<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>金币冒险者 - 完整版</title>
    <style>
        /* 样式保持不变 */
        body { font-family: Arial, sans-serif; padding: 20pxf; background-color: #ffffff; }
        button { padding: 10px; margin: 5px; cursor: pointer; }
        #equipmentList, #itemList, #collectionList, #reincarnationList, #petList, #stockList, #lotteryList, #bankList, #dungeonEquipmentList, #soulRingList { margin-top: 20px; max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; }
        .log { color: #666; font-size: 0.9em; }
        .common { color: #666; border-left: 4px solid #666; padding: 2px 5px; }
        .rare { color: blue; border-left: 4px solid blue; }
        .epic { color: purple; border-left: 4px solid purple; }
        .legendary { color: orange; border-left: 4px solid orange; }
        .ancient { color: brown; border-left: 4px solid brown; }
        .divine { color: gold; border-left: 4px solid gold; }
        .arcane { color: deepskyblue; border-left: 4px solid deepskyblue; }
        .celestial { color: lightblue; border-left: 4px solid lightblue; }
        .infernal { color: darkred; border-left: 4px solid darkred; }
        .astral { color: violet; border-left: 4px solid violet; }
        .primeval { color: darkgreen; border-left: 4px solid darkgreen; }
        .transcendental { color: fuchsia; border-left: 4px solid fuchsia; }
        .quantum { color: aqua; border-left: 4px solid aqua; }
        .ultimate { color: orange; border-left: 4px solid orange; }
        .chaos { color: #FF4500; border-left: 4px solid #FF4500; }
       .eternal { color: #00CED1; border-left: 4px solid #00CED1; }
         .void { color: #8A2BE2; border-left: 4px solid #8A2BE2; }
        .genesis { color: #FFD700; border-left: 4px solid #FFD700; }
         .divineRealm { color: #FF69B4; border-left: 4px solid #FF69B4; }
         .apocalypse { color: #000000; border-left: 4px solid #000000; }
       .yeyu1 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu2 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu3 { color: #FF4530; border-left: 4px solid #FF4530; }
        .yeyu4 { color: #4B0082; border-left: 4px solid #4B0082; }
         .yeyu5 { color: #FFD770; border-left: 4px solid #FFD770; }
         .yeyu6 { color: #8B0000; border-left: 4px solid #8B0000; }
       .yeyu7 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu8 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu9 { color: #FF4530; border-left: 4px solid #FF4530; }
        .yeyu10 { color: #4B0082; border-left: 4px solid #4B0082; }
         .yeyu11 { color: #FFD770; border-left: 4px solid #FFD770; }
         .yeyu12 { color: #8B0000; border-left: 4px solid #8B0000; }
       .yeyu13 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu14 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu15 { color: #FF4530; border-left: 4px solid #FF4530; }
      .yeyu16 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu17 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu18 { color: #FF4530; border-left: 4px solid #FF4530; }
        .yeyu19 { color: #4B0082; border-left: 4px solid #4B0082; }
         .yeyu20 { color: #FFD770; border-left: 4px solid #FFD770; }
         .yeyu21 { color: #8B0000; border-left: 4px solid #8B0000; }
       .yeyu22 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu23 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu24 { color: #FF4530; border-left: 4px solid #FF4530; }
   .ultimate2 { color: #00CED1; border-left: 4px solid #00CED1; }
.ultimate3 { color: #8A2BE2; border-left: 4px solid #8A2BE2; } 
.ultimate4 { color: #FFD700; border-left: 4px solid #FFD700; } 
.ultimate5 { color: #FF69B4; border-left: 4px solid #FF69B4; }
.ultimate6 { color: #000000; border-left: 4px solid #000000; }
.ultimate7 { color: #00FF00; border-left: 4px solid #00FF00; } 
.ultimate8 { color: #FF0000; border-left: 4px solid #FF0000; } 
.ultimate9 { color: #0000FF; border-left: 4px solid #0000FF; }
.ultimate10 { color: #800080; border-left: 4px solid #800080; } 
.ultimate11 { color: #FFA500; border-left: 4px solid #FFA500; } 
.ultimate12 { color: #008080; border-left: 4px solid #008080; } 
.ultimate13 { color: #4B0082; border-left: 4px solid #4B0082; } 
.ultimate14 { color: #FF6347; border-left: 4px solid #FF6347; } 
.ultimate15 { color: #7CFC00; border-left: 4px solid #7CFC00; } 
.ultimate16 { color: #DC143C; border-left: 4px solid #DC143C; } 
.ultimate17 { color: #00FFFF; border-left: 4px solid #00FFFF; } 
.ultimate18 { color: #FF00FF; border-left: 4px solid #FF00FF; } 
.ultimate19 { color: #FFFF00; border-left: 4px solid #FFFF00; }
.ultimate20 { color: #8B0000; border-left: 4px solid #8B0000; } 
.ultimate21 { color: #800000; border-left: 4px solid #800000; } 
.ultimate22 { color: #FFDAB9; border-left: 4px solid #FFDAB9; }
.ultimate23 { color: #000080; border-left: 4px solid #000080; } 
.ultimate24 { color: #FF1493; border-left: 4px solid #FF1493; } 
.ultimate25 { color: #00BFFF; border-left: 4px solid #00BFFF; }
.ultimate26 { color: #FF4500; border-left: 4px solid #FF4500; } 
.ultimate27 { color: #00CED1; border-left: 4px solid #00CED1; }
.ultimate28 { color: #8A2BE2; border-left: 4px solid #8A2BE2; } 
.ultimate29 { color: #FFD700; border-left: 4px solid #FFD700; }
.ultimate30 { color: #FF69B4; border-left: 4px solid #FF69B4; }
.ultimate31 { color: #000000; border-left: 4px solid #000000; }
.ultimate32 { color: #00FF00; border-left: 4px solid #00FF00; }
.ultimate33 { color: #FF0000; border-left: 4px solid #FF0000; } 
.ultimate34 { color: #0000FF; border-left: 4px solid #0000FF; } 
.ultimate35 { color: #800080; border-left: 4px solid #800080; } 
.ultimate36 { color: #FFA500; border-left: 4px solid #FFA500; } 
.ultimate37 { color: #008080; border-left: 4px solid #008080; }
.ultimate38 { color: #4B0082; border-left: 4px solid #4B0082; } 
.ultimate39 { color: #FF6347; border-left: 4px solid #FF6347; } 
.ultimate40 { color: #7CFC00; border-left: 4px solid #7CFC00; } 
.ultimate41 { color: #DC143C; border-left: 4px solid #DC143C; } 
.ultimate42 { color: #00FFFF; border-left: 4px solid #00FFFF; } 
.ultimate43 { color: #FF00FF; border-left: 4px solid #FF00FF; }
.ultimate44 { color: #FFFF00; border-left: 4px solid #FFFF00; }
.ultimate45 { color: #8B0000; border-left: 4px solid #8B0000; } 
.ultimate46 { color: #800000; border-left: 4px solid #800000; } 
.ultimate47 { color: #FFDAB9; border-left: 4px solid #FFDAB9; }
.ultimate48 { color: #000080; border-left: 4px solid #000080; }
.ultimate49 { color: #FF1493; border-left: 4px solid #FF1493; }
.ultimate50 { color: #00BFFF; border-left: 4px solid #00BFFF; }
          .equipment { position: relative; padding: 5px; margin: 3px 0; }
        .tooltip { 
            display: none;
            position: absolute;
            left: 65%;
            top: 0;
            background: white;
            border: 5px solid #ddd;
            padding: 5px;
            min-width: 200px;
            z-index: 0;
            transform: scale(0.5);
            margin-top: -90px;
        }
        .equipment:hover .tooltip { display: block; }
        @keyframes shake {
            -50%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .error { animation: shake 0.3s; color: red; }
        #actionLog {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }
        .offline-reward {
            color: #2ecc71;
            font-weight: bold;
            animation: fadeOut 1.5s ease-out 2s forwards;
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .success { color: #27ae60; }
        .info { color: #2980b9; }
        .auto-buy-container {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .auto-buy-btn { background-color: #e0e0e0; }
        .achievement { margin: 5px 0; padding: 5px; border: 1px solid #ddd; border-radius: 5px; }
        .achievement.unlocked { background-color: #e0f7fa; }
        .tab { cursor: pointer; padding: 10px; border: 1px solid #ccc; display: inline-block; margin-right: 5px; }
        .tab.active { background-color: #ccc; }

        /* 新增样式：装备品质面板缩小 200% */
        #equipmentList {
    transform: scale(1);
    transform-origin: top left;
    width: 100%;
    /* 新增以下样式 */
    max-height: 29.6vh; /* 限制最大高度为屏幕高度的20%，可根据需求调整 */
    overflow-y: auto; /* 允许垂直滚动 */
    -webkit-overflow-scrolling: touch; /* 启用移动端平滑滚动特性 */
    overscroll-behavior-y: contain; /* 阻止滚动到底部时的全局回弹 */
}

        /* 新增样式：游戏日志分页 */
        .log-tab { cursor: pointer; padding: 10px; border: 1px solid #ccc; display: inline-block; margin-right: 5px; }
        .log-tab.active { background-color: #ccc; }
        #gameLogPage1, #gameLogPage2, #gameLogPage3, #gameLogPage4 { display: none; }
        #gameLogPage1.active, #gameLogPage2.active, #gameLogPage3.active, #gameLogPage4.active { display: block; }

        /* 自定义对话框样式 */
        #customDialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            z-index: 1000;
            text-align: center;
        }
        #dialogOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        #dialogConfirm, #dialogCancel {
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
        }

        /* 新增股票样式 */
        #stocksContainer { margin-top: 20px; }
        .stock-item { 
            padding: 10px; 
            border: 1px solid #ddd; 
            margin: 5px 0; 
            cursor: pointer; 
        }
        .stock-item.selected { background-color: #e3f2fd; }
        .stock-control { margin-top: 20px; }
        .stock-control input { 
            padding: 5px;
            width: 120px;
            margin-right: 10px;
        }

        /* 新增彩票样式 */
        #lotteryResults, #traditionalLotteryNumbers {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }

        /* 新增银行系统样式 */
        #bankList {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }

        /* 新增打怪模式样式 */
        #monsterUI {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f9f9f9;
            border: 1px solid #ccc;
            padding: 10px;
            width: 300px;
            z-index: 1000;
        }
        #monsterUI h3 { margin-top: 0; }
        #monsterUI .monster-info { margin-bottom: 10px; }
        #monsterUI .player-info { margin-bottom: 10px; }
        #monsterUI .battle-log { max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; }

        /* 新增魂环样式 */
        #soulRingsContainer .equipment {
            padding: 8px;
            margin: 5px;
            border: 1px solid gold;
            border-radius: 4px;
        }
         /* 功法秘笈样式 */
.technique {
    padding: 10px;
    margin: 5px;
    border: 1px solid #8B4513; /* 棕色边框 */
    border-radius: 4px;
    background-color: #FFF8DC; /* 浅黄色背景 */
} 
#worldBossUI {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px; /* 从800px缩小到600px */
            max-width: 90%;
            max-height: 80vh; /* 限制最大高度 */
            background: #1a1a1a;
            border: 2px solid #d4af37;
            box-shadow: 0 0 15px #d4af37;
            padding: 15px; /* 减少内边距 */
            z-index: 1001;
            display: none;
            color: #fff;
            border-radius: 8px; /* 稍微减小圆角 */
            overflow-y: auto; /* 添加滚动条 */
        }
        
        #worldBossUI h3 {
            color: #d4af37;
            text-align: center;
            margin-top: 0;
            font-size: 20px; /* 减小字号 */
            text-shadow: 0 0 5px #d4af37;
            margin-bottom: 10px; /* 减小下边距 */
        }
        
        .boss-section {
            margin-bottom: 15px; /* 减小间距 */
            padding: 10px; /* 减小内边距 */
            background: #2a2a2a;
            border-radius: 6px;
            border: 1px solid #444;
        }
        
        .boss-section-title {
            color: #d4af37;
            font-weight: bold;
            margin-bottom: 8px; /* 减小下边距 */
            font-size: 16px; /* 减小字号 */
        }
        
        .boss-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px; /* 减小下边距 */
            font-size: 14px; /* 减小字号 */
        }
        
        .boss-name {
            font-size: 18px; /* 从22px减小 */
            color: #d4af37;
            text-align: center;
            margin: 8px 0; /* 减小边距 */
            text-shadow: 0 0 5px #d4af37;
        }
        
        .boss-world {
            font-size: 14px; /* 从16px减小 */
            color: #aaa;
            text-align: center;
            margin-bottom: 10px; /* 减小下边距 */
            font-style: italic;
        }
        
        .boss-stars {
            text-align: center;
            font-size: 16px; /* 从20px减小 */
            color: gold;
            margin-bottom: 10px; /* 减小下边距 */
        }
        
        .boss-health-bar {
            height: 20px; /* 从30px减小 */
            background: #333;
            border-radius: 10px;
            margin-bottom: 10px; /* 减小下边距 */
            overflow: hidden;
            position: relative;
        }
        
        .boss-health-fill {
            height: 100%;
            background: linear-gradient(to right, #d4af37, #f1e5ac);
            width: 100%;
            transition: width 0.3s;
        }
        
        .boss-health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            line-height: 20px; /* 与health-bar高度匹配 */
            color: #000;
            font-weight: bold;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-time-left {
            text-align: center;
            font-size: 14px; /* 从18px减小 */
            margin-bottom: 10px; /* 减小下边距 */
            color: #d4af37;
        }
        
        .boss-button {
            background: linear-gradient(to bottom, #d4af37, #a67c00);
            border: none;
            color: #000;
            padding: 6px 12px; /* 减小内边距 */
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin: 3px; /* 减小外边距 */
            transition: all 0.3s;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-button:hover {
            background: linear-gradient(to bottom, #f1e5ac, #d4af37);
            box-shadow: 0 0 8px #d4af37; /* 减小阴影 */
        }
        
        .boss-button:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }
        
        .boss-rankings {
            max-height: 120px; /* 从200px减小 */
            overflow-y: auto;
            border: 1px solid #444;
            padding: 6px; /* 减小内边距 */
            border-radius: 4px;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0; /* 减小内边距 */
            border-bottom: 1px solid #444;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-battle-log {
            max-height: 100px; /* 从150px减小 */
            overflow-y: auto;
            border: 1px solid #444;
            padding: 6px; /* 减小内边距 */
            border-radius: 4px;
            font-size: 11px; /* 减小字号 */
        }
        
        .boss-battle-log-entry {
            margin-bottom: 3px; /* 减小下边距 */
            padding-bottom: 3px; /* 减小内边距 */
            border-bottom: 1px dotted #444;
        }
        
        .boss-rewards {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        
        .boss-reward-tier {
            background: #333;
            padding: 6px; /* 减小内边距 */
            border-radius: 4px;
            margin: 3px; /* 减小外边距 */
            text-align: center;
            width: 45%; /* 调整宽度使两列显示 */
            min-width: 120px;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-reward-tier h4 {
            color: #d4af37;
            margin-top: 0;
            font-size: 13px; /* 减小字号 */
        }
        
        .boss-close-button {
            position: absolute;
            top: 5px; /* 减小位置 */
            right: 5px;
            background: none;
            border: none;
            color: #d4af37;
            font-size: 16px; /* 从20px减小 */
            cursor: pointer;
            padding: 2px;
        }
        
        .boss-summon-count {
            position: absolute;
            top: 5px; /* 减小位置 */
            left: 5px;
            color: #d4af37;
            font-weight: bold;
            font-size: 12px; /* 减小字号 */
        }
  .player-name {
  margin: 10px 0;
  padding: 8px 15px;
  font-size: 18px;
  font-weight: bold;
  position: relative;
  display: inline-block;
  background: linear-gradient(90deg, #fff, #f8f9fa, #fff);
  background-size: 200% 100%;
  border-radius: 6px;
  overflow: hidden;
}

.player-name::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    rgba(52, 152, 219, 0) 0%,
    rgba(52, 152, 219, 0.1) 50%,
    rgba(52, 152, 219, 0) 100%);
  animation: shine 3s infinite;
}

#playerName {
  background: linear-gradient(90deg, #3498db, #9b59b6, #e74c3c);
  background-size: 200% 200%;
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  animation: gradientShift 5s ease infinite;
  padding: 0 5px;
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@keyframes shine {
  100% { left: 100%; }
}

.player-name:hover #playerName {
  animation: gradientShift 2s ease infinite, bounce 0.5s ease;
}

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
}

.titleBranch {
    margin: 20px 0;
    padding: 10px;
    border: 1px solid #ddd;
}

.titleRow {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
}

.titleItem {
    padding: 8px 12px;
    background: #f0f0f0;
    border-radius: 4px;
    cursor: pointer;
    width: calc(20% - 10px); /* 每排5个 */
    text-align: center;
    box-sizing: border-box;
}

.titleItem.unlocked {
    background: #4CAF50;
    color: white;
}

.titleItem.selected {
    border: 2px solid #ffd700;
    font-weight: bold;
}
/* 通天塔界面缩小样式 */
#towerUI {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 500px; /* 缩小宽度 */
    max-width: 90%; /* 响应式最大宽度 */
    max-height: 70vh; /* 限制最大高度为屏幕的70% */
    background: #f9f9f9;
    border: 1px solid #ccc;
    padding: 15px; /* 减少内边距 */
    z-index: 1001;
    display: none; /* 默认隐藏 */
    overflow-y: auto; /* 内容过多时显示滚动条 */
    border-radius: 6px;
}

#towerUI h3 {
    font-size: 18px; /* 缩小标题字体 */
    margin: 10px 0;
    text-align: center;
}

#towerUI .floor-info {
    font-size: 14px; /* 缩小信息字体 */
    margin: 8px 0;
    padding: 8px;
    background: #f0f0f0;
    border-radius: 4px;
}

#towerUI button {
    padding: 6px 12px; /* 缩小按钮 */
    font-size: 12px;
    margin: 4px;
}

#towerUI .tower-log {
    max-height: 150px; /* 缩小日志区域 */
    overflow-y: auto;
    font-size: 12px;
    padding: 8px;
    margin-top: 10px;
    border: 1px solid #ddd;
}
#customDialog {
    z-index: 2000 !important; /* 确保高于其他元素 */
}

#dialogOverlay {
    z-index: 1999 !important;
}
.farm-field:hover {
    background-color: #3a3a3a !important;
    transition: background-color 0.3s;
}

.seed-item:hover {
    background-color: #3a3a3a !important;
    border-color: #4CAF50 !important;
    transition: all 0.3s;
}



button:hover {
    background: #666;
}
/* 星域探索系统样式 */
#explorationSystemUI {
    font-family: 'Arial', sans-serif;
}

.attribute-card {
    background: #2a2a4a;
    border-radius: 8px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.3s;
}

.attribute-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(74, 134, 232, 0.3);
}

.attribute-icon {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    margin-bottom: 10px;
}

.attribute-info {
    text-align: center;
    margin-bottom: 10px;
}

.upgrade-btn {
    background: linear-gradient(to bottom, #4a86e8, #1c5bb8);
    color: white;
    border: none;
    padding: 5px 15px;
    border-radius: 15px;
    cursor: pointer;
    width: 100%;
    transition: all 0.3s;
}

.upgrade-btn:hover {
    background: linear-gradient(to bottom, #5a96f8, #2c6bc8);
    transform: scale(1.05);
}

.mission-card {
    background: #2a2a4a;
    border-radius: 8px;
    padding: 15px;
    transition: all 0.3s;
}

.mission-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(74, 134, 232, 0.3);
}

.mission-card[data-difficulty="easy"] {
    border-left: 4px solid #00cc66;
}

.mission-card[data-difficulty="medium"] {
    border-left: 4px solid #4a86e8;
}

.mission-card[data-difficulty="hard"] {
    border-left: 4px solid #ff9900;
}

.mission-card[data-difficulty="extreme"] {
    border-left: 4px solid #ff3333;
}

.mission-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.difficulty-tag {
    background: #4a86e8;
    color: white;
    padding: 3px 10px;
    border-radius: 15px;
    font-size: 12px;
}

.mission-info {
    margin-bottom: 15px;
    font-size: 14px;
}

.start-mission-btn {
    background: linear-gradient(to bottom, #4a86e8, #1c5bb8);
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    width: 100%;
    transition: all 0.3s;
}

.start-mission-btn:hover {
    background: linear-gradient(to bottom, #5a96f8, #2c6bc8);
    transform: scale(1.05);
}

.resource-card {
    background: #2a2a4a;
    border-radius: 8px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.3s;
}

.resource-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(74, 134, 232, 0.3);
}

.resource-icon {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    margin-bottom: 10px;
}

.resource-info {
    text-align: center;
}

.log-entry {
    padding: 8px;
    margin-bottom: 5px;
    background: #2a2a4a;
    border-radius: 5px;
    font-size: 14px;
}

.log-entry:nth-child(odd) {
    background: #33335a;
}
.upgrade-btn:disabled {
    background: #666 !important;
    cursor: not-allowed;
    opacity: 0.7;
}
 .exchange-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
    }
    
    .exchange-info {
        flex: 1;
    }
    
    .exchange-controls {
        display: flex;
        gap: 10px;
    }
 .gem-shop-item {
        background: #2a2a2a;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
    }
    
    .gem-icon {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        font-weight: bold;
        margin: 0 auto 10px;
    }
    
    .gem-icon.red { background: linear-gradient(to bottom, #ff4d4d, #cc0000); }
    .gem-icon.blue { background: linear-gradient(to bottom, #4da6ff, #0066cc); }
    .gem-icon.black { background: linear-gradient(to bottom, #666666, #000000); }
    .gem-icon.green { background: linear-gradient(to bottom, #66ff66, #00cc00); }
    .gem-icon.pink { background: linear-gradient(to bottom, #ff66cc, #cc0099); }
    .gem-icon.yellow { background: linear-gradient(to bottom, #ffff66, #cccc00); }
    
    .gem-item {
        background: #2a2a2a;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        position: relative;
    }
    
    .gem-level {
        position: absolute;
        top: 5px;
        right: 5px;
        background: #d4af37;
        color: black;
        border-radius: 50%;
        width: 25px;
        height: 25px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
    }
.progress-bar {
    width: 100%;
    height: 20px;
    background-color: #333;
    border-radius: 10px;
    overflow: hidden;
    margin-top: 5px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(to right, #9C27B0, #E91E63);
    border-radius: 10px;
    transition: width 0.5s ease;
}

.tablink.active {
    background: #9C27B0 !important;
    font-weight: bold;
}
/* 添加弹幕动画效果 */
@keyframes danmakuMove {
    from {
        transform: translateX(100%);
    }
    to {
        transform: translateX(-100%);
    }
}

.danmaku {
    animation: danmakuMove linear forwards;
   pointer-events: none;
}
/* 添加一些动画效果 */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

#giftBoxBtn {
    animation: pulse 2s infinite;
    transition: all 0.3s;
}

#giftBoxBtn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(255, 94, 98, 0.5);
}

#boxInner {
    cursor: pointer;
    transition: transform 1s;
}

#giftBoxModal div {
    color: #ffffff;
}
 
    .exchange-btn {
        background: linear-gradient(to bottom, #4CAF50, #2E7D32);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
    }
    
    .exchange-btn:hover {
        background: linear-gradient(to bottom, #66BB6A, #388E3C);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .exchange-btn:active {
        transform: translateY(0);
    }
    
    .exchange-item {
        transition: all 0.3s;
    }
    
    .exchange-item:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    .gem-icon {
        box-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
    }
.artifact-tab {
    cursor: pointer;
    padding: 8px 15px;
    background: #333;
    border: 1px solid #d4af37;
    border-radius: 5px;
    color: #d4af37;
    font-weight: bold;
}

.artifact-tab.active {
    background: #d4af37;
    color: black;
}

.set-group {
    margin-bottom: 15px;
    border: 1px solid #444;
    border-radius: 5px;
    overflow: hidden;
}

.set-header {
    background: linear-gradient(to right, #2c2c2c, #1a1a1a);
    padding: 12px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #444;
}

.set-header:hover {
    background: linear-gradient(to right, #3c3c3c, #2a2a2a);
}

.set-name {
    font-weight: bold;
    color: #d4af37;
    font-size: 1.1em;
}

.set-count {
    background: #d4af37;
    color: black;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.9em;
}

.set-content {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    padding: 10px;
    background: #222;
}

.set-collapsed .set-content {
    display: none;
}

.folder-arrow {
    transition: transform 0.3s;
}

.set-collapsed .folder-arrow {
    transform: rotate(-90deg);
}
    .lottery-countdown {
            font-size: 14px;
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0;
            padding: 5px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
.dimension-selector {
            margin: 15px 0;
            padding: 10px;
            background: #2c3e50;
            border-radius: 8px;
            color: white;
        }
        .dimension-btn {
            padding: 8px 15px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #34495e;
            color: #ecf0f1;
            transition: all 0.3s;
        }
        .dimension-btn.active {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }
        .dimension-btn:hover:not(.active) {
            background: #4a6572;
        }
        .dimension-info {
            margin-top: 10px;
            font-size: 14px;
            line-height: 1.5;
        }
   /* 新增页脚样式 */
        #footer {
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: #666;
            font-size: 14px;
            z-index: 1000;
            pointer-events: none; /* 防止干扰交互 */
        }
  .currency:has(span:empty) {
    display: none;
}
.tab-container {
    display: flex;
    margin-bottom: 15px;
    border-bottom: 2px solid #444;
}

.tab-btn {
    background: #333;
    color: white;
    border: none;
    padding: 10px 20px;
    cursor: pointer;
    margin-right: 5px;
    border-radius: 5px 5px 0 0;
}

.tab-btn.active {
    background: #FFD700;
    color: black;
    font-weight: bold;
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.good-item, .inventory-item {
    transition: all 0.3s ease;
    border-radius: 3px;
}

.good-item:hover, .inventory-item:hover {
    background-color: #2a2a2a;
    transform: translateY(-1px);
}
.inventory-item {
    border-left: 3px solid transparent;
}

.inventory-item:hover {
    border-left-color: #FFD700;
}

.profit-positive {
    color: #4CAF50;
    font-weight: bold;
}

.profit-negative {
    color: #f44336;
    font-weight: bold;
}

.profit-neutral {
    color: #FFC107;
}

.price-trend-up {
    color: #4CAF50;
    animation: pulseGreen 2s infinite;
}

.price-trend-down {
    color: #f44336;
    animation: pulseRed 2s infinite;
}

@keyframes pulseGreen {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

@keyframes pulseRed {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.region {
    background: #2a2a2a;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 10px;
}

.city {
    padding: 5px;
    margin: 3px 0;
    background: #333;
    border-radius: 3px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.city:hover {
    background: #444;
}


button:hover:not(:disabled) {
    background: #45a049;
}

button:disabled {
    background: #666;
    cursor: not-allowed;
}

#tradingSystemUI {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    border: 2px solid #FFD700;
}

#tradingSystemUI h2, #tradingSystemUI h3, #tradingSystemUI h4 {
    color: #FFD700;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}
#inventorySummaryModal table th {
    background: #333;
    position: sticky;
    top: 0;
}

#inventorySummaryModal table tr:hover {
    background-color: #2a2a2a;
}

#inventorySummaryModal table td, #inventorySummaryModal table th {
    border: 1px solid #444;
}

.inventory-high-profit {
    background: rgba(76, 175, 80, 0.1);
}

.inventory-low-profit {
    background: rgba(244, 67, 54, 0.1);
}

.sortable-header {
    cursor: pointer;
    user-select: none;
}

.sortable-header:hover {
    background-color: #444;
}

.export-btn {
    background: linear-gradient(45deg, #4CAF50, #45a049);
    transition: all 0.3s ease;
}

.export-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.sort-btn {
    background: linear-gradient(45deg, #2196F3, #0b7dda);
    transition: all 0.3s ease;
}

.sort-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}
.region {
    transition: transform 0.3s ease;
}

.region:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.city-button {
    transition: all 0.3s ease;
}

.city-button:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.city-button:disabled {
    opacity: 0.6;
}

#travelInfo {
    border: 1px solid #555;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#travelProgressBar {
    transition: width 0.5s ease-in-out;
}
.auto-trade-status {
    background: #333;
    padding: 15px;
    border-radius: 5px;
    margin-top: 15px;
}

.auto-trade-status h4 {
    color: #FFD700;
    margin-top: 0;
    border-bottom: 1px solid #444;
    padding-bottom: 5px;
}

.auto-trade-progress {
    margin-top: 10px;
}

.route-item {
    background: #2a2a2a;
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
    border-left: 3px solid #4CAF50;
}

.route-item h5 {
    margin: 0;
    color: #FFD700;
}

.route-details {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-top: 5px;
    font-size: 0.9em;
}

.route-details div {
    padding: 3px 0;
}

.auto-trade-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.auto-trade-controls button {
    flex: 1;
    padding: 5px 10px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.auto-trade-controls button:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.auto-trade-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 10px;
}

.stat-item {
    background: #2a2a2a;
    padding: 8px;
    border-radius: 3px;
    text-align: center;
}

.stat-value {
    font-size: 1.2em;
    font-weight: bold;
    color: #FFD700;
}

.stat-label {
    font-size: 0.8em;
    color: #aaa;
}

.auto-trade-route {
    border: 1px solid #444;
    border-radius: 5px;
    padding: 10px;
    margin: 10px 0;
    background: #2a2a2a;
}

.auto-trade-route.active {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.1);
}

.route-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
}

.route-details {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
    font-size: 0.9em;
}

.route-action {
    margin-top: 5px;
    text-align: right;
}
.log-entry {
    transition: all 0.3s ease;
}

.log-entry:hover {
    background: #333 !important;
    transform: translateX(5px);
}

#logSearch:focus, #logFilter:focus {
    outline: none;
    border-color: #FFD700;
}

#autoTradeLogContainer {
    scrollbar-width: thin;
    scrollbar-color: #444 #222;
}

#autoTradeLogContainer::-webkit-scrollbar {
    width: 8px;
}

#autoTradeLogContainer::-webkit-scrollbar-track {
    background: #222;
}

#autoTradeLogContainer::-webkit-scrollbar-thumb {
    background: #444;
    border-radius: 4px;
}

#autoTradeLogContainer::-webkit-scrollbar-thumb:hover {
    background: #555;
}

.auto-trade-progress {
    margin-bottom: 15px;
    padding: 10px;
    background: #2a2a2a;
    border-radius: 5px;
    border-left: 4px solid #FFD700;
}

.progress-label {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-weight: bold;
}

.progress-bar {
    width: 100%;
    height: 15px;
    background: #333;
    border-radius: 7px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    border-radius: 7px;
    transition: width 0.5s;
}

.good-selection-item {
    transition: all 0.3s ease;
    cursor: pointer;
}

.good-selection-item:hover {
    border-color: #FFD700 !important;
    transform: translateY(-2px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.good-selection-item input[type="checkbox"] {
    accent-color: #4CAF50;
}

.auto-trade-route {
    transition: all 0.3s ease;
}

.auto-trade-route:hover {
    border-color: #FFD700 !important;
}

.auto-trade-route.active {
    border-color: #4CAF50 !important;
    background: rgba(76, 175, 80, 0.1) !important;
}

#goodsSelection input[type="number"] {
    background: #333;
    color: white;
    border: 1px solid #555;
    border-radius: 3px;
    padding: 5px;
}

#goodsSelection input[type="number"]:focus {
    outline: none;
    border-color: #FFD700;
}
.auto-trade-progress {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 15px;
    border-left: 4px solid #FFD700;
}

.progress-label {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-weight: bold;
}

.progress-label span:first-child {
    color: #FFD700;
}

.progress-label span:last-child {
    color: #4CAF50;
}

.progress-bar {
    width: 100%;
    height: 12px;
    background: #333;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    border-radius: 6px;
    transition: width 0.3s ease;
    position: relative;
    overflow: hidden;
}

.progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% {
        left: -100%;
    }
    100% {
        left: 100%;
    }
}

.real-time-indicator {
    position: absolute;
    right: 0;
    top: 0;
    background: rgba(0,0,0,0.5);
    color: white;
    padding: 2px 5px;
    font-size: 0.7em;
    border-radius: 0 0 0 3px;
}

.auto-trade-status {
    transition: all 0.3s ease;
}

.auto-trade-status:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}
.background-indicator {
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.background-trade-notice {
    background: linear-gradient(90deg, #2a2a2a, #333);
    border-left: 4px solid #4CAF50;
}

.background-trade-notice h4 {
    color: #4CAF50;
    margin-top: 0;
}

.background-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.background-controls button {
    flex: 1;
    padding: 8px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.background-controls button:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
button:disabled {
    opacity: 0.6;
    cursor: not-allowed !important;
}

.disabled-tooltip {
    position: relative;
}

.disabled-tooltip::after {
    content: "自动贸易已启用，无法手动操作";
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 5px;
    background: #333;
    color: white;
    border-radius: 3px;
    font-size: 0.8em;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}

.disabled-tooltip:hover::after {
    opacity: 1;
    visibility: visible;
}

.auto-trade-notice {
    background: linear-gradient(90deg, #2a2a2a, #333);
    border-left: 4px solid #FF9800;
    animation: pulseNotice 2s infinite;
}

@keyframes pulseNotice {
    0% { opacity: 1; }
    50% { opacity: 0.8; }
    100% { opacity: 1; }
}
.good-selection-item {
    transition: all 0.3s ease;
    cursor: pointer;
}

.good-selection-item:hover {
    border-color: #FFD700 !important;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.auto-trade-route {
    transition: all 0.3s ease;
}

.auto-trade-route:hover {
    border-color: #FFD700 !important;
    transform: translateY(-1px);
}

.auto-trade-route.active {
    border-color: #4CAF50 !important;
    background: rgba(76, 175, 80, 0.1) !important;
}

.flexible-trade-status {
    background: linear-gradient(135deg, #2a2a2a, #333);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    border-left: 4px solid #FFD700;
}

.status-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 8px;
}

.status-indicator.idle {
    background: #FF9800;
    animation: pulse 2s infinite;
}

.status-indicator.buying {
    background: #4CAF50;
}

.status-indicator.selling {
    background: #2196F3;
}

.status-indicator.traveling {
    background: #9C27B0;
    animation: pulse 1.5s infinite;
}

.status-indicator.monitoring {
    background: #FFC107;
    animation: pulse 3s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.city-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    margin-top: 10px;
}

.city-stat-item {
    background: rgba(255,255,255,0.05);
    padding: 8px;
    border-radius: 4px;
    text-align: center;
}

.city-stat-value {
    font-size: 1.2em;
    font-weight: bold;
    color: #FFD700;
}

.city-stat-label {
    font-size: 0.8em;
    color: #aaa;
}

.trade-opportunity {
    background: linear-gradient(90deg, rgba(76,175,80,0.1), transparent);
    border-left: 3px solid #4CAF50;
    padding: 10px;
    margin: 5px 0;
    border-radius: 4px;
}

.trade-opportunity.warning {
    background: linear-gradient(90deg, rgba(255,152,0,0.1), transparent);
    border-left-color: #FF9800;
}

.trade-opportunity.info {
    background: linear-gradient(90deg, rgba(33,150,243,0.1), transparent);
    border-left-color: #2196F3;
}

.progress-container {
    margin: 15px 0;
}

.progress-bar-flexible {
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
    position: relative;
}

.progress-fill-flexible {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    border-radius: 4px;
    transition: width 0.5s ease;
}

.progress-fill-flexible::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 2s infinite;
}

.control-panel {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 10px;
    margin-top: 15px;
}

.control-btn {
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    transition: all 0.3s ease;
    text-align: center;
}

.control-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.control-btn.primary {
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
}

.control-btn.secondary {
    background: linear-gradient(135deg, #2196F3, #0b7dda);
    color: white;
}

.control-btn.warning {
    background: linear-gradient(135deg, #FF9800, #f57c00);
    color: white;
}

.control-btn.danger {
    background: linear-gradient(135deg, #f44336, #d32f2f);
    color: white;
}

.control-btn:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.price-monitor {
    background: #2a2a2a;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
}

.price-change {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.8em;
    font-weight: bold;
}

.price-change.positive {
    background: rgba(76,175,80,0.2);
    color: #4CAF50;
}

.price-change.negative {
    background: rgba(244,67,54,0.2);
    color: #f44336;
}

.price-change.neutral {
    background: rgba(255,193,7,0.2);
    color: #FFC107;
}

.trade-log-entry {
    border-left: 3px solid;
    padding: 8px 12px;
    margin: 5px 0;
    background: rgba(255,255,255,0.02);
    border-radius: 0 4px 4px 0;
}

.trade-log-entry.success {
    border-left-color: #4CAF50;
}

.trade-log-entry.info {
    border-left-color: #2196F3;
}

.trade-log-entry.warning {
    border-left-color: #FF9800;
}

.trade-log-entry.error {
    border-left-color: #f44336;
}

.opportunity-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.7em;
    font-weight: bold;
    margin-left: 8px;
}

.opportunity-badge.buy {
    background: rgba(76,175,80,0.2);
    color: #4CAF50;
}

.opportunity-badge.sell {
    background: rgba(33,150,243,0.2);
    color: #2196F3;
}

.opportunity-badge.travel {
    background: rgba(156,39,176,0.2);
    color: #9C27B0;
}

.flexible-settings {
    background: #2a2a2a;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
}

.setting-group {
    margin-bottom: 15px;
}

.setting-label {
    display: block;
    margin-bottom: 5px;
    color: #FFD700;
    font-weight: bold;
}

.setting-input {
    width: 100%;
    padding: 8px;
    background: #333;
    border: 1px solid #444;
    border-radius: 4px;
    color: white;
}

.setting-input:focus {
    outline: none;
    border-color: #FFD700;
}

.setting-description {
    font-size: 0.8em;
    color: #aaa;
    margin-top: 5px;
}

@media (max-width: 768px) {
    .city-stats {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .control-panel {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .flexible-trade-status {
        padding: 10px;
    }
}

.loading-spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid #333;
    border-top: 2px solid #FFD700;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 8px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.auto-trade-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: #2a2a2a;
    border-left: 4px solid #FFD700;
    padding: 15px;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 1000;
    max-width: 300px;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.notification-close {
    position: absolute;
    top: 5px;
    right: 10px;
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.2em;
}

.notification-close:hover {
    color: white;
}

.trade-summary {
    background: linear-gradient(135deg, #2a2a2a, #333);
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
}

.summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.summary-item {
    text-align: center;
}

.summary-value {
    font-size: 1.5em;
    font-weight: bold;
    color: #FFD700;
    margin-bottom: 5px;
}

.summary-label {
    font-size: 0.9em;
    color: #aaa;
}

.profit-positive {
    color: #4CAF50;
}

.profit-negative {
    color: #f44336;
}

.efficiency-high {
    color: #4CAF50;
}

.efficiency-medium {
    color: #FFC107;
}

.efficiency-low {
    color: #f44336;
}
.control-btn {
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    transition: all 0.3s ease;
    text-align: center;
}

.control-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.control-btn.primary {
    background: linear-gradient(135deg, #2196F3, #0b7dda);
    color: white;
}

.control-btn.secondary {
    background: linear-gradient(135deg, #9C27B0, #7b1fa2);
    color: white;
}

.control-btn.success {
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
}

.control-btn.info {
    background: linear-gradient(135deg, #00BCD4, #0097a7);
    color: white;
}

.control-btn.warning {
    background: linear-gradient(135deg, #FF9800, #f57c00);
    color: white;
}

.control-btn.danger {
    background: linear-gradient(135deg, #f44336, #d32f2f);
    color: white;
}

.control-btn.default {
    background: linear-gradient(135deg, #607D8B, #455a64);
    color: white;
}

.control-btn:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}
.intelligence-modal {
    animation: modalAppear 0.3s ease;
}

@keyframes modalAppear {
    from {
        transform: scale(0.9);
        opacity: 0;
    }
    to {
        transform: scale(1);
        opacity: 1;
    }
}

.intelligence-item {
    transition: all 0.3s ease;
}

.intelligence-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    background: rgba(255,255,255,0.1) !important;
}

.intelligence-table {
    width: 100%;
    border-collapse: collapse;
    margin: 10px 0;
}

.intelligence-table th {
    background: rgba(255, 215, 0, 0.1);
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #333;
    color: #FFD700;
}

.intelligence-table td {
    padding: 8px 10px;
    border-bottom: 1px solid #333;
}

.intelligence-table tr:last-child td {
    border-bottom: none;
}

.intelligence-table tr:hover {
    background: rgba(255,255,255,0.05);
}

.progress-bar-intel {
    display: inline-block;
    width: 60px;
    height: 6px;
    background: #333;
    border-radius: 3px;
    margin-right: 5px;
    vertical-align: middle;
}

.progress-fill-intel {
    height: 100%;
    border-radius: 3px;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
}

.status-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
}

.status-high {
    background: #4CAF50;
}

.status-medium {
    background: #FFC107;
}

.status-low {
    background: #f44336;
}

.event-impact-positive {
    color: #4CAF50;
    font-weight: bold;
}

.event-impact-negative {
    color: #f44336;
    font-weight: bold;
}

.event-impact-neutral {
    color: #FFC107;
    font-weight: bold;
}
.difficulty-btn {
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    color: white;
    transition: all 0.3s ease;
    min-width: 80px;
}

.difficulty-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 10px currentColor;
}

.difficulty-btn:active {
    transform: scale(0.95);
}
 .landlord-ui {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 90%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow: hidden;
        }
        
        .landlord-header {
            background: linear-gradient(to right, #2c3e50, #4a6491);
            color: white;
            padding: 15px 20px;
            text-align: center;
            border-bottom: 5px solid #f1c40f;
        }
        
        .landlord-header h2 {
            font-size: 2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .landlord-currency {
            font-size: 1.5em;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 50px;
            display: inline-block;
        }
        
        .landlord-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
        }
        
        .landlord-nav {
            display: flex;
            background: #34495e;
            padding: 0;
        }
        
        .landlord-tab {
            flex: 1;
            background: none;
            border: none;
            color: white;
            padding: 12px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .landlord-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .landlord-tab.active {
            background: #1abc9c;
            font-weight: bold;
        }
        
        .landlord-content {
            padding: 20px;
            height: calc(100% - 250px);
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.95);
        }
        
        .landlord-tab-content {
            display: none;
        }
        
        .landlord-tab-content.active {
            display: block;
            animation: fadeIn 0.5s;
        }
        
        /* 商店样式 */
        .landlord-store-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .landlord-seed-item, .landlord-item-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s;
            border: 2px solid #eee;
        }
        
        .landlord-seed-item:hover, .landlord-item-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .landlord-seed-icon, .landlord-item-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            color: white;
        }
        
        .landlord-seed-price, .landlord-item-price {
            font-size: 1.2em;
            font-weight: bold;
            margin: 10px 0;
            color: #e74c3c;
        }
        
        .landlord-buy-button {
            background: #2ecc71;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.3s;
        }
        
        .landlord-buy-button:hover:not(:disabled) {
            background: #27ae60;
        }
        
        .landlord-buy-button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        
        /* 田地样式 */
        .landlord-fields-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .landlord-field {
            background: linear-gradient(to bottom, #8BC34A, #689F38);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            min-height: 220px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .landlord-field.empty {
            background: linear-gradient(to bottom, #A5D6A7, #81C784);
            cursor: pointer;
        }
        
        .landlord-field.empty:hover {
            background: linear-gradient(to bottom, #C8E6C9, #A5D6A7);
        }
        
        .landlord-field-status {
            font-size: 1.2em;
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 10px;
        }
        
        .landlord-plant-info {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .landlord-mutations-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            margin: 10px 0;
        }
        
        .landlord-mutation-tag {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .landlord-mutation-grey { background: #bdc3c7; color: #2c3e50; }
        .landlord-mutation-green { background: #2ecc71; color: white; }
        .landlord-mutation-blue { background: #3498db; color: white; }
        .landlord-mutation-purple { background: #9b59b6; color: white; }
        .landlord-mutation-gold { background: #f1c40f; color: #2c3e50; }
        .landlord-mutation-rainbow { 
            background: linear-gradient(45deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6600ff);
            color: white;
        }
        
        .landlord-field-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .landlord-action-row {
            display: flex;
            gap: 8px;
        }
        
        .landlord-action-button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .landlord-harvest-button {
            background: #f39c12;
            color: white;
        }
        
        .landlord-harvest-button:hover {
            background: #e67e22;
        }
        
        .landlord-remove-button {
            background: #e74c3c;
            color: white;
        }
        
        .landlord-remove-button:hover {
            background: #c0392b;
        }
        
        .landlord-plant-button {
            background: #3498db;
            color: white;
            width: 100%;
            padding: 10px;
        }
        
        .landlord-plant-button:hover {
            background: #2980b9;
        }
        
        .landlord-item-button {
            background: #9b59b6;
            color: white;
        }
        
        .landlord-item-button:hover {
            background: #8e44ad;
        }
        
        /* 仓库样式 */
        .landlord-storage-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .landlord-storage-section {
            flex: 1;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .landlord-storage-section h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .landlord-storage-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .landlord-storage-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
            transition: background 0.3s;
        }
        
        .landlord-storage-item:hover {
            background: #f8f9fa;
        }
        
        .landlord-item-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .landlord-item-weight {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .landlord-item-value {
            color: #27ae60;
            font-weight: bold;
        }
        
        .landlord-total-assets {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .landlord-total-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-top: 10px;
        }
        
        /* 统计页面样式 */
        .landlord-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .landlord-stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .landlord-stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
            text-align: center;
            margin: 10px 0;
        }
        
        .landlord-progress-bar {
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .landlord-progress-fill {
            height: 100%;
            background: linear-gradient(to right, #2ecc71, #3498db);
            border-radius: 10px;
        }
        
        /* 解锁地块样式 */
        .landlord-unlock-container {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .landlord-unlock-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }
        
        .landlord-unlock-button:hover:not(:disabled) {
            opacity: 0.9;
        }
        
        .landlord-unlock-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* 通知样式 */
        .landlord-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            animation: slideIn 0.5s, fadeOut 0.5s 2.5s;
        }
        
        .landlord-notification.success {
            background: #2ecc71;
        }
        
        .landlord-notification.error {
            background: #e74c3c;
        }
        
        .landlord-notification.info {
            background: #3498db;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        /* 模态框样式 */
        .landlord-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1002;
        }
        
        .landlord-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            min-width: 300px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
        }
        
        .landlord-modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
        }
.landlord-storage-item.locked {
                position: relative;
                background: linear-gradient(135deg, #fff3cd, #ffeaa7) !important;
                border: 2px solid #f39c12 !important;
            }
            
            .landlord-storage-item.locked::before {
                content: '🔒';
                position: absolute;
                top: 5px;
                right: 5px;
                font-size: 1.2em;
            }
            
            .landlord-storage-item.locked .landlord-item-info {
                opacity: 0.9;
            }
            
            .landlord-lock-button {
                background: #f39c12 !important;
                color: white !important;
            }
            
            .landlord-lock-button:hover {
                background: #e67e22 !important;
            }
            #miningUI {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            background: #1a1a1a;
            color: white;
            padding: 20px;
            border: 3px solid #4CAF50;
            border-radius: 10px;
            z-index: 1001;
            overflow-y: auto;
        }
        
        .mining-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        .mining-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .mining-stat {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .mining-stamina {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .stamina-bar {
            width: 100%;
            height: 20px;
            background: #555;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .stamina-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9a00);
            border-radius: 10px;
            transition: width 0.5s;
        }
        
        /* 新增：调整控制按钮区域布局 */
        .mining-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        /* 新增：通知栏样式调整 */
        .mining-notifications {
            height: 200px;
            overflow-y: auto;
            background: #222;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .mining-notification {
            padding: 5px;
            margin-bottom: 5px;
            border-left: 3px solid #4CAF50;
            background: #2a2a2a;
        }
        
        /* 新增：按钮组样式 */
        .mining-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        /* 分页标签样式 */
        .mining-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #4CAF50;
        }
        
        .mining-tab {
            padding: 10px 20px;
            cursor: pointer;
            background: #333;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s;
        }
        
        .mining-tab.active {
            background: #4CAF50;
            font-weight: bold;
        }
        
        .mining-tab:hover:not(.active) {
            background: #444;
        }
        
        /* 宝石页面样式 */
        .mining-gems-page {
            display: none;
        }
        
        .mining-gems-page.active {
            display: block;
        }
        
        .mining-gems {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mining-gem {
            background: #333;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* 新增：药水显示在宝石页面内 */
        .mining-potions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #52b788;
        }
        
        .potion-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .potion-icon {
            font-size: 1.5em;
        }
        
        .potion-count {
            font-size: 1.2em;
            font-weight: bold;
            color: #52b788;
        }
        
        /* 升级页面样式 */
        .mining-upgrades-page {
            display: none;
        }
        
        .mining-upgrades-page.active {
            display: block;
        }
        
        .mining-upgrades {
            margin-bottom: 20px;
        }
        
        .mining-upgrade {
            background: #333;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
     /* 房屋系统样式 */
        #houseSystemOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
        }
        
        #houseSystemUI {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            color: white;
            padding: 20px;
            border: 3px solid #8B4513;
            border-radius: 10px;
            z-index: 1001;
            width: 850px;
            max-height: 800px;
            overflow-y: auto;
        }
        
        .house-card {
            background: #333;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            border: 2px solid;
        }
        
        .house-common { border-color: #1E90FF; }
        .house-rare { border-color: #32CD32; }
        .house-epic { border-color: #FFD700; }
        .house-legendary { border-color: #9370DB; }
        .house-mythic { border-color: #FF4500; }
    </style>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body onload="resetItemDisplay(); resetPetDisplay()">
<body>
<div style="position: fixed; top: 10px; right: 10px; z-index: 9999; display: flex; flex-direction: column; align-items: flex-end;">
    <!-- 公告切换按钮 -->
    <button id="announcementToggle" style="background: #3498db; color: white; border: none; padding: 5px 10px; cursor: pointer; border-radius: 3px 3px 0 0;">
        点击呼出新手必看↓
    </button>
    
    <!-- 公告内容区域（默认隐藏） -->
    <div id="gameLogPage5" style="display: none; background: white; border: 1px solid #ddd; padding: 10px; max-height: 400px; width: 300px; overflow-y: auto; border-radius: 0 0 3px 3px;">
        <div class="log">
            <h4>游戏公告介绍</h4>
            <p>QQ群：864788026  有问题可以进群问（存档异常联系群管理修复）</p>
            <p>1. 转生系统：玩家可以通过转生重置游戏进度，并获得转生币，用于提升转生属性（转生要求必须普通装备10000+转生次数*20）。</p>
            <p> 转生币等级兑换比例：普通10000=1  稀有5000=1 史诗1000=1 传说300=1 远古200=1 神圣125=1 奥术100=1 天空33=1 地狱20=1 星界12.5=1  原初10=1 超凡3=1 量子2=1 究极1=1  混沌1=3 永恒1=5 虚无1=10 创世1=20 神域1=30 终焉1=40 星辰1=50 起源1=60 时光1=70 造物1=80 银河1=90 天界1=100 星云1=200 星河1=300 纪元1=400 鸿蒙1=500 星穹1=600 亘古1=700 万象1=800 太虚1=900 九垓1=1000  穿梭1=2000  恒古1=3000 虚空1=4000 蔚来1=5000 神罚1=6000  时空1=7000  未来1=8000  从前1=9000   星澜1=10000</p>
            <p>货币兑换比例：1e5 → 1e8 → 1e8 → 1e8 → 1e9 → 1e12 → 1e12 → 1e12 → 1e15 → 1e15 → 1e15 → 1e20 → 1e20 → 1e20 </p>
            <p>2. 宠物系统：玩家可以通过升级宠物来提升装备属性加成。</p>
            <p>3. 离线系统：现在离线也能奥秘经验和银行和股票，彩票更新，升级装备。</p>
            <p>4. 股票系统，显示实时股价和持有情况，每10分钟股价随机波动±1%~10%，离线时间自动计算股价波动，所有交易使用转生币结算，实时显示价格变化趋势</p>
            <p>5. 彩票系统：30分钟开奖1次。刮刮卡：直接生效，开奖结果看获取！</p>
            <p>6. 银行系统：存钱每6分钟0.02%收益！</p>
            <p>7. 副本装备系统：副本装备可以提升第一页装备的全属性，使用洗炼石（材料宝箱或者打怪掉）可以重铸副本装备的成长属性或者分解重新获取。成长数值上限：废品0.05%，倚天剑10%，青龙枪15%，白虎斧20%，朱雀弓25%，玄武盾30%，麒麟杖35%，凤凰剑40%，饕餮刀45%，穷奇戟50%，烛龙枪60%，白泽剑70%，混沌斧80%，太初刃90%   后续加深颜色多10%  比如：☆=100%★=110% ○=200% ●=210%  ◇=300%  ◆=310%  □=400%  ■=410%  △=500%  ▲=510%</p>
            <p>8. 魂环系统：魂环可以永久提升装备属性，通过打怪掉落升级。</p>
            <p>9. 打怪模式(必须先打)：1转开启，逃跑等于重置关卡消耗最大关卡*10转生币（取消扫荡增加自动扫荡4秒1次！！！）（优先打！第一次打点逃跑！！！）。</p>
            <p>10. 升级属性：第一次加载要转生一次，在点洗点就正常了（总数和实际不一样点一下洗点）。</p>
            <p>11. 功法秘籍：后期比较强，加成属性直接算到玩家属性乘于里面（如果突然没效果了开一个秘法宝箱就好了，正常不会有问题）</p>
            <p>11. 世界BOSS系统：50转开启，才能打比较难，有连击后期简单。</p>
            <p>12. VIP系统：每一级提升大属性，材料宝箱和打怪模式，各种系统掉落。</p>
            <p>13. 职业系统：20转开启，有法师和战士不同搭配属性，对于关卡解锁属性，选择获得属性，通天塔达到层数2转3转。</p>
            <p>14. 称号系统：10转开启，解锁每一个都可以永久获得属性，自由搭配选择称号(不影响属性效果）。</p>
            <p>14. 官职系统：10转开启，增加总和攻击，一共65级。</p>
            <p>15. 伴侣系统：30转开启，大幅度增加属性。天赋品阶初级→中级→高级→终极→圣级→神级→远古→太古→洪荒，进阶玩法：每进阶+1倍率加1倍，未锁定状态才能进阶，点进阶自动消耗道具里面的同品质伴侣灵魂，想保留的伴侣记得锁定，史诗以上才能合成洗练！！！（伴侣钥匙和玫瑰花和洗髓丹：打怪或者材料宝箱各种系统掉落）。</p>
            <p>16. 通天塔：100转开启，只要通过每一层加1点玩家属性，每一层加0.01倍GPS,还有对应称号。</p>
            <p>17. 存档问题：换设备后存档导入一开始进去VIP和伴侣是空的，你直接退出在重新进就恢复了或者刷新页面（点了导出按钮，会自动复制，你黏贴就可以了）</p>
            <p>18. 奥秘系统：100转开启，每阶段只生效第一个效果。</p>
            <p>19. 基金系统：投入的越多波动的幅度越大10-50%，1分钟刷新一次 ，10分钟不能实时卖出，如果跌到总价值20%以下 就全部没收清零。</p>
            <p>20. 钓鱼系统：20转开启，分解鱼类可以获得VIP能力值，玫瑰花，洗髓丹，洗练石，农场种子。鱼饵掉率（打怪模式扫荡，各种系统兑换）（自动钓鱼开启没用，点一下开始钓鱼，自动分解是分解钓到的所有东西）</p>
             <p>21. 农场系统：50转开启，种子靠鱼类分解，可以获得VIP能力值（水滴等于VIP能力值），每级都有每秒GPS和点击加成</p>
            <p>22. 停车场系统：200转开启，靠种子收取时候有几率获得车（进群领取兑换码送 "法拉利" ），每级都有每秒GPS和点击加成</p>
            <p>23. 神器锻造系统：500转开启，探索获取材料，6个品质，集齐套装加格外属性。</p>
           <p>24. 星域探索：300转开启，获取新材料，商店：（发票可以兑换4材料，星尘：杂货铺或者藏宝图。暗物质：购买宝石。宇宙晶体：升级神器。神器碎片：锻造神器）</p>
           <p>25. 宝石系统：800转开启，提供大量属性</p>
           <p>26. 修仙系统：500转开启，开启经验获得条件是：获得一次灵根和血脉。材料都是杂货铺购买</p>
           <p>27. 宝图系统：600转开启，随机奖励或者打BOSS。</p>
           <p>28. 夜店系统：600转开启，店铺每级加点击伤害，特殊事件消耗50-200星币，提升30-60分钟金币或者经验收益，获得的星币可以兑换藏宝图，或者打世界地图怪物消耗（后续会加其他材料兑换）。</p>
           <p>29. 玩家等级：50转开启，每级1倍属性飞升轮回有加成，世界地图怪物打怪升级。每100级可以飞升一次，10次飞升1转轮回，翅膀：打怪次元2以上掉落，坐骑：打怪次元3以上掉落，符文：打怪次元4以上掉落</p>
           <p>30. 世界地图：50转开启，打怪掉玩家经验，每挑战一次消耗星币，如果打的时候闪退界面，那就是打不过这关。（掉落材料，翅膀，符文）。</p>
          <p>31. 直播系统：500转开启，每级增加点击伤害，粉丝数增加GPS加成，流量是获得多倍经验（获取大量玫瑰花）</p>
        <p>32. 宗门系统：1000转开启，每级GPS收益，功法库提升功法秘笈加成。</p>
          <p>33. 黑龙潭副本：1轮回开启，掉落大量材料，翅膀升级材料。</p>
        <p>34. 圣兽岛副本：2轮回开启，掉落大量材料，坐骑升级材料。</p>
        <p>35. 跑商系统：1000转开启，可以获得大量星币。</p>
         <p>36. 蓬莱仙岛系统：3轮回开启，掉落大量材料，符文升级材料。</p>
        <p>37. 娱乐玩法：老虎机。</p>
       <p>38. 秘境：2000转开启，提升临时总数值，和大量神器碎片（藏宝图怪物掉落）。</p>
       <p>39. 疯狂地主：0转开启（打怪模式第三层以上开启），提升总数值根据（总获得地主币），新版农田，10分钟刷新商店，成熟只要不收获也可以吃天气词条，离线也可以吃词条，最高26条。</p>
       <p>40. 无尽挖矿：(升级一下稿子等级不然挖不到普通矿)1500转开启，提升大量世界地图经验，和各项属性。</p>
       <p>41. 新版股票:（离线后如果打不开点一下疯狂地主再打开）</p>
      <p>42. 房子系统:200转开启，新版股票资金购买，每秒GPS加成 ，收益点击加成（群里兑换码可以领取别墅）</p>
        </div>
    </div>
</div>
   <div style="position: fixed; top: 10px; right: 510px; z-index: 9999; display: flex; flex-direction: column; align-items: flex-end;">
    <!-- 公告切换按钮 -->
    <button id="announcementToggle1" style="background: #3498db; color: white; border: none; padding: 5px 10px; cursor: pointer; border-radius: 3px 3px 0 0;">
        点击呼出更新日志↓
    </button>
    
    <!-- 公告内容区域（默认隐藏） -->
    <div id="gameLogPage4" style="display: none; background: white; border: 1px solid #ddd; padding: 10px; max-height: 400px; width: 300px; overflow-y: auto; border-radius: 0 0 3px 3px;">
        <div class="log">
            <h4>1.73更新日志</h4>
           <p>2025/12/29: 更新疯狂地主系统，加强停车场加成，增加房子系统200转开启，股票资金购买（群里兑换码可以领取别墅）</p>
           <p>2025/12/28:修复疯狂地主一键收获BUG，修复严重BUG离线系统异常没生效问题，直播系统过几秒人数只有6人正常不影响送礼（保存机制原因不会暂用内存），加入新版股票，随机波动涨跌，对应称号。 </p>
           <p>2025/12/24:修复无尽挖宝石发现没获得宝石BUG,修复红宝石没生效世界经验加成BUG,修复直播人数越来越少，优化存档内存老玩家点一下保存在点一下加载会流畅很多，降低货币兑换。</p>
           <p>2025/12/22:增加无尽挖矿：开启条件1500转(升级一下稿子等级不然挖不到普通矿)，提升大量世界地图经验，和各项属性，对应称号。</p>
           <p>2025/12/21:修改疯狂地主（新版农田）：开启条件，打怪模式第三层以上开启，增加疯狂地主对应称号。</p>
            <p>2025/12/20:增加疯狂地主（新版农田）：提升大量点击和每秒GPS，十分钟刷新一次。</p>
            <p>2025/12/19:停车场加入批量分解，降低职业转生要求。加入秘境：2000转开启（秘境钥匙，藏宝图打怪掉落）。</p>
           <p>2025/11/06:修改星域获得，现在掉落是发票，增加新轮回副本，掉落符文强化材料，增加娱乐水果机：货币为星辰发票。</p>
           <p>2025/11/05:神器，翅膀，坐骑，增加锁定。</p>
           <p>2025/11/01:增加符文系统：5个属性有增加世界地图经验词条。</p>
           <p>2025/10/30 :增加跑商系统：1000转开启，可以获取大量星币，隐藏游戏日志自动购买宝箱信息</p>
           <p>2025/10/27 :增加坐骑9品质提升大量属性，次元3以上掉落，分解可以获得星币。增加圣兽岛副本2轮回才能进入（掉落升级坐骑材料），世界地图次元调整：降低星币消耗，VIP增加10倍经验效果。</p>
          <p>2025/10/26 : 增加黑龙潭副本1轮回才能进入（掉落升级翅膀材料）。修改职业更换消耗职业转换书，职业增加：二转有分支→三转→四转（通天塔层数解锁职业专职）。（藏宝图打怪掉落或者商店兑换）。世界地图次元修改（轮回解锁次元难度），次元2以上低概率掉落翅膀，增加轮回：每飞升10次→轮回1转。降低世界地图和通天塔复活次数改为3次。打怪模式1000关修改成5000关，通天塔10W层修改50W层，藏宝图打怪掉落增加：副本令牌和职业转换书（商店也可以购买）。修改伴侣洗练：现在是全词条洗练，每锁定1个消耗加2材料。</p>
             <p>2025/10/23 : 由于数值过大导致游戏暴毙，削弱数值。</p>
             <p>2025/10/10 : 修复卡顿（点设置 点保存游戏（多点几次）在点加载游戏，就不卡了（如果还卡就刷新页面。））</p>
             <p>2025/10/09 : 世界地图增加难度次元，切换次元可以多倍经验，会掉落一些道具。通天塔怪物复活次数20次修改为5次</p>
           <p>2025/10/08 : 玩家等级增加飞升，每100级可以飞升一次(飞升后等级变为1级）属性翻倍，世界地图100转修改50转开启。鱼类分解增加获得种子几率。</p>
           <p>2025/10/07 : 修复星域探险任务进行中点开宗门导致星域不更新任务时间奖励</p>
           <p>2025/10/04 : 修复传统彩票不显示开奖结果。另外增加奖励！传统彩票奖励不再是转生币改为星尘发票（开奖后想看结果可以随便购买下面普通2个彩票中的一个刷新开奖结果界面）</p>
           <p>2025/10/03 :修改伴侣进阶要求：对应的伴侣灵魂获得。分解伴侣可以获得对应的伴侣灵魂（宝图小概率获得天使恶魔精灵），伴侣界面增加伴侣商店。宝图购买次数增加10-50次，开启也增加次数。宝图提高品质奖励：增加宝图2合1合成。修改农田浇水，每次浇水消耗30VIP能力值，可以加速成熟3分钟。</p>
           <p>2025/10/02 :神器界面加入筛选，想看什么筛选什么，神器锻造次数增加10-100次，建议不要太多分解再点。</p>
           <p>2025/10/01 :增加星域探索材料兑换转存档的时候可以用，伴侣宝箱开启次数增加10-50次，自动购买宝箱里面增加功法秘籍价格上限自己设置价格(输入10000或者1E4这样都可以)自动购买超出会停止购买转生后会自动开启，增加农场在线自动种植和收货。</p>
           <p>2025/9/30 : 修复宗门BUG</p>
           <p>2025/9/20 : 增加宗门，提升功法秘笈大量加成，忠诚度影响获得任务收益，大于忠诚50加低于减。宗门令牌：宝藏金币兑换，香囊：宝图打怪掉落</p>
           <p>2025/9/16 : 增加TXT导入存档，增加藏宝图商店，宝藏金币：宝图怪物掉落</p>
            <p>2025/9/14 : 优化扫荡严重卡顿，修复杂货铺兑换异常只能兑换1个的BUG</p>
            <p>2025/9/12 : 直播：盲盒出的礼物不加玫瑰花，只加粉丝数量，更新加了新3个宝箱9装备20成就3宠物3称号。</p>
            <p>2025/9/11 : 修复农田和离线时间异常显示，  增加直播：500转开启，每级增加点击伤害，粉丝数增加GPS加成，流量是获得多倍经验（每次进游戏建议结束直播在重新开播，不这样可能没礼物）（第一次加载记得刷新一下页面，第一次直播经验显示异常，刷新后正常）</p>
            <p>2025/9/10 : 玩家等级：50转开启，每一级增加10倍效果。世界地图：100转开启：打怪经验可以给玩家升级每次生成怪物消耗1星币（后续会加掉落材料）（如果属性显示低打一下打怪模式）</p>
            <p>2025/9/9 : 夜店：600转开启，生产星币，获得的星币可以兑换藏宝图或者升级（后续会加入更多东西兑换）已修复</p>
            <p>2025/9/8 : 通天塔失败不会关闭自动攻击</p>
            <p>2025/9/7 : 减少宝图兑换数量，神器增加进阶，消耗进阶神石：宝图掉落。（如果打怪模式显示血负了，脱一件神器在穿上就可以了）</p>

        </div>
    </div>
</div>
    <h1>金币冒险者</h1>
 <div class="player-name">
    <span id="playerName">勇者</span> <span id="playerClassName" style="color: #00f;"></span><span id="currentTitle" style="margin-left: 10px; color: #ffd700;"></span>
    <div class="vip-container" style="text-align: center; margin: 10px 0;">
     <span id="ascentionCountqa" style="margin-left: 10px; color: #4CAF50;">0</span>
     <span id="ascentionCountq" style="margin-left: 10px; color: #4CAF50;">0</span>
    <span id="playerLevelDisplay" style="margin-left: 10px; color: #4CAF50;">Lv.1</span>
  <div class="vip-level-display" style="font-size: 18px; font-weight: bold; background: linear-gradient(to right, #ffd700, #ffA500); -webkit-background-clip: text; color: transparent;">
    VIP等级: <span id="vipLevel">1</span>
  </div>
  <div class="vip-progress" style="height: 10px; background-color: #eee; border-radius: 5px; margin: 5px 0;">
    <div id="vipProgressBar" style="height: 100%; background: linear-gradient(to right, #ffd700, #ffA500); width: 0%;"></div>
  </div>
  <div class="vip-next-level" style="font-size: 12px; color: #666;">
    距离下一级: <span id="vipProgressText">0/1</span>
  </div>
</div>
 <div class="vip-power-use">
    <button onclick="useAllVipPower()">使用全部VIP能力值 (当前: <span id="vipPowerCount">0</span>)</button>
</div>
</div>
   <div class="currency">金币: <span id="gold">0</span></div>
    <div class="currency">钻石: <span id="diamond">0</span></div>
    <div class="currency">钛晶石: <span id="titanium">0</span></div>
    <div class="currency">星耀石: <span id="starstone">0</span></div>
    <div class="currency">宇宙石: <span id="cosmicstone">0</span></div>
    <div class="currency">超能石: <span id="superstone">0</span></div>
    <div class="currency">异界石: <span id="otherworldstone">0</span></div>
    <div class="currency">星界石: <span id="xingjiestone">0</span></div>
    <div class="currency">混沌石: <span id="hundunstone">0</span></div>
    <div class="currency">灵髓石: <span id="lingtone">0</span></div>
    <div class="currency">幻空石: <span id="huangtone">0</span></div>
    <div class="currency">冥源石: <span id="mingtone">0</span></div>
    <div class="currency">虚空石: <span id="xutong">0</span></div>
    <div class="currency">时空石: <span id="shitone">0</span></div>
    <div class="currency">未来石: <span id="weitone">0</span></div>
    <div class="currency">转生币: <span id="reincarnationCoin">0</span></div>
    <div>每秒金币（GPS）: <span id="gps">1</span></div>
    <div>点击收益: <span id="clickValue">1</span></div>
    <div>转生次数: <span id="reincarnationCount">0</span></div>
    <div>最高关卡: <span id="maxStage">0</span></div>
    <div>通天塔层数: <span id="towerFloor">0</span></div>
    <div>当前官职: <span id="currentOfficialTitle">无</span></div>
    <div>当前奥秘: <span id="currentMysteryTitle">初级秘法师 1阶1级</span></div>
    <div>修仙境界: <span id="currentStageq">凡人</span></div>
     <div id="sectNameDisplay" style="color: #8B4513; font-weight: bold; margin-top: 5px;">
        <!-- 宗门名称将在这里显示 -->
    </div>

    <button onclick="clickGold()">点击获取金币</button>
    <button onclick="reincarnate()">转生</button>
    <button onclick="toggleAutoReincarnation()" style="margin-left: 10px;">自动转生: <span id="autoReincarnationStatus">关闭</span></button>
    <button onclick="toggleLevelSystem()">玩家等级</button>
    <button onclick="toggleShopUI()">打开宝箱商店</button>
    <button onclick="toggleGroceriesUI()" style="margin-left: 10px;">杂货铺</button> 
    <button onclick="toggleMonsterUI()">打怪模式(优先打!)</button> 
    <button onclick="toggleWorldMap()">世界地图</button>
    <button onclick="toggleTowerUI()">通天塔</button>
     <button onclick="toggleAutoBuyShopa()">轮回BOSS副本</button>
    <button onclick="toggleWorldBossUI()" style="background: linear-gradient(to bottom, #d4af37, #a67c00); color: #000; font-weight: bold; padding: 6px 12px; font-size: 12px;">世界BOSS</button>
     <button onclick="toggleLandlordGame()" style="background: #8e44ad; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px;">疯狂地主</button>
     <button onclick="toggleInvestmentGame()" style="background: linear-gradient(45deg, #4CAF50, #2196F3); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">
    <i class="fas fa-chart-line"></i> 模拟投资</button>
    <button onclick="toggleSlotMachine()">老虎机</button>
    <button onclick="toggleFundSystem()">基金系统</button>
    <button onclick="showTitleDialog()">称号系统</button>
    <button onclick="toggleOfficialSystem()">官职系统</button>
    <button onclick="toggleClassSystem()">职业系统</button>
    <button onclick="openCompanionSystem()">伴侣系统</button>
    <button onclick="toggleMysterySystem()">奥秘系统</button>
    <button onclick="toggleFishingSystem()" style="margin-left: 10px;">钓鱼系统</button>
    <button onclick="toggleFarmSystem()" style="margin-left: 10px;">农场系统</button>
    <button onclick="toggleParkingSystem()">停车位系统</button>
    <button onclick="toggleHouseSystem()">房屋系统</button>
    <button onclick="toggleExplorationSystem()" style="margin-left: 10px;">星域探索</button>
    <button onclick="toggleArtifactSystem()" style="margin-left: 10px;">神器锻造系统</button>
    <button onclick="toggleCultivationSystem()" style="margin-left: 10px;">修仙系统</button>
    <button onclick="toggleGemSystem()" style="margin-left: 10px;">宝石系统</button>
    <button onclick="toggleTreasureMapSystem()">藏宝图系统</button>
    <button onclick="toggleNightClubSystem()" style="margin-left: 10px;">夜店系统</button>
    <button onclick="toggleLiveStreamSystem()" class="tab-button">直播系统</button>
    <button onclick="toggleSectSystem()" class="system-btn">宗门系统</button>
   <button onclick="toggleTradingSystem()" style="margin: 5px; padding: 8px 15px; background: linear-gradient(45deg, #FFD700, #FFA500); color: black; border: none; border-radius: 5px; cursor: pointer;">跑商系统</button>  
   <button onclick="toggleMiningUI()" style="margin: 5px; padding: 8px 15px; background: linear-gradient(45deg, #FFD700, #FFA500); color: black; border: none; border-radius: 5px; cursor: pointer;">无尽挖矿</button>
<button onclick="toggleTimeSecretRealm()" style="background: linear-gradient(to bottom, #00bfff, #006994); color: #e6f7ff; border: 2px solid #00bfff; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; text-shadow: 0 0 5px #00bfff; box-shadow: 0 0 10px #00bfff; margin-left: 10px;">时光秘境</button>     
    <button onclick="toggleSettingsUI()">设置</button>

<h3>自动购买设置</h3>
    <div class="auto-buy-container">
      <button onclick="toggleAutoBuyShop()">自动购买商店</button>
      <button onclick="toggleAutoConvertUI()">自动兑换货币</button>
        <button id="autoBuySpeedBoost" class="auto-buy-btn" onclick="toggleAutoBuySpeedBoost()">在线自动购买100倍数量：关闭</button>
        <button id="toggleOnlineBoost" onclick="toggleOnlineBoost()">在线金币加速100倍: 关闭</button>
    </div>

  

    <div class="tab active" onclick="switchTab('equipment')">装备</div>
    <div class="tab" onclick="switchTab('items')">道具</div>
    <div class="tab" onclick="switchTab('collections')">收藏物</div>
    <div class="tab" onclick="switchTab('reincarnation')">转生属性</div>
    <div class="tab" onclick="switchTab('pets')">宠物</div>
    <div class="tab" onclick="switchTab('stocks')">股票</div>
    <div class="tab" onclick="switchTab('lottery')">彩票</div>
    <div class="tab" onclick="switchTab('bank')">银行系统</div>
    <div class="tab" onclick="switchTab('dungeonEquipment')">副本装备</div>
    <div class="tab" onclick="switchTab('soulRings')">魂环</div> <!-- 新增魂环标签 -->
    <div class="tab" onclick="switchTab('playerAttributes')">玩家属性</div>
    <div class="tab" onclick="switchTab('techniques')">功法秘籍</div>

    <h3></h3>
    <div id="equipmentList"></div>
    <h3></h3>
    <div id="itemList" style="display: none;">
    <h3></h3>
    <button onclick="resetItemDisplay()">重置道具页面</button> <!-- 新增按钮 -->
    
    <div id="itemContainer"></div> <!-- 用于显示道具信息的容器 -->
</div>
    <div id="collectionList" style="display: none;">
    <button onclick="resetAllCollectionEffects()">重新计算收藏物效果</button>
    <div id="collectionInfoContainer" style="margin-top: 10px;"></div>
</div>
    <h3></h3>
    <div id="reincarnationList" style="display: none;"></div>
    <h3></h3>
    <div id="petList" style="display: none;">
    <h3></h3>
    <button onclick="resetPetDisplay()">重置宠物页面</button> <!-- 新增按钮 -->
    <div id="petContainer"></div> <!-- 用于显示宠物信息的容器 -->
</div>
    <div id="stockList" style="display: none;">
        <h3>股票市场（每10分钟波动一次）</h3>
        <div id="stocksContainer"></div>
        <div class="stock-control">
            <input type="number" id="stockAmount" placeholder="数量" min="1">
            <button onclick="buyStock()">买入选中股</button>
            <button onclick="sellStock()">卖出选中股</button>
            <button onclick="buyAllStock()">买入选中所有股</button>
            <button onclick="sellAllStock()">卖出选中所有股</button>
        </div>
    </div>
    <h3></h3>
    <div id="lotteryList" style="display: none;">
        <h3></h3>
        <div>
            <h4>传统数字彩票（购买刮刮卡刷新开奖结果）</h4>
            <p>每30分钟开奖，1-50数字中6个100万，中5个10万，中4个1万，中3个1000，中2个100，中1个10（中奖奖励星尘发票）。记得来一注！</p>
            <button onclick="buyTraditionalLottery()">购买传统数字彩票（10转生币）</button>
            <div id="traditionalLotteryNumbers"></div>
            <div id="traditionalLotteryCountdown" class="lottery-countdown">下次开奖: --:--:--</div>
        </div>
        <div>
            <h4>蛇年刮刮卡（购买后刷新开奖结果）</h4>
            <p>60%谢谢惠顾0转生币，35%鼓励奖获得10-100转生币，三等奖3.9%获得100-500，二等奖1%获得500-2000，一等奖0.1%获得2000-10000。</p>
            <button onclick="buySnakeScratchCard()">购买蛇年刮刮卡（50转生币）</button>
        </div>
        <div>
            <h4>发财刮刮卡（购买后刷新开奖结果）</h4>
            <p>60%谢谢惠顾0转生币，35%鼓励奖获得100-1000转生币，三等奖3.9%获得1000-5000，二等奖1%获得5000-20000，一等奖0.1%获得20000-100000。</p>
            <button onclick="buyFortuneScratchCard()">购买发财刮刮卡（500转生币）</button>
        </div>
    </div>

    <!-- 新增银行系统 -->
    <div id="bankList" style="display: none;">
        <h3>银行系统</h3>
        <div>
            <p>当前存款: <span id="bankDeposit">0</span> 转生币</p>
            <p>利息: <span id="bankInterest">0.2%</span> 每6分钟</p>
            <p>总金额: <span id="bankTotal">0</span> 转生币</p>
            <input type="number" id="bankAmount" placeholder="存款金额" min="1">
            <button onclick="depositToBank()">存款</button>
            <button onclick="withdrawFromBank()">取款</button>
            <button onclick="depositAllToBank()">存款所有</button>
            <button onclick="withdrawAllFromBank()">取款所有</button>
        </div>
    </div>

    <!-- 新增副本装备系统 -->
    <div id="dungeonEquipmentList" style="display: none;">
        <h3></h3>
        <div id="dungeonEquipmentContainer"></div>
    </div>

    <!-- 新增魂环系统 -->
    <div id="soulRingList" style="display: none;">
        <h3></h3>
        <div id="soulRingsContainer"></div>
    </div>

        <!-- 玩家属性页面 -->
<div id="playerAttributesList" style="display: none;">
    <h3>玩家属性</h3>
    <div>总属性点: <span id="totalAttributePoints">0</span></div>
    <div>剩余属性点: <span id="remainingAttributePoints">0</span></div>
    <div>
        <strong>生命加成</strong>: 每2点属性点增加2%生命 
        (当前加成: <span id="healthBonus">0%</span>, 已投入: <span id="healthPoints">0</span>)
        <button onclick="addAttributePoint('health', 1)">+1</button>
        <button onclick="addAttributePoint('health', 10)">+10</button>
        <button onclick="addAttributePoint('health', 100)">+100</button>
        <button onclick="addAttributePoint('health', 1000)">+1000</button>
        <button onclick="addAttributePoint('health', 'all')">+全部</button>
    </div>
    <div>
        <strong>攻击加成</strong>: 每2点属性点增加2%攻击 
        (当前加成: <span id="attackBonus">0%</span>, 已投入: <span id="attackPoints">0</span>)
        <button onclick="addAttributePoint('attack', 1)">+1</button>
        <button onclick="addAttributePoint('attack', 10)">+10</button>
        <button onclick="addAttributePoint('attack', 100)">+100</button>
        <button onclick="addAttributePoint('attack', 1000)">+1000</button>
        <button onclick="addAttributePoint('attack', 'all')">+全部</button>
    </div>
    <div>
        <strong>暴击率加成</strong>: 每2点属性点增加0.1%暴击率 
        (当前加成: <span id="critRateBonus">0%</span>, 已投入: <span id="critRatePoints">0</span>)
        <button onclick="addAttributePoint('critRate', 1)">+1</button>
        <button onclick="addAttributePoint('critRate', 10)">+10</button>
        <button onclick="addAttributePoint('critRate', 100)">+100</button>
        <button onclick="addAttributePoint('critRate', 1000)">+1000</button>
        <button onclick="addAttributePoint('critRate', 'all')">+全部</button>
    </div>
    <div>
        <strong>爆伤加成</strong>: 每2点属性点增加1%爆伤 
        (当前加成: <span id="critDamageBonus">0%</span>, 已投入: <span id="critDamagePoints">0</span>)
        <button onclick="addAttributePoint('critDamage', 1)">+1</button>
        <button onclick="addAttributePoint('critDamage', 10)">+10</button>
        <button onclick="addAttributePoint('critDamage', 100)">+100</button>
        <button onclick="addAttributePoint('critDamage', 1000)">+1000</button>
        <button onclick="addAttributePoint('critDamage', 'all')">+全部</button>
    </div>
    <div>
        <strong>连击</strong>: 每300点属性点增加1次攻击 
        (当前加成: <span id="multiAttackBonus">0</span>, 已投入: <span id="multiAttackPoints">0</span>)
        <button onclick="addAttributePoint('multiAttack', 1)">+1</button>
        <button onclick="addAttributePoint('multiAttack', 10)">+10</button>
        <button onclick="addAttributePoint('multiAttack', 100)">+100</button>
        <button onclick="addAttributePoint('multiAttack', 1000)">+1000</button>
        <button onclick="addAttributePoint('multiAttack', 'all')">+全部</button>
    </div>
    <button onclick="resetAttributes()">洗点 (消耗1转生币)</button>
</div>

      <!-- 功法秘籍页面 -->
<div id="techniquesList" style="display: none;" >
    <h3></h3>
    <button onclick="resetTechniquesData()">重置功法页面</button>
    <div id="techniquesContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px;"></div>
 </div>

        <!-- 新增：游戏日志分页 -->
    <h3>游戏日志</h3>
    <div class="log-tab active" onclick="switchLogTab(1)">游戏记录</div>
    <div class="log-tab" onclick="switchLogTab(2)">公告右上角</div>
    <div class="log-tab" onclick="switchLogTab(3)">开奖结果</div>    
    <div id="gameLogPage1" class="active">
        <div id="actionLog" class="log"></div>
    </div>
    <div id="gameLogPage2">
        <div class="log">  
    </div>
</div>
    <div id="gameLogPage3">
        <div id="lotteryResults" class="log"></div>
    </div>
    <div id="gameLogPage4">
        <div id="battleLog" class="log"></div>
    </div>

    <h3>成就系统</h3>
    <div id="achievements" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px;"></div>

    <!-- 自定义对话框 -->
    <div id="customDialog">
        <div id="dialogMessage"></div>
        <textarea id="dialogInput" style="width: 100%; height: 100px; margin-bottom: 10px;"></textarea>
        <button id="dialogConfirm">确定</button>
        <button id="dialogCancel">取消</button>
    </div>
    <div id="dialogOverlay"></div>

 <div id="gemUseDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ccc; z-index: 1001; text-align: center;">
    <div id="gemUseMessage"></div>
    <div style="margin: 15px 0;">
        <button id="gemUseConfirm" style="padding: 8px 15px; margin-right: 10px;">确认使用</button>
        <button id="gemUseCancel" style="padding: 8px 15px;">取消</button>
    </div>
</div>
<div id="gemUseOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
  <div id="renameDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ccc; z-index: 1001;">
    <div>输入新名字:</div>
    <input type="text" id="newNameInput" style="margin: 10px 0;" maxlength="10">
    <div>
        <button onclick="confirmRename()">确定</button>
        <button onclick="cancelRename()">取消</button>
    </div>
</div>
<div id="classSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>

<div id="classSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 2px solid #333; z-index: 1000; max-width: 90%; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; text-align: center;">职业系统</h3>
    
    <div style="margin-bottom: 15px;">
        当前职业: <span id="currentClassName">无</span>
    </div>
    
    <div id="classSelection" style="margin: 15px 0; display: flex; gap: 10px; justify-content: center;">
        <button onclick="selectClass('warrior')">战士</button>
        <button onclick="selectClass('mage')">法师</button>
        <button onclick="toggleClassSystem()">关闭页面</button>
    </div>
    
    <div id="classChangeCost" style="color: red; margin: 10px 0; text-align: center; font-size: 0.9em;">
        更换职业将消耗1本职业转换书，所有职业加成将重置
    </div>
    
    <div id="classBranches" style="display: none; margin: 15px 0; padding: 10px; border-top: 1px dashed #333;max-height: 380px; overflow-y: auto">
        <h4 style="margin-top: 0;">职业分支加点</h4>
        <div id="branchPointsContainer"></div>

    </div>
</div>
<div id="renameOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
 <div id="activationCodeDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1001;">
    <h3>激活码兑换</h3>
    <input type="text" id="activationCodeInput" placeholder="请输入激活码" style="width: 200px; margin: 10px 0;">
    <div>
        <button onclick="confirmActivationCode()">确认兑换</button>
        <button onclick="cancelActivationCode()">取消</button>
    </div>
</div>
<div id="activationCodeOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>

    <!-- 新增打怪模式UI -->
    <div id="monsterUI" style="display: none;">
    <button onclick="toggleMonsterUI()" style="position: absolute; top: 5px; right: 200px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 25px; height: 25px; cursor: pointer;">×</button>
        <h3>打怪模式</h3>
        <div class="player-info">
            <p>生命: <span id="playerHealth">0</span></p>
            <p>攻击: <span id="playerAttack">0</span></p>
            <p>暴击率: <span id="playerCritRate">0%</span></p>
            <p>爆伤: <span id="playerCritDamage">0%</span></p>
            <p>命中: <span id="playerAccuracy">0%</span></p>
            <p>闪避: <span id="playerDodge">0%</span></p>
        </div>
        <div class="monster-info">
            <p>当前关卡: <span id="currentStage">0</span></p>
            <p>怪物名称: <span id="monsterName">无</span></p>
            <p>怪物品阶: <span id="monsterRank">无</span></p>
            <p>怪物生命: <span id="monsterHealth">0</span></p>
            <p>怪物攻击: <span id="monsterAttack">0</span></p>
            <p>怪物词条: <span id="monsterModifiers">无</span></p>
        </div>
        <div class="battle-controls">
            <button onclick="attackMonster()">攻击</button>
            <button onclick="fleeFromBattle()">逃跑</button>
            <button onclick="toggleAutoSweep()">自动扫荡: <span id="autoSweepStatus">关</span></button>
            <input type="number" id="jumpStage" placeholder="第一次打点逃跑" min="1">
            <button onclick="jumpToStage()">必看</button>
        </div>
        <div class="battle-log">
            <h4>战斗记录</h4>
            <div id="battleLogContent"></div>
        </div>
    </div>

<!-- 称号系统弹窗 -->
<div id="titleDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1001; width: 80%; max-width: 800px; max-height: 80vh; overflow-y: auto;">
    <h3>称号系统</h3>
    <div id="titleBranches">
        <!-- 关卡分支 -->
        <div class="titleBranch">
            <h4>关卡称号</h4>
            <div class="titleRow" id="stageBranchContainer"></div>
        </div>
        <!-- 转生分支 -->
        <div class="titleBranch">
            <h4>转生称号</h4>
            <div class="titleRow" id="reincarnationBranchContainer"></div>
        </div>
        <!-- 驯兽师分支 -->
        <div class="titleBranch">
            <h4>驯兽师称号</h4>
            <div class="titleRow" id="tamerBranchContainer"></div>
        </div>
        <!-- 魂环分支 -->
        <div class="titleBranch">
            <h4>魂环称号</h4>
            <div class="titleRow" id="soulRingBranchContainer"></div>
        </div>
        <!-- 特殊分支 -->
        <div class="titleBranch">
            <h4>特殊称号</h4>
            <div class="titleRow" id="specialBranchContainer"></div>
        </div>
     <!-- 特殊分支 -->
        <div class="titleBranch">
            <h4>普通称号</h4>
            <div class="titleRow" id="towerBranyyContainer"></div>
        </div>
    <!-- 特殊分支 -->
        <div class="titleBranch">
            <h4>通天塔称号</h4>
            <div class="titleRow" id="towerBranchContainer"></div>
        </div>
    </div>
    <button onclick="closeTitleDialog()" style="margin-top: 20px;">关闭</button>
</div>
<div id="titleOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>


<!-- 官职系统界面 -->
<div id="officialSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="officialSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 2px solid #333; z-index: 1001; max-width: 90%; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; text-align: center;">官职系统</h3>
    
    <div style="margin-bottom: 15px;">
        当前官职: <span id="officialTitleDisplay">无</span> (等级 <span id="officialLevelDisplay">0</span>)
    </div>
    <div style="margin-bottom: 15px;">
        当前加成: 攻击总和提升 <span id="officialBonusDisplay">1</span> 倍
    </div>
    
    <div style="margin: 15px 0;">
        <h4>下一阶官职</h4>
        <div id="nextOfficialInfo">请升级官职</div>
    </div>
    
    <div style="margin: 15px 0;">
        <label for="officialUpgradeAmount">升级次数:</label>
        <input type="number" id="officialUpgradeAmount" value="1" min="1" style="width: 60px;">
        <button onclick="upgradeOfficialByAmount()">升级</button>
        <button onclick="upgradeOfficialMaxPossible()">一键升级</button>
    </div>
    
    <div style="margin-top: 20px; text-align: center;">
        <button onclick="toggleOfficialSystem()">关闭</button>
    </div>
</div>

<div id="companionSystem" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <!-- 标题栏（包含标题和关闭按钮） -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
        <h2 style="color: #4CAF50; margin: 0;">伴侣系统</h2>
        <button onclick="closeCompanionSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
      <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 伴侣等级与升级 -->
    <div style="margin: 15px 0; padding: 10px; background: #333; border-radius: 5px;">
        <h3>伴侣等级: Lv. <span id="companionLevel">1</span></h3>
        <p>升级消耗: <span id="upgradeCost">10</span> 玫瑰花</p>
        <button onclick="upgradeCompanion()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">升级</button>
      <button onclick="toggleExpeditionSystem()" style="margin-top: 15px; background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">探险</button>
     <button onclick="toggleCompanionShop()" style="margin-top: 15px; background: #7417B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">伴侣商店</button>

</div> 
 
     <div style="flex: 1; min-width: 400px; background: #2a2a2a; padding: 10px; border-radius: 5px;">
        <h3>伴侣属性加成</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 0.9em;">
            <div>品质加成倍数: <span id="qualityMultiplier">1x</span></div>
            <div>攻击总和加成: <span id="attackTotalBonus">1x</span></div>
            <div>生命总和加成: <span id="healthTotalBonus">1x</span></div>
            <div>暴击率总和加成: <span id="critRateTotalBonus">1x</span></div>
            <div>爆伤总和加成: <span id="critDamageTotalBonus">1x</span></div>
            <div>连击总和加成: <span id="comboTotalBonus">0</span></div>
            <div>全属性总和加成: <span id="allStatsTotalBonus">1x</span></div>
</div>
</div>
</div>
    <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 伴侣宝箱 -->
    <div style="flex: 1; padding: 10px; background: #333; border-radius: 5px;">
        <h3>伴侣宝箱</h3>
        <p>当前钥匙: <span id="companionKeyCount">0</span></p>
        <button onclick="drawCompanion()" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启宝箱 (消耗1钥匙)</button>
    <div style="margin-top: 15px;">
    <h4>批量开启</h4>
    <button onclick="drawCompanionMultiple(10)" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启10次</button>
    <button onclick="drawCompanionMultiple(20)" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启20次</button>
</div>
     <div style="margin-top: 15px; padding: 10px; background: #333; border-radius: 5px; font-size: 12px;">
        <h4 style="margin-top: 0; font-size: 13px; color: #d4af37;">保底机制</h4>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
            <div>史诗(紫色): <span id="epicGuarantee">0</span>/100</div>
            <div>卓越(粉色): <span id="pinkGuarantee">0</span>/500</div>
            <div>完美(橙色): <span id="orangeGuarantee">0</span>/1000</div>
            <div>神赐(红色): <span id="redGuarantee">0</span>/5000</div>
        </div>
    </div>
    </div>
    
    <!-- 批量分解 -->
    <div style="flex: 1; padding: 10px; background: #333; border-radius: 5px;">
        <h3>批量分解</h3>
        <select id="decomposeRarity" style="padding: 5px; margin-right: 10px;">
            <option value="white">普通(白色)</option>
            <option value="blue">稀有(蓝色)</option>
            <option value="epic">史诗(紫色)</option>
            <option value="pink">卓越(粉色)</option>
            <option value="orange">完美(橙色)</option>
            <option value="red">神赐(红色)</option>
            <option value="angel">天使(彩色)</option>
            <option value="emyyyy">恶魔(深红色)</option>
           <option value="jlyyyy">精灵(绿色)</option>
        </select>
        <button onclick="batchDecompose()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">批量分解选中品阶(未锁定)</button>
<div style="flex: 1; padding: 10px; background: #333; border-radius: 5px; margin-top: 1px;">
    <h3>自动分解设置</h3>
    <select id="autoDecomposeBelowRarity" style="padding: 5px; margin-right: 10px;">
        <option value="white">普通(白色)及以下</option>
        <option value="blue">稀有(蓝色)及以下</option>
        <option value="epic">史诗(紫色)及以下</option>
        <option value="pink">卓越(粉色)及以下</option>
        <option value="orange">完美(橙色)及以下</option>
        <option value="red">神赐(红色)及以下</option>
        <option value="angel">天使(彩色)及以下</option>
        <option value="emyyyy">恶魔(深红色)及以下</option>
        <option value="jlyyyy">精灵(绿色)及以下</option>
    </select>
    <button id="toggleAutoDecompose" onclick="toggleAutoDecompose()" style="background: #ff9800; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">自动分解：关闭</button>
</div>
    </div>
</div>
    
    <!-- 伴侣列表 -->
    <div style="margin: 15px 0;">
        <h3>我的伴侣</h3>
        <div id="companionList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;max-height: 400px; overflow-y: auto;">
            <!-- 伴侣卡片会动态生成在这里 -->
        </div>
    </div>
  </div>  
 
<div id="towerUI" style="display: none; position: fixed; top: 20%; left: 20%; transform: translate(50%, -10%); width: 30%; max-width: 800px; background: #fff; border: 2px solid #333; border-radius: 10px; padding: 20px; z-index: 1000;">
    <!-- 右上角关闭按钮 -->
    <button onclick="toggleTowerUI()" style="position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
    <h3>通天塔</h3>
     <div>GPS加成: <span id="towerBonus">0%</span> (每层增加0.01倍)</div>
    <div class="player-info">
        <p>生命: <span id="towerPlayerHealth">0</span></p>
        <p>攻击: <span id="towerPlayerAttack">0</span></p>
        <p>暴击率: <span id="towerPlayerCritRate">0%</span></p>
        <p>爆伤: <span id="towerPlayerCritDamage">0%</span></p>
        <p>命中: <span id="towerPlayerAccuracy">0%</span></p>
        <p>闪避: <span id="towerPlayerDodge">0%</span></p>
    </div>
    <div class="monster-info">
        <p>当前层数: <span id="towerCurrentFloor">0</span></p>
        <p>怪物名称: <span id="towerMonsterName">无</span></p>
        <p>怪物品阶: <span id="towerMonsterRank">无</span></p>
        <p>怪物生命: <span id="towerMonsterHealth">0</span></p>
        <p>怪物攻击: <span id="towerMonsterAttack">0</span></p>
        <p>怪物词条: <span id="towerMonsterModifiers">无</span></p>
        <p>剩余复活次数: <span id="towerMonsterResurrections">20</span></p>
    </div>
    <div class="battle-controls">
        <button onclick="attackTowerMonster()">攻击</button>
        <button onclick="toggleTowerAutoAttack()">自动攻击: <span id="towerAutoAttackStatus">关</span></button>
    </div><h4>如果属性是初始没加成，打一次打怪模式恢复在重新点击通天塔</h4>
    <div class="battle-log" id="towerBattleLog"></div>
</div>
</div>
</div>


<!-- 奥秘系统界面 -->
<div id="mysterySystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="mysterySystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 2px solid #333; z-index: 1001; max-width: 90%; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; text-align: center;">奥秘系统</h3>
    
    <div style="margin-bottom: 15px;">
        当前奥秘: <span id="mysteryTitleDisplay">初级秘法师 1阶1级</span>
    </div>
    <div style="margin-bottom: 15px;">
        当前加成: GPS加成 <span id="mysteryBonusDisplay">1</span> 倍（每一阶生效）
    </div>
    <div style="margin-bottom: 15px;">
        当前经验: <span id="currentMysteryExp">0</span> / <span id="nextMysteryExp">1000</span>
    </div>
    <div style="margin-bottom: 15px;">
        每分钟经验获取: <span id="expPerMinute">0</span> (通天塔层数 × VIP等级)
    </div>
    
    <div style="margin: 15px 0;">
        <h4>下一等级</h4>
        <div id="nextMysteryInfo">初级秘法师 1阶2级 - 消耗: 1000经验</div>
    </div>
    
    <div style="margin: 15px 0;">
        <label for="mysteryUpgradeAmount">升级次数:</label>
        <input type="number" id="mysteryUpgradeAmount" value="1" min="1" style="width: 60px;">
        <button onclick="upgradeMysteryByAmount()">升级</button>
        <button onclick="upgradeMysteryMaxPossible()">一键升级</button>
    </div>
    
    <div style="margin-top: 20px; text-align: center;">
        <button onclick="toggleMysterySystem()">关闭</button>
    </div>
</div>
<!-- 基金系统界面 -->
<div id="fundSystem" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 800px; background: #fff; border: 2px solid #333; border-radius: 10px; padding: 20px; z-index: 1001;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2>基金系统</h2>
          <h3>投入的越多波动的幅度越大10-50%（按满仓算50%）。1分钟刷新一次 ，10分钟不能实时卖出，最后5分钟不能投入，如果跌到总价值20%以下 就全部没收清零。每次第一次购买净值会归为1，已购买后正常。</h3> <button onclick="resetFundData()" style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">重置基金</button>
        <button onclick="toggleFundSystem()" style="padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭</button>
     <button onclick="updateFundDisplay()" style="padding: 5px 10px; margin-right: 10px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">刷新</button>
    </div>
    
    <div style="max-height: 500px; overflow-y: auto; padding-right: 10px;">
        <div id="fundsContainer"></div>
    </div>
    
   <!-- 基金遮罩层 -->
<div id="fundOverlay" style="display: none;"></div>
</div><!-- 基金遮罩层 -->
<!-- 商店界面HTML (添加到body标签内任意位置) -->
<div id="shopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; border-radius: 10px; z-index: 1000; max-width: 500px; max-height: 80vh; overflow-y: auto;">
    <h2>商店</h2>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button onclick="buyChest(1)">普通宝箱（100金币）</button>
        <button onclick="buyChest(2)">高级宝箱（10钻石）</button>
        <button onclick="buyChest(3)">稀有宝箱（1钛晶石）</button>
        <button onclick="buyChest(4)">史诗宝箱（1星耀石）</button>
        <button onclick="buyChest(5)">传说宝箱（1宇宙石）</button>
        <button onclick="buyChest(6)">混沌宝箱（1超能石）</button>
        <button onclick="buyChest(7)">终焉宝箱（1异界石）</button>
        <button onclick="buyChest(8)">星辰宝箱（1星界石）</button>
        <button onclick="buyChest(9)">银河宝箱（1混沌石）</button>
        <button onclick="buyChest(10)">星云宝箱（1灵髓石）</button>
        <button onclick="buyChest(11)">鸿蒙宝箱（1幻空石）</button>
        <button onclick="buyChest(12)">太虚宝箱（1冥源石）</button>
        <button onclick="buyChest(13)">虚空宝箱（1虚空石）</button>
        <button onclick="buyChest(14)">时空宝箱（1时空石）</button>
        <button onclick="buyChest(15)">未来宝箱（1未来石）</button>
     <button onclick="buyMaterialChest()">材料宝箱（<span id="materialChestCost">1</span>钻石）</button>
    <button onclick="buyTechniqueChest()">功法秘籍宝箱（<span id="techniqueChestCost">1</span>转生币）</button>
    </div>
    <button onclick="toggleShopUI()" style="margin-top: 20px; padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭商店</button>
</div>
<!-- 半透明背景遮罩 (添加到body标签内) -->
<div id="shopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
<!-- 设置界面对话框 -->
<div id="settingsDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ccc; z-index: 1000; text-align: center;">
    <h3>游戏设置</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button onclick="showRenameDialog()">名字修改</button>
        <button onclick="showActivationCodeDialog()">激活码兑换</button>
        <button onclick="saveGame()">保存游戏</button>
        <button onclick="loadGame()">加载游戏</button>
        <button onclick="exportSave()">导出存档（自动复制）</button>        
        <button onclick="importSave()">导入存档</button>
        <button onclick="downloadSave()">下载TXT存档</button>
         <button onclick="importEncryptedSave()">导入TXT存档</button>
        <button onclick="resetGame()" style="background-color: #ff4444; color: white; border: none;">重置游戏</button>
    </div>
    <button onclick="toggleSettingsUI()">关闭设置</button>
</div>
<input type="file" id="fileInput" accept=".txt" style="display: none;">


<!-- 半透明遮罩层 -->
<div id="settingsOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
<!-- 新增合成面板HTML -->
<div id="combinePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; background: #333; border: 2px solid #9C27B0; border-radius: 10px; padding: 20px; z-index: 1001;">
    <button onclick="closeCombinePanel()" style="position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
    <h3 style="color: #fff; text-align: center;">伴侣合成</h3>
    
    <div style="display: flex; gap: 20px; margin: 20px 0;">
        <!-- 主伴侣选择 -->
        <div style="flex: 1;">
            <h4 style="color: #fff;">主伴侣</h4>
            <div id="mainCompanionSlot" style="background: #444; border-radius: 5px; padding: 10px; min-height: 150px;">
                <select id="mainCompanionSelect" style="width: 100%; padding: 5px; background: #555; color: white; border: 1px solid #666;">
                    <!-- 动态填充可选伴侣 -->
                </select>
                <div id="mainCompanionInfo" style="margin-top: 10px; color: #fff; font-size: 0.9em;">
                    <!-- 显示选中的主伴侣信息 -->
                </div>
            </div>
        </div>
        
        <!-- 合成图标 -->
        <div style="display: flex; align-items: center; justify-content: center;">
            <button onclick="combineCompanions()" style="background: #9C27B0; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 20px; cursor: pointer;">→</button>
        </div>
        
        <!-- 副伴侣选择 -->
        <div style="flex: 1;">
            <h4 style="color: #fff;">副伴侣</h4>
            <div id="secondaryCompanionSlot" style="background: #444; border-radius: 5px; padding: 10px; min-height: 150px;">
                <select id="secondaryCompanionSelect" style="width: 100%; padding: 5px; background: #555; color: white; border: 1px solid #666;">
                    <!-- 动态填充可选伴侣 -->
                </select>
                <div id="secondaryCompanionInfo" style="margin-top: 10px; color: #fff; font-size: 0.9em;">
                    <!-- 显示选中的副伴侣信息 -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 合成预览 -->
    <div style="background: #444; border-radius: 5px; padding: 10px; margin: 10px 0;">
        <h4 style="color: #fff; margin-top: 0;">合成预览</h4>
        <div id="combinePreview" style="color: #fff; font-size: 0.9em;">
            <p>选择主副伴侣查看合成预览</p>
            <p>新一代数: <span id="previewGeneration">--</span></p>
            <p>预计天赋数量: <span id="previewTalentCount">--</span></p>
            <p>预计品质: <span id="previewRarity" style="color: #ff00ff;">天使(彩色)丶</span> <span id="previewRarity" style="color: #E63946;">恶魔(深红色)丶</span> <span id="previewRarity" style="color: #7CFC00;">精灵(绿色)</span></p>
            <p>预计评分范围: <span id="previewScoreRange">--</span></p>
            <p>品质加成倍数: <span id="previewQualityMultiplier">--</span></p>
        </div>
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="combineCompanions()" style="background: #9C27B0; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">确认合成</button>
        <p style="color: #ff4444; font-size: 0.8em; margin-top: 10px;">注意: 合成将消耗主副两只伴侣，且结果随机！</p>
    </div>
</div>
<div id="autoBuyShopa" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1000; max-height: 80vh; overflow-y: auto; width: 500px;">
    <h3>轮回BOSS副本</h3>
    <div class="auto-buy-container">
    <button onclick="toggleBlackDragonAbyss()" style="margin-left: 10px; background: linear-gradient(to bottom, #2c003e, #0f0024); color: #ffd700; border: 1px solid #8a2be2; box-shadow: 0 0 10px #8a2be2;">黑龙潭副本</button>
     <button onclick="toggleHolyBeastIsland()" style="background: linear-gradient(to bottom, #ff0000, #8b0000); color: #ffd700; border: 2px solid #ff4500; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; text-shadow: 0 0 5px #ff0000; box-shadow: 0 0 10px #ff0000;">圣兽岛副本</button>
      <button onclick="togglePenglaiIsland()" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #8b4513; border: 2px solid #ffd700; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; text-shadow: 0 0 5px #ffd700; box-shadow: 0 0 10px #ffd700; margin-left: 10px;">蓬莱仙岛副本</button>   
    </div>
    <button onclick="toggleAutoBuyShopa()" style="margin-top: 15px;">关闭界面</button>
</div>

<!-- 新增自动购买商店界面 -->
<div id="autoBuyShop" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1000; max-height: 80vh; overflow-y: auto; width: 500px;">
    <h3>自动购买设置</h3>
    <div class="auto-buy-container">
        <button id="autoChest1" class="auto-buy-btn" onclick="toggleAutoBuy(1)">普通宝箱自动购买：关闭</button>
        <button id="autoChest2" class="auto-buy-btn" onclick="toggleAutoBuy(2)">高级宝箱自动购买：关闭</button>
        <button id="autoChest3" class="auto-buy-btn" onclick="toggleAutoBuy(3)">稀有宝箱自动购买：关闭</button>
        <button id="autoChest4" class="auto-buy-btn" onclick="toggleAutoBuy(4)">史诗宝箱自动购买：关闭</button>
        <button id="autoChest5" class="auto-buy-btn" onclick="toggleAutoBuy(5)">传说宝箱自动购买：关闭</button>
        <button id="autoChest6" class="auto-buy-btn" onclick="toggleAutoBuy(6)">混沌宝箱自动购买：关闭</button>
        <button id="autoChest7" class="auto-buy-btn" onclick="toggleAutoBuy(7)">终焉宝箱自动购买：关闭</button>
        <button id="autoChest8" class="auto-buy-btn" onclick="toggleAutoBuy(8)">星辰宝箱自动购买：关闭</button>
        <button id="autoChest9" class="auto-buy-btn" onclick="toggleAutoBuy(9)">银河宝箱自动购买：关闭</button>
        <button id="autoChest10" class="auto-buy-btn" onclick="toggleAutoBuy(10)">星云宝箱自动购买：关闭</button>
        <button id="autoChest11" class="auto-buy-btn" onclick="toggleAutoBuy(11)">鸿蒙宝箱自动购买：关闭</button>
        <button id="autoChest12" class="auto-buy-btn" onclick="toggleAutoBuy(12)">太虚宝箱自动购买：关闭</button>
        <button id="autoChest13" class="auto-buy-btn" onclick="toggleAutoBuy(13)">虚空宝箱自动购买：关闭</button>
        <button id="autoChest14" class="auto-buy-btn" onclick="toggleAutoBuy(14)">时空宝箱自动购买：关闭</button>
        <button id="autoChest15" class="auto-buy-btn" onclick="toggleAutoBuy(15)">未来宝箱自动购买：关闭</button>
        <button id="autoMaterialChest" class="auto-buy-btn" onclick="toggleAutoBuyMaterialChest()">材料宝箱自动购买：关闭</button>
        <button id="autoTechniqueChest" class="auto-buy-btn" onclick="toggleAutoBuyTechniqueChest()">功法秘籍宝箱自动购买：关闭</button>
    </div>
    <button onclick="toggleAutoBuyShop()" style="margin-top: 15px;">关闭商店</button>
     <button onclick="toggleAutoBuySettings()">功法秘籍自动购买设置</button>
</div>
<!-- 自动兑换货币界面 -->
<div id="autoConvertUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #3498db; border-radius: 10px; z-index: 1000; max-width: 500px; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; color: #3498db; text-align: center;">自动兑换设置</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
        <button id="autoConvertGold" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('gold')">金币自动兑换：关闭</button>
        <button id="autoConvertDiamond" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('diamond')">钻石自动兑换：关闭</button>
        <button id="autoConvertTitanium" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('titanium')">钛晶石自动兑换：关闭</button>
        <button id="autoConvertStarstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('starstone')">星耀石自动兑换：关闭</button>
        <button id="autoConvertCosmicstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('cosmicstone')">宇宙石自动兑换：关闭</button>
        <button id="autoConvertSuperstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('superstone')">超能石自动兑换：关闭</button>
        <button id="autoConvertOtherworldstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('otherworldstone')">异界石自动兑换：关闭</button>
        <button id="autoConvertXingjiestone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('xingjiestone')">星界石自动兑换：关闭</button>
        <button id="autoConvertHundunstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('hundunstone')">混沌石自动兑换：关闭</button>
        <button id="autoConvertLingtone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('lingtone')">灵髓石自动兑换：关闭</button>
        <button id="autoConvertHuangtone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('huangtone')">幻空石自动兑换：关闭</button>
        <button id="autoConvertMingtone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('mingtone')">冥源石自动兑换：关闭</button>
        <button id="autoConvertXutong" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('xutong')">虚空石自动兑换：关闭</button>
        <button id="autoConvertShitone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('shitone')">时空石自动兑换：关闭</button>
    </div>
    <div style="text-align: center; margin-top: 15px;">
        <button onclick="toggleAutoConvertUI()" style="background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">关闭</button>
    </div>
</div>

<!-- 半透明遮罩层 -->
<div id="autoConvertOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
<!-- 新增洗练面板HTML -->
<div id="washPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: #333; border: 2px solid #2196F3; border-radius: 10px; padding: 20px; z-index: 1001;">
    <button onclick="closeWashPanel()" style="position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
    <h3 style="color: #fff; text-align: center;">伴侣洗练</h3>
    
    <div id="washCompanionInfo" style="background: #444; border-radius: 5px; padding: 10px; margin: 15px 0;">
        <!-- 伴侣信息将在这里动态填充 -->
    </div>
    
    <div style="margin: 15px 0; color: #fff;">
        <p>基础洗练消耗：1 洗髓丹</p>
        <p>每锁定一个天赋额外消耗：2 洗髓丹</p>
        <p>当前洗髓丹数量：<span id="rebornDanCount">0</span></p>
        <p id="totalWashCost">本次洗练总消耗：1 洗髓丹</p>
    </div>
    <!-- 天赋列表与锁定选项 -->
    <div id="talentList" style="background: #444; border-radius: 5px; padding: 10px; margin: 15px 0; max-height: 200px; overflow-y: auto;">
        <!-- 天赋和锁定复选框将在这里动态生成 -->
    </div>

    
    <div id="washResult" style="background: #444; border-radius: 5px; padding: 10px; margin: 15px 0; min-height: 60px;max-height: 200px ;overflow-y: auto;  color: #fff; display: none;">
        <!-- 洗练结果将在这里动态显示 -->
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="washCompanion()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">确认洗练</button>
    </div>
</div>
<div id="fishingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="fishingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #f0f8ff; padding: 20px; border: 3px solid #4682b4; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <!-- 标题栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #4682b4; padding-bottom: 10px;">
        <h2 style="color: #1e3a8a; margin: 0;">钓鱼系统</h2>
        <button onclick="toggleFishingSystem()" style="background: #ff4444; color: white; border: none; border-radius: 5px; padding: 5px 10px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 钓鱼信息 -->
    <div style="margin-bottom: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div>
                <strong>钓鱼等级: </strong><span id="fishingLevel">1</span>
            </div>
            <div>
                <strong>当前经验: </strong><span id="currentFishingExp">0</span>/<span id="nextFishingExp">500</span>
            </div>
            <div>
                <strong>点击收益加成: </strong><span id="fishingBonus">1</span>
            </div>
        </div>
        <div style="margin-top: 10px;">
            <strong>鱼饵数量: </strong><span id="baitCount">0</span>
        </div>
    </div>
    
    <!-- 钓鱼区域 -->
    <div style="background: #87ceeb; height: 200px; border-radius: 8px; margin-bottom: 20px; position: relative; overflow: hidden;">
        <div id="fishingPond" style="width: 100%; height: 100%; position: relative;">
            <!-- 水面效果 -->
            <div style="position: absolute; bottom: 0; width: 100%; height: 120px; background: #1e90ff; opacity: 0.7; border-top: 2px dashed #4682b4;"></div>
            
            <!-- 鱼竿 -->
            <div id="fishingRod" style="position: absolute; bottom: 120px; left: 50px; width: 150px; height: 10px; background: #8b4513; transform-origin: left center; transform: rotate(-30deg); display: none;">
                <div style="position: absolute; right: 0; width: 20px; height: 20px; background: #ffd700; border-radius: 50%;"></div>
            </div>
            
            <!-- 浮标 -->
            <div id="fishingBobber" style="position: absolute; bottom: 130px; left: 180px; width: 15px; height: 15px; background: #ff4500; border-radius: 50%; display: none;"></div>
            
            <!-- 鱼咬钩动画区域 -->
            <div id="biteIndicator" style="position: absolute; bottom: 120px; left: 180px; color: white; font-weight: bold; display: none; text-shadow: 0 0 5px #000;">
                鱼咬钩了！快拉！
            </div>
            
            <!-- 状态文本 -->
            <div id="fishingStatus" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: #1e3a8a; font-weight: bold;">
                点击"开始钓鱼"按钮开始
            </div>
        </div>
    </div>
    
    <!-- 钓鱼控制按钮 -->
    <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
        <button id="startFishingBtn" onclick="startFishing()" style="background: #228b22; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">开始钓鱼</button>
        <button id="reelInBtn" onclick="reelInFish()" style="background: #d2691e; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; display: none;">拉钩上钓</button>
     <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
    <button id="autoFishingBtn" onclick="toggleAutoFishing()" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">
        自动钓鱼: 关闭
    </button>
    <button id="autoDecomposeFishBtn" onclick="toggleAutoDecomposeFish()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">
        自动分解: 关闭
    </button>
</div>
    </div>
    
    <!-- 鱼笼信息 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #1e3a8a; border-bottom: 1px solid #4682b4; padding-bottom: 5px;">鱼笼 (<span id="cageCount">0</span>/20)</h3>
        <div id="fishCage" style="background: white; padding: 10px; border-radius: 8px; max-height: 200px; overflow-y: auto; border: 1px solid #ddd; display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
            <!-- 鱼会动态显示在这里 -->
            <div style="grid-column: 1 / -1; text-align: center; color: #666;">鱼笼是空的，快去钓鱼吧！</div>
        </div>
    </div>
    
    <!-- 分解按钮 -->
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="decomposeSelectedFish()" style="background: #8b0000; color: white; border: none; padding: 10px 30px; border-radius: 5px; cursor: pointer; font-size: 16px;">分解选中的鱼获</button>
    </div>
</div>
<!-- 农场系统界面 -->
<div id="farmSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="farmSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
        <h2 style="color: #4CAF50; margin: 0;">农场系统</h2>
        <button onclick="closeFarmSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 农场信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between;">
            <div>
                <strong>农场等级:</strong> <span id="farmLevel">1</span>
                <strong>经验:</strong> <span id="farmExp">0</span>/<span id="farmExpNext">100</span>
            </div>
            <div>
                <strong>农田数量:</strong> <span id="farmFieldCount">2</span>/<span id="farmMaxFields">5</span>
            </div>
            <div>
                <strong>水滴:</strong> <span id="waterCount">10</span>
            </div>
        </div>
    </div>
    
    <!-- 农田区域 -->
    <div style="margin-bottom: 20px;">
        <h3>农田</h3>
        <div id="farmFields" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 10px;">
            <!-- 农田地块将动态生成 -->
        </div>
    </div>
    
    <!-- 种子仓库 -->
    <div style="margin-bottom: 20px;">
        <h3>种子仓库</h3>
        <div id="seedInventory" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 10px; max-height: 200px; overflow-y: auto;">
            <!-- 种子将动态生成 -->
        </div>
    </div>
    
    <!-- 操作按钮 -->
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="waterAllCrops()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">一键浇水</button>
        <button onclick="harvestAllCrops()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">一键收获</button>

    <button id="autoPlantBtn" onclick="toggleAutoPlant()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">自动种植: 关闭</button>
    <button id="autoHarvestBtn" onclick="toggleAutoHarvest()" style="background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">自动收获: 关闭</button>
    </div>
</div>
<!-- 停车位系统界面 -->
<div id="parkingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="parkingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <!-- 标题栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
        <h2 style="color: #4CAF50; margin: 0;">停车位系统</h2>
        <button onclick="closeParkingSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 停车位信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div>
                <strong>停车位等级:</strong> <span id="parkingLevel">1</span>
            </div>
            <div>
                <strong>停车位数量:</strong> <span id="parkingSpotCount">1</span>/<span id="maxParkingSpots">5</span>
            </div>
            <div>
                <strong>停车经验:</strong> <span id="parkingExp">0</span>/<span id="nextLevelExp">150</span>
            </div>
            <div>
                <strong>总收益:</strong> <span id="totalParkingIncome">0</span> 转生币
            </div>
        </div>
        <button onclick="upgradeParking()" style="margin-top: 10px; background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">升级停车位 (消耗经验)</button>
    </div>
    
    <!-- 车辆管理 -->
    <div style="margin-bottom: 20px;">
        <h3>我的车辆</h3>
        <div id="vehicleList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; padding: 10px; background: #333; border-radius: 5px;">
            <!-- 车辆卡片会动态生成在这里 -->
        </div>
    </div>
    
    <!-- 停车操作 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>停车操作</h3>
        <div id="parkingSpotsContainer" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin: 10px 0; max-height: 400px; overflow-y: auto; ">
            <!-- 停车位会动态生成在这里 -->
        </div>
        <div>
            <button onclick="parkAllVehicles()" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; margin-right: 10px;">一键停车</button>
            <button onclick="collectAllParkingIncome()" style="background: #FFC107; color: black; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">收取所有收益</button>
                       
        </div>
    </div>
    
    <!-- 车辆分解 -->
    <div style="background: #333; padding: 15px; border-radius: 8px;">
    <h3>车辆分解</h3>
    <p>选择车辆进行分解，获得转生币</p>
    
    <!-- 批量选择选项 -->
    <div style="margin-bottom: 10px;">
        <strong>批量选择:</strong>
        <button onclick="selectByRarity(5)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">5稀有度以下</button>
        <button onclick="selectByRarity(10)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">10稀有度以下</button>
        <button onclick="selectByRarity(15)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">15稀有度以下</button>
        <button onclick="selectByRarity(20)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">20稀有度以下</button>
        <button onclick="selectByRarity(30)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">30稀有度以下</button>
        <button onclick="selectByRarity(35)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">35稀有度以下</button>
        <button onclick="selectAllVehicles()" style="margin: 2px; padding: 3px 6px; font-size: 12px;">全选</button>
        <button onclick="deselectAllVehicles()" style="margin: 2px; padding: 3px 6px; font-size: 12px;">全不选</button>
    </div>
    
    <div id="decomposeVehicleContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;max-height: 400px; overflow-y: auto;">
        <!-- 分解界面会动态生成在这里 -->
    </div>
    <button onclick="decomposeSelectedVehicle()" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">分解选中车辆</button>
</div>
</div>
<!-- 星域探索系统界面 -->
<div id="explorationSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="explorationSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #0a0a2a; color: white; padding: 20px; border: 3px solid #4a86e8; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4a86e8; padding-bottom: 10px;">
        <h2 style="color: #4a86e8; margin: 0;">星域探索系统</h2>
        <button onclick="toggleExplorationSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    <div style="text-align: center; margin-top: 15px;">
    <button onclick="toggleExchangeShop()" style="background: #FFD700; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">兑换商店</button>
</div>

    <!-- 舰队属性 -->
    <div style="margin-bottom: 20px; background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">舰队属性</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 15px;">
           <div class="attribute-card">
    <div class="attribute-icon" style="background: linear-gradient(to bottom, #ff9900, #ff6600);">⏱️</div>
    <div class="attribute-info">
        <strong>速度</strong>
        <div>等级: <span id="speedLevel">1</span></div>
        <div>探索时间: <span id="explorationTime">60</span>分钟</div>
    </div>
    <button class="upgrade-btn" data-attr="speed" onclick="upgradeAttribute('speed')">升级</button>
</div>

<div class="attribute-card">
    <div class="attribute-icon" style="background: linear-gradient(to bottom, #00cc66, #00994d);">📦</div>
    <div class="attribute-info">
        <strong>容量</strong>
        <div>等级: <span id="capacityLevel">1</span></div>
        <div>资源获取: <span id="resourceGain">100%</span></div>
    </div>
    <button class="upgrade-btn" data-attr="capacity" onclick="upgradeAttribute('capacity')">升级</button>
</div>

<div class="attribute-card">
    <div class="attribute-icon" style="background: linear-gradient(to bottom, #9966ff, #6600cc);">🛡️</div>
    <div class="attribute-info">
        <strong>耐久</strong>
        <div>等级: <span id="durabilityLevel">1</span></div>
        <div>稀有率: <span id="rareRate">5%</span></div>
        <div>损坏率: <span id="damageRate">10%</span></div>
    </div>
    <button class="upgrade-btn" data-attr="durability" onclick="upgradeAttribute('durability')">升级</button>
</div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="upgradeAllAttributes()" style="background: #4a86e8; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer;">一键升级全部属性</button>
        </div>
    </div>
    
    <!-- 探索任务 -->
    <div style="margin-bottom: 20px; background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">探索任务</h3>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <div class="mission-card" data-difficulty="easy">
                <div class="mission-header">
                    <h4>近地星域</h4>
                    <span class="difficulty-tag">简单</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">60分钟</span></div>
                    <div>资源: 星尘发票</div>
                    <div>资源: 暗物质发票</div>
                    <div>损坏风险: <span class="damage-risk">10%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('easy')">开始探索</button>
            </div>
            
            <div class="mission-card" data-difficulty="medium">
                <div class="mission-header">
                    <h4>深空星域</h4>
                    <span class="difficulty-tag">中等</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">120分钟</span></div>
                    <div>资源: 星尘发票</div>
                    <div>资源: 暗物质发票</div>
                    <div>资源: 宇宙晶体发票</div>
                    <div>损坏风险: <span class="damage-risk">20%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('medium')">开始探索</button>
            </div>
            
            <div class="mission-card" data-difficulty="hard">
                <div class="mission-header">
                    <h4>黑洞边缘</h4>
                    <span class="difficulty-tag">困难</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">180分钟</span></div>
                    <div>资源: 星尘发票</div>
                    <div>资源: 暗物质发票</div>
                    <div>资源: 宇宙晶体发票</div>
                    <div>损坏风险: <span class="damage-risk">30%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('hard')">开始探索</button>
            </div>
            
            <div class="mission-card" data-difficulty="extreme">
                <div class="mission-header">
                    <h4>宇宙边缘</h4>
                    <span class="difficulty-tag">极限</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">240分钟</span></div>
                    <div>资源: 宇宙晶体发票</div>
                    <div>资源: 神器碎片发票</div>
                    <div>损坏风险: <span class="damage-risk">40%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('extreme')">开始探索</button>
            </div>
        </div>
    </div>
    
    <!-- 资源仓库 -->
    <div style="margin-bottom: 20px; background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">资源仓库</h3>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #cccccc, #999999);">✨</div>
                <div class="resource-info">
                    <strong>星尘</strong>
                    <div id="stardustCount">0</div>
                </div>
            </div>
            
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #333366, #000033);">🌌</div>
                <div class="resource-info">
                    <strong>暗物质</strong>
                    <div id="darkMatterCount">0</div>
                </div>
            </div>
            
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #66ccff, #3399ff);">💎</div>
                <div class="resource-info">
                    <strong>宇宙晶体</strong>
                    <div id="cosmicCrystalCount">0</div>
                </div>
            </div>
            
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #ffcc00, #ff9900);">🔱</div>
                <div class="resource-info">
                    <strong>神器碎片</strong>
                    <div id="artifactFragmentCount">0</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 探索日志 -->
    <div style="background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">探索日志</h3>
        <div id="explorationLog" style="height: 200px; overflow-y: auto; background: #0a0a1a; padding: 10px; border-radius: 5px; margin-top: 10px;">
            <div class="log-entry">欢迎使用星域探索系统！</div>
            <div class="log-entry">选择任务并开始探索宇宙奥秘吧！</div>
        </div>
    </div>
</div>
<!-- 神器锻造系统 -->
<div id="artifactSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="artifactSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #d4af37; padding-bottom: 10px;">
        <h2 style="color: #d4af37; margin: 0;">神器锻造系统</h2>
        <button onclick="toggleArtifactSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    

    <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 锻造区域 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">锻造神器</h3>
        <p>消耗10神器碎片随机锻造一件神器</p>
        <button onclick="forgeArtifact()" style="background: #d4af37; color: black; border: none; padding: 8px 20px; border-radius: 5px; cursor: font-weight: bold; margin-top: 10px;">锻造1次</button>
                       <button onclick="forgeArtifact(10)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造10次</button>
                <button onclick="forgeArtifact(20)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造20次</button>
                <button onclick="forgeArtifact(50)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造50次</button>
                <button onclick="forgeArtifact(100)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造100次</button>
    </div>
     <div style="margin-top: 0px; background: #444; padding: 15px; border-radius: 8px; width: 28%;">
        <h4 style="color: #d4af37; margin-top: 0;">进阶系统</h4>
        <h6 style="color: #d4af37; margin-top: 0;">下方神器仓库选择一个点击详情</h6>
        <div id="artifactAdvanceInfo">
            <!-- 进阶信息将动态填充 -->
        </div>
        <button id="advanceArtifactBtn" onclick="advanceArtifact()" style="margin-top: 10px; background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px;">进阶神器</button>
    </div>

     <div style="margin-top: 0px; background: #444; padding: 15px; border-radius: 8px; width: 28%;">
        <h7 style="color: #d4af37; margin-top: 0;"></h7>
        <h8 style="color: #d4af37; margin-top: 0;"></h8>
        </div> 
   </div>


    <!-- 装备部位 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d4af37; margin-top: 0;">装备部位</h3>
        <div id="artifactSlots" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
            <!-- 6个装备部位将动态生成 -->
        </div>
    </div>
    
    <!-- 神器仓库 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d4af37; margin-top: 0; overflow-y: auto;">神器仓库</h3>
    <div style="display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 1px solid #d4af37; padding-bottom: 10px; max-height: 400px; overflow-y: auto;">
    <div class="artifact-tab active" onclick="switchArtifactTab('all')">全部神器</div>
    <div class="artifact-tab" onclick="switchArtifactTab('sets')">按套装查看</div>
        <div id="artifactInventory" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-height: 400px; overflow-y: auto; padding: 10px; background: #333; border-radius: 8px;">
            <!-- 神器将动态生成 -->

</div>

<!-- 添加套装查看容器 -->
<div id="artifactSetsView" style="display: none;max-height: 400px; overflow-y: auto; padding: 10px; background: #333; border-radius: 8px;">
    <div id="artifactSetsContainer"></div>
</div>
        </div>
    </div>
   
    <!-- 套装效果 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">套装效果</h3>
        <div id="setBonuses">
            <!-- 套装效果将动态显示 -->
        </div>
    </div>
</div>
<!-- 杂货铺界面 -->
<div id="groceriesOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="groceriesUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; border-radius: 10px; z-index: 1001; width: 500px;">
    <h2>杂货铺</h2>
    <p>当前星尘: <span id="currentStardust">0</span></p>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>鱼饵</strong>
            <div>100星尘 → 2鱼饵</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="baitAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('bait')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>伴侣钥匙</strong>
            <div>200星尘 → 1钥匙</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="keyAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('key')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>玫瑰花</strong>
            <div>100星尘 → 20玫瑰花</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="roseAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('rose')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>VIP能力值</strong>
            <div>100星尘 → 10VIP能力值</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="vipAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('vip')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>神级宝石</strong>
            <div>5000星尘 → 1神级宝石</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="gemAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('gem')">兑换</button>
        </div>
    </div>
    <div class="exchange-item">
    <div class="exchange-info">
        <strong>灵根检测器</strong>
        <div>500星尘 → 1个</div>
    </div>
    <div class="exchange-controls">
        <input type="number" id="rootAmount" min="1" value="1" style="width: 60px;">
        <button onclick="exchangeStardust('root')">兑换</button>
    </div>
</div>
    <div class="exchange-item">
    <div class="exchange-info">
        <strong>血脉检测剂</strong>
        <div>500星尘 → 1个</div>
    </div>
    <div class="exchange-controls">
        <input type="number" id="bloodAmount" min="1" value="1" style="width: 60px;">
        <button onclick="exchangeStardust('blood')">兑换</button>
    </div>
</div>
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>转生币</strong>
            <div>100星尘 → 1000000转生币</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="coinAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('coin')">兑换</button>
        </div>
    </div>
    
    <button onclick="toggleGroceriesUI()" style="margin-top: 20px; padding: 8px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭</button>
</div>
<!-- 宝石系统界面 -->
<div id="gemSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="gemSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #d4af37; margin: 0;">宝石系统</h2>
        <button onclick="toggleGemSystem()" style="background: #ff4444; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 宝石商店 -->
    <div style="margin-bottom: 30px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">宝石商店</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
            <div class="gem-shop-item">
                <div class="gem-icon red">红</div>
                <div>红宝石 (攻击)</div>
                <div>价格: 100暗物质</div>
                <button onclick="buyGem('red', 1)">购买</button>
            </div>
            <div class="gem-shop-item">
                <div class="gem-icon blue">蓝</div>
                <div>蓝宝石 (生命)</div>
                <div>价格: 100暗物质</div>
                <button onclick="buyGem('blue', 1)">购买</button>
            </div>
            <div class="gem-shop-item">
                <div class="gem-icon black">黑</div>
                <div>黑宝石 (爆伤)</div>
                <div>价格: 100暗物质</div>
                <button onclick="buyGem('black', 1)">购买</button>

            </div>
        </div>
    </div>
    
    <!-- 宝石仓库 -->
    <div style="margin-bottom: 30px;">
        <h3 style="color: #d4af37; margin-top: 0;">宝石仓库</h3>
        <div id="gemInventory" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
            <!-- 宝石将动态生成在这里 -->
        </div>
    </div>
</div>
<!-- 修仙系统UI -->
<div id="cultivationSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="cultivationSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #4CAF50; margin: 0;">修仙系统</h2>
        <button onclick="toggleCultivationSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 当前灵根信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4CAF50; margin-top: 0;">当前灵根</h3>
        <div id="currentRootInfo" style="text-align: center; padding: 0px;">
            尚未检测灵根
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="openRootBox()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">开启灵根宝箱</button>
        </div>
    </div>
    <div style="margin-top: 0px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4CAF50; margin-top: 0;">当前血脉</h3>
        <div id="currentBloodlineInfo" style="text-align: center; padding: 0px;">
            尚未检测血脉
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="openBloodlineBox()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">开启血脉宝箱</button>
        </div>
    </div>
    <!-- 修仙阶段 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4CAF50; margin-top: 0;">修仙阶段</h3>
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div>境界等级: <span id="stageLevel">0</span></div>
        </div>
        <div style="margin-bottom: 10px;">
            <div>当前经验: <span id="currentExp">0</span></div>
            <div>升级所需: <span id="nextExp">1000</span></div>
      <div style="margin-top: 10px; background: #444; padding: 10px; border-radius: 5px;">
        <p>经验计算公式: (灵根加成 × 血脉加成) × 转生次数</p>
        <p>当前每分钟经验: <span id="currentExpPerMinute">0</span></p>
    </div>
</div>
        </div>
        <div class="exp-bar">
            <div id="expProgress" class="exp-progress" style="width: 0%;"></div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="upgradeCultivation()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">升级</button>
        </div>
    </div>
    
    <!-- 阶段加成 -->
    <div style="background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4CAF50; margin-top: 0;">阶段加成</h3>
        <div id="stageBonusInfo">
            当前加成: 点击收益+GPS × <span id="gpsMultiplier">1</span>
        </div>
    </div>
</div>

<!-- 灵根宝箱UI -->
<div id="rootBoxOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="rootBoxUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 400px; text-align: center;">
    <h3 style="color: #FFD700; margin-top: 0;">灵根宝箱</h3>
    <p>消耗1个灵根检测器开启宝箱</p>
    <div id="rootResult" style="margin: 20px 0; font-size: 18px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
        点击开启获取灵根
    </div>
    <button onclick="drawRoot()" style="background: #FFD700; color: black; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin-right: 10px;">开启宝箱</button>
    <button onclick="closeRootBox()" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">关闭</button>
</div>
<!-- 血脉宝箱UI -->
<div id="bloodlineBoxOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="bloodlineBoxUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 400px; text-align: center;">
    <h3 style="color: #FFD700; margin-top: 0;">血脉宝箱</h3>
    <p>消耗1个血脉检测剂开启宝箱</p>
    <div id="bloodlineResult" style="margin: 20px 0; font-size: 18px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
        点击开启获取血脉
    </div>
    <button onclick="drawBloodline()" style="background: #FFD700; color: black; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin-right: 10px;">开启宝箱</button>
    <button onclick="closeBloodlineBox()" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">关闭</button>
</div>
<!-- 伴侣探险系统UI -->
<div id="expeditionSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="expeditionSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #9C27B0; margin: 0;">伴侣探险</h2>
        <button onclick="toggleExpeditionSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 探险任务列表 -->
    <div style="margin-bottom: 20px;">
        <h3>探险任务（自动选择最高评分）</h3>
        <div id="expeditionTasks" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 10px;">
            <!-- 任务将动态生成 -->
        </div>
    </div>
    
    <!-- 当前探险状态 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>当前探险（评分有加成倍数）</h3>
        <div id="currentExpedition" style="margin-top: 10px;">
            <p>没有进行中的探险</p>
        </div>
    </div>
    
    <!-- 探险历史记录 -->
    <div style="margin-bottom: 20px;">
        <h3>探险记录</h3>
        <div id="expeditionHistory" style="max-height: 200px; overflow-y: auto; background: #333; padding: 10px; border-radius: 5px;">
            <!-- 记录将动态生成 -->
        </div>
    </div>
</div>
<!-- 藏宝图系统界面 -->
<div id="treasureMapSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureMapSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #d4af37; margin: 0;">藏宝图系统</h2>
        <button onclick="toggleTreasureMapSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 藏宝图钥匙信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">藏宝图钥匙</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>当前数量: <span id="treasureKeyCount">0</span></div>
            <button onclick="buyTreasureKey()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换钥匙 (100星尘)</button>
            <button onclick="buyTreasureKey1()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换钥匙 (100星币)</button>
            <button onclick="buyTreasureKey2()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换10个钥匙 (1000星币)</button>
            <button onclick="buyTreasureKey3()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换50个钥匙 (5000星币)</button>
        </div>
    </div>
    
    <!-- 开启藏宝图宝箱 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">开启藏宝图宝箱</h3>
        <p>消耗1个藏宝图钥匙随机获得一张藏宝图</p>
        <button onclick="openTreasureChest()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: font-weight: bold; margin-top: 10px;">开启宝箱</button>
          <button onclick="openTreasureChestBatch(10)" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开启10次</button>
    <button onclick="openTreasureChestBatch(20)" style="background: #FF9800; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开启20次</button>
    <button onclick="openTreasureChestBatch(50)" style="background: #F44336; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开启50次</button>
        <button onclick="openTreasureShop()" style="background: #9C27B0; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">藏宝图商店</button>
    </div>
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
    <h3 style="color: #d4af37; margin-top: 0;">藏宝图合成</h3>
    <p>将2张同等级同品质的藏宝图合成为1张更高品质的藏宝图</p>
    
    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
        <select id="craftLevel" style="padding: 5px; flex: 1;">
            <option value="1">一级藏宝图</option>
            <option value="2">二级藏宝图</option>
            <option value="3">三级藏宝图</option>
            <option value="4">四级藏宝图</option>
            <option value="5">五级藏宝图</option>
        </select>
        
        <select id="craftQuality" style="padding: 5px; flex: 1;">
            <option value="1">普通</option>
            <option value="2">精良</option>
            <option value="3">稀有</option>
            <option value="4">史诗</option>
            <option value="5">传说</option>
            <!-- 神话品质无法继续合成 -->
        </select>
    </div>
    
    <div style="margin-bottom: 10px;">
        当前拥有: <span id="craftCount">0</span> 张
    </div>
    
    <button onclick="craftTreasureMap()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; width: 100%;">合成</button>
    <button onclick="craftAllTreasureMaps()" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; width: 100%; margin-top: 10px;">一键合成全部</button>
</div>
    <!-- 我的藏宝图 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d4af37; margin-top: 0;">我的藏宝图（开宝图前建议打一下打怪模式刷新属性）</h3>
        <div id="treasureMapList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 300px; overflow-y: auto; padding: 10px; background: #333; border-radius: 5px;">
            <!-- 藏宝图卡片会动态生成在这里 -->
        </div>
    </div>
</div>
<div id="treasureBattleOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureBattleUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 600px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #d4af37; margin: 0;">宝藏守卫者</h2>
       <div id="treasureBattleStatus" style="color: #4CAF50; font-weight: bold;">战斗中...</div>
    </div>
    
    <div class="player-info">
        <p>生命: <span id="treasurePlayerHealth">0</span></p>
        <p>攻击: <span id="treasurePlayerAttack">0</span></p>
        <p>暴击率: <span id="treasurePlayerCritRate">0%</span></p>
        <p>爆伤: <span id="treasurePlayerCritDamage">0%</span></p>
    </div>
    
    <div class="monster-info">
        <p>怪物名称: <span id="treasureMonsterName">宝藏守卫者</span></p>
        <p>怪物品阶: <span id="treasureMonsterRank">无</span></p>
        <p>怪物生命: <span id="treasureMonsterHealth">0</span></p>
        <p>怪物攻击: <span id="treasureMonsterAttack">0</span></p>
        <p>怪物词条: <span id="treasureMonsterModifiers">无</span></p>
    </div>
    
    <div class="battle-controls">
        <button onclick="attackTreasureMonster()">攻击</button>
    </div>
    
    <div class="battle-log" id="treasureBattleLog" style="margin-top: 20px; height: 100px; overflow-y: auto; background: #333; padding: 10px; border-radius: 5px;"></div>
</div>

<!-- 藏宝图奖励界面 -->
<div id="treasureRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 500px;">
    <h2 style="color: #4CAF50; text-align: center; margin-top: 0;">藏宝图奖励</h2>
    <div id="treasureRewardContent" style="text-align: center; margin: 20px 0;">
        <!-- 奖励内容将在这里显示 -->
    </div>
    <button onclick="closeTreasureReward()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; display: block; margin: 0 auto;">关闭</button>
</div>
<!-- 夜店之王系统界面 -->
<div id="nightClubOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="nightClubUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 850px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #9C27B0; padding-bottom: 10px;">
        <h2 style="color: #9C27B0; margin: 0;">夜店之王</h2>
        <button onclick="toggleNightClubSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 店铺信息 -->
    <div style="margin-bottom: 20px; background: #222; padding: 15px; border-radius: 8px; border: 1px solid #444;">
        <div style="display: flex; justify-content: space-between;">
            <div>
                <strong>店铺等级:</strong> <span id="nightClubLevel">1</span>
                <div style="margin-top: 5px;">
                    <div class="progress-bar">
                        <div id="nightClubExpBar" class="progress-fill" style="width: 0%;"></div>
                    </div>
                    <div style="font-size: 0.9em; margin-top: 5px;">
                        经验: <span id="nightClubExp">0</span>/<span id="nightClubExpNext">100</span>
                    </div>
                </div>
            </div>
            <div style="text-align: right;">
                <strong>星币:</strong> <span id="starCoinCount">0</span>
                <div style="margin-top: 5px;">
                    <strong>每分钟收益:</strong>
                    <div>经验: <span id="expPerMinuteq">0</span></div>
                    <div>星币: <span id="coinsPerMinute">0</span></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 标签页 -->
    <div class="nightclub-tabs" style="display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 1px solid #444;">
        <button class="tablink active" onclick="openNightClubTab('staff')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">店员</button>
        <button class="tablink" onclick="openNightClubTab('equipment')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">设备</button>
        <button class="tablink" onclick="openNightClubTab('special')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">特殊人群</button>
        <button class="tablink" onclick="openNightClubTab('events')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">事件</button>
    </div>
    
    <!-- 店员标签页 -->
    <div id="nightClubStaff" class="nightclub-tabcontent">
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <!-- 店员卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 设备标签页 -->
    <div id="nightClubEquipment" class="nightclub-tabcontent" style="display:none;">
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <!-- 设备卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 特殊人群标签页 -->
    <div id="nightClubSpecial" class="nightclub-tabcontent" style="display:none;">
        <div style="background: #222; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <h3 style="margin-top: 0; color: #9C27B0;">VIP客人</h3>
            <p>VIP客人会定期光顾你的夜店，带来大量经验和星币！</p>
            <div id="vipInfo" style="margin-top: 10px;">
                <!-- VIP信息将动态显示 -->
            </div>
        </div>
    </div>
    
    <!-- 事件标签页 -->
    <div id="nightClubEvents" class="nightclub-tabcontent" style="display:none;">
        <div style="background: #222; padding: 15px; border-radius: 8px;">
            <h3 style="margin-top: 0; color: #9C27B0;">当前事件（消耗50-200星币）</h3>
            <div id="currentEvent" style="margin-bottom: 15px;">
                <!-- 当前事件将动态显示 -->
            </div>
            <button onclick="triggerRandomEventa()" style="background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">触发随机事件</button>
        </div>
    </div>
</div>
<!-- 玩家等级系统界面 -->
<div id="levelSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="levelSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 500px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #4CAF50; margin: 0;">玩家等级系统</h2>
        <button onclick="toggleLevelSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px;">
        <div>当前等级: <span id="currentPlayerLevel">1</span></div>
        <div>当前经验: <span id="currentPlayerExp">0</span>/<span id="nextLevelExpq">10000</span></div>
        <div>点击收益加成: <span id="clickBonus">0.01%</span></div>
        <div>每秒金币加成: <span id="gpsBonus">0.01</span></div>
         <div>飞升次数: <span id="ascentionCount">0</span></div>
        <div>飞升加成倍数: <span id="ascentionMultiplier">1</span></div>
        <div>下次飞升要求: <span id="nextAscentionRequirement">500</span>级</div>
         <div>轮回转生: <span id="ascentionCounta">0</span></div>
        <div>轮回加成倍数: <span id="ascentionMultipliera">1</span></div>
        <div>下次轮回要求: <span id="nextAscentionRequirementa">500</span>次飞升</div>
    </div>
    
    <div class="exp-bar" style="height: 20px; background: #333; border-radius: 10px; margin: 10px 0;">
        <div id="playerExpProgress" style="height: 100%; background: #4CAF50; border-radius: 10px; width: 0%;"></div>
    </div>
    
    <div style="margin: 15px 0;">
         <button onclick="ascendPlayer()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">飞升</button>
       <button onclick="ascendPlayera()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">轮回</button>
      <button onclick="toggleWingSystem()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">翅膀</button>
      <button onclick="toggleMountSystem()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">坐骑</button>
     <button onclick="toggleRuneSystem()"  style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">符文</button>
    </div>
</div>

<!-- 世界地图界面 -->
<div id="worldMapOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="worldMapUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">世界地图</h2> 
        <button onclick="toggleWorldMap()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    <!-- 次元难度选择器 -->
        <div class="dimension-selector">
            <h3>次元难度选择</h3>
            <div>
                <button class="dimension-btn active" onclick="changeDimension(1)">次元1</button>
                <button class="dimension-btn" onclick="changeDimension(2)">次元2</button>
                <button class="dimension-btn" onclick="changeDimension(3)">次元3</button>
                <button class="dimension-btn" onclick="changeDimension(4)">次元4</button>
                <button class="dimension-btn" onclick="changeDimension(5)">次元5</button>
            </div>
            <div class="dimension-info">
                当前难度: <span id="currentDimension">次元1</span><br>
                星币消耗: <span id="dimensionCost">1</span><br>
                经验倍数: <span id="dimensionExpMultiplier">1</span>倍<br>
                怪物攻击: <span id="dimensionAttackMultiplier">1</span>倍
            </div>
        </div>
    <div id="zoneList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
        <!-- 区域列表会动态生成 -->
    </div>
</div>

<!-- 战斗界面 -->
<div id="battleOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="battleUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FF4500; border-radius: 10px; z-index: 1001; width: 600px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FF4500; margin: 0;">战斗</h2>
        <button onclick="closeBattle()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    <div style="color: #FFD700; margin: 0;">
    星币: <span id="battleRebornDanCount">0</span>
    <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
        <div class="player-stats">
            <h3>玩家属性</h3>
            <div>生命: <span id="battlePlayerHealth">0</span></div>
            <div>攻击: <span id="battlePlayerAttack">0</span></div>
            <div>暴击率: <span id="battlePlayerCritRate">0%</span></div>
            <div>爆伤: <span id="battlePlayerCritDamage">0%</span></div>
        </div>
        
        <div class="monster-info">
    <p>怪物名称: <span id="battleMonsterName">无</span></p>
    <p>怪物词条: <span id="battleMonsterModifier">无</span></p>
    <p>怪物生命: <span id="battleMonsterHealth">0</span>/<span id="battleMonsterMaxHealth">0</span></p>
    <p>怪物攻击: <span id="battleMonsterAttack">0</span></p>
    <p>复活次数: <span id="battleMonsterResurrections">0</span>/3</p>
</div>
    </div>
    
    <div class="battle-controls" style="text-align: center; margin: 20px 0;">
<button onclick="toggleWorldMapAutoBattle()" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-right: 10px;">
    自动战斗: <span id="worldMapAutoBattleStatus">关闭</span>
</button>
    </div>
    
    <div id="addbattleLog" style="height: 200px; overflow-y: auto; background: #333; padding: 10px; border-radius: 5px; margin-top: 10px;">
        <!-- 战斗日志会动态显示 -->
    </div></div></div>
<!-- 直播系统UI -->
<div id="liveStreamSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="liveStreamSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #0f0f23; color: white; padding: 20px; border: 3px solid #ff00ff; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #ff00ff; padding-bottom: 10px;">
        <h2 style="color: #ff00ff; margin: 0;">直播系统</h2>
        <button onclick="toggleLiveStreamSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 直播状态和等级信息 -->
    <div style="margin-bottom: 20px; background: #1a1a2a; padding: 15px; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between;">
            <div>
                <strong>直播等级:</strong> <span id="liveStreamLevel">1</span>
                <strong>经验:</strong> <span id="liveStreamExp">0</span>/<span id="liveStreamNextExp">100</span>
            </div>
            <div>
                <strong>在线观众:</strong> <span id="liveViewerCount">0</span>
            </div>
            <div>
                <strong>粉丝数:</strong> <span id="totalLiveEarnings">0</span> 
            </div>
        </div>
        <div class="exp-bar" style="margin-top: 10px;">
            <div id="liveExpProgress" class="exp-progress" style="width: 0%;"></div>
        </div>
    </div>
    
    <!-- 直播控制 -->
    <div style="margin-bottom: 20px; text-align: center;">
        <button id="startLiveBtn" onclick="startLiveStream()" style="background: #ff00ff; color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">开始直播</button>
        <button id="boostLiveBtn" onclick="boostLiveStream()" style="background: #2196F3; color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-left: 10px;">推广流量 (1000星币)</button>
        <button id="giftBoxBtn" onclick="openGiftBox()" style="background: linear-gradient(to right, #ff9966, #ff5e62); color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-left: 10px; box-shadow: 0 4px 8px rgba(255, 94, 98, 0.4);">盲盒宝箱</button>
    </div>
    
    <!-- 直播内容区域 -->
    <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
        <!-- 直播窗口 -->
        <div style="background: #000; border-radius: 8px; overflow: hidden; position: relative;">
           <!-- 在直播窗口添加弹幕容器 -->
<div id="liveStreamVideo" style="height: 300px; background: linear-gradient(to bottom, #1a1a2a, #0f0f23); position: relative; overflow: hidden;">
    <div id="liveStatus" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #aaa; text-align: center; z-index: 1;">
        直播未开始
    </div>
    <div id="danmakuContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none;"></div>
</div>

<!-- 在直播控制区域添加弹幕控制 -->
<div style="margin-top: 10px; display: flex; justify-content: space-between;">
    <div>
        <label>
            <input type="checkbox" id="danmakuToggle" checked> 显示弹幕
        </label>
        <label style="margin-left: 10px;">
            速度: <input type="range" id="danmakuSpeed" min="1" max="10" value="5">
        </label>
    </div>
    <div>
        <label>
            密度: <input type="range" id="danmakuDensity" min="1" max="10" value="3">
        </label>
    </div>
</div>
            <div style="padding: 10px; background: #1a1a2a;">
                <h3 style="margin: 0; color: #ff00ff;">我的直播间</h3>
                <div style="display: flex; align-items: center; margin-top: 5px;">
                    <span style="background: #f44336; color: white; padding: 2px 6px; border-radius: 3px; font-size: 12px; margin-right: 10px;">LIVE</span>
                    <span id="liveTopic">转生大陆冒险日记</span>
                </div>
            </div>
        </div>
        
        <!-- 观众列表 -->
        <div style="background: #1a1a2a; border-radius: 8px; padding: 15px;">
            <h3 style="color: #ff00ff; margin-top: 0;">在线观众</h3>
            <div id="viewerList" style="max-height: 320px; overflow-y: auto;">
                <div style="text-align: center; color: #666; padding: 20px 0;">暂无观众</div>
            </div>
        </div>
    </div>
    
    <!-- 弹幕区域 -->
    <div style="margin-top: 20px; background: #1a1a2a; border-radius: 8px; padding: 15px;">
        <h3 style="color: #ff00ff; margin-top: 0;">弹幕互动</h3>
        <div id="danmakuContainerq" style="height: 200px; overflow-y: auto; background: #0a0a1a; border-radius: 5px; padding: 10px; margin-bottom: 10px;">
            <div class="danmaku-message">欢迎来到直播间！发送消息与其他观众互动吧！</div>
        </div>
        <div style="display: flex;">
            <input type="text" id="danmakuInput" placeholder="发送弹幕..." style="flex: 1; padding: 8px; border: 1px solid #444; border-radius: 3px; background: #0a0a1a; color: white;">
            <button onclick="sendDanmaku()" style="background: #ff00ff; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer; margin-left: 10px;">发送</button>
        </div>
    </div>
    
    <!-- 打赏记录 -->
    <div style="margin-top: 20px; background: #1a1a2a; border-radius: 8px; padding: 15px;">
        <h3 style="color: #ff00ff; margin-top: 0;">打赏记录</h3>
        <div id="donationHistory" style="max-height: 150px; overflow-y: auto;">
            <div style="text-align: center; color: #666; padding: 20px 0;">暂无打赏记录</div>
        </div>
    </div>
</div>
<!-- 盲盒宝箱模态框 -->
<div id="giftBoxModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center;">
    <div style="background: #1a1a2a; border-radius: 15px; padding: 30px; width: 80%; max-width: 600px; text-align: center; border: 3px solid #ff9966; box-shadow: 0 0 30px rgba(255, 153, 102, 0.6);">
        <h2 style="color: #ff9966; margin-top: 0;">神秘盲盒宝箱</h2>
        <p style="color: #ccc;">花费 <span style="color: #2196F3; font-weight: bold;">500星币</span> 开启盲盒，有机会获得超值礼物！</p>
        
        <div id="giftBox" style="position: relative; width: 200px; height: 200px; margin: 20px auto; perspective: 1000px;">
            <div id="boxInner" style="position: relative; width: 100%; height: 100%; transform-style: preserve-3d; transition: transform 1s;">
                <div style="position: absolute; width: 100%; height: 100%; backface-visibility: hidden; background: linear-gradient(135deg, #ff9966, #ff5e62); border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 24px; color: white; font-weight: bold; box-shadow: 0 10px 20px rgba(0,0,0,0.3);">
                    <div style="text-align: center;">
                        <div style="font-size: 40px;">🎁</div>
                        <div>点击开启</div>
                    </div>
                </div>
                <div id="giftResult" style="position: absolute; width: 100%; height: 100%; backface-visibility: hidden; background: linear-gradient(135deg, #5c6bc0, #3949ab); border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 24px; color: white; font-weight: bold; transform: rotateY(180deg); flex-direction: column; padding: 20px; box-sizing: border-box;">
                    <div id="giftIcon" style="font-size: 50px; margin-bottom: 15px;">🎁</div>
                    <div id="giftName" style="font-size: 24px; margin-bottom: 10px;">未知礼物</div>
                    <div id="giftValue" style="font-size: 20px;">价值: 0 玫瑰花</div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 20px;">
            <button onclick="drawGift()" style="background: linear-gradient(to right, #ff9966, #ff5e62); color: white; border: none; padding: 10px 30px; border-radius: 30px; cursor: pointer; font-size: 18px; font-weight: bold; box-shadow: 0 4px 8px rgba(255, 94, 98, 0.4);">开启盲盒 (500✨)</button>
            <button onclick="closeGiftBox()" style="background: #555; color: white; border: none; padding: 10px 30px; border-radius: 30px; cursor: pointer; font-size: 18px; margin-left: 15px;">关闭</button>
        </div>
        
        <div style="margin-top: 30px; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px;">
            <h3 style="color: #ff9966; margin-top: 0;">奖品概率</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: left;">
                <div><span style="color: #4CAF50;">鲜花:</span> 70% (10,000)</div>
                <div><span style="color: #2196F3;">墨镜:</span> 19.889% (25,000)</div>
                <div><span style="color: #FFC107;">礼花筒:</span> 7% (50,000)</div>
                <div><span style="color: #E91E63;">比心兔兔:</span> 3% (100,000)</div>
                <div><span style="color: #9C27B0;">热气球:</span> 0.1% (520,000)</div>
                <div><span style="color: #FF5722;">跑车:</span> 0.01% (1,200,000)</div>
                <div><span style="color: #00BCD4;">嘉年华:</span> 0.001% (2,800,000)</div>
            </div>
        </div>
    </div>
</div>
<!-- 翅膀系统界面 -->
<div id="wingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="wingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">翅膀系统</h2>
        <button onclick="toggleWingSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 当前装备的翅膀 -->
    <div id="equippedWing" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 5px;">
        <h3>当前装备的翅膀</h3>
        <div id="currentWingInfo">无</div>
    </div>
    
    <!-- 翅膀等级和升级 -->
    <div style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 5px;">
        <h3>翅膀等级系统</h3>
        <div>当前翅膀等级: <span id="wingLevel">1</span></div>
        <div>翅膀属性加成: <span id="wingBonus">10%</span></div>
        <div>升级所需黑龙王翅膀: <span id="wingUpgradeCost">5</span>个</div>
        <button onclick="upgradeWing()" style="margin-top: 10px;">升级翅膀</button>
    </div>
    
    <!-- 翅膀仓库和筛选功能 -->
    <div style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">翅膀仓库</h3>
            <div>
                <select id="wingRarityFilter" onchange="filterWings()" style="padding: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 3px;">
                    <option value="all">全部品质</option>
                    <option value="劣质级">劣质级</option>
                    <option value="普通级">普通级</option>
                    <option value="优秀级">优秀级</option>
                    <option value="精良级">精良级</option>
                    <option value="卓越级">卓越级</option>
                    <option value="史诗级">史诗级</option>
                    <option value="传说级">传说级</option>
                    <option value="神圣级">神圣级</option>
                    <option value="不朽级">不朽级</option>
                </select>
                <button onclick="decomposeAllFilteredWings()" style="margin-left: 10px; background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">一键分解</button>
            </div>
        </div>
        <div id="wingInventory" style="max-height: 300px; overflow-y: auto; border: 1px solid #555; padding: 10px;">
            <!-- 翅膀列表将在这里显示 -->
        </div>
    </div>
</div>
<!-- 添加坐骑系统界面 -->
<div id="mountSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="mountSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #8B4513; border-radius: 10px; z-index: 1001; width: 700px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #8B4513; margin: 0;">坐骑系统</h2>
        <button onclick="toggleMountSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 当前装备的坐骑 -->
    <div id="equippedMount" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 5px;">
        <h3>当前装备的坐骑</h3>
        <div id="currentMountInfo">无</div>
    </div>
    
    <!-- 坐骑等级和升级 -->
    <div style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 5px;">
        <h3>坐骑等级系统</h3>
        <div>当前坐骑等级: <span id="mountLevel">1</span></div>
        <div>坐骑属性加成: <span id="mountBonus">100%</span></div>
        <div>升级所需远古圣兽精魄: <span id="mountUpgradeCost">5</span>个</div>
        <button onclick="upgradeMount()" style="margin-top: 10px;">升级坐骑</button>
    </div>
    
    <!-- 坐骑仓库和筛选功能 -->
    <div style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">坐骑仓库</h3>
            <div>
                <select id="mountRarityFilter" onchange="filterMounts()" style="padding: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 3px;">
                    <option value="all">全部品质</option>
                    <option value="劣质级">劣质级</option>
                    <option value="普通级">普通级</option>
                    <option value="优秀级">优秀级</option>
                    <option value="精良级">精良级</option>
                    <option value="卓越级">卓越级</option>
                    <option value="史诗级">史诗级</option>
                    <option value="传说级">传说级</option>
                    <option value="神圣级">神圣级</option>
                    <option value="不朽级">不朽级</option>
                </select>
                <button onclick="decomposeAllFilteredMounts()" style="margin-left: 10px; background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">一键分解</button>
            </div>
        </div>
        <div id="mountInventory" style="max-height: 300px; overflow-y: auto; border: 1px solid #555; padding: 10px;">
            <!-- 坐骑列表将在这里显示 -->
        </div>
    </div>
</div>
<!-- 符文系统界面 -->
<div id="runeSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(75, 0, 130, 0.9); z-index: 1020;"></div>
<div id="runeSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #4b0082, #2e0854); color: #e6e6fa; padding: 25px; border: 3px solid #9370db; border-radius: 15px; box-shadow: 0 0 30px #8a2be2, inset 0 0 20px #4b0082; z-index: 1021; width: 800px; max-height: 90vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #9370db; padding-bottom: 10px;">
        <h2 style="color: #e6e6fa; margin: 0; text-shadow: 0 0 10px #8a2be2;">符文系统</h2>
        <button onclick="toggleRuneSystem()" style="background: #9370db; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 材料显示 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d8bfd8; border-bottom: 1px solid #9370db; padding-bottom: 5px;">符文材料</h3>
        <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 10px;">
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #ffd700;">
                <div>金</div>
                <div id="runeMaterialGold">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #32cd32;">
                <div>木</div>
                <div id="runeMaterialWood">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #1e90ff;">
                <div>水</div>
                <div id="runeMaterialWater">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #ff4500;">
                <div>火</div>
                <div id="runeMaterialFire">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #daa520;">
                <div>土</div>
                <div id="runeMaterialEarth">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #f0e68c;">
                <div>光</div>
                <div id="runeMaterialLight">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #483d8b;">
                <div>暗</div>
                <div id="runeMaterialDark">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #87ceeb;">
                <div>风</div>
                <div id="runeMaterialWind">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #add8e6;">
                <div>冰</div>
                <div id="runeMaterialIce">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #ffff00;">
                <div>电</div>
                <div id="runeMaterialElectric">0</div>
            </div>
        </div>
    </div>
    
    <!-- 符文合成区域 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d8bfd8; border-bottom: 1px solid #9370db; padding-bottom: 5px;">符文合成</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #9370db;">
                <h4 style="color: #e6e6fa; margin-top: 0;">选择5种材料</h4>
                <div id="runeMaterialSelection" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 10px;">
                    <!-- 材料选择按钮将通过JavaScript动态生成 -->
                </div>
                <button onclick="synthesizeRune()" style="background: linear-gradient(to bottom, #9370db, #6a5acd); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; width: 100%; font-size: 16px;">合成符文</button>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #9370db;">
                <h4 style="color: #e6e6fa; margin-top: 0;">当前选择</h4>
                <div id="selectedMaterials" style="min-height: 100px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; margin-bottom: 10px; border: 1px dashed #9370db;">
                    <!-- 已选材料将显示在这里 -->
                </div>
                <div style="font-size: 12px; color: #d8bfd8;">
                    提示: 选择5种不同材料组合将生成不同属性的符文
                </div>
            </div>
        </div>
    </div>
    
    <!-- 装备的符文 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d8bfd8; border-bottom: 1px solid #9370db; padding-bottom: 5px;">已装备符文</h3>
        <div id="equippedRune" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 2px solid #ffd700; min-height: 100px;">
            <!-- 装备的符文信息将显示在这里 -->
        </div>
    </div>
    
    <!-- 符文背包 -->
    <div style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="color: #d8bfd8; margin: 0;">符文背包</h3>
            <div>
                <button onclick="decomposeAllRunes()" style="background: linear-gradient(to bottom, #dc143c, #8b0000); color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">一键分解</button>
                <button onclick="toggleRuneFilter()" id="runeFilterBtn" style="background: linear-gradient(to bottom, #9370db, #6a5acd); color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">显示全部</button>
            </div>
        </div>
        <div id="runeInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto;">
            <!-- 符文背包内容将通过JavaScript动态生成 -->
        </div>
    </div>
    
    <!-- 符文升级 -->
    <div>
        <h3 style="color: #d8bfd8; border-bottom: 1px solid #9370db; padding-bottom: 5px;">符文升级</h3>
        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #9370db;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div>当前符文等级: <span id="runeLevel">1</span></div>
                <div>升级消耗: <span id="runeUpgradeCost">10</span> 个秘法符文</div>
            </div>
            <button onclick="upgradeRune()" id="upgradeRuneBtn" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #4b0082; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; width: 100%; font-size: 16px; font-weight: bold;">升级符文 (提升100%属性)</button>
        </div>
    </div>
</div>










<!-- 在页面底部添加黑龙潭副本的HTML结构 -->
<div id="blackDragonAbyssOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="blackDragonAbyssUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a0825; color: #e0b0ff; padding: 20px; border: 3px solid #8a2be2; border-radius: 10px; box-shadow: 0 0 20px #8a2be2, inset 0 0 10px #4b0082; z-index: 1001; width: 700px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #8a2be2; padding-bottom: 10px;">
        <h2 style="color: #ffd700; margin: 0; text-shadow: 0 0 10px #ffd700;">黑龙潭副本</h2>
        <button onclick="toggleBlackDragonAbyss()" style="background: #8a2be2; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 20px; text-align: center;">
        <div style="font-size: 18px; color: #ff6347; margin-bottom: 10px;">副本令牌: <span id="dungeonTokenCount">0</span></div>
        <button onclick="startBlackDragonBattle()" id="startBattleBtn" style="background: linear-gradient(to bottom, #8b0000, #600000); color: #ffd700; border: 2px solid #ff0000; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; box-shadow: 0 0 10px #ff0000;">挑战黑龙王 (消耗1副本令牌)</button>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div class="battle-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #4b0082;">
            <h3 style="color: #ffd700; margin-top: 0; border-bottom: 1px solid #8a2be2; padding-bottom: 5px;">玩家属性</h3>
            <div>生命: <span id="bdaPlayerHealth">0</span></div>
            <div>攻击: <span id="bdaPlayerAttack">0</span></div>
            <div>暴击率: <span id="bdaPlayerCritRate">0%</span></div>
            <div>爆伤: <span id="bdaPlayerCritDamage">0%</span></div>
        </div>
        
        <div class="boss-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #4b0082;">
            <h3 style="color: #ff6347; margin-top: 0; border-bottom: 1px solid #ff0000; padding-bottom: 5px;">黑龙王属性</h3>
            <div>等级: <span id="bdaBossLevel">1</span></div>
            <div>生命: <span id="bdaBossHealth">0</span>/<span id="bdaBossMaxHealth">0</span></div>
            <div>攻击: <span id="bdaBossAttack">0</span></div>
            <div>复活次数: <span id="bdaBossResurrections">0</span>/10</div>
        </div>
    </div>
    
    <div class="battle-controls" style="text-align: center; margin: 20px 0;">
        <button onclick="attackBlackDragon()" id="attackBossBtn" style="display: none; background: linear-gradient(to bottom, #ff4500, #cc3700); color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px;">攻击</button>
        <button onclick="fleeBlackDragonBattle()" id="fleeBossBtn" style="display: none; background: linear-gradient(to bottom, #6a5acd, #483d8b); color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px;">逃跑</button>
    </div>
    
    <div id="bdaBattleLog" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace;"></div>
</div>

<!-- 奖励弹窗 -->
<div id="bdaRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1010;"></div>
<div id="bdaRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a0825; color: #e0b0ff; padding: 25px; border: 3px solid #ffd700; border-radius: 10px; box-shadow: 0 0 30px #ffd700, inset 0 0 15px #daa520; z-index: 1011; width: 500px; text-align: center;">
    <h2 style="color: #ffd700; margin-top: 0; text-shadow: 0 0 10px #ffd700;">挑战奖励</h2>
    <div style="margin: 20px 0; font-size: 18px;">
        <div>BOSS等级: <span id="rewardBossLevel">1</span></div>
        <div>奖励倍数: <span id="rewardMultiplier">1</span>x</div>
    </div>
    <div id="rewardItems" style="margin: 20px 0; text-align: left; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;"></div>
    <button onclick="closeBdaReward()" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #000; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px;">确认</button>
</div>
<!-- 圣兽岛副本界面 -->
<div id="holyBeastIslandOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(139, 0, 0, 0.9); z-index: 1000;"></div>
<div id="holyBeastIslandUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #8b0000, #450000); color: #ffd700; padding: 25px; border: 3px solid #ff4500; border-radius: 15px; box-shadow: 0 0 30px #ff0000, inset 0 0 20px #8b0000; z-index: 1001; width: 700px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #ff4500; padding-bottom: 10px;">
        <h2 style="color: #ffd700; margin: 0; text-shadow: 0 0 10px #ff0000;">圣兽岛副本</h2>
        <button onclick="toggleHolyBeastIsland()" style="background: #ff4500; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 20px;">
        <div style="font-size: 18px; color: #ff6347; margin-bottom: 10px;">
            副本令牌: <span id="hbiTokenCount">0</span>
        </div>
        <button onclick="startHolyBeastBattle()" id="startHbiBattleBtn" style="background: linear-gradient(to bottom, #ff0000, #8b0000); color: #ffd700; border: 2px solid #ff4500; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; text-shadow: 0 0 5px #ff0000; box-shadow: 0 0 15px #ff0000;">
            挑战上古火麒麟 (消耗1副本令牌)
        </button>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div class="hbi-player-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #ffd700;">
            <h3 style="color: #ffd700; margin-top: 0; border-bottom: 1px solid #ffd700; padding-bottom: 5px;">玩家属性</h3>
            <div>生命: <span id="hbiPlayerHealth">0</span></div>
            <div>攻击: <span id="hbiPlayerAttack">0</span></div>
            <div>暴击率: <span id="hbiPlayerCritRate">0%</span></div>
            <div>爆伤: <span id="hbiPlayerCritDamage">0%</span></div>
        </div>
        
        <div class="hbi-boss-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #ff4500;">
            <h3 style="color: #ff6347; margin-top: 0; border-bottom: 1px solid #ff4500; padding-bottom: 5px;">上古火麒麟</h3>
            <div>等级: <span id="hbiBossLevel">1</span></div>
            <div>生命: <span id="hbiBossHealth">0</span>/<span id="hbiBossMaxHealth">0</span></div>
            <div>攻击: <span id="hbiBossAttack">0</span></div>
            <div>复活次数: <span id="hbiBossResurrections">0</span>/10</div>
        </div>
    </div>
    
    <div class="hbi-battle-controls" style="text-align: center; margin: 20px 0;">
        <button onclick="attackHolyBeastBoss()" id="attackHbiBossBtn" style="display: none; background: linear-gradient(to bottom, #ff4500, #cc3700); color: white; border: none; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px; box-shadow: 0 0 10px #ff4500;">攻击</button>
        <button onclick="fleeHolyBeastBattle()" id="fleeHbiBossBtn" style="display: none; background: linear-gradient(to bottom, #8b0000, #600000); color: white; border: none; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; box-shadow: 0 0 10px #8b0000;">逃跑</button>
    </div>
    
    <div id="hbiBattleLog" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace; border: 1px solid #ff4500;"></div>
</div>

<!-- 圣兽岛奖励弹窗 -->
<div id="hbiRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(139, 0, 0, 0.95); z-index: 1010;"></div>
<div id="hbiRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #8b0000, #450000); color: #ffd700; padding: 30px; border: 3px solid #ffd700; border-radius: 15px; box-shadow: 0 0 40px #ffd700, inset 0 0 20px #daa520; z-index: 1011; width: 550px; text-align: center;">
    <h2 style="color: #ffd700; margin-top: 0; text-shadow: 0 0 15px #ffd700;">挑战奖励</h2>
    <div style="margin: 20px 0; font-size: 18px;">
        <div>BOSS等级: <span id="hbiRewardBossLevel">1</span></div>
        <div>奖励倍数: <span id="hbiRewardMultiplier">1</span>x</div>
    </div>
    <div id="hbiRewardItems" style="margin: 20px 0; text-align: left; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; border: 1px solid #ffd700;"></div>
    <button onclick="closeHbiReward()" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #8b0000; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 0 15px #ffd700;">确认</button>
</div>



<!-- 蓬莱仙岛副本界面 -->
<div id="penglaiIslandOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(75, 0, 130, 0.95); z-index: 1030;"></div>
<div id="penglaiIslandUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #2e0854, #1a0033); color: #d8bfd8; padding: 25px; border: 3px solid #4b0082; border-radius: 15px; box-shadow: 0 0 30px #4b0082, inset 0 0 20px #2e0854; z-index: 1031; width: 700px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #4b0082; padding-bottom: 10px;">
        <h2 style="color: #9370db; margin: 0; text-shadow: 0 0 10px #4b0082; font-family: '楷体', 'KaiTi', serif;">蓬莱仙岛副本</h2>
        <button onclick="togglePenglaiIsland()" style="background: #4b0082; color: #d8bfd8; border: 1px solid #9370db; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
    
    <div style="margin-bottom: 20px;">
        <div style="font-size: 18px; color: #9370db; margin-bottom: 10px; text-shadow: 0 0 5px #4b0082;">
            副本令牌: <span id="penglaiTokenCount" style="color: #ffd700;">0</span>
        </div>
        <button onclick="startPenglaiBattle()" id="startPenglaiBattleBtn" style="background: linear-gradient(to bottom, #4b0082, #2e0854); color: #ffd700; border: 2px solid #9370db; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; text-shadow: 0 0 5px #4b0082; box-shadow: 0 0 15px #4b0082;">
            挑战太古饕鬄 (消耗1副本令牌)
        </button>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div class="penglai-player-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #9370db;">
            <h3 style="color: #9370db; margin-top: 0; border-bottom: 1px solid #9370db; padding-bottom: 5px; text-shadow: 0 0 5px #4b0082;">玩家属性</h3>
            <div style="color: #d8bfd8;">生命: <span id="penglaiPlayerHealth" style="color: #ff6b6b;">0</span></div>
            <div style="color: #d8bfd8;">攻击: <span id="penglaiPlayerAttack" style="color: #ffa500;">0</span></div>
            <div style="color: #d8bfd8;">暴击率: <span id="penglaiPlayerCritRate" style="color: #00ff00;">0%</span></div>
            <div style="color: #d8bfd8;">爆伤: <span id="penglaiPlayerCritDamage" style="color: #ff00ff;">0%</span></div>
        </div>
        
        <div class="penglai-boss-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #8a2be2;">
            <h3 style="color: #8a2be2; margin-top: 0; border-bottom: 1px solid #8a2be2; padding-bottom: 5px; text-shadow: 0 0 5px #4b0082;">太古饕鬄</h3>
            <div style="color: #d8bfd8;">等级: <span id="penglaiBossLevel" style="color: #ffd700;">1</span></div>
            <div style="color: #d8bfd8;">生命: <span id="penglaiBossHealth" style="color: #ff6b6b;">0</span>/<span id="penglaiBossMaxHealth" style="color: #ff6b6b;">0</span></div>
            <div style="color: #d8bfd8;">攻击: <span id="penglaiBossAttack" style="color: #ffa500;">0</span></div>
            <div style="color: #d8bfd8;">复活次数: <span id="penglaiBossResurrections" style="color: #00ff00;">0</span>/10</div>
        </div>
    </div>
    
    <div class="penglai-battle-controls" style="text-align: center; margin: 20px 0;">
        <button onclick="attackPenglaiBoss()" id="attackPenglaiBossBtn" style="display: none; background: linear-gradient(to bottom, #8a2be2, #4b0082); color: #d8bfd8; border: 1px solid #9370db; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px; box-shadow: 0 0 10px #8a2be2;">攻击</button>
        <button onclick="fleePenglaiBattle()" id="fleePenglaiBossBtn" style="display: none; background: linear-gradient(to bottom, #4b0082, #2e0854); color: #d8bfd8; border: 1px solid #9370db; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; box-shadow: 0 0 10px #4b0082;">逃跑</button>
    </div>
    
    <div id="penglaiBattleLog" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace; border: 1px solid #4b0082; color: #d8bfd8;"></div>
</div>

<!-- 蓬莱仙岛奖励弹窗 - 深色版本 -->
<div id="penglaiRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(75, 0, 130, 0.98); z-index: 1040;"></div>
<div id="penglaiRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #2e0854, #1a0033); color: #d8bfd8; padding: 30px; border: 3px solid #9370db; border-radius: 15px; box-shadow: 0 0 40px #9370db, inset 0 0 20px #2e0854; z-index: 1041; width: 550px; text-align: center;">
    <h2 style="color: #9370db; margin-top: 0; text-shadow: 0 0 15px #4b0082; font-family: '楷体', 'KaiTi', serif;">挑战奖励</h2>
    <div style="margin: 20px 0; font-size: 18px;">
        <div style="color: #d8bfd8;">BOSS等级: <span id="penglaiRewardBossLevel" style="color: #ffd700;">1</span></div>
        <div style="color: #d8bfd8;">奖励倍数: <span id="penglaiRewardMultiplier" style="color: #ffd700;">1</span>x</div>
    </div>
    <div id="penglaiRewardItems" style="margin: 20px 0; text-align: left; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; border: 1px solid #9370db; color: #d8bfd8;"></div>
    <button onclick="closePenglaiReward()" style="background: linear-gradient(to bottom, #9370db, #4b0082); color: #ffd700; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 0 15px #9370db;">确认</button>
</div>















<!-- 老虎机界面 -->
<div id="slotMachineOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; backdrop-filter: blur(5px);"></div>
<div id="slotMachineUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #8B0000, #B22222); color: white; padding: 20px; border: 5px solid #FFD700; border-radius: 15px; z-index: 1001; width: 500px; box-shadow: 0 0 20px rgba(255,215,0,0.5);">
<button onclick="toggleSlotMachine()" style="background: #4b0082; color: #d8bfd8; border: 1px solid #9370db; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    <div style="text-align: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin: 0;">幸运老虎机</h2>
        <div style="color: #FFD700; font-size: 14px;">使用星尘发票赢取更多奖励！</div>
    </div>
    
    <!-- 余额和下注控制 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
        <div>
            <span style="color: #FFD700;">星尘发票: </span>
            <span id="slotMachineBalance">0</span>
        </div>
        <div>
            <span style="color: #FFD700;">下注: </span>
            <button onclick="changeBet(-1)" style="background: #444; color: white; border: none; width: 30px; height: 30px; border-radius: 15px; margin: 0 5px;">-</button>
            <span id="currentBet">10</span>
            <button onclick="changeBet(1)" style="background: #444; color: white; border: none; width: 30px; height: 30px; border-radius: 15px; margin: 0 5px;">+</button>
        </div>
    </div>
    
    <!-- 老虎机转轴 -->
    <div id="slotReels" style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; perspective: 1000px;">
        <div class="reel-container" style="position: relative; width: 100px; height: 300px; background: #000; border: 3px solid #FFD700; border-radius: 10px; overflow: hidden; transform-style: preserve-3d;">
            <div class="reel" id="reel1" style="position: absolute; width: 100%; transition: top 3s cubic-bezier(0.17, 0.67, 0.83, 0.67);">
                <!-- 符号将通过JavaScript动态生成 -->
            </div>
        </div>
        <div class="reel-container" style="position: relative; width: 100px; height: 300px; background: #000; border: 3px solid #FFD700; border-radius: 10px; overflow: hidden; transform-style: preserve-3d;">
            <div class="reel" id="reel2" style="position: absolute; width: 100%; transition: top 3s cubic-bezier(0.17, 0.67, 0.83, 0.67);">
                <!-- 符号将通过JavaScript动态生成 -->
            </div>
        </div>
        <div class="reel-container" style="position: relative; width: 100px; height: 300px; background: #000; border: 3px solid #FFD700; border-radius: 10px; overflow: hidden; transform-style: preserve-3d;">
            <div class="reel" id="reel3" style="position: absolute; width: 100%; transition: top 3s cubic-bezier(0.17, 0.67, 0.83, 0.67);">
                <!-- 符号将通过JavaScript动态生成 -->
            </div>
        </div>
    </div>
    
    <!-- 控制按钮 -->
    <div style="display: flex; justify-content: center; gap: 15px;">
        <button id="spinButton" onclick="spinSlotMachine()" style="background: linear-gradient(45deg, #FFD700, #FF8C00); color: black; border: none; padding: 12px 25px; border-radius: 25px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">旋转</button>
        <button id="autoSpinButton" onclick="toggleAutoSpin()" style="background: #444; color: white; border: none; padding: 12px 25px; border-radius: 25px; font-weight: bold; cursor: pointer;">自动旋转: 关闭</button>
    </div>
    
    <!-- 中奖信息和历史记录 -->
    <div style="margin-top: 20px;">
        <div id="slotResult" style="text-align: center; min-height: 40px; font-weight: bold; color: #FFD700;"></div>
        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; max-height: 100px; overflow-y: auto;">
            <div style="color: #FFD700; margin-bottom: 5px;">最近结果:</div>
            <div id="slotHistory"></div>
        </div>
    </div>
    
    <!-- 赔率表 -->
    <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
        <div style="color: #FFD700; margin-bottom: 5px;">赔率表:</div>
        <div style="font-size: 12px; line-height: 1.4;">
            <div>🍒🍒🍒: 5倍</div>
            <div>🍋🍋🍋: 10倍</div>
            <div>🍊🍊🍊: 15倍</div>
            <div>🍇🍇🍇: 20倍</div>
            <div>🍉🍉🍉: 25倍</div>
            <div>🍎🍎🍎: 50倍</div>
            <div>7️⃣7️⃣7️⃣: 100倍 Jackpot!</div>
        </div>
    </div>
</div>






<!-- 时光秘境主界面 -->
<div id="timeSecretRealmOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 105, 148, 0.95); z-index: 1050;"></div>
<div id="timeSecretRealmUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #006994, #004d73); color: #e6f7ff; padding: 25px; border: 3px solid #00bfff; border-radius: 15px; box-shadow: 0 0 30px #00bfff, inset 0 0 20px #006994; z-index: 1051; width: 800px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #00bfff; padding-bottom: 10px;">
        <h2 style="color: #e6f7ff; margin: 0; text-shadow: 0 0 10px #00bfff;">时光秘境</h2>
        <button onclick="toggleTimeSecretRealm()" style="background: #00bfff; color: #004d73; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
      <!-- 在这里添加难度选择区域 -->
    <div id="tsrDifficultySelection" style="margin-bottom: 20px;">
        <h3 style="color: #00bfff; border-bottom: 1px solid #00bfff; padding-bottom: 5px; margin-bottom: 10px;">难度选择</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 15px;">
            <button onclick="selectTsrDifficulty('easy')" id="difficultyEasy" class="difficulty-btn" style="background: linear-gradient(to bottom, #32cd32, #228b22); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">简单</button>
            <button onclick="selectTsrDifficulty('normal')" id="difficultyNormal" class="difficulty-btn" style="background: linear-gradient(to bottom, #1e90ff, #006994); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">普通</button>
            <button onclick="selectTsrDifficulty('hard')" id="difficultyHard" class="difficulty-btn" style="background: linear-gradient(to bottom, #ffa500, #daa520); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">困难</button>
            <button onclick="selectTsrDifficulty('nightmare')" id="difficultyNightmare" class="difficulty-btn" style="background: linear-gradient(to bottom, #ff4500, #cc3700); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">噩梦</button>
            <button onclick="selectTsrDifficulty('hell')" id="difficultyHell" class="difficulty-btn" style="background: linear-gradient(to bottom, #8b0000, #600000); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">地狱</button>
        </div>
        <div id="tsrDifficultyInfo" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff; font-size: 14px;">
            <div id="difficultyDescription">选择难度开始冒险</div>
            <div id="difficultyUnlockCondition" style="font-size: 12px; color: #d8bfd8; margin-top: 5px;"></div>
        </div>
    </div>
<!-- 开始冒险按钮 -->
<button onclick="startTimeSecretRealm()" id="startTsrBtn" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #004d73; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold; margin: 10px 0;">开始冒险</button>
    <!-- 秘境信息显示 -->
    <div style="margin-bottom: 20px;">
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px;">
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">秘境币</div>
                <div id="tsrCurrency" style="font-size: 18px; color: #ffd700;">0</div>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">最佳层数</div>
                <div id="tsrBestFloor" style="font-size: 18px; color: #ffd700;">0</div>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">通关次数</div>
                <div id="tsrClearCount" style="font-size: 18px; color: #ffd700;">0</div>
            </div>
        </div>
    </div>

    <!-- 秘境控制区域 -->
    <div style="margin-bottom: 20px;">
      
        <button onclick="openTsrShop()" id="openTsrShopBtn" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #004d73; border: 2px solid #ffd700; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; text-shadow: 0 0 5px #ffd700; box-shadow: 0 0 15px #ffd700; margin-left: 10px;">
            秘境商店
        </button>
    </div>
    <!-- 秘境状态显示 -->
    <div id="tsrStatusDisplay" style="display: none; margin-bottom: 20px;">
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px;">
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">当前层数</div>
                <div id="tsrCurrentFloor" style="font-size: 16px; color: #ffd700;">1</div>
            </div>
          <div id="tsrBuffsDisplay" style="display: none; margin-bottom: 20px;">
    <h3 style="color: #90ee90; border-bottom: 1px solid #90ee90; padding-bottom: 5px; margin-bottom: 10px;">当前增益效果</h3>
    <div id="tsrCurrentBuffs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; max-height: 150px; overflow-y: auto;"></div>
</div>
<div id="tsrHealthBar" style="display: none; margin-bottom: 15px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
        <span style="color: #ff6b6b; font-weight: bold;">生命值:</span>
        <span id="tsrHealthText" style="color: #ff6b6b; font-weight: bold;">100%</span>
    </div>
    <div style="width: 100%; height: 20px; background: rgba(255, 107, 107, 0.2); border-radius: 10px; overflow: hidden;">
        <div id="tsrHealthBarFill" style="height: 100%; background: linear-gradient(to right, #ff6b6b, #ff0000); border-radius: 10px; transition: width 0.3s ease; width: 100%;"></div>
    </div>
    <div style="font-size: 11px; color: #ff6b6b; text-align: center; margin-top: 3px;">
        <span id="tsrHealthWarning" style="display: none;">⚠️ 生命值低于30%，危险！</span>
    </div>
</div>
<div id="tsrSkillsDisplay" style="display: none; margin-bottom: 20px;">
    <h3 style="color: #00bfff; border-bottom: 1px solid #00bfff; padding-bottom: 5px; margin-bottom: 10px;">陷阱技能</h3>
    <div id="tsrCurrentSkills" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;"></div>
</div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">剩余时间</div>
                <div id="tsrTimeLeft" style="font-size: 16px; color: #ff6b6b;">300秒</div>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">临时强化</div>
                <div id="tsrTempBuffs" style="font-size: 16px; color: #90ee90;">0个</div>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">秘境币</div>
                <div id="tsrCurrentCurrency" style="font-size: 16px; color: #ffd700;">0</div>
            </div>
        </div>
    </div>
    
    <!-- 秘境房间显示 -->
    <div id="tsrRoomDisplay" style="display: none; margin-bottom: 20px;">
        <h3 style="color: #00bfff; margin-bottom: 10px;">当前房间</h3>
        <div id="tsrCurrentRoom" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 2px solid #00bfff; min-height: 100px;"></div>
    </div>
    
    <!-- 秘境行动控制 -->
    <div id="tsrActionControls" style="display: none; margin-bottom: 20px;">
        <div style="display: flex; justify-content: center; gap: 10px;">
            <button onclick="tsrExploreRoom()" id="tsrExploreBtn" style="background: linear-gradient(to bottom, #32cd32, #228b22); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">探索房间</button>
            <button onclick="tsrRest()" id="tsrRestBtn" style="background: linear-gradient(to bottom, #1e90ff, #006994); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">休息恢复</button>
            <button onclick="tsrNextFloor()" id="tsrNextFloorBtn" style="background: linear-gradient(to bottom, #ffa500, #daa520); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">前往下一层</button>
            <button onclick="tsrExitRealm()" id="tsrExitBtn" style="background: linear-gradient(to bottom, #dc143c, #8b0000); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">退出秘境</button>
        </div>
    </div>
    
    <!-- 秘境日志 -->
    <div id="tsrLogContainer" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; border: 1px solid #00bfff;">
        <div id="tsrBattleLog" style="font-family: monospace; color: #e6f7ff;"></div>
    </div>
</div>

<!-- 时光秘境商店 -->
<div id="tsrShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 105, 148, 0.98); z-index: 1060;"></div>
<div id="tsrShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #006994, #004d73); color: #e6f7ff; padding: 30px; border: 3px solid #ffd700; border-radius: 15px; box-shadow: 0 0 40px #ffd700, inset 0 0 20px #006994; z-index: 1061; width: 700px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #ffd700; margin: 0; text-shadow: 0 0 15px #ffd700;">秘境商店</h2>
        <button onclick="closeTsrShop()" style="background: #00bfff; color: #004d73; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
    
    <div style="margin-bottom: 20px; font-size: 18px;">
        <span style="color: #00bfff;">秘境币: </span>
        <span id="tsrShopCurrency" style="color: #ffd700; font-weight: bold;">0</span>
    </div>
     <!-- 新增：永久加成显示区域 -->
    <div id="tsrPermanentBonuses" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 5px; border: 1px solid #00bfff; margin-bottom: 20px;">
        <div style="color: #888; text-align: center;">暂无永久加成</div>
    </div>
    <div id="tsrShopItems" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 400px; overflow-y: auto;"></div>
</div>
  <div id="worldBossUI">
        <button class="boss-close-button" onclick="toggleWorldBossUI()">×</button>
        <div class="boss-summon-count">
    召唤: <span id="bossSummonCount">1</span>/10
    <br>
    下次恢复: <span id="summonCountdown">00:00:00</span>
</div>
        <h3>世界BOSS系统</h3>
        
        <div class="boss-section">
            <div class="boss-section-title">BOSS状态</div>
            <div class="boss-name" id="bossName">未召唤BOSS</div>
            <div class="boss-world" id="bossWorld"></div>
            <div class="boss-stars" id="bossStars"></div>
            <div class="boss-health-bar" id="bossHealthBar">
                <div class="boss-health-fill" id="bossHealthFill"></div>
                <div class="boss-health-text" id="bossHealthText">0/0</div>
            </div>
            <div class="boss-time-left" id="bossTimeLeft">剩余: 未开始</div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">你的状态</div>
            <div class="boss-info">攻击: <span id="playerBossAttack">0</span></div>
            <div class="boss-info">连击: <span id="playerBossMultiAttack">0</span></div>
            <div class="boss-info">暴击: <span id="playerBossCritRate">0%</span></div>
            <div class="boss-info">爆伤: <span id="playerBossCritDamage">0%</span></div>
            <div class="boss-info">伤害: <span id="playerBossDamage">0</span></div>
            <div class="boss-info">当前排行: <span id="playerBossRank">未排名</span></div>
            <div style="text-align: center; margin-top: 8px;">
                <button class="boss-button" id="bossAttackButton" onclick="attackBoss()">攻击</button>
                <button class="boss-button" id="bossAutoAttackButton" onclick="toggleAutoAttackBoss()">自动</button>
                <button class="boss-button" id="bossSummonButton" onclick="summonBoss()">召唤</button>
            </div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">排行榜</div>
            <div class="boss-rankings" id="bossRankings">
                <div>尚未开始战斗</div>
            </div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">战斗记录</div>
            <div class="boss-battle-log" id="bossBattleLog"></div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">奖励</div>
            <div class="boss-rewards">
                <div class="boss-reward-tier">
                    <h4>第1名</h4>
                    <div>5神级宝石</div>
                    <div>30000转生币</div>
                </div>
                <div class="boss-reward-tier">
                    <h4>第2-10名</h4>
                    <div>5极品宝石</div>
                    <div>10000转生币</div>
                </div>
                <div class="boss-reward-tier">
                    <h4>第11-30名</h4>
                    <div>3高级宝石</div>
                    <div>5000转生币</div>
                </div>
                <div class="boss-reward-tier">
                    <h4>参与奖</h4>
                    <div>1初级宝石</div>
                    <div>100转生币</div>
                </div>
            </div>
        </div>
    </div>
    <div id="bossOverlay"></div>
<!-- 新增宝石商店模态框 -->
<div id="treasureShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #9C27B0; margin: 0;">藏宝图商店</h2>
        <button onclick="closeTreasureShop()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px; text-align: center; font-size: 18px;">
        当前宝藏金币: <span id="currentPrimaryGemqCount" style="color: #FFD700; font-weight: bold;">0</span>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
        <!-- 兑换选项1: 50玫瑰花 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #e91e63;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #e91e63;">玫瑰花束</h4>
                    <p style="margin: 0;">兑换50朵玫瑰花</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(1)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项2: VIP能力值 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">VIP能力值</h4>
                    <p style="margin: 0;">兑换10点VIP能力值</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(2)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项3: 鱼饵 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #4CAF50;">鱼饵</h4>
                    <p style="margin: 0;">兑换1个鱼饵</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(3)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项4: 伴侣钥匙 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #FF9800;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #FF9800;">伴侣钥匙</h4>
                    <p style="margin: 0;">兑换1把伴侣钥匙</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">2</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(4)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项5: 灵根检测器 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #9C27B0;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #9C27B0;">灵根检测器</h4>
                    <p style="margin: 0;">兑换1个灵根检测器</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">5</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(5)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项6: 血脉检测剂 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #673AB7;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #673AB7;">血脉检测剂</h4>
                    <p style="margin: 0;">兑换1个血脉检测剂</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">5</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(6)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项7: 进阶神石 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F44336;">进阶神石</h4>
                    <p style="margin: 0;">兑换1个进阶神石</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">20</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(7)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
     <!-- 兑换选项9: 副本令牌 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F34336;">副本令牌</h4>
                    <p style="margin: 0;">兑换1个副本令牌</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">10</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(9)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
      <!-- 兑换选项10: 职业转换书 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F91336;">职业转换书</h4>
                    <p style="margin: 0;">兑换1个职业转换书</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">10</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(10)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
  <!-- 兑换选项7: 宗门令牌 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F54336;">宗门令牌</h4>
                    <p style="margin: 0;">兑换1个宗门令牌</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">50</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(8)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- 宗门系统界面 -->
<div id="sectSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="sectSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #8B4513; border-radius: 10px; z-index: 1001; width: 850px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #8B4513; padding-bottom: 10px;">
        <h2 style="color: #8B4513; margin: 0;">宗门系统</h2>
        <button onclick="toggleSectSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 宗门信息区域 -->
    <div id="sectInfoContainer" style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <!-- 宗门信息将动态生成 -->
    </div>
    
    <!-- 标签页导航 -->
    <div class="sect-tabs" style="display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 1px solid #444;">
        <button class="sect-tablink active" onclick="openSectTab('members')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">成员管理</button>
        <button class="sect-tablink" onclick="openSectTab('missions')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">任务派遣</button>
        <button class="sect-tablink" onclick="openSectTab('techniques')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">功法库</button>
        <button class="sect-tablink" onclick="openSectTab('settings')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">宗门设置</button>
    </div>
    
    <!-- 成员管理标签页 -->
    <div id="sectMembers" class="sect-tabcontent">
        <div style="margin-bottom: 15px;">
            <button onclick="recruitMember()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">招募弟子</button>
            <span>消耗: <span id="recruitCost">100</span> 灵石</span>
        </div>
        <div id="memberList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; max-height: 300px; overflow-y: auto;">
            <!-- 成员卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 任务派遣标签页 -->
    <div id="sectMissions" class="sect-tabcontent" style="display:none;">
        <div id="missionList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
            <!-- 任务卡片将动态生成 -->
        </div>
        <div id="activeMissions" style="background: #333; padding: 15px; border-radius: 8px;">
            <h3 style="color: #8B4513; margin-top: 0;">进行中的任务</h3>
            <div id="activeMissionList">
                <!-- 进行中的任务将动态生成 -->
            </div>
        </div>
    </div>
    
    <!-- 功法库标签页 -->
    <div id="sectTechniques" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px;">
            <button onclick="upgradeAllTechniques()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">一键升级所有功法</button>
            <span>消耗: <span id="upgradeAllCost">1000</span> 灵石</span>
        </div>
        <div id="techniqueList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 300px; overflow-y: auto;">
            <!-- 功法卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 宗门设置标签页 -->
    <div id="sectSettings" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px;">
            <label for="sectNameInput">宗门名称:</label>
            <input type="text" id="sectNameInput" style="margin-left: 10px; padding: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 3px;">
            <button onclick="changeSectName()" style="background: #FF9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 10px;">修改名称</button>
        </div>
        <div style="margin-bottom: 15px;">
            <p>创建于: <span id="sectCreationDate">未创建</span></p>
            <p>宗门宗旨: <span id="sectMotto">自强不息，厚德载物</span></p>
        </div>
        <div>
            <button onclick="disbandSect()" style="background: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">解散宗门</button>
            <p style="color: #ff4444; font-size: 0.9em; margin-top: 5px;">警告: 解散宗门将失去所有成员和宗门等级！！！</p>
        </div>
    </div>
</div>
<!-- 兑换商店界面 -->
<div id="exchangeShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="exchangeShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 500px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">兑换商店</h2>
        <button onclick="toggleExchangeShop()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px;">
        <p>在这里可以将探索资源与对应的发票道具互相兑换（1:1比例）</p>
    </div>
    
    <!-- 星尘兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <h3 style="color: #cccccc; margin-top: 0;">星尘 ↔ 星尘发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前星尘: <span id="currentStardustExchange">0</span></span>
                <span style="margin-left: 15px;">星尘发票: <span id="currentStardustTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="stardustAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('stardust', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('stardust', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换星尘</button>
            </div>
        </div>
    </div>
    
    <!-- 暗物质兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <h3 style="color: #333366; margin-top: 0;">暗物质 ↔ 暗物质发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前暗物质: <span id="currentDarkMatterExchange">0</span></span>
                <span style="margin-left: 15px;">暗物质发票: <span id="currentDarkMatterTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="darkMatterAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('darkMatter', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('darkMatter', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换暗物质</button>
            </div>
        </div>
    </div>
    
    <!-- 宇宙晶体兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <h3 style="color: #66ccff; margin-top: 0;">宇宙晶体 ↔ 宇宙晶体发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前宇宙晶体: <span id="currentCosmicCrystalExchange">0</span></span>
                <span style="margin-left: 15px;">宇宙晶体发票: <span id="currentCosmicCrystalTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="cosmicCrystalAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('cosmicCrystal', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('cosmicCrystal', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换晶体</button>
            </div>
        </div>
    </div>
    
    <!-- 神器碎片兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #ffcc00; margin-top: 0;">神器碎片 ↔ 神器碎片发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前神器碎片: <span id="currentArtifactFragmentExchange">0</span></span>
                <span style="margin-left: 15px;">神器碎片发票: <span id="currentArtifactFragmentTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="artifactFragmentAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('artifactFragment', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('artifactFragment', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换碎片</button>
            </div>
        </div>
    </div>
</div>
<div id="autoBuySettings" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1000;">
    <h3>自动购买设置</h3>
    
    <div style="margin: 15px 0;">
        <label for="techniqueMaxCost">功法秘籍宝箱自动购买价格上限: </label>
        <input type="number" id="techniqueMaxCost" min="1" step="1">
        <button onclick="setTechniqueMaxCost()">设置</button>
    </div>
    
    <button onclick="toggleAutoBuySettings()" style="margin-top: 15px;">关闭</button>
</div>
<!-- 伴侣商店界面 -->
<div id="companionShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="companionShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #9C27B0; padding-bottom: 10px;">
        <h2 style="color: #9C27B0; margin: 0;">伴侣商店</h2>
        <button onclick="toggleCompanionShop()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 当前灵魂道具数量显示 -->
    <div style="margin-bottom: 20px; padding: 10px; background: #333; border-radius: 5px;">
        <h3 style="margin-top: 0;">当前灵魂道具数量</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
            <div>普通伴侣灵魂: <span id="soulCount1">0</span></div>
            <div>稀有伴侣灵魂: <span id="soulCount2">0</span></div>
            <div>史诗伴侣灵魂: <span id="soulCount3">0</span></div>
            <div>卓越伴侣灵魂: <span id="soulCount4">0</span></div>
            <div>完美伴侣灵魂: <span id="soulCount5">0</span></div>
            <div>神赐伴侣灵魂: <span id="soulCount6">0</span></div>
            <div>天使伴侣灵魂: <span id="soulCount7">0</span></div>
            <div>恶魔伴侣灵魂: <span id="soulCount8">0</span></div>
            <div>精灵伴侣灵魂: <span id="soulCount9">0</span></div>
        </div>
    </div>
    
    <!-- 兑换选项 -->
    <div>
        <h3>灵魂道具兑换</h3>
        
        <!-- 稀有伴侣灵魂兑换普通伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>稀有伴侣灵魂 → 普通伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">100个稀有伴侣灵魂兑换500个普通伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv2', 'banlv1', 100, 500)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换史诗伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 史诗伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">100个普通伴侣灵魂兑换1个史诗伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv3', 100, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换天使伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 天使伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">250个普通伴侣灵魂兑换1个天使伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv7', 250, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换恶魔伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 恶魔伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">220个普通伴侣灵魂兑换1个恶魔伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv8', 220, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换精灵伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 精灵伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">200个普通伴侣灵魂兑换1个精灵伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv9', 200, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换卓越伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 卓越伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">500个普通伴侣灵魂兑换1个卓越伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv4', 500, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换完美伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 完美伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">1000个普通伴侣灵魂兑换1个完美伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv5', 1000, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换神赐伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 神赐伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">5000个普通伴侣灵魂兑换1个神赐伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv6', 5000, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
    </div>
</div>
<div id="tradingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="tradingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 900px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">跑商系统</h2>
        <button onclick="toggleTradingSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>

    <!-- 顶部状态栏 -->
    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px; background: #333; padding: 10px; border-radius: 5px;">
        <div>
            <strong>当前城市:</strong> <span id="currentCity">王都</span>
        </div>
        <div>
            <strong>星币:</strong> <span id="tradingStarCoins">0</span>
        </div>
        <div>
            <strong>货仓:</strong> <span id="warehouseCapacity">20/20</span>
        </div>
        <div>
            <strong>运输工具:</strong> <span id="transportType">手推车</span>
        </div>
    </div>

    <!-- 主界面标签页 -->
    <div class="tab-container" style="margin-bottom: 20px;">
        <button class="tab-btn active" onclick="switchTradingTab('market')">市场交易</button>
        <button class="tab-btn" onclick="switchTradingTab('map')">世界地图</button>
        <button class="tab-btn" onclick="switchTradingTab('auto')">自动贸易</button>
        <button class="tab-btn" onclick="switchTradingTab('management')">经营管理</button>
    </div>

    <!-- 市场交易标签页 -->
    <div id="marketTab" class="tab-content active">
        <div style="margin-bottom: 15px;">
            <h3>当前城市商品价格</h3>
            <div id="cityGoodsList" style="max-height: 300px; overflow-y: auto;">
                <!-- 商品列表将在这里动态生成 -->
            </div>
        </div>
        
        <div>
            <h3>我的库存</h3>
            <div id="playerInventory" style="max-height: 200px; overflow-y: auto;">
                <!-- 库存列表将在这里动态生成 -->
            </div>
        </div>
    </div>

    <!-- 世界地图标签页 -->
    <div id="mapTab" class="tab-content">
        <div style="text-align: center; margin-bottom: 15px;">
            <h3>世界地图</h3>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <div class="region">
                    <h4>森林区</h4>
                    <div class="city" onclick="travelToCity('绿叶镇')">绿叶镇</div>
                    <div class="city" onclick="travelToCity('林荫城')">林荫城</div>
                    <div class="city" onclick="travelToCity('精灵之都')">精灵之都</div>
                </div>
                <div class="region">
                    <h4>山区</h4>
                    <div class="city" onclick="travelToCity('铁石堡')">铁石堡</div>
                    <div class="city" onclick="travelToCity('高山城')">高山城</div>
                    <div class="city" onclick="travelToCity('矿石镇')">矿石镇</div>
                </div>
                <div class="region">
                    <h4>沿海区</h4>
                    <div class="city" onclick="travelToCity('海港城')">海港城</div>
                    <div class="city" onclick="travelToCity('渔村')">渔村</div>
                    <div class="city" onclick="travelToCity('珍珠港')">珍珠港</div>
                </div>
                <div class="region">
                    <h4>平原区</h4>
                    <div class="city" onclick="travelToCity('谷物乡')">谷物乡</div>
                    <div class="city" onclick="travelToCity('牧野城')">牧野城</div>
                    <div class="city" onclick="travelToCity('平原镇')">平原镇</div>
                </div>
                <div class="region">
                    <h4>沙漠区</h4>
                    <div class="city" onclick="travelToCity('金沙城')">金沙城</div>
                    <div class="city" onclick="travelToCity('绿洲镇')">绿洲镇</div>
                    <div class="city" onclick="travelToCity('香料市')">香料市</div>
                </div>
                <div class="region">
                    <h4>都市区</h4>
                    <div class="city" onclick="travelToCity('王都')">王都</div>
                    <div class="city" onclick="travelToCity('商盟总部')">商盟总部</div>
                    <div class="city" onclick="travelToCity('贸易中心')">贸易中心</div>
                    <div class="city" onclick="travelToCity('工艺之都')">工艺之都</div>
                    <div class="city" onclick="travelToCity('魔法学院')">魔法学院</div>
                </div>
            </div>
        </div>
        
        <div id="travelInfo" style="margin-top: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div>当前位置: <span id="currentLocation">王都</span></div>
            <div>目标城市: <span id="targetCity">-</span></div>
            <div>预计时间: <span id="travelTime">-</span></div>
            <div>状态: <span id="travelStatus">准备出发</span></div>
            <button id="startTravelBtn" onclick="startTravel()" style="margin-top: 10px;">开始旅行</button>
        </div>
    </div>

    <!-- 自动贸易标签页 -->
    <div id="autoTab" class="tab-content">
        <h3>自动贸易设置</h3>
        <div style="margin-bottom: 15px;">
            <label>
                <input type="checkbox" id="autoTradeEnabled" onchange="toggleAutoTrade()">
                启用自动贸易
            </label>
        </div>
        
        <div id="autoTradeSettings" style="display: none;">
            <div style="margin-bottom: 10px;">
                <label>采购城市: 
                    <select id="buyCity">
                        <!-- 城市选项将动态生成 -->
                    </select>
                </label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>销售城市: 
                    <select id="sellCity">
                        <!-- 城市选项将动态生成 -->
                    </select>
                </label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>采购商品: 
                    <select id="tradeGoods">
                        <!-- 商品选项将动态生成 -->
                    </select>
                </label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>最大买入价: <input type="number" id="maxBuyPrice" value="0"></label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>最小利润率: <input type="number" id="minProfitMargin" value="10">%</label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>单次资金: <input type="number" id="tradeCapital" value="10000"></label>
            </div>
            <button onclick="saveAutoTradeRoute()">保存路线</button>
        </div>
        
        <div id="autoTradeStatus" style="margin-top: 15px;">
            <h4>自动贸易状态</h4>
            <div>状态: <span id="autoTradeState">未启用</span></div>
            <div>效率: <span id="autoTradeEfficiency">0%</span></div>
            <div>今日利润: <span id="todayProfit">0</span></div>
        </div>
    </div>

    <!-- 经营管理标签页 -->
    <div id="managementTab" class="tab-content">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <!-- 货仓升级 -->
            <div>
                <h3>货仓升级</h3>
                <div>当前等级: <span id="warehouseLevel">1</span></div>
                <div>当前容量: <span id="currentCapacity">20</span>格</div>
                <div>升级费用: <span id="upgradeCosta">300000</span>星币</div>
                <button onclick="upgradeWarehouse()">升级货仓</button>
            </div>
            
            <!-- 运输工具 -->
            <div>
                <h3>运输工具</h3>
                <div id="transportList">
                    <!-- 运输工具列表将动态生成 -->
                </div>
            </div>
            
            <!-- 雇员管理 -->
            <div>
                <h3>雇员管理</h3>
                <div id="employeeList">
                    <!-- 雇员列表将动态生成 -->
                </div>
                <button onclick="hireEmployee('初级商贩')" style="margin-top: 10px;">雇佣初级商贩</button>
            </div>
            
            <!-- 风险管理 -->
            <div>
                <h3>风险管理</h3>
                <div>
                    <label>
                        <input type="checkbox" id="goodsInsurance" onchange="toggleInsurance('goods')">
                        货物险 (保费5%)
                    </label>
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="transportInsurance" onchange="toggleInsurance('transport')">
                        运输险 (保费3%)
                </div>
        </div>
    </div>
</div>
            </div>
        </div>
    </div>
</div>
  <div id="landlordUI" class="landlord-ui">
        <div class="landlord-header">
            <h2>疯狂地主</h2>
            <div class="landlord-currency">
                地主币: <span id="landlordCoinBalance">0</span>
            </div>
            <button class="landlord-close" onclick="closeLandlordGame()">×</button>
        </div>
        
        <div class="landlord-nav">
            <button class="landlord-tab active" onclick="switchLandlordTab('store')">种子商店</button>
            <button class="landlord-tab" onclick="switchLandlordTab('itemStore')">道具商店</button>
            <button class="landlord-tab" onclick="switchLandlordTab('fields')">田地</button>
            <button class="landlord-tab" onclick="switchLandlordTab('storage')">仓库</button>
            <button class="landlord-tab" onclick="switchLandlordTab('stats')">统计</button>
        </div>
        
        <div class="landlord-content">
            <!-- 种子商店页面 -->
            <div id="landlordStoreTab" class="landlord-tab-content active">
                <div class="landlord-refresh-info">
                    种子商店每10分钟自动刷新一次
                    <br>
                    下次刷新: <span id="landlordSeedRefreshTimer">10:00</span>
                </div>
                <div class="landlord-store-grid" id="landlordStoreItems">
                    <!-- 种子将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <!-- 道具商店页面 -->
            <div id="landlordItemStoreTab" class="landlord-tab-content">
                <div class="landlord-refresh-info">
                    道具商店每10分钟自动刷新一次
                    <br>
                    下次刷新: <span id="landlordItemRefreshTimer">10:00</span>
                </div>
                <div class="landlord-store-grid" id="landlordItemStoreItems">
                    <!-- 道具将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <!-- 田地页面 -->
            <div id="landlordFieldsTab" class="landlord-tab-content">
                <div id="landlordFieldsContainer" class="landlord-fields-container">
                    <!-- 地块将通过JavaScript动态生成 -->
                </div>
                <div class="landlord-unlock-container" id="landlordUnlockSection">
                    <!-- 解锁地块信息将动态生成 -->
                </div>
            </div>
            
            <!-- 仓库页面 -->
            <div id="landlordStorageTab" class="landlord-tab-content">
                <div class="landlord-total-assets">
                    <div>仓库总资产</div>
                    <div class="landlord-total-value" id="landlordTotalAssetsValue">0 地主币</div>
                </div>
                <div class="landlord-storage-container">
                    <div class="landlord-storage-section">
                        <h3>种子仓库</h3>
                        <div id="landlordSeedStorage" class="landlord-storage-list">
                            <!-- 种子仓库内容将动态生成 -->
                        </div>
                    </div>
                    <div class="landlord-storage-section">
                        <h3>果实仓库</h3>
                        <div id="landlordFruitStorage" class="landlord-storage-list">
                            <!-- 果实仓库内容将动态生成 -->
                        </div>
                    </div>
                    <div class="landlord-storage-section">
                        <h3>道具仓库</h3>
                        <div id="landlordItemStorage" class="landlord-storage-list">
                            <!-- 道具仓库内容将动态生成 -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 统计页面 -->
            <div id="landlordStatsTab" class="landlord-tab-content">
                <div class="landlord-stats-grid">
                    <div class="landlord-stat-card">
                        <h3>游戏统计</h3>
                        <div>总种植次数: <span id="landlordTotalPlants">0</span></div>
                        <div>总收获次数: <span id="landlordTotalHarvests">0</span></div>
                        <div>总获得地主币: <span id="landlordTotalCoinsEarned">0</span></div>
                        <div>当前天气: <span id="landlordCurrentWeather">晴朗</span></div>
                    </div>
                    
                    <div class="landlord-stat-card">
                        <h3>突变统计</h3>
                        <div>基础突变: <span id="landlordBasicMutations">0</span></div>
                        <div>天气突变: <span id="landlordWeatherMutations">0</span></div>
                        <div>特殊突变: <span id="landlordSpecialMutations">0</span></div>
                        <div>最高突变倍率: <span id="landlordHighestMultiplier">1x</span></div>
                    </div>
                    
                    <div class="landlord-stat-card">
                        <h3>进度</h3>
                        <div>已解锁地块: <span id="landlordUnlockedFields">5</span>/50</div>
                        <div>种子仓库容量: <span id="landlordSeedStorageCount">0</span>/∞</div>
                        <div>果实仓库容量: <span id="landlordFruitStorageCount">0</span>/200</div>
                        <div>道具使用次数: <span id="landlordItemUsageCount">0</span>/∞</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 通知区域 -->
    <div id="landlordNotificationArea"></div>
    
    <!-- 选择种子模态框 -->
    <div id="landlordSeedModal" class="landlord-modal">
        <div class="landlord-modal-content">
            <h3 style="text-align: center; margin-bottom: 20px;">选择种子</h3>
            <div id="landlordSeedModalContent" style="max-height: 300px; overflow-y: auto;">
                <!-- 种子列表将动态生成 -->
            </div>
            <button onclick="closeLandlordSeedModal()" style="margin-top: 20px; width: 100%; padding: 10px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer;">取消</button>
        </div>
    </div>
    
    <!-- 选择道具模态框 -->
    <div id="landlordItemModal" class="landlord-modal">
        <div class="landlord-modal-content">
            <h3 style="text-align: center; margin-bottom: 20px;">选择道具</h3>
            <div id="landlordItemModalContent" style="max-height: 300px; overflow-y: auto;">
                <!-- 道具列表将动态生成 -->
            </div>
            <button onclick="closeLandlordItemModal()" style="margin-top: 20px; width: 100%; padding: 10px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer;">取消</button>
        </div>
    </div>
   <div id="miningUI">
        <div class="mining-header">
            <h2>⛏️ 无尽挖矿系统</h2>
            <button onclick="toggleMiningUI()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        
        <div class="mining-stats">
            <div class="mining-stat">
                <div>当前深度</div>
                <div id="miningDepth">0 米</div>
            </div>
            <div class="mining-stat">
                <div>挖掘力量</div>
                <div id="miningPower">1</div>
            </div>
            <div class="mining-stat">
                <div>体力上限</div>
                <div id="miningMaxStamina">100</div>
            </div>
        </div>
        
        <div class="mining-stamina">
            <div>体力值: <span id="miningStaminaText">100 / 100</span></div>
            <div class="stamina-bar">
                <div class="stamina-progress" id="miningStaminaBar" style="width: 100%"></div>
            </div>
            <div style="font-size: 0.8em; color: #ff6b6b; margin-top: 5px;">
                ⚠️ 体力不会自动恢复，只能使用体力药水恢复
            </div>
        </div>
        
        <!-- 调整后的控制区域 -->
        <div class="mining-controls">
            <!-- 通知栏移动到按钮上方 -->
            <div class="mining-notifications" id="miningNotifications">
                <div class="mining-notification">游戏开始！点击"开始自动挖矿"开始冒险！</div>
            </div>
            
            <!-- 按钮组 -->
            <div class="mining-buttons">
                <button id="miningToggleBtn" onclick="toggleMining()">开始自动挖矿</button>
                <button onclick="useMiningPotion()">使用体力药水</button>
                <button onclick="buyMiningPotion()">购买药水 (1个宝藏金币)</button>
                <button onclick="clearMiningNotifications()">清空通知</button>
            </div>
        </div>
        
        <!-- 分页标签 -->
        <div class="mining-tabs">
            <div class="mining-tab active" onclick="switchMiningTab('gems')">宝石收集</div>
            <div class="mining-tab" onclick="switchMiningTab('upgrades')">装备升级</div>
        </div>
        
        <!-- 宝石页面 -->
        <div id="miningGemsPage" class="mining-gems-page active">
            <!-- 药水显示移动到宝石页面内 -->
            <div class="mining-potions">
                <div class="potion-info">
                    <span class="potion-icon">💊</span>
                    <div>
                        <div>体力药水</div>
                        <div style="font-size: 0.8em; color: #8da1b9;">恢复全部体力</div>
                    </div>
                </div>
                <div class="potion-count" id="miningPotionCount">3</div>
            </div>
            
            <div class="mining-gems">
                <div class="mining-gem" style="border-left: 4px solid #ff6b6b;">
                    <span>💎</span>
                    <div>
                        <div>红宝石(世界地图经验）</div>
                        <div id="miningRuby">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #48cae4;">
                    <span>🔷</span>
                    <div>
                        <div>蓝宝石（攻击力）</div>
                        <div id="miningSapphire">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #52b788;">
                    <span>💚</span>
                    <div>
                        <div>翡翠（生命）</div>
                        <div id="miningEmerald">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #7b2cbf;">
                    <span>🔮</span>
                    <div>
                        <div>紫水晶（爆伤）</div>
                        <div id="miningAmethyst">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #caf0f8;">
                    <span>💎</span>
                    <div>
                        <div>钻石（每秒GPS）</div>
                        <div id="miningDiamond">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #ffd166;">
                    <span>⛏️</span>
                    <div>
                        <div>矿石总量</div>
                        <div id="miningOre">100</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 升级页面 -->
        <div id="miningUpgradesPage" class="mining-upgrades-page">
            <div class="mining-upgrades">
                <h3>装备升级</h3>
                <div class="mining-upgrade">
                    <div>
                        <div>强化镐头 (等级 <span id="miningPowerLevel">1</span>/100)</div>
                        <div style="font-size: 0.8em;">提高挖掘深度和矿石获取</div>
                    </div>
                    <button onclick="upgradeMiningPower()" id="upgradeMiningPowerBtn">升级 (50)</button>
                </div>
                <div class="mining-upgrade">
                    <div>
                        <div>体力上限 (等级 <span id="miningStaminaLevel">1</span>/10)</div>
                        <div style="font-size: 0.8em;">每级增加10点体力上限</div>
                    </div>
                    <button onclick="upgradeMiningStamina()" id="upgradeMiningStaminaBtn">升级 (150)</button>
                </div>
                <div class="mining-upgrade">
                    <div>
                        <div>宝石探测器 (等级 <span id="miningDetectorLevel">1</span>/10)</div>
                        <div style="font-size: 0.8em;">每级提高0.5%宝石发现几率</div>
                    </div>
                    <button onclick="upgradeMiningDetector()" id="upgradeMiningDetectorBtn">升级 (200)</button>
                </div>
            </div>
        </div>
    </div>
<!-- 模拟投资交易游戏界面 -->
<div id="investmentGameUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 95%; max-width: 1200px; height: 90vh; background: #f5f7fa; border: 3px solid #3b82f6; border-radius: 15px; z-index: 1002; overflow: hidden;">
    <div style="position: absolute; top: 10px; right: 10px;">
        <button onclick="closeInvestmentGame()" style="background: #ef4444; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 16px;">
            <i class="fas fa-times"></i> 关闭
        </button>
    </div>
    
    <div id="investmentGameContent" style="height: 100%; overflow-y: auto; padding: 20px;">
        <!-- 模拟投资交易游戏的内容将通过JavaScript动态生成 -->
    </div>
</div>
 <!-- 房屋系统界面 -->
    <div id="houseSystemOverlay"></div>
    <div id="houseSystemUI">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #8B4513; padding-bottom: 10px;">
            <h2 style="color: #8B4513; margin: 0;">房屋系统</h2>
            <button onclick="closeHouseSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
        </div>
        
        <!-- 房屋信息 -->
        <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
            <div style="display: flex; justify-content: space-between;">
                <div>
                    <strong>房屋等级:</strong> <span id="houseLevel">1</span>
                    <strong>经验:</strong> <span id="houseExp">0</span>/<span id="houseExpNext">100</span>
                </div>
                <button onclick="upgradeHouseSystem()" 
                style="background: #8B4513; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">
            升级房屋系统
        </button>
                <div>
                    <strong>房屋数量:</strong> <span id="houseCount">0</span>/<span id="maxHouses">5</span>
                </div>
                <div>
                    <strong>房子总收益:</strong> <span id="totalHouseIncome">0</span> 资金
                </div>
                <div>
                    <strong>当前资产:</strong> <span id="totalHouseIncoma">0</span> 资金
                </div>
            </div>
        
       
         <!-- 房屋购买区域 -->
        <div style="margin-bottom: 20px;">
            <h3>购买房屋</h3>
            <div id="houseStore" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px;">
                <!-- 房屋购买选项将动态生成 -->
            </div>
        </div>
        </div>
               
        <!-- 我的房屋 -->
        <div style="margin-bottom: 20px;">
            <h3>我的房屋</h3>
            <div id="houseList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; padding: 10px; background: #333; border-radius: 5px;">
                <!-- 房屋卡片会动态生成在这里 -->
            </div>
        </div>
        
        <!-- 房屋操作 -->
        <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
            <h3>房屋操作</h3>
            <div id="houseSlotsContainer" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin: 10px 0; max-height: 400px; overflow-y: auto;">
                <!-- 房屋槽位会动态生成在这里 -->
            </div>
            <div>
                <button onclick="rentAllHouses()" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; margin-right: 10px;">一键出租</button>
                <button onclick="collectAllHouseIncome()" style="background: #FFC107; color: black; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">收取所有收益</button>
            </div>
        </div>
        
        <!-- 房屋分解 -->
        <div style="background: #333; padding: 15px; border-radius: 8px;">
            <h3>房屋分解</h3>
            <p>选择房屋进行分解，获得转生币</p>
            
            <!-- 批量选择选项 -->
            <div style="margin-bottom: 10px;">
                <strong>批量选择:</strong>
                <button onclick="selectHousesByRarity(5)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">5稀有度以下</button>
                <button onclick="selectHousesByRarity(10)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">10稀有度以下</button>
                <button onclick="selectHousesByRarity(15)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">15稀有度以下</button>
                <button onclick="selectAllHouses()" style="margin: 2px; padding: 3px 6px; font-size: 12px;">全选</button>
                <button onclick="deselectAllHouses()" style="margin: 2px; padding: 3px 6px; font-size: 12px;">全不选</button>
            </div>
            
            <div id="decomposeHouseContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; max-height: 400px; overflow-y: auto;">
                <!-- 分解界面会动态生成在这里 -->
            </div>
            <button onclick="decomposeSelectedHouse()" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">分解选中房屋</button>
        </div>
    </div>
 </div>
 </div>
<div id="footer">版本号: v1.7.3</div>
    <script>
        // 初始化玩家数据
    let player = {
    name: "勇者",
    gold: 0,
    diamond: 0,
    titanium: 0,
    starstone: 0,
    cosmicstone: 0,
    superstone: 0,
    otherworldstone: 0,
    xingjiestone: 0,
    hundunstone: 0,
    lingtone: 0,
    huangtone: 0,
    mingtone: 0,
    xutong: 0,
    shitone: 0,
    weitone: 0,
    reincarnationCoin: 0,
    reincarnationCount: 0,
    equipment: [],
    usedActivationCodes: [],
    dimensionLevel: 1,
    class: null, // 当前职业: null, 'warrior', 'mage'
    classSecond: null,    // 二转职业
    classThird: null,    // 三转职业  
    classFourth: null, 
    classBranches: [], // 已选择的分支 [0, 2, 1] 表示第1排选第0个，第2排选第2个等
    classBonuses: { // 新增：存储职业分支选择的加成
    soulRingMultiplier: 1,    // 魂环总加成乘数（默认1倍）
    dungeonEquipMultiplier: 1 // 副本装备总加成乘数（默认1倍）
  },
  houses: {
                    level: 1,
                    exp: 0,
                    maxHouses: 5,
                    ownedHouses: [],
                    rentedHouses: [],
                    lastUpdate: Date.now(),
                    totalIncome: 0
                },
 investmentGame: {
            stocks: [
                {code: "zj0001", name: "鱼鱼基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0002", name: "闫闫基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},           
                {code: "zj0003", name: "茶茶金股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0004", name: "麒麟企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0005", name: "云南白药", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0006", name: "黑三逢源", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0007", name: "乐途企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0008", name: "PDD企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0009", name: "空白控股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0010", name: "慢手企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0011", name: "斗音公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0012", name: "阿里妈妈", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0013", name: "淘宝宝", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0014", name: "千达有限", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0015", name: "通元房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0016", name: "预言鱼塘", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0017", name: "新股长虹", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0018", name: "萩萩萩萩音乐", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0019", name: "盛通快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0020", name: "十鼎洗浴", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0021", name: "九鼎红楼", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0022", name: "星巴克", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0023", name: "大吴疆土", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0024", name: "九转仙股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0025", name: "乌龟科技", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0026", name: "阿斯塔特", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0027", name: "万里药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0028", name: "万里证券", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0029", name: "顶峰相见", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0030", name: "顺封快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0031", name: "晋商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0032", name: "爆涨房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0033", name: "书法银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0034", name: "阳城银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0035", name: "程羽银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0036", name: "中铁银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0037", name: "工商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0038", name: "明港基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0039", name: "东坑企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0040", name: "黑龙银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0041", name: "韵达银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0042", name: "巴士企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0043", name: "京东公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0044", name: "科技企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0045", name: "羊同药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0046", name: "风雪药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0047", name: "霸王别姬", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0048", name: "一点点奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0049", name: "古茗奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0050", name: "蜜雪冰城", price: 10.00, change: 0, holdings: 0, costPrice: 0}
            ],
            userData: {
                availableFunds: 1000.00,
                totalAssets: 1000.00,
                holdingPercent: 0.00,
                todayProfit: 0.00,
                tradeCount: 16,
                initialFunds: 1000.00,
                lastUpdateTime: Date.now()
            },
            currentStockIndex: 0,
            tradeData: {
                quantity: 0,
                type: "buy",
                feeRate: 0.0048
            },
            chartHistoryCache: {},
            priceUpdateTimer: null,
            chartUpdateTimer: null
        },
    mining: {
            depth: 0,
            power: 1,
            isMining: false,
            ore: 1500,
            stamina: 100,
            baseMaxStamina: 100,
            staminaUpgradeLevel: 1,
            potions: 3,
            gems: {
                ruby: 0,
                sapphire: 0,
                emerald: 0,
                amethyst: 0,
                diamond: 0
            },
            upgrades: {
                power: 1,
                detector: 1
            },
            notifications: [],
            lastUpdate: Date.now()
        },
landlord: {
                coins: 10000,
                unlockedFields: 5,
                fields: Array(50).fill(null),
                seedStorage: {},
                fruitStorage: [],
                itemStorage: {},
                storeItems: {},
                itemStoreItems: {},
                lastSeedRefreshTime: Date.now(),
                lastItemRefreshTime: Date.now(),
                weather: "晴朗",
                lastWeatherChange: Date.now(),
                stats: {
                    totalPlants: 0,
                    totalHarvests: 0,
                    totalCoinsEarned: 0,
                    basicMutations: 0,
                    weatherMutations: 0,
                    specialMutations: 0,
                    highestMultiplier: 1,
                    itemsUsed: 0
                },
                selectedFieldIndex: null
            },
        
 penglaiIsland: {
    bossLevel: 1,
    bossHealth: 1e150,
    bossAttack: 1e20,
    bossMaxHealth: 1e150,
    bossResurrections: 0,
    isBattling: false,
    playerHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
},
holyBeastIsland: {
    bossLevel: 1,
    bossHealth: 1e100,
    bossAttack: 1e10,
    bossMaxHealth: 1e100,
    bossResurrections: 0,
    isBattling: false,
    playerHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
},
runes: {
    materials: {
        gold: 0,
        wood: 0,
        water: 0,
        fire: 0,
        earth: 0,
        light: 0,
        dark: 0,
        wind: 0,
        ice: 0,
        electric: 0
    },
    equipped: null,
    inventory: [],
    level: 1,
    upgradeCost: 10,
    selectedMaterials: [],
    currentFilter: 'all'
},
  sect: {
            created: false,
            name: "",
            level: 0,
            exp: 0,
            spiritStones: 0,
            members: [],
            missions: [],
            techniques: {},
            creationTime: 0,
            maxMembers: 5
        },
   battle: {
    currentZone: null,
    currentMonster: null,
    monsterResurrections: 0,
},
  worldMapBattle: {
    autoBattle: false,
    autoBattleInterval: null
},
liveStream: {
            level: 1,
            exp: 0,
            totalEarnings: 1000,
            isLive: false,
            lastLiveStart: 0,
            totalLiveTime: 0,
            expMultiplier: 1,
            viewers: [],
            donationHistory: [],
           lastDanmaku: null
        },
level: {
    current: 1,
    exp: 0,
    nextLevelExp: 10000,
    clickBonus: 1,
    gpsBonus: 1,
    ascentionCount: 0, // 飞升次数
    ascentionMultiplier: 1, // 飞升加成倍数
    ascentionCounta: 0, 
    ascentionMultipliera: 1 
},
cultivation: {
            stage: 0, // 当前阶段索引
            exp: 0,   // 当前经验值
            root: null, // 当前灵根
            bloodline: null,
           bonus: 1
        },
 artifacts: {
            fragments: 0,
            crystals: 0,
            inventory: [],
            equipped: {
                helmet: null,
                clothes: null,
                pants: null,
                shoes: null,
                necklace: null,
                weapon: null
            },
        advanceLevels: {}
        },
   mystery: {
        stage: 1,
        level: 1,
        exp: 0,
        bonus: 1, // 默认加成1倍
        lastUpdateTime: Date.now() // 添加这个字段
    },
    autoReincarnation: false, // 新增自动转生状态
    officialLevel: 0, // 官职等级，初始为0
    officialBonus: 1, // 初始加成1倍
    vip: {
        level: 1,
        power: 0 // 累计VIP能力值数量
    },
   companionExpedition: {
            currentExpedition: null,
            history: [],
            lastUpdate: Date.now()
        },
   bossBattleSnapshot: {
    playerAttack: 0,
    playerMultiAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
},
 backgroundBattle: {
    active: false,
    interval: null
},
treasure: {
        keys: 0, // 藏宝图钥匙数量
        maps: [], // 拥有的藏宝图
        currentBattle: null // 当前战斗信息
    },
 parking: {
    level: 1, // 停车位等级
    exp: 0, // 停车经验
    expToNextLevel: [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000, 10000000, 20000000, 50000000, 100000000, 200000000], // 每级所需经验
    parkingLots: [], // 停车位数组，每个元素是一个对象 { carId: 'car1', parkTime: 1234567890 }
    cars: [] // 拥有的车辆数组，每个元素是车辆ID
},
   companionChestGuarantee: {
    epic: 0,     // 史诗保底计数器
    pink: 0,     // 卓越保底计数器
    orange: 0,  // 完美保底计数器
    red: 0       // 神赐保底计数器
},
 fishing: {
    level: 1,
    currentExp: 0,
    fishCage: [],
    isFishing: false,
    isBiting: false,
    biteTimer: null,
    biteWindowTimer: null,
    biteTime: 0,
    bonus: 1,
    autoFishingEnabled: false,
    autoDecomposeFishEnabled: false

},
mounts: {
            inventory: [], // 拥有的坐骑列表
            equipped: null, // 当前装备的坐骑ID
            level: 1, // 坐骑等级
            upgradeCost: 5 // 升级所需远古圣兽精魄数量
        },

wings: {
    inventory: [], // 拥有的翅膀列表
    equipped: null, // 当前装备的翅膀ID
    level: 1, // 翅膀等级（共享）
    upgradeCost: 5 // 下次升级所需的黑龙王翅膀数量
},
exploration: {
            speed: { level: 1, cost: 100 },
            capacity: { level: 1, cost: 100 },
            durability: { level: 1, cost: 100 },
            resources: {
                stardust: 0,
                darkMatter: 0,
                cosmicCrystal: 0,
                artifactFragment: 0
            },
            activeMission: null,
            missionEndTime: 0,
            logs: []
        },
tower: {
    currentFloor: 0,
    maxFloor: 0,
    isAutoAttacking: false,
    autoAttackInterval: null,
    battleLog: [],
    playerHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0,
    monster: null
},
gems: {
            red: {},   // {等级: 数量}
            blue: {},
            black: {},
            green: {},
            pink: {},
            yellow: {}
        },
        companions: [], // 伴侣列表
    equippedCompanionId: null, // 当前装备的伴侣ID
    companionLevel: 1, // 共享的伴侣等级
   autoDecompose: {
    enabled: false,
    belowRarity: 'white' // 默认分解普通及以下
},
    items: {
        primaryGem: 0,
        advancedGem: 0,
        superiorGem: 0,
        divineGem: 0,
        refineStone: 0,
        vipPower: 0,
        rose: 0, // 玫瑰花
        companionKey: 0, // 伴侣钥匙
        rebornDan: 0,
        baitCount: 0,
        rootDetector: 0,
        bloodlineDetector: 0,
        advanceStone: 0,
        primaryGemq: 0,
        zongmen: 0,
        roseq: 0,
        yuzhou1: 0,  
       yuzhou2: 0, 
      yuzhou3: 0, 
     yuzhou4: 0, 
    banlv1: 0, 
     banlv2: 0, 
    banlv3: 0, 
    banlv4: 0, 
    banlv5: 0, 
     banlv6: 0, 
    banlv7: 0,
   banlv8: 0,
   banlv9: 0,
   zhiye1: 0,
   chiban1: 0,
   zuoqi1: 0,
   fuben1: 0,
  shenshou1: 0,
   fuwen1: 0,
  fuben2: 0
    },
timeSecretRealm: {
    currency: 0, // 秘境币
    bestFloor: 0, // 最佳层数
    clearCount: 0, // 通关次数
    unlockedItems: [], // 已解锁商店物品
    currentRun: {
        isActive: false, // 是否正在进行冒险
        currentFloor: 1, // 当前层数
        timeLeft: 300, // 剩余时间（秒）
        tempBuffs: [], // 临时强化
        currentRoom: null, // 当前房间
        exploredRooms: 0, // 已探索房间数
        currencyEarned: 0, // 本次冒险获得的秘境币
        playerHealth: 0, // 玩家生命值（临时）
        playerAttack: 0, // 玩家攻击力（临时）
    },
   difficulty: {
   levels: {
        easy: { 
            name: '简单', 
            multiplier: 0.8, 
            rewardMultiplier: 0.7, 
            description: '适合新手玩家', 
            unlockCondition: '无',
            clearFloor: 10  // 通关层数要求
        },
        normal: { 
            name: '普通', 
            multiplier: 1.0, 
            rewardMultiplier: 1.0, 
            description: '标准难度', 
            unlockCondition: '通关简单难度3次',
            clearFloor: 15
        },
        hard: { 
            name: '困难', 
            multiplier: 1.5, 
            rewardMultiplier: 1.5, 
            description: '更具挑战性', 
            unlockCondition: '通关普通难度5次',
            clearFloor: 20
        },
        nightmare: { 
            name: '噩梦', 
            multiplier: 2.0, 
            rewardMultiplier: 2.5, 
            description: '极限挑战', 
            unlockCondition: '通关困难难度10次',
            clearFloor: 25
        },
        hell: { 
            name: '地狱', 
            multiplier: 3.0, 
            rewardMultiplier: 4.0, 
            description: '终极考验', 
            unlockCondition: '通关噩梦难度20次',
            clearFloor: 30
        }
    },
    current: 'easy',
    unlocked: ['easy']
},
    roomTypes: {
        battle: { weight: 40, name: '战斗房间' },
        event: { weight: 25, name: '事件房间' },
        treasure: { weight: 20, name: '宝箱房间' },
        rest: { weight: 10, name: '休息房间' },
        shop: { weight: 5, name: '商店房间' }
    },  
    tempBuffs: {
              attack: { 
        name: '攻击强化', 
        description: '攻击力提升50%，探索时间+30秒', 
        effect: 'attack', 
        value: 0.5, 
        duration: 0,
        timeBonus: 30  // 新增：增加20秒探索时间
    },
    health: { 
        name: '生命强化', 
        description: '生命值提升50%，探索时间+60秒', 
        effect: 'health', 
        value: 0.5, 
        duration: 0,
        timeBonus: 60  // 新增：增加40秒探索时间
    },
    critRate: { 
        name: '暴击强化', 
        description: '暴击率提升10%，探索时间+90秒', 
        effect: 'critRate', 
        value: 0.1, 
        duration: 0,
        timeBonus: 90  // 新增：增加60秒探索时间
    },
    critDamage: { 
        name: '爆伤强化', 
        description: '爆伤提升50%，探索时间+120秒', 
        effect: 'critDamage', 
        value: 0.5, 
        duration: 0,
        timeBonus: 120  // 新增：增加80秒探索时间
    },
    speed: { 
        name: '速度强化', 
        description: '探索速度提升，探索时间+150秒', 
        effect: 'speed', 
        value: 10, 
        duration: 0,
        timeBonus: 150  // 新增：增加100秒探索时间
    },
                luck: { name: '幸运强化', description: '获得双倍秘境币', effect: 'luck', value: 1, duration: 0  }
    },
    shopItems: {
        permanentAttack: { 
            name: '永恒攻击符文', 
            description: '临时提升现有攻击力50%可以叠加（转生失效）', 
            cost: 100000, 
            type: 'permanent',
            effect: 'attack'
        },
        permanentHealth: { 
            name: '永恒生命符文', 
            description: '临时提升现有生命值50%可以叠加（转生失效）', 
            cost: 100000, 
            type: 'permanent',
            effect: 'health'
        },
        timeExtension: { 
        name: '时间沙漏', 
        description: '永久增加探索时间60秒（限购50个）', 
        cost: 500000, 
        type: 'permanent',
        effect: 'time',
        maxPurchase: 50, // 限购50个
        purchased: 0, // 已购买数量
        permanentEffect: true // 永久效果
    },
    startingBuff: { 
        name: '起始祝福', 
        description: '每次冒险开始时永久获得1个随机增益效果（限购2个）', 
        cost: 800000, 
        type: 'permanent',
        effect: 'startingBuff',
        maxPurchase: 2, // 限购2个
        purchased: 0, // 已购买数量
        permanentEffect: true // 永久效果
    },
       trapSkillBook1: {
    name: '侦查技能书·初级',
    description: '提升陷阱侦查成功率到60%',
    cost: 500000,
    type: 'permanent',
    effect: 'detection_advanced'
},
 trapSkillBook2: {
    name: '侦查技能书·高级',
    description: '提升陷阱侦查成功率到80%',
    cost: 800000,
    type: 'permanent',
    effect: 'detection_expert'
},
 trapSkillBook3: {
    name: '解除技能书·初级',
    description: '提升陷阱解除成功率到70%',
    cost: 500000,
    type: 'permanent',
    effect: 'disarm_advanced'
},
 trapSkillBook4: {
    name: '解除技能书·高级',
    description: '提升陷阱解除成功率到85%',
    cost: 800000,
    type: 'permanent',
    effect: 'disarm_expert'
},
 trapSense: {
    name: '陷阱感知药水',
    description: '下次冒险陷阱侦查成功率提升30%',
    cost: 10000,
    type: 'permanent',
    effect: 'detection_boost'
},
        rareMaterial: { 
            name: '秘境结晶', 
            description: '神器碎片1000个', 
            cost: 100000, 
            type: 'material',
            effect: 'material'
        }
    },
traps: {
    // 陷阱类型配置
    types: {
        poison: { weight: 20, name: '毒液陷阱', damageType: 'percentage', damage: 0.15, duration: 3 },
        spike: { weight: 15, name: '尖刺陷阱', damageType: 'fixed', damage: 1000, duration: 1 },
        curse: { weight: 10, name: '诅咒陷阱', damageType: 'debuff', effect: 'attack', value: -0.3, duration: 5 },
        slow: { weight: 12, name: '迟缓陷阱', damageType: 'time', damage: 30, duration: 0 },
        confusion: { weight: 8, name: '混乱陷阱', damageType: 'random', damage: 0.2, duration: 2 },
        disarm: { weight: 5, name: '缴械陷阱', damageType: 'debuff', effect: 'critRate', value: -0.5, duration: 4 }
    },
    
    // 陷阱检测技能
    detectionSkills: {
        basic: { name: '基础侦查', successRate: 0.3, cost: 5 },
        advanced: { name: '高级侦查', successRate: 0.6, cost: 15 },
        expert: { name: '专家侦查', successRate: 0.8, cost: 25 },
        master: { name: '大师侦查', successRate: 0.95, cost: 40 }
    },
    // 陷阱解除技能
    disarmSkills: {
        basic: { name: '基础解除', successRate: 0.4, cost: 10 },
        advanced: { name: '高级解除', successRate: 0.7, cost: 20 },
        expert: { name: '专家解除', successRate: 0.85, cost: 35 },
        master: { name: '大师解除', successRate: 1.0, cost: 50 }
    },
    // 玩家掌握的陷阱技能
    playerSkills: {
        detection: 'basic',
        disarm: 'basic'
    }
}
},
  nightClub: {
    level: 1,
    exp: 0,
    starCoins: 0,
    staff: [
        { type: 'waiter', level: 1, expOutput: 0.5, coinsOutput: 0.2 },
        { type: 'guard', level: 1, expOutput: 0.3, coinsOutput: 0.1 },
        { type: 'dj', level: 1, expOutput: 1.0, coinsOutput: 0.5 },
        { type: 'chef', level: 1, expOutput: 0.4, coinsOutput: 0.3 },
        { type: 'hostess', level: 1, expOutput: 0.7, coinsOutput: 0.4 }
    ],
    equipment: [
        { type: 'sound', level: 1, bonus: 1.05 },
        { type: 'light', level: 1, bonus: 1.03 },
        { type: 'bar', level: 1, bonus: 1.02 },
        { type: 'dancefloor', level: 1, bonus: 1.04 }
    ],
    vip: {
        lastVisit: 0,
        nextVisit: 0
    },
    activeEvent: null,
    lastUpdate: Date.now()
},
    collections: {
        lightSpeedHand: 0,
        empHand: 0,
        godlyHand: 0,
        quickHand: 0,
        shadowHand: 0,
        quantumHand: 0,
        lightningHand: 0,
        divineHand: 0
    },
    pets: {
        thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
        chaosTaotie: { level: 0, cost: 1, multiplier: 0.30 },
        netherQiongqi: { level: 0, cost: 1, multiplier: 0.90 },
        abyssKun: { level: 0, cost: 1, multiplier: 2.70 },
        primordialZhuLong: { level: 0, cost: 1, multiplier: 8.10 },
        wanJunSuanNi: { level: 0, cost: 1, multiplier: 24.30 },
         yanYuBiAn: { level: 0, cost: 1, multiplier: 72.90 },
        yuyu1: { level: 0, cost: 1, multiplier: 218.70 },
         yuyu2: { level: 0, cost: 1, multiplier: 656.10 },   
              yuyu3: { level: 0, cost: 1, multiplier: 1968.30 },
         yuyu4: { level: 0, cost: 1, multiplier: 5904.90 },
              yuyu5: { level: 0, cost: 1, multiplier: 17714.70 },
              yuyu6: { level: 0, cost: 1, multiplier: 53144.10 },
         yuyu7: { level: 0, cost: 1, multiplier: 159432.30 },
              yuyu8: { level: 0, cost: 1, multiplier: 478296.50 }   
    },
    dungeonEquipment: [],
     techniques: {}, 
            soulRings: [], 
            attributes: {
              totalPoints: 0,
               remainingPoints: 0,
                health: 0,
            attack: 0,
             critRate: 0,
              critDamage: 0,
             multiAttack: 0,
           block: 0
            },
      farm: {
    level: 1,
    exp: 0,
    expToNextLevel: 100,
    fields: [],
    maxFields: 2,
    seeds: {},
    water: 10,
    lastUpdate: Date.now(),
    autoPlant: false,    // 新增自动种植设置
    autoHarvest: false
},
            lastUpdate: Date.now(),
            achievements: {
    "first_equipment": false,
    "first_rare": false,
    "first_epic": false,
    "first_legendary": false,
    "first_ancient": false,
    "first_divine": false,
    "first_arcane": false,
    "first_celestial": false,
    "first_infernal": false,
    "first_astral": false,
    "first_primeval": false,
    "first_transcendental": false,
    "first_quantum": false,
    "first_ultimate": false,
    "first_chaos": false,
    "first_eternal": false,
    "first_void": false,
    "first_genesis": false,
    "first_divineRealm": false,
    "first_apocalypse": false,
    "first_yeyu1": false,
    "first_yeyu2": false,
    "first_yeyu3": false,
    "first_yeyu4": false,
    "first_yeyu5": false,
    "first_yeyu6": false,
    "first_yeyu7": false,
    "first_yeyu8": false,
    "first_yeyu9": false,
    "first_yeyu10": false,
    "first_yeyu11": false,
    "first_yeyu12": false,
    "first_yeyu13": false,
    "first_yeyu14": false,
    "first_yeyu15": false,
    "first_yeyu16": false,
    "first_yeyu17": false,
    "first_yeyu18": false,
    "first_yeyu19": false,
    "first_yeyu20": false,
    "first_yeyu21": false,
    "first_yeyu22": false,
    "first_yeyu23": false,
    "first_yeyu24": false,
    "common_chest_100": false,
    "common_chest_10000": false,
    "common_chest_1000000": false,
    "common_chest_10000000": false,
    "common_chest_100000000": false,
    "advanced_chest_100": false,
    "advanced_chest_10000": false,
    "advanced_chest_1000000": false,
    "advanced_chest_10000000": false,
    "advanced_chest_100000000": false,
    "rare_chest_100": false,
    "rare_chest_10000": false,
    "rare_chest_1000000": false,
    "rare_chest_10000000": false,
    "rare_chest_100000000": false,
    "epic_chest_100": false,
    "epic_chest_10000": false,
    "epic_chest_1000000": false,
    "epic_chest_10000000": false,
    "epic_chest_100000000": false,
    "legendary_chest_100": false,
    "legendary_chest_10000": false,
    "legendary_chest_1000000": false,
    "legendary_chest_10000000": false,
    "legendary_chest_100000000": false,
    "chaos_chest_100": false,
    "chaos_chest_10000": false,
    "chaos_chest_1000000": false,
    "chaos_chest_10000000": false,
    "chaos_chest_100000000": false,
    "apocalypse_chest_100": false,
    "apocalypse_chest_10000": false,
    "apocalypse_chest_1000000": false,
    "apocalypse_chest_10000000": false,
    "apocalypse_chest_100000000": false,
    "yeyu1_chest_100": false,
    "yeyu1_chest_10000": false,
    "yeyu1_chest_1000000": false,
    "yeyu1_chest_10000000": false,
    "yeyu1_chest_100000000": false,
    "yeyu2_chest_100": false,
    "yeyu2_chest_10000": false,
    "yeyu2_chest_1000000": false,
    "yeyu2_chest_10000000": false,
    "yeyu2_chest_100000000": false,
    "yeyu3_chest_100": false,
    "yeyu3_chest_10000": false,
    "yeyu3_chest_1000000": false,
    "yeyu3_chest_10000000": false,
    "yeyu3_chest_100000000": false,
    "yeyu4_chest_100": false,
    "yeyu4_chest_10000": false,
    "yeyu4_chest_1000000": false,
    "yeyu4_chest_10000000": false,
    "yeyu4_chest_100000000": false,
    "yeyu5_chest_100": false,
    "yeyu5_chest_10000": false,
    "yeyu5_chest_1000000": false,
    "yeyu5_chest_10000000": false,
    "yeyu5_chest_100000000": false,
    "yeyu6_chest_100": false,
    "yeyu6_chest_10000": false,
    "yeyu6_chest_1000000": false,
    "yeyu6_chest_10000000": false,
    "yeyu6_chest_100000000": false,
    "yeyu7_chest_100": false,
    "yeyu7_chest_10000": false,
    "yeyu7_chest_1000000": false,
    "yeyu7_chest_10000000": false,
    "yeyu7_chest_100000000": false,
    "yeyu8_chest_100": false,
    "yeyu8_chest_10000": false,
    "yeyu8_chest_1000000": false,
    "yeyu8_chest_10000000": false,
    "yeyu8_chest_100000000": false,
    "max_stage_10": false,
    "max_stage_30": false,
    "max_stage_60": false,
    "max_stage_90": false,
    "max_stage_120": false,
    "max_stage_200": false,
    "max_stage_300": false,
    "max_stage_400": false,
    "max_stage_500": false,
    "max_stage_600": false,
    "max_stage_700": false,
    "max_stage_800": false,
    "max_stage_900": false,
    "max_stage_1000": false,

    // 新增宠物成就状态
    "thunderKirin_10": false,
    "thunderKirin_50": false,
    "thunderKirin_100": false,
    "chaosTaotie_10": false,
    "chaosTaotie_50": false,
    "chaosTaotie_100": false,
    "netherQiongqi_10": false,
    "netherQiongqi_50": false,
    "netherQiongqi_100": false,
    "abyssKun_10": false,
    "abyssKun_50": false,
    "abyssKun_100": false,
    "primordialZhuLong_10": false,
    "primordialZhuLong_50": false,
    "primordialZhuLong_100": false,
    "wanJunSuanNi_10": false,
    "wanJunSuanNi_50": false,
    "wanJunSuanNi_100": false,
    "yanYuBiAn_10": false,
    "yanYuBiAn_50": false,
    "yanYuBiAn_100": false,
    "yuyu1_10": false,
    "yuyu1_50": false,
    "yuyu1_100": false,
    "yuyu2_10": false,
    "yuyu2_50": false,
    "yuyu2_100": false,
    "yuyu3_10": false,
    "yuyu3_50": false,
    "yuyu3_100": false,
    "yuyu4_10": false,
    "yuyu4_50": false,
    "yuyu4_100": false,
    "yuyu5_10": false,
    "yuyu5_50": false,
    "yuyu5_100": false,
    "yuyu6_10": false,
    "yuyu6_50": false,
    "yuyu6_100": false,
    "yuyu7_10": false,
    "yuyu7_50": false,
    "yuyu7_100": false,
    "yuyu8_10": false,
    "yuyu8_50": false,
    "yuyu8_100": false,

    // 新增魂环成就状态
    "year1_10": false,
    "year10_10": false,
    "year100_10": false,
    "year1000_10": false,
    "year10000_10": false,
    "year100000_10": false,
    "year1000000_10": false,
    "year10000000_10": false,
    "year100000000_10": false,
    "year1_100": false,
    "year10_100": false,
    "year100_100": false,
    "year1000_100": false,
    "year10000_100": false,
    "year100000_100": false,
    "year1000000_100": false,
    "year10000000_100": false,
    "year100000000_100": false,
    "year1_1000": false,
    "year10_1000": false,
    "year100_1000": false,
    "year1000_1000": false,
    "year10000_1000": false,
    "year100000_1000": false,
    "year1000000_1000": false,
    "year10000000_1000": false,
    "year100000000_1000": false,
    "year1_10000": false,
    "year10_10000": false,
    "year100_10000": false,
    "year1000_10000": false,
    "year10000_10000": false,
    "year100000_10000": false,
    "year1000000_10000": false,
    "year10000000_10000": false,
    "year100000000_10000": false,
    "year2_10": false,
    "year2_100": false,
    "year2_1000": false,
    "year2_10000": false,
    "year3_10": false,
    "year3_100": false,
    "year3_1000": false,
    "year3_10000": false,
    "year4_10": false,
    "year4_100": false,
    "year4_1000": false,
    "year4_10000": false,
    "year5_10": false,
    "year5_100": false,
    "year5_1000": false,
    "year5_10000": false,
    "year6_10": false,
    "year6_100": false,
    "year6_1000": false,
    "year6_10000": false,
    "year7_10": false,
    "year7_100": false,
    "year7_1000": false,
    "year7_10000": false,
    "year8_10": false,
    "year8_100": false,
    "year8_1000": false,
    "year8_10000": false,
    "year9_10": false,
    "year9_100": false,
    "year9_1000": false,
    "year9_10000": false,
    "year11_10": false,
    "year11_100": false,
    "year11_1000": false,
    "year11_10000": false,
    "year12_10": false,
    "year12_100": false,
    "year12_1000": false,
    "year12_10000": false,
    "year13_10": false,
    "year13_100": false,
    "year13_1000": false,
    "year13_10000": false,
    "year14_10": false,
    "year14_100": false,
    "year14_1000": false,
    "year14_10000": false,
    "year15_10": false,
    "year15_100": false,
    "year15_1000": false,
    "year15_10000": false,
    "year16_10": false,
    "year16_100": false,
    "year16_1000": false,
    "year16_10000": false,
    "year17_10": false,
    "year17_100": false,
    "year17_1000": false,
    "year17_10000": false,
    "year18_10": false,
    "year18_100": false,
    "year18_1000": false,
    "year18_10000": false,
    "year19_10": false,
    "year19_100": false,
    "year19_1000": false,
    "year19_10000": false,
    "year20_10": false,
    "year20_100": false,
    "year20_1000": false,
    "year20_10000": false,
    "year21_10": false,
    "year21_100": false,
    "year21_1000": false,
    "year21_10000": false,
    "year22_10": false,
    "year22_100": false,
    "year22_1000": false,
    "year22_10000": false,
    "year23_10": false,
    "year23_100": false,
    "year23_1000": false,
    "year23_10000": false,
    "year24_10": false,
    "year24_100": false,
    "year24_1000": false,
    "year24_10000": false,
    "year25_10": false,
    "year25_100": false,
    "year25_1000": false,
    "year25_10000": false,
    "year26_10": false,
    "year26_100": false,
    "year26_1000": false,
    "year26_10000": false,
    "year27_10": false,
    "year27_100": false,
    "year27_1000": false,
    "year27_10000": false,
    "year28_10": false,
    "year28_100": false,
    "year28_1000": false,
    "year28_10000": false,
    "year29_10": false,
    "year29_100": false,
    "year29_1000": false,
    "year29_10000": false,
    "year30_10": false,
    "year30_100": false,
    "year30_1000": false,
    "year30_10000": false,
    "year31_10": false,
    "year31_100": false,
    "year31_1000": false,
    "year31_10000": false,
    "year32_10": false,
    "year32_100": false,
    "year32_1000": false,
    "year32_10000": false,
    "year33_10": false,
    "year33_100": false,
    "year33_1000": false,
    "year33_10000": false,
    "year34_10": false,
    "year34_100": false,
    "year34_1000": false,
    "year34_10000": false,
    "year35_10": false,
    "year35_100": false,
    "year35_1000": false,
    "year35_10000": false,
    "year36_10": false,
    "year36_100": false,
    "year36_1000": false,
    "year36_10000": false,
    "year37_10": false,
    "year37_100": false,
    "year37_1000": false,
    "year37_10000": false,
    "world_boss_1st": false,
    "world_boss_top5": false,
    "world_boss_top10": false,
    "world_boss_participant": false,
    "reincarnation_10": false,
    "reincarnation_100": false,
    "reincarnation_1000": false,
    "reincarnation_10000": false
      },
            actionLogs: [], 
            goldLogs: [],
            autoBuy: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], 
            autoBuySpeedBoost: false,
            onlineBoostEnabled: false,
            autoBuyMaterialChest: false, 
            autoBuyTechniqueChest: false, 
            autoBuyTechniqueMaxCost: 1,
            gpsMultiplier: 1, 
            clickMultiplier: 1,
            autoConvert: false,
            autoConvertCurrency: { 
                gold: false,
                diamond: false,
                titanium: false,
                starstone: false
            },
            clickTimestamps: [], 
            chestCounts: { 
                common: 0,
                advanced: 0,
                rare: 0,
                epic: 0,
                legendary: 0
            },
            reincarnationStats: { 
                gpsBonus: { level: 0, cost: 1 },
                equipmentLevelBonus: { level: 0, cost: 1 },
                clickLimitBonus: { level: 0, cost: 1 }
            },
            materialChestCost: 1,
            techniqueChestCost: 1,
            stockData: { 
                stocks: [
                    { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                    { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                    { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                    { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                    { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
                ],
                lastStockUpdate: Date.now()
            },
     fundData: {
    funds: [
        { name: "稳健型基金", netValue: 1.00, maxInvestment: 100000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "平衡型基金", netValue: 1.00, maxInvestment: 1000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "成长型基金", netValue: 1.00, maxInvestment: 100000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "进取型基金", netValue: 1.00, maxInvestment: 1e15, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "激进型基金", netValue: 1.00, maxInvestment: 1e30, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "风险型基金", netValue: 1.00, maxInvestment: 1e50, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 }
    ],
    lastFundUpdate: Date.now()
},
            lotteryResults: [],
            traditionalLotteryNumbers: [],
         traditionalLotteryPurchased: false,
          traditionalLotteryBought: false,
         traditionalLotteryDrawTime: 0,
            lastLotteryDraw: Date.now(),
           titles: {
        unlocked: [], // 已解锁称号列表
        current: null // 当前选择的称号
    },
            bank: { 
                deposit: 0, 
                lastInterestUpdate: Date.now() 
            },
         parking: {
            level: 1,
            exp: 0,
            maxSpots: 1,
            vehicles: [],
            parkedVehicles: [],
            lastUpdate: Date.now(),
            totalIncome: 0
        },
            battle: {
                currentStage: 0,
        maxStage: 0,
        monster: null,
        playerHealth: 0,
        playerAttack: 0,
        playerCritRate: 0.1,
        playerCritDamage: 1.5,
        playerAccuracy: 0.9,
        playerDodge: 0.1,
        autoSweepEnabled: false  
    }
};
        // 成就奖励配置
        const achievementRewards = {
    "common": { gpsMultiplier: 0.15, description: "获得普通装备，GPS +15%" },
    "rare": { gpsMultiplier: 0.30, description: "获得稀有装备，GPS +30%" },
    "epic": { gpsMultiplier: 0.45, description: "获得史诗装备，GPS +45%" },
    "legendary": { gpsMultiplier: 0.60, description: "获得传说装备，GPS +60%" },
    "ancient": { gpsMultiplier: 0.75, description: "获得远古装备，GPS +75%" },
    "divine": { gpsMultiplier: 0.90, description: "获得神圣装备，GPS +90%" },
    "arcane": { gpsMultiplier: 1.05, description: "获得奥术装备，GPS +105%" },
    "celestial": { gpsMultiplier: 1.30, description: "获得天空装备，GPS +130%" },
    "infernal": { gpsMultiplier: 1.45, description: "获得地狱装备，GPS +145%" },
    "astral": { gpsMultiplier: 1.60, description: "获得星界装备，GPS +160%" },
    "primeval": { gpsMultiplier: 1.75, description: "获得原初装备，GPS +175%" },
    "transcendental": { gpsMultiplier: 1.90, description: "获得超凡装备，GPS +190%" },
    "quantum": { gpsMultiplier: 2.05, description: "获得量子装备，GPS +205%" },
    "ultimate": { gpsMultiplier: 2.20, description: "获得究极装备，GPS +220%" },
    "chaos": { gpsMultiplier: 2.35, description: "获得混沌装备，GPS +235%" },
    "eternal": { gpsMultiplier: 2.50, description: "获得永恒装备，GPS +250%" },
    "void": { gpsMultiplier: 2.70, description: "获得虚无装备，GPS +270%" },
    "genesis": { gpsMultiplier: 2.80, description: "获得创世装备，GPS +280%" },
    "divineRealm": { gpsMultiplier: 2.90, description: "获得神域装备，GPS +290%" },
    "apocalypse": { gpsMultiplier: 3.00, description: "获得终焉装备，GPS +300%" },
    "yeyu1": { gpsMultiplier: 3.10, description: "获得星辰装备，GPS +310%" },
    "yeyu2": { gpsMultiplier: 3.20, description: "获得起源装备，GPS +320%" },
    "yeyu3": { gpsMultiplier: 3.30, description: "获得时光装备，GPS +330%" },
    "yeyu4": { gpsMultiplier: 3.40, description: "获得造物装备，GPS +340%" },
    "yeyu5": { gpsMultiplier: 3.50, description: "获得银河装备，GPS +350%" },
    "yeyu6": { gpsMultiplier: 3.60, description: "获得天界装备，GPS +360%" },
    "yeyu7": { gpsMultiplier: 3.70, description: "获得星云装备，GPS +370%" },
    "yeyu8": { gpsMultiplier: 3.80, description: "获得星河装备，GPS +380%" },
    "yeyu9": { gpsMultiplier: 3.90, description: "获得纪元装备，GPS +390%" },
    "yeyu10": { gpsMultiplier: 4.00, description: "获得鸿蒙装备，GPS +400%" },
    "yeyu11": { gpsMultiplier: 4.10, description: "获得星穹装备，GPS +410%" },
    "yeyu12": { gpsMultiplier: 4.20, description: "获得亘古装备，GPS +420%" },
    "yeyu13": { gpsMultiplier: 4.30, description: "获得万象装备，GPS +430%" },
    "yeyu14": { gpsMultiplier: 4.40, description: "获得太虚装备，GPS +440%" },
    "yeyu15": { gpsMultiplier: 4.50, description: "获得九垓装备，GPS +450%" },
    "yeyu16": { gpsMultiplier: 4.60, description: "获得穿梭装备，GPS +460%" },
    "yeyu17": { gpsMultiplier: 4.70, description: "获得恒古装备，GPS +470%" },
    "yeyu18": { gpsMultiplier: 4.80, description: "获得虚空装备，GPS +480%" },    
     "yeyu19": { gpsMultiplier: 4.90, description: "获得蔚来装备，GPS +490%" },
    "yeyu20": { gpsMultiplier: 5.00, description: "获得神罚装备，GPS +500%" },
    "yeyu21": { gpsMultiplier: 5.10, description: "获得时空装备，GPS +510%" },    
    "yeyu22": { gpsMultiplier: 5.20, description: "获得未来装备，GPS +520%" },
    "yeyu23": { gpsMultiplier: 5.30, description: "获得从前装备，GPS +530%" },
    "yeyu24": { gpsMultiplier: 5.40, description: "获得星澜装备，GPS +540%" },    
    // 新增成就奖励
    "common_chest_100": { gpsMultiplier: 0.10, description: "购买普通宝箱总数达到100个，GPS +10%" },
    "common_chest_10000": { gpsMultiplier: 0.20, description: "购买普通宝箱总数达到1万个，GPS +20%" },
    "common_chest_1000000": { gpsMultiplier: 0.40, description: "购买普通宝箱总数达到100万个，GPS +40%" },
    "common_chest_10000000": { gpsMultiplier: 0.80, description: "购买普通宝箱总数达到1000万个，GPS +80%" },
    "common_chest_100000000": { gpsMultiplier: 1.00, description: "购买普通宝箱总数达到1亿个，GPS +100%" },
    "advanced_chest_100": { gpsMultiplier: 0.20, description: "购买高级宝箱总数达到100个，GPS +20%" },
    "advanced_chest_10000": { gpsMultiplier: 0.40, description: "购买高级宝箱总数达到1万个，GPS +40%" },
    "advanced_chest_1000000": { gpsMultiplier: 0.70, description: "购买高级宝箱总数达到100万个，GPS +70%" },
    "advanced_chest_10000000": { gpsMultiplier: 1.20, description: "购买高级宝箱总数达到1000万个，GPS +120%" },
    "advanced_chest_100000000": { gpsMultiplier: 1.70, description: "购买高级宝箱总数达到1亿个，GPS +170%" },
    "rare_chest_100": { gpsMultiplier: 0.30, description: "购买稀有宝箱总数达到100个，GPS +30%" },
    "rare_chest_10000": { gpsMultiplier: 0.60, description: "购买稀有宝箱总数达到1万个，GPS +60%" },
    "rare_chest_1000000": { gpsMultiplier: 1.00, description: "购买稀有宝箱总数达到100万个，GPS +100%" },
    "rare_chest_10000000": { gpsMultiplier: 1.60, description: "购买稀有宝箱总数达到1000万个，GPS +160%" },
    "rare_chest_100000000": { gpsMultiplier: 2.40, description: "购买稀有宝箱总数达到1亿个，GPS +240%" },
    "epic_chest_100": { gpsMultiplier: 0.40, description: "购买史诗宝箱总数达到100个，GPS +40%" },
    "epic_chest_10000": { gpsMultiplier: 0.80, description: "购买史诗宝箱总数达到1万个，GPS +80%" },
    "epic_chest_1000000": { gpsMultiplier: 1.30, description: "购买史诗宝箱总数达到100万个，GPS +130%" },
    "epic_chest_10000000": { gpsMultiplier: 2.00, description: "购买史诗宝箱总数达到1000万个，GPS +200%" },
    "epic_chest_100000000": { gpsMultiplier: 3.10, description: "购买史诗宝箱总数达到1亿个，GPS +310%" },
    "legendary_chest_100": { gpsMultiplier: 0.50, description: "购买传说宝箱总数达到100个，GPS +50%" },
    "legendary_chest_10000": { gpsMultiplier: 1.00, description: "购买传说宝箱总数达到1万个，GPS +100%" },
    "legendary_chest_1000000": { gpsMultiplier: 1.60, description: "购买传说宝箱总数达到100万个，GPS +160%" },
    "legendary_chest_10000000": { gpsMultiplier: 2.40, description: "购买传说宝箱总数达到1000万个，GPS +240%" },
    "legendary_chest_100000000": { gpsMultiplier: 3.80, description: "购买传说宝箱总数达到1亿个，GPS +380%" },
    "chaos_chest_100": { gpsMultiplier: 0.60, description: "购买混沌宝箱总数达到100个，GPS +60%" },
    "chaos_chest_10000": { gpsMultiplier: 1.20, description: "购买混沌宝箱总数达到1万个，GPS +120%" },
    "chaos_chest_1000000": { gpsMultiplier: 1.90, description: "购买混沌宝箱总数达到100万个，GPS +190%" },
    "chaos_chest_10000000": { gpsMultiplier: 2.80, description: "购买混沌宝箱总数达到1000万个，GPS +280%" },
    "chaos_chest_100000000": { gpsMultiplier: 4.50, description: "购买混沌宝箱总数达到1亿个，GPS +450%" },
    "apocalypse_chest_100": { gpsMultiplier: 0.70, description: "购买终焉宝箱总数达到100个，GPS +70%" },
    "apocalypse_chest_10000": { gpsMultiplier: 1.40, description: "购买终焉宝箱总数达到1万个，GPS +140%" },
    "apocalypse_chest_1000000": { gpsMultiplier: 2.20, description: "购买终焉宝箱总数达到100万个，GPS +220%" },
    "apocalypse_chest_10000000": { gpsMultiplier: 3.20, description: "购买终焉宝箱总数达到1000万个，GPS +320%" },
    "apocalypse_chest_100000000": { gpsMultiplier: 5.20, description: "购买终焉宝箱总数达到1亿个，GPS +520%" },
    "yeyu1_chest_100": { gpsMultiplier: 0.80, description: "购买星辰宝箱总数达到100个，GPS +80%" },
    "yeyu1_chest_10000": { gpsMultiplier: 1.50, description: "购买星辰宝箱总数达到1万个，GPS +150%" },
    "yeyu1_chest_1000000": { gpsMultiplier: 2.30, description: "购买星辰宝箱总数达到100万个，GPS +230%" },
    "yeyu1_chest_10000000": { gpsMultiplier: 3.30, description: "购买星辰宝箱总数达到1000万个，GPS +330%" },
    "yeyu1_chest_100000000": { gpsMultiplier: 5.30, description: "购买星辰宝箱总数达到1亿个，GPS +530%" },
    "yeyu2_chest_100": { gpsMultiplier: 0.90, description: "购买银河宝箱总数达到100个，GPS +90%" },
    "yeyu2_chest_10000": { gpsMultiplier: 1.60, description: "购买银河宝箱总数达到1万个，GPS +160%" },
    "yeyu2_chest_1000000": { gpsMultiplier: 2.40, description: "购买银河宝箱总数达到100万个，GPS +240%" },
    "yeyu2_chest_10000000": { gpsMultiplier: 3.40, description: "购买银河宝箱总数达到1000万个，GPS +340%" },
    "yeyu2_chest_100000000": { gpsMultiplier: 5.40, description: "购买银河宝箱总数达到1亿个，GPS +540%" },
        "yeyu3_chest_100": { gpsMultiplier: 1.00, description: "购买星云宝箱总数达到100个，GPS +100%" },
    "yeyu3_chest_10000": { gpsMultiplier: 1.70, description: "购买星云宝箱总数达到1万个，GPS +170%" },
    "yeyu3_chest_1000000": { gpsMultiplier: 2.50, description: "购买星云宝箱总数达到100万个，GPS +250%" },
    "yeyu3_chest_10000000": { gpsMultiplier: 3.50, description: "购买星云宝箱总数达到1000万个，GPS +350%" },
    "yeyu3_chest_100000000": { gpsMultiplier: 5.50, description: "购买星云宝箱总数达到1亿个，GPS +550%" },
        "yeyu4_chest_100": { gpsMultiplier: 1.10, description: "购买鸿蒙宝箱总数达到100个，GPS +110%" },
    "yeyu4_chest_10000": { gpsMultiplier: 1.80, description: "购买鸿蒙宝箱总数达到1万个，GPS +180%" },
    "yeyu4_chest_1000000": { gpsMultiplier: 2.60, description: "购买鸿蒙宝箱总数达到100万个，GPS +260%" },
    "yeyu4_chest_10000000": { gpsMultiplier: 3.60, description: "购买鸿蒙宝箱总数达到1000万个，GPS +360%" },
    "yeyu4_chest_100000000": { gpsMultiplier: 5.60, description: "购买鸿蒙宝箱总数达到1亿个，GPS +560%" },
        "yeyu5_chest_100": { gpsMultiplier: 1.20, description: "购买太虚宝箱总数达到100个，GPS +120%" },
    "yeyu5_chest_10000": { gpsMultiplier: 1.90, description: "购买太虚宝箱总数达到1万个，GPS +190%" },
    "yeyu5_chest_1000000": { gpsMultiplier: 2.70, description: "购买太虚宝箱总数达到100万个，GPS +270%" },
    "yeyu5_chest_10000000": { gpsMultiplier: 3.70, description: "购买太虚宝箱总数达到1000万个，GPS +370%" },
    "yeyu5_chest_100000000": { gpsMultiplier: 5.70, description: "购买太虚宝箱总数达到1亿个，GPS +570%" },
       "yeyu6_chest_100": { gpsMultiplier: 1.30, description: "购买星云宝箱总数达到100个，GPS +130%" },
    "yeyu6_chest_10000": { gpsMultiplier: 2.00, description: "购买星云宝箱总数达到1万个，GPS +200%" },
    "yeyu6_chest_1000000": { gpsMultiplier: 2.80, description: "购买星云宝箱总数达到100万个，GPS +280%" },
    "yeyu6_chest_10000000": { gpsMultiplier: 3.70, description: "购买星云宝箱总数达到1000万个，GPS +370%" },
    "yeyu6_chest_100000000": { gpsMultiplier: 5.70, description: "购买星云宝箱总数达到1亿个，GPS +570%" },
    "yeyu7_chest_100": { gpsMultiplier: 1.40, description: "购买鸿蒙宝箱总数达到100个，GPS +140%" },
    "yeyu7_chest_10000": { gpsMultiplier: 2.10, description: "购买鸿蒙宝箱总数达到1万个，GPS +210%" },
    "yeyu7_chest_1000000": { gpsMultiplier: 2.90, description: "购买鸿蒙宝箱总数达到100万个，GPS +290%" },
    "yeyu7_chest_10000000": { gpsMultiplier: 3.80, description: "购买鸿蒙宝箱总数达到1000万个，GPS +380%" },
    "yeyu7_chest_100000000": { gpsMultiplier: 5.80, description: "购买鸿蒙宝箱总数达到1亿个，GPS +580%" },
    "yeyu8_chest_100": { gpsMultiplier: 1.50, description: "购买太虚宝箱总数达到100个，GPS +120%" },
    "yeyu8_chest_10000": { gpsMultiplier: 2.20, description: "购买太虚宝箱总数达到1万个，GPS +220%" },
    "yeyu8_chest_1000000": { gpsMultiplier: 3.00, description: "购买太虚宝箱总数达到100万个，GPS +300%" },
    "yeyu8_chest_10000000": { gpsMultiplier: 3.90, description: "购买太虚宝箱总数达到1000万个，GPS +390%" },
    "yeyu8_chest_100000000": { gpsMultiplier: 5.90, description: "购买太虚宝箱总数达到1亿个，GPS +590%" },
    "max_stage_10": { gpsMultiplier: 0.20, description: "达到最大关卡10，GPS +20%" },
    "max_stage_30": { gpsMultiplier: 0.50, description: "达到最大关卡30，GPS +50%" },
    "max_stage_60": { gpsMultiplier: 0.80, description: "达到最大关卡60，GPS +80%" },
    "max_stage_90": { gpsMultiplier: 1.20, description: "达到最大关卡90，GPS +120%" },
    "max_stage_120": { gpsMultiplier: 1.50, description: "达到最大关卡120，GPS +150%" },
    "max_stage_200": { gpsMultiplier: 1.80, description: "达到最大关卡200，GPS +180%" },
    "max_stage_300": { gpsMultiplier: 2.10, description: "达到最大关卡300，GPS +210%" },
    "max_stage_400": { gpsMultiplier: 2.40, description: "达到最大关卡400，GPS +240%" },
    "max_stage_500": { gpsMultiplier: 2.70, description: "达到最大关卡500，GPS +270%" },
    "max_stage_600": { gpsMultiplier: 3.00, description: "达到最大关卡600，GPS +300%" },
    "max_stage_700": { gpsMultiplier: 3.30, description: "达到最大关卡700，GPS +330%" },
    "max_stage_800": { gpsMultiplier: 3.60, description: "达到最大关卡800，GPS +360%" },
    "max_stage_900": { gpsMultiplier: 3.90, description: "达到最大关卡900，GPS +390%" },
    "max_stage_1000": { gpsMultiplier: 4.10, description: "达到最大关卡1000，GPS +410%" },

    // 新增宠物成就
    "thunderKirin_10": { gpsMultiplier: 0.10, description: "苍雷麒麟达到10级，GPS +10%" },
    "thunderKirin_50": { gpsMultiplier: 0.30, description: "苍雷麒麟达到50级，GPS +30%" },
    "thunderKirin_100": { gpsMultiplier: 1.00, description: "苍雷麒麟达到100级，GPS +100%" },
    "chaosTaotie_10": { gpsMultiplier: 0.20, description: "混沌饕餮达到10级，GPS +20%" },
    "chaosTaotie_50": { gpsMultiplier: 0.40, description: "混沌饕餮达到50级，GPS +40%" },
    "chaosTaotie_100": { gpsMultiplier: 1.20, description: "混沌饕餮达到100级，GPS +120%" },
    "netherQiongqi_10": { gpsMultiplier: 0.20, description: "九幽穷奇达到10级，GPS +20%" },
    "netherQiongqi_50": { gpsMultiplier: 0.50, description: "九幽穷奇达到50级，GPS +50%" },
    "netherQiongqi_100": { gpsMultiplier: 1.50, description: "九幽穷奇达到100级，GPS +150%" },
    "abyssKun_10": { gpsMultiplier: 0.30, description: "霸渊巨鲲达到10级，GPS +30%" },
    "abyssKun_50": { gpsMultiplier: 0.70, description: "霸渊巨鲲达到50级，GPS +70%" },
    "abyssKun_100": { gpsMultiplier: 2.00, description: "霸渊巨鲲达到100级，GPS +200%" },
    "primordialZhuLong_10": { gpsMultiplier: 0.50, description: "太初烛龙达到10级，GPS +50%" },
    "primordialZhuLong_50": { gpsMultiplier: 1.00, description: "太初烛龙达到50级，GPS +100%" },
    "primordialZhuLong_100": { gpsMultiplier: 2.50, description: "太初烛龙达到100级，GPS +250%" },
    "wanJunSuanNi_10": { gpsMultiplier: 0.70, description: "万钧狻猊达到10级，GPS +70%" },
    "wanJunSuanNi_50": { gpsMultiplier: 1.50, description: "万钧狻猊达到50级，GPS +150%" },
    "wanJunSuanNi_100": { gpsMultiplier: 3.00, description: "万钧狻猊达到100级，GPS +300%" },
    "yanYuBiAn_10": { gpsMultiplier: 1.00, description: "炎狱狴犴达到10级，GPS +100%" },
    "yanYuBiAn_50": { gpsMultiplier: 2.00, description: "炎狱狴犴达到50级，GPS +200%" },
    "yanYuBiAn_100": { gpsMultiplier: 3.50, description: "炎狱狴犴达到100级，GPS +350%" },
     "yuyu1_10": { gpsMultiplier: 1.00, description: "赤霄夔龙达到10级，GPS +100%" },
    "yuyu1_50": { gpsMultiplier: 2.50, description: "赤霄夔龙达到50级，GPS +250%" },
    "yuyu1_100": { gpsMultiplier: 4.00, description: "赤霄夔龙达到100级，GPS +400%" },
    "yuyu2_10": { gpsMultiplier: 1.30, description: "震岳白泽达到10级，GPS +130%" },
    "yuyu2_50": { gpsMultiplier: 3.00, description: "震岳白泽达到50级，GPS +300%" },
    "yuyu2_100": { gpsMultiplier: 4.50, description: "震岳白泽达到100级，GPS +450%" },
    "yuyu3_10": { gpsMultiplier: 1.60, description: "焚天蛊雕达到10级，GPS +160%" },
    "yuyu3_50": { gpsMultiplier: 3.50, description: "焚天蛊雕达到50级，GPS +350%" },
    "yuyu3_100": { gpsMultiplier: 5.00, description: "焚天蛊雕达到100级，GPS +500%" },
    "yuyu4_10": { gpsMultiplier: 1.90, description: "血煞梼杌达到10级，GPS +190%" },
    "yuyu4_50": { gpsMultiplier: 4.00, description: "血煞梼杌达到50级，GPS +400%" },
    "yuyu4_100": { gpsMultiplier: 5.50, description: "血煞梼杌达到100级，GPS +550%" },
    "yuyu5_10": { gpsMultiplier: 2.20, description: "玄渊白犼达到10级，GPS +220%" },
    "yuyu5_50": { gpsMultiplier: 4.50, description: "玄渊白犼达到50级，GPS +450%" },
    "yuyu5_100": { gpsMultiplier: 6.00, description: "玄渊白犼达到100级，GPS +600%" },
    "yuyu6_10": { gpsMultiplier: 2.50, description: "灾祸蜚牛达到10级，GPS +250%" },
    "yuyu6_50": { gpsMultiplier: 5.00, description: "灾祸蜚牛达到50级，GPS +500%" },
    "yuyu6_100": { gpsMultiplier: 6.50, description: "灾祸蜚牛达到100级，GPS +650%" },
    "yuyu7_10": { gpsMultiplier: 2.80, description: "寂灭罗睺达到10级，GPS +280%" },
    "yuyu7_50": { gpsMultiplier: 5.50, description: "寂灭罗睺达到50级，GPS +550%" },
    "yuyu7_100": { gpsMultiplier: 7.00, description: "寂灭罗睺达到100级，GPS +700%" },
    "yuyu8_10": { gpsMultiplier: 3.10, description: "永劫蚩尤达到10级，GPS +310%" },
    "yuyu8_50": { gpsMultiplier: 6.50, description: "永劫蚩尤达到50级，GPS +650%" },
    "yuyu8_100": { gpsMultiplier: 7.50, description: "永劫蚩尤达到100级，GPS +750%" },

    // 新增魂环成就
    "year1_10": { gpsMultiplier: 0.20, description: "一年魂环达到10级，GPS +20%" },
    "year10_10": { gpsMultiplier: 0.30, description: "十年魂环达到10级，GPS +30%" },
    "year100_10": { gpsMultiplier: 0.40, description: "百年魂环达到10级，GPS +40%" },
    "year1000_10": { gpsMultiplier: 0.50, description: "千年魂环达到10级，GPS +50%" },
    "year10000_10": { gpsMultiplier: 0.60, description: "万年魂环达到10级，GPS +60%" },
    "year100000_10": { gpsMultiplier: 0.70, description: "十万年魂环达到10级，GPS +70%" },
    "year1000000_10": { gpsMultiplier: 0.80, description: "百万年魂环达到10级，GPS +80%" },
    "year10000000_10": { gpsMultiplier: 0.90, description: "千万年魂环达到10级，GPS +90%" },
    "year100000000_10": { gpsMultiplier: 1.00, description: "亿年魂环达到10级，GPS +100%" },
    "year1_100": { gpsMultiplier: 0.50, description: "一年魂环达到100级，GPS +50%" },
    "year10_100": { gpsMultiplier: 0.60, description: "十年魂环达到100级，GPS +60%" },
    "year100_100": { gpsMultiplier: 0.70, description: "百年魂环达到100级，GPS +70%" },
    "year1000_100": { gpsMultiplier: 0.80, description: "千年魂环达到100级，GPS +80%" },
    "year10000_100": { gpsMultiplier: 0.90, description: "万年魂环达到100级，GPS +90%" },
    "year100000_100": { gpsMultiplier: 1.00, description: "十万年魂环达到100级，GPS +100%" },
    "year1000000_100": { gpsMultiplier: 1.10, description: "百万年魂环达到100级，GPS +110%" },
    "year10000000_100": { gpsMultiplier: 1.20, description: "千万年魂环达到100级，GPS +120%" },
    "year100000000_100": { gpsMultiplier: 1.30, description: "亿年魂环达到100级，GPS +130%" },
    "year1_1000": { gpsMultiplier: 1.00, description: "一年魂环达到1000级，GPS +100%" },
    "year10_1000": { gpsMultiplier: 1.10, description: "十年魂环达到1000级，GPS +110%" },
    "year100_1000": { gpsMultiplier: 1.20, description: "百年魂环达到1000级，GPS +120%" },
    "year1000_1000": { gpsMultiplier: 1.30, description: "千年魂环达到1000级，GPS +130%" },
    "year10000_1000": { gpsMultiplier: 1.40, description: "万年魂环达到1000级，GPS +140%" },
    "year100000_1000": { gpsMultiplier: 1.50, description: "十万年魂环达到1000级，GPS +150%" },
    "year1000000_1000": { gpsMultiplier: 1.60, description: "百万年魂环达到1000级，GPS +160%" },
    "year10000000_1000": { gpsMultiplier: 1.70, description: "千万年魂环达到1000级，GPS +170%" },
    "year100000000_1000": { gpsMultiplier: 1.80, description: "亿年魂环达到1000级，GPS +180%" },
    "year1_10000": { gpsMultiplier: 2.00, description: "一年魂环达到10000级，GPS +200%" },
    "year10_10000": { gpsMultiplier: 2.10, description: "十年魂环达到10000级，GPS +210%" },
    "year100_10000": { gpsMultiplier: 2.20, description: "百年魂环达到10000级，GPS +220%" },
    "year1000_10000": { gpsMultiplier: 2.30, description: "千年魂环达到10000级，GPS +230%" },
    "year10000_10000": { gpsMultiplier: 2.40, description: "万年魂环达到10000级，GPS +240%" },
    "year100000_10000": { gpsMultiplier: 2.50, description: "十万年魂环达到10000级，GPS +250%" },
    "year1000000_10000": { gpsMultiplier: 2.60, description: "百万年魂环达到10000级，GPS +260%" },
    "year10000000_10000": { gpsMultiplier: 2.70, description: "千万年魂环达到10000级，GPS +270%" },
    "year100000000_10000": { gpsMultiplier: 2.80, description: "亿年魂环达到10000级，GPS +280%" },
    "year2_10": { gpsMultiplier: 1.10, description: "太古·混沌亿年魂环达到10级，GPS +110%" },
    "year2_100": { gpsMultiplier: 1.40, description: "太古·混沌亿年魂环达到100级，GPS +140%" },
    "year2_1000": { gpsMultiplier: 1.90, description: "太古·混沌亿年魂环达到1000级，GPS +190%" },
    "year2_10000": { gpsMultiplier: 3.80, description: "太古·混沌亿年魂环达到10000级，GPS +380%" },
    "year3_10": { gpsMultiplier: 1.20, description: "鸿蒙·始源亿年魂环达到10级，GPS +120%" },
    "year3_100": { gpsMultiplier: 1.50, description: "鸿蒙·始源亿年魂环达到100级，GPS +150%" },
    "year3_1000": { gpsMultiplier: 2.00, description: "鸿蒙·始源亿年魂环达到1000级，GPS +200%" },
    "year3_10000": { gpsMultiplier: 3.90, description: "鸿蒙·始源亿年魂环达到10000级，GPS +390%" },
    "year4_10": { gpsMultiplier: 1.30, description: "亘古·时空亿年魂环达到10级，GPS +130%" },
    "year4_100": { gpsMultiplier: 1.60, description: "亘古·时空亿年魂环达到100级，GPS +160%" },
    "year4_1000": { gpsMultiplier: 2.10, description: "亘古·时空亿年魂环达到1000级，GPS +210%" },
    "year4_10000": { gpsMultiplier: 4.00, description: "亘古·时空亿年魂环达到10000级，GPS +400%" },
    "year5_10": { gpsMultiplier: 1.40, description: "九幽·冥渊亿年魂环达到10级，GPS +140%" },
    "year5_100": { gpsMultiplier: 1.70, description: "九幽·冥渊亿年魂环达到100级，GPS +170%" },
    "year5_1000": { gpsMultiplier: 2.20, description: "九幽·冥渊亿年魂环达到1000级，GPS +220%" },
    "year5_10000": { gpsMultiplier: 4.10, description: "九幽·冥渊亿年魂环达到10000级，GPS +410%" },
    "year6_10": { gpsMultiplier: 1.50, description: "皓宇·星辰亿年魂环达到10级，GPS +150%" },
    "year6_100": { gpsMultiplier: 1.80, description: "皓宇·星辰亿年魂环达到100级，GPS +180%" },
    "year6_1000": { gpsMultiplier: 2.30, description: "皓宇·星辰亿年魂环达到1000级，GPS +230%" },
    "year6_10000": { gpsMultiplier: 4.20, description: "皓宇·星辰亿年魂环达到10000级，GPS +420%" },
    "year7_10": { gpsMultiplier: 1.60, description: "炎狱·焚天亿年魂环达到10级，GPS +160%" },
    "year7_100": { gpsMultiplier: 1.90, description: "炎狱·焚天亿年魂环达到100级，GPS +190%" },
    "year7_1000": { gpsMultiplier: 2.40, description: "炎狱·焚天亿年魂环达到1000级，GPS +240%" },
    "year7_10000": { gpsMultiplier: 4.30, description: "炎狱·焚天亿年魂环达到10000级，GPS +430%" },
    "year8_10": { gpsMultiplier: 1.70, description: "霜烬·极寒亿年魂环达到10级，GPS +170%" },
    "year8_100": { gpsMultiplier: 2.00, description: "霜烬·极寒亿年魂环达到100级，GPS +200%" },
    "year8_1000": { gpsMultiplier: 2.50, description: "霜烬·极寒亿年魂环达到1000级，GPS +250%" },
    "year8_10000": { gpsMultiplier: 4.40, description: "霜烬·极寒亿年魂环达到10000级，GPS +440%" },
    "year9_10": { gpsMultiplier: 1.80, description: "灵幻·万象亿年魂环达到10级，GPS +180%" },
    "year9_100": { gpsMultiplier: 2.10, description: "灵幻·万象亿年魂环达到100级，GPS +210%" },
    "year9_1000": { gpsMultiplier: 2.60, description: "灵幻·万象亿年魂环达到1000级，GPS +260%" },
    "year9_10000": { gpsMultiplier: 4.50, description: "灵幻·万象亿年魂环达到10000级，GPS +450%" },
    "year11_10": { gpsMultiplier: 1.90, description: "炽阳·耀世亿年魂环达到10级，GPS +190%" },
    "year11_100": { gpsMultiplier: 2.20, description: "炽阳·耀世亿年魂环达到100级，GPS +220%" },
    "year11_1000": { gpsMultiplier: 2.70, description: "炽阳·耀世亿年魂环达到1000级，GPS +270%" },
    "year11_10000": { gpsMultiplier: 4.60, description: "炽阳·耀世亿年魂环达到10000级，GPS +460%" },
    "year12_10": { gpsMultiplier: 2.00, description: "暗蚀·灭世亿年魂环达到10级，GPS +200%" },
    "year12_100": { gpsMultiplier: 2.30, description: "暗蚀·灭世亿年魂环达到100级，GPS +230%" },
    "year12_1000": { gpsMultiplier: 2.80, description: "暗蚀·灭世亿年魂环达到1000级，GPS +280%" },
    "year12_10000": { gpsMultiplier: 4.70, description: "暗蚀·灭世亿年魂环达到10000级，GPS +470%" },
    "year13_10": { gpsMultiplier: 2.10, description: "圣辉·救赎亿年魂环达到10级，GPS +210%" },
    "year13_100": { gpsMultiplier: 2.40, description: "圣辉·救赎亿年魂环达到100级，GPS +240%" },
    "year13_1000": { gpsMultiplier: 2.90, description: "圣辉·救赎亿年魂环达到1000级，GPS +290%" },
    "year13_10000": { gpsMultiplier: 4.80, description: "圣辉·救赎亿年魂环达到10000级，GPS +480%" },
    "year14_10": { gpsMultiplier: 2.30, description: "紫霄·雷罚亿年魂环达到10级，GPS +220%" },
    "year14_100": { gpsMultiplier: 2.50, description: "紫霄·雷罚亿年魂环达到100级，GPS +250%" },
    "year14_1000": { gpsMultiplier: 3.00, description: "紫霄·雷罚亿年魂环达到1000级，GPS +300%" },
    "year14_10000": { gpsMultiplier: 4.90, description: "紫霄·雷罚亿年魂环达到10000级，GPS +490%" },
    "year15_10": { gpsMultiplier: 2.30, description: "青木·生机亿年魂环达到10级，GPS +230%" },
    "year15_100": { gpsMultiplier: 2.60, description: "青木·生机亿年魂环达到100级，GPS +260%" },
    "year15_1000": { gpsMultiplier: 3.00, description: "青木·生机亿年魂环达到1000级，GPS +300%" },
    "year15_10000": { gpsMultiplier: 5.00, description: "青木·生机亿年魂环达到10000级，GPS +500%" },
    "year16_10": { gpsMultiplier: 2.40, description: "星澜·幻梦亿年魂环达到10级，GPS +240%" },
    "year16_100": { gpsMultiplier: 2.70, description: "星澜·幻梦亿年魂环达到100级，GPS +270%" },
    "year16_1000": { gpsMultiplier: 3.10, description: "星澜·幻梦亿年魂环达到1000级，GPS +310%" },
    "year16_10000": { gpsMultiplier: 5.10, description: "星澜·幻梦亿年魂环达到10000级，GPS +510%" },
    "year17_10": { gpsMultiplier: 2.50, description: "渊海·无尽亿年魂环达到10级，GPS +250%" },
    "year17_100": { gpsMultiplier: 2.80, description: "渊海·无尽亿年魂环达到100级，GPS +280%" },
    "year17_1000": { gpsMultiplier: 3.20, description: "渊海·无尽亿年魂环达到1000级，GPS +320%" },
    "year17_10000": { gpsMultiplier: 5.20, description: "渊海·无尽亿年魂环达到10000级，GPS +520%" },
    "year18_10": { gpsMultiplier: 2.60, description: "荒古·遗世亿年魂环达到10级，GPS +260%" },
    "year18_100": { gpsMultiplier: 2.90, description: "荒古·遗世亿年魂环达到100级，GPS +290%" },
    "year18_1000": { gpsMultiplier: 3.30, description: "荒古·遗世亿年魂环达到1000级，GPS +330%" },
    "year18_10000": { gpsMultiplier: 5.30, description: "荒古·遗世亿年魂环达到10000级，GPS +530%" },
    "year19_10": { gpsMultiplier: 2.70, description: "净世·光明亿年魂环达到10级，GPS +270%" },
    "year19_100": { gpsMultiplier: 3.00, description: "净世·光明亿年魂环达到100级，GPS +300%" },
    "year19_1000": { gpsMultiplier: 3.40, description: "净世·光明亿年魂环达到1000级，GPS +340%" },
    "year19_10000": { gpsMultiplier: 5.40, description: "净世·光明亿年魂环达到10000级，GPS +540%" },
    "year20_10": { gpsMultiplier: 2.80, description: "蚀灵·诅咒亿年魂环达到10级，GPS +280%" },
    "year20_100": { gpsMultiplier: 3.10, description: "蚀灵·诅咒亿年魂环达到100级，GPS +310%" },
    "year20_1000": { gpsMultiplier: 3.50, description: "蚀灵·诅咒亿年魂环达到1000级，GPS +350%" },
    "year20_10000": { gpsMultiplier: 5.50, description: "蚀灵·诅咒亿年魂环达到10000级，GPS +550%" },
    "year21_10": { gpsMultiplier: 2.90, description: "逆乱·时空亿年魂环达到10级，GPS +290%" },
    "year21_100": { gpsMultiplier: 3.20, description: "逆乱·时空亿年魂环达到100级，GPS +320%" },
    "year21_1000": { gpsMultiplier: 3.60, description: "逆乱·时空亿年魂环达到1000级，GPS +360%" },
    "year21_10000": { gpsMultiplier: 5.60, description: "逆乱·时空亿年魂环达到10000级，GPS +560%" },
    "year22_10": { gpsMultiplier: 3.00, description: "龙渊·霸者亿年魂环达到10级，GPS +300%" },
    "year22_100": { gpsMultiplier: 3.30, description: "龙渊·霸者亿年魂环达到100级，GPS +330%" },
    "year22_1000": { gpsMultiplier: 3.70, description: "龙渊·霸者亿年魂环达到1000级，GPS +370%" },
    "year22_10000": { gpsMultiplier: 5.70, description: "龙渊·霸者亿年魂环达到10000级，GPS +570%" },
    "year23_10": { gpsMultiplier: 3.10, description: "凤羽·炎舞亿年魂环达到10级，GPS +310%" },
    "year23_100": { gpsMultiplier: 3.40, description: "凤羽·炎舞亿年魂环达到100级，GPS +340%" },
    "year23_1000": { gpsMultiplier: 3.80, description: "凤羽·炎舞亿年魂环达到1000级，GPS +380%" },
    "year23_10000": { gpsMultiplier: 5.80, description: "凤羽·炎舞亿年魂环达到10000级，GPS +580%" },
    "year24_10": { gpsMultiplier: 3.20, description: "星辰·命数亿年魂环达到10级，GPS +320%" },
    "year24_100": { gpsMultiplier: 3.50, description: "星辰·命数亿年魂环达到100级，GPS +350%" },
    "year24_1000": { gpsMultiplier: 3.90, description: "星辰·命数亿年魂环达到1000级，GPS +390%" },
    "year24_10000": { gpsMultiplier: 5.90, description: "星辰·命数亿年魂环达到10000级，GPS +590%" },
    "year25_10": { gpsMultiplier: 3.30, description: "荒炎·破灭亿年魂环达到10级，GPS +330%" },
    "year25_100": { gpsMultiplier: 3.60, description: "荒炎·破灭亿年魂环达到100级，GPS +360%" },
    "year25_1000": { gpsMultiplier: 4.00, description: "荒炎·破灭亿年魂环达到1000级，GPS +400%" },
    "year25_10000": { gpsMultiplier: 6.00, description: "荒炎·破灭亿年魂环达到10000级，GPS +600%" },
    "year26_10": { gpsMultiplier: 3.40, description: "玄冰·永冻亿年魂环达到10级，GPS +340%" },
    "year26_100": { gpsMultiplier: 3.70, description: "玄冰·永冻亿年魂环达到100级，GPS +370%" },
    "year26_1000": { gpsMultiplier: 4.10, description: "玄冰·永冻亿年魂环达到1000级，GPS +410%" },
    "year26_10000": { gpsMultiplier: 6.10, description: "玄冰·永冻亿年魂环达到10000级，GPS +610%" },
    "year27_10": { gpsMultiplier: 3.50, description: "灵犀·心眼亿年魂环达到10级，GPS +350%" },
    "year27_100": { gpsMultiplier: 3.80, description: "灵犀·心眼亿年魂环达到100级，GPS +380%" },
    "year27_1000": { gpsMultiplier: 4.20, description: "灵犀·心眼亿年魂环达到1000级，GPS +420%" },
    "year27_10000": { gpsMultiplier: 6.20, description: "灵犀·心眼亿年魂环达到10000级，GPS +620%" },
    "year28_10": { gpsMultiplier: 3.60, description: "圣谕·裁决亿年魂环达到10级，GPS +360%" },
    "year28_100": { gpsMultiplier: 3.90, description: "圣谕·裁决亿年魂环达到100级，GPS +390%" },
    "year28_1000": { gpsMultiplier: 4.30, description: "圣谕·裁决亿年魂环达到1000级，GPS +430%" },
    "year28_10000": { gpsMultiplier: 6.30, description: "圣谕·裁决亿年魂环达到10000级，GPS +630%" },
    "year29_10": { gpsMultiplier: 3.70, description: "九幽·黄泉亿年魂环达到10级，GPS +370%" },
    "year29_100": { gpsMultiplier: 4.00, description: "九幽·黄泉亿年魂环达到100级，GPS +400%" },
    "year29_1000": { gpsMultiplier: 4.40, description: "九幽·黄泉亿年魂环达到1000级，GPS +440%" },
    "year29_10000": { gpsMultiplier: 6.40, description: "九幽·黄泉亿年魂环达到10000级，GPS +640%" },
    "year30_10": { gpsMultiplier: 3.80, description: "灵蕴·造化亿年魂环达到10级，GPS +380%" },
    "year30_100": { gpsMultiplier: 4.10, description: "灵蕴·造化亿年魂环达到100级，GPS +410%" },
    "year30_1000": { gpsMultiplier: 4.50, description: "灵蕴·造化亿年魂环达到1000级，GPS +450%" },
    "year30_10000": { gpsMultiplier: 6.50, description: "灵蕴·造化亿年魂环达到10000级，GPS +650%" },
    "year31_10": { gpsMultiplier: 3.90, description: "混沌·元始亿年魂环达到10级，GPS +390%" },
    "year31_100": { gpsMultiplier: 4.20, description: "混沌·元始亿年魂环达到100级，GPS +420%" },
    "year31_1000": { gpsMultiplier: 4.60, description: "混沌·元始亿年魂环达到1000级，GPS +460%" },
    "year31_10000": { gpsMultiplier: 6.60, description: "混沌·元始亿年魂环达到10000级，GPS +660%" },
    "year32_10": { gpsMultiplier: 4.00, description: "苍穹·御天亿年魂环达到10级，GPS +400%" },
    "year32_100": { gpsMultiplier: 4.30, description: "苍穹·御天亿年魂环达到100级，GPS +430%" },
    "year32_1000": { gpsMultiplier: 4.70, description: "苍穹·御天亿年魂环达到1000级，GPS +470%" },
    "year32_10000": { gpsMultiplier: 6.70, description: "苍穹·御天亿年魂环达到10000级，GPS +670%" },
    "year33_10": { gpsMultiplier: 4.10, description: "龙炎·焚天亿年魂环达到10级，GPS +410%" },
    "year33_100": { gpsMultiplier: 4.40, description: "龙炎·焚天亿年魂环达到100级，GPS +440%" },
    "year33_1000": { gpsMultiplier: 4.80, description: "龙炎·焚天亿年魂环达到1000级，GPS +480%" },
    "year33_10000": { gpsMultiplier: 6.80, description: "龙炎·焚天亿年魂环达到10000级，GPS +680%" },
    "year34_10": { gpsMultiplier: 4.20, description: "血狱·魔神亿年魂环达到10级，GPS +420%" },
    "year34_100": { gpsMultiplier: 4.50, description: "血狱·魔神亿年魂环达到100级，GPS +450%" },
    "year34_1000": { gpsMultiplier: 4.90, description: "血狱·魔神亿年魂环达到1000级，GPS +490%" },
    "year34_10000": { gpsMultiplier: 6.90, description: "血狱·魔神亿年魂环达到10000级，GPS +690%" },
    "year35_10": { gpsMultiplier: 4.30, description: "赤霄·苍穹亿年魂环达到10级，GPS +430%" },
    "year35_100": { gpsMultiplier: 4.60, description: "赤霄·苍穹亿年魂环达到100级，GPS +460%" },
    "year35_1000": { gpsMultiplier: 5.00, description: "赤霄·苍穹亿年魂环达到1000级，GPS +500%" },
    "year35_10000": { gpsMultiplier: 7.00, description: "赤霄·苍穹亿年魂环达到10000级，GPS +700%" },
    "year36_10": { gpsMultiplier: 4.40, description: "炎凤·涅槃亿年魂环达到10级，GPS +440%" },
    "year36_100": { gpsMultiplier: 4.70, description: "炎凤·涅槃亿年魂环达到100级，GPS +470%" },
    "year36_1000": { gpsMultiplier: 5.10, description: "炎凤·涅槃亿年魂环达到1000级，GPS +510%" },
    "year36_10000": { gpsMultiplier: 7.10, description: "炎凤·涅槃亿年魂环达到10000级，GPS +710%" },
    "year37_10": { gpsMultiplier: 4.50, description: "闫闫·黑丝亿年魂环达到10级，GPS +450%" },
    "year37_100": { gpsMultiplier: 4.80, description: "闫闫·黑丝亿年魂环达到100级，GPS +480%" },
    "year37_1000": { gpsMultiplier: 5.20, description: "闫闫·黑丝亿年魂环达到1000级，GPS +520%" },
    "year37_10000": { gpsMultiplier: 7.20, description: "闫闫·黑丝亿年魂环达到10000级，GPS +720%" },
    "world_boss_1st": { gpsMultiplier: 10.0, description: "在世界BOSS中获得第1名，GPS +1000%"  },
    "world_boss_top5": { gpsMultiplier: 5.0, description: "在世界BOSS中获得第2-10名，GPS +500%"  },
    "world_boss_top10": { gpsMultiplier: 3.0, description: "在世界BOSS中获得第11-30名，GPS +300%"  },
    "world_boss_participant": { gpsMultiplier: 1.00, description: "参与世界BOSS战斗，GPS +100%"  },
    // 新增转生成就奖励
    "reincarnation_10": { gpsMultiplier: 0.50, description: "转生10次，GPS +50%" },
    "reincarnation_100": { gpsMultiplier: 1.00, description: "转生100次，GPS +100%" },
    "reincarnation_1000": { gpsMultiplier: 5.00, description: "转生1000次，GPS +500%" },
    "reincarnation_10000": { gpsMultiplier: 10.00, description: "转生10000次，GPS +1000%" }
};
 
// 功法秘笈配置
const techniqueConfig = {
    "immortalAsuraBody": { name: "不灭修罗体", type: "health", effect: 0.0001, description: "每一级增加0.01%生命永久属性" },
    "eightDesolationsWarDemonBody": { name: "八荒战魔躯", type: "health", effect: 0.001, description: "每一级增加0.1%生命永久属性" },
    "nineRevolutionsProfoundBody": { name: "九转玄黄身", type: "health", effect: 0.005, description: "每一级增加0.5%生命永久属性" },
    "loneDestinyBone": { name: "天煞孤星骨", type: "health", effect: 0.01, description: "每一级增加1%生命永久属性" },
    "bloodPrisonMadGodArmor": { name: "血狱狂神铠", type: "health", effect: 0.10, description: "每一级增加10%生命永久属性" },
    "godSlayingBurningHeavenArt": { name: "弑神焚天诀", type: "attack", effect: 0.0001, description: "每一级增加0.01%攻击永久属性" },
    "burialHeavenBladePrisonManual": { name: "葬天刀狱谱", type: "attack", effect: 0.001, description: "每一级增加0.1%攻击永久属性" },
    "tenDirectionsAnnihilationSpearCodex": { name: "十方俱灭枪典", type: "attack", effect: 0.005, description: "每一级增加0.5%攻击永久属" },
    "thousandCalamitiesVoidArrowArt": { name: "千劫裂空箭术", type: "attack", effect: 0.05, description: "每一级增加5%攻击永久属性" },
    "ancientAnnihilationHalberdArt": { name: "万古寂灭戟法", type: "attack", effect: 0.10, description: "每一级增加10%攻击永久属性" },
    "nineCalamitiesWorldDestroyingPalm": { name: "九劫灭世掌", type: "critDamage", effect: 0.001, description: "每一级增加0.1%爆伤永久属性" },
    "chaosCreationForce": { name: "混沌开天劲", type: "critDamage", effect: 0.005, description: "每一级增加0.5%爆伤永久属性" },
    "dragonElephantShatteringVoidArt": { name: "龙象碎穹功", type: "critDamage", effect: 0.01, description: "每一级增加1%爆伤永久属性" },
    "greatSunFallingStarFist": { name: "大日陨星拳", type: "critDamage", effect: 0.10, description: "每一级增加10%爆伤永久属性" },
    "nineHeavensThunderboltTruth": { name: "九霄雷殛真解", type: "critRate", effect: 0.00001, description: "每一级增加0.001%暴击率永久属性" },
    "netherBloodSeaDiagram": { name: "幽冥血海图录", type: "critRate", effect: 0.0005, description: "每一级增加0.05%暴击率永久属性" },
    "riverStarsHangingSecretScroll": { name: "星河倒悬秘卷", type: "critRate", effect: 0.0001, description: "每一级增加0.01%暴击率永久属性" },
    "eightDesolationsFireDragonRecord": { name: "八荒火龙焚世录", type: "critRate", effect: 0.001, description: "每一级增加0.1%暴击率永久属性" },
    "iceSealThreeThousandRealmArt": { name: "冰封三千界心法", type: "critRate", effect: 0.01, description: "每一级增加1%暴击率永久属性" },
    "greatVoidReturnToVoidCodex": { name: "太虚归墟典", type: "multiAttack", effect: 2, description: "每一级攻击次数+2永久属性" },
    "samsaraCalamityAnnihilationSutra": { name: "轮回劫灭经", type: "multiAttack", effect: 3, description: "每一级攻击次数+3永久属性" },
    "yinYangReversalArt": { name: "阴阳逆命术", type: "multiAttack", effect: 5, description: "每一级攻击次数+5永久属性" },
    "zhouHeavenStarsFallingWay": { name: "周天星陨道", type: "multiAttack", effect: 10, description: "每一级攻击次数+10永久属性" },
    "ancientVoidRecord": { name: "万古空冥录", type: "multiAttack", effect: 50, description: "每一级攻击次数+50永久属性" }
};
const vipConfig = [
    { level: 1, requiredPower: 0, bonus: 1 }, 
    { level: 2, requiredPower: 5, bonus: 2 }, 
    { level: 3, requiredPower: 15, bonus: 4 }, 
    { level: 4, requiredPower: 32, bonus: 6 }, 
    { level: 5, requiredPower: 64, bonus: 8 },
    { level: 6, requiredPower: 128, bonus: 10 },
    { level: 7, requiredPower: 648, bonus: 20 }, 
    { level: 8, requiredPower: 1280, bonus: 40 }, 
    { level: 9, requiredPower: 3280, bonus: 60 }, 
    { level: 10, requiredPower: 6480, bonus: 80 }, 
    { level: 11, requiredPower: 10000, bonus: 100 },
    { level: 12, requiredPower: 20000, bonus: 200 },
    { level: 13, requiredPower: 30000, bonus: 400 },
    { level: 14, requiredPower: 40000, bonus: 600 },
    { level: 15, requiredPower: 50000, bonus: 800 },
    { level: 16, requiredPower: 60000, bonus: 1000 },
    { level: 17, requiredPower: 70000, bonus: 2000 },
    { level: 18, requiredPower: 80000, bonus: 4000 },
    { level: 19, requiredPower: 90000, bonus: 6000 },
    { level: 20, requiredPower: 100000, bonus: 8000 },
    { level: 21, requiredPower: 125000, bonus: 10000 },
    { level: 22, requiredPower: 150000, bonus: 20000 },
    { level: 23, requiredPower: 200000, bonus: 40000 },
    { level: 24, requiredPower: 250000, bonus: 60000 },
    { level: 25, requiredPower: 300000, bonus: 80000 },
    { level: 26, requiredPower: 400000, bonus: 100000 },
    { level: 27, requiredPower: 500000, bonus: 200000 },
    { level: 28, requiredPower: 600000, bonus: 400000 },
    { level: 29, requiredPower: 750000, bonus: 600000 },
    { level: 30, requiredPower: 1000000, bonus: 800000 },
    { level: 31, requiredPower: 2000000, bonus: 1000000 },
    { level: 32, requiredPower: 4000000, bonus: 2000000 },
    { level: 33, requiredPower: 6000000, bonus: 4000000 },
    { level: 34, requiredPower: 8000000, bonus: 6000000 },
    { level: 35, requiredPower: 10000000, bonus: 8000000 },
    { level: 36, requiredPower: 20000000, bonus: 10000000 },
    { level: 37, requiredPower: 40000000, bonus: 20000000 },
    { level: 38, requiredPower: 60000000, bonus: 40000000 },
    { level: 39, requiredPower: 80000000, bonus: 60000000 },
    { level: 40, requiredPower: 100000000, bonus: 80000000 }
];
        // 道具配置
        const itemEffects = {
    primaryGem: { name: '初级宝石', effect: 10.00, description: '增加装备属性+1000%' },
    advancedGem: { name: '高级宝石', effect: 50.00, description: '增加装备属性+5000%' },
    superiorGem: { name: '极品宝石', effect: 500.00, description: '增加装备属性+50000%' },
    divineGem: { name: '神级宝石', effect: 5000.00, description: '增加装备属性+500000%' },
    vipPower: { name: 'VIP能力值', effect: 1, description: '提升VIP等级的特殊道具' },
    refineStone: { name: '洗炼石', effect: 0, description: '用于重铸副本装备的成长属性' }, // 新增洗炼石
    rose: { name: '玫瑰花', effect: 1, description: '用于升级伴侣等级' },
    companionKey: { name: '伴侣钥匙', effect: 0, description: '用于开启伴侣宝箱' }, 
    rebornDan: { name: '洗髓丹', effect: 0, description: '用于洗练伴侣天赋' },
    baitCount: { name: '鱼饵', effect: 0, description: '用于钓鱼消耗品' },
    rootDetector: { name: '灵根检测器', effect: 0, description: '用于开启灵根宝箱' },
    bloodlineDetector: { name: '血脉检测剂', effect: 0, description: '用于开启血脉宝箱' },
    advanceStone: { name: '进阶神石', effect: 0, description: '用于进阶神器' },  
   primaryGemq: { name: '宝藏金币', effect: 0, description: '用于兑换藏宝图商店物品' },
   zongmen: { name: '宗门令牌', effect: 0, description: '创建宗门消耗的必须品' },  
   roseq: { name: '香囊', effect: 0, description: '赠送宗门成员增加忠诚度' }, 
  yuzhou1: { name: '星尘发票', effect: 0, description: '兑换星尘专用' }, 
   yuzhou2: { name: '暗物质发票', effect: 0, description: '兑换暗物质专用' }, 
   yuzhou3: { name: '宇宙晶体发票', effect: 0, description: '兑换宇宙晶体专用' }, 
   yuzhou4: { name: '神器碎片发票', effect: 0, description: '兑换神器碎片专用' },
  banlv1: { name: '普通伴侣灵魂', effect: 0, description: '普通伴侣进阶必需品' },
 banlv2: { name: '稀有伴侣灵魂', effect: 0, description: '稀有伴侣进阶必需品' },
 banlv3: { name: '史诗伴侣灵魂', effect: 0, description: '史诗伴侣进阶必需品' },
 banlv4: { name: '卓越伴侣灵魂', effect: 0, description: '卓越伴侣进阶必需品' },
banlv5: { name: '完美伴侣灵魂', effect: 0, description: '完美伴侣进阶必需品' },
banlv6: { name: '神赐伴侣灵魂', effect: 0, description: '神赐伴侣进阶必需品' },
banlv7: { name: '天使伴侣灵魂', effect: 0, description: '天使伴侣进阶必需品' },
banlv8: { name: '恶魔伴侣灵魂', effect: 0, description: '恶魔伴侣进阶必需品' },
banlv9: { name: '精灵伴侣灵魂', effect: 0, description: '精灵伴侣进阶必需品' },
zhiye1: { name: '职业转换书', effect: 0, description: '用于更换职业' },
chiban1: { name: '黑龙王翅膀', effect: 0, description: '用于强化翅膀' },
zuoqi1: { name: '远古圣兽精魄', effect: 0, description: '用于强化坐骑' },
fuben1: { name: '副本令牌', effect: 0, description: '用于挑战副本' },
shenshou1: { name: '神兽蛋', effect: 0, description: '用于召唤神兽' },
fuwen1: { name: '秘法符文', effect: 0, description: '用于强化符文' },
fuben2: { name: '秘境钥匙', effect: 0, description: '用于开启秘境' }
};

        // 收藏物配置
        const collectionEffects = {
             lightSpeedHand: { name: '光速幻影手', effect: 0.01, description: '增加全部装备属性 +1%' },
    empHand: { name: '电磁脉冲快手', effect: 0.05, description: '增加全部装备属性 +5%' },
    godlyHand: { name: '神级手速怪', effect: 0.30, description: '增加全部装备属性 +30%' },
    quickHand: { name: '秒点快手侠', effect: 2.00, description: '增加全部装备属性 +200%' },
    shadowHand: { name: '无影闪击手', effect: 5.00, description: '增加全部装备属性 +500%' },
    quantumHand: { name: '量子跃迁快手', effect: 10.00, description: '增加全部装备属性 +1000%' },
    lightningHand: { name: '闪电连点器之手', effect: 100.00, description: '增加全部装备属性 +10000%' },
    divineHand: { name: '天神之手', effect: 5000.00, description: '增加全部装备属性 +500000%' }
};

        // 材料宝箱掉落概率配置
        const materialChestProbabilities = [
     { type: 'lightSpeedHand', prob: 0.71188 },
    { type: 'empHand', prob: 0.2305 },
    { type: 'godlyHand', prob: 0.0324 },
    { type: 'quickHand', prob: 0.01 },
    { type: 'shadowHand', prob: 0.005 },
    { type: 'quantumHand', prob: 0.0005 },
    { type: 'lightningHand', prob: 0.00005 },
    { type: 'divineHand', prob: 0.00001 },
    { type: 'primaryGem', prob: 0.005 },
    { type: 'advancedGem', prob: 0.0005 },
    { type: 'superiorGem', prob: 0.00005 },
    { type: 'divineGem', prob: 0.00001 },
    { type: 'vipPower', prob: 0.001 },
    { type: 'refineStone', prob: 0.001 }, 
    { type: 'companionKey', prob: 0.001 }, 
     { type: 'rebornDan', prob: 0.001 }, 
    
];
    const techniqueChestDrops = [
    // 第一档 22%~21.8%
    { id: "immortalAsuraBody", prob: 0.21 },          // 不灭修罗体 21%
    { id: "godSlayingBurningHeavenArt", prob: 0.21 }, // 弑神焚天诀 21%
    { id: "nineHeavensThunderboltTruth", prob: 0.23299 }, // 九霄雷殛真解 20.65%
    
    // 第二档 5%
    { id: "eightDesolationsWarDemonBody", prob: 0.05 },  // 八荒战魔躯 5%
    { id: "burialHeavenBladePrisonManual", prob: 0.05 }, // 葬天刀狱谱 5%
    { id: "nineCalamitiesWorldDestroyingPalm", prob: 0.05 }, // 九劫灭世掌 5%
    { id: "netherBloodSeaDiagram", prob: 0.05 },        // 幽冥血海图录 5%
    
    // 第三档 2%
    { id: "nineRevolutionsProfoundBody", prob: 0.02 },  // 九转玄黄身 2%
    { id: "tenDirectionsAnnihilationSpearCodex", prob: 0.02 }, // 十方俱灭枪典 2%
    { id: "chaosCreationForce", prob: 0.02 },           // 混沌开天劲 2%
    { id: "riverStarsHangingSecretScroll", prob: 0.02 }, // 星河倒悬秘卷 2%
    
    // 第四档 1%
    { id: "loneDestinyBone", prob: 0.01 },              // 天煞孤星骨 1%
    { id: "thousandCalamitiesVoidArrowArt", prob: 0.01 }, // 千劫裂空箭术 1%
    { id: "dragonElephantShatteringVoidArt", prob: 0.01 }, // 龙象碎穹功 1%
    { id: "eightDesolationsFireDragonRecord", prob: 0.01 }, // 八荒火龙焚世录 1%
    
    // 第五档 0.5%
    { id: "bloodPrisonMadGodArmor", prob: 0.0051 },      // 血狱狂神铠 0.5%
    { id: "ancientAnnihilationHalberdArt", prob: 0.0051 }, // 万古寂灭戟法 0.5%
    { id: "greatSunFallingStarFist", prob: 0.0051 },     // 大日陨星拳 0.5%
    { id: "iceSealThreeThousandRealmArt", prob: 0.0051 }, // 冰封三千界心法 0.5%
    
    // 第六档 0.5%~0.001%
    { id: "greatVoidReturnToVoidCodex", prob: 0.005 },  // 太虚归墟典 0.5%
    { id: "samsaraCalamityAnnihilationSutra", prob: 0.001 }, // 轮回劫灭经 0.1%
    { id: "yinYangReversalArt", prob: 0.0005 },         // 阴阳逆命术 0.05%
    { id: "zhouHeavenStarsFallingWay", prob: 0.0001 },  // 周天星陨道 0.01%
    { id: "ancientVoidRecord", prob: 0.00001 }          // 万古空冥录 0.001%
];
 // 奥秘系统配置
const mysteryConfig = [
    { stage: 1, name: "初级秘法师", levelCost: 100, totalBonus: 1 },
    { stage: 2, name: "奥法转运者", levelCost: 10000, totalBonus: 2 },
    { stage: 3, name: "奥术掌握者", levelCost: 100000, totalBonus: 4 },
    { stage: 4, name: "秘能大师", levelCost: 500000, totalBonus: 6 },
    { stage: 5, name: "奥术之灵", levelCost: 1000000, totalBonus: 8 },
    { stage: 6, name: "神圣秘灵师", levelCost: 5000000, totalBonus: 10 },
    { stage: 7, name: "神之奥术掌握者", levelCost: 10000000, totalBonus: 20 },
    { stage: 8, name: "先知大师", levelCost: 50000000, totalBonus: 40 },
    { stage: 9, name: "恒星秘法师", levelCost: 100000000, totalBonus: 60 },
    { stage: 10, name: "暗能量宗师", levelCost: 200000000, totalBonus: 80 },
    { stage: 11, name: "星光秘耀使者", levelCost: 300000000, totalBonus: 100 },
    { stage: 12, name: "混沌秘能主宰", levelCost: 400000000, totalBonus: 200 },
    { stage: 13, name: "维度漫游大师", levelCost: 500000000, totalBonus: 400 },
    { stage: 14, name: "终焉秘法先知", levelCost: 600000000, totalBonus: 600 },
    { stage: 15, name: "时律操纵者", levelCost: 800000000, totalBonus: 800 },
    { stage: 16, name: "创世星芒导师", levelCost: 1000000000, totalBonus: 1000 },
    { stage: 17, name: "虚无之光缔造者", levelCost: 2000000000, totalBonus: 2000 },
    { stage: 18, name: "神谕秘能神", levelCost: 4000000000, totalBonus: 4000 },
    { stage: 19, name: "永恒奥术神", levelCost: 6000000000, totalBonus: 6000 },
    { stage: 20, name: "超维秘耀神", levelCost: 8000000000, totalBonus: 8000 },
    { stage: 21, name: "奥秘本身", levelCost: 10000000000, totalBonus: 10000 },
    { stage: 22, name: "万物创造者", levelCost: 25000000000, totalBonus: 20000 },
    { stage: 23, name: "奥秘创造者", levelCost: 50000000000, totalBonus: 60000 },
    { stage: 24, name: "创世神", levelCost: 75000000000, totalBonus: 80000 },
    { stage: 25, name: "位面之子", levelCost: 100000000000, totalBonus: 100000 },
   { stage: 26, name: "版本之子", levelCost: 1000000000000, totalBonus: 1000000 }
];
        // 装备配置
      const equipmentTypes = {
            common: { name: '普通', gps: 1, click: 0, prob: 0.6, growthRate: 0.025 },
            rare: { name: '稀有', gps: 3, click: 3, prob: 0.15, growthRate: 0.05 },
            epic: { name: '史诗', gps: 15, click: 15, prob: 0.1, growthRate: 0.10 },
            legendary: { name: '传说', gps: 20, click: 20, prob: 0.05, growthRate: 0.15 },
            ancient: { name: '远古', gps: 50, click: 50, prob: 0.03, growthRate: 0.20 },
            divine: { name: '神圣', gps: 100, click: 100, prob: 0.02, growthRate: 0.30 },
            arcane: { name: '奥术', gps: 300, click: 300, prob: 0.015, growthRate: 0.35 },
            celestial: { name: '天空', gps: 1000, click: 1000, prob: 0.01, growthRate: 0.40 },
            infernal: { name: '地狱', gps: 5000, click: 5000, prob: 0.005, growthRate: 0.50 },
            astral: { name: '星界', gps: 10000, click: 10000, prob: 0.003, growthRate: 0.60 },
            primeval: { name: '原初', gps: 50000, click: 50000, prob: 0.002, growthRate: 0.70 },
            transcendental: { name: '超凡', gps: 100000, click: 100000, prob: 0.001, growthRate: 0.80 },
            quantum: { name: '量子', gps: 500000, click: 500000, prob: 0.0005, growthRate: 0.90 },
            ultimate: { name: '究极', gps: 1000000, click: 1000000, prob: 0.0134, growthRate: 1.00 },
            chaos: { name: '混沌', gps: 10000000, click: 10000000, prob: 0.01, growthRate: 1.20 },
            eternal: { name: '永恒', gps: 20000000, click: 20000000, prob: 0.01, growthRate: 1.50 },
           void: { name: '虚无', gps: 50000000, click: 50000000, prob: 0.001, growthRate: 2.00 },
          genesis: { name: '创世', gps: 1e9, click: 1e9, prob: 0.01, growthRate: 2.50 },
          divineRealm: { name: '神域', gps: 2e9, click: 2e9, prob: 0.01, growthRate: 2.70 },
          apocalypse: { name: '终焉', gps: 5e9, click: 5e9, prob: 0.01, growthRate: 3.00 },
         yeyu1: { name: '星辰', gps: 1e11, click: 1e11, prob: 0.0001, growthRate: 3.20 },
         yeyu2: { name: '起源', gps: 2e11, click: 2e11, prob: 0.00005, growthRate: 3.50 },
         yeyu3: { name: '时光', gps: 5e11, click: 5e11, prob: 0.00001, growthRate: 4.00 },
         yeyu4: { name: '造物', gps: 1e13, click: 1e13, prob: 0.000005, growthRate: 4.20 },
         yeyu5: { name: '银河', gps: 2e13, click: 2e13, prob: 0.000001, growthRate: 4.50 },
         yeyu6: { name: '天界', gps: 5e13, click: 5e13, prob: 0.0000001, growthRate: 5.00 },
         yeyu7: { name: '星云', gps: 1e15, click: 1e15, prob: 0.0000001, growthRate: 5.50 },
         yeyu8: { name: '星河', gps: 2e15, click: 2e15, prob: 0.0000001, growthRate: 6.00 },
         yeyu9: { name: '纪元', gps: 5e15, click: 5e15, prob: 0.0000001, growthRate: 6.50 }, 
         yeyu10: { name: '鸿蒙', gps: 1e17, click: 1e17, prob: 0.0000001, growthRate: 7.00 },
         yeyu11: { name: '星穹', gps: 2e17, click: 2e17, prob: 0.0000001, growthRate: 7.50 },
         yeyu12: { name: '亘古', gps: 5e17, click: 5e17, prob: 0.0000001, growthRate: 8.00 },
         yeyu13: { name: '万象', gps: 1e19, click: 1e19, prob: 0.0000001, growthRate: 8.50 },
         yeyu14: { name: '太虚', gps: 2e19, click: 2e19, prob: 0.0000001, growthRate: 9.00 },
         yeyu15: { name: '九垓', gps: 5e19, click: 5e19, prob: 0.0000001, growthRate: 9.50 },
         yeyu16: { name: '穿梭', gps: 1e21, click: 1e21, prob: 0.0000001, growthRate: 10.00 },
         yeyu17: { name: '恒古', gps: 2e21, click: 2e21, prob: 0.0000001, growthRate: 10.50 },
         yeyu18: { name: '虚空', gps: 5e21, click: 5e21, prob: 0.0000001, growthRate: 11.00 },
         yeyu19: { name: '蔚来', gps: 1e23, click: 1e23, prob: 0.0000001, growthRate: 11.50 },
         yeyu20: { name: '神罚', gps: 2e23, click: 2e23, prob: 0.0000001, growthRate: 12.00 },
         yeyu21: { name: '时空', gps: 5e23, click: 5e23, prob: 0.0000001, growthRate: 12.50 },
         yeyu22: { name: '未来', gps: 1e25, click: 1e26, prob: 0.0000001, growthRate: 13.00 },
         yeyu23: { name: '从前', gps: 2e25, click: 2e26, prob: 0.0000001, growthRate: 13.50 },
         yeyu24: { name: '星澜', gps: 5e25, click: 5e26, prob: 0.0000001, growthRate: 14.00 }
        };
        // 副本装备配置
        const dungeonEquipmentTypes = {
            common: { name: '废品', growthRange: [0.00001, 0.0005] },
            rare: { name: '倚天剑', growthRange: [0.001, 0.10] },
            epic: { name: '青龙枪', growthRange: [0.001, 0.15] },
            legendary: { name: '白虎斧', growthRange: [0.001, 0.20] },
            ancient: { name: '朱雀弓', growthRange: [0.001, 0.25] },
            divine: { name: '玄武盾', growthRange: [0.001, 0.30] },
            arcane: { name: '麒麟杖', growthRange: [0.001, 0.35] },
            celestial: { name: '凤凰剑', growthRange: [0.001, 0.40] },
            infernal: { name: '饕餮刀', growthRange: [0.001, 0.45] },
            astral: { name: '穷奇戟', growthRange: [0.001, 0.50] },
            primeval: { name: '烛龙枪', growthRange: [0.001, 0.60] },
            transcendental: { name: '白泽剑', growthRange: [0.001, 0.70] },
            quantum: { name: '混沌斧', growthRange: [0.001, 0.80] },
            ultimate: { name: '太初刃', growthRange: [0.001, 0.90] },
            ultimate1: { name: '幻梦·洪荒刃☆', growthRange: [0.001, 1.00] },
            ultimate2: { name: '灵蕴神界剑★', growthRange: [0.001, 1.10] },
            ultimate3: { name: '蚀魂·地狱斧★★', growthRange: [0.001, 1.20] },
            ultimate4: { name: '蚀魂·暗夜枪★★★', growthRange: [0.001, 1.30] },
            ultimate5: { name: '遗梦·异界弓★★★★', growthRange: [0.001, 1.40] },
            ultimate6: { name: '幻月·现代盾★★★★★', growthRange: [0.001, 1.50] },
            ultimate7: { name: '寒星·风神杖★★★★★★', growthRange: [0.001, 1.60] },
            ultimate8: { name: '炎凤·雷霆戟★★★★★★★', growthRange: [0.001, 1.70] },
            ultimate9: { name: '雾霭·星辰刃★★★★★★★★', growthRange: [0.001, 1.80] },
            ultimate10: { name: '月尘·虚空斧★★★★★★★★', growthRange: [0.001, 1.90] },
            ultimate11: { name: '焚天·混沌枪○', growthRange: [0.001, 2.00] },
            ultimate12: { name: '焚天·永恒剑●', growthRange: [0.001, 2.10] },
            ultimate13: { name: '混沌·幽冥弓●●', growthRange: [0.001, 2.20] },
            ultimate14: { name: '星辰·天启盾●●●', growthRange: [0.001, 2.30] },
            ultimate15: { name: '太古·破晓杖●●●●', growthRange: [0.001, 2.40] },
            ultimate16: { name: '月尘·末日戟●●●●●', growthRange: [0.001, 2.50] },
            ultimate17: { name: '月尘·苍穹刃●●●●●●', growthRange: [0.001, 2.60] },
            ultimate18: { name: '流萤·幻影斧●●●●●●●', growthRange: [0.001, 2.70] },
            ultimate19: { name: '皓宇·天罚枪●●●●●●●●', growthRange: [0.001, 2.80] },
            ultimate20: { name: '灵幻·神罚剑●●●●●●●●●', growthRange: [0.001, 2.90] },
            ultimate21: { name: '炽阳·魔界弓◇', growthRange: [0.001, 3.00] },
            ultimate22: { name: '琥珀·圣光盾◆', growthRange: [0.001, 3.10] },
            ultimate23: { name: '紫霄·暗影杖◆◆', growthRange: [0.001, 3.20] },
            ultimate24: { name: '荒古·龙魂戟◆◆◆', growthRange: [0.001, 3.30] },
            ultimate25: { name: '破晓·天穹刃◆◆◆◆', growthRange: [0.001, 3.40] },
            ultimate26: { name: '星澜·炎狱斧◆◆◆◆◆', growthRange: [0.001, 3.50] },
            ultimate27: { name: '龙炎·神枪戟◆◆◆◆◆◆', growthRange: [0.001, 3.60] },
            ultimate28: { name: '鸿蒙·冥界剑◆◆◆◆◆◆◆', growthRange: [0.001, 3.70] },
            ultimate29: { name: '鸿蒙·天界弓◆◆◆◆◆◆◆◆', growthRange: [0.001, 3.80] },
            ultimate30: { name: '荒古·地狱盾◆◆◆◆◆◆◆◆◆', growthRange: [0.001, 3.90] },
            ultimate31: { name: '荒炎·太古杖□', growthRange: [0.001, 4.00] },
            ultimate32: { name: '荒炎·异界戟■', growthRange: [0.001, 4.10] },
            ultimate33: { name: '荒炎·现代刃■■', growthRange: [0.001, 4.20] },
            ultimate34: { name: '凤羽·风神斧■■■', growthRange: [0.001, 4.30] },
            ultimate35: { name: '荒炎·雷霆枪■■■■', growthRange: [0.001, 4.40] },
            ultimate36: { name: '荒炎·星辰剑■■■■■', growthRange: [0.001, 4.50] },
            ultimate37: { name: '虚空·玄冰弓■■■■■■', growthRange: [0.001, 4.60] },
            ultimate38: { name: '虚空·混沌盾■■■■■■■', growthRange: [0.001, 4.70] },
            ultimate39: { name: '虚空·永恒杖■■■■■■■■', growthRange: [0.001, 4.80] },
            ultimate40: { name: '虚空·幽冥戟■■■■■■■■■', growthRange: [0.001, 4.90] },
            ultimate41: { name: '天启·穿越刃△', growthRange: [0.001, 5.00] },
            ultimate42: { name: '天启·破晓斧▲', growthRange: [0.001, 5.10] },
            ultimate43: { name: '时空·末日枪▲▲', growthRange: [0.001, 5.20] },
            ultimate44: { name: '九幽·苍穹剑▲▲▲', growthRange: [0.001, 5.30] },
            ultimate45: { name: '幻影·雷电弓▲▲▲▲', growthRange: [0.001, 5.40] },
            ultimate46: { name: '天罚·雷霆盾▲▲▲▲▲', growthRange: [0.001, 5.50] },
            ultimate47: { name: '神罚·雷霆杖▲▲▲▲▲▲', growthRange: [0.001, 5.60] },
            ultimate48: { name: '魔界·邪战戟▲▲▲▲▲▲▲', growthRange: [0.001, 5.70] },
            ultimate49: { name: '圣光·灭世剑▲▲▲▲▲▲▲▲', growthRange: [0.001, 5.80] },
            ultimate50: { name: '宇宙·神王剑▲▲▲▲▲▲▲▲▲', growthRange: [0.001, 5.90] }      
        };

        // 宝箱概率配置
        const chestProbabilities = {
    1: [ { rarity: 'common', prob: 0.8 }, { rarity: 'rare', prob: 0.2 } ],
    2: [ { rarity: 'rare', prob: 0.8 }, { rarity: 'epic', prob: 0.14 }, { rarity: 'legendary', prob: 0.05 }, { rarity: 'ancient', prob: 0.01 } ],
    3: [ { rarity: 'ancient', prob: 0.8 }, { rarity: 'divine', prob: 0.14 }, { rarity: 'arcane', prob: 0.05 }, { rarity: 'celestial', prob: 0.01 } ],
    4: [ { rarity: 'celestial', prob: 0.8 }, { rarity: 'infernal', prob: 0.14 }, { rarity: 'astral', prob: 0.05 }, { rarity: 'primeval', prob: 0.01 } ],
    5: [ { rarity: 'primeval', prob: 0.8 }, { rarity: 'transcendental', prob: 0.14 }, { rarity: 'quantum', prob: 0.05 }, { rarity: 'ultimate', prob: 0.01 } ],
    6: [ { rarity: 'ultimate', prob: 0.8 }, { rarity: 'chaos', prob: 0.14 }, { rarity: 'eternal', prob: 0.05 }, { rarity: 'void', prob: 0.01 } ],
    7: [ { rarity: 'void', prob: 0.8 }, { rarity: 'genesis', prob: 0.14 }, { rarity: 'divineRealm', prob: 0.05 }, { rarity: 'apocalypse', prob: 0.01 } ],
    8: [ { rarity: 'apocalypse', prob: 0.8 }, { rarity: 'yeyu1', prob: 0.14 }, { rarity: 'yeyu2', prob: 0.05 }, { rarity: 'yeyu3', prob: 0.01 } ],
    9: [ { rarity: 'yeyu3', prob: 0.8 }, { rarity: 'yeyu4', prob: 0.14 }, { rarity: 'yeyu5', prob: 0.05 }, { rarity: 'yeyu6', prob: 0.01 } ],
    10: [ { rarity: 'yeyu6', prob: 0.8 }, { rarity: 'yeyu7', prob: 0.14 }, { rarity: 'yeyu8', prob: 0.05 }, { rarity: 'yeyu9', prob: 0.01 } ],
    11: [ { rarity: 'yeyu9', prob: 0.8 }, { rarity: 'yeyu10', prob: 0.14 }, { rarity: 'yeyu11', prob: 0.05 }, { rarity: 'yeyu12', prob: 0.01 } ],
    12: [ { rarity: 'yeyu12', prob: 0.8 }, { rarity: 'yeyu13', prob: 0.14 }, { rarity: 'yeyu14', prob: 0.05 }, { rarity: 'yeyu15', prob: 0.01 } ],
    13: [ { rarity: 'yeyu15', prob: 0.8 }, { rarity: 'yeyu16', prob: 0.14 }, { rarity: 'yeyu17', prob: 0.05 }, { rarity: 'yeyu18', prob: 0.01 } ],
    14: [ { rarity: 'yeyu18', prob: 0.8 }, { rarity: 'yeyu19', prob: 0.14 }, { rarity: 'yeyu20', prob: 0.05 }, { rarity: 'yeyu21', prob: 0.01 } ],
    15: [ { rarity: 'yeyu21', prob: 0.8 }, { rarity: 'yeyu22', prob: 0.14 }, { rarity: 'yeyu23', prob: 0.05 }, { rarity: 'yeyu24', prob: 0.01 } ]
};

        // 宠物配置
        const petConfig = {
            thunderKirin: { name: '苍雷麒麟', currency: 'gold', multiplier: 0.10 }, 
            chaosTaotie: { name: '混沌饕餮', currency: 'diamond', multiplier: 0.30 }, 
            netherQiongqi: { name: '九幽穷奇', currency: 'titanium', multiplier: 0.90 }, 
            abyssKun: { name: '霸渊巨鲲', currency: 'starstone', multiplier: 2.70 }, 
            primordialZhuLong: { name: '太初烛龙', currency: 'cosmicstone', multiplier: 8.10 }, 
        wanJunSuanNi: { name: '万钧狻猊', currency: 'superstone', multiplier: 24.30 }, 
          yanYuBiAn: { name: '炎狱狴犴', currency: 'otherworldstone', multiplier: 72.90 }, 
          yuyu1: { name: '赤霄夔龙', currency: 'xingjiestone', multiplier: 218.70 }, 
          yuyu2: { name: '震岳白泽', currency: 'hundunstone', multiplier: 656.10 }, 
         yuyu3: { name: '焚天蛊雕', currency: 'lingtone', multiplier: 1968.30 }, 
         yuyu4: { name: '血煞梼杌', currency: 'huangtone', multiplier: 5904.90 }, 
        yuyu5: { name: '玄渊白犼', currency: 'mingtone', multiplier: 17714.70 },
         yuyu6: { name: '灾祸蜚牛', currency: 'xutong', multiplier: 53144.10 }, 
         yuyu7: { name: '寂灭罗睺', currency: 'shitone', multiplier: 159432.30 }, 
        yuyu8: { name: '永劫蚩尤', currency: 'weitone', multiplier: 478296.90 } 
     };

        // 魂环配置
        const soulRingTypes = {
            year1: { name: '一年魂环', baseMult: 0.02, costBase: 1000 },
            year10: { name: '十年魂环', baseMult: 0.05, costBase: 1000 },
            year100: { name: '百年魂环', baseMult: 0.08, costBase: 1000 },
            year1000: { name: '千年魂环', baseMult: 0.10, costBase: 1000 },
            year10000: { name: '万年魂环', baseMult: 0.12, costBase: 1000 },
            year100000: { name: '十万年魂环', baseMult: 0.15, costBase: 1000 },
            year1000000: { name: '百万年魂环', baseMult: 0.18, costBase: 1000 },
            year10000000: { name: '千万年魂环', baseMult: 0.20, costBase: 1000 },
            year100000000: { name: '亿年魂环', baseMult: 0.25, costBase: 1000 },
            year2: { name: '太古·混沌亿年魂环', baseMult: 0.30, costBase: 1000 },
            year3: { name: '鸿蒙·始源亿年魂环', baseMult: 0.35, costBase: 1000 },
            year4: { name: '亘古·时空亿年魂环', baseMult: 0.40, costBase: 1000 },
            year5: { name: '九幽·冥渊亿年魂环', baseMult: 0.45, costBase: 1000 },
            year6: { name: '皓宇·星辰亿年魂环', baseMult: 0.50, costBase: 1000 },
            year7: { name: '炎狱·焚天亿年魂环', baseMult: 0.55, costBase: 1000 },
            year8: { name: '霜烬·极寒亿年魂环', baseMult: 0.60, costBase: 1000 },
            year9: { name: '灵幻·万象亿年魂环', baseMult: 0.65, costBase: 1000 },
            year11: { name: '炽阳·耀世亿年魂环', baseMult: 0.70, costBase: 1000 },
            year12: { name: '暗蚀·灭世亿年魂环', baseMult: 0.75, costBase: 1000 },
            year13: { name: '圣辉·救赎亿年魂环', baseMult: 0.80, costBase: 1000 },
            year14: { name: '紫霄·雷罚亿年魂环', baseMult: 0.85, costBase: 1000 },
            year15: { name: '青木·生机亿年魂环', baseMult: 0.90, costBase: 1000 },
            year16: { name: '星澜·幻梦亿年魂环', baseMult: 0.95, costBase: 1000 },
            year17: { name: '渊海·无尽亿年魂环', baseMult: 1.00, costBase: 1000 },
            year18: { name: '荒古·遗世亿年魂环', baseMult: 1.10, costBase: 1000 },
            year19: { name: '净世·光明亿年魂环', baseMult: 1.20, costBase: 1000 },
            year20: { name: '蚀灵·诅咒亿年魂环', baseMult: 1.30, costBase: 1000 },
            year21: { name: '逆乱·时空亿年魂环', baseMult: 1.40, costBase: 1000 },
            year22: { name: '龙渊·霸者亿年魂环', baseMult: 1.50, costBase: 1000 },
            year23: { name: '凤羽·炎舞亿年魂环', baseMult: 1.60, costBase: 1000 },
            year24: { name: '星辰·命数亿年魂环', baseMult: 1.70, costBase: 1000 },
            year25: { name: '荒炎·破灭亿年魂环', baseMult: 1.80, costBase: 1000 },
            year26: { name: '玄冰·永冻亿年魂环', baseMult: 1.90, costBase: 1000 },
            year27: { name: '灵犀·心眼亿年魂环', baseMult: 2.00, costBase: 1000 },
            year28: { name: '圣谕·裁决亿年魂环', baseMult: 2.10, costBase: 1000 },
            year29: { name: '九幽·黄泉亿年魂环', baseMult: 2.20, costBase: 1000 },
            year30: { name: '灵蕴·造化亿年魂环', baseMult: 2.30, costBase: 1000 },
            year31: { name: '混沌·元始亿年魂环', baseMult: 2.40, costBase: 1000 },
            year32: { name: '苍穹·御天亿年魂环', baseMult: 2.50, costBase: 1000 },
            year33: { name: '龙炎·焚天亿年魂环', baseMult: 2.60, costBase: 1000 }, 
            year34: { name: '血狱·魔神亿年魂环', baseMult: 2.70, costBase: 1000 },  
            year35: { name: '赤霄·苍穹亿年魂环', baseMult: 2.80, costBase: 1000 },
            year36: { name: '炎凤·涅槃亿年魂环', baseMult: 2.90, costBase: 1000 },
            year37: { name: '闫闫·黑丝亿年魂环', baseMult: 3.00, costBase: 1000 }
        };
           const TECHNIQUE_DISPLAY_ORDER = [
    // 生命类（防御型）
    "immortalAsuraBody",       // 不灭修罗体
    "eightDesolationsWarDemonBody", // 八荒战魔躯
    "nineRevolutionsProfoundBody",  // 九转玄黄身
    "loneDestinyBone",         // 天煞孤星骨
    "bloodPrisonMadGodArmor",  // 血狱狂神铠
    
    // 攻击类（输出型）
    "godSlayingBurningHeavenArt",  // 弑神焚天诀
    "burialHeavenBladePrisonManual", // 葬天刀狱谱
    "tenDirectionsAnnihilationSpearCodex", // 十方俱灭枪典
    "thousandCalamitiesVoidArrowArt", // 千劫裂空箭术
    "ancientAnnihilationHalberdArt", // 万古寂灭戟法
    
    // 暴击类
    "nineHeavensThunderboltTruth", // 九霄雷殛真解
    "netherBloodSeaDiagram",    // 幽冥血海图录
    "riverStarsHangingSecretScroll", // 星河倒悬秘卷
    "eightDesolationsFireDragonRecord", // 八荒火龙焚世录
    "iceSealThreeThousandRealmArt", // 冰封三千界心法
    
    // 爆伤类
    "nineCalamitiesWorldDestroyingPalm", // 九劫灭世掌
    "chaosCreationForce",      // 混沌开天劲
    "dragonElephantShatteringVoidArt", // 龙象碎穹功
    "greatSunFallingStarFist", // 大日陨星拳
    
    // 特殊效果类（连击/多段攻击）
    "greatVoidReturnToVoidCodex", // 太虚归墟典
    "samsaraCalamityAnnihilationSutra", // 轮回劫灭经
    "yinYangReversalArt",      // 阴阳逆命术
    "zhouHeavenStarsFallingWay", // 周天星陨道
    "ancientVoidRecord"        // 万古空冥录
];
   const DUNGEON_EQUIPMENT_ORDER = [
    'common',     
    'rare',       
    'epic',       
    'legendary',  
    'ancient',    
    'divine',    
    'arcane',     
    'celestial',  
    'infernal',  
    'astral',     
    'primeval',  
    'transcendental', 
    'quantum',   
    'ultimate',
    'ultimate1',     
    'ultimate2',   
    'ultimate3',       
    'ultimate4',   
    'ultimate5', 
    'ultimate6',    
    'ultimate7',     
    'ultimate8',   
    'ultimate9',       
    'ultimate10',   
    'ultimate11', 
    'ultimate12',     
    'ultimate13',     
    'ultimate14',   
    'ultimate15',       
    'ultimate16',   
    'ultimate17', 
    'ultimate18',   
    'ultimate19',     
    'ultimate20',   
    'ultimate21',       
    'ultimate22',   
    'ultimate23', 
    'ultimate24',   
    'ultimate25',   
    'ultimate26',       
    'ultimate27',   
    'ultimate28', 
    'ultimate29',     
    'ultimate30',     
    'ultimate31',   
    'ultimate32',       
    'ultimate33',   
    'ultimate34', 
    'ultimate35',     
    'ultimate36',     
    'ultimate37',   
    'ultimate38',       
    'ultimate39',   
    'ultimate40', 
    'ultimate41',    
    'ultimate42',     
    'ultimate43',   
    'ultimate44',       
    'ultimate45',   
    'ultimate46', 
    'ultimate47', 
    'ultimate48',   
    'ultimate49', 
    'ultimate50'
];

// 切换自动转生状态
function toggleAutoReincarnation() {
    player.autoReincarnation = !player.autoReincarnation;
    document.getElementById('autoReincarnationStatus').textContent = player.autoReincarnation ? '开启' : '关闭';
    logAction(`自动转生已${player.autoReincarnation ? '开启' : '关闭'}`, 'info');
}

// 切换自动转生状态
function toggleAutoReincarnation() {
    player.autoReincarnation = !player.autoReincarnation;
    document.getElementById('autoReincarnationStatus').textContent = player.autoReincarnation ? '开启' : '关闭';
    logAction(`自动转生已${player.autoReincarnation ? '开启' : '关闭'}`, 'info');
}

// 检查自动转生条件
function checkAutoReincarnation() {
    if (!player.autoReincarnation) return;
    
    // 计算当前转生所需的总等级
    const requiredLevel = 10000 + player.reincarnationCount * 20;
    
    // 计算所有普通装备的总等级
    const totalCommonLevel = player.equipment
        .filter(eq => eq.rarity === 'common')
        .reduce((sum, eq) => sum + eq.level, 0);
    
    if (totalCommonLevel >= requiredLevel) {
        // 直接执行转生逻辑，不弹出确认对话框
        autoReincarnate();
    }
}

// 自动转生逻辑（不弹出确认对话框）
function autoReincarnate() {
    // 计算当前转生所需的总等级
    const requiredLevel = 10000 + player.reincarnationCount * 20;
    
    // 计算所有普通装备的总等级
    const totalCommonLevel = player.equipment
        .filter(eq => eq.rarity === 'common')
        .reduce((sum, eq) => sum + eq.level, 0);
    
    if (totalCommonLevel < requiredLevel) {
        logAction(`自动转生失败：普通装备总等级不足（需要${requiredLevel}级，当前${totalCommonLevel}级）`, "error");
        return;
    }

    let totalReincarnationCoin = 0;

    // 计算转生币奖励
    player.equipment.forEach(eq => {
        switch (eq.rarity) {
            case 'common':
                totalReincarnationCoin += eq.level * 0.0001;
                break;
            case 'rare':
                totalReincarnationCoin += eq.level * 0.0002;
                break;
            case 'epic':
                totalReincarnationCoin += eq.level * 0.001;
                break;
            case 'legendary':
                totalReincarnationCoin += eq.level * 0.003;
                break;
            case 'ancient':
                totalReincarnationCoin += eq.level * 0.005;
                break;
            case 'divine':
                totalReincarnationCoin += eq.level * 0.008;
                break;
            case 'arcane':
                totalReincarnationCoin += eq.level * 0.01;
                break;
            case 'celestial':
                totalReincarnationCoin += eq.level * 0.03;
                break;
            case 'infernal':
                totalReincarnationCoin += eq.level * 0.05;
                break;
            case 'astral':
                totalReincarnationCoin += eq.level * 0.08;
                break;
            case 'primeval':
                totalReincarnationCoin += eq.level * 0.1;
                break;
            case 'transcendental':
                totalReincarnationCoin += eq.level * 0.3;
                break;
            case 'quantum':
                totalReincarnationCoin += eq.level * 0.5;
                break;
            case 'ultimate':
                totalReincarnationCoin += eq.level * 1.0;
                break;
            case 'chaos':
                totalReincarnationCoin += eq.level * 3.0;
                break;
            case 'eternal':
                totalReincarnationCoin += eq.level * 5.0;
                break;
            case 'void':
                totalReincarnationCoin += eq.level * 10.0;
                break;
            case 'genesis':
                totalReincarnationCoin += eq.level * 20.0;
                break;
            case 'divineRealm':
                totalReincarnationCoin += eq.level * 30.0;
                break;
            case 'apocalypse':
                totalReincarnationCoin += eq.level * 40.0;
                break;
            case 'yeyu1':
                totalReincarnationCoin += eq.level * 50.0;
                break;
            case 'yeyu2':
                totalReincarnationCoin += eq.level * 60.0;
                break;
            case 'yeyu3':
                totalReincarnationCoin += eq.level * 70.0;
                break;
            case 'yeyu4':
                totalReincarnationCoin += eq.level * 80.0;
                break;
            case 'yeyu5':
                totalReincarnationCoin += eq.level * 90.0;
                break;
            case 'yeyu6':
                totalReincarnationCoin += eq.level * 100.0;
                break;
            case 'yeyu7':
                totalReincarnationCoin += eq.level * 200.0;
                break;
            case 'yeyu8':
                totalReincarnationCoin += eq.level * 300.0;
                break;
            case 'yeyu9':
                totalReincarnationCoin += eq.level * 400.0;
                break;
            case 'yeyu10':
                totalReincarnationCoin += eq.level * 500.0;
                break;
            case 'yeyu11':
                totalReincarnationCoin += eq.level * 600.0;
                break;
            case 'yeyu12':
                totalReincarnationCoin += eq.level * 700.0;
                break;
            case 'yeyu13':
                totalReincarnationCoin += eq.level * 800.0;
                break;
            case 'yeyu14':
                totalReincarnationCoin += eq.level * 900.0;
                break;
            case 'yeyu15':
                totalReincarnationCoin += eq.level * 1000.0;
                break;
            case 'yeyu16':
                totalReincarnationCoin += eq.level * 2000.0;
                break;
            case 'yeyu17':
                totalReincarnationCoin += eq.level * 3000.0;
                break;
            case 'yeyu18':
                totalReincarnationCoin += eq.level * 4000.0;
                break;
            case 'yeyu19':
                totalReincarnationCoin += eq.level * 5000.0;
                break;
            case 'yeyu20':
                totalReincarnationCoin += eq.level * 6000.0;
                break;
            case 'yeyu21':
                totalReincarnationCoin += eq.level * 7000.0;
                break;
            case 'yeyu22':
                totalReincarnationCoin += eq.level * 8000.0;
                break;
            case 'yeyu23':
                totalReincarnationCoin += eq.level * 9000.0;
                break;
            case 'yeyu24':
                totalReincarnationCoin += eq.level * 10000.0;
                break;
        }
    });

    // 重置装备等级
    player.equipment.forEach(eq => {
        eq.level = 1 + player.reincarnationStats.equipmentLevelBonus.level * 200; // 转生属性加成
        eq.gps = equipmentTypes[eq.rarity].gps * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
        eq.click = equipmentTypes[eq.rarity].click * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
    });

    // 清空货币
    player.gold = 0;
    player.diamond = 0;
    player.titanium = 0;
    player.starstone = 0;
    player.cosmicstone = 0;
    player.superstone = 0;
    player.otherworldstone = 0;
    player.xingjiestone = 0;
    player.hundunstone = 0;
    player.lingtone = 0;
    player.huangtone = 0;
    player.mingtone = 0;
    player.xutong = 0;
    player.shitone = 0;
    player.weitone = 0;   
 // 重置材料宝箱购买成本
            player.materialChestCost = 1;
            player.techniqueChestCost = 1;
    // 增加转生币
    player.reincarnationCoin += totalReincarnationCoin;
    player.reincarnationCount++;
 player.autoBuyTechniqueChest = true;
    // 修改属性点计算逻辑
    player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
    player.attributes.remainingPoints += 1; // 每次转生增加1点剩余属性点

    // 检查转生成就
    checkReincarnationAchievements();

    logAction(`自动转生成功！获得转生币: ${totalReincarnationCoin.toFixed(4)}`, 'success');
    updateDisplay();
    updateTechniqueBonuses(); // 转生后更新功法加成
    updatePlayerBattleStats(); // 更新战斗属性
}


        // 转生系统
        function reincarnate() {
   // 计算当前转生所需的总等级
    const requiredLevel = 10000 + player.reincarnationCount * 20;
    
    // 计算所有普通装备的总等级
    const totalCommonLevel = player.equipment
        .filter(eq => eq.rarity === 'common')
        .reduce((sum, eq) => sum + eq.level, 0);
    
    if (totalCommonLevel < requiredLevel) {
        logAction(`转生需要普通装备总等级达到${requiredLevel}级（当前${totalCommonLevel}级）！`, "error");
        return;
    }

    showCustomConfirm(`确定要转生吗？需要普通装备总等级≥${requiredLevel}级，所有装备等级将重置为1级，货币将被清空！`, (confirmed) => {
        if (confirmed) {
            let totalReincarnationCoin = 0;

            // 计算转生币奖励
            player.equipment.forEach(eq => {
                switch (eq.rarity) {
                    case 'common':
                        totalReincarnationCoin += eq.level * 0.0001;
                        break;
                    case 'rare':
                        totalReincarnationCoin += eq.level * 0.0002;
                        break;
                    case 'epic':
                        totalReincarnationCoin += eq.level * 0.001;
                        break;
                    case 'legendary':
                        totalReincarnationCoin += eq.level * 0.003;
                        break;
                    case 'ancient':
                        totalReincarnationCoin += eq.level * 0.005;
                        break;
                    case 'divine':
                        totalReincarnationCoin += eq.level * 0.008;
                        break;
                    case 'arcane':
                        totalReincarnationCoin += eq.level * 0.01;
                        break;
                    case 'celestial':
                        totalReincarnationCoin += eq.level * 0.03;
                        break;
                    case 'infernal':
                        totalReincarnationCoin += eq.level * 0.05;
                        break;
                    case 'astral':
                        totalReincarnationCoin += eq.level * 0.08;
                        break;
                    case 'primeval':
                        totalReincarnationCoin += eq.level * 0.1;
                        break;
                    case 'transcendental':
                        totalReincarnationCoin += eq.level * 0.3;
                        break;
                    case 'quantum':
                        totalReincarnationCoin += eq.level * 0.5;
                        break;
                    case 'ultimate':
                        totalReincarnationCoin += eq.level * 1.0;
                        break;
                    case 'chaos':
                        totalReincarnationCoin += eq.level * 3.0;
                        break;
                   case 'eternal':
                        totalReincarnationCoin += eq.level * 5.0;
                        break;
                   case 'void':
                        totalReincarnationCoin += eq.level * 10.0;
                        break;
                   case 'genesis':
                        totalReincarnationCoin += eq.level * 20.0;
                        break;
                   case 'divineRealm':
                        totalReincarnationCoin += eq.level * 30.0;
                        break;
                   case 'apocalypse':
                        totalReincarnationCoin += eq.level * 40.0;
                        break;
                    case 'yeyu1':
                        totalReincarnationCoin += eq.level * 50.0;
                        break;
                    case 'yeyu2':
                        totalReincarnationCoin += eq.level * 60.0;
                        break;
                     case 'yeyu3':
                        totalReincarnationCoin += eq.level * 70.0;
                        break;
                     case 'yeyu4':
                        totalReincarnationCoin += eq.level * 80.0;
                        break;
                     case 'yeyu5':
                        totalReincarnationCoin += eq.level * 90.0;
                        break;
                     case 'yeyu6':
                        totalReincarnationCoin += eq.level * 100.0;
                        break;
                    case 'yeyu7':
                        totalReincarnationCoin += eq.level * 200.0;
                        break;
                    case 'yeyu8':
                        totalReincarnationCoin += eq.level * 300.0;
                        break;
                     case 'yeyu9':
                        totalReincarnationCoin += eq.level * 400.0;
                        break;
                     case 'yeyu10':
                        totalReincarnationCoin += eq.level * 500.0;
                        break;
                     case 'yeyu11':
                        totalReincarnationCoin += eq.level * 600.0;
                        break;
                     case 'yeyu12':
                        totalReincarnationCoin += eq.level * 700.0;
                        break; 
                       case 'yeyu13':
                        totalReincarnationCoin += eq.level * 800.0;
                        break;
                    case 'yeyu14':
                        totalReincarnationCoin += eq.level * 900.0;
                        break;
                     case 'yeyu15':
                        totalReincarnationCoin += eq.level * 1000.0;
                        break;
                    case 'yeyu16':
                        totalReincarnationCoin += eq.level * 2000.0;
                        break;
                    case 'yeyu17':
                        totalReincarnationCoin += eq.level * 3000.0;
                        break;
                     case 'yeyu18':
                        totalReincarnationCoin += eq.level * 4000.0;
                        break;
                     case 'yeyu19':
                        totalReincarnationCoin += eq.level * 5000.0;
                        break;
                     case 'yeyu20':
                        totalReincarnationCoin += eq.level * 6000.0;
                        break;
                     case 'yeyu21':
                        totalReincarnationCoin += eq.level * 7000.0;
                        break; 
                       case 'yeyu22':
                        totalReincarnationCoin += eq.level * 8000.0;
                        break;
                    case 'yeyu23':
                        totalReincarnationCoin += eq.level * 9000.0;
                        break;
                     case 'yeyu24':
                        totalReincarnationCoin += eq.level * 10000.0;
                        break;
                }
            });

            // 重置装备等级
            player.equipment.forEach(eq => {
                eq.level = 1 + player.reincarnationStats.equipmentLevelBonus.level * 200; // 转生属性加成
                eq.gps = equipmentTypes[eq.rarity].gps * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
                eq.click = equipmentTypes[eq.rarity].click * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
            });

            // 清空货币
            player.gold = 0;
            player.diamond = 0;
            player.titanium = 0;
            player.starstone = 0;
            player.cosmicstone = 0;
            player.superstone = 0;
            player.otherworldstone = 0;
            player.xingjiestone = 0;
            player.hundunstone = 0;
            player.lingtone = 0;
            player.huangtone = 0;
            player.mingtone = 0;
            player.xutong = 0;
            player.shitone = 0;
            player.weitone = 0;

            // 重置材料宝箱购买成本
            player.materialChestCost = 1;
            player.techniqueChestCost = 1;

            // 增加转生币
            player.reincarnationCoin += totalReincarnationCoin;
            player.reincarnationCount++;
            player.autoBuyTechniqueChest = true;
            // 修改属性点计算逻辑
            player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
            player.attributes.remainingPoints += 1; // 每次转生增加1点剩余属性点

            // 检查转生成就
            checkReincarnationAchievements();
       
            logAction(`转生成功！获得转生币: ${totalReincarnationCoin.toFixed(4)}`, 'success');
            updateDisplay();
            updateTechniqueBonuses(); // 转生后更新功法加成
            updatePlayerBattleStats(); // 更新战斗属性
        }
    });
}
        // 检查转生成就
        function checkReincarnationAchievements() {
            const achievements = [
                { count: 10, key: 'reincarnation_10' },
                { count: 100, key: 'reincarnation_100' },
                { count: 1000, key: 'reincarnation_1000' },
                { count: 10000, key: 'reincarnation_10000' }
            ];

            achievements.forEach(({ count, key }) => {
                if (player.reincarnationCount >= count && !player.achievements[key]) {
                    player.achievements[key] = true;
                    const reward = achievementRewards[key];
                    if (reward) {
                        player.gpsMultiplier += reward.gpsMultiplier;
                        logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                        updateAchievementsDisplay();
                    }
                }
            });
        }
      function showActivationCodeDialog() {
    document.getElementById("activationCodeDialog").style.display = "block";
    document.getElementById("activationCodeOverlay").style.display = "block";
    document.getElementById("activationCodeInput").focus();
}

function cancelActivationCode() {
    document.getElementById("activationCodeDialog").style.display = "none";
    document.getElementById("activationCodeOverlay").style.display = "none";
}

function confirmActivationCode() {
      if (player.battle.maxStage < 2) {
        alert("需要打怪模式达到第3层才能开启激活码兑换！");
        return;
    }
    const code = document.getElementById("activationCodeInput").value.trim().toUpperCase();
    const usedCodes = player.usedActivationCodes || [];
    
    if (!code) {
        logAction("请输入激活码", "error");
        return;
    }
    
    if (usedCodes.includes(code)) {
        logAction("该激活码已使用过", "error");
        cancelActivationCode();
        return;
    }
    
    let rewardMsg = "";
    let success = false;
    
    switch(code) {
        case "VIP666":
            player.reincarnationCoin += 1000;
            rewardMsg = "获得1000转生币";
            success = true;
            break;
        case "VIP777":
            // 假设洗炼石字段为refineStone，若实际字段不同请修改
            player.items.refineStone = (player.items.refineStone || 0) + 10;
            rewardMsg = "获得10个洗炼石";
            success = true;
            break;
        case "VIP888":
            player.items.advancedGem = (player.items.advancedGem || 0) + 3;
            rewardMsg = "获得3个高级宝石";
            success = true;
            break;
        case "XINGBI":
            player.nightClub.starCoins = (player.nightClub.starCoins || 0) + 300;
            rewardMsg = "获得300星币";
            success = true;
            break;
        case "YUYU":
            player.cosmicstone += 2;
            rewardMsg = "获得2个宇宙石";
            success = true;
            break;
       case "BANLV":
            player.items.companionKey += 10; 
            player.items.rose += 520;
            rewardMsg = "获得10个伴侣钥匙和520朵玫瑰花";
            success = true;
            break;  
          case "BANLV1":
            player.items.companionKey += 30; 
            player.items.rose += 520;
            rewardMsg = "获得30个伴侣钥匙和520朵玫瑰花";
            success = true;
            break;     
          case "XISUIDAN":
            player.items.rebornDan = (player.items.rebornDan || 0) + 10;
            rewardMsg = "获得10个洗髓丹";
            success = true;
            break;
           case "XIUXIAN":
            player.items.rootDetector = (player.items.rootDetector || 0) + 5;
            rewardMsg = "获得5个灵根检测器";
            success = true;
            break;
            case "XIUXIAN1":
            player.items.bloodlineDetector = (player.items.bloodlineDetector || 0) + 5;
            rewardMsg = "获得5个血脉检测剂";
            success = true;
            break;
           case "WOYAOCHE":
            const models = ["Portofino", "Roma", "SF90"];
            const randomModel = models[Math.floor(Math.random() * models.length)];
            const newVehicle = {
                id: 'vehicle_' + Date.now(),
                brand: "法拉利",
                model: randomModel,
                rarity: 15, // 普通稀有度
                parkTime: 0,
                income: 0
            };
            
            player.parking.vehicles.push(newVehicle);
            rewardMsg = `获得一辆法拉利${randomModel}汽车`;
            success = true;
            break;
      case "WOYAOBYFANG":
            // 兑换别墅
            const villaType = houseTypes.find(h => h.id === 5); // 别墅的id为5
            if (!villaType) {
                logAction("无效的房屋类型", "error");
                return false;
            }
            
            // 创建别墅实例
            const newHouse = {
                id: 'house_' + Date.now(),
                type: villaType.id,
                name: villaType.name,
                rarity: villaType.rarity,
                baseIncome: villaType.income,
                rentTime: 0,
                isRented: false
            };
            
            // 添加到拥有的房屋列表
            player.houses.ownedHouses.push(newHouse);            
         rewardMsg ="成功兑换激活码  获得别墅！";     
          success = true;
            break;
        case "SHENQI":
            player.items.yuzhou4 = (player.items.yuzhou4 || 0) + 200;
            rewardMsg = "获得200个神器碎片发票";
            success = true;
            break;       
       case "YUZHOU":
            player.items.yuzhou3 = (player.items.yuzhou3 || 0) + 200;
            rewardMsg = "获得200个宇宙晶体发票";
            success = true;
            break;    
       case "ANBAO":
            player.items.yuzhou2 = (player.items.yuzhou2 || 0) + 1000;
            rewardMsg = "获得1000个暗物质发票";
            success = true;
            break; 
       case "MIMI":
            player.items.fuben1 = (player.items.fuben1 || 0) + 10;
            rewardMsg = "获得10个副本令牌";
            success = true;
            break; 
       case "FUBEN":
            player.items.fuben2 = (player.items.fuben2 || 0) + 10;
            rewardMsg = "获得10个秘境钥匙";
            success = true;
            break; 
       case "YUANDAN":
            player.items.baitCount = (player.items.baitCount || 0) + 200;
            rewardMsg = "获得200个鱼饵";
            success = true;
            break; 
       case "YUANDAN1":
            player.items.vipPower = (player.items.vipPower || 0) + 500;
            rewardMsg = "500个VIP能力值";
            success = true;
            break; 
       case "YUANDAN2":
            player.items.companionKey = (player.items.companionKey || 0) + 100;
            rewardMsg = "获得100个伴侣钥匙";
            success = true;
            break; 
        case "YUER":
            player.items.baitCount = (player.items.baitCount || 0) + 20;
            rewardMsg = "获得20个鱼饵";
            success = true;
            break;
        case "VIP666666":
        player.items.vipPower = (player.items.vipPower || 0) + 10;
        rewardMsg = "获得10个VIP能力值";
        success = true;
        break;
        case "ZHIYESHU1":
        player.items.zhiye1 = (player.items.zhiye1 || 0) + 10;
        rewardMsg = "获得10个职业转换书";
        success = true;
        break;
        case "DAGUAIWU1":
        player.items.fuben1 = (player.items.fuben1 || 0) + 3;
        rewardMsg = "获得3个副本令牌";
        success = true;
        break;
            case "HUOBAN1":
        player.items.roseq = (player.items.roseq || 0) + 20;
        rewardMsg = "获得20个香囊";
        success = true;
        break;   
       case "VIP666777":
            // 添加"公测玩家"称号
            if (!player.titles.unlocked.includes("公测玩家")) {
                player.titles.unlocked.push("公测玩家");
                rewardMsg = "获得称号：公测玩家";
                success = true;
                // 自动选择新称号
                player.titles.current = "公测玩家";
                updateDisplay();
            } else {
                logAction("您已拥有此称号", "info");
            }
            break;
        case "补偿宝石损失":
        player.items.divineGem = (player.items.divineGem || 0) + 1;
        rewardMsg = "获得1个神级宝石";
        success = true;
        break;
        default:
            logAction("无效的激活码", "error");
            return;
    }
    
    if (success) {
        // 记录已使用的激活码
        usedCodes.push(code);
        player.usedActivationCodes = usedCodes;
        
        logAction(`激活码兑换成功：${rewardMsg}`, "success");
        updateDisplay(); // 更新界面显示
        cancelActivationCode();
         saveGame();
      setTimeout(() => {
                location.reload(true);
            }, 1000);
    }
}
// 添加VIP等级计算函数
function calculateVipLevel() {
    let currentLevel = 1;
    const { power } = player.vip;
    
    for (let i = vipConfig.length - 1; i >= 0; i--) {
        if (power >= vipConfig[i].requiredPower) {
            currentLevel = vipConfig[i].level;
            break;
        }
    }
    
    return currentLevel;
}

// 获取当前VIP等级的加成
function getVipBonus() {
    const level = player.vip.level;
    const config = vipConfig.find(c => c.level === level) || vipConfig[0];
    return config.bonus;
}

// 更新VIP显示
function updateVipDisplay() {
    const { level, power } = player.vip;
    const currentConfig = vipConfig.find(c => c.level === level) || vipConfig[0];
    const nextConfig = vipConfig.find(c => c.level === level + 1);
    
    document.getElementById('vipLevel').textContent = level;
    
    let progressPercent = 0;
    let progressText = '';
    
    if (nextConfig) {
        const progress = power - currentConfig.requiredPower;
        const total = nextConfig.requiredPower - currentConfig.requiredPower;
        progressPercent = Math.min(100, (progress / total) * 100);
        progressText = `${progress}/${total}`;
    } else {
        progressPercent = 100;
        progressText = '已达最高级';
    }
    
    document.getElementById('vipProgressBar').style.width = `${progressPercent}%`;
    document.getElementById('vipProgressText').textContent = progressText;
    
    // 设置VIP等级渐变色
    const hue = (level - 1) * (360 / 20); // 从0到360度的色相渐变
    document.querySelector('.vip-level-display').style.background = `linear-gradient(to right, hsl(${hue}, 100%, 50%), hsl(${(hue + 60) % 360}, 100%, 50%))`;
    document.querySelector('.vip-level-display').style.webkitBackgroundClip = 'text';
}
function useAllVipPower() {
    if (player.items.vipPower && player.items.vipPower > 0) {
        const useCount = player.items.vipPower;
        player.items.vipPower = 0;
        player.vip.power += useCount;
        
        const newLevel = calculateVipLevel();
        if (newLevel > player.vip.level) {
            const oldLevel = player.vip.level;
            player.vip.level = newLevel;
            logAction(`VIP等级提升至${newLevel}级！全属性装备提升${vipConfig[newLevel - 1].bonus * 100}%`, 'success');
            
            // 刷新所有装备属性
            const newVipBonus = 1 + getVipBonus();
            player.equipment.forEach(eq => {
                eq.gps = safeNumber(eq.gps / (1 + getVipBonusByLevel(oldLevel)) * newVipBonus); 
                eq.click = safeNumber(eq.click / (1 + getVipBonusByLevel(oldLevel)) * newVipBonus);
            });
        }
        
        updateVipDisplay();
        updateDisplay();
        logAction(`使用了${useCount}个VIP能力值`, "info");
    } else {
        logAction("VIP能力值不足！", "error");
    }
}

// 辅助函数：根据等级获取旧的VIP加成（需要实现）
function getVipBonusByLevel(level) {
    const config = vipConfig.find(c => c.level === level) || vipConfig[0];
    return config.bonus;
}
// 计算总GPS时，实时应用当前VIP加成
function calculateTotalGPS() {
    let totalGps = 0;
    player.equipment.forEach(eq => {
        totalGps += eq.gps * (1 + getVipBonus()); // 实时获取最新VIP加成
    });
    // 其他加成（如成就、转生等）
    return totalGps;
}
// 添加设置界面切换函数
function toggleAutoBuySettings() {
    const settings = document.getElementById('autoBuySettings');
    if (settings.style.display === 'none') {
        settings.style.display = 'block';
        // 将当前设置的值填入输入框
        document.getElementById('techniqueMaxCost').value = player.autoBuyTechniqueMaxCost;
    } else {
        settings.style.display = 'none';
    }
}

// 添加设置价格上限函数
function setTechniqueMaxCost() {
    const input = document.getElementById('techniqueMaxCost');
    const value = parseFloat(input.value);
    
    if (!isNaN(value) && value > 0) {
        player.autoBuyTechniqueMaxCost = value;
        logAction(`已设置功法秘籍宝箱自动购买价格上限为: ${formatNumber(value)}`, 'success');
    } else {
        logAction("请输入有效的价格上限", "error");
    }
}

        // 加载存档
       function loadSave() {
    try {
        const save = JSON.parse(localStorage.getItem('goldGameSave'));
        if (save) {
            if (save.lastUpdate && save.lastUpdate > Date.now()) {
                throw new Error("检测到时间回退，强制重置游戏");
            }
            player = migrateSaveData(save);
            player.equipment = validateEquipmentList(save.equipment);
        
            if (save.battle && save.battle.autoSweepEnabled !== undefined) {
            player.battle.autoSweepEnabled = save.battle.autoSweepEnabled;
        }
         updateAutoConvertDisplay();
        if (!player.battle) {
        player.battle = {
            playerHealth: 100 + player.reincarnationCount * 10,
            playerAttack: getTotalClickValue(),
            playerCritRate: 0.1 + player.attributes.critRate * 0.0005,
            playerCritDamage: 1.5 + player.attributes.critDamage * 0.005,
            currentZone: null,
            currentMonster: null,
            monsterResurrections: 0,
            autoBattle: false,
            autoBattleInterval: null
        };
    }
        if (save.autoBuyTechniqueMaxCost !== undefined) {
    player.autoBuyTechniqueMaxCost = save.autoBuyTechniqueMaxCost;
}
  

 if (!player.wings) {
        player.wings = {
            inventory: [],
            equipped: null,
            level: 1,
            upgradeCost: 5
        };
    }

          if (save.level) {
                player.level = {
                    current: save.level.current || 1,
                    exp: save.level.exp || 0,
                    nextLevelExp: save.level.nextLevelExp || 10000,
                    clickBonus: save.level.clickBonus || 0,
                    gpsBonus: save.level.gpsBonus || 0,
                    ascentionCount: save.level.ascentionCount || 0,
                    ascentionMultiplier: save.level.ascentionMultiplier || 1,
                     ascentionCounta: save.level.ascentionCounta || 0,
                    ascentionMultipliera: save.level.ascentionMultipliera || 1                 
                };
            }

             // 确保加载通天塔数据
          if (!player.fishing) {
        player.fishing = {
            level: 1,
            currentExp: 0,
            fishCage: [],
            isFishing: false,
            isBiting: false,
            biteTimer: null,
            biteWindowTimer: null,
            biteTime: 0,
            bonus: 1
        };
    }
         
           
           updateTowerUI();
          calculateOfflineMysteryExp();
            // 重置并重新计算收藏物效果
            resetAllCollectionEffects();
         // 新增：加载存档后自动计算并更新VIP等级
            const actualVipLevel = calculateVipLevel();
            player.vip.level = actualVipLevel;
            updateVipDisplay(); // 立即更新VIP显示

            // 确保自动购买状态被正确加载
            player.autoBuy = save.autoBuy || [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            player.autoBuyMaterialChest = save.autoBuyMaterialChest || false;
           player.autoBuyTechniqueChest = save.autoBuyTechniqueChest || false;
            // 强制覆盖宠物的 multiplier，同时保留等级和其他数据
            Object.keys(player.pets).forEach(petKey => {
                if (petConfig[petKey]) {
                    player.pets[petKey].multiplier = petConfig[petKey].multiplier;
                }
            });
       
            // 初始化自动购买按钮状态
            player.autoBuy.forEach((enabled, index) => {
                const btn = document.getElementById(`autoChest${index + 1}`);
                if (btn) {
                    btn.textContent = `${['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'][index]}宝箱自动购买：${enabled ? '开启' : '关闭'}`;
                }
            });
   

            // 初始化材料宝箱自动购买按钮状态
            const materialChestBtn = document.getElementById('autoMaterialChest');
            if (materialChestBtn) {
                materialChestBtn.textContent = `材料宝箱自动购买：${player.autoBuyMaterialChest ? '开启' : '关闭'}`;
            }
 const techniqueChestBtn = document.getElementById('autoTechniqueChest');
    if (techniqueChestBtn) {
        techniqueChestBtn.textContent = `功法秘籍宝箱自动购买：${player.autoBuyTechniqueChest ? '开启' : '关闭'}`;
    }
         // 在初始化自动购买按钮状态的地方添加
const speedBoostBtn = document.getElementById('autoBuySpeedBoost');
if (speedBoostBtn) {
    speedBoostBtn.textContent = `在线自动购买100倍数量：${player.autoBuySpeedBoost ? '开启' : '关闭'}`;
}
      const onlineBoostBtn = document.getElementById('toggleOnlineBoost');
    if (onlineBoostBtn) {
        onlineBoostBtn.textContent = `在线金币加速100倍: ${player.onlineBoostEnabled ? '开启' : '关闭'}`;
    }
      
            // 确保日志不超过 20 条
            player.actionLogs = player.actionLogs.slice(0, 20);
            player.lotteryResults = player.lotteryResults.slice(0, 5);

         

            // 计算离线时间
            const currentTime = Date.now();
            const maxOfflineTime = 86400 * 1000; // 24 小时（以毫秒为单位）
            const offlineTime = Math.min(currentTime - (player.lastUpdate || currentTime), maxOfflineTime); // 限制离线时间
            const offlineSeconds = Math.floor(offlineTime / 1000); // 将毫秒转换为秒

            if (offlineTime > 1000) {
// 计算离线分钟数
        const offlineMinutes = Math.floor(offlineSeconds / 60);
        
        // 每分钟为每件装备增加1000级
        player.equipment.forEach(eq => {
            eq.level += offlineMinutes * 1000;
        });
                // 模拟离线期间的自动购买
                simulateOfflineAutoBuy(offlineSeconds);
     
               
                // 计算离线收益
                const offlineGPS = getTotalGPS();
                const earnedGold = offlineSeconds * offlineGPS;
                player.gold += earnedGold;
            
      

                // 格式化离线收益
                const formattedEarnedGold = earnedGold >= 1e8 ? earnedGold.toExponential(3) : earnedGold.toLocaleString();

                logAction(`离线收益: +${formattedEarnedGold}金币 (${formatTime(offlineTime)})`, 'offline-reward');
             
                // 模拟离线期间的彩票开奖
                if (player.traditionalLotteryNumbers.length > 0) {
                    const lotteryIntervals = Math.floor(offlineTime / 1800000); // 每 30 分钟开奖一次
                    for (let i = 0; i < lotteryIntervals; i++) {
                        checkTraditionalLotteryResult();
                    }
                }
               calculateOfflineCultivationExp(offlineMinutes);
                // 计算离线期间的银行利息
                calculateBankInterest();
            }
          initSlotMachine();
          initMountData();
          initFarmData();
        updateSectNameDisplay();
         initExplorationSystem();
        initExpeditionData();
    initTreasureMapSystem();
   initNightClubSystem();
    // 计算离线探险奖励
    calculateOfflineExpeditionRewards();
   initHouseSystemOnLoad();
        if (save.exploration) {
                Object.assign(explorationData, save.exploration);
            }
       if (save.tower) {
                player.tower = save.tower;
            }
        // 加载投资游戏数据
            if (save.investmentGame) {
                player.investmentGame = save.investmentGame;
            }
            
            // 初始化投资游戏
            initInvestmentGameOnLoad();
            loadInvestmentGameData();       
 // 初始化投资游戏数据
            if (!player.investmentGame) {
                initInvestmentGame();
            } else {
                // 模拟离线期间的价格变化
                simulateOfflinePriceChanges();
            }
          if (save.runes) {
                player.runes = save.runes;
                           }
          
    if (save.traditionalLotteryBought && save.traditionalLotteryDrawTime) {
                        if (Date.now() >= save.traditionalLotteryDrawTime) {
                            // 立即开奖
                            checkTraditionalLotteryResult();
                        } else {
                            // 设置开奖时间
                            player.traditionalLotteryDrawTime = save.traditionalLotteryDrawTime;
                        }
                    }
        }
    } catch (e) {
        console.warn('存档加载失败，使用默认数据:', e);
    }
    player.lastUpdate = Date.now();
}

  



        // 模拟离线期间的自动购买
        function simulateOfflineAutoBuy(offlineSeconds) {
    const maxOfflineTime = 86400; // 24小时（秒）
    const actualOfflineTime = Math.min(offlineSeconds, maxOfflineTime);
    const minutes = Math.floor(actualOfflineTime / 86400); // 转换为分钟数
    const chestsPerMinute = 1; // 每分钟购买数量

    player.autoBuy.forEach((enabled, index) => {
        if (enabled) {
            const type = index + 1;
            const costConfig = [
                { currency: "gold", amount: 100 },
                { currency: "diamond", amount: 10 },
                { currency: "titanium", amount: 1 },
                { currency: "starstone", amount: 1 },
                { currency: "cosmicstone", amount: 1 },
                { currency: "superstone", amount: 1 },
                { currency: "otherworldstone", amount: 1 },
                { currency: "xingjiestone", amount: 1 },
                { currency: "hundunstone", amount: 1 },
                { currency: "lingtone", amount: 1 },
                { currency: "huangtone", amount: 1 },
                { currency: "mingtone", amount: 1 },
                { currency: "xutong", amount: 1 },
                { currency: "shitone", amount: 1 },
                { currency: "weitone", amount: 1 }                
            ][index];

            // 计算最大可购买数量：分钟数 × 每分钟500个
            const maxPossible = minutes * chestsPerMinute;
            // 计算实际能购买的数量（受限于货币数量）
            const affordable = Math.floor(player[costConfig.currency] / costConfig.amount);
            const actualBuy = Math.min(maxPossible, affordable);

            if (actualBuy > 0) {
                // 扣除总消耗
                player[costConfig.currency] -= actualBuy * costConfig.amount;
                
                // 更新宝箱计数
                const chestType = ['common', 'advanced', 'rare', 'epic', 'legendary', 'chaos', 'apocalypse','yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6', 'yeyu7', 'yeyu8'][index];
                player.chestCounts[chestType] += actualBuy;
                
                // 批量处理装备获取（这里简化处理，实际可根据需要调整概率计算）
                for (let i = 0; i < actualBuy; i++) {
                    const selectedRarity = selectRarity(type);
                    handleEquipment(selectedRarity);
                }
                
                // 检查成就（会自动处理区间判断）
                checkChestAchievements(chestType, player.chestCounts[chestType]);
            }
        }
    });




    // 材料宝箱类似处理
    if (player.autoBuyMaterialChest) {
        const maxPossible = minutes * chestsPerMinute;
        let remaining = maxPossible;
        let totalCost = 0;
        
        // 计算材料宝箱可购买数量（考虑成本递增）
        while (remaining > 0 && player.diamond >= player.materialChestCost + totalCost) {
            totalCost += player.materialChestCost;
            player.materialChestCost *= 2; // 成本翻倍
            remaining--;
        }
        
        if (maxPossible - remaining > 0) {
            player.diamond -= totalCost;
            // 批量处理材料宝箱奖励
            for (let i = 0; i < maxPossible - remaining; i++) {
                const selectedItem = selectMaterialChestItem();
                if (selectedItem.type in player.collections) {
                    player.collections[selectedItem.type]++;
                    applyCollectionEffect(selectedItem.type);
                } else if (selectedItem.type in player.items) {
                    player.items[selectedItem.type]++;
                }
            }
        }
    }

    autoConvertCurrency();
}
function handleVipPowerGain() {
    player.vip.power++;
    const newLevel = calculateVipLevel();
    
    if (newLevel > player.vip.level) {
        const oldLevel = player.vip.level;
        player.vip.level = newLevel;
        logAction(`VIP等级提升至${newLevel}级！全属性装备提升${vipConfig[newLevel - 1].bonus * 100}%`, 'success');
    }
    
    updateVipDisplay();
}
        // 数据迁移
        function migrateSaveData(oldSave) {
    return {
        ...player,
        ...oldSave,
        achievements: {
            ...player.achievements, // 使用默认成就数据
            ...(oldSave.achievements || {}) // 覆盖旧存档的成就数据
        },
        equipment: oldSave.equipment || [],
        items: oldSave.items || { primaryGem: 0, advancedGem: 0, superiorGem: 0, divineGem: 0, vipPower: 0, refineStone: 0, rose: 0, companionKey: 0, rebornDan: 0, baitCount: 0, rootDetector: 0, bloodlineDetector: 0, advanceStone: 0, primaryGemq: 0, zongmen: 0, roseq: 0, yuzhou1: 0, yuzhou2: 0, yuzhou3: 0, yuzhou4: 0, banlv1: 0, banlv2: 0, banlv3: 0, banlv4: 0, banlv5: 0, banlv6: 0, banlv7: 0, banlv8: 0, banlv9: 0, zhiye1: 0, chiban1: 0, zuoqi1: 0, fuben1: 0, shenshou1: 0, fuwen1: 0, fuben2: 0},
        collections: oldSave.collections || {
            lightSpeedHand: 0,
            empHand: 0,
            godlyHand: 0,
            quickHand: 0,
            shadowHand: 0,
            quantumHand: 0,
            lightningHand: 0,
            divineHand: 0
        },
     houses: oldSave.houses || {
                    level: 1,
                    exp: 0,
                    maxHouses: 5,
                    ownedHouses: [],
                    rentedHouses: [],
                    lastUpdate: Date.now(),
                    totalIncome: 0
                },
        pets: oldSave.pets || {
            thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
            chaosTaotie: { level: 0, cost: 1, multiplier: 0.30 },
            netherQiongqi: { level: 0, cost: 1, multiplier: 0.90 },
            abyssKun: { level: 0, cost: 1, multiplier: 2.70 },
            primordialZhuLong: { level: 0, cost: 1, multiplier: 8.10 },
           wanJunSuanNi: { level: 0, cost: 1, multiplier: 24.30 },
           yanYuBiAn: { level: 0, cost: 1, multiplier: 72.90 },
          yuyu1: { level: 0, cost: 1, multiplier: 218.70 },
         yuyu2: { level: 0, cost: 1, multiplier: 656.10 },
          yuyu3: { level: 0, cost: 1, multiplier: 1968.30 },
         yuyu4: { level: 0, cost: 1, multiplier: 5904.90 },
          yuyu5: { level: 0, cost: 1, multiplier: 17714.70 },
          yuyu6: { level: 0, cost: 1, multiplier: 53144.10 },
         yuyu7: { level: 0, cost: 1, multiplier: 159432.30 },
          yuyu8: { level: 0, cost: 1, multiplier: 478296.90 }
        },
        dungeonEquipment: oldSave.dungeonEquipment || [],
        soulRings: oldSave.soulRings || [],
        achievements: oldSave.achievements || player.achievements,
        autoBuy: oldSave.autoBuy || [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], // 新增宝箱自动购买状态
        autoBuyMaterialChest: oldSave.autoBuyMaterialChest || false,
        autoBuyTechniqueChest: oldSave.autoBuyTechniqueChest || false,
       autoBuyTechniqueMaxCost: oldSave.autoBuyTechniqueMaxCost ||1,
        gpsMultiplie: oldSave.gpsMultiplier ||1,
        clickMultiplier: oldSave.clickMultiplier || 1,
        autoConvert: oldSave.autoConvert || false,
        autoConvertCurrency: oldSave.autoConvertCurrency || { gold: false, diamond: false, titanium: false, starstone: false },
        clickTimestamps: oldSave.clickTimestamps || [],
        chestCounts: oldSave.chestCounts || { common: 0, advanced: 0, rare: 0, epic: 0, legendary: 0, chaos: 0, apocalypse: 0, yeyu1: 0, yeyu2: 0, yeyu3: 0, yeyu4: 0, yeyu5: 0, yeyu6: 0, yeyu7: 0, yeyu8: 0 }, // 新增宝箱计数
        reincarnationCoin: oldSave.reincarnationCoin || 0,
        reincarnationCount: oldSave.reincarnationCount || 0,
        reincarnationStats: oldSave.reincarnationStats || {
            gpsBonus: { level: 0, cost: 1 },
            equipmentLevelBonus: { level: 0, cost: 1 },
            clickLimitBonus: { level: 0, cost: 1 }
        },
        materialChestCost: oldSave.materialChestCost || 1,
        stockData: oldSave.stockData || {
            stocks: [
                { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
            ],
            lastStockUpdate: Date.now()
        },
        lotteryResults: oldSave.lotteryResults || [],
        traditionalLotteryNumbers: oldSave.traditionalLotteryNumbers || [],
        lastLotteryDraw: oldSave.lastLotteryDraw || Date.now(),
        bank: oldSave.bank || {
            deposit: 0,
            lastInterestUpdate: Date.now()
        }
    };
}

        // 装备验证
        function validateEquipmentList(equipmentList) {
            return (equipmentList || []).map(eq => ({
                name: eq.name || getEquipmentName(eq),
                rarity: validateRarity(eq.rarity),
                level: Math.max(1, parseInt(eq.level) || 1),
                gps: safeNumber(eq.gps, 0),
                click: safeNumber(eq.click, 0),
                growthRate: safeNumber(eq.growthRate, getDefaultGrowthRate(eq.rarity)),
                gemMultiplier: safeNumber(eq.gemMultiplier, 0),
                collectionMultiplier: safeNumber(eq.collectionMultiplier, 0)
            }));
        }

        // 安全数值处理
        function safeNumber(value, fallback = 0) {
            return typeof value === 'number' ? value : parseFloat(value) || fallback;
        }

        // 核心游戏逻辑
        function getTotalGPS() {
    const towerMultiplier = 1 + player.tower.currentFloor * 0.01;
    const gpsBonus = player.reincarnationStats.gpsBonus.level * 1.00; // 每级增加100% GPS
    const petMultiplier = Object.values(player.pets).reduce((sum, pet) => sum + pet.level * pet.multiplier, 1);

    // 改为使用带职业加成的总装备加成
    const dungeonBonus = getTotalDungeonEquipBonus();
    // 改为使用带职业加成的总魂环加成
    const soulRingBonus = getTotalSoulRingBonus();
 const mysteryBonus = player.mystery.bonus || 1;
const cultivationBonus = player.cultivation.bonus || 1;
const gpsEnhancements =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
const farmGPSEnhancement  = gpsEnhancements[player.farm.level - 1] || gpsEnhancements[gpsEnhancements.length - 1];

const gpsEnhancementss =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
const farmGPSEnhancements  = gpsEnhancementss[player.parking.level - 1] || gpsEnhancementss[gpsEnhancementss.length - 1];

const gpsEnhancemenzss =  [1, 3, 6, 8, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 150, 200, 250, 300, 350, 400, 1];
const farmGPSEnhancemezts  = gpsEnhancemenzss[player.houses.level - 1] || gpsEnhancemenzss[gpsEnhancemenzss.length - 1];

    const gpsBonuss = player.level.gpsBonus * 1.00;   
   const gpsBonusssq = player.liveStream.totalEarnings * 0.00001;  
const gpsBonusssqaa = player.landlord.stats.totalCoinsEarned * 0.0001;  
 const gpsBonussbb = player.mining.gems.diamond * 1.00;  
const gpsEnhancementsp =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
const farmGPSEnhancementp  = gpsEnhancementsp[player.sect.level - 1] || gpsEnhancementsp[gpsEnhancementsp.length - 1];


    return (1 + player.equipment.reduce((sum, eq) => sum + eq.gps * (1+eq.gemMultiplier + eq.collectionMultiplier), 0)) 
        * player.gpsMultiplier 
        * (1 + gpsBonus) 
        * petMultiplier * (1 + dungeonBonus) * (1 + soulRingBonus) * towerMultiplier * mysteryBonus * farmGPSEnhancement * farmGPSEnhancements  * cultivationBonus * gpsBonuss * (1 + gpsBonusssq) * farmGPSEnhancementp * (1 + gpsBonusssqaa) * (1 + gpsBonussbb)*farmGPSEnhancemezts ;
}

function getTotalClickValue() {
    const petMultiplier = Object.values(player.pets).reduce((sum, pet) => sum + pet.level * pet.multiplier, 1);
    // 改为使用带职业加成的总装备加成
    const dungeonBonus = getTotalDungeonEquipBonus();
    // 改为使用带职业加成的总魂环加成
   const fishingBonus = player.fishing ? player.fishing.bonus : 1;
    const soulRingBonus = getTotalSoulRingBonus();
   const cultivationBonus = player.cultivation.bonus || 1;
    const farmClickMultipliers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
 const farmClickBonus = farmClickMultipliers[player.farm.level - 1] || farmClickMultipliers[farmClickMultipliers.length - 1];

const farmClickMultiplierss = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
    const farmClickBonuss = farmClickMultiplierss[player.parking.level - 1] || farmClickMultiplierss[farmClickMultiplierss.length - 1];
const farmClickMultipliersss = [1, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 1];
    const farmClickBonusss = farmClickMultipliersss[player.nightClub.level - 1] || farmClickMultipliersss[farmClickMultipliersss.length - 1];     
     const gpsBonuvvs = player.houses.totalIncome *  0.0001;
    const gpsBonubbs = player.parking.totalIncome *  0.0001;
    const gpsBonusss = player.level.clickBonus * 1.00; 

const farmClickMultiplierssa = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
    const farmClickBonussa = farmClickMultiplierssa[player.liveStream.level - 1] || farmClickMultiplierssa[farmClickMultiplierssa.length - 1];
       const farmClickBonussw = player.landlord.stats.totalCoinsEarned * 0.0001;      

    return (1 + player.equipment.reduce((sum, eq) => sum + eq.click * (1+eq.gemMultiplier + eq.collectionMultiplier), 0)) 
        * player.clickMultiplier 
        * petMultiplier 
        * (1 + dungeonBonus)  // 应用副本装备总加成（含职业乘数）
        * (1 + soulRingBonus) * fishingBonus * farmClickBonus * farmClickBonuss * cultivationBonus * farmClickBonusss * gpsBonusss * farmClickBonussa* (1 + farmClickBonussw) * (1+gpsBonuvvs) * (1+gpsBonubbs); 
}


     
        // 自动兑换货币
        function autoConvertCurrency() {
    const conversions = [
        { from: 'gold', to: 'diamond', rate: 1e5 },
        { from: 'diamond', to: 'titanium', rate: 1e8 },
        { from: 'titanium', to: 'starstone', rate: 1e8 },
        { from: 'starstone', to: 'cosmicstone', rate: 1e8 },
        { from: 'cosmicstone', to: 'superstone', rate: 1e9 },
        { from: 'superstone', to: 'otherworldstone', rate: 1e12 },
        { from: 'otherworldstone', to: 'xingjiestone', rate: 1e12 },
        { from: 'xingjiestone', to: 'hundunstone', rate: 1e12 },
        { from: 'hundunstone', to: 'lingtone', rate: 1e15 },
        { from: 'lingtone', to: 'huangtone', rate: 1e15 },
        { from: 'huangtone', to: 'mingtone', rate: 1e15 },
        { from: 'mingtone', to: 'xutong', rate: 1e20 },
        { from: 'xutong', to: 'shitone', rate: 1e20 },
        { from: 'shitone', to: 'weitone', rate: 1e20 }        
    ];

    conversions.forEach(({ from, to, rate }) => {
        if (player.autoConvertCurrency[from]) {
            const converted = Math.floor(player[from] / rate);
            player[to] += converted;
            player[from] %= rate;
        }
    });
}

        // 点击获取金币，限制每秒10次
        function clickGold() {
            const now = Date.now();
            // 移除超过1秒的点击记录
            player.clickTimestamps = player.clickTimestamps.filter(timestamp => now - timestamp < 1000);

            const clickLimit = 10 + player.reincarnationStats.clickLimitBonus.level; // 每级增加1次点击上限
            if (player.clickTimestamps.length >= clickLimit) {
                logAction("点击速度过快，请稍后再试！", "error");
                return;
            }

            player.clickTimestamps.push(now);

            const value = getTotalClickValue();
            player.gold += value;
            logAction(`点击获取金币: +${value}`, 'info');
            updateDisplay();
        }

        function buyChest(type) {
    const costConfig = [
        { currency: "gold", amount: 100 },
        { currency: "diamond", amount: 10 },
        { currency: "titanium", amount: 1 },
        { currency: "starstone", amount: 1 },
        { currency: "cosmicstone", amount: 1 },
        { currency: "superstone", amount: 1 }, 
        { currency: "otherworldstone", amount: 1 }, 
        { currency: "xingjiestone", amount: 1 },
        { currency: "hundunstone", amount: 1 },
        { currency: "lingtone", amount: 1 }, 
        { currency: "huangtone", amount: 1 },
        { currency: "mingtone", amount: 1 }, 
        { currency: "xutong", amount: 1 }, 
        { currency: "shitone", amount: 1 },
        { currency: "weitone", amount: 1 }       
    ][type - 1];

    if (player[costConfig.currency] >= costConfig.amount) {
        player[costConfig.currency] -= costConfig.amount;
        const selectedRarity = selectRarity(type);
        console.log(`购买宝箱类型: ${type}, 掉落装备品质: ${selectedRarity}`); // 调试信息
        handleEquipment(selectedRarity);

        // 更新宝箱购买计数
        const chestType = ['common', 'advanced', 'rare', 'epic', 'legendary', 'chaos', 'apocalypse', 'yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6', 'yeyu7', 'yeyu8'][type - 1];
        player.chestCounts[chestType]++;
        checkChestAchievements(chestType, player.chestCounts[chestType]);
    } else {
        logAction(`${costConfig.currency}不足！无法购买${['普通','高级','稀有','史诗','传说','混沌','终焉','星辰','银河','星云','鸿蒙','太虚', '虚空', '时空', '未来'][type-1]}宝箱`, 'error');
    }
    updateDisplay();
}

        // 检查宝箱成就
        function checkChestAchievements(chestType, count) {
    const achievements = [
        { count: 100, key: `${chestType}_chest_100` },
        { count: 10000, key: `${chestType}_chest_10000` },
        { count: 1000000, key: `${chestType}_chest_1000000` },
        { count: 10000000, key: `${chestType}_chest_10000000` },
        { count: 100000000, key: `${chestType}_chest_100000000` }
    ];

    achievements.forEach(({ count: targetCount, key }) => {
        if (count >= targetCount && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updateAchievementsDisplay();
            }
        }
    });
}

        function buyMaterialChest() {
    const cost = player.materialChestCost;
    if (player.diamond >= cost) {
        player.diamond -= cost;
        const selectedItem = selectMaterialChestItem();
        
        if (selectedItem.type in player.collections) {
            player.collections[selectedItem.type]++;
            onCollectionAdded(selectedItem.type); // 应用效果
            logAction(`获得收藏物：${collectionEffects[selectedItem.type].name}`, 'success');
            updateCollectionDisplay(); // 更新收藏物页面
        } else if (selectedItem.type in player.items) {
            player.items[selectedItem.type]++;
            logAction(`获得道具：${itemEffects[selectedItem.type].name}`, 'success');
            updateItemDisplay(); // 更新道具页面
        }
// 新增：处理VIP能力值道具
        else if (selectedItem.type === 'vipPower') {
            handleVipPowerGain(); // 调用VIP能力值处理函数
        }
        // 更新材料宝箱购买成本
             player.materialChestCost *= 2;
            updateDisplay();
      }   else {
        logAction("钻石不足！无法购买材料宝箱", "error");
    }
}
     function buyTechniqueChest() {
    const cost = player.techniqueChestCost;
    if (player.reincarnationCoin >= cost) {
        player.reincarnationCoin -= cost;
        player.techniqueChestCost *= 2;  // 下次消耗翻倍
        player.techniqueChestLevel++;
        
        // 根据概率随机选择功法
        const roll = Math.random();
        let cumulativeProb = 0;
        
        for (const drop of techniqueChestDrops) {
            cumulativeProb += drop.prob;
            if (roll <= cumulativeProb) {
                addTechnique(drop.id);
                break;
            }
        }
        
        logAction("打开了功法秘笈宝箱！", "success");
        updateDisplay();
    } else {
        logAction("转生币不足！", "error");

    }
}
   // 初始化或重置时调用
function resetAllCollectionEffects() {
    // 重置所有装备的收藏物加成
    player.equipment.forEach(eq => {
        eq.collectionMultiplier = 0;
    });
    
    // 重新应用所有收藏物效果
    applyAllCollectionEffects();
}

// 应用所有收藏物效果
function applyAllCollectionEffects() {
    // 先重置所有效果
    player.equipment.forEach(eq => {
        eq.collectionMultiplier = 0;
    });
    
    // 累加所有收藏物效果
    Object.entries(player.collections).forEach(([type, count]) => {
        if(count > 0) {
            const effect = collectionEffects[type].effect * count;
            player.equipment.forEach(eq => {
                eq.collectionMultiplier += effect;
            });
        }
    });
    
    updateCollectionDisplay();
}

// 获得新收藏物时调用
function onCollectionAdded(collectionType) {
    const effect = collectionEffects[collectionType].effect;
    player.equipment.forEach(eq => {
        eq.collectionMultiplier += effect;
    });
    updateCollectionDisplay();
}


        // 选择材料宝箱掉落物品
        function selectMaterialChestItem() {
            let totalProb = materialChestProbabilities.reduce((sum, p) => sum + p.prob, 0);
            let rand = Math.random() * totalProb;
            for (const { type, prob } of materialChestProbabilities) {
                if (rand < prob) return { type };
                rand -= prob;
            }
            return { type: 'lightSpeedHand' }; // 默认掉落
        }

        function selectRarity(type) {
    const probConfig = chestProbabilities[type];
    let totalProb = probConfig.reduce((sum, p) => sum + p.prob, 0);
    let rand = Math.random() * totalProb;
    for (const { rarity, prob } of probConfig) {
        if (rand < prob) return validateRarity(rarity);
        rand -= prob;
    }
    return 'common';
}

        function handleEquipment(rarity) {
    const existingIndex = player.equipment.findIndex(eq => eq.rarity === rarity);
    if (existingIndex >= 0) {
        upgradeExistingEquipment(existingIndex, rarity);
    } else {
        addNewEquipment(rarity);
    }
    checkAchievement(rarity);
}

        function upgradeExistingEquipment(index, rarity) {
            const eq = player.equipment[index];
            const config = equipmentTypes[rarity];
            eq.level++;
            const vipBonus = 1 + getVipBonus();
            eq.gps = safeNumber(config.gps * (1 + (config.growthRate * eq.level*0.01)) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%
            eq.click = safeNumber(config.click * (1 + (config.growthRate * eq.level*0.01)) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%

        }

        function addNewEquipment(rarity) {
            const config = equipmentTypes[rarity] || equipmentTypes.common;
            const newEq = {
                name: config.name,
                gps: config.gps * (1 + player.reincarnationStats.gpsBonus.level), // 每级装备属性乘以100%
                click: config.click * (1 + player.reincarnationStats.gpsBonus.level), // 每级装备属性乘以100%
                rarity: rarity,
                level: 1 + player.reincarnationStats.equipmentLevelBonus.level * 200, // 转生属性加成
                growthRate: config.growthRate,
                gemMultiplier: 0,
                collectionMultiplier: 0
            };
            player.equipment.push(newEq);
            logAction(`获得 ${newEq.name}装备`, rarity);
        }

        function upgradeEquipment(index) {
            const eq = player.equipment[index];
            const cost = Math.floor(100 * Math.pow(1.5, eq.level));
            if (player.gold >= cost) {
                player.gold -= cost;
                eq.level++;
                const vipBonus = 1 + getVipBonus();
                eq.gps = safeNumber(eq.gps * (1 + eq.growthRate) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%
                eq.click = safeNumber(eq.click * (1 + eq.growthRate) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%
                logAction(`主动升级 ${eq.name}装备 至 Lv.${eq.level}`, eq.rarity);
                updateDisplay();
              updateVipDisplay();
            } else {
                logAction("金币不足！", "error");
            }
        }

        // 自动购买逻辑
       function checkAutoBuy() {
    const speedMultiplier = player.autoBuySpeedBoost ? 100 : 1;
    player.autoBuy.forEach((enabled, index) => {
        if (enabled) {
            const type = index + 1;
            const costConfig = [
                { currency: "gold", amount: 100 },
                { currency: "diamond", amount: 10 },
                { currency: "titanium", amount: 1 },
                { currency: "starstone", amount: 1 },
                { currency: "cosmicstone", amount: 1 },
                { currency: "superstone", amount: 1 },
                { currency: "otherworldstone", amount: 1 },
                { currency: "xingjiestone", amount: 1 },
                { currency: "hundunstone", amount: 1 },
                { currency: "lingtone", amount: 1 },
                { currency: "huangtone", amount: 1 },
                { currency: "mingtone", amount: 1 },
                { currency: "xutong", amount: 1 },
                { currency: "shitone", amount: 1 },
                { currency: "weitone", amount: 1 }              
            ][index];
            
            if (player[costConfig.currency] >= costConfig.amount) {
                // 计算最大可购买数量（最多100个）
                const maxBuy = Math.min(speedMultiplier, 100);
                const affordable = Math.floor(player[costConfig.currency] / costConfig.amount);
                const actualBuy = Math.min(maxBuy, affordable);
                
                if (actualBuy > 0) {
                    // 批量扣除货币
                    player[costConfig.currency] -= actualBuy * costConfig.amount;
                    
                    // 统计装备升级总级数
                    let totalLevelsUp = 0;
                    const chestTypeName = ['普通','高级','稀有','史诗','传说','混沌','终焉','星辰','银河','星云','鸿蒙','太虚', '虚空', '时空', '未来'][index];
                    
                    // 批量处理装备获取并统计升级计数
                    for (let i = 0; i < actualBuy; i++) {
                        const selectedRarity = selectRarity(type);
                        // 临时修改handleEquipment，使其返回升级的级数
                        const levelsUp = handleEquipment(selectedRarity);
                        totalLevelsUp += levelsUp;
                    }
                    
                    // 更新宝箱计数
                    const chestType = ['common', 'advanced', 'rare', 'epic', 'legendary', 'chaos', 'apocalypse', 'yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6', 'yeyu7', 'yeyu8'][index];
                    player.chestCounts[chestType] += actualBuy;
                    checkChestAchievements(chestType, player.chestCounts[chestType]);
                    
                    // 统一记录日志
                    logAction(`自动购买${chestTypeName}宝箱 x${actualBuy},${name}`, 'success');
                    updateDisplay();
                }
            }
        }
    });
if (player.autoBuyTechniqueChest && player.reincarnationCoin >= player.techniqueChestCost) {
       // 检查价格是否超过上限
        if (player.techniqueChestCost <= player.autoBuyTechniqueMaxCost) {
            buyTechniqueChest();
        } else {
            // 可选: 记录日志或通知玩家
           player.autoBuyTechniqueChest = false;
            logAction("功法秘籍宝箱价格超过上限，停止自动购买", "info");
        }
    }

    

    // 新增：自动购买材料宝箱
    if (player.autoBuyMaterialChest && player.diamond >= player.materialChestCost) {
        buyMaterialChest();
    }
}

        // 切换自动购买状态
        function toggleAutoBuy(typeIndex) {
    const index = typeIndex - 1; // 将宝箱类型转换为数组索引
    player.autoBuy[index] = !player.autoBuy[index]; // 切换状态
    const btn = document.getElementById(`autoChest${typeIndex}`);
    btn.textContent = `${['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'][index]}宝箱自动购买：${player.autoBuy[index] ? '开启' : '关闭'}`;
    logAction(`${player.autoBuy[index] ? '开启' : '关闭'}自动购买${['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'][index]}宝箱`, 'info');
}

        // 切换自动购买材料宝箱状态
        function toggleAutoBuyMaterialChest() {
    player.autoBuyMaterialChest = !player.autoBuyMaterialChest;
    const btn = document.getElementById('autoMaterialChest');
    btn.textContent = `材料宝箱自动购买：${player.autoBuyMaterialChest ? '开启' : '关闭'}`;
    logAction(`${player.autoBuyMaterialChest ? '开启' : '关闭'}自动购买材料宝箱`, 'info');
}
  function toggleAutoBuyTechniqueChest() {
    player.autoBuyTechniqueChest = !player.autoBuyTechniqueChest;
    const btn = document.getElementById('autoTechniqueChest');
    btn.textContent = `功法秘籍宝箱自动购买：${player.autoBuyTechniqueChest ? '开启' : '关闭'}`;
    logAction(`${player.autoBuyTechniqueChest ? '开启' : '关闭'}功法秘籍宝箱自动购买`, 'info');
}
     function toggleOnlineBoost() {
    player.onlineBoostEnabled = !player.onlineBoostEnabled;
    const btn = document.getElementById('toggleOnlineBoost');
    btn.textContent = `在线金币加速100倍: ${player.onlineBoostEnabled ? '开启' : '关闭'}`;
    logAction(`${player.onlineBoostEnabled ? '开启' : '关闭'}在线金币100倍加速`, 'info');
}
     function toggleAutoBuySpeedBoost() {
    player.autoBuySpeedBoost = !player.autoBuySpeedBoost;
    const btn = document.getElementById('autoBuySpeedBoost');
    btn.textContent = `在线自动购买100倍数量：${player.autoBuySpeedBoost ? '开启' : '关闭'}`;
    logAction(`${player.autoBuySpeedBoost ? '开启' : '关闭'}在线自动购买100倍数量`, 'info');
}

     // 添加更新自动兑换货币显示的函数
function updateAutoConvertDisplay() {
    const currencies = ['gold', 'diamond', 'titanium', 'starstone', 'cosmicstone', 
                        'superstone', 'otherworldstone', 'xingjiestone', 'hundunstone', 
                        'lingtone', 'huangtone', 'mingtone', 'xutong', 'shitone', 'weitone'];
    
    currencies.forEach(currency => {
        const btn = document.getElementById(`autoConvert${currency.charAt(0).toUpperCase() + currency.slice(1)}`);
        if (btn) {
            btn.textContent = `${getCurrencyName(currency)}自动兑换：${player.autoConvertCurrency[currency] ? '开启' : '关闭'}`;
        }
    });
}

// 辅助函数：获取货币中文名称
function getCurrencyName(currency) {
    const names = {
        gold: '金币',
        diamond: '钻石',
        titanium: '钛晶石',
        starstone: '星耀石',
        cosmicstone: '宇宙石',
        superstone: '超能石',
        otherworldstone: '异界石',
        xingjiestone: '星界石',
        hundunstone: '混沌石',
        lingtone: '灵髓石',
        huangtone: '幻空石',
        mingtone: '冥源石',
        xutong: '虚空石',
        shitone: '时空石',
        weitone: '未来石'      
    };
    return names[currency] || currency;
}

// 修改切换函数，确保更新显示
function toggleAutoConvertCurrency(currency) {
    player.autoConvertCurrency[currency] = !player.autoConvertCurrency[currency];
    
    // 更新按钮显示
    const btn = document.getElementById(`autoConvert${currency.charAt(0).toUpperCase() + currency.slice(1)}`);
    if (btn) {
        btn.textContent = `${getCurrencyName(currency)}自动兑换：${player.autoConvertCurrency[currency] ? '开启' : '关闭'}`;
    }
    
    logAction(`${getCurrencyName(currency)}自动兑换${player.autoConvertCurrency[currency] ? '开启' : '关闭'}`, 'info');
}
        // 成就检查
        function checkAchievement(rarity) {
    if (!player.achievements[rarity]) {
        player.achievements[rarity] = true;
        const reward = achievementRewards[rarity];
        if (reward) {
            player.gpsMultiplier += reward.gpsMultiplier;
            logAction(`成就达成：获得${equipmentTypes[rarity].name}装备，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
            updateAchievementsDisplay();
        }
    }
}

        // 更新成就显示
       function updateAchievementsDisplay() {
    const achievementsContainer = document.getElementById('achievements');
    const unlockedAchievements = Object.entries(player.achievements)
        .filter(([key, unlocked]) => unlocked)
        .map(([key]) => key);

    // 定义排序优先级
    const achievementOrder = [
     'common', 'rare', 'epic', 'legendary',
     'ancient', 'divine', 'arcane', 'celestial',
     'infernal', 'astral', 'primeval', 'transcendental',
     'quantum', 'ultimate', 'chaos', 'eternal',
     'void', 'genesis', 'divineRealm', 'apocalypse', 'yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6','yeyu7', 'yeyu8', 'yeyu9', 'yeyu10', 'yeyu11', 'yeyu12','yeyu13', 'yeyu14', 'yeyu15', 'yeyu16', 'yeyu17', 'yeyu18','yeyu19', 'yeyu20', 'yeyu21', 'yeyu22', 'yeyu23', 'yeyu24', 
    'common_chest_100',
    'common_chest_10000',
    'common_chest_1000000',
    'common_chest_10000000',
    'common_chest_100000000',
    'advanced_chest_100',
    'advanced_chest_10000',
    'advanced_chest_1000000',
    'advanced_chest_10000000',
    'advanced_chest_100000000',
    'rare_chest_100',
    'rare_chest_10000',
    'rare_chest_1000000',
    'rare_chest_10000000',
    'rare_chest_100000000',
    'epic_chest_100',
    'epic_chest_10000',
    'epic_chest_1000000',
    'epic_chest_10000000',
    'epic_chest_100000000',
    'legendary_chest_100',
    'legendary_chest_10000',
    'legendary_chest_1000000',
    'legendary_chest_10000000',
    'legendary_chest_100000000',
    'chaos_chest_100',
    'chaos_chest_10000',
    'chaos_chest_1000000',
    'chaos_chest_10000000',
    'chaos_chest_100000000',
    'apocalypse_chest_100',
    'apocalypse_chest_10000',
    'apocalypse_chest_1000000',
    'apocalypse_chest_10000000',
    'apocalypse_chest_100000000',
    'yeyu1_chest_100',
    'yeyu1_chest_10000',
    'yeyu1_chest_1000000',
    'yeyu1_chest_10000000',
    'yeyu1_chest_100000000',
    'yeyu2_chest_100',
    'yeyu2_chest_10000',
    'yeyu2_chest_1000000',
    'yeyu2_chest_10000000',
    'yeyu2_chest_100000000',
    'yeyu3_chest_100',
    'yeyu3_chest_10000',
    'yeyu3_chest_1000000',
    'yeyu3_chest_10000000',
    'yeyu3_chest_100000000',
    'yeyu4_chest_100',
    'yeyu4_chest_10000',
    'yeyu4_chest_1000000',
    'yeyu4_chest_10000000',
    'yeyu4_chest_100000000',
    'yeyu5_chest_100',
    'yeyu5_chest_10000',
    'yeyu5_chest_1000000',
    'yeyu5_chest_10000000',
    'yeyu5_chest_100000000',
    'yeyu6_chest_100',
    'yeyu6_chest_10000',
    'yeyu6_chest_1000000',
    'yeyu6_chest_10000000',
    'yeyu6_chest_100000000',
    'yeyu7_chest_100',
    'yeyu7_chest_10000',
    'yeyu7_chest_1000000',
    'yeyu7_chest_10000000',
    'yeyu7_chest_100000000',
    'yeyu8_chest_100',
    'yeyu8_chest_10000',
    'yeyu8_chest_1000000',
    'yeyu8_chest_10000000',
    'yeyu8_chest_100000000',
  'max_stage_10', 'max_stage_30', 'max_stage_60', 'max_stage_90',
   'max_stage_120', 'max_stage_200', 'max_stage_300', 'max_stage_400',
   'max_stage_500', 'max_stage_600', 'max_stage_700', 'max_stage_800',
   'max_stage_900', 'max_stage_1000',
 'thunderKirin_10',
    'thunderKirin_50',
    'thunderKirin_100',
    'chaosTaotie_10',
    'chaosTaotie_50',
    'chaosTaotie_100',
    'netherQiongqi_10',
    'netherQiongqi_50',
    'netherQiongqi_100',
    'abyssKun_10',
    'abyssKun_50',
    'abyssKun_100',
    'primordialZhuLong_10',
    'primordialZhuLong_50',
    'primordialZhuLong_100',
    'wanJunSuanNi_10',
    'wanJunSuanNi_50',
    'wanJunSuanNi_100',
    'yanYuBiAn_10',
    'yanYuBiAn_50',
    'yanYuBiAn_100',
    'yuyu1_10',
    'yuyu1_50',
    'yuyu1_100',
    'yuyu2_10',
    'yuyu2_50',
    'yuyu2_100',
    'yuyu3_10',
    'yuyu3_50',
    'yuyu3_100',
    'yuyu4_10',
    'yuyu4_50',
    'yuyu4_100',
    'yuyu5_10',
    'yuyu5_50',
    'yuyu5_100',
    'yuyu6_10',
    'yuyu6_50',
    'yuyu6_100',
    'yuyu7_10',
    'yuyu7_50',
    'yuyu7_100',
    'yuyu8_10',
    'yuyu8_50',
    'yuyu8_100',
     'year1_10',
    'year10_10',
    'year100_10',
    'year1000_10',
    'year10000_10',
    'year100000_10',
    'year1000000_10',
    'year10000000_10',
    'year100000000_10',
    'year1_100',
    'year10_100',
    'year100_100',
    'year1000_100',
    'year10000_100',
    'year100000_100',
    'year1000000_100',
    'year10000000_100',
    'year100000000_100',
    'year1_1000',
    'year10_1000',
    'year100_1000',
    'year1000_1000',
    'year10000_1000',
    'year100000_1000',
    'year1000000_1000',
    'year10000000_1000',
    'year100000000_1000',
    'year1_10000',
    'year10_10000',
    'year100_10000',
    'year1000_10000',
    'year10000_10000',
    'year100000_10000',
    'year1000000_10000',
    'year10000000_10000',
    'year100000000_10000',
    'year2_10',
    'year2_100',
    'year2_1000',
    'year2_10000',
    'year3_10',
    'year3_100',
    'year3_1000',
    'year3_10000',
    'year4_10',
    'year4_100',
    'year4_1000',
    'year4_10000',
    'year5_10',
    'year5_100',
    'year5_1000',
    'year5_10000',
    'year6_10',
    'year6_100',
    'year6_1000',
    'year6_10000',
    'year7_10',
    'year7_100',
    'year7_1000',
    'year7_10000',
    'year8_10',
    'year8_100',
    'year8_1000',
    'year8_10000',
    'year9_10',
    'year9_100',
    'year9_1000',
    'year9_10000',
    'year11_10',
    'year11_100',
    'year11_1000',
    'year11_10000',
    'year12_10',
    'year12_100',
    'year12_1000',
    'year12_10000',
    'year13_10',
    'year13_100',
    'year13_1000',
    'year13_10000',
    'year14_10',
    'year14_100',
    'year14_1000',
    'year14_10000',
    'year15_10',
    'year15_100',
    'year15_1000',
    'year15_10000',
    'year16_10',
    'year16_100',
    'year16_1000',
    'year16_10000',
    'year17_10',
    'year17_100',
    'year17_1000',
    'year17_10000',
    'year18_10',
    'year18_100',
    'year18_1000',
    'year18_10000',
    'year19_10',
    'year19_100',
    'year19_1000',
    'year19_10000',
    'year20_10',
    'year20_100',
    'year20_1000',
    'year20_10000',
    'year21_10',
    'year21_100',
    'year21_1000',
    'year21_10000',
    'year22_10',
    'year22_100',
    'year22_1000',
    'year22_10000',
    'year23_10',
    'year23_100',
    'year23_1000',
    'year23_10000',
    'year24_10',
    'year24_100',
    'year24_1000',
    'year24_10000',
    'year25_10',
    'year25_100',
    'year25_1000',
    'year25_10000',
    'year26_10',
    'year26_100',
    'year26_1000',
    'year26_10000',
    'year27_10',
    'year27_100',
    'year27_1000',
    'year27_10000',
    'year28_10',
    'year28_100',
    'year28_1000',
    'year28_10000',
    'year29_10',
    'year29_100',
    'year29_1000',
    'year29_10000',
    'year30_10',
    'year30_100',
    'year30_1000',
    'year30_10000',
    'year31_10',
    'year31_100',
    'year31_1000',
    'year31_10000',
    'year32_10',
    'year32_100',
    'year32_1000',
    'year32_10000',
    'year33_10',
    'year33_100',
    'year33_1000',
    'year33_10000',
    'year34_10',
    'year34_100',
    'year34_1000',
    'year34_10000',
    'year35_10',
    'year35_100',
    'year35_1000',
    'year35_10000',
    'year36_10',
    'year36_100',
    'year36_1000',
    'year36_10000',
    'year37_10',
    'year37_100',
    'year37_1000',
    'year37_10000',
   'reincarnation_10', 'reincarnation_100', 
   'reincarnation_1000', 'reincarnation_10000', 'world_boss_1st', 'world_boss_top5', 'world_boss_top10', 'world_boss_participant'
    ];

    // 按定义顺序过滤并排序已解锁成就
    const sortedAchievements = achievementOrder
        .filter(key => unlockedAchievements.includes(key))
        .map(key => ({
            key,
            ...achievementRewards[key]
        }));

    achievementsContainer.innerHTML = Object.entries(player.achievements)
        .filter(([key, value]) => value && achievementRewards[key]) // 只显示已解锁的成就
        .map(([key, value]) => {
            const reward = achievementRewards[key];
            return `<div class="achievement unlocked">${reward.description}</div>`;
        })
        .join('');
}

        // 切换装备、道具和收藏物页面
        function switchTab(tab) {
            document.getElementById('equipmentList').style.display = tab === 'equipment' ? 'block' : 'none';
            document.getElementById('itemList').style.display = tab === 'items' ? 'block' : 'none';
            document.getElementById('collectionList').style.display = tab === 'collections' ? 'block' : 'none';
            document.getElementById('reincarnationList').style.display = tab === 'reincarnation' ? 'block' : 'none';
            document.getElementById('petList').style.display = tab === 'pets' ? 'block' : 'none';
            document.getElementById('stockList').style.display = tab === 'stocks' ? 'block' : 'none';
            document.getElementById('lotteryList').style.display = tab === 'lottery' ? 'block' : 'none';
            document.getElementById('bankList').style.display = tab === 'bank' ? 'block' : 'none';
            document.getElementById('dungeonEquipmentList').style.display = tab === 'dungeonEquipment' ? 'block' : 'none'; // 新增副本装备页面
            document.getElementById('soulRingList').style.display = tab === 'soulRings' ? 'block' : 'none'; // 新增魂环页面
            document.getElementById('playerAttributesList').style.display = tab === 'playerAttributes' ? 'block' : 'none';
            document.getElementById('techniquesList').style.display = tab === 'techniques' ? 'block' : 'none';
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tab}')"]`).classList.add('active');
            if (tab === 'items') updateItemDisplay();
            if (tab === 'collections') updateCollectionDisplay();
            if (tab === 'reincarnation') updateReincarnationDisplay();
            if (tab === 'pets') updatePetDisplay();
            if (tab === 'stocks') updateStockDisplay();
            if (tab === 'bank') updateBankDisplay();
            if (tab === 'dungeonEquipment') updateDungeonEquipmentDisplay(); // 新增：更新副本装备显示
            if (tab === 'soulRings') updateSoulRingDisplay(); // 新增：更新魂环显示
            if (tab === 'techniques') updateTechniquesDisplay();
            if (tab === 'playerAttributes') updatePlayerAttributesDisplay();
        }

        // 更新道具显示
        function updateItemDisplay() {
            const itemContainer = document.getElementById('itemList');
            itemContainer.innerHTML = Object.entries(player.items)
                .map(([key, value]) => {
                    const item = itemEffects[key];
                    return `<div>${item.name}: ${value} - ${item.description}</div>`;
                })
                .join('');
        }

       // 重置收藏物显示
function resetCollectionDisplay() {
resetCollectionEffects();
    logAction("已完全重置收藏物效果计算", "success");
}
    // 重新计算所有收藏物效果（确保加法叠加）
    Object.keys(player.collections).forEach(collectionType => {
        const effect = collectionEffects[collectionType].effect;
        const count = player.collections[collectionType];
        const totalEffect = count * effect;
        
        player.equipment.forEach(eq => {
            eq.collectionMultiplier = totalEffect;
        });
    });
    
    updateCollectionDisplay();
    logAction("已重置收藏物效果计算", "info");

// 更新后的收藏物显示函数
function updateCollectionDisplay() {
    const container = document.getElementById("collectionInfoContainer");
    
    // 计算全部收藏物总加成
    const totalEffect = player.equipment.length > 0 ? 
        player.equipment[0].collectionMultiplier * 100 : 0;
    
    // 顶部总加成显示（保持不变）
    container.innerHTML = `
        <div style="margin-bottom: 15px; font-weight: bold;">
            当前全部收藏物总加成: +${totalEffect.toFixed(5)}%
        </div>
    `;
    
    // 每个收藏物的详细显示（增加总效果）
    container.innerHTML += Object.entries(player.collections)
        .map(([key, value]) => {
            const collection = collectionEffects[key];
            const singleEffect = collection.effect * 100;
            const totalEffect = value * singleEffect;
            
            return `
                <div style="margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #eee;">
                    <strong>${collection.name}</strong>: 
                    <span>数量: ${value}</span> | 
                    <span>单个效果: +${singleEffect.toFixed(5)}%</span> |
                    <span>总效果: +${totalEffect.toFixed(5)}%</span>
                    <div style="color:#666; font-size:0.9em; margin-top: 3px;">${collection.description}</div>
                </div>
            `;
        })
        .join('');
}
        // 更新转生属性显示
        function updateReincarnationDisplay() {
    const reincarnationContainer = document.getElementById('reincarnationList');
    reincarnationContainer.innerHTML = `
        <div>
            <h3>转生属性</h3>
            <div>
                <strong>收益加成</strong>: 每级装备属性 +${player.reincarnationStats.gpsBonus.level * 100}% (等级: ${player.reincarnationStats.gpsBonus.level})
                <button onclick="upgradeReincarnationStat('gpsBonus')">升级 (消耗 ${player.reincarnationStats.gpsBonus.cost.toFixed(0)} 转生币)</button>
            </div>
            <div>
                <strong>装备等级</strong>: 全部装备初始等级 +${player.reincarnationStats.equipmentLevelBonus.level * 200} 级 (等级: ${player.reincarnationStats.equipmentLevelBonus.level})
                <button onclick="upgradeReincarnationStat('equipmentLevelBonus')">升级 (消耗 ${player.reincarnationStats.equipmentLevelBonus.cost.toFixed(0)} 转生币)</button>
            </div>
            <div>
                <strong>点击上限</strong>: 每秒点击上限 +${player.reincarnationStats.clickLimitBonus.level} 次 (等级: ${player.reincarnationStats.clickLimitBonus.level})
                <button onclick="upgradeReincarnationStat('clickLimitBonus')">升级 (消耗 ${player.reincarnationStats.clickLimitBonus.cost.toFixed(0)} 转生币)</button>
            </div>
        </div>
    `;
}
   function updateTechniquesDisplay() {
    const container = document.getElementById('techniquesContainer');
    
    // 按预定顺序筛选已获得的功法
    const sortedTechniques = TECHNIQUE_DISPLAY_ORDER
        .filter(id => player.techniques[id])
        .map(id => {
            const tech = techniqueConfig[id];
            return {
                id,
                name: tech.name,
                level: player.techniques[id],
                description: tech.description,
                effect: tech.effect,
                type: tech.type
            };
        });

    // 生成HTML
    container.innerHTML = sortedTechniques.map(tech => `
        <div class="technique ${tech.type}">
            <h4>${tech.name} [Lv.${tech.level}]</h4>
            <p>${tech.description}</p>
            <div class="tech-effect">
                当前效果: ${
                    tech.type === 'multiAttack' 
                        ? `攻击次数+${tech.level * tech.effect}`
                        : `${(tech.level * tech.effect * 100).toFixed(tech.type === 'critRate' ? 4 : 4)}%`
                }
            </div>
        </div>
    `).join('');
}

// 添加功法秘笈获取函数
function addTechnique(type) {
    if (player.techniques[type]) {
        player.techniques[type]++;
    } else {
        player.techniques[type] = 1;
    }
    logAction(`获得功法: ${techniqueConfig[type].name} Lv.${player.techniques[type]}`, 'success');
    updateTechniqueBonuses(); // 新增调用
    updateTechniquesDisplay();
}

function calculateTechniqueBonuses() {
    const bonuses = {
        health: 0,
        attack: 0,
        critRate: 0,
        critDamage: 0,
        multiAttack: 0
    };

    // 计算所有功法加成
    Object.entries(player.techniques).forEach(([techId, level]) => {
        const tech = techniqueConfig[techId];
        if (tech && tech.effect) {
            // 获取宗门功法等级加成
            const sectLevel = player.sect.techniques[techId] || 0;
            const sectMultiplier = 1 + (sectLevel * 2); // 每级增加2倍效果
            
            // 应用宗门加成
            bonuses[tech.type] += level * tech.effect * sectMultiplier;
        }
    });

    return bonuses;
}
        // 重置宠物页面
function resetPetDisplay() {
    // 保留宠物的等级和升级成本
    const petData = {};
    Object.keys(player.pets).forEach(petKey => {
        petData[petKey] = {
            level: player.pets[petKey].level, // 保留等级
            cost: player.pets[petKey].cost    // 保留升级成本
        };
    });

    // 重置宠物页面（重新生成宠物数据）
    player.pets = {
        thunderKirin: { level: petData.thunderKirin?.level || 0, cost: petData.thunderKirin?.cost || 1, multiplier: 0.10 },
        chaosTaotie: { level: petData.chaosTaotie?.level || 0, cost: petData.chaosTaotie?.cost || 1, multiplier: 0.30 },
        netherQiongqi: { level: petData.netherQiongqi?.level || 0, cost: petData.netherQiongqi?.cost || 1, multiplier: 0.90 },
        abyssKun: { level: petData.abyssKun?.level || 0, cost: petData.abyssKun?.cost || 1, multiplier: 2.70 },
        primordialZhuLong: { level: petData.primordialZhuLong?.level || 0, cost: petData.primordialZhuLong?.cost || 1, multiplier: 8.10 },
        wanJunSuanNi: { level: petData.wanJunSuanNi?.level || 0, cost: petData.wanJunSuanNi?.cost || 1, multiplier: 24.30 },
        yanYuBiAn: { level: petData.yanYuBiAn?.level || 0, cost: petData.yanYuBiAn?.cost || 1, multiplier: 72.90 },
       yuyu1: { level: petData.yuyu1?.level || 0, cost: petData.yuyu1?.cost || 1, multiplier: 218.70 },
        yuyu2: { level: petData.yuyu2?.level || 0, cost: petData.yuyu2?.cost || 1, multiplier: 656.10 },
       yuyu3: { level: petData.yuyu3?.level || 0, cost: petData.yuyu3?.cost || 1, multiplier: 1968.30 },
        yuyu4: { level: petData.yuyu4?.level || 0, cost: petData.yuyu4?.cost || 1, multiplier: 5904.90 },
       yuyu5: { level: petData.yuyu5?.level || 0, cost: petData.yuyu5?.cost || 1, multiplier: 17714.70 },
       yuyu6: { level: petData.yuyu6?.level || 0, cost: petData.yuyu6?.cost || 1, multiplier: 53144.10 },
        yuyu7: { level: petData.yuyu7?.level || 0, cost: petData.yuyu7?.cost || 1, multiplier: 159432.30 },
       yuyu8: { level: petData.yuyu8?.level || 0, cost: petData.yuyu8?.cost || 1, multiplier: 478296.90 }
    };

    // 更新宠物页面显示
    updatePetDisplay();
    logAction('宠物页面已重置，等级和升级消耗保留', 'success');
}

// 更新宠物页面显示
function updatePetDisplay() {
    const petContainer = document.getElementById('petContainer');
    if (!petContainer) {
        console.error('宠物容器未找到！');
        return;
    }
    
    // 货币类型到中文名称的映射
    const currencyNames = {
        gold: '金币',
        diamond: '钻石',
        titanium: '钛晶石',
        starstone: '星耀石',
        cosmicstone: '宇宙石',
        superstone: '超能石',
        otherworldstone: '异界石',
        xingjiestone: '星界石',
        hundunstone: '混沌石',
        lingtone: '灵髓石',
        huangtone: '幻空石',
        mingtone: '冥源石',
        xutong: '虚空石',
        shitone: '时空石',
        weitone: '未来石'  
    };
    
    petContainer.innerHTML = Object.entries(player.pets)
        .map(([key, pet]) => {
            const config = petConfig[key];
            if (!config) {
                console.error(`宠物配置未找到：${key}`);
                return '';
            }
            const cost = pet.cost;
            const formattedCost = cost >= 1e8 ? cost.toExponential(3) : cost.toLocaleString();
            
            // 获取货币中文名称
            const currencyName = currencyNames[config.currency] || config.currency;
            
            return `
                <div>
                    <strong>${config.name}</strong>: 等级 ${pet.level} - 装备属性加成 ${(pet.level * pet.multiplier * 100).toFixed(2)}%
                    <button onclick="upgradePet('${key}')">升级 (消耗 ${formattedCost} ${currencyName})</button>
                </div>
            `;
        })
        .join('');
}
    // 如果需要真正的重置功能（保留等级但刷新效果），可以添加这个函数
function resetTechniquesData() {
    showCustomConfirm('确定要重置功法数据吗？这将保留等级但重置所有效果计算！', (confirmed) => {
        if (confirmed) {
            // 重新计算所有功法效果
            updateTechniqueBonuses();
            updateTechniquesDisplay();
            logAction('功法数据已重置，效果重新计算', 'success');
        }
    });
}






   // 重置道具页面
function resetItemDisplay() {
    // 保留道具的数量
    const itemCounts = { ...player.items }; // 复制当前道具数量

    // 重置道具页面（重新生成道具数据）
    player.items = {
        primaryGem: itemCounts.primaryGem || 0,
        advancedGem: itemCounts.advancedGem || 0,
        superiorGem: itemCounts.superiorGem || 0,
        divineGem: itemCounts.divineGem || 0,
        vipPower: itemCounts.vipPower || 0,
        refineStone: itemCounts.refineStone || 0,
        rose: itemCounts.rose || 0,
        companionKey: itemCounts.companionKey || 0,
         rebornDan: itemCounts.rebornDan || 0,
      baitCount: itemCounts.baitCount || 0,
   rootDetector: itemCounts.rootDetector || 0,
 bloodlineDetector: itemCounts.bloodlineDetector || 0,
 advanceStone: itemCounts.advanceStone || 0, 
 primaryGemq: itemCounts.primaryGemq || 0, 
  zongmen: itemCounts.zongmen || 0, 
roseq: itemCounts.roseq || 0,
 yuzhou1: itemCounts.yuzhou1 || 0, 
  yuzhou2: itemCounts.yuzhou2 || 0, 
  yuzhou3: itemCounts.yuzhou3 || 0, 
  yuzhou4: itemCounts.yuzhou4 || 0,
  banlv1: itemCounts.banlv1 || 0,
  banlv2: itemCounts.banlv2 || 0,
  banlv3: itemCounts.banlv3 || 0,
  banlv4: itemCounts.banlv4 || 0,
  banlv5: itemCounts.banlv5 || 0,
  banlv6: itemCounts.banlv6 || 0,
  banlv7: itemCounts.banlv7 || 0,
  banlv8: itemCounts.banlv8 || 0,
  banlv9: itemCounts.banlv9 || 0,
  zhiye1: itemCounts.zhiye1 || 0,
  chiban1: itemCounts.chiban1 || 0,
  zuoqi1: itemCounts.zuoqi1 || 0,
  fuben1: itemCounts.fuben1 || 0,
  shenshou1: itemCounts.shenshou1 || 0,
 fuwen1: itemCounts.fuwen1 || 0,
  fuben2: itemCounts.fuben2 || 0
    };

    // 更新道具页面显示
    updateItemDisplay();
    logAction('道具页面已重置，道具数量保留', 'success');
}

// 更新道具页面显示
function updateItemDisplay() {
    const itemContainer = document.getElementById('itemContainer');
    if (!itemContainer) {
        console.error('道具容器未找到！');
        return;
    }
    itemContainer.innerHTML = Object.entries(player.items)
        .map(([key, value]) => {
            const item = itemEffects[key];
            if (!item) {
                console.error(`道具配置未找到：${key}`);
                return '';
            }
            return `
                <div>
                    <strong>${item.name}</strong>: ${value} - ${item.description}
                </div>
            `;
        })
        .join('');
}
 window.onload = function() {
    loadSave();
      // 执行重置函数
    resetItemDisplay();
    resetPetDisplay();
    updateExplorationUI();
   updateDimensionUI();
    // 恢复自动扫荡状态显示
    document.getElementById('autoSweepStatus').textContent = 
        player.battle.autoSweepEnabled ? '开' : '关';
    
    // 如果自动扫荡是开启状态，重新启动
    if (player.battle.autoSweepEnabled) {
        startAutoSweep();
    }
};
        // 更新股票显示
        function updateStockDisplay() {
    const container = document.getElementById('stocksContainer');
    container.innerHTML = player.stockData.stocks.map((stock, index) => `
        <div class="stock-item" data-index="${index}" onclick="this.parentNode.querySelectorAll('.stock-item').forEach(e=>e.classList.remove('selected'));this.classList.add('selected')">
            <strong>${stock.name}</strong><br>
            当前价: ${stock.currentPrice.toFixed(2)} | 涨跌幅: ${((stock.currentPrice / stock.lastPrice - 1) * 100).toFixed(2)}%<br>
            持有: ${stock.shares}股 | 均价: ${stock.avgCost.toFixed(2)}<br>
            市值: ${(stock.shares * stock.currentPrice).toFixed(2)} | 收益率: ${stock.avgCost ? ((stock.currentPrice / stock.avgCost - 1) * 100).toFixed(2) + '%' : '-'}
        </div>
    `).join('');
}
document.getElementById('announcementToggle').addEventListener('click', function() {
    const announcementPanel = document.getElementById('gameLogPage5');
    // 切换显示状态
    announcementPanel.style.display = announcementPanel.style.display === 'none' ? 'block' : 'none';
    // 切换按钮文本箭头方向
    this.textContent = announcementPanel.style.display === 'block' ? '点击关闭新手必看↑' : '点击呼出新手必看↓';
});
document.getElementById('announcementToggle1').addEventListener('click', function() {
    const announcementPanel = document.getElementById('gameLogPage4');
    // 切换显示状态
    announcementPanel.style.display = announcementPanel.style.display === 'none' ? 'block' : 'none';
    // 切换按钮文本箭头方向
    this.textContent = announcementPanel.style.display === 'block' ? '点击关闭更新日志↑' : '点击呼出更新日志↓';
});
        // 升级宠物
        function upgradePet(petKey) {
    const pet = player.pets[petKey];
    const config = petConfig[petKey];
    if (player[config.currency] >= pet.cost) {
        player[config.currency] -= pet.cost;
        pet.level++;
        pet.cost *= 2; // 每次升级成本翻倍

        // 检查宠物成就
        checkPetAchievements(petKey, pet.level);

        logAction(`升级 ${config.name} 成功！`, 'success');
        updatePetDisplay();
        updateDisplay();
    } else {
        logAction(`${config.currency}不足！`, "error");
    }
}

function checkPetAchievements(petKey, level) {
    const achievements = [
        { level: 10, key: `${petKey}_10` },
        { level: 50, key: `${petKey}_50` },
        { level: 100, key: `${petKey}_100` },
    ];

    achievements.forEach(({ level: targetLevel, key }) => {
        if (level >= targetLevel && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updateAchievementsDisplay();
            }
        }
    });
}

        // 升级转生属性
        function upgradeReincarnationStat(stat) {
            const statData = player.reincarnationStats[stat];
            if (player.reincarnationCoin >= statData.cost) {
                player.reincarnationCoin -= statData.cost;
                statData.level++;
                if (stat === 'equipmentLevelBonus') {
                    statData.cost *= 5; // 装备等级加成每次升级消耗增加5倍
                } else {
                    statData.cost *= 1.2; // 其他属性每次升级消耗增加20%
                }
                logAction(`升级 ${stat} 成功！`, 'success');
                updateReincarnationDisplay();
                updateDisplay();
            } else {
                logAction("转生币不足！", "error");
            }
        }

function resetGemEffects() {
    player.equipment.forEach(eq => {
        eq.gemMultiplier = 0;
    });
    logAction("已重置所有宝石效果", "info");
    updateDisplay();
}
        // 使用宝石升级装备
        function useGem(index, gemType) {
    const eq = player.equipment[index];
    const gem = itemEffects[gemType];
    
    if (player.items[gemType] > 0) {
        player.items[gemType]--;
        // 改为加法叠加
        eq.gemMultiplier += gem.effect;
        
        logAction(`使用${gem.name}升级 ${eq.name}装备 (当前加成: +${(eq.gemMultiplier * 100).toFixed(2)}%)`, 'success');
        updateDisplay();
    } else {
        logAction(`${gem.name}不足！`, "error");
    }
}
// 新增一键使用宝石函数
function useAllGems(index, gemType) {
    const eq = player.equipment[index];
    const gem = itemEffects[gemType];
    const count = player.items[gemType];
    
    if (count > 0) {
        // 计算总加成
        const totalEffect = gem.effect * count;
        // 减少宝石数量
        player.items[gemType] = 0;
        // 增加装备宝石加成
        eq.gemMultiplier += totalEffect;
        
        logAction(`一键使用${count}个${gem.name}升级 ${eq.name}装备 (当前总加成: +${(eq.gemMultiplier * 100).toFixed(2)}%)`, 'success');
        updateDisplay();
    } else {
        logAction(`${gem.name}不足！`, "error");
    }
}
        // 股票价格波动函数
        function updateStockPrices() {
            const now = Date.now();
            const elapsed = now - player.stockData.lastStockUpdate;
            const intervals = Math.floor(elapsed / (10 * 60 * 1000));

            player.stockData.stocks.forEach(stock => {
                for (let i = 0; i < intervals; i++) {
                    stock.lastPrice = stock.currentPrice;

                    // 计算当前价格与初始价格的比例
                    const priceRatio = stock.currentPrice / stock.basePrice;

                    // 根据比例动态调整涨跌概率
                    let riseProbability; // 涨的概率
                    if (priceRatio <= 0.7) {
                        riseProbability = 0.8; 
                    } else if (priceRatio <= 0.8) {
                        riseProbability = 0.7; 
                    } else if (priceRatio <= 0.9) {
                        riseProbability = 0.6; 
                    } else if (priceRatio >= 1.6) {
                        riseProbability = 0.35; 
                    } else if (priceRatio >= 1.8) {
                        riseProbability = 0.25; 
                    } else if (priceRatio >= 2.0) {
                        riseProbability = 0.1; 
                    } else {
                        riseProbability = 0.5;
                    }

                    // 根据涨跌概率决定价格波动
                    const willRise = Math.random() < riseProbability; // 是否上涨
                    const fluctuation = willRise ? Math.random() * 0.1 : -Math.random() * 0.1; // 涨跌幅度
                    stock.currentPrice *= 1 + fluctuation;

                    // 价格保护机制
                    const minPrice = stock.basePrice * 0.3;
                    if (stock.currentPrice < minPrice) stock.currentPrice = minPrice;
                }
            });
            player.stockData.lastStockUpdate = now - (elapsed % (10 * 60 * 1000));
        }

        // 股票购买逻辑
        function buyStock() {
            const amount = parseInt(document.getElementById('stockAmount').value) || 0;
            const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
            
            if(selectedIndex === undefined || amount < 1) {
                logAction("请先选择股票并输入有效数量", "error");
                return;
            }

            const stock = player.stockData.stocks[selectedIndex];
            const totalCost = stock.currentPrice * amount;
            
            if(player.reincarnationCoin >= totalCost) {
                player.reincarnationCoin -= totalCost;
                const totalShares = stock.shares + amount;
                stock.avgCost = (stock.avgCost * stock.shares + totalCost) / totalShares;
                stock.shares += amount;
                logAction(`成功购买${stock.name} ${amount}股`, "success");
            } else {
                logAction("转生币不足！", "error");
            }
            updateStockDisplay();
        }

        // 股票出售逻辑
        function sellStock() {
            const amount = parseInt(document.getElementById('stockAmount').value) || 0;
            const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
            
            if(selectedIndex === undefined || amount < 1) {
                logAction("请先选择股票并输入有效数量", "error");
                return;
            }

            const stock = player.stockData.stocks[selectedIndex];
            if(stock.shares < amount) {
                logAction("持有份额不足！", "error");
                return;
            }

            const totalValue = stock.currentPrice * amount;
            player.reincarnationCoin += totalValue;
            stock.shares -= amount;
            logAction(`成功出售${stock.name} ${amount}股`, "success");
            
            if(stock.shares === 0) stock.avgCost = 0;
            updateStockDisplay();
        }
      // 购买所有股票
function buyAllStock() {
    const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
    if (selectedIndex === undefined) {
        logAction("请先选择股票", "error");
        return;
    }

    const stock = player.stockData.stocks[selectedIndex];
    const maxShares = Math.floor(player.reincarnationCoin / stock.currentPrice);

    if (maxShares > 0) {
        const totalCost = stock.currentPrice * maxShares;
        player.reincarnationCoin -= totalCost;
        const totalShares = stock.shares + maxShares;
        stock.avgCost = (stock.avgCost * stock.shares + totalCost) / totalShares;
        stock.shares += maxShares;
        logAction(`成功购买${stock.name} ${maxShares}股`, "success");
    } else {
        logAction("转生币不足，无法购买任何股票", "error");
    }
    updateStockDisplay();
}

// 出售所有股票
function sellAllStock() {
    const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
    if (selectedIndex === undefined) {
        logAction("请先选择股票", "error");
        return;
    }

    const stock = player.stockData.stocks[selectedIndex];
    if (stock.shares <= 0) {
        logAction("没有持有该股票", "error");
        return;
    }

    const totalValue = stock.currentPrice * stock.shares;
    player.reincarnationCoin += totalValue;
    logAction(`成功出售${stock.name} ${stock.shares}股`, "success");
    stock.shares = 0;
    stock.avgCost = 0;
    updateStockDisplay();
}

        // 购买传统数字彩票
     function buyTraditionalLottery() {
    if (player.traditionalLotteryBought) {
        logAction("您已购买过传统数字彩票，需等待开奖后才能重新购买。", "error");
        return;
    }

    if (player.reincarnationCoin >= 10) {
        player.reincarnationCoin -= 10;
        const numbers = generateTraditionalLotteryNumbers();
        player.traditionalLotteryNumbers = numbers;
        player.traditionalLotteryBought = true; // 设置购买标记
         player.traditionalLotteryDrawTime = Date.now() + 30 * 60 * 1000;
        updateTraditionalLotteryDisplay();
        logAction(`购买了传统数字彩票，号码为：${numbers.join(', ')}`, 'info');
        
        setTimeout(() => {
            checkTraditionalLotteryResult();
            resetTraditionalLottery(); // 开奖后重置状态
        }, 1800000);
    } else {
        logAction("转生币不足！无法购买传统数字彩票", "error");
    }
}

// 新增重置函数
function resetTraditionalLottery() {
    player.traditionalLotteryNumbers = [];
    player.traditionalLotteryBought = false; // 重置购买标记
    player.traditionalLotteryPurchased = false; // 重置原有限购标记
   player.traditionalLotteryDrawTime = 0;
    updateTraditionalLotteryDisplay();
}


        // 生成传统数字彩票号码
        function generateTraditionalLotteryNumbers() {
            const numbers = [];
            while (numbers.length < 6) {
                const num = Math.floor(Math.random() * 50) + 1; // 生成1到50的随机数
                if (!numbers.includes(num)) { // 确保号码不重复
                    numbers.push(num);
                }
            }
            return numbers.sort((a, b) => a - b); // 返回排序后的号码
        }

        // 检查传统数字彩票结果
        function checkTraditionalLotteryResult() {
    const winningNumbers = generateTraditionalLotteryNumbers();
    const matchedNumbers = player.traditionalLotteryNumbers.filter(num => winningNumbers.includes(num)).length;
    let reward = 0;
    switch (matchedNumbers) {
        case 6:
            reward = 1000000;
            break;
        case 5:
            reward = 100000;
            break;
        case 4:
            reward = 10000;
            break;
        case 3:
            reward = 1000;
            break;
        case 2:
            reward = 100;
            break;
        case 1:
            reward = 10;
            break;
      }
    player.items.yuzhou1 += reward;

     // 添加开奖结果
    player.lotteryResults.unshift({
        type: '传统数字彩票',
        numbers: winningNumbers,
        matched: matchedNumbers,
        reward: reward,
       timestamp: new Date().toLocaleTimeString()
    });

    // 保持开奖结果不超过 20 条
    if (player.lotteryResults.length > 20) {
        player.lotteryResults.pop(); // 移除最旧的一条开奖结果
    }
    
    logAction(`传统数字彩票开奖结果：中奖号码为 ${winningNumbers.join(', ')}，你中了 ${matchedNumbers} 个号码，获得 ${reward} 星尘发票`, 'success');
  // 开奖后重置购买状态
     resetTraditionalLottery();
    player.traditionalLotteryPurchased = false;
    updateLotteryResultsDisplay();
    saveGame();

}

  

        // 购买蛇年刮刮卡
        function buySnakeScratchCard() {
            if (player.reincarnationCoin >= 50) {
                player.reincarnationCoin -= 50;
                const reward = getSnakeScratchCardReward();
                player.reincarnationCoin += reward;

              // 添加开奖结果
        player.lotteryResults.unshift({
            type: '蛇年刮刮卡',
            reward: reward,
            timestamp: new Date().toLocaleTimeString()
        });

        // 保持开奖结果不超过 20 条
        if (player.lotteryResults.length > 20) {
            player.lotteryResults.pop(); // 移除最旧的一条开奖结果
        }
                logAction(`购买了蛇年刮刮卡，获得 ${reward} 转生币`, 'info');
                updateLotteryResultsDisplay();
            } else {
                logAction("转生币不足！无法购买蛇年刮刮卡", "error");
            }
        }

        // 获取蛇年刮刮卡奖励
        function getSnakeScratchCardReward() {
            const rand = Math.random();
            if (rand < 0.6) return 0;
            if (rand < 0.95) return Math.floor(Math.random() * 91) + 10; // 10-100
            if (rand < 0.989) return Math.floor(Math.random() * 401) + 100; // 100-500
            if (rand < 0.999) return Math.floor(Math.random() * 1501) + 500; // 500-2000
            return Math.floor(Math.random() * 8001) + 2000; // 2000-10000
        }

        // 购买发财刮刮卡
        function buyFortuneScratchCard() {
            if (player.reincarnationCoin >= 500) {
                player.reincarnationCoin -= 500;
                const reward = getFortuneScratchCardReward();
                player.reincarnationCoin += reward;

                 // 添加开奖结果
        player.lotteryResults.unshift({
            type: '发财刮刮卡',
            reward: reward,
            timestamp: new Date().toLocaleTimeString()
        });

        // 保持开奖结果不超过 20 条
        if (player.lotteryResults.length > 20) {
            player.lotteryResults.pop(); // 移除最旧的一条开奖结果
        }
                logAction(`购买了发财刮刮卡，获得 ${reward} 转生币`, 'info');
                updateLotteryResultsDisplay();
            } else {
                logAction("转生币不足！无法购买发财刮刮卡", "error");
            }
        }

        // 获取发财刮刮卡奖励
        function getFortuneScratchCardReward() {
            const rand = Math.random();
            if (rand < 0.6) return 0;
            if (rand < 0.95) return Math.floor(Math.random() * 901) + 100; // 100-1000
            if (rand < 0.989) return Math.floor(Math.random() * 4001) + 1000; // 1000-5000
            if (rand < 0.999) return Math.floor(Math.random() * 15001) + 5000; // 5000-20000
            return Math.floor(Math.random() * 80001) + 20000; // 20000-100000
        }

        // 更新传统数字彩票显示
     function updateTraditionalLotteryDisplay() {
            const container = document.getElementById('traditionalLotteryNumbers');
            if (player.traditionalLotteryBought) {
                container.textContent = `您的号码：${player.traditionalLotteryNumbers.join(', ')} (已购买，等待开奖...)`;
                document.querySelector('.buy-traditional-lottery-btn').style.display = 'none';
            } else {
                container.textContent = "您还没有购买彩票";
                document.querySelector('.buy-traditional-lottery-btn').style.display = 'block';
            }
            // 更新倒计时显示
            updateLotteryCountdown();
        }
      // 更新彩票倒计时
        function updateLotteryCountdown() {
            const countdownElement = document.getElementById('traditionalLotteryCountdown');
            if (!countdownElement) return;

            if (player.traditionalLotteryBought && player.traditionalLotteryDrawTime > 0) {
                const now = Date.now();
                const timeLeft = player.traditionalLotteryDrawTime - now;
                
                if (timeLeft <= 0) {
                    countdownElement.textContent = '开奖中...';
                    // 时间到了，立即开奖
                    checkTraditionalLotteryResult();
                } else {
                    const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                    const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                    countdownElement.textContent = `下次开奖: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            } else {
                countdownElement.textContent = '下次开奖: --:--:--';
            }
        }
        // 更新开奖结果显示
        function updateLotteryResultsDisplay() {
    const container = document.getElementById('lotteryResults');
    container.innerHTML = player.lotteryResults
        .slice(0, 20)
        .map(result => {
            if (result.type === '传统数字彩票') {
                return `<div>${result.type} - 中奖号码: ${result.numbers.join(', ')}，你中了 ${result.matched} 个号码，获得 ${result.reward} 星尘发票</div>`;
            } else {
                return `<div>${result.type} - 获得 ${result.reward} 转生币</div>`;
            }
        })
        .join('');
}

        // 银行系统逻辑
        function depositToBank() {
            const amount = parseInt(document.getElementById('bankAmount').value) || 0;
            if (amount < 1) {
                logAction("请输入有效的存款金额", "error");
                return;
            }
            if (player.reincarnationCoin >= amount) {
                player.reincarnationCoin -= amount;
                player.bank.deposit += amount;
                logAction(`成功存款 ${amount} 转生币`, "success");
                updateBankDisplay();
            } else {
                logAction("转生币不足！", "error");
            }
        }

        function withdrawFromBank() {
            const amount = parseInt(document.getElementById('bankAmount').value) || 0;
            if (amount < 1) {
                logAction("请输入有效的取款金额", "error");
                return;
            }
            if (player.bank.deposit >= amount) {
                player.bank.deposit -= amount;
                player.reincarnationCoin += amount;
                logAction(`成功取款 ${amount} 转生币`, "success");
                updateBankDisplay();
            } else {
                logAction("存款不足！", "error");
            }
        }
     // 存款所有转生币
function depositAllToBank() {
    const amount = player.reincarnationCoin; // 获取当前所有转生币
    if (amount < 1) {
        logAction("没有可存款的转生币", "error");
        return;
    }

    player.reincarnationCoin -= amount;
    player.bank.deposit += amount;
    logAction(`成功存款所有 ${amount} 转生币`, "success");
    updateBankDisplay();
}

// 取款所有转生币
function withdrawAllFromBank() {
    const amount = player.bank.deposit; // 获取当前所有存款
    if (amount < 1) {
        logAction("没有可取款的转生币", "error");
        return;
    }

    player.bank.deposit -= amount;
    player.reincarnationCoin += amount;
    logAction(`成功取款所有 ${amount} 转生币`, "success");
    updateBankDisplay();
    }      
        function calculateBankInterest() {
            const now = Date.now();
            const elapsed = now - player.bank.lastInterestUpdate;
            const intervals = Math.floor(elapsed / (6 * 60 * 1000)); // 每6分钟计算一次利息

            if (intervals > 0) {
                const interestRate = 0.002; // 0.2% 利息
                const interest = player.bank.deposit * interestRate * intervals;
                player.bank.deposit += interest;
                player.bank.lastInterestUpdate = now - (elapsed % (6 * 60 * 1000));
                logAction(`银行利息: +${interest.toFixed(2)} 转生币`, "info");
            }
        }

       function formatSci(value) {
    if (value >= 1e8) {
        return value.toExponential(3);
    } else {
        return value.toLocaleString();
    }
}

// 更新银行显示函数
function updateBankDisplay() {
    document.getElementById("bankDeposit").textContent = formatSci(player.bank.deposit);
    document.getElementById("bankTotal").textContent = formatSci(player.bank.deposit);
}

        // 新增：副本装备系统
        function addDungeonEquipment(rarity) {
    const config = dungeonEquipmentTypes[rarity];
    const growthRate = Math.random() * (config.growthRange[1] - config.growthRange[0]) + config.growthRange[0];

    // 检查是否已经有相同的副本装备
    const existingEq = player.dungeonEquipment.find(eq => eq.rarity === rarity);
    if (existingEq) {
        existingEq.quantity = (existingEq.quantity || 1) + 1; // 增加数量
        if (existingEq.quantity >= 3) {
            existingEq.level++; // 升级装备等级
            existingEq.quantity = 0; // 重置数量
            
       
        }
    } else {
        // 如果没有相同的副本装备，则添加新的装备
        const newEq = {
            name: config.name,
            rarity: rarity,
            level: 1,
            growthRate: growthRate,
            quantity: 1 // 初始化数量
        };
        player.dungeonEquipment.push(newEq);
        logAction(`获得副本装备：${newEq.name}`, rarity);
    }

    updateDungeonEquipmentDisplay(); // 更新副本装备显示
}

        function upgradeDungeonEquipment(index) {
            const eq = player.dungeonEquipment[index];
            const cost = eq.level * 100;
            if (player.reincarnationCoin >= cost) {
                player.reincarnationCoin -= cost;
                eq.level++;
                logAction(`升级副本装备：${eq.name} 至 Lv.${eq.level}`, eq.rarity);
                updateDungeonEquipmentDisplay(); // 刷新副本装备页面
                updateDisplay();
            } else {
                logAction("转生币不足！", "error");
            }
        }

        function refineDungeonEquipment(index) {
            const eq = player.dungeonEquipment[index];
            if (player.items.refineStone > 0) {
                player.items.refineStone--;
                const config = dungeonEquipmentTypes[eq.rarity];
                eq.growthRate = Math.random() * (config.growthRange[1] - config.growthRange[0]) + config.growthRange[0];
                logAction(`洗炼副本装备：${eq.name}，新的成长属性为 ${(eq.growthRate * 100).toFixed(2)}%`, 'success');
                updateDungeonEquipmentDisplay(); // 刷新副本装备页面
                updateDisplay();
            } else {
                logAction("洗炼石不足！", "error");
            }
        }

       function updateDungeonEquipmentDisplay() {

    const container = document.getElementById('dungeonEquipmentContainer');
    const rarityOrder = [
        'common',     
    'rare',       
    'epic',       
    'legendary',  
    'ancient',    
    'divine',    
    'arcane',     
    'celestial',  
    'infernal',  
    'astral',     
    'primeval',  
    'transcendental', 
    'quantum',    
    'ultimate',  
    'ultimate1',     
    'ultimate2',   
    'ultimate3',       
    'ultimate4',   
    'ultimate5', 
    'ultimate6',    
    'ultimate7',     
    'ultimate8',   
    'ultimate9',       
    'ultimate10',   
    'ultimate11', 
    'ultimate12',     
    'ultimate13',     
    'ultimate14',   
    'ultimate15',       
    'ultimate16',   
    'ultimate17', 
    'ultimate18',   
    'ultimate19',     
    'ultimate20',   
    'ultimate21',       
    'ultimate22',   
    'ultimate23', 
    'ultimate24',   
    'ultimate25',   
    'ultimate26',       
    'ultimate27',   
    'ultimate28', 
    'ultimate29',     
    'ultimate30',     
    'ultimate31',   
    'ultimate32',       
    'ultimate33',   
    'ultimate34', 
    'ultimate35',     
    'ultimate36',     
    'ultimate37',   
    'ultimate38',       
    'ultimate39',   
    'ultimate40', 
    'ultimate41',    
    'ultimate42',     
    'ultimate43',   
    'ultimate44',       
    'ultimate45',   
    'ultimate46', 
    'ultimate47', 
    'ultimate48',   
    'ultimate49', 
    'ultimate50'
    ];
    
    // 按品质排序
    const sortedEquipment = player.dungeonEquipment.sort((a, b) => {
        // 先按品质排序
        const rarityDiff = rarityOrder.indexOf(a.rarity) - rarityOrder.indexOf(b.rarity);
        if (rarityDiff !== 0) return rarityDiff;
        
        // 同品质按成长属性降序
        return b.growthRate - a.growthRate;
    });
    const totalBonus = player.dungeonEquipment.reduce((sum, eq) => sum + eq.level * eq.growthRate, 0);
    container.innerHTML = `
        <div>总加成: +${(totalBonus * 100).toFixed(2)}%</div>
        ${player.dungeonEquipment.map((eq, index) => `
            <div class="equipment ${eq.rarity}">
                ${eq.name} Lv.${eq.level} (数量: ${eq.quantity}/3, 成长属性: +${(eq.growthRate * 100).toFixed(2)}%)
                <button onclick="refineDungeonEquipment(${index})">洗炼</button>
                <button onclick="dismantleDungeonEquipment(${index})">分解</button>
            </div>
        `).join('')}
    `;
}

        // 分解副本装备
        function dismantleDungeonEquipment(index) {
            const eq = player.dungeonEquipment[index];
            player.dungeonEquipment.splice(index, 1);
            logAction(`分解了副本装备：${eq.name}`, 'success');
            updateDungeonEquipmentDisplay();
        }

        // 新增：魂环系统
        function addSoulRing(type) {
            const existing = player.soulRings.find(r => r.type === type);
            if(existing) {
                existing.level++;
            } else {
                player.soulRings.push({
                    type: type,
                    level: 1,
                    multiplier: soulRingTypes[type].baseMult
                });
            }
        }

        function upgradeSoulRing(type) {
    const ring = player.soulRings.find(r => r.type === type);
    const cost = ring.level * soulRingTypes[type].costBase * 1000;

    if (player.reincarnationCoin >= cost) {
        player.reincarnationCoin -= cost;
        ring.level++;

        // 检查魂环成就
        checkSoulRingAchievements(type, ring.level);

        logAction(`${soulRingTypes[type].name} 升级到 Lv.${ring.level}`, 'success');
    } else {
        logAction("转生币不足！", "error");
    }
}

function checkSoulRingAchievements(type, level) {
    const achievements = [
        { level: 10, key: `${type}_10` },
        { level: 100, key: `${type}_100` },
        { level: 1000, key: `${type}_1000` },
        { level: 10000, key: `${type}_10000` },
    ];

    achievements.forEach(({ level: targetLevel, key }) => {
        if (level >= targetLevel && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updateAchievementsDisplay();
            }
        }
    });
}
        function updateSoulRingDisplay() {
            const container = document.getElementById('soulRingsContainer');
            container.innerHTML = player.soulRings.map(ring => `
                <div class="equipment">
                    ${soulRingTypes[ring.type].name} Lv.${ring.level}
                    (全属性+${(ring.level * ring.multiplier * 100).toFixed(1)}%)

                    </button>
                </div>
            `).join('');
        }
      function showRenameDialog() {
    document.getElementById("renameDialog").style.display = "block";
    document.getElementById("renameOverlay").style.display = "block";
    document.getElementById("newNameInput").value = player.name;
    document.getElementById("newNameInput").focus();
}

function cancelRename() {
    document.getElementById("renameDialog").style.display = "none";
    document.getElementById("renameOverlay").style.display = "none";
}

function confirmRename() {
    const newName = document.getElementById("newNameInput").value.trim();
    if (newName && newName.length <= 10) {
        player.name = newName;
        document.getElementById("playerName").textContent = newName;
        saveGame();  // 确保保存玩家数据
        cancelRename();
    } else {
        alert("请输入有效的名字（1-10个字符）");
    }
}

        // 界面更新
        function updateDisplay() {
        const soulRingRingBonus = getTotalSoulRingBonus();
  const dungeonEquipBonus = getTotalDungeonEquipBonus();
      document.getElementById("playerName").textContent = player.name;
       const currentTitleEl = document.getElementById("currentTitle");
    currentTitleEl.textContent = player.titles.current ? `[${player.titles.current}]` : "";
    const runeBonuses = calculateRuneBonuses();
    let runeBonusText = '';
    
    if (player.runes.equipped) {
        runeBonusText = '符文加成: ';
        const bonuses = [];
        
        if (runeBonuses.attack > 0) bonuses.push(`攻击+${(runeBonuses.attack * 100).toFixed(1)}%`);
        if (runeBonuses.health > 0) bonuses.push(`生命+${(runeBonuses.health * 100).toFixed(1)}%`);
        if (runeBonuses.critRate > 0) bonuses.push(`暴击+${(runeBonuses.critRate * 100).toFixed(2)}%`);
        if (runeBonuses.critDamage > 0) bonuses.push(`爆伤+${(runeBonuses.critDamage * 100).toFixed(1)}%`);
        if (runeBonuses.combo > 0) bonuses.push(`连击+${runeBonuses.combo.toFixed(0)}次`);
        if (runeBonuses.worldExp > 0) bonuses.push(`世界经验+${(runeBonuses.worldExp * 100).toFixed(1)}%`);
        
        runeBonusText += bonuses.join(' ');
    }
    
    // 将符文加成信息添加到界面中合适的位置
    const runeBonusElement = document.getElementById('runeBonusDisplay');
    if (!runeBonusElement) {
        // 如果不存在，创建一个新的元素
        const newElement = document.createElement('div');
        newElement.id = 'runeBonusDisplay';
        newElement.style.cssText = 'color: #90ee90; font-size: 12px; margin-top: 5px;';
        newElement.textContent = runeBonusText;
        
        // 找到合适的位置插入（例如在玩家属性显示区域）
        const playerStatsContainer = document.querySelector('.player-stats-container');
        if (playerStatsContainer) {
            playerStatsContainer.appendChild(newElement);
        }
    } else {
        runeBonusElement.textContent = runeBonusText;
    }
    
 
    // 数值显示
    const display = (value) => {
    if (value >= 1e8) {  // 当数值大于等于 100,000,000 时使用科学计数法
        return value.toExponential(3);
    } else {
        return value.toLocaleString();  // 否则使用常规的数值显示
    }
};
   
  
    // 更新显示
   const currencies = ['gold', 'diamond', 'titanium', 'starstone', 'cosmicstone', 
                       'superstone', 'otherworldstone', 'xingjiestone', 'hundunstone', 
                       'lingtone', 'huangtone', 'mingtone', 'xutong', 'shitone', 'weitone'];
    
    currencies.forEach(currency => {
        const element = document.getElementById(currency);
        if (player[currency] === 0) {
            element.textContent = ''; // 设置为空
        } else {
            element.textContent = display(player[currency]);
        }
    });
    document.getElementById("reincarnationCoin").textContent = display(player.reincarnationCoin);
    document.getElementById("reincarnationCount").textContent = player.reincarnationCount;
    document.getElementById("maxStage").textContent = player.battle.maxStage;
    document.getElementById("gps").textContent = display(getTotalGPS());
    document.getElementById("clickValue").textContent = display(getTotalClickValue());
    document.getElementById("vipPowerCount").textContent = player.items.vipPower || 0;
   document.getElementById("mysteryBonusDisplay").textContent = player.mystery.bonus;
  document.getElementById('playerLevelDisplay').textContent = `Lv.${player.level.current}级`;
  document.getElementById('ascentionCountq').textContent = `飞升.${player.level.ascentionCount}次`;
document.getElementById('ascentionCountqa').textContent = `轮回.${player.level.ascentionCounta}转`;

    // 更新材料宝箱购买成本显示
    document.getElementById("materialChestCost").textContent = display(player.materialChestCost);

        // 更新宝箱成本显示
     document.getElementById("techniqueChestCost").textContent = display(player.techniqueChestCost);

    // 更新怪物生命和攻击显示
    if (player.battle.monster) {
        document.getElementById("monsterHealth").textContent = display(player.battle.monster.health);
        document.getElementById("monsterAttack").textContent = display(player.battle.monster.attack);
    }
   
    // 更新玩家攻击显示
    document.getElementById("playerAttack").textContent = display(player.battle.playerAttack);

            // 装备列表
            const fragment = document.createDocumentFragment();
   player.equipment.forEach((eq, index) => {
    const div = document.createElement("div");
    div.className = `equipment ${eq.rarity}`;
    div.innerHTML = `
        ${getEquipmentName(eq)} Lv.${eq.level}
        (GPS +${eq.gps.toExponential(3)} 点击 +${eq.click.toExponential(3)})
        <button onclick="useGem(${index}, 'primaryGem')">使用初级宝石</button>
        <button onclick="useAllGems(${index}, 'primaryGem')">一键使用初级宝石</button>
        <button onclick="useGem(${index}, 'advancedGem')">使用高级宝石</button>
        <button onclick="useAllGems(${index}, 'advancedGem')">一键使用高级宝石</button>
        <button onclick="useGem(${index}, 'superiorGem')">使用极品宝石</button>
        <button onclick="useAllGems(${index}, 'superiorGem')">一键使用极品宝石</button>
        <button onclick="useGem(${index}, 'divineGem')">使用神级宝石</button>
        <button onclick="useAllGems(${index}, 'divineGem')">一键使用神级宝石</button>
        <div class="tooltip">
                品质: ${eq.name}<br>
                等级: ${eq.level}<br>
                成长率: +${(eq.growthRate * 100).toFixed(1)}%/级<br>
                宝石加成: +${(eq.gemMultiplier * 100).toFixed(2)}%<br>
            </div>
        `;
        fragment.appendChild(div);
    });
    document.getElementById("equipmentList").innerHTML = "";
    document.getElementById("equipmentList").appendChild(fragment);

            // 日志
            document.getElementById("actionLog").innerHTML = player.actionLogs
                .map(log => `<div class="${log.type}">[${log.timestamp}] ${log.message}</div>`)
                .join("");

            // 成就
            updateAchievementsDisplay();
            localStorage.setItem("goldGameSave", JSON.stringify(player));
        }

        // 辅助函数
        function getEquipmentName(eq) {
            return eq.name || equipmentTypes[eq.rarity]?.name || '神秘装备';
        }

        function validateRarity(rarity) {
            return equipmentTypes[rarity] ? rarity : 'common';
        }

        function getDefaultGrowthRate(rarity) {
            return equipmentTypes[rarity]?.growthRate || 0.01;
        }
            function formatSci(number) {
    if (number >= 1e9) {
        return number.toExponential(3)
            .replace(/(\.\d+?)0+e/, '$1e')
            .replace(/\.?e\+?/, 'e');
    }
    return Math.floor(number).toLocaleString();
}


        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            return [hours && `${hours}小时`, minutes && `${minutes}分`, `${secs}秒`]
                .filter(Boolean).join(' ');
        }

       function logAction(message, type = 'info') {
    // 过滤包含"自动购买"的消息
    if (message.includes('自动购买')) {
        return; // 直接返回，不记录这类消息
    }
    
    const timestamp = new Date().toLocaleTimeString();

    // 辅助函数：将大数值转换为科学计数法
    const formatNumber = (value) => {
        if (value >= 1e8) { // 当数值大于等于 100,000,000 时使用科学计数法
            return value.toExponential(3);
        } else {
            return value.toLocaleString(); // 否则使用常规的数值显示
        }
    };

    // 格式化消息中的数值
    const formattedMessage = message.replace(/\d+(\.\d+)?/g, (match) => {
        const number = parseFloat(match);
        return formatNumber(number);
    });

    // 添加到统一日志数组
    player.actionLogs.unshift({ message: formattedMessage, type, timestamp });
    // 保持日志长度不超过 20 条
    if (player.actionLogs.length > 20) {
        player.actionLogs.pop(); // 移除最旧的一条日志
    }

    // 原有 DOM 更新逻辑保持不变...
    const logEntry = document.createElement('div');
    logEntry.className = type;
    logEntry.textContent = `[${timestamp}] ${message}`;

    const logContainer = document.getElementById('actionLog');
    logContainer.insertAdjacentHTML("afterbegin", logEntry);

    if (logContainer.children.length > 20) {
        logContainer.removeChild(logContainer.lastChild);
    }
}


        // 保存游戏
        function saveGame() {
    player.lastUpdate = Date.now(); // 确保保存时更新最后更新时间   
    player.actionLogs = player.actionLogs.slice(0, 5);
    player.lotteryResults = player.lotteryResults.slice(0, 5);
   
    if (player.liveStream && player.liveStream.donationHistory) {
        player.liveStream.donationHistory = player.liveStream.donationHistory.slice(-5);
    }
     if (player.investmentGame && player.investmentGame.userData) {
        player.investmentGame.userData.lastUpdateTime = Date.now();
    }
    if (player.liveStream && player.liveStream.viewers) {
        player.liveStream.viewers = player.liveStream.viewers.slice(-5);
    }
    player.mystery.lastUpdateTime = Date.now();
   cleanupArtifactAdvanceLevels(); 
    saveInvestmentGameData();
    player.tower.lastUpdate = Date.now();
    player.exploration = {
        speed: explorationData.speed,
        capacity: explorationData.capacity,
        durability: explorationData.durability,
        resources: explorationData.resources,
        activeMission: explorationData.activeMission,
        missionEndTime: explorationData.missionEndTime,
        logs: explorationData.logs
    };
    
    localStorage.setItem('goldGameSave', JSON.stringify(player));
    localStorage.setItem('traditionalLotteryPurchased', player.traditionalLotteryPurchased);
    logAction('游戏已保存', 'success');
}

        // 加载游戏
        function loadGame() {
    loadSave();
   updateSectNameDisplay();
    updateDisplay();
   calculateTotalGPS();
  if (!player.timeSecretRealm) {
        player.timeSecretRealm = {
            currency: 0,
            bestFloor: 0,
            clearCount: 0,
            unlockedItems: [],
            currentRun: {
                isActive: false,
                currentFloor: 1,
                timeLeft: 300,
                tempBuffs: [],
                currentRoom: null,
                exploredRooms: 0,
                currencyEarned: 0,
                playerHealth: 0,
                playerAttack: 0
            },
         difficulty: {
   levels: {
        easy: { 
            name: '简单', 
            multiplier: 0.8, 
            rewardMultiplier: 0.7, 
            description: '适合新手玩家', 
            unlockCondition: '无',
            clearFloor: 10  // 通关层数要求
        },
        normal: { 
            name: '普通', 
            multiplier: 1.0, 
            rewardMultiplier: 1.0, 
            description: '标准难度', 
            unlockCondition: '通关简单难度3次',
            clearFloor: 15
        },
        hard: { 
            name: '困难', 
            multiplier: 1.5, 
            rewardMultiplier: 1.5, 
            description: '更具挑战性', 
            unlockCondition: '通关普通难度5次',
            clearFloor: 20
        },
        nightmare: { 
            name: '噩梦', 
            multiplier: 2.0, 
            rewardMultiplier: 2.5, 
            description: '极限挑战', 
            unlockCondition: '通关困难难度10次',
            clearFloor: 25
        },
        hell: { 
            name: '地狱', 
            multiplier: 3.0, 
            rewardMultiplier: 4.0, 
            description: '终极考验', 
            unlockCondition: '通关噩梦难度20次',
            clearFloor: 30
        }
    },
    current: 'easy',
    unlocked: ['easy']
},
            roomTypes: {
                battle: { weight: 40, name: '战斗房间' },
                event: { weight: 25, name: '事件房间' },
                treasure: { weight: 20, name: '宝箱房间' },
                rest: { weight: 10, name: '休息房间' },
                shop: { weight: 5, name: '商店房间' }
            },
            tempBuffs: {
                attack: { 
        name: '攻击强化', 
        description: '攻击力提升50%，探索时间+30秒', 
        effect: 'attack', 
        value: 0.5, 
        duration: 0,
        timeBonus: 30  // 新增：增加20秒探索时间
    },
    health: { 
        name: '生命强化', 
        description: '生命值提升50%，探索时间+60秒', 
        effect: 'health', 
        value: 0.5, 
        duration: 0,
        timeBonus: 60  // 新增：增加40秒探索时间
    },
    critRate: { 
        name: '暴击强化', 
        description: '暴击率提升10%，探索时间+90秒', 
        effect: 'critRate', 
        value: 0.1, 
        duration: 0,
        timeBonus: 90  // 新增：增加60秒探索时间
    },
    critDamage: { 
        name: '爆伤强化', 
        description: '爆伤提升50%，探索时间+120秒', 
        effect: 'critDamage', 
        value: 0.5, 
        duration: 0,
        timeBonus: 120  // 新增：增加80秒探索时间
    },
    speed: { 
        name: '速度强化', 
        description: '探索速度提升，探索时间+150秒', 
        effect: 'speed', 
        value: 10, 
        duration: 0,
        timeBonus: 150  // 新增：增加100秒探索时间
    },
                luck: { name: '幸运强化', description: '获得双倍秘境币', effect: 'luck', value: 1, duration: 0  }
            },
            shopItems: {
                permanentAttack: { 
                    name: '永恒攻击符文', 
                    description: '临时提升现有攻击力50%可以叠加（转生失效)', 
                    cost: 100000, 
                    type: 'permanent',
                    effect: 'attack'
                },
                permanentHealth: { 
                    name: '永恒生命符文', 
                    description: '临时提升现有生命值50%可以叠加（转生失效)', 
                    cost: 100000, 
                    type: 'permanent',
                    effect: 'health'
                },
                timeExtension: { 
        name: '时间沙漏', 
        description: '永久增加探索时间60秒（限购50个）', 
        cost: 500000, 
        type: 'permanent',
        effect: 'time',
        maxPurchase: 50, // 限购50个
        purchased: 0, // 已购买数量
        permanentEffect: true // 永久效果
    },
    startingBuff: { 
        name: '起始祝福', 
        description: '每次冒险开始时永久获得1个随机增益效果（限购2个）', 
        cost: 800000, 
        type: 'permanent',
        effect: 'startingBuff',
        maxPurchase: 2, // 限购2个
        purchased: 0, // 已购买数量
        permanentEffect: true // 永久效果
    },
           trapSkillBook1: {
    name: '侦查技能书·初级',
    description: '提升陷阱侦查成功率到60%',
    cost: 500000,
    type: 'permanent',
    effect: 'detection_advanced'
},
 trapSkillBook2: {
    name: '侦查技能书·高级',
    description: '提升陷阱侦查成功率到80%',
    cost: 800000,
    type: 'permanent',
    effect: 'detection_expert'
},
 trapSkillBook3: {
    name: '解除技能书·初级',
    description: '提升陷阱解除成功率到70%',
    cost: 500000,
    type: 'permanent',
    effect: 'disarm_advanced'
},
 trapSkillBook4: {
    name: '解除技能书·高级',
    description: '提升陷阱解除成功率到85%',
    cost: 800000,
    type: 'permanent',
    effect: 'disarm_expert'
},
 trapSense: {
    name: '陷阱感知药水',
    description: '下次冒险陷阱侦查成功率提升30%',
    cost: 10000,
    type: 'consumable',
    effect: 'detection_boost'
},
                rareMaterial: { 
                    name: '秘境结晶', 
                    description: '神器碎片1000个', 
                    cost: 100000, 
                    type: 'material',
                    effect: 'material'
                }
            },
traps: {
    // 陷阱类型配置
    types: {
        poison: { weight: 20, name: '毒液陷阱', damageType: 'percentage', damage: 0.15, duration: 3 },
        spike: { weight: 15, name: '尖刺陷阱', damageType: 'fixed', damage: 1000, duration: 1 },
        curse: { weight: 10, name: '诅咒陷阱', damageType: 'debuff', effect: 'attack', value: -0.3, duration: 5 },
        slow: { weight: 12, name: '迟缓陷阱', damageType: 'time', damage: 30, duration: 0 },
        confusion: { weight: 8, name: '混乱陷阱', damageType: 'random', damage: 0.2, duration: 2 },
        disarm: { weight: 5, name: '缴械陷阱', damageType: 'debuff', effect: 'critRate', value: -0.5, duration: 4 }
    },
    
    // 陷阱检测技能
    detectionSkills: {
        basic: { name: '基础侦查', successRate: 0.3, cost: 5 },
        advanced: { name: '高级侦查', successRate: 0.6, cost: 15 },
        expert: { name: '专家侦查', successRate: 0.8, cost: 25 },
        master: { name: '大师侦查', successRate: 0.95, cost: 40 }
    },
    
    // 陷阱解除技能
    disarmSkills: {
        basic: { name: '基础解除', successRate: 0.4, cost: 10 },
        advanced: { name: '高级解除', successRate: 0.7, cost: 20 },
        expert: { name: '专家解除', successRate: 0.85, cost: 35 },
        master: { name: '大师解除', successRate: 1.0, cost: 50 }
    },
    
    // 玩家掌握的陷阱技能
    playerSkills: {
        detection: 'basic',
        disarm: 'basic'
    }
 }
        };
    
    
    updateTimeSecretRealmUI();
}
 player.traditionalLotteryPurchased = localStorage.getItem('traditionalLotteryPurchased') === 'true';
 if (player.parking) {
        calculateOfflineParkingIncome();
    }
    logAction('游戏已加载', 'success');
}
 const ENCRYPTION_KEY = "your-secure-key-here-123";
        // 导出存档
        function exportSave() {
        try {
            // 转换玩家数据为JSON字符串
            const saveData = JSON.stringify(player);
            // 使用AES加密
            const encryptedData = CryptoJS.AES.encrypt(
                saveData,
                ENCRYPTION_KEY
            ).toString();
            
            // 复制加密后的数据到剪贴板
            const textArea = document.createElement('textarea');
            textArea.value = encryptedData;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            logAction('加密存档已复制到剪贴板', 'success');
        } catch (error) {
            logAction('存档导出失败', 'error');
            console.error('导出错误:', error);
        }
    }
 // 导出存档到文件（新增功能）
function downloadSave() {
    try {
        // 获取当前存档数据
        const saveData = JSON.stringify(player);
        
        // 使用AES加密存档
        const encryptedData = CryptoJS.AES.encrypt(
            saveData,
            ENCRYPTION_KEY
        ).toString();
        
        // 创建Blob对象
        const blob = new Blob([encryptedData], { type: 'text/plain' });
        
        // 创建下载链接
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `gold_adventurer_save_${new Date().toISOString().slice(0, 10)}.txt`;
        
        // 触发下载
        document.body.appendChild(a);
        a.click();
        
        // 清理
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        logAction('存档已加密并下载', 'success');
    } catch (error) {
        logAction('存档下载失败: ' + error.message, 'error');
        console.error('存档下载错误:', error);
    }
}
function importEncryptedSave() {
    // 检查冷却时间
    const lastImportTime = localStorage.getItem('lastImportTime');
    if (lastImportTime) {
        const currentTime = Date.now();
        const timeDiff = currentTime - parseInt(lastImportTime);
        const cooldown = 6 * 60 * 60 * 1000; // 6小时冷却时间
        
        if (timeDiff < cooldown) {
            const remaining = Math.ceil((cooldown - timeDiff) / (60 * 1000));
            logAction(`导入功能冷却中，请等待 ${remaining} 分钟后再试`, "error");
            return;
        }
    }
    
    // 触发文件选择器
    document.getElementById('fileInput').click();
    
    // 添加文件选择事件监听
    document.getElementById('fileInput').addEventListener('change', handleFileSelect);
}

// 处理文件选择
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // 检查文件类型
    if (file.type !== "text/plain" && !file.name.endsWith('.txt')) {
        logAction("请选择.txt格式的存档文件", "error");
        return;
    }
    
    // 读取文件内容
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const encryptedData = e.target.result;
            decryptAndLoadSave(encryptedData);
        } catch (error) {
            logAction("存档导入失败：" + error.message, "error");
            console.error("存档导入错误:", error);
        }
    };
    reader.readAsText(file);
}

// 解密并加载存档
function decryptAndLoadSave(encryptedData) {
    try {
        // 解密数据
        const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
        const saveData = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
        
        // 应用存档数据
        player = migrateSaveData(saveData);
        updateDisplay();
        logAction('加密存档导入成功！', 'success');
        
        // 更新导入时间
        localStorage.setItem('lastImportTime', Date.now().toString());
       saveGame();
      setTimeout(() => {
                location.reload(true);
            }, 1000);
    } catch (error) {
        logAction('存档导入失败：无效的存档或密钥错误', 'error');
        console.error('导入错误:', error);
    }
}
// 存档迁移函数（确保兼容性）
function migrateSaveData(save) {
    // 这里添加必要的存档迁移逻辑
    // 确保旧版存档能兼容新版游戏
    
    return {
        ...player, // 使用默认值
        ...save    // 覆盖为导入的数据
    };
}

        // 导入存档
    function importSave() {
    // 检查冷却时间
    const lastImportTime = localStorage.getItem('lastImportTime');
    if (lastImportTime) {
        const currentTime = Date.now();
        const timeDiff = currentTime - parseInt(lastImportTime);
        const cooldown = 6 * 60 * 60 * 1000; // 6小时冷却时间
        
        if (timeDiff < cooldown) {
            const remaining = Math.ceil((cooldown - timeDiff) / (60 * 1000));
            logAction(`导入功能冷却中，请等待 ${remaining} 分钟后再试`, "error");
            return;
        }
    }
    
    showCustomPrompt('请输入加密存档代码：', async (encryptedData) => {
        if (!encryptedData) return;
        
        try {
            // 解密存档数据
            const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
            const saveData = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
            
            // 应用存档数据
            player = migrateSaveData(saveData);
            updateDisplay();
            logAction('存档已成功导入！', 'success');
            
            // 更新导入时间
            localStorage.setItem('lastImportTime', Date.now().toString());
      saveGame();
      setTimeout(() => {
                location.reload(true);
            }, 1000);
        } catch (error) {
            logAction('存档导入失败：无效的存档或密钥错误', 'error');
            console.error('导入错误:', error);
        }
    });
}

// 获取加密的时间戳
async function getEncryptedTime(key) {
    const encrypted = localStorage.getItem(key);
    if (!encrypted) return null;
    try {
        const decrypted = CryptoJS.AES.decrypt(encrypted, ENCRYPTION_KEY);
        return parseInt(decrypted.toString(CryptoJS.enc.Utf8));
    } catch {
        return null;
    }
}

// 设置加密的时间戳
async function setEncryptedTime(key, value) {
    const encrypted = CryptoJS.AES.encrypt(String(value), ENCRYPTION_KEY);
    localStorage.setItem(key, encrypted.toString());
}

// 格式化时间显示
function formatTime(milliseconds) {
    const hours = Math.floor(milliseconds / 3600000);
    const mins = Math.floor((milliseconds % 3600000) / 60000);
    return `${hours}小时${mins}分钟`;
}
          function resetItems() {
      showCustomConfirm('确定要重置道具数据吗？所有道具将被清除！', (confirmed) => {
          if (confirmed) {
            // 重置道具数据
            player.items = {
                primaryGem: 0,
                advancedGem: 0,
                superiorGem: 0,
                divineGem: 0,
                vipPower: 0,
                refineStone: 0
            };

            // 更新道具页面
            updateItemDisplay();
            logAction('道具数据已重置', 'success');
           }
        });
   }
        // 重置游戏
        function resetGame() {
            showCustomConfirm('确定要重置游戏吗？所有进度将丢失！', (confirmed) => {
                if (confirmed) {
                    localStorage.removeItem('goldGameSave');
                    player = {
                        gold: 0,
                        diamond: 0,
                        titanium: 0,
                        starstone: 0,
                        cosmicstone: 0,
                        superstone: 0,
                        otherworldstone: 0, 
                        xingjiestone: 0, 
                        hundunstone: 0,  
                        lingtone: 0,
                        huangtone: 0,
                        mingtone: 0,
                        xutong: 0,
                        shitone: 0,
                        weitone: 0,
                        reincarnationCoin: 0,
                        reincarnationCount: 0,
                        equipment: [],
                        vip: {
        level: 1,
        power: 0, // 累计VIP能力值数量
    },
                        items: {
                            primaryGem: 0,
                            advancedGem: 0,
                            superiorGem: 0,
                            divineGem: 0,
                            vipPower: 0,
                            refineStone: 0 // 新增洗炼石
                           
                        },
                        collections: {
                            lightSpeedHand: 0,
                            empHand: 0,
                            godlyHand: 0,
                            quickHand: 0,
                            shadowHand: 0,
                            quantumHand: 0,
                            lightningHand: 0,
                            divineHand: 0
                        },
                        pets: {
                             thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
                             chaosTaotie: { level: 0, cost: 1, multiplier: 0.30 },
                             netherQiongqi: { level: 0, cost: 1, multiplier: 0.90 },
                             abyssKun: { level: 0, cost: 1, multiplier: 2.70 },
                             primordialZhuLong: { level: 0, cost: 1, multiplier: 8.10 },
                            wanJunSuanNi: { level: 0, cost: 1, multiplier: 24.30 },
                            yanYuBiAn: { level: 0, cost: 1, multiplier: 72.30 },
                            yuyu1: { level: 0, cost: 1, multiplier: 218.70 },
                              yuyu2: { level: 0, cost: 1, multiplier: 656.10 },
                            yuyu3: { level: 0, cost: 1, multiplier: 1968.30 },
                              yuyu4: { level: 0, cost: 1, multiplier: 5904.90 },
                            yuyu5: { level: 0, cost: 1, multiplier: 17714.70 },
                            yuyu6: { level: 0, cost: 1, multiplier: 53144.10 },
                              yuyu7: { level: 0, cost: 1, multiplier: 159432.30 },
                            yuyu8: { level: 0, cost: 1, multiplier: 478296.90 }
                        },
                        dungeonEquipment: [], // 新增副本装备
                        soulRings: [], // 新增魂环系统
                        techniques: {},
                        attributes: {
                         totalPoints: 0,
                        remainingPoints: 0,
                        health: 0,
                        attack: 0,
                        critRate: 0,
                         critDamage: 0,
                       multiAttack: 0,
                         block: 0
                        },
                        lastUpdate: Date.now(),
                        achievements: {
        first_equipment: false,
        first_rare: false,
        first_epic: false,
        first_legendary: false,
        first_ancient: false,
        first_divine: false,
        first_arcane: false,
        first_celestial: false,
        first_infernal: false,
        first_astral: false,
        first_primeval: false,
        first_transcendental: false,
        first_quantum: false,
        first_ultimate: false,
        first_chaos: false,
        first_eternal: false,
        first_void: false,
        first_genesis: false,
        first_divineRealm: false,
        first_apocalypse: false,
        first_yeyu1: false,
        first_yeyu2: false,
        first_yeyu3: false,
        first_yeyu4: false,
        first_yeyu5: false,
        first_yeyu6: false,
        first_yeyu7: false,
        first_yeyu8: false,
        first_yeyu9: false,
        first_yeyu10: false,
        first_yeyu11: false,
        first_yeyu12: false,
        first_yeyu13: false,
        first_yeyu14: false,
        first_yeyu15: false,
        first_yeyu16: false,
        first_yeyu17: false,
        first_yeyu18: false,
        first_yeyu19: false,
        first_yeyu20: false,
        first_yeyu21: false,
        first_yeyu22: false,
        first_yeyu23: false,
        first_yeyu24: false,
        // 宝箱成就
        common_chest_100: false,
        common_chest_10000: false,
        common_chest_1000000: false,
        common_chest_10000000: false,
        common_chest_100000000: false,
        advanced_chest_100: false,
        advanced_chest_10000: false,
        advanced_chest_1000000: false,
        advanced_chest_10000000: false,
        advanced_chest_100000000: false,
        rare_chest_100: false,
        rare_chest_10000: false,
        rare_chest_1000000: false,
        rare_chest_10000000: false,
        rare_chest_100000000: false,
        epic_chest_100: false,
        epic_chest_10000: false,
        epic_chest_1000000: false,
        epic_chest_10000000: false,
        epic_chest_100000000: false,
        legendary_chest_100: false,
        legendary_chest_10000: false,
        legendary_chest_1000000: false,
        legendary_chest_10000000: false,
        legendary_chest_100000000: false,
        chaos_chest_100: false,
        chaos_chest_10000: false,
        chaos_chest_1000000: false,
        chaos_chest_10000000: false,
        chaos_chest_100000000: false,
        apocalypse_chest_100: false,
        apocalypse_chest_10000: false,
        apocalypse_chest_1000000: false,
        apocalypse_chest_10000000: false,
        apocalypse_chest_100000000: false,
        yeyu1_chest_100: false,
        yeyu1_chest_10000: false,
        yeyu1_chest_1000000: false,
        yeyu1_chest_10000000: false,
        yeyu1_chest_100000000: false,
        yeyu2_chest_100: false,
        yeyu2_chest_10000: false,
        yeyu2_chest_1000000: false,
        yeyu2_chest_10000000: false,
        yeyu2_chest_100000000: false,
        yeyu3_chest_100: false,
        yeyu3_chest_10000: false,
        yeyu3_chest_1000000: false,
        yeyu3_chest_10000000: false,
        yeyu3_chest_100000000: false,
        yeyu4_chest_100: false,
        yeyu4_chest_10000: false,
        yeyu4_chest_1000000: false,
        yeyu4_chest_10000000: false,
        yeyu4_chest_100000000: false,
        yeyu5_chest_100: false,
        yeyu5_chest_10000: false,
        yeyu5_chest_1000000: false,
        yeyu5_chest_10000000: false,
        yeyu5_chest_100000000: false,
        yeyu6_chest_100: false,
        yeyu6_chest_10000: false,
        yeyu6_chest_1000000: false,
        yeyu6_chest_10000000: false,
        yeyu6_chest_100000000: false,
        yeyu7_chest_100: false,
        yeyu7_chest_10000: false,
        yeyu7_chest_1000000: false,
        yeyu7_chest_10000000: false,
        yeyu7_chest_100000000: false,
        yeyu8_chest_100: false,
        yeyu8_chest_10000: false,
        yeyu8_chest_1000000: false,
        yeyu8_chest_10000000: false,
        yeyu8_chest_100000000: false,
        "max_stage_10": false,
    "max_stage_30": false,
    "max_stage_60": false,
    "max_stage_90": false,
    "max_stage_120": false,
    "max_stage_200": false,
    "max_stage_300": false,
    "max_stage_400": false,
    "max_stage_500": false,
    "max_stage_600": false,
    "max_stage_700": false,
    "max_stage_800": false,
    "max_stage_900": false,
    "max_stage_1000": false,

    // 新增宠物成就状态
    "thunderKirin_10": false,
    "thunderKirin_50": false,
    "thunderKirin_100": false,
    "chaosTaotie_10": false,
    "chaosTaotie_50": false,
    "chaosTaotie_100": false,
    "netherQiongqi_10": false,
    "netherQiongqi_50": false,
    "netherQiongqi_100": false,
    "abyssKun_10": false,
    "abyssKun_50": false,
    "abyssKun_100": false,
    "primordialZhuLong_10": false,
    "primordialZhuLong_50": false,
    "primordialZhuLong_100": false,
    "wanJunSuanNi_10": false,
    "wanJunSuanNi_50": false,
    "wanJunSuanNi_100": false,
    "yanYuBiAn_10": false,
    "yanYuBiAn_50": false,
    "yanYuBiAn_100": false,
    "yuyu1_10": false,
    "yuyu1_50": false,
    "yuyu1_100": false,
    "yuyu2_10": false,
    "yuyu2_50": false,
    "yuyu2_100": false,
    "yuyu3_10": false,
    "yuyu3_50": false,
    "yuyu3_100": false,
    "yuyu4_10": false,
    "yuyu4_50": false,
    "yuyu4_100": false,
    "yuyu5_10": false,
    "yuyu5_50": false,
    "yuyu5_100": false,
    "yuyu6_10": false,
    "yuyu6_50": false,
    "yuyu6_100": false,
    "yuyu7_10": false,
    "yuyu7_50": false,
    "yuyu7_100": false,
    "yuyu8_10": false,
    "yuyu8_50": false,
    "yuyu8_100": false,
    // 新增魂环成就状态
    "year1_10": false,
    "year10_10": false,
    "year100_10": false,
    "year1000_10": false,
    "year10000_10": false,
    "year100000_10": false,
    "year1000000_10": false,
    "year10000000_10": false,
    "year100000000_10": false,
    "year1_100": false,
    "year10_100": false,
    "year100_100": false,
    "year1000_100": false,
    "year10000_100": false,
    "year100000_100": false,
    "year1000000_100": false,
    "year10000000_100": false,
    "year100000000_100": false,
    "year1_1000": false,
    "year10_1000": false,
    "year100_1000": false,
    "year1000_1000": false,
    "year10000_1000": false,
    "year100000_1000": false,
    "year1000000_1000": false,
    "year10000000_1000": false,
    "year100000000_1000": false,
    "year1_10000": false,
    "year10_10000": false,
    "year100_10000": false,
    "year1000_10000": false,
    "year10000_10000": false,
    "year100000_10000": false,
    "year1000000_10000": false,
    "year10000000_10000": false,
    "year100000000_10000": false,
    "year2_10": false,
    "year2_100": false,
    "year2_1000": false,
    "year2_10000": false,
    "year3_10": false,
    "year3_100": false,
    "year3_1000": false,
    "year3_10000": false,
    "year4_10": false,
    "year4_100": false,
    "year4_1000": false,
    "year4_10000": false,
    "year5_10": false,
    "year5_100": false,
    "year5_1000": false,
    "year5_10000": false,
    "year6_10": false,
    "year6_100": false,
    "year6_1000": false,
    "year6_10000": false,
    "year7_10": false,
    "year7_100": false,
    "year7_1000": false,
    "year7_10000": false,
    "year8_10": false,
    "year8_100": false,
    "year8_1000": false,
    "year8_10000": false,
    "year9_10": false,
    "year9_100": false,
    "year9_1000": false,
    "year9_10000": false,
    "year11_10": false,
    "year11_100": false,
    "year11_1000": false,
    "year11_10000": false,
    "year12_10": false,
    "year12_100": false,
    "year12_1000": false,
    "year12_10000": false,
    "year13_10": false,
    "year13_100": false,
    "year13_1000": false,
    "year13_10000": false,
    "year14_10": false,
    "year14_100": false,
    "year14_1000": false,
    "year14_10000": false,
    "year15_10": false,
    "year15_100": false,
    "year15_1000": false,
    "year15_10000": false,
    "year16_10": false,
    "year16_100": false,
    "year16_1000": false,
    "year16_10000": false,
    "year17_10": false,
    "year17_100": false,
    "year17_1000": false,
    "year17_10000": false,
    "year18_10": false,
    "year18_100": false,
    "year18_1000": false,
    "year18_10000": false,
    "year19_10": false,
    "year19_100": false,
    "year19_1000": false,
    "year19_10000": false,
    "year20_10": false,
    "year20_100": false,
    "year20_1000": false,
    "year20_10000": false,
    "year21_10": false,
    "year21_100": false,
    "year21_1000": false,
    "year21_10000": false,
    "year22_10": false,
    "year22_100": false,
    "year22_1000": false,
    "year22_10000": false,
    "year23_10": false,
    "year23_100": false,
    "year23_1000": false,
    "year23_10000": false,
    "year24_10": false,
    "year24_100": false,
    "year24_1000": false,
    "year24_10000": false,
    "year25_10": false,
    "year25_100": false,
    "year25_1000": false,
    "year25_10000": false,
    "year26_10": false,
    "year26_100": false,
    "year26_1000": false,
    "year26_10000": false,
    "year27_10": false,
    "year27_100": false,
    "year27_1000": false,
    "year27_10000": false,
    "year28_10": false,
    "year28_100": false,
    "year28_1000": false,
    "year28_10000": false,
    "year29_10": false,
    "year29_100": false,
    "year29_1000": false,
    "year29_10000": false,
    "year30_10": false,
    "year30_100": false,
    "year30_1000": false,
    "year30_10000": false,
    "year31_10": false,
    "year31_100": false,
    "year31_1000": false,
    "year31_10000": false,
    "year32_10": false,
    "year32_100": false,
    "year32_1000": false,
    "year32_10000": false,
    "year33_10": false,
    "year33_100": false,
    "year33_1000": false,
    "year33_10000": false,
    "year34_10": false,
    "year34_100": false,
    "year34_1000": false,
    "year34_10000": false,
    "year35_10": false,
    "year35_100": false,
    "year35_1000": false,
    "year35_10000": false,
    "year36_10": false,
    "year36_100": false,
    "year36_1000": false,
    "year36_10000": false,
    "year37_10": false,
    "year37_100": false,
    "year37_1000": false,
    "year37_10000": false,
    "world_boss_1st": false,
    "world_boss_top5": false,
    "world_boss_top10": false,
    "world_boss_participant": false,
    
        // 转生成就
        reincarnation_10: false,
        reincarnation_100: false,
        reincarnation_1000: false,
        reincarnation_10000: false
                        },
                        actionLogs: [], // 新增：统一存储所有操作日志
                        goldLogs: [], // 保留原有金币日志（如果仍需单独使用）
                        autoBuy: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], // 对应 7 种宝箱的自动购买状态
                        autoBuyMaterialChest: false, // 新增：自动购买材料宝箱的状态
                      autoBuyTechniqueChest: false,
                     autoBuyTechniqueMaxCost: 1,
                        gpsMultiplier: 1,
                        clickMultiplier: 1,
                        autoConvert: false,
                        autoConvertCurrency: { gold: false, diamond: false, titanium: false, starstone: false }, // 新增：自动兑换货币状态
                        clickTimestamps: [],
                        chestCounts: { common: 0, advanced: 0, rare: 0, epic: 0, legendary: 0 },
                        reincarnationStats: {
                            gpsBonus: { level: 0, cost: 1 },
                            equipmentLevelBonus: { level: 0, cost: 1 },
                            clickLimitBonus: { level: 0, cost: 1 }
                        },
                        materialChestCost: 1,
                        stockData: { // 新增股票数据
                            stocks: [
                                { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                                { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                                { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                                { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                                { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
                            ],
                            lastStockUpdate: Date.now()
                        },
                        lotteryResults: [], // 新增：彩票开奖结果
                        traditionalLotteryNumbers: [], // 新增：传统数字彩票号码
                        lastLotteryDraw: Date.now(), // 新增：上次开奖时间
                        bank: { // 新增银行系统
                            deposit: 0, // 存款金额
                            lastInterestUpdate: Date.now() // 上次利息计算时间
                        }
                    };
                    updateDisplay();
                    logAction('游戏已重置', 'success');
                }
            });
        }

        // 自定义对话框逻辑
        function showCustomConfirm(message, callback) {
            const dialog = document.getElementById('customDialog');
            const overlay = document.getElementById('dialogOverlay');
            document.getElementById('dialogMessage').textContent = message;
            
            dialog.style.display = 'block';
            overlay.style.display = 'block';

            const confirmBtn = document.getElementById('dialogConfirm');
            const cancelBtn = document.getElementById('dialogCancel');

            const handler = (result) => {
                dialog.style.display = 'none';
                overlay.style.display = 'none';
                callback(result);
                confirmBtn.removeEventListener('click', confirmHandler);
                cancelBtn.removeEventListener('click', cancelHandler);
            };

            const confirmHandler = () => handler(true);
            const cancelHandler = () => handler(false);

            confirmBtn.addEventListener('click', confirmHandler);
            cancelBtn.addEventListener('click', cancelHandler);
        }

        function showCustomPrompt(message, callback) {
            const dialog = document.getElementById('customDialog');
            const overlay = document.getElementById('dialogOverlay');
            document.getElementById('dialogMessage').textContent = message;
            document.getElementById('dialogInput').style.display = 'block'; // 显示输入框
            document.getElementById('dialogInput').value = ''; // 清空输入框

            dialog.style.display = 'block';
            overlay.style.display = 'block';

            const confirmBtn = document.getElementById('dialogConfirm');
            const cancelBtn = document.getElementById('dialogCancel');

            const handler = (result) => {
                dialog.style.display = 'none';
                overlay.style.display = 'none';
                document.getElementById('dialogInput').style.display = 'none'; // 隐藏输入框
                callback(result);
                confirmBtn.removeEventListener('click', confirmHandler);
                cancelBtn.removeEventListener('click', cancelHandler);
            };

            const confirmHandler = () => handler(document.getElementById('dialogInput').value);
            const cancelHandler = () => handler(null);

            confirmBtn.addEventListener('click', confirmHandler);
            cancelBtn.addEventListener('click', cancelHandler);
        }

        // 游戏初始化
        loadSave();
        setInterval(() => {
    let gpsPerSecond = getTotalGPS();
    // 如果在线且开启了加速，应用100倍加成
    if (document.visibilityState === 'visible' && player.onlineBoostEnabled) {
        gpsPerSecond *= 100;
    }
    player.gold += gpsPerSecond; // 每秒增加GPS
    autoConvertCurrency(); 
  gainCultivationExp();
 setInterval(calculateNightClubIncome, 1000);
 updateLiveStreamUI();
  initAutoDecomposeUI();
    checkAutoBuy(); 
 checkAutoDecompose();
    updateStockPrices(); 
    calculateBankInterest(); 
  calculateOfflineExpeditionRewards();
   updateFundValues(); // 添加这一行 
 checkAutoReincarnation(); // 检查自动转生
 updateCompanionDisplay();
 updateLotteryCountdown();
 updateDisplay();
   if (player.battle.maxStage > 10500) {
        localStorage.removeItem('goldGameSave');
        player = {
                        gold: 0,
                        diamond: 0,
                        titanium: 0,
                        starstone: 0,
                        cosmicstone: 0,
                        superstone: 0,
                        otherworldstone: 0, 
                        xingjiestone: 0, 
                        hundunstone: 0,  
                        lingtone: 0,
                        huangtone: 0,
                        mingtone: 0,
                        xutong: 0,
                        shitone: 0,
                        weitone: 0,
                        reincarnationCoin: 0,
                        reincarnationCount: 0,
                        equipment: [],
                        vip: {
        level: 1,
        power: 0, // 累计VIP能力值数量
    },
                        items: {
                            primaryGem: 0,
                            advancedGem: 0,
                            superiorGem: 0,
                            divineGem: 0,
                            vipPower: 0,
                            refineStone: 0 // 新增洗炼石
                        },
                        collections: {
                            lightSpeedHand: 0,
                            empHand: 0,
                            godlyHand: 0,
                            quickHand: 0,
                            shadowHand: 0,
                            quantumHand: 0,
                            lightningHand: 0,
                            divineHand: 0
                        },
                        pets: {
                             thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
                             chaosTaotie: { level: 0, cost: 1, multiplier: 0.30 },
                             netherQiongqi: { level: 0, cost: 1, multiplier: 0.90 },
                             abyssKun: { level: 0, cost: 1, multiplier: 2.70 },
                             primordialZhuLong: { level: 0, cost: 1, multiplier: 8.10 },
                            wanJunSuanNi: { level: 0, cost: 1, multiplier: 24.30 },
                            yanYuBiAn: { level: 0, cost: 1, multiplier: 72.90 },
                            yuyu1: { level: 0, cost: 1, multiplier: 218.70 },
                              yuyu2: { level: 0, cost: 1, multiplier: 656.10 },
                            yuyu3: { level: 0, cost: 1, multiplier: 1968.30 },
                              yuyu4: { level: 0, cost: 1, multiplier: 5904.90 },
                            yuyu5: { level: 0, cost: 1, multiplier: 17714.70 },
                            yuyu6: { level: 0, cost: 1, multiplier: 53144.10 },
                              yuyu7: { level: 0, cost: 1, multiplier: 159432.30 },
                            yuyu8: { level: 0, cost: 1, multiplier: 478296.90 }
                        },
                        dungeonEquipment: [], // 新增副本装备
                        soulRings: [], // 新增魂环系统
                        techniques: {},
                        attributes: {
                         totalPoints: 0,
                        remainingPoints: 0,
                        health: 0,
                        attack: 0,
                        critRate: 0,
                         critDamage: 0,
                       multiAttack: 0,
                         block: 0
                        },
                        lastUpdate: Date.now(),
                        achievements: {
        first_equipment: false,
        first_rare: false,
        first_epic: false,
        first_legendary: false,
        first_ancient: false,
        first_divine: false,
        first_arcane: false,
        first_celestial: false,
        first_infernal: false,
        first_astral: false,
        first_primeval: false,
        first_transcendental: false,
        first_quantum: false,
        first_ultimate: false,
        first_chaos: false,
        first_eternal: false,
        first_void: false,
        first_genesis: false,
        first_divineRealm: false,
        first_apocalypse: false,
        first_yeyu1: false,
        first_yeyu2: false,
        first_yeyu3: false,
        first_yeyu4: false,
        first_yeyu5: false,
        first_yeyu6: false,
        first_yeyu7: false,
        first_yeyu8: false,
        first_yeyu9: false,
        first_yeyu10: false,
        first_yeyu11: false,
        first_yeyu12: false,
        first_yeyu13: false,
        first_yeyu14: false,
        first_yeyu15: false,
        first_yeyu16: false,
        first_yeyu17: false,
        first_yeyu18: false,
        first_yeyu19: false,
        first_yeyu20: false,
        first_yeyu21: false,
        first_yeyu22: false,
        first_yeyu23: false,
        first_yeyu24: false,
        // 宝箱成就
        common_chest_100: false,
        common_chest_10000: false,
        common_chest_1000000: false,
        common_chest_10000000: false,
        common_chest_100000000: false,
        advanced_chest_100: false,
        advanced_chest_10000: false,
        advanced_chest_1000000: false,
        advanced_chest_10000000: false,
        advanced_chest_100000000: false,
        rare_chest_100: false,
        rare_chest_10000: false,
        rare_chest_1000000: false,
        rare_chest_10000000: false,
        rare_chest_100000000: false,
        epic_chest_100: false,
        epic_chest_10000: false,
        epic_chest_1000000: false,
        epic_chest_10000000: false,
        epic_chest_100000000: false,
        legendary_chest_100: false,
        legendary_chest_10000: false,
        legendary_chest_1000000: false,
        legendary_chest_10000000: false,
        legendary_chest_100000000: false,
        chaos_chest_100: false,
        chaos_chest_10000: false,
        chaos_chest_1000000: false,
        chaos_chest_10000000: false,
        chaos_chest_100000000: false,
        apocalypse_chest_100: false,
        apocalypse_chest_10000: false,
        apocalypse_chest_1000000: false,
        apocalypse_chest_10000000: false,
        apocalypse_chest_100000000: false,
        yeyu1_chest_100: false,
        yeyu1_chest_10000: false,
        yeyu1_chest_1000000: false,
        yeyu1_chest_10000000: false,
        yeyu1_chest_100000000: false,
        yeyu2_chest_100: false,
        yeyu2_chest_10000: false,
        yeyu2_chest_1000000: false,
        yeyu2_chest_10000000: false,
        yeyu2_chest_100000000: false,
        yeyu3_chest_100: false,
        yeyu3_chest_10000: false,
        yeyu3_chest_1000000: false,
        yeyu3_chest_10000000: false,
        yeyu3_chest_100000000: false,
        yeyu4_chest_100: false,
        yeyu4_chest_10000: false,
        yeyu4_chest_1000000: false,
        yeyu4_chest_10000000: false,
        yeyu4_chest_100000000: false,
        yeyu5_chest_100: false,
        yeyu5_chest_10000: false,
        yeyu5_chest_1000000: false,
        yeyu5_chest_10000000: false,
        yeyu5_chest_100000000: false,
        yeyu6_chest_100: false,
        yeyu6_chest_10000: false,
        yeyu6_chest_1000000: false,
        yeyu6_chest_10000000: false,
        yeyu6_chest_100000000: false,
        yeyu7_chest_100: false,
        yeyu7_chest_10000: false,
        yeyu7_chest_1000000: false,
        yeyu7_chest_10000000: false,
        yeyu7_chest_100000000: false,
        yeyu8_chest_100: false,
        yeyu8_chest_10000: false,
        yeyu8_chest_1000000: false,
        yeyu8_chest_10000000: false,
        yeyu8_chest_100000000: false,
        "max_stage_10": false,
    "max_stage_30": false,
    "max_stage_60": false,
    "max_stage_90": false,
    "max_stage_120": false,
    "max_stage_200": false,
    "max_stage_300": false,
    "max_stage_400": false,
    "max_stage_500": false,
    "max_stage_600": false,
    "max_stage_700": false,
    "max_stage_800": false,
    "max_stage_900": false,
    "max_stage_1000": false,

    // 新增宠物成就状态
    "thunderKirin_10": false,
    "thunderKirin_50": false,
    "thunderKirin_100": false,
    "chaosTaotie_10": false,
    "chaosTaotie_50": false,
    "chaosTaotie_100": false,
    "netherQiongqi_10": false,
    "netherQiongqi_50": false,
    "netherQiongqi_100": false,
    "abyssKun_10": false,
    "abyssKun_50": false,
    "abyssKun_100": false,
    "primordialZhuLong_10": false,
    "primordialZhuLong_50": false,
    "primordialZhuLong_100": false,
    "wanJunSuanNi_10": false,
    "wanJunSuanNi_50": false,
    "wanJunSuanNi_100": false,
    "yanYuBiAn_10": false,
    "yanYuBiAn_50": false,
    "yanYuBiAn_100": false,
    "yuyu1_10": false,
    "yuyu1_50": false,
    "yuyu1_100": false,
    "yuyu2_10": false,
    "yuyu2_50": false,
    "yuyu2_100": false,
    "yuyu3_10": false,
    "yuyu3_50": false,
    "yuyu3_100": false,
    "yuyu4_10": false,
    "yuyu4_50": false,
    "yuyu4_100": false,
    "yuyu5_10": false,
    "yuyu5_50": false,
    "yuyu5_100": false,
    "yuyu6_10": false,
    "yuyu6_50": false,
    "yuyu6_100": false,
    "yuyu7_10": false,
    "yuyu7_50": false,
    "yuyu7_100": false,
    "yuyu8_10": false,
    "yuyu8_50": false,
    "yuyu8_100": false,
    // 新增魂环成就状态
    "year1_10": false,
    "year10_10": false,
    "year100_10": false,
    "year1000_10": false,
    "year10000_10": false,
    "year100000_10": false,
    "year1000000_10": false,
    "year10000000_10": false,
    "year100000000_10": false,
    "year1_100": false,
    "year10_100": false,
    "year100_100": false,
    "year1000_100": false,
    "year10000_100": false,
    "year100000_100": false,
    "year1000000_100": false,
    "year10000000_100": false,
    "year100000000_100": false,
    "year1_1000": false,
    "year10_1000": false,
    "year100_1000": false,
    "year1000_1000": false,
    "year10000_1000": false,
    "year100000_1000": false,
    "year1000000_1000": false,
    "year10000000_1000": false,
    "year100000000_1000": false,
    "year1_10000": false,
    "year10_10000": false,
    "year100_10000": false,
    "year1000_10000": false,
    "year10000_10000": false,
    "year100000_10000": false,
    "year1000000_10000": false,
    "year10000000_10000": false,
    "year100000000_10000": false,
    "year2_10": false,
    "year2_100": false,
    "year2_1000": false,
    "year2_10000": false,
    "year3_10": false,
    "year3_100": false,
    "year3_1000": false,
    "year3_10000": false,
    "year4_10": false,
    "year4_100": false,
    "year4_1000": false,
    "year4_10000": false,
    "year5_10": false,
    "year5_100": false,
    "year5_1000": false,
    "year5_10000": false,
    "year6_10": false,
    "year6_100": false,
    "year6_1000": false,
    "year6_10000": false,
    "year7_10": false,
    "year7_100": false,
    "year7_1000": false,
    "year7_10000": false,
    "year8_10": false,
    "year8_100": false,
    "year8_1000": false,
    "year8_10000": false,
    "year9_10": false,
    "year9_100": false,
    "year9_1000": false,
    "year9_10000": false,
    "year11_10": false,
    "year11_100": false,
    "year11_1000": false,
    "year11_10000": false,
    "year12_10": false,
    "year12_100": false,
    "year12_1000": false,
    "year12_10000": false,
    "year13_10": false,
    "year13_100": false,
    "year13_1000": false,
    "year13_10000": false,
    "year14_10": false,
    "year14_100": false,
    "year14_1000": false,
    "year14_10000": false,
    "year15_10": false,
    "year15_100": false,
    "year15_1000": false,
    "year15_10000": false,
    "year16_10": false,
    "year16_100": false,
    "year16_1000": false,
    "year16_10000": false,
    "year17_10": false,
    "year17_100": false,
    "year17_1000": false,
    "year17_10000": false,
    "year18_10": false,
    "year18_100": false,
    "year18_1000": false,
    "year18_10000": false,
    "year19_10": false,
    "year19_100": false,
    "year19_1000": false,
    "year19_10000": false,
    "year20_10": false,
    "year20_100": false,
    "year20_1000": false,
    "year20_10000": false,
    "year21_10": false,
    "year21_100": false,
    "year21_1000": false,
    "year21_10000": false,
    "year22_10": false,
    "year22_100": false,
    "year22_1000": false,
    "year22_10000": false,
    "year23_10": false,
    "year23_100": false,
    "year23_1000": false,
    "year23_10000": false,
    "year24_10": false,
    "year24_100": false,
    "year24_1000": false,
    "year24_10000": false,
    "year25_10": false,
    "year25_100": false,
    "year25_1000": false,
    "year25_10000": false,
    "year26_10": false,
    "year26_100": false,
    "year26_1000": false,
    "year26_10000": false,
    "year27_10": false,
    "year27_100": false,
    "year27_1000": false,
    "year27_10000": false,
    "year28_10": false,
    "year28_100": false,
    "year28_1000": false,
    "year28_10000": false,
    "year29_10": false,
    "year29_100": false,
    "year29_1000": false,
    "year29_10000": false,
    "year30_10": false,
    "year30_100": false,
    "year30_1000": false,
    "year30_10000": false,
    "year31_10": false,
    "year31_100": false,
    "year31_1000": false,
    "year31_10000": false,
    "year32_10": false,
    "year32_100": false,
    "year32_1000": false,
    "year32_10000": false,
    "year33_10": false,
    "year33_100": false,
    "year33_1000": false,
    "year33_10000": false,
    "year34_10": false,
    "year34_100": false,
    "year34_1000": false,
    "year34_10000": false,
    "year35_10": false,
    "year35_100": false,
    "year35_1000": false,
    "year35_10000": false,
    "year36_10": false,
    "year36_100": false,
    "year36_1000": false,
    "year36_10000": false,
    "year37_10": false,
    "year37_100": false,
    "year37_1000": false,
    "year37_10000": false,
    "world_boss_1st": false,
    "world_boss_top5": false,
    "world_boss_top10": false,
    "world_boss_participant": false,
    
        // 转生成就
        reincarnation_10: false,
        reincarnation_100: false,
        reincarnation_1000: false,
        reincarnation_10000: false
                        },
                        actionLogs: [], // 新增：统一存储所有操作日志
                        goldLogs: [], // 保留原有金币日志（如果仍需单独使用）
                        autoBuy: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], // 对应 7 种宝箱的自动购买状态
                        autoBuyMaterialChest: false, // 新增：自动购买材料宝箱的状态
                      autoBuyTechniqueChest: false,
                      autoBuyTechniqueMaxCost: 1,
                        gpsMultiplier: 1,
                        clickMultiplier: 1,
                        autoConvert: false,
                        autoConvertCurrency: { gold: false, diamond: false, titanium: false, starstone: false }, // 新增：自动兑换货币状态
                        clickTimestamps: [],
                        chestCounts: { common: 0, advanced: 0, rare: 0, epic: 0, legendary: 0 },
                        reincarnationStats: {
                            gpsBonus: { level: 0, cost: 1 },
                            equipmentLevelBonus: { level: 0, cost: 1 },
                            clickLimitBonus: { level: 0, cost: 1 }
                        },
                        materialChestCost: 1,
                        stockData: { // 新增股票数据
                            stocks: [
                                { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                                { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                                { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                                { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                                { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
                            ],
                            lastStockUpdate: Date.now()
                        },
                        lotteryResults: [], // 新增：彩票开奖结果
                        traditionalLotteryNumbers: [], // 新增：传统数字彩票号码
                        lastLotteryDraw: Date.now(), // 新增：上次开奖时间
                        bank: { // 新增银行系统
                            deposit: 0, // 存款金额
                            lastInterestUpdate: Date.now() // 上次利息计算时间
                        }
        };
        updateDisplay();
        logAction('游戏已自动重置', 'success');
    }
}, 1000);
        updateDisplay();

        // 页面可见性监听
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                loadSave();
                updateDisplay();
            }
        });

        // 新增：切换游戏日志分页
        function switchLogTab(page) {
            document.getElementById('gameLogPage1').classList.remove('active');
            document.getElementById('gameLogPage2').classList.remove('active');
            document.getElementById('gameLogPage3').classList.remove('active');
            document.getElementById('gameLogPage4').classList.remove('active');
            document.getElementById(`gameLogPage${page}`).classList.add('active');
            document.querySelectorAll('.log-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.log-tab[onclick="switchLogTab(${page})"]`).classList.add('active');
        }
   function toggleAutoConvertUI() {
    const ui = document.getElementById('autoConvertUI');
    const overlay = document.getElementById('autoConvertOverlay');
    
    if (ui.style.display === 'none') {
        ui.style.display = 'block';
        overlay.style.display = 'block';
    } else {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    }
}
function toggleAutoBuyShopa() {
      if (player.level.ascentionCounta < 1) {
        alert("需要达到轮回1转才能开启轮回副本！");
        return;
    }
    const shop = document.getElementById('autoBuyShopa');
    shop.style.display = shop.style.display === 'none' ? 'block' : 'none';
}
function toggleAutoBuyShop() {
    const shop = document.getElementById('autoBuyShop');
    shop.style.display = shop.style.display === 'none' ? 'block' : 'none';
}
function toggleShopUI() {
    const shopUI = document.getElementById('shopUI');
    const overlay = document.getElementById('shopOverlay');
    
    if (shopUI.style.display === 'none') {
        shopUI.style.display = 'block';
        overlay.style.display = 'block';
    } else {
        shopUI.style.display = 'none';
        overlay.style.display = 'none';
    }
}
function toggleSettingsUI() {
    const dialog = document.getElementById('settingsDialog');
    const overlay = document.getElementById('settingsOverlay');
    
    if (dialog.style.display === 'none') {
        dialog.style.display = 'block';
        overlay.style.display = 'block';
    } else {
        dialog.style.display = 'none';
        overlay.style.display = 'none';
    }
}

        // 新增：打怪模式逻辑
        function toggleMonsterUI() {
        // 检查转生次数是否达到1次
    if (player.reincarnationCount < 1) {
        alert("需要达到1转才能开启打怪模式！");
        return;
    }
    const monsterUI = document.getElementById('monsterUI');
    monsterUI.style.display = monsterUI.style.display === 'none' ? 'block' : 'none';
    if (monsterUI.style.display === 'block') {
        // 重新生成玩家属性，但不重新生成怪物
        player.battle.playerHealth = player.reincarnationCount;
        player.battle.playerAttack = getTotalClickValue();
      updateOfficialSystemDisplay();
        updateMonsterUI(); // 更新UI显示
      updatePlayerBattleStats();
      
    }
}

        function startBattle() {
    player.battle.playerHealth = 1 + player.reincarnationCount;
    player.battle.playerAttack = 1 + getTotalClickValue();
    player.battle.playerCritRate = 0.1 + player.attributes.critRate * 0.0005; // 初始暴击率 + 属性加成
    player.battle.playerCritDamage = 1.5 + player.attributes.critDamage * 0.005; // 初始爆伤 + 属性加成
    player.battle.currentStage = player.battle.currentStage || 0;
    player.battle.maxStage = Math.max(player.battle.maxStage, player.battle.currentStage);
   updateOfficialSystemDisplay();
    updateMonsterUI(); // 更新UI显示
}

        const monsterModifiers = {
    // 防御类词条
    "硬化": { damageReduction: 0.9 }, // 受到伤害减少10%
    "钢铁": { damageReduction: 0.99 }, // 受到伤害减少20%
    "金身": { damageReduction: 0.999 }, // 受到伤害减少50%
    "不败": { damageReduction: 0.9999 }, // 受到伤害减少70%
    "圣体": { damageReduction: 0.99999 }, // 受到伤害减少80%
    "不死": { damageReduction: 0.999999 }, // 受到伤害减少99%

    // 攻击类词条
    "强击": { attackMultiplier: 2.10 }, 
    "突击": { attackMultiplier: 3.20 }, 
    "嗜血": { attackMultiplier: 4.30 }, 
    "炼狱": { attackMultiplier: 5.40 }, 
    "修罗": { attackMultiplier: 6.50 }, 
    "死神": { attackMultiplier: 10.00 }, 

    // 闪避类词条
    "初级闪避": { dodgeChance: 0.5 },
    "中级闪避": { dodgeChance: 0.6 }, 
    "高级闪避": { dodgeChance: 0.7 }, 
    "终极闪避": { dodgeChance: 0.8 }, 
    "神级闪避": { dodgeChance: 0.9 }, 

    // 特殊效果类词条
    "抵消": { blockCount: 2 }, // 可以抵消玩家2次攻击
    "金光": { blockCount: 3 }, // 可以抵消玩家3次攻击
    "神盾": { blockCount: 5 }, // 可以抵消玩家5次攻击

    // 特殊攻击类词条
    "连击": { attackCount: 3 }, // 攻击5次
    "虚弱": { damageTakenMultiplier: 1.50 } // 受到玩家伤害增加50%
};
 
const monsterRankModifiers = {
    "普通": { pool: ["硬化", "强击", "初级闪避", "虚弱"], selectCount: 2 },
    "精英": { pool: ["连击", "硬化", "强击", "初级闪避"], selectCount: 2 },
    "普通BOSS": { pool: ["虚弱", "连击", "钢铁", "突击", "初级闪避"], selectCount: 3 },
    "特殊BOSS": { pool: ["连击",  "钢铁", "突击", "中级闪避"], selectCount: 3 },
    "领主BOSS": { pool: ["连击", "钢铁", "突击", "嗜血", "中级闪避", "抵消"], selectCount: 4 },
    "霸主级BOSS": { pool: ["金身", "连击", "嗜血", "突击", "中级闪避", "抵消"], selectCount: 4 },
    "王级BOSS": { pool: ["连击", "金身", "炼狱", "嗜血", "高级闪避", "抵消"], selectCount: 4 },
    "皇级BOSS": { pool: ["连击", "不败", "炼狱", "高级闪避", "抵消"], selectCount: 4 },
    "帝级BOSS": { pool: ["连击", "不败", "炼狱", "修罗", "高级闪避", "金光"], selectCount: 4 },
    "神级BOSS": { pool: ["连击", "圣体", "修罗", "终极闪避", "金光", "死神"], selectCount: 5 },
    "圣级BOSS": { pool: ["连击", "不死", "死神", "神级闪避", "神盾"], selectCount: 5 }
};
 const monsterNames = [
    "夜叉丸", "玄天青龙帝", "九幽冥凤尊", "太虚剑仙·凌霄", "紫微星君·太华",
    "黄泉引渡使", "焚天炎龙圣主", "噬魂夜叉皇", "青丘九尾天狐", "白骨夫人·夜魅",
    "天河银蛟龙王", "幽冥骑士·龙煞", "永恒梦魇·修普诺斯", "幽冥鬼判·玄煞", "金翅大鹏明王",
    "天启四骑士·天罚", "混沌主宰", "哥布林", "太虚剑灵", "月宫蟾仙",
    "九幽煞魔", "幽冥鬼王", "幽狱魔尊", "混元道傀", "八荒龙神",
    "炎阳帝君", "星垣神王", "黄金狮心王·理查德", "幽冥鬼判·玄煞", "金翅大鹏明王",
    "玉虚雷神将", "鸿蒙祖神", "玄天帝君", "风暴之眼", "暗月武士·凯恩",
    "黑丝女神·闫闫", "萝莉·茶茶", "修罗刀魔·无间", "机械降神·欧米茄", "光年守望者·天狼",
    "寒冰之魂", "血月狼王·芬里尔", "永恒黑暗·厄瑞玻斯", "虚数之龙·阿莱夫", "数据化身·尼奥"
];

function getRandomMonsterName() {
    return monsterNames[Math.floor(Math.random() * monsterNames.length)];
}

function generateMonster() {
    const stage = player.battle.currentStage;
    const monsterRanks = ['普通', '精英', '普通BOSS', '特殊BOSS', '领主BOSS', '霸主级BOSS', '王级BOSS', '皇级BOSS', '帝级BOSS', '神级BOSS', '圣级BOSS'];
    const rankProbabilities = [0.45, 0.20, 0.10, 0.06, 0.05, 0.04, 0.03, 0.03, 0.02, 0.015, 0.005];

    // 随机生成怪物品阶
    let rankIndex = 0;
    let rand = Math.random();
    for (let i = 0; i < rankProbabilities.length; i++) {
        rand -= rankProbabilities[i];
        if (rand < 0) {
            rankIndex = i;
            break;
        }
    }
    const rank = monsterRanks[rankIndex];

    // 根据品阶选择词条
    const modifierPool = monsterRankModifiers[rank].pool;
    const selectCount = monsterRankModifiers[rank].selectCount;
    const selectedModifiers = [];
    const usedModifiers = new Set(); // 用于记录已经使用的词条

    for (let i = 0; i < selectCount; i++) {
        let modifier;
        do {
            modifier = modifierPool[Math.floor(Math.random() * modifierPool.length)];
        } while (usedModifiers.has(modifier)); // 确保词条不重复
        usedModifiers.add(modifier); // 记录已使用的词条
        selectedModifiers.push(modifier);
    }

    // 计算怪物属性
    const healthMultiplier = Math.pow(1.148698355, stage);
    let attackMultiplier;
    if (stage <= 5) {
        attackMultiplier = Math.floor(Math.random() * 3) + 10;
    } else if (stage <= 15) {
        attackMultiplier = 35 + (stage - 4) * 100;
    } else if (stage <= 100) {
        attackMultiplier = 50 + (stage - 14) * 1000;
    } else if (stage <= 300) {
        attackMultiplier = 100 + (stage - 99) * 10000;
    } else if (stage <= 500) {
        attackMultiplier = 350 + (stage - 299) * 100000;
    } else if (stage <= 750) {
        attackMultiplier = 3500 + (stage - 499) * 1e9;
    } else if (stage <= 1000) {
        attackMultiplier = 35000 + (stage - 749) * 1e12;
    } else if (stage <= 1250) {
        attackMultiplier = 350000 + (stage - 999) * 1e15;
    } else if (stage <= 1500) {
        attackMultiplier = 3500000 + (stage - 1249) * 1e20;
    } else if (stage <= 1750) {
        attackMultiplier = 450000000 + (stage - 1499) * 1e25;
    } else if (stage <= 2000) {
        attackMultiplier = 5500009000 + (stage - 1749) * 1e30;
    } else if (stage <= 2250) {
        attackMultiplier = 650000000900 + (stage - 1999) * 1e60;
    } else if (stage <= 2500) {
        attackMultiplier = 6500000000900 + (stage - 2249) * 1e90;
     } else if (stage <= 2750) {
        attackMultiplier = 6500000000000900 + (stage - 2449) * 1e120;
     } else if (stage <= 3000) {
        attackMultiplier = 6500000000000000900 + (stage - 2749) * 1e150;
    } else if (stage <= 3250) {
        attackMultiplier = 65000000000000000000900 + (stage - 2999) * 1e180;
    } else if (stage <= 3500) {
        attackMultiplier = 6500000000000000000000000900 + (stage - 3249) * 1e210;
    } else if (stage <= 4000) {
        attackMultiplier = 10000000000000000000000000000000 + (stage - 3499) * 1e230;
    } else if (stage <= 4500) {
        attackMultiplier = 100000000000000000000000000000000000 + (stage - 3999) * 1e250;
    } else {
        attackMultiplier = 1000000000000000000000000000000000000000 + (stage - 4000) * 1e270;
    }

    // 应用词条效果
    let attack = attackMultiplier;
    let damageReduction = 0;
    let dodgeChance = 0;
    let blockCount = 0;
    let attackCount = 1;
    let damageTakenMultiplier = 1;

    selectedModifiers.forEach(modifier => {
        const effect = monsterModifiers[modifier];
        if (effect.attackMultiplier) attack *= effect.attackMultiplier;
        if (effect.damageReduction) damageReduction += effect.damageReduction;
        if (effect.dodgeChance) dodgeChance += effect.dodgeChance;
        if (effect.blockCount) blockCount += effect.blockCount;
        if (effect.attackCount) attackCount = effect.attackCount;
        if (effect.damageTakenMultiplier) damageTakenMultiplier *= effect.damageTakenMultiplier;
    });

    // 生成怪物
    player.battle.monster = {
        name: `${getRandomMonsterName()}             等级${stage  * 2 + 7}`, // 随机生成怪物名字
        rank: rank,
        health: 10000 * healthMultiplier,
        attack: attack,
        modifiers: selectedModifiers,
        damageReduction: damageReduction,
        dodgeChance: dodgeChance,
        blockCount: blockCount,
        attackCount: attackCount,
        damageTakenMultiplier: damageTakenMultiplier
    };
}

       function updateMonsterUI() {
    document.getElementById('playerHealth').textContent = player.battle.playerHealth.toExponential(3);
    document.getElementById('playerAttack').textContent = player.battle.playerAttack.toExponential(3);
    document.getElementById('playerCritRate').textContent = `${((player.battle.playerCritRate + player.attributes.critRate * 0.0005) * 100).toFixed(1)}%`; // 更新暴击率显示
    document.getElementById('playerCritDamage').textContent = `${((player.battle.playerCritDamage + player.attributes.critDamage * 0.005) * 100).toFixed(1)}%`; // 更新爆伤显示
    document.getElementById('playerAccuracy').textContent = `${(player.battle.playerAccuracy * 100).toFixed(1)}%`;
    document.getElementById('playerDodge').textContent = `${(player.battle.playerDodge * 100).toFixed(1)}%`;

    document.getElementById('currentStage').textContent = player.battle.currentStage + 1;
    document.getElementById('monsterName').textContent = player.battle.monster.name;
    document.getElementById('monsterRank').textContent = player.battle.monster.rank;
    document.getElementById('monsterHealth').textContent = player.battle.monster.health.toExponential(3);
    document.getElementById('monsterAttack').textContent = player.battle.monster.attack.toExponential(3);

    // 显示怪物词条
    const modifiers = player.battle.monster.modifiers.join(', ');
    document.getElementById('monsterModifiers').textContent = ` ${modifiers}`;
     
}
       function attackMonster() {
const now = Date.now();
            // 移除超过1秒的点击记录
            player.clickTimestamps = player.clickTimestamps.filter(timestamp => now - timestamp < 1000);

            const clickLimit = 10 + player.reincarnationStats.clickLimitBonus.level; // 每级增加1次点击上限
            if (player.clickTimestamps.length >= clickLimit) {
                logAction("点击速度过快，请稍后再试！", "error");
                return;
            }

            player.clickTimestamps.push(now);
    const monster = player.battle.monster;
    
    // 应用属性加成
    const playerAttack = player.battle.playerAttack;
    const playerCritRate = player.battle.playerCritRate;
    const playerCritDamage = player.battle.playerCritDamage;
    const playerMultiAttack = player.battle.playerMultiAttack;
    const playerBlock = Math.floor(player.attributes.block / 5000000); // 每5000000点抵消属性点抵消1次攻击

    // 新增：统计变量
    let totalDamage = 0;           // 总伤害
    let dodgeCount = 0;            // 闪避次数
    let critCount = 0;             // 暴击次数
    let normalDamage = 0;          // 普通伤害总和
    const totalAttacks = playerMultiAttack + 1; // 总连击次数

    // 连击次数
    for (let i = 0; i < totalAttacks; i++) {
        // 计算命中
        if (Math.random() < monster.dodgeChance) {
            dodgeCount++; // 记录闪避次数
            continue;
        }

        // 计算伤害
        let damage = playerAttack * monster.damageTakenMultiplier;
        damage *= (1 - monster.damageReduction); // 应用伤害减免

        // 抵消效果
        if (monster.blockCount > 0) {
            monster.blockCount--;
            logBattleAction(`你的攻击被抵消了！怪物剩余抵消次数：${monster.blockCount}`);
            continue;
        }

        // 暴击计算
        if (Math.random() < playerCritRate) {
            damage *= playerCritDamage; // 应用爆伤加成
            critCount++;
            totalDamage += damage;
        } else {
            normalDamage += damage;
            totalDamage += damage;
        }

        // 应用伤害
        monster.health -= damage;

        if (monster.health <= 0) {
            break; // 如果怪物被击败，跳出连击循环
        }
    }

    // 新增：输出综合攻击日志
    logBattleAction(`你造成了${totalDamage.toFixed(0)}点伤害 (${totalAttacks}连击) - 普通伤害: ${normalDamage.toFixed(0)}, 闪避x${dodgeCount} 暴击x${critCount}`);

    // 检查怪物是否被击败
    if (monster.health <= 0) {
        logBattleAction(`你击败了${monster.name}，通关第${player.battle.currentStage + 1}关！`);
        player.battle.currentStage++;
        player.battle.maxStage = Math.max(player.battle.maxStage, player.battle.currentStage);
        
        updatePlayerBattleStats();
        // 更新总属性点
        player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10;
        // 检查最大关卡成就
        checkMaxStageAchievements();
        // 新增：检查称号解锁
        checkTitleUnlocks();
        updateOfficialSystemDisplay();
        // 掉落副本装备
        dropDungeonEquipment(player.battle.currentStage);

        // 掉落魂环
        dropSoulRing(player.battle.currentStage);
       
        // 掉落道具
        dropItemsAfterBattle();
                 
        generateMonster();
    }

    updateMonsterUI();

    function checkMaxStageAchievements() {
    const maxStage = player.battle.maxStage;
    const achievements = [
        { stage: 10, key: 'max_stage_10' },
        { stage: 30, key: 'max_stage_30' },
        { stage: 60, key: 'max_stage_60' },
        { stage: 90, key: 'max_stage_90' },
        { stage: 120, key: 'max_stage_120' },
        { stage: 200, key: 'max_stage_200' },
        { stage: 300, key: 'max_stage_300' },
        { stage: 400, key: 'max_stage_400' },
        { stage: 500, key: 'max_stage_500' },
        { stage: 600, key: 'max_stage_600' },
        { stage: 700, key: 'max_stage_700' },
        { stage: 800, key: 'max_stage_800' },
        { stage: 900, key: 'max_stage_900' },
        { stage: 1000, key: 'max_stage_1000' },
    ];

    achievements.forEach(({ stage, key }) => {
        if (maxStage >= stage && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updatePlayerBattleStats();
            }
        }
    });
}
    // 怪物反击逻辑
    if (monster.health > 0) {
        for (let i = 0; i < monster.attackCount; i++) {
            if (Math.random() > player.battle.playerDodge) {
                if (playerBlock > 0) {
                    playerBlock--; // 消耗一次抵消次数
                    logBattleAction(`你抵消了怪物的攻击！剩余抵消次数：${playerBlock}`);
                } else {
                    player.battle.playerHealth -= monster.attack; // 如果没有抵消次数，玩家受到伤害
                    logBattleAction(`${monster.name}对你造成了${monster.attack.toFixed(0)}点伤害`);
                }
            } else {
                logBattleAction('你闪避了怪物的攻击！');
            }
        }
    // 检查玩家是否被击败
        if (player.battle.playerHealth <= 0) {
            logBattleAction('你被怪物击败了！');
            monster.health = 10000 * Math.pow(1.148698355, player.battle.currentStage); // 重置怪物生命
          updatePlayerBattleStats();
       updateOfficialSystemDisplay();
        }
    }

    updateMonsterUI();
}
   // 掉落道具函数
function dropItemsAfterBattle() {
    const stage = player.battle.currentStage;

    // 洗炼石掉落（30关以上0.1%概率）
    if (stage >= 30 && Math.random() < 0.0005) {
        player.items.refineStone++;
        logBattleAction('获得了洗炼石！');
    }
     if (stage >= 1 && Math.random() < 0.0001) {
        player.items.vipPower++;
        logBattleAction('获得了VIP能力值！');
    }
   if (stage >= 50 && Math.random() < 0.0005) {
        player.items.primaryGem++;
        logBattleAction('获得了初级宝石！');
    }
     if (stage >= 100 && Math.random() < 0.0005) {
        player.items.advancedGem++;
        logBattleAction('获得了高级宝石！');
    }
     if (stage >= 150 && Math.random() < 0.0005) {
        player.items.superiorGem++;
        logBattleAction('获得了极品宝石！');
    }

     if (stage >= 1 && Math.random() < 0.001) {
        player.items.rose++;
        logBattleAction('获得了玫瑰花！');
    }

     if (stage >= 200 && Math.random() < 0.0001) {
        player.items.rebornDan++;
        logBattleAction('获得了洗髓丹！');
    }

     if (stage >= 1 && Math.random() < 0.0003) {
        player.items.companionKey++;
        logBattleAction('获得了伴侣钥匙！');
    }
    // 其他道具掉落逻辑可以在这里添加
}

// 更新道具显示
function updateItemDisplay() {
    const container = document.getElementById('itemContainer');
    container.innerHTML = Object.entries(player.items)
        .map(([key, value]) => {
            const item = itemEffects[key];
            return `<div>${item.name}: ${value} - ${item.description}</div>`;
        })
        .join('');
}
        function dropDungeonEquipment(stage) {
            const dropRates = getDropRatesByStage(stage);
            const drops = [];
            for (let i = 0; i < 3; i++) {
                const rand = Math.random();
                let cumulativeProb = 0;
                for (const [rarity, prob] of Object.entries(dropRates)) {
                    cumulativeProb += prob;
                    if (rand < cumulativeProb) {
                        drops.push(rarity);
                        break;
                    }
                }
            }

            drops.forEach(rarity => {
                addDungeonEquipment(rarity);
                logBattleAction(`获得了副本装备：${dungeonEquipmentTypes[rarity].name}`);
          // 新增：检查称号解锁
            checkTitleUnlocks();
            });
        }

        function dropSoulRing(stage) {
    const soulRingDrops = [
        { minStage: 1, type: 'year1', chance: 0.02 },
        { minStage: 105, type: 'year10', chance: 0.02 },
        { minStage: 205, type: 'year100', chance: 0.02 },
        { minStage: 305, type: 'year1000', chance: 0.02 },
        { minStage: 405, type: 'year10000', chance: 0.01 },
        { minStage: 505, type: 'year10000', chance: 0.01 },
        { minStage: 605, type: 'year100000', chance: 0.01 },
        { minStage: 705, type: 'year1000000', chance: 0.01 },
        { minStage: 890, type: 'year10000000', chance: 0.01 },
        { minStage: 920, type: 'year100000000', chance: 0.01 },
        { minStage: 1040, type: 'year2', chance: 0.01 },
        { minStage: 1160, type: 'year3', chance: 0.01 },
        { minStage: 1280, type: 'year4', chance: 0.01 },
        { minStage: 1300, type: 'year5', chance: 0.01 },
        { minStage: 1420, type: 'year6', chance: 0.01 },
        { minStage: 1540, type: 'year7', chance: 0.01 },
        { minStage: 1660, type: 'year8', chance: 0.01 },
        { minStage: 1780, type: 'year9', chance: 0.01 },
        { minStage: 1800, type: 'year11', chance: 0.01 },
        { minStage: 1920, type: 'year12', chance: 0.01 },
        { minStage: 2040, type: 'year13', chance: 0.01 },
        { minStage: 2160, type: 'year14', chance: 0.01 },
        { minStage: 2280, type: 'year15', chance: 0.01 },
        { minStage: 2300, type: 'year16', chance: 0.01 },
        { minStage: 2420, type: 'year17', chance: 0.01 },
        { minStage: 2540, type: 'year18', chance: 0.01 },
        { minStage: 2660, type: 'year19', chance: 0.01 },
        { minStage: 2780, type: 'year20', chance: 0.01 },
        { minStage: 2800, type: 'year21', chance: 0.01 },
        { minStage: 2920, type: 'year22', chance: 0.01 },
        { minStage: 3040, type: 'year23', chance: 0.01 },
        { minStage: 3100, type: 'year24', chance: 0.01 },
        { minStage: 3280, type: 'year25', chance: 0.01 },
        { minStage: 3300, type: 'year26', chance: 0.01 },
        { minStage: 3420, type: 'year27', chance: 0.01 },
        { minStage: 3540, type: 'year28', chance: 0.01 },
        { minStage: 3660, type: 'year29', chance: 0.01 },
        { minStage: 3780, type: 'year30', chance: 0.01 },
        { minStage: 3800, type: 'year31', chance: 0.01 },
        { minStage: 4020, type: 'year32', chance: 0.01 },
        { minStage: 4140, type: 'year33', chance: 0.01 },
        { minStage: 4280, type: 'year34', chance: 0.01 },
        { minStage: 4300, type: 'year35', chance: 0.01 },
        { minStage: 4420, type: 'year36', chance: 0.01 },
        { minStage: 4550, type: 'year37', chance: 0.01 }
    ];

    soulRingDrops.forEach(drop => {
        if (stage >= drop.minStage && Math.random() < drop.chance) {
            addSoulRing(drop.type);
            logBattleAction(`获得了${soulRingTypes[drop.type].name}`);
          // 新增：检查称号解锁
                checkTitleUnlocks();
            // 检查成就
            const ring = player.soulRings.find(r => r.type === drop.type);
            if (ring) {
                checkSoulRingAchievements(drop.type, ring.level);
            }
        }
    });
}

       function getDropRatesByStage(stage) {
            if (stage <= 5) {
                return { common: 0.9, rare: 0.1 };
            } else if (stage <= 20) {
                return { common: 0.9, rare: 0.04, epic: 0.05, legendary: 0.01  };
            } else if (stage <= 150) {
                return { common: 0.9, rare: 0.02, epic: 0.04, legendary: 0.03, ancient: 0.01 };
            } else if (stage <= 300) {
                return { common: 0.8, epic: 0.11, legendary: 0.03, ancient: 0.03, divine: 0.02, arcane: 0.01 };
            } else if (stage <= 450) {
                return { common: 0.8, legendary: 0.05, ancient: 0.06, divine: 0.04, arcane: 0.02, celestial: 0.02, infernal: 0.01 };
            } else if (stage <= 600) {
                return { common: 0.8, ancient: 0.04, divine: 0.06, arcane: 0.04, celestial: 0.02, infernal: 0.02, astral: 0.01, primeval: 0.01 };
            } else if (stage <= 750) {
                return { common: 0.8, divine: 0.03, arcane: 0.06, celestial: 0.04, infernal: 0.02, astral: 0.02, primeval: 0.01, transcendental: 0.01, quantum: 0.01 };
            } else if (stage <= 900) {
                return { common: 0.8, celestial: 0.03, infernal: 0.06, astral: 0.04, primeval: 0.02, transcendental: 0.02, quantum: 0.01, ultimate: 0.01, ultimate1: 0.01 };
            } else if (stage <= 1050) {
                return { common: 0.8, infernal: 0.03, astral: 0.06, primeval: 0.04, transcendental: 0.02, quantum: 0.02, ultimate: 0.01, ultimate2: 0.01, ultimate3: 0.01 };
            } else if (stage <= 1200) {
                return { common: 0.8, primeval: 0.03, transcendental: 0.06, quantum: 0.04, ultimate: 0.02, ultimate1: 0.02, ultimate2: 0.01, ultimate3: 0.01, ultimate4: 0.01 };
            } else if (stage <= 1350) {
                return { common: 0.8, quantum: 0.03, ultimate: 0.06, ultimate1: 0.04, ultimate2: 0.02, ultimate3: 0.02, ultimate4: 0.01, ultimate5: 0.01, ultimate6: 0.01 };
            } else if (stage <= 1500) {
                return { common: 0.8, ultimate1: 0.03, ultimate2: 0.06, ultimate3: 0.04, ultimate4: 0.02, ultimate5: 0.02, ultimate6: 0.01, ultimate7: 0.01, ultimate8: 0.01 };
            } else if (stage <= 1650) {
                return { common: 0.8, ultimate3: 0.03, ultimate4: 0.06, ultimate5: 0.04, ultimate6: 0.02, ultimate7: 0.02, ultimate8: 0.01, ultimate9: 0.01, ultimate10: 0.01 };
            } else if (stage <= 1800) {
                return { common: 0.8, ultimate5: 0.03, ultimate6: 0.06, ultimate7: 0.04, ultimate8: 0.02, ultimate9: 0.02, ultimate10: 0.01, ultimate11: 0.01, ultimate12: 0.01 };
            } else if (stage <= 1950) {
                return { common: 0.8, ultimate7: 0.03, ultimate8: 0.06, ultimate9: 0.04, ultimate10: 0.02, ultimate11: 0.02, ultimate12: 0.01, ultimate13: 0.01, ultimate14: 0.01 };
            } else if (stage <= 2100) {
                return { common: 0.8, ultimate9: 0.03, ultimate10: 0.06, ultimate11: 0.04, ultimate12: 0.02, ultimate13: 0.02, ultimate14: 0.01, ultimate15: 0.01, ultimate16: 0.01 };
            } else if (stage <= 2250) {
                return { common: 0.8, ultimate11: 0.03, ultimate12: 0.06, ultimate13: 0.04, ultimate14: 0.02, ultimate15: 0.02, ultimate16: 0.01, ultimate17: 0.01, ultimate18: 0.011 };
            } else if (stage <= 2400) {
                return { common: 0.8, ultimate13: 0.03, ultimate14: 0.06, ultimate15: 0.04, ultimate16: 0.02, ultimate17: 0.02, ultimate18: 0.01, ultimate19: 0.01, ultimate20: 0.01 };
            } else if (stage <= 2550) {
                return { common: 0.8, ultimate15: 0.03, ultimate16: 0.06, ultimate17: 0.04, ultimate18: 0.02, ultimate19: 0.02, ultimate20: 0.01, ultimate21: 0.01, ultimate22: 0.01 };
            } else if (stage <= 2700) {
                return { common: 0.8, ultimate17: 0.03, ultimate18: 0.06, ultimate19: 0.04, ultimate20: 0.02, ultimate21: 0.02, ultimate22: 0.01, ultimate23: 0.01, ultimate24: 0.01 };
            } else if (stage <= 2850) {
                return { common: 0.8, ultimate19: 0.03, ultimate20: 0.06, ultimate21: 0.04, ultimate22: 0.02, ultimate23: 0.02, ultimate24: 0.01, ultimate25: 0.01, ultimate26: 0.01 };
            } else if (stage <= 3000) {
                return { common: 0.8, ultimate21: 0.03, ultimate22: 0.06, ultimate23: 0.04, ultimate24: 0.02, ultimate25: 0.02, ultimate26: 0.01, ultimate27: 0.01, ultimate28: 0.01 };
            } else if (stage <= 3150) {
                return { common: 0.8, ultimate23: 0.03, ultimate24: 0.06, ultimate25: 0.04, ultimate26: 0.02, ultimate27: 0.02, ultimate28: 0.01, ultimate29: 0.01, ultimate30: 0.01 };
            } else if  (stage <= 3300) {
                return { common: 0.8, ultimate25: 0.03, ultimate26: 0.06, ultimate27: 0.04, ultimate28: 0.02, ultimate29: 0.02, ultimate30: 0.01, ultimate31: 0.01, ultimate32: 0.01 };
            } else if (stage <= 3450) {
                return { common: 0.8, ultimate27: 0.03, ultimate28: 0.06, ultimate29: 0.04, ultimate30: 0.02, ultimate31: 0.02, ultimate32: 0.01, ultimate33: 0.01, ultimate34: 0.01 };
            } else if (stage <= 3600) {
                return { common: 0.8, ultimate29: 0.03, ultimate30: 0.06, ultimate31: 0.04, ultimate32: 0.02, ultimate33: 0.02, ultimate34: 0.01, ultimate35: 0.01, ultimate36: 0.01 };
            } else if (stage <= 3750) {
                return { common: 0.8, ultimate31: 0.03, ultimate32: 0.06, ultimate33: 0.04, ultimate34: 0.02, ultimate35: 0.02, ultimate36: 0.01, ultimate37: 0.01, ultimate38: 0.01 };
            } else if (stage <= 3900) {
                return { common: 0.8, ultimate33: 0.03, ultimate34: 0.06, ultimate35: 0.04, ultimate36: 0.02, ultimate37: 0.02, ultimate38: 0.01, ultimate39: 0.01, ultimate40: 0.01 };
            } else if (stage <= 4050) {
                return { common: 0.8, ultimate35: 0.03, ultimate36: 0.06, ultimate37: 0.04, ultimate38: 0.02, ultimate39: 0.02, ultimate40: 0.01, ultimate41: 0.01, ultimate42: 0.01 };
            } else if (stage <= 4200) {
                return { common: 0.8, ultimate37: 0.03, ultimate38: 0.06, ultimate39: 0.04, ultimate40: 0.02, ultimate41: 0.02, ultimate42: 0.01, ultimate43: 0.01, ultimate44: 0.01 };
            } else if (stage <= 4350) {
                return { common: 0.8, ultimate39: 0.03, ultimate40: 0.06, ultimate41: 0.04, ultimate42: 0.02, ultimate43: 0.02, ultimate44: 0.01, ultimate45: 0.01, ultimate46: 0.01 };
            } else if (stage <= 4500) {
                return { common: 0.8, ultimate41: 0.03, ultimate42: 0.06, ultimate43: 0.04, ultimate44: 0.02, ultimate45: 0.02, ultimate46: 0.01, ultimate47: 0.01, ultimate48: 0.01 };
            } else {
                return { common: 0.8, ultimate43: 0.03, ultimate44: 0.06, ultimate45: 0.04, ultimate46: 0.02, ultimate47: 0.02, ultimate48: 0.01, ultimate49: 0.01, ultimate50: 0.01 };
            }
        }


        function fleeFromBattle() {
            const cost = player.battle.maxStage * 10;
            if (player.reincarnationCoin >= cost) {
                player.reincarnationCoin -= cost;
                player.battle.currentStage = 0;
                generateMonster();
               updateOfficialSystemDisplay();
                updateMonsterUI();
                logBattleAction(`你重置了关卡，消耗了${cost}转生币`);
            } else {
                logBattleAction('转生币不足，无法重置关卡！');
            }
        }
      
        function sweepStages() {
    const currentStage = player.battle.currentStage;
    const maxStage = player.battle.maxStage;
    const targetStage = Math.max(1, maxStage - 6); // 扫荡到最大关卡-5
    
    if (currentStage >= targetStage) {
        logBattleAction("没有可扫荡的关卡！");
        return;
    }
    
    // 计算消耗的转生币
    const cost = (targetStage - currentStage) * 2;
    
    if (player.reincarnationCoin < cost) {
        logBattleAction(`扫荡需要 ${cost} 转生币，当前不足！`);
        return;
    }
    
    // 确认对话框
    showCustomConfirm(`确定要扫荡从第${currentStage + 1}关到第${targetStage}关吗？消耗 ${cost} 转生币`, (confirmed) => {
        if (confirmed) {
            player.reincarnationCoin -= cost;
            
            // 记录扫荡前的状态
            const originalStage = player.battle.currentStage;
            let totalDrops = 0;
            let dungeonEquipmentDrops = 0;
            let soulRingDrops = 0;
            let itemDrops = 0;
            
            // 模拟扫荡过程
            for (let stage = currentStage; stage < targetStage; stage++) {
                player.battle.currentStage = stage;
                
                // 固定掉落3个副本装备
                for (let i = 0; i < 3; i++) {
                    const dungeonDrops = getDropRatesByStage(stage);
                    const rand = Math.random();
                    let cumulativeProb = 0;
                    
                    for (const [rarity, prob] of Object.entries(dungeonDrops)) {
                        cumulativeProb += prob;
                        if (rand < cumulativeProb) {
                            addDungeonEquipment(rarity);
                            dungeonEquipmentDrops++;
                            break;
                        }
                    }
                }
                
                // 魂环掉落（保持原逻辑）
                const soulRingResult = simulateSoulRingDrop(stage);
                if (soulRingResult) {
                    soulRingDrops++;
                }
                
                // 道具掉落（保持原逻辑）
                const itemResult = simulateItemDrop(stage);
                if (itemResult) {
                    itemDrops++;
                }
                
                // 更新显示（每10关更新一次）
                if (stage % 10 === 0) {
                    updateMonsterUI();
                }
            }
            
            // 扫荡完成后停留在目标关卡
            player.battle.currentStage = targetStage;
            generateMonster();
            
            logBattleAction(`扫荡完成！从第${originalStage + 1}关到第${targetStage}关`);
            logBattleAction(`获得副本装备: ${dungeonEquipmentDrops}件`);
            logBattleAction(`获得魂环: ${soulRingDrops}件`);
            logBattleAction(`获得道具: ${itemDrops}件`);
            updateMonsterUI();
           updateOfficialSystemDisplay();
        }
    });
}

// 单独提取魂环掉落逻辑
function simulateSoulRingDrop(stage) {
    const soulRingDrops = [
       { minStage: 1, type: 'year1', chance: 0.02 },
        { minStage: 105, type: 'year10', chance: 0.02 },
        { minStage: 205, type: 'year100', chance: 0.02 },
        { minStage: 305, type: 'year1000', chance: 0.02 },
        { minStage: 405, type: 'year10000', chance: 0.01 },
        { minStage: 505, type: 'year10000', chance: 0.01 },
        { minStage: 605, type: 'year100000', chance: 0.01 },
        { minStage: 705, type: 'year1000000', chance: 0.01 },
        { minStage: 890, type: 'year10000000', chance: 0.01 },
        { minStage: 920, type: 'year100000000', chance: 0.01 },
        { minStage: 1040, type: 'year2', chance: 0.01 },
        { minStage: 1160, type: 'year3', chance: 0.01 },
        { minStage: 1280, type: 'year4', chance: 0.01 },
        { minStage: 1300, type: 'year5', chance: 0.01 },
        { minStage: 1420, type: 'year6', chance: 0.01 },
        { minStage: 1540, type: 'year7', chance: 0.01 },
        { minStage: 1660, type: 'year8', chance: 0.01 },
        { minStage: 1780, type: 'year9', chance: 0.01 },
        { minStage: 1800, type: 'year11', chance: 0.01 },
        { minStage: 1920, type: 'year12', chance: 0.01 },
        { minStage: 2040, type: 'year13', chance: 0.01 },
        { minStage: 2160, type: 'year14', chance: 0.01 },
        { minStage: 2280, type: 'year15', chance: 0.01 },
        { minStage: 2300, type: 'year16', chance: 0.01 },
        { minStage: 2420, type: 'year17', chance: 0.01 },
        { minStage: 2540, type: 'year18', chance: 0.01 },
        { minStage: 2660, type: 'year19', chance: 0.01 },
        { minStage: 2780, type: 'year20', chance: 0.01 },
        { minStage: 2800, type: 'year21', chance: 0.01 },
        { minStage: 2920, type: 'year22', chance: 0.01 },
        { minStage: 3040, type: 'year23', chance: 0.01 },
        { minStage: 3100, type: 'year24', chance: 0.01 },
        { minStage: 3280, type: 'year25', chance: 0.01 },
        { minStage: 3300, type: 'year26', chance: 0.01 },
        { minStage: 3420, type: 'year27', chance: 0.01 },
        { minStage: 3540, type: 'year28', chance: 0.01 },
        { minStage: 3660, type: 'year29', chance: 0.01 },
        { minStage: 3780, type: 'year30', chance: 0.01 },
        { minStage: 3800, type: 'year31', chance: 0.01 },
        { minStage: 4020, type: 'year32', chance: 0.01 },
        { minStage: 4140, type: 'year33', chance: 0.01 },
        { minStage: 4280, type: 'year34', chance: 0.01 },
        { minStage: 4300, type: 'year35', chance: 0.01 },
        { minStage: 4420, type: 'year36', chance: 0.01 },
        { minStage: 4550, type: 'year37', chance: 0.01 }
    ];
    
    for (const drop of soulRingDrops) {
        if (stage >= drop.minStage && Math.random() < drop.chance) {
            addSoulRing(drop.type);
            return true;
        }
    }
    return false;
}

// 单独提取道具掉落逻辑
function simulateItemDrop(stage) {
    let hasDropped = false;
    
    // 洗炼石掉落（1000关以上0.05%概率）
    if (stage >= 1000 && Math.random() < 0.0001) {
        player.items.refineStone++;
        hasDropped = true;
    }
    
    // VIP能力值掉落（全关卡0.1%概率）
    if (stage >= 1 && Math.random() < 0.0002) {
        player.items.vipPower++;
        hasDropped = true;
    }
    
    // 初级宝石掉落（500关以上0.04%概率）
    if (stage >= 500 && Math.random() < 0.0003) {
        player.items.primaryGem++;
        hasDropped = true;
    }
    
    // 高级宝石掉落（1000关以上0.03%概率）
    if (stage >= 1000 && Math.random() < 0.0002) {
        player.items.advancedGem++;
        hasDropped = true;
    }
    
    // 极品宝石掉落（1500关以上0.01%概率）
    if (stage >= 1500 && Math.random() < 0.0001) {
        player.items.superiorGem++;
        hasDropped = true;
    }
    
    // 玫瑰花掉落（1关以上0.05%概率）
    if (stage >= 1 && Math.random() < 0.001) {
        player.items.rose++;
        hasDropped = true;
    }
    // 洗髓丹匙掉落（2000关以上0.001%概率）
    if (stage >= 2000 && Math.random() < 0.0001) {
        player.items.rebornDan++;
        hasDropped = true;
    }
    // 洗髓丹匙掉落（1000关以上0.001%概率）
    if (stage >= 1000 && Math.random() < 0.0001) {
        player.items.baitCount++;
        hasDropped = true;
    }
    // 伴侣钥匙掉落（1关以上0.001%概率）
    if (stage >= 1 && Math.random() < 0.0001) {
        player.items.companionKey++;
        hasDropped = true;
    }
    
    return hasDropped;
}
        function jumpToStage() {
            const stage = parseInt(document.getElementById('jumpStage').value) || 0;
            if (stage > player.battle.currentStage && stage <= player.battle.maxStage && player.reincarnationCoin >= stage) {
                player.reincarnationCoin -= stage;
                player.battle.currentStage = stage;
                generateMonster();
                updateMonsterUI();
                logBattleAction(`你跳到了第${stage + 1}关`);
            } else {
                logBattleAction('无法跳到该关卡！');
            }
        }
     function formatNumber(value) {
    if (value >= 1e8) { // 当数值大于等于 100,000,000 时使用科学计数法
        return value.toExponential(3); // 保留两位小数
    } else {
        return value.toLocaleString(); // 否则使用常规的数值显示
    }
}
        function logBattleAction(message) {
    const formattedMessage = message.replace(/\d+(\.\d+)?/g, num => 
        formatSci(parseFloat(num))
    );
    
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `<div class="battle-log-entry">[${timestamp}] ${formattedMessage}</div>`;
    
    const logContainer = document.getElementById("battleLogContent");
    logContainer.insertAdjacentHTML("afterbegin", logEntry);
    
    // 保持最多20条日志
    if (logContainer.children.length > 20) {
        logContainer.removeChild(logContainer.lastChild);
    }
}
 let autoSweepInterval = null;
let isAutoSweeping = false;

// 添加自动扫荡控制函数
function toggleAutoSweep() {
    player.battle.autoSweepEnabled = !player.battle.autoSweepEnabled;
    
    // 更新UI显示
    document.getElementById('autoSweepStatus').textContent = 
        player.battle.autoSweepEnabled ? '开' : '关';
    
    // 如果开启自动扫荡，启动定时器
    if (player.battle.autoSweepEnabled) {
        startAutoSweep();
    } else {
        stopAutoSweep();
    }
    
    logAction(`自动扫荡已${player.battle.autoSweepEnabled ? '开启' : '关闭'}`, 'info');
    saveGame();
 
}

// 启动自动扫荡
function startAutoSweep() {
    // 清除现有定时器（如果有）
    stopAutoSweep();
    // 每4秒执行一次自动扫荡
    player.battle.autoSweepInterval = setInterval(autoSweepProcess, 4000);
}

// 停止自动扫荡
function stopAutoSweep() {
    if (player.battle.autoSweepInterval) {
        clearInterval(player.battle.autoSweepInterval);
        player.battle.autoSweepInterval = null;
    }
}

// 自动扫荡处理流程
function autoSweepProcess() {
    // 检查是否需要重置关卡
    if (player.battle.currentStage >= Math.max(1, player.battle.maxStage - 1)) {
        // 重置关卡到0
        player.battle.currentStage = 0;
        logBattleAction("已自动重置关卡到初始位置");
    }
    
    // 执行扫荡
    const currentStage = player.battle.currentStage;
    const maxStage = player.battle.maxStage;
    const targetStage = Math.max(1, maxStage - 1);
    
    if (currentStage >= targetStage) {
        logBattleAction("自动扫荡：没有可扫荡的关卡，将重置关卡");
        return;
    }
    
    const cost = (targetStage - currentStage) * 12;
    if (player.reincarnationCoin < cost) {
        logBattleAction(`自动扫荡：转生币不足（需要${cost}），已停止`);
        toggleAutoSweep(); // 停止自动扫荡
        return;
    }
    
    // 自动执行扫荡（无需确认）
    player.reincarnationCoin -= cost;
    
    const originalStage = player.battle.currentStage;
    let totalDrops = 0;
    let dungeonEquipmentDrops = 0;
    let soulRingDrops = 0;
    let itemDrops = 0;
    
     for (let stage = currentStage; stage < targetStage; stage++) {
        player.battle.currentStage = stage;
        
        // 固定掉落3个副本装备 - 使用静默方式添加
        for (let i = 0; i < 3; i++) {
            const dungeonDrops = getDropRatesByStage(stage);
            const rand = Math.random();
            let cumulativeProb = 0;
            
            for (const [rarity, prob] of Object.entries(dungeonDrops)) {
                cumulativeProb += prob;
                if (rand < cumulativeProb) {
                    addDungeonEquipmentSilent(rarity); // 使用静默版本
                    dungeonEquipmentDrops++;
                    break;
                }
            }
        }
        
        // 魂环掉落 - 使用静默方式
        const soulRingResult = simulateSoulRingDropSilent(stage);
        if (soulRingResult) {
            soulRingDrops++;
        }
        
      // 道具掉落 - 保持原样（如果需要也可以静默）
        const itemResult = simulateItemDrop(stage);
        if (itemResult) {
            itemDrops++;
        }
    }

    // 扫荡完成后停留在目标关卡
    player.battle.currentStage = targetStage;
    generateMonster();
    
    logBattleAction(`自动扫荡完成！从第${originalStage + 1}关到第${targetStage}关`);
    logBattleAction(`获得副本装备: ${dungeonEquipmentDrops}件，魂环: ${soulRingDrops}个，道具: ${itemDrops}个`);
      updateOfficialSystemDisplay();
        updateMonsterUI(); 
}
// 静默添加副本装备（不显示提示）
function addDungeonEquipmentSilent(rarity) {
    const config = dungeonEquipmentTypes[rarity];
    const growthRate = Math.random() * (config.growthRange[1] - config.growthRange[0]) + config.growthRange[0];

    const existingEq = player.dungeonEquipment.find(eq => eq.rarity === rarity);
    if (existingEq) {
        existingEq.quantity = (existingEq.quantity || 1) + 1;
        if (existingEq.quantity >= 3) {
            existingEq.level++;
            existingEq.quantity = 0;
        }
    } else {
        const newEq = {
            name: config.name,
            rarity: rarity,
            level: 1,
            growthRate: growthRate,
            quantity: 1
        };
        player.dungeonEquipment.push(newEq);
    }
}

// 静默添加魂环（不显示提示）
function simulateSoulRingDropSilent(stage) {
    const soulRingDrops = [
        { minStage: 1, type: 'year1', chance: 0.02 },
        { minStage: 105, type: 'year10', chance: 0.02 },
        { minStage: 205, type: 'year100', chance: 0.02 },
        { minStage: 305, type: 'year1000', chance: 0.02 },
        { minStage: 405, type: 'year10000', chance: 0.01 },
        { minStage: 505, type: 'year10000', chance: 0.01 },
        { minStage: 605, type: 'year100000', chance: 0.01 },
        { minStage: 705, type: 'year1000000', chance: 0.01 },
        { minStage: 890, type: 'year10000000', chance: 0.01 },
        { minStage: 920, type: 'year100000000', chance: 0.01 },
        { minStage: 1040, type: 'year2', chance: 0.01 },
        { minStage: 1160, type: 'year3', chance: 0.01 },
        { minStage: 1280, type: 'year4', chance: 0.01 },
        { minStage: 1300, type: 'year5', chance: 0.01 },
        { minStage: 1420, type: 'year6', chance: 0.01 },
        { minStage: 1540, type: 'year7', chance: 0.01 },
        { minStage: 1660, type: 'year8', chance: 0.01 },
        { minStage: 1780, type: 'year9', chance: 0.01 },
        { minStage: 1800, type: 'year11', chance: 0.01 },
        { minStage: 1920, type: 'year12', chance: 0.01 },
        { minStage: 2040, type: 'year13', chance: 0.01 },
        { minStage: 2160, type: 'year14', chance: 0.01 },
        { minStage: 2280, type: 'year15', chance: 0.01 },
        { minStage: 2300, type: 'year16', chance: 0.01 },
        { minStage: 2420, type: 'year17', chance: 0.01 },
        { minStage: 2540, type: 'year18', chance: 0.01 },
        { minStage: 2660, type: 'year19', chance: 0.01 },
        { minStage: 2780, type: 'year20', chance: 0.01 },
        { minStage: 2800, type: 'year21', chance: 0.01 },
        { minStage: 2920, type: 'year22', chance: 0.01 },
        { minStage: 3040, type: 'year23', chance: 0.01 },
        { minStage: 3100, type: 'year24', chance: 0.01 },
        { minStage: 3280, type: 'year25', chance: 0.01 },
        { minStage: 3300, type: 'year26', chance: 0.01 },
        { minStage: 3420, type: 'year27', chance: 0.01 },
        { minStage: 3540, type: 'year28', chance: 0.01 },
        { minStage: 3660, type: 'year29', chance: 0.01 },
        { minStage: 3780, type: 'year30', chance: 0.01 },
        { minStage: 3800, type: 'year31', chance: 0.01 },
        { minStage: 4020, type: 'year32', chance: 0.01 },
        { minStage: 4140, type: 'year33', chance: 0.01 },
        { minStage: 4280, type: 'year34', chance: 0.01 },
        { minStage: 4300, type: 'year35', chance: 0.01 },
        { minStage: 4420, type: 'year36', chance: 0.01 },
        { minStage: 4550, type: 'year37', chance: 0.01 }
    ];
    
    for (const drop of soulRingDrops) {
        if (stage >= drop.minStage && Math.random() < drop.chance) {
            addSoulRingSilent(drop.type); // 使用静默版本
            return true;
        }
    }
    return false;
}

function addSoulRingSilent(type) {
    const existing = player.soulRings.find(r => r.type === type);
    if(existing) {
        existing.level++;
    } else {
        player.soulRings.push({
            type: type,
            level: 1,
            multiplier: soulRingTypes[type].baseMult
        });
    }
}
  function addAttributePoint(attribute, amount) {
    // 计算实际要加的点数
    let pointsToAdd = 0;
    if (amount === 'all') {
        pointsToAdd = player.attributes.remainingPoints; // 全部剩余属性点
    } else {
        pointsToAdd = Math.min(amount, player.attributes.remainingPoints); // 不能超过剩余属性点
    }

    if (pointsToAdd <= 0) {
        logAction("剩余属性点不足！", "error");
        return;
    }

    // 根据属性类型加点
    switch (attribute) {
        case 'health':
            player.attributes.health += pointsToAdd;
            break;
        case 'attack':
            player.attributes.attack += pointsToAdd;
            break;
        case 'critRate':
            player.attributes.critRate += pointsToAdd;
            break;
        case 'critDamage':
            player.attributes.critDamage += pointsToAdd;
            break;
        case 'multiAttack':
            player.attributes.multiAttack += pointsToAdd;
            break;
        case 'block':
            player.attributes.block += pointsToAdd;
            break;
        default:
            logAction("无效的属性类型！", "error");
            return;
    }

    // 扣除剩余属性点
    player.attributes.remainingPoints -= pointsToAdd;

    // 更新显示
    updatePlayerAttributesDisplay();
    logAction(`成功为${attribute}属性增加${pointsToAdd}点`, 'success');
}

function resetAttributes() {
    if (player.reincarnationCoin >= 1) {
        player.reincarnationCoin -= 1;
        // 重置所有属性点
        player.attributes.health = 0;
        player.attributes.attack = 0;
        player.attributes.critRate = 0;
        player.attributes.critDamage = 0;
        player.attributes.multiAttack = 0;
        player.attributes.block = 0;
        // 重置剩余属性点 = 总属性点
        player.attributes.remainingPoints = player.attributes.totalPoints;
        updatePlayerAttributesDisplay(); // 更新显示
        logAction("属性点已重置", "success");
    } else {
        logAction("转生币不足！", "error");
    }
}

 function handleBattleResult(isVictory) {
    // 保存当前的功法加成
    const techniqueBonuses = {
        health: player.attributes.healthBonus,
        attack: player.attributes.attackBonus,
        critRate: player.attributes.critRateBonus,
        critDamage: player.attributes.critDamageBonus,
        multiAttack: player.attributes.multiAttackBonus
    };
    
    if (isVictory) {
        // 胜利逻辑...
        player.battle.currentStage++;
        player.battle.maxStage = Math.max(player.battle.maxStage, player.battle.currentStage);
    } else {
        // 失败逻辑...
        player.battle.playerHealth = player.reincarnationCount;
    }
    
    // 恢复功法加成
    player.attributes.healthBonus = techniqueBonuses.health;
    player.attributes.attackBonus = techniqueBonuses.attack;
    player.attributes.critRateBonus = techniqueBonuses.critRate;
    player.attributes.critDamageBonus = techniqueBonuses.critDamage;
    player.attributes.multiAttackBonus = techniqueBonuses.multiAttack;
    
    // 更新玩家战斗属性
    updatePlayerBattleStats();
    
}
function updatePlayerAttributesDisplay() {
    // 计算总属性点
    const totalAttributePoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
    player.attributes.totalPoints = totalAttributePoints;

    // 更新总属性点和剩余属性点
    document.getElementById("totalAttributePoints").textContent = player.attributes.totalPoints;
    document.getElementById("remainingAttributePoints").textContent = player.attributes.remainingPoints;

    // 更新各属性加成显示和已投入点数
    document.getElementById("healthBonus").textContent = 
        (player.attributes.health * 1 + player.attributes.healthBonus * 100).toFixed(2) + "%";
    document.getElementById("healthPoints").textContent = player.attributes.health;
    
    document.getElementById("attackBonus").textContent = 
        (player.attributes.attack * 1 + player.attributes.attackBonus * 100).toFixed(2) + "%";
    document.getElementById("attackPoints").textContent = player.attributes.attack;
    
    document.getElementById("critRateBonus").textContent = 
        (player.attributes.critRate * 0.05 + player.attributes.critRateBonus * 100).toFixed(3) + "%";
    document.getElementById("critRatePoints").textContent = player.attributes.critRate;
    
    document.getElementById("critDamageBonus").textContent = 
        (player.attributes.critDamage * 0.50 + player.attributes.critDamageBonus * 100).toFixed(2) + "%";
    document.getElementById("critDamagePoints").textContent = player.attributes.critDamage;
    
    document.getElementById("multiAttackBonus").textContent = 
        Math.floor(player.attributes.multiAttack / 300) + player.attributes.multiAttackBonus;
    document.getElementById("multiAttackPoints").textContent = player.attributes.multiAttack;
}
function updateTechniqueBonuses() {
    // 重置所有加成
    player.attributes.healthBonus = 0;
    player.attributes.attackBonus = 0;
    player.attributes.critRateBonus = 0;
    player.attributes.critDamageBonus = 0;
    player.attributes.multiAttackBonus = 0;
    
    // 计算所有功法提供的加成
    Object.entries(player.techniques).forEach(([type, level]) => {
        const tech = techniqueConfig[type];
        if(tech) {
            switch(tech.type) {
                case 'health':
                    player.attributes.healthBonus += level * tech.effect;
                    break;
                case 'attack':
                    player.attributes.attackBonus += level * tech.effect;
                    break;
                case 'critRate':
                    player.attributes.critRateBonus += level * tech.effect;
                    break;
                case 'critDamage':
                    player.attributes.critDamageBonus += level * tech.effect;
                    break;
                case 'multiAttack':
                    player.attributes.multiAttackBonus += Math.floor(level * tech.effect);
                    break;
            }
        }
    });
    
    // 更新玩家战斗属性
    updatePlayerBattleStats();
     updateOfficialSystemDisplay();
    updatePlayerAttributesDisplay();
}
function updatePlayerBattleStats() {
 let mountHealthBonus = 0;
    let mountAttackBonus = 0;
    let mountCritDamageBonus = 0;
    
    if (player.mounts.equipped) {
        const equippedMount = player.mounts.inventory.find(m => m.id === player.mounts.equipped);
        if (equippedMount) {
            // 坐骑等级加成（每级增加100%）
            const mountLevelMultiplier = player.mounts.level;
            
            // 计算各项属性加成
            if (equippedMount.stats.health) {
                mountHealthBonus = equippedMount.stats.health * mountLevelMultiplier;
            }
            if (equippedMount.stats.attack) {
                mountAttackBonus = equippedMount.stats.attack * mountLevelMultiplier;
            }
            if (equippedMount.stats.critDamage) {
                mountCritDamageBonus = equippedMount.stats.critDamage * mountLevelMultiplier;
            }
        }
    }

let wingHealthBonus = 0;
    if (player.wings.equipped) {
        const equippedWing = player.wings.inventory.find(w => w.id === player.wings.equipped);
        if (equippedWing) {
            wingHealthBonus = equippedWing.healthBonus * player.wings.level * 1; // 翅膀等级每级提供100%加成
        }
    }
     const runeBonuses = calculateRuneBonuses();
    // 1. 获取各类加成
    const classBonuses = calculateClassBonuses();
    const titleBonuses = calculateTotalBonuses(); // 重命名变量避免混淆
    const officialBonus = getOfficialBonus();
    const companionBonuses = getCompanionBonuses(); // 获取伴侣天赋加成
   const artifactBonuses = calculateArtifactBonuses();
    // 保存职业加成到player对象
    player.classBonuses = classBonuses;
    const bonuses = calculateGemBonuses(); 
    const techBonuses = calculateTechniqueBonuses();

    // 2. 计算玩家生命（应用伴侣生命加成）
    player.battle.playerHealth = Math.floor(
        player.reincarnationCount * 
        (1 + player.attributes.healthBonus + player.attributes.health * 0.01) *
        classBonuses.healthMultiplier * titleBonuses.healthMultiplier *
        companionBonuses.healthMultiplier * (1 + artifactBonuses.health) * (1 + bonuses.health / 100) *  (1 + techBonuses.health) *  (1 + wingHealthBonus)  *  (1 + mountHealthBonus) *
        (1 + runeBonuses.health) * (1 + (player.mining.gems.emerald*0.05)) // 应用伴侣生命加成
    );

    // 3. 计算玩家攻击（应用伴侣攻击加成）
    player.battle.playerAttack = Math.floor(
        getTotalClickValue() * 
        (1 + player.attributes.attackBonus + player.attributes.attack * 0.01) *
        classBonuses.attackMultiplier * titleBonuses.attackMultiplier *
        officialBonus * companionBonuses.attackMultiplier * (1 + artifactBonuses.attack) * (1 + bonuses.attack / 100) *  (1 + techBonuses.attack)  *  (1 + mountAttackBonus) *
        (1 + runeBonuses.attack) * (1 + (player.mining.gems.sapphire*0.05))// 应用伴侣攻击加成
    );

    // 4. 计算暴击率（应用伴侣暴击率加成）
    const baseCritRate = 0.1 + player.attributes.critRateBonus + player.attributes.critRate * 0.00025 +
        classBonuses.critChance;
    player.battle.playerCritRate = Math.min(
        0.9,
        baseCritRate * companionBonuses.critRateMultiplier +  (1 + techBonuses.critRate) + (0.001+
        runeBonuses.critRate) // 应用伴侣暴击率乘数
    );

    // 5. 计算爆伤（应用伴侣爆伤加成和全属性加成）
    player.battle.playerCritDamage = (1.5 + 
        player.attributes.critDamageBonus + 
        player.attributes.critDamage * 0.0025) *
        classBonuses.critMultiplier * titleBonuses.critMultiplier *
        companionBonuses.critDamageMultiplier * (1 + artifactBonuses.critDamage) * (1 + bonuses.critDamage / 100) *  (1 + techBonuses.critDamage)  *  (1 + mountCritDamageBonus) *
        (1 + runeBonuses.critDamage)* (1 + (player.mining.gems.amethyst*0.05)) ; // 应用伴侣爆伤加成

    // 6. 计算连击次数（应用伴侣连击加成）
    player.battle.playerMultiAttack = Math.max(1,
        Math.floor(player.attributes.multiAttack / 300) + 
        player.attributes.multiAttackBonus +
        companionBonuses.combo+ techBonuses.multiAttack +
        (1+runeBonuses.combo)  // 应用伴侣连击加成
    );

    // 更新UI显示
    updateMonsterUI();
}
function checkTimeValidity() {
    const now = Date.now();
    const storedTime = localStorage.getItem('lastValidTime');
    
    if (!storedTime) {
        localStorage.setItem('lastValidTime', now);
        return true;
    }
    
    const timeDiff = now - storedTime;
    if (timeDiff < 0 || timeDiff > 30 * 60 * 1000) { // 允许30分钟内偏差
        return false;
    }
    
    localStorage.setItem('lastValidTime', now);
    return true;
}

// 计算离线经验
// 新增：计算离线奥秘经验
function calculateOfflineMysteryExp() {
    if (!player.mystery || !player.mystery.lastUpdateTime) return;
    
    const now = Date.now();
    const timeDiff = now - player.mystery.lastUpdateTime;
   // 时间回退检测
    if (timeDiff < 0) {
        console.warn("检测到时间回退，重置奥秘经验");
        player.mystery.exp = 0;
        player.mystery.lastUpdateTime = now;
        return;
    }
    const minutesPassed = Math.floor(timeDiff / (1000 * 60));
    
    if (minutesPassed > 0) {
        const towerFloor = player.tower.currentFloor || 0;
        const vipLevel = player.vip.level || 1;
        const expGained = minutesPassed * towerFloor * vipLevel;
        
        if (expGained > 0) {
            player.mystery.exp += expGained;
            logAction(`离线获得 ${expGained} 奥秘经验`, 'success');
        }
    }
    
    // 更新最后更新时间
    player.mystery.lastUpdateTime = now;
}

// 定时增加经验
setInterval(() => {
    if (player.mystery) {
        const towerFloor = parseInt(document.getElementById('towerFloor').textContent) || 0;
        const vipLevel = parseInt(document.getElementById('vipLevel').textContent) || 1;
        const expPerMinute = towerFloor * vipLevel;
        
        if (expPerMinute > 0) {
            // 每分钟增加一次，这里按秒计算
            player.mystery.exp += expPerMinute / 60;
            player.mystery.lastUpdateTime = new Date().getTime();
            updateMysterySystemDisplay();
        }
    }
}, 1000);

// 切换奥秘系统界面
function toggleMysterySystem() {
   if (player.reincarnationCount < 100) {
        alert("需要达到100转才能开启奥秘系统！");
        return;
    }
  calculateOfflineMysteryExp();
    const ui = document.getElementById('mysterySystemUI');
    const overlay = document.getElementById('mysterySystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateMysterySystemDisplay();
    }
}

// 更新奥秘系统显示
function updateMysterySystemDisplay() {
    const currentStage = player.mystery.stage;
    const currentLevel = player.mystery.level;
    const currentConfig = mysteryConfig.find(c => c.stage === currentStage);
    const nextLevel = currentLevel < 10 ? currentLevel + 1 : 1;
    const nextStage = currentLevel < 10 ? currentStage : currentStage + 1;
    const nextConfig = mysteryConfig.find(c => c.stage === nextStage);
    
    // 更新当前奥秘信息
    const title = `${currentConfig.name} ${currentStage}阶${currentLevel}级`;
    document.getElementById('mysteryTitleDisplay').textContent = title;
    document.getElementById('currentMysteryTitle').textContent = title;
    
    // 更新加成显示
    const maxStageReached = Math.min(currentStage, mysteryConfig.length);
    const maxConfig = mysteryConfig.find(c => c.stage === maxStageReached);
    document.getElementById('mysteryBonusDisplay').textContent = maxConfig ? maxConfig.totalBonus : 1;
    
    // 更新经验显示
    document.getElementById('currentMysteryExp').textContent = Math.floor(player.mystery.exp);
    document.getElementById('nextMysteryExp').textContent = currentConfig.levelCost;
    
    // 更新每分钟经验
    const towerFloor = parseInt(document.getElementById('towerFloor').textContent) || 0;
    const vipLevel = parseInt(document.getElementById('vipLevel').textContent) || 1;
    document.getElementById('expPerMinute').textContent = towerFloor * vipLevel;
    


    // 更新下一等级信息
    const nextMysteryInfo = document.getElementById('nextMysteryInfo');
    if (nextConfig && currentStage < mysteryConfig.length) {
        nextMysteryInfo.innerHTML = `${nextConfig.name} ${nextStage}阶${nextLevel}级 - 消耗: ${nextConfig.levelCost}经验`;
    } else {
        nextMysteryInfo.textContent = '已达到最高奥秘等级';
      document.getElementById('mysteryBonusDisplay').textContent = player.mystery.bonus;
 const offlineExpElement = document.createElement('div');
    offlineExpElement.textContent = `离线经验: ${player.mystery.exp}`;
    container.appendChild(offlineExpElement);
    }
}

// 升级一次奥秘
function upgradeMystery() {
    const currentStage = player.mystery.stage;
    const currentLevel = player.mystery.level;
    const currentConfig = mysteryConfig.find(c => c.stage === currentStage);
    
    // 检查是否已达最高等级
    if (currentStage >= mysteryConfig.length && currentLevel >= 10) {
        logAction("已达到最高奥秘等级！", "error");
        return false;
    }
    
    // 检查经验是否足够
    if (player.mystery.exp < currentConfig.levelCost) {
        logAction("奥秘经验不足，无法升级！", "error");
        return false;
    }
    
    // 消耗经验
    player.mystery.exp -= currentConfig.levelCost;
    
    // 升级处理
    if (currentLevel < 10) {
        player.mystery.level += 1;
    } else {
        player.mystery.level = 1;
        player.mystery.stage += 1;
    }
    updateDisplay();
    return true;
}

// 按指定次数升级奥秘
function upgradeMysteryByAmount() {
    calculateOfflineMysteryExp();
    const amount = parseInt(document.getElementById('mysteryUpgradeAmount').value) || 1;
    let upgraded = 0;
    
    for (let i = 0; i < amount; i++) {
        if (!upgradeMystery()) {
            break;
        }
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级奥秘！`, 'success');
        updateMysterySystemDisplay();
        updateDisplay();
    }
}
 // 升级后更新加成
    const config = mysteryConfig.find(c => c.stage === player.mystery.stage);
    if (config) {
        player.mystery.bonus = config.totalBonus;
    }
  updateDisplay();

// 一键升级奥秘到最大可能
function upgradeMysteryMaxPossible() {
    calculateOfflineMysteryExp();
    let upgraded = 0;
    
    while (upgradeMystery()) {
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级奥秘！`, 'success');
        updateMysterySystemDisplay();
        updateDisplay();
    }
}
function resetFundData() {
    showCustomConfirm('确定要重置所有基金数据吗？这将清空所有投资和收益！', (confirmed) => {
        if (confirmed) {
            player.fundData = {
                funds: [
                    { name: "稳健型基金", netValue: 1.00, maxInvestment: 100000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "平衡型基金", netValue: 1.00, maxInvestment: 1000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "成长型基金", netValue: 1.00, maxInvestment: 100000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "进取型基金", netValue: 1.00, maxInvestment: 1e15, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "激进型基金", netValue: 1.00, maxInvestment: 1e30, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "风险型基金", netValue: 1.00, maxInvestment: 1e50, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 }
                ],
                lastFundUpdate: Date.now()
            };
            
            logAction("基金数据已重置到初始状态", "success");
            updateFundDisplay();
        }
    });
}
// 切换基金系统显示状态
function toggleFundSystem() {
    const fundSystem = document.getElementById('fundSystem');
    const overlay = document.getElementById('fundOverlay');
    const isVisible = fundSystem.style.display !== 'none';
    
    fundSystem.style.display = isVisible ? 'none' : 'block';
    overlay.style.display = isVisible ? 'none' : 'block';
    
    if (!isVisible) {
        updateFundDisplay();
    }
}

// 更新基金显示
function updateFundDisplay() {
    const container = document.getElementById('fundsContainer');
    container.innerHTML = player.fundData.funds.map((fund, index) => {
        const currentValue = fund.investment * fund.netValue;
        const changeRate = ((fund.netValue - 1) * 100).toFixed(2);
        const isPositive = changeRate >= 0;
        const canRedeem = Date.now() >= fund.redemptionTime;
        const redemptionLeft = canRedeem ? 0 : Math.ceil((fund.redemptionTime - Date.now()) / 1000);
        
        return `
            <div style="border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 5px;">
                <h3>${fund.name}</h3>
                <p>当前净值: ${fund.netValue.toFixed(4)}</p>
                <p>收益率: <span style="color: ${fund.returnRate >= 0 ? 'green' : 'red'}">${fund.returnRate >= 0 ? '+' : ''}${fund.returnRate}%</span></p>
                <p>最大投资: ${formatNumber(fund.maxInvestment)} 转生币</p>
                <p>你的投资: ${formatNumber(fund.investment)} 转生币</p>
                <p>当前价值: ${formatNumber(currentValue)} 转生币</p>
                <p>涨幅度: <span style="color: ${isPositive ? 'green' : 'red'}">${isPositive ? '+' : ''}${changeRate}%</span></p>
                
                ${!canRedeem ? `<p>赎回倒计时: ${Math.floor(redemptionLeft / 60)}分${redemptionLeft % 60}秒</p>` : ''}
                
                <div style="margin-top: 10px;">
                    <input type="number" id="fundAmount${index}" placeholder="投资金额" min="1" style="width: 120px; margin-right: 10px;">
                    <button onclick="investFund(${index})" ${fund.investment >= fund.maxInvestment ? 'disabled' : ''}>投资</button>
                    <button onclick="investAllFund(${index})" ${fund.investment >= fund.maxInvestment ? 'disabled' : ''}>一键投资</button>
                    <button onclick="redeemAllFund(${index})" ${fund.investment <= 0 || !canRedeem ? 'disabled' : ''}>一键赎回</button>
                </div>
            </div>
        `;
    }).join('');
}
// 投资基金
function investFund(index) {
   const fund = player.fundData.funds[index];
// 检查是否在赎回前5分钟内
    const now = Date.now();
    const redemptionTime = fund.redemptionTime;
    if (redemptionTime && now > redemptionTime - 5 * 60 * 1000 && now < redemptionTime) {
        logAction("赎回前最后5分钟内禁止投资！", "error");
        return;
    }
    
    const amount = parseInt(document.getElementById(`fundAmount${index}`).value) || 0;
    
    if (amount <= 0) {
        logAction("请输入有效的投资金额", "error");
        return;
    }
    
    if (fund.investment + amount > fund.maxInvestment) {
        logAction(`投资金额超过基金上限${formatNumber(fund.maxInvestment)}`, "error");
        return;
    }
    
    if (player.reincarnationCoin < amount) {
        logAction("转生币不足！", "error");
        return;
    }
    // 检查赎回倒计时状态
    if (fund.redemptionTime <= 0) {
        // 如果没有赎回倒计时，重置净值为1
        fund.netValue = 1.00;
        logAction(`重置基金净值至1.00`, "info");
    }
    player.reincarnationCoin -= amount;
    fund.investment += amount;
    
    // 设置赎回时间为10分钟后
    if (fund.redemptionTime < Date.now()) {
        fund.redemptionTime = Date.now() + 10 * 60 * 1000;
    }
    
    logAction(`成功投资${fund.name} ${amount}转生币`, "success");
    updateFundDisplay();
}

// 赎回基金
function redeemFund(index) {
    const fund = player.fundData.funds[index];
    const amount = parseInt(document.getElementById(`fundAmount${index}`).value) || 0;
    
    if (amount <= 0) {
        logAction("请输入有效的赎回金额", "error");
        return;
    }
    
    if (fund.investment < amount) {
        logAction("投资金额不足！", "error");
        return;
    }
    
    const redeemValue = amount * fund.netValue;
    player.reincarnationCoin += redeemValue;
    fund.investment -= amount;
    
    logAction(`成功赎回${fund.name} ${amount}转生币，获得${redeemValue.toFixed(2)}转生币`, "success");
    
    if (fund.investment === 0) {
        fund.redemptionTime = 0;
    }
    
    updateFundDisplay();
}

// 一键投资
function investAllFund(index) {
    const fund = player.fundData.funds[index];
    const redeemedTime = Date.now() - fund.redemptionStart;
// 检查是否在赎回前5分钟内
    const now = Date.now();
    const redemptionTime = fund.redemptionTime;
    if (redemptionTime && now > redemptionTime - 5 * 60 * 1000 && now < redemptionTime) {
        logAction("赎回前最后5分钟内禁止投资！", "error");
        return;
    }
    const maxCanInvest = fund.maxInvestment - fund.investment;
    const amount = Math.min(player.reincarnationCoin, maxCanInvest);
    
    if (amount <= 0) {
        logAction("没有可投资的转生币或已达投资上限", "error");
        return;
    }
    // 检查赎回倒计时状态
    if (fund.redemptionTime <= 0) {
        // 如果没有赎回倒计时，重置净值为1
        fund.netValue = 1.00;
        logAction(`重置基金净值至1.00`, "info");
    }
    player.reincarnationCoin -= amount;
    fund.investment += amount;
    
    // 设置赎回时间为10分钟后
    if (fund.redemptionTime < Date.now()) {
        fund.redemptionTime = Date.now() + 10 * 60 * 1000;
    }
    
    logAction(`成功全额投资${fund.name} ${amount}转生币`, "success");
    updateFundDisplay();
}

// 一键赎回
function redeemAllFund(index) {
    const fund = player.fundData.funds[index];
    
    if (fund.investment <= 0) {
        logAction("没有可赎回的投资", "error");
        return;
    }
    
    if (Date.now() < fund.redemptionTime) {
        logAction("未到赎回时间", "error");
        return;
    }
    
    const redeemValue = fund.investment * fund.netValue;
    player.reincarnationCoin += redeemValue;
    
    logAction(`成功全额赎回${fund.name}，获得${redeemValue.toFixed(2)}转生币`, "success");
    
    fund.investment = 0;
    fund.redemptionTime = 0;
    
    updateFundDisplay();
}

// 更新基金净值
function updateFundValues() {
    const now = Date.now();
    const elapsed = now - player.fundData.lastFundUpdate;
    const intervals = Math.floor(elapsed / (60 * 1000)); // 每分钟更新一次
    
    if (intervals > 0) {
        player.fundData.funds.forEach(fund => {
           
            let riseProbability;
            if (fund.netValue < 1.0) {
                riseProbability = 0.45; 
            } else if (fund.netValue < 1.5) {
                riseProbability = 0.40; 
            } else if (fund.netValue < 2.0) {
                riseProbability = 0.35; 
            } else if (fund.netValue < 2.5) {
                riseProbability = 0.25; 
            } else {
                riseProbability = 0.10; 
            }

            // 计算投资比例（0-1）
            const investmentRatio = fund.maxInvestment > 0 ? Math.min(fund.investment / fund.maxInvestment, 1) : 0;
            
            // 根据投资比例计算波动幅度（10%-50%）
            const baseVolatility = 0.10 + (0.4 * investmentRatio);
            
           
            
            let newNetValue = fund.netValue;
            for (let i = 0; i < intervals; i++) {
                const willRise = Math.random() < riseProbability;
                const volatility = willRise ? 
                    Math.random() * baseVolatility : 
                    -Math.random() * baseVolatility;
                
                newNetValue *= (1 + volatility);
                
                // 检查是否跌到20%以下，若是则清零
                if (newNetValue <= 0.2) {
                    logAction(`${fund.name}已退市，投资已清零`, "error");
                    fund.investment = 0;
                    newNetValue = 1.00;
                    fund.redemptionTime = 0;
                    break;
                }
            }
            
            // 计算收益率（新增）
            const returnRate = ((newNetValue / fund.netValue - 1) * 100).toFixed(2);
            fund.returnRate = parseFloat(returnRate);
            
            // 更新净值
            fund.netValue = newNetValue;
        });
        
        player.fundData.lastFundUpdate = now - (elapsed % (60 * 1000));
        
        // 如果基金面板打开则更新显示
        if (document.getElementById('fundSystem').style.display !== 'none') {
            updateFundDisplay();
        }
    }
}


// 添加格式化大数字的辅助函数
function formatNumber(num) {
    if (num >= 1e30) return (num / 1e30).toFixed(2) + 'e30';
    if (num >= 1e15) return (num / 1e15).toFixed(2) + 'e15';
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
    return num.toFixed(2);
}

// 钓鱼系统配置
const fishQualities = [
    { name: "普通", color: "#000", exp: 1, rarity: 80 },
    { name: "稀有", color: "#008000", exp: 2, rarity: 12 },
    { name: "珍贵", color: "#0000CD", exp: 5, rarity: 5 },
    { name: "传说", color: "#8B4513", exp: 10, rarity: 2 },
    { name: "神话", color: "#FFD700", exp: 20, rarity: 1 }
];

const junkItems = [
    "破旧的鞋子", "生锈的铁片", "塑料瓶", "烂木头", "破布", "闫闫的黑丝", "比基尼", "杜蕾斯",
    "空罐头", "旧轮胎", "玻璃瓶", "渔网碎片", "朽木"
];

const fishNames = [
    "鲫鱼", "鲤鱼", "草鱼", "闫闫鱼", "黑鱼",
    "鲶鱼", "鳊鱼", "鳙鱼", "鲢鱼", "青鱼",
    "黄鱼", "鳕鳕鱼", "金枪鱼", "三文鱼", "鲨鱼",
    "鳗鱼", "带鱼", "比目鱼", "鲳鱼", "鲈鱼",
    "虹鳟鱼", "罗非鱼", "鲷鱼", "鲅鱼", "鲮鱼", "巨龙", "龙王", "金龙鱼",
    "泥鳅", "黄鳝", "河虾", "对虾", "龙虾", "鳄鱼", "石斑鱼", "秋刀鱼", "河豚",
    "螃蟹", "扇贝", "牡蛎", "蛤蜊", "叶鱼", "墨鱼", "黄花鱼", "中华鲟", "马口鱼",
    "章鱼", "墨鱼", "虾蛄", "海马", "海龙", "美人鱼",
    "河豚", "石斑鱼", "金鱼", "锦鲤", "斗鱼",
    "龙鱼", "天使鱼", "孔雀鱼", "罗汉鱼", "鹦鹉鱼"
];

const decompositionRewards = [
    "vip能力值", "洗髓丹", "洗练石", "玫瑰花"
];
const levelConfig = [
    { level: 1, requiredExp: 0, bonus: 1 },
    { level: 2, requiredExp: 100, bonus: 1 },
    { level: 3, requiredExp: 500, bonus: 1 },
    { level: 4, requiredExp: 1000, bonus: 1 },
    { level: 5, requiredExp: 2500, bonus: 1 },
    { level: 6, requiredExp: 5000, bonus: 1 },
    { level: 7, requiredExp: 10000, bonus: 1 },
    { level: 8, requiredExp: 25000, bonus: 1 },
    { level: 9, requiredExp: 50000, bonus: 1 },
    { level: 10, requiredExp: 100000, bonus: 1 },
    { level: 11, requiredExp: 500000, bonus: 1 },
    { level: 12, requiredExp: 1000000, bonus: 1 },
    { level: 13, requiredExp: 5000000, bonus: 1 },
    { level: 14, requiredExp: 10000000, bonus: 1 },
    { level: 15, requiredExp: 50000000, bonus: 1 }
];

// 钓鱼系统函数
function toggleFishingSystem() {
 if (player.reincarnationCount < 20) {
        alert("需要达到20转才能开启钓鱼系统！");
        return;
    }
    const ui = document.getElementById('fishingSystemUI');
    const overlay = document.getElementById('fishingSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateFishingUI();
    }
}
// 切换自动钓鱼状态
function toggleAutoFishing() {
    player.fishing.autoFishingEnabled = !player.fishing.autoFishingEnabled;
    const btn = document.getElementById('autoFishingBtn');
    btn.textContent = `自动钓鱼: ${player.fishing.autoFishingEnabled ? '开启' : '关闭'}`;
    btn.style.background = player.fishing.autoFishingEnabled ? '#4CAF50' : '#f44336';
    
    logAction(`自动钓鱼${player.fishing.autoFishingEnabled ? '开启' : '关闭'}`, 'info');
    
    // 如果开启自动钓鱼且当前没有在钓鱼，则开始钓鱼
    if (player.fishing.autoFishingEnabled && !player.fishing.isFishing) {
        startFishing();
    }
}

// 切换自动分解状态
function toggleAutoDecomposeFish() {
    player.fishing.autoDecomposeFishEnabled = !player.fishing.autoDecomposeFishEnabled;
    const btn = document.getElementById('autoDecomposeFishBtn');
    btn.textContent = `自动分解: ${player.fishing.autoDecomposeFishEnabled ? '开启' : '关闭'}`;
    btn.style.background = player.fishing.autoDecomposeFishEnabled ? '#2196F3' : '#f44336';
    
    logAction(`自动分解${player.fishing.autoDecomposeFishEnabled ? '开启' : '关闭'}`, 'info');
}

function updateFishingUI() {
    if (!player.fishing) return;
    
   document.getElementById('fishingLevel').textContent = player.fishing.level;
    document.getElementById('currentFishingExp').textContent = player.fishing.currentExp;
    
    // 使用玩家道具中的鱼饵数量
    document.getElementById('baitCount').textContent = player.items.baitCount || 0;
    
    document.getElementById('cageCount').textContent = player.fishing.fishCage.length;
    
    // 计算下一级所需经验
    const nextLevel = Math.min(player.fishing.level, levelConfig.length - 1);
     document.getElementById('nextFishingExp').textContent = levelConfig[player.fishing.level].requiredExp;
    
    document.getElementById('fishingBonus').textContent = player.fishing.bonus.toFixed(2) + '倍';
    
    updateFishCageDisplay();
}

function startFishing() {
    // 检查是否有鱼饵（使用玩家道具中的鱼饵）
    if (!player.items.baitCount || player.items.baitCount <= 0) {
        document.getElementById('fishingStatus').textContent = "没有鱼饵了，无法钓鱼！";
     // 自动钓鱼模式下，鱼饵不足时关闭自动钓鱼
        if (player.fishing.autoFishingEnabled) {
            player.fishing.autoFishingEnabled = false;
            document.getElementById('autoFishingBtn').textContent = "自动钓鱼: 关闭";
            document.getElementById('autoFishingBtn').style.background = '#f44336';
        }

        return;
    }
    
    // 检查鱼笼是否已满
    if (player.fishing.fishCage.length >= 20) {
        document.getElementById('fishingStatus').textContent = "鱼笼已满，请先分解一些鱼获！";
        return;
    }
    
    // 消耗一个鱼饵（从玩家道具中扣除）
    player.items.baitCount--;
    updateFishingUI();
    
    // 更新状态
    player.fishing.isFishing = true;
    document.getElementById('startFishingBtn').style.display = 'none';
    document.getElementById('fishingStatus').textContent = "正在下竿...等待鱼上钩...";
    document.getElementById('fishingRod').style.display = 'block';
    document.getElementById('fishingBobber').style.display = 'block';
    
    // 随机3-10秒后鱼咬钩
    const biteDelay = 3000 + Math.random() * 7000; // 3-10秒
    player.fishing.biteTime = Date.now() + biteDelay;
    
    // 鱼咬钩定时器
    player.fishing.biteTimer = setTimeout(() => {
        fishBite();
    }, biteDelay);
}

function fishBite() {
    player.fishing.isBiting = true;
    document.getElementById('fishingStatus').textContent = "注意！有鱼对鱼饵感兴趣...";
    document.getElementById('fishingBobber').style.animation = 'bobberMove 0.5s infinite alternate';
    document.getElementById('biteIndicator').style.display = 'block';
    
    // 显示拉钩按钮
    document.getElementById('reelInBtn').style.display = 'block';
    
    // 如果开启了自动钓鱼，自动拉钩
    if (player.fishing.autoFishingEnabled) {
        // 随机延迟0.5-1.5秒后自动拉钩，模拟玩家反应时间
        const reelDelay = 500 + Math.random() * 1000;
        setTimeout(() => {
            reelInFish();
        }, reelDelay);
    }
    
    // 咬钩窗口期为2秒
    if (player.fishing.biteWindowTimer) {
        clearTimeout(player.fishing.biteWindowTimer);
    }
    
    player.fishing.biteWindowTimer = setTimeout(() => {
        // 窗口期结束，未及时拉杆
        if (player.fishing.isBiting) {
            document.getElementById('fishingStatus').textContent = "鱼跑掉了！";
            resetFishing();
            
            // 自动钓鱼模式下，自动开始下一次钓鱼
            if (player.fishing.autoFishingEnabled) {
                startFishing();
            }
        }
    }, 2000);
}

function reelInFish() {
    // 检查是否在咬钩状态
    if (!player.fishing.isBiting) return;
    
    // 清除定时器
    clearTimeout(player.fishing.biteWindowTimer);
    
    // 计算是否成功钓到鱼（基于时机）
    const currentTime = Date.now();
    const timeSinceBite = currentTime - player.fishing.biteTime;
    let success = timeSinceBite >= 0 && timeSinceBite <= 2000;
    
    if (success) {
        // 70%概率钓到鱼，30%概率钓到破烂
        if (Math.random() < 0.7) {
            catchFish();
        } else {
            catchJunk();
        }
    } else {
        document.getElementById('fishingStatus').textContent = "时机不对，鱼跑掉了！";
    }
    
    resetFishing();
  // 自动钓鱼模式下，自动开始下一次钓鱼
    if (player.fishing.autoFishingEnabled) {
        startFishing();
    }
}

function catchFish() {
    // 随机选择鱼的品质
    let quality = determineQuality();
    
    // 随机选择鱼的名称
    let name = fishNames[Math.floor(Math.random() * fishNames.length)];
    
    // 随机长度和重量
    let length = (2 + Math.random() * 98).toFixed(1); // 2-100厘米
    let weight = (0.1 + Math.random() * 9.9).toFixed(1); // 0.1-10公斤
    
    // 创建鱼对象
    let fish = {
        type: 'fish',
        name: name,
        quality: quality,
        length: length,
        weight: weight,
        selected: false
    };
    // 如果开启了自动分解，立即分解这条鱼
    if (player.fishing.autoDecomposeFishEnabled) {
        decomposeSingleFish(fish);
        document.getElementById('fishingStatus').textContent = `钓到${fish.quality.name}的${fish.name}并自动分解！`;
    } else {
        // 否则放入鱼笼
        player.fishing.fishCage.push(fish);
        document.getElementById('fishingStatus').textContent = `成功钓到${fish.quality.name}的${fish.name}！`;
    }
    
  // 添加经验
    addExperience(quality.exp);
    
}

function catchJunk() {
    // 随机选择破烂
    let junkName = junkItems[Math.floor(Math.random() * junkItems.length)];
    
    // 创建破烂对象
    let junk = {
        type: 'junk',
        name: junkName,
        selected: false
    };
    
   // 如果开启了自动分解，立即分解这个破烂
    if (player.fishing.autoDecomposeFishEnabled) {
        decomposeSingleJunk(junk);
        document.getElementById('fishingStatus').textContent = `钓到${junk.name}并自动分解！`;
    } else {
        // 否则放入鱼笼
        player.fishing.fishCage.push(junk);
        document.getElementById('fishingStatus').textContent = `钓到了${junk.name}！`;
    }
}

function resetFishing() {
    player.fishing.isFishing = false;
    player.fishing.isBiting = false;
    
    clearTimeout(player.fishing.biteTimer);
    clearTimeout(player.fishing.biteWindowTimer);
    
    document.getElementById('fishingRod').style.display = 'none';
    document.getElementById('fishingBobber').style.display = 'none';
    document.getElementById('biteIndicator').style.display = 'none';
    document.getElementById('fishingBobber').style.animation = '';
    document.getElementById('reelInBtn').style.display = 'none';
    document.getElementById('startFishingBtn').style.display = 'block';
    
    updateFishingUI();
}
function decomposeSingleFish(fish) {
    const qualityFactor = fishQualities.findIndex(q => q.name === fish.quality.name) + 2;
    const lengthFactor = parseFloat(fish.length) / 100;
    const weightFactor = parseFloat(fish.weight) / 10;
    
    // 计算基础数量
    let baseQuantity = Math.floor(1 + qualityFactor * (lengthFactor + weightFactor));
    // 应用收益加成
    baseQuantity = Math.floor(baseQuantity * getCurrentBonus());
    
    // 随机选择一种奖励
    const rewardType = decompositionRewards[Math.floor(Math.random() * decompositionRewards.length)];
    
    // 添加到玩家物品
    switch(rewardType) {
        case 'vip能力值':
            player.items.vipPower = (player.items.vipPower || 0) + baseQuantity;
            break;
        case '洗髓丹':
            player.items.rebornDan = (player.items.rebornDan || 0) + baseQuantity;
            break;
        case '洗练石':
            player.items.refineStone = (player.items.refineStone || 0) + baseQuantity;
            break;
        case '玫瑰花':
            player.items.rose = (player.items.rose || 0) + baseQuantity;
            break;
    }
    
    // 添加种子掉落
    if (Math.random() < 0.15) { // 15%概率获得种子
        dropSeedAfterDecompose();
    }
    
    // 更新显示
    updateFishingUI();
    updateItemDisplay();
   checkTitleUnlocks();
}

// 新增：分解单个破烂
function decomposeSingleJunk(junk) {
    // 破烂分解固定获得1朵玫瑰花
    player.items.rose = (player.items.rose || 0) + 1;
    
    // 更新显示
    updateFishingUI();
    updateItemDisplay();
  checkTitleUnlocks();
}
function addExperience(amount) {
    // 应用收益加成
    const bonus = getCurrentBonus();
    const actualAmount = amount * bonus;
    
    player.fishing.currentExp += actualAmount;
    checkLevelUp();
}

function checkLevelUp() {
    // 从当前等级开始检查是否可以升级
    let currentLevelIndex = levelConfig.findIndex(conf => conf.level === player.fishing.level);
    
    // 检查是否可以升级到下一级
    while (currentLevelIndex + 1 < levelConfig.length && 
           player.fishing.currentExp >= levelConfig[currentLevelIndex + 1].requiredExp) {
        player.fishing.level++;
        currentLevelIndex++;
        document.getElementById('fishingStatus').textContent += `恭喜！钓鱼等级提升到${player.fishing.level}级！`;
    }
    const fishingBonuses = [1, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000, 50000000];
     player.fishing.bonus = fishingBonuses[player.fishing.level - 1] || 50000000;   // 每级增加50倍（10%）
    updateFishingUI();
}

function updateFishCageDisplay() {
    const cageContainer = document.getElementById('fishCage');
    cageContainer.innerHTML = '';
    
    if (!player.fishing.fishCage || player.fishing.fishCage.length === 0) {
        cageContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #666;">鱼笼是空的，快去钓鱼吧！</div>';
        return;
    }
    
    player.fishing.fishCage.forEach((item, index) => {
        let itemElement = document.createElement('div');
        itemElement.style.padding = '5px';
        itemElement.style.borderRadius = '4px';
        itemElement.style.cursor = 'pointer';
        itemElement.style.transition = 'all 0.2s';
        
        // 设置选中状态样式
        if (item.selected) {
            itemElement.style.backgroundColor = '#e6f7ff';
            itemElement.style.border = '1px solid #91d5ff';
        } else {
            itemElement.style.backgroundColor = '#f9f9f9';
            itemElement.style.border = '1px solid transparent';
        }
        
        // 设置内容
        if (item.type === 'fish') {
            itemElement.innerHTML = `
                <span style="color: ${item.quality.color}; font-weight: bold;">${item.quality.name}</span>
                ${item.name} (${item.length}cm, ${item.weight}kg)
            `;
        } else {
            itemElement.textContent = item.name;
        }
        
        // 添加点击选中事件
        itemElement.addEventListener('click', () => {
            item.selected = !item.selected;
            updateFishCageDisplay();
        });
        
        cageContainer.appendChild(itemElement);
    });
}

function decomposeSelectedFish() {
    if (!player.fishing.fishCage || player.fishing.fishCage.length === 0) {
        alert('鱼笼是空的！');
        return;
    }
    
    const selectedItems = player.fishing.fishCage.filter(item => item.selected);
    
    if (selectedItems.length === 0) {
        alert('请先选择要分解的鱼获！');
        return;
    }
    
    let rewards = [];
    
    // 处理每种选中的物品
    selectedItems.forEach(item => {
        // 添加种子掉落
    if (Math.random() < 0.15) { // 15%概率获得种子
        dropSeedAfterDecompose();
    }
       
        if (item.type === 'junk') {
            // 破烂分解固定获得1朵玫瑰花
            player.items.rose = (player.items.rose || 0) + 1; // 添加到玩家物品
            rewards.push({type: '玫瑰花', quantity: 1});
        } else if (item.type === 'fish') {
            // 鱼分解根据品质、长度和重量获得奖励
            const qualityFactor = fishQualities.findIndex(q => q.name === item.quality.name) + 2;
            const lengthFactor = parseFloat(item.length) / 100;
            const weightFactor = parseFloat(item.weight) / 10;
            
            // 计算基础数量
            let baseQuantity = Math.floor(1 + qualityFactor * (lengthFactor + weightFactor));
            // 应用收益加成
            baseQuantity = Math.floor(baseQuantity * getCurrentBonus());
            
            // 随机选择一种奖励
            const rewardType = decompositionRewards[Math.floor(Math.random() * decompositionRewards.length)];
            
            // 添加到玩家物品
            switch(rewardType) {
                case 'vip能力值':
                    player.items.vipPower = (player.items.vipPower || 0) + baseQuantity;
                    break;
                case '洗髓丹':
                    player.items.rebornDan = (player.items.rebornDan || 0) + baseQuantity;
                    break;
                case '洗练石':
                    player.items.refineStone = (player.items.refineStone || 0) + baseQuantity;
                    break;
                case '玫瑰花':
                    player.items.rose = (player.items.rose || 0) + baseQuantity;
                    break;
            }
            
            rewards.push({type: rewardType, quantity: baseQuantity});
        }
        
        // 从鱼笼中移除
        const index = player.fishing.fishCage.indexOf(item);
        if (index > -1) {
            player.fishing.fishCage.splice(index, 1);
        }
    });
    
    // 显示奖励
    let rewardMessage = '分解获得：\n';
    rewards.forEach(reward => {
        rewardMessage += `- ${reward.type} x ${reward.quantity}\n`;
    });
    alert(rewardMessage);
    
    // 更新显示
    updateFishingUI();
    updateItemDisplay(); // 更新物品显示
}

function determineQuality() {
    let rand = Math.random() * 100;
    let cumulative = 0;


    for (let quality of fishQualities) {
        cumulative += quality.rarity;

        if (rand <= cumulative) {
            return quality;
        }
    }
    
    return fishQualities[0]; // 默认普通品质
}

function getCurrentBonus() {
    if (!player.fishing.level) return 1;
    const currentLevelConfig = levelConfig.find(conf => conf.level === player.fishing.level);
    return currentLevelConfig ? currentLevelConfig.bonus : 1;
}

// 添加CSS动画
const style = document.createElement('style');
style.textContent = `
    @keyframes bobberMove {
        from { transform: translateY(0); }
        to { transform: translateY(-10px); }
    }
`;
document.head.appendChild(style);

// 种子配置
const seedConfig = [
    { id: "seed1", name: "小麦种子", growthTime: 300, exp: 3, value: 2, rarity: 30 },
    { id: "seed2", name: "水稻种子", growthTime: 600, exp: 5, value: 4, rarity: 25 },
    { id: "seed3", name: "玉米种子", growthTime: 900, exp: 10, value: 10, rarity: 20 },
    { id: "seed4", name: "土豆种子", growthTime: 1200, exp: 15, value: 15, rarity: 18 },
    { id: "seed5", name: "胡萝卜种子", growthTime: 1500, exp: 20, value: 20, rarity: 15 },
    { id: "seed6", name: "番茄种子", growthTime: 1800, exp: 30, value: 25, rarity: 12 },
    { id: "seed7", name: "草莓种子", growthTime: 2100, exp: 40, value: 35, rarity: 10 },
    { id: "seed8", name: "蓝莓种子", growthTime: 2400, exp: 50, value: 40, rarity: 8 },
    { id: "seed9", name: "葡萄种子", growthTime: 2700, exp: 60, value: 50, rarity: 6 },
    { id: "seed10", name: "西瓜种子", growthTime: 3000, exp: 70, value: 60, rarity: 5 },
    { id: "seed11", name: "南瓜种子", growthTime: 3300, exp: 80, value: 70, rarity: 4 },
    { id: "seed12", name: "向日葵种子", growthTime: 3600, exp: 100, value: 80, rarity: 3 },
    { id: "seed13", name: "咖啡豆种子", growthTime: 7200, exp: 200, value: 160, rarity: 2 },
    { id: "seed14", name: "茶树种子", growthTime: 10800, exp: 500, value: 250, rarity: 1 },
    { id: "seed15", name: "金苹果种子", growthTime: 21600, exp: 1200, value: 500, rarity: 0.5 }
];

// 切换农场系统界面
function toggleFarmSystem() {
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启农场系统！");
        return;
    }
    const ui = document.getElementById('farmSystemUI');
    const overlay = document.getElementById('farmSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        
        // 关闭界面时清除自动化检查
        if (window.farmAutoCheckInterval) {
            clearInterval(window.farmAutoCheckInterval);
            window.farmAutoCheckInterval = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateFarmDisplay();
        
        // 开启界面时启动自动化检查（每10秒检查一次）
        if (!window.farmAutoCheckInterval) {
            window.farmAutoCheckInterval = setInterval(() => {
                if (player.farm.autoHarvest) autoHarvest();
                if (player.farm.autoPlant) autoPlant();
            }, 1000); // 1秒检查一次
        }
    }
}

function closeFarmSystem() {
    document.getElementById('farmSystemUI').style.display = 'none';
    document.getElementById('farmSystemOverlay').style.display = 'none';
}

// 更新农场显示
function updateFarmDisplay() {
    // 更新基本信息
    document.getElementById('farmLevel').textContent = player.farm.level;
    document.getElementById('farmExp').textContent = player.farm.exp;
    document.getElementById('farmExpNext').textContent = player.farm.expToNextLevel;
    document.getElementById('farmFieldCount').textContent = player.farm.fields.filter(f => f.planted).length;
    document.getElementById('farmMaxFields').textContent = player.farm.maxFields;
    document.getElementById('waterCount').textContent = player.items.vipPower;
     document.getElementById('autoPlantBtn').textContent = `自动种植: ${player.farm.autoPlant ? '开启' : '关闭'}`;
    document.getElementById('autoPlantBtn').style.background = player.farm.autoPlant ? '#4CAF50' : '#FF9800';
    document.getElementById('autoHarvestBtn').textContent = `自动收获: ${player.farm.autoHarvest ? '开启' : '关闭'}`;
    document.getElementById('autoHarvestBtn').style.background = player.farm.autoHarvest ? '#4CAF50' : '#9C27B0';
    // 更新农田显示
    const fieldsContainer = document.getElementById('farmFields');
    fieldsContainer.innerHTML = '';
    
    for (let i = 0; i < player.farm.maxFields; i++) {
        const field = player.farm.fields[i] || { planted: false };
        const fieldDiv = document.createElement('div');
        fieldDiv.className = 'farm-field';
        fieldDiv.style.border = '1px solid #555';
        fieldDiv.style.borderRadius = '5px';
        fieldDiv.style.padding = '10px';
        fieldDiv.style.textAlign = 'center';
        fieldDiv.style.cursor = 'pointer';
        fieldDiv.style.position = 'relative';
        fieldDiv.style.height = '100px';
        
        if (i >= player.farm.maxFields) {
            fieldDiv.style.backgroundColor = '#333';
            fieldDiv.innerHTML = '<div style="color: #777;">未解锁</div>';
            fieldsContainer.appendChild(fieldDiv);
            continue;
        }
        
        if (!field.planted) {
            fieldDiv.innerHTML = '<div>空闲农田</div><button onclick="openSeedSelection(' + i + ')" style="margin-top: 10px;">种植</button>';
            fieldDiv.style.backgroundColor = '#2a2a2a';
        } else {
            const seed = seedConfig.find(s => s.id === field.seedId);
            const now = Date.now();
            const elapsed = now - field.plantTime;
            const progress = Math.min(100, (elapsed / (seed.growthTime * 1000)) * 100);
            
            // 显示作物状态
            let statusText = '';
            if (progress < 100) {
                statusText = '生长中: ' + Math.floor(progress) + '%';
                
                // 检查是否需要浇水
                if (field.wateredAt && (now - field.wateredAt) > 1800000000) { // 半小时需要浇水
                    statusText = '<span style="color: #ff5555;">需要浇水!</span>';
                }
            } else {
                statusText = '<span style="color: #55ff55;">可收获!</span>';
            }
            
            fieldDiv.innerHTML = `
                <div><strong>${seed.name}</strong></div>
                <div>${statusText}</div>
                <div style="height: 10px; background: #555; margin-top: 10px; border-radius: 5px;">
                    <div style="height: 100%; background: #4CAF50; width: ${progress}%; border-radius: 5px;"></div>
                </div>
            `;
            
            // 添加操作按钮
            const buttonContainer = document.createElement('div');
            buttonContainer.style.marginTop = '0px';
            
            if (progress < 100) {
                const waterBtn = document.createElement('button');
                waterBtn.textContent = '浇水';
                waterBtn.onclick = () => waterCrop(i);
                waterBtn.style.marginRight = '5px';
                buttonContainer.appendChild(waterBtn);
            } else {
                const harvestBtn = document.createElement('button');
                harvestBtn.textContent = '收获';
                harvestBtn.onclick = () => harvestCrop(i);
                harvestBtn.style.backgroundColor = '#4CAF50';
                buttonContainer.appendChild(harvestBtn);
            }
            
            fieldDiv.appendChild(buttonContainer);
            
            if (progress < 100) {
                fieldDiv.style.backgroundColor = '#2a2a2a';
            } else {
                fieldDiv.style.backgroundColor = '#334433';
            }
        }
        
        fieldsContainer.appendChild(fieldDiv);
    }
    
    // 更新种子仓库
    const seedContainer = document.getElementById('seedInventory');
    seedContainer.innerHTML = '';
    
    seedConfig.forEach(seed => {
        const count = player.farm.seeds[seed.id] || 0;
        if (count > 0) {
            const seedDiv = document.createElement('div');
            seedDiv.className = 'seed-item';
            seedDiv.style.border = '1px solid #555';
            seedDiv.style.borderRadius = '5px';
            seedDiv.style.padding = '10px';
            seedDiv.style.textAlign = 'center';
            seedDiv.style.backgroundColor = '#2a2a2a';
            
            seedDiv.innerHTML = `
                <div><strong>${seed.name}</strong></div>
                <div>数量: ${count}</div>
                <div>时间: ${formatTimeq(seed.growthTime)}</div>
            `;
            
            seedContainer.appendChild(seedDiv);
        }
    });
}

// 打开种子选择界面
function openSeedSelection(fieldIndex) {
    const seedContainer = document.getElementById('seedInventory');
    seedContainer.innerHTML = '';
    
    seedConfig.forEach(seed => {
        const count = player.farm.seeds[seed.id] || 0;
        if (count > 0) {
            const seedDiv = document.createElement('div');
            seedDiv.className = 'seed-item';
            seedDiv.style.border = '1px solid #555';
            seedDiv.style.borderRadius = '5px';
            seedDiv.style.padding = '10px';
            seedDiv.style.textAlign = 'center';
            seedDiv.style.backgroundColor = '#2a2a2a';
            seedDiv.style.cursor = 'pointer';
            
            seedDiv.innerHTML = `
                <div><strong>${seed.name}</strong></div>
                <div>数量: ${count}</div>
                <div>时间: ${formatTimeq(seed.growthTime)}</div>
            `;
            
            seedDiv.onclick = () => plantSeed(fieldIndex, seed.id);
            
            seedContainer.appendChild(seedDiv);
        }
    });
    
    // 添加取消按钮
    const cancelDiv = document.createElement('div');
    cancelDiv.className = 'seed-item';
    cancelDiv.style.border = '1px solid #555';
    cancelDiv.style.borderRadius = '5px';
    cancelDiv.style.padding = '10px';
    cancelDiv.style.textAlign = 'center';
    cancelDiv.style.backgroundColor = '#442222';
    cancelDiv.style.cursor = 'pointer';
    cancelDiv.innerHTML = '<div><strong>取消</strong></div>';
    cancelDiv.onclick = updateFarmDisplay;
    seedContainer.appendChild(cancelDiv);
}

// 种植种子
function plantSeed(fieldIndex, seedId) {
    if (player.farm.seeds[seedId] <= 0) return;
    
    // 初始化农田数组
    while (player.farm.fields.length <= fieldIndex) {
        player.farm.fields.push({ planted: false });
    }
    
    player.farm.fields[fieldIndex] = {
        planted: true,
        seedId: seedId,
        plantTime: Date.now(),
        wateredAt: Date.now()
    };
    
    player.farm.seeds[seedId]--;
    
    updateFarmDisplay();
    logAction(`在农田${fieldIndex + 1}种植了种子`, 'success');
}

// 浇水
function waterCrop(fieldIndex) {
    if (player.items.vipPower <= 30) {
        logAction("水滴不足！", "error");
        return;
    }
    
    const field = player.farm.fields[fieldIndex];
    if (!field || !field.planted) return;
    
    // 减少3分钟成熟时间（180000毫秒）
    field.plantTime -= 180000;
    
    field.wateredAt = Date.now();
    player.items.vipPower-=30;
    
    updateFarmDisplay();
    logAction(`为农田${fieldIndex + 1}浇水，成熟时间减少3分钟`, 'info');
}

// 收获作物
function harvestCrop(fieldIndex) {
    const field = player.farm.fields[fieldIndex];
    if (!field || !field.planted) return;
    
    const seed = seedConfig.find(s => s.id === field.seedId);
    const now = Date.now();
    const elapsed = now - field.plantTime;
    
    if (elapsed < seed.growthTime * 1000) {
        logAction("作物还未成熟！", "error");
        return;
    }
    
    // 获得经验和转生币
    player.farm.exp += seed.exp;
    player.items.vipPower += seed.value;
    
    // 检查升级
    checkFarmLevelUp();
    
    // 重置农田
    player.farm.fields[fieldIndex] = { planted: false };
    onFarmHarvest();
    updateFarmDisplay();
    updateDisplay(); // 更新主界面显示
   checkTitleUnlocks();
    logAction(`收获${seed.name}，获得${seed.exp}农场经验和${seed.value}VIP能力值`, 'success');
}

// 一键浇水
function waterAllCrops() {
    if (player.items.vipPower <= 0) {
        logAction("水滴不足！", "error");
        return;
    }
    
    let watered = 0;
    player.farm.fields.forEach((field, index) => {
        if (field.planted) {
            const now = Date.now();
            if (field.wateredAt && (now - field.wateredAt) > 1800000) {
                if (player.items.vipPower > 0) {
                    field.wateredAt = now;
                    playe.items.vipPower--;
                    watered++;
                }
            }
        }
    });
    
    if (watered > 0) {
        updateFarmDisplay();
        logAction(`一键浇水完成，浇灌了${watered}块农田`, 'success');
    } else {
        logAction("没有需要浇水的农田", "info");
    }
}

// 一键收获
function harvestAllCrops() {
    let harvested = 0;
    let totalExp = 0;
    let totalCoins = 0;
    
    player.farm.fields.forEach((field, index) => {
        if (field.planted) {
            const seed = seedConfig.find(s => s.id === field.seedId);
            const now = Date.now();
            const elapsed = now - field.plantTime;
            
            if (elapsed >= seed.growthTime * 1000) {
                // 收获作物
                player.farm.exp += seed.exp;
                player.items.vipPower += seed.value;
                totalExp += seed.exp;
                totalCoins += seed.value;
                
                // 重置农田
                player.farm.fields[index] = { planted: false };
               onFarmHarvest();
                harvested++;
            }
        }
    });
    
    if (harvested > 0) {
        // 检查升级
        checkFarmLevelUp();
        updateFarmDisplay();
        updateDisplay(); // 更新主界面显示
        logAction(`一键收获完成，收获${harvested}块农田，获得${totalExp}农场经验和${totalCoins}VIP能力值`, 'success');
    } else {
        logAction("没有可收获的农田", "info");
    }
}

// 检查农场升级
function checkFarmLevelUp() {
    while (player.farm.exp >= player.farm.expToNextLevel) {
        player.farm.exp -= player.farm.expToNextLevel;
        player.farm.level++;
        
        // 每级增加最大农田数量
        if (player.farm.level % 3 === 0) {
            player.farm.maxFields++;
        }
        
        // 更新下一级所需经验
        player.farm.expToNextLevel = Math.floor(player.farm.expToNextLevel * 1.5);
        
        logAction(`农场升级到${player.farm.level}级！解锁新农田`, 'success');
    }
}
function dropSeedAfterDecompose() {
    const totalRarity = seedConfig.reduce((sum, seed) => sum + seed.rarity, 0);
    const rand = Math.random() * totalRarity;
    
    let cumulative = 0;
    for (const seed of seedConfig) {
        cumulative += seed.rarity;
        if (rand <= cumulative) {
            // 添加种子到仓库
            player.farm.seeds[seed.id] = (player.farm.seeds[seed.id] || 0) + 1;
            logAction(`分解获得${seed.name}`, 'success');
            break;
        }
    }
}
// 时间格式化辅助函数
function formatTimeq(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    return `${hours > 0 ? hours + '小时' : ''}${minutes > 0 ? minutes + '分' : ''}${secs}秒`;
}
// 离线时更新农场
function updateFarmOffline() {
    const now = Date.now();
    const elapsed = (now - player.farm.lastUpdate) / 1000; // 转换为秒
    
    player.farm.fields.forEach(field => {
        if (field.planted) {
            const seed = seedConfig.find(s => s.id === field.seedId);
            // 更新生长进度（但不自动收获）
            // 实际收获需要玩家手动操作
        }
    });
    
    player.farm.lastUpdate = now;
}
function initFarmData() {
    if (!player.farm) {
        player.farm = {
            level: 1,
            exp: 0,
            expToNextLevel: 150,
            fields: Array(2).fill().map(() => ({ planted: false })),
            maxFields: 2,
            seeds: {},
            water: 10,
            lastUpdate: Date.now(),
          autoPlant: false,    // 新增自动种植设置
            autoHarvest: false 
        };
    }
    
    // 确保农田数组大小正确
    while (player.farm.fields.length < player.farm.maxFields) {
        player.farm.fields.push({ planted: false });
    }
}
// 切换自动种植功能
function toggleAutoPlant() {
    player.farm.autoPlant = !player.farm.autoPlant;
    const btn = document.getElementById('autoPlantBtn');
    btn.textContent = `自动种植: ${player.farm.autoPlant ? '开启' : '关闭'}`;
    btn.style.background = player.farm.autoPlant ? '#4CAF50' : '#FF9800';
    
    logAction(`自动种植${player.farm.autoPlant ? '开启' : '关闭'}`, 'info');
    
    // 如果开启自动种植，立即执行一次
    if (player.farm.autoPlant) {
        autoPlant();
    }
}

// 切换自动收获功能
function toggleAutoHarvest() {
    player.farm.autoHarvest = !player.farm.autoHarvest;
    const btn = document.getElementById('autoHarvestBtn');
    btn.textContent = `自动收获: ${player.farm.autoHarvest ? '开启' : '关闭'}`;
    btn.style.background = player.farm.autoHarvest ? '#4CAF50' : '#9C27B0';
    
    logAction(`自动收获${player.farm.autoHarvest ? '开启' : '关闭'}`, 'info');
    
    // 如果开启自动收获，立即执行一次
    if (player.farm.autoHarvest) {
        autoHarvest();
    }
}

// 自动种植逻辑
function autoPlant() {
    if (!player.farm.autoPlant) return;
    
    let planted = false;
    
    // 检查是否有空闲农田
    for (let i = 0; i < player.farm.fields.length; i++) {
        const field = player.farm.fields[i];
        
        // 如果农田空闲且有种子可用
        if (!field.planted && Object.keys(player.farm.seeds).length > 0) {
            // 选择第一个有库存的种子
            for (const seedId in player.farm.seeds) {
                if (player.farm.seeds[seedId] > 0) {
                    plantSeed(i, seedId);
                    planted = true;
                    break;
                }
            }
        }
    }
    
    if (planted) {
        logAction("自动种植执行完成", 'success');
    }
}

// 自动收获逻辑
function autoHarvest() {
    if (!player.farm.autoHarvest) return;
    
    let harvested = false;
    
    // 检查所有农田
    for (let i = 0; i < player.farm.fields.length; i++) {
        const field = player.farm.fields[i];
        
        if (field.planted) {
            const seed = seedConfig.find(s => s.id === field.seedId);
            const now = Date.now();
            const elapsed = now - field.plantTime;
            
            // 如果作物已成熟
            if (elapsed >= seed.growthTime * 1000) {
                harvestCrop(i);
                harvested = true;
            }
        }
    }
    
    if (harvested) {
        logAction("自动收获执行完成", 'success');
    }
}

const liveStreamSystem = {
    level: 1,
    exp: 0,
    expToNextLevel: [1000, 5000, 7500, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000, 65000, 70000, 75000, 80000, 85000, 90000, 95000, 100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 2500000, 5000000, 7500000, 10000000, 25000000, 50000000, 75000000, 100000000, 10000000000],
    isLive: false,
    viewers: [],
    viewerCount: 0,
    maxViewers: 10,
    totalEarnings: 1000,
    expMultiplier: 1,
    lastUpdate: Date.now(),
   danmakuGeneratorActive: false,
    aiMessages: [
        "主播今天玩什么？",
        "加油！支持主播！",
        "这个游戏看起来好有趣",
        "刚刚的打斗太精彩了！",
        "主播技术真好",
        "求教学怎么快速转生",
        "关注了，下次还来",
        "礼物已送上，继续加油",
        "今天运气不错啊",
        "这个装备怎么获得的？",
        "6666666",
        "我喜欢你主播",
        "太强了",
         "主播嫁给我",
        "哈哈哈，这个操作笑死我了",
        "主播多大了？",
        "什么时候下次直播？",
        "求背景音乐名字",
        "画质好清晰啊",
        "卡了吗？怎么不动了",
        "第一次来看，感觉不错！",
        "求问主播用的什么鼠标？",
        "支持支持！打赏走一波",
        "这个角色怎么加点？",
        "新来的，关注了",
        "背景音乐好好听！",
        "刚刚那下没看清，能回放吗？",
        "主播吃饭了吗",
        "这游戏需要氪金吗？",
        "太厉害了吧，学到了",
        "卡了卡了，主播那边还好吗？",
        "下次能玩无限升级吗？",
        "礼物收到了吗？主播",
        "666，必须录屏了",
        "今天直播到几点呀？",
        "新手能玩这个游戏吗？",
        "主播加油，别慌！",
        "求组队一起玩！",
        "这个地图怎么解锁？",
        "哈哈哈，主播被坑了",
        "关注了，主播多更新",
        "主播今天状态不错啊",
        "网络有点卡，刷新试试",
        "这个技能怎么放的？",
        "刚刚那波失误有点可惜",
        "求主播带飞！",
        "这个游戏什么时候上线的？",
        "主播累不累？歇会儿吧",
        "新来的，求问这是什么游戏？",
        "太精彩了，全程没快进",
        "主播用的什么显卡？画质这么好",
        "下次直播能提前说一声吗？",
        "什么时候下次直播？",
        "刚刚那下反应好快！",
        "卡退了，重新进来了",
        "求问这个游戏怎么下载？",
        "主播技术比我朋友好多了",
        "哈哈哈，主播的表情太逗了",
        "这个游戏有手游吗？",
        "主播快回复一下我的问题呀",
        "网络怎么回事，老是卡顿",
        "主播明天几点直播？",
        "求教学怎么躲这个技能",
        "这个游戏画质真不错",
        "支持主播，会一直关注",
        "主播用的什么耳机？",
        "这个角色哪个职业最强？",
        "新来的，求主播带一下",
        "这个游戏需要什么配置？",
        "背景音乐是什么歌？好熟悉",
        "卡了，主播能等一下吗？",
        "主播今天直播内容好丰富",
        "求问怎么快速升级？",
        "礼物已刷，主播看得到吗？",
        "主播技术真的没话说，太强了",
        "新来的，觉得主播很有趣",
        "主播什么时候换游戏玩？",
        "关注了，下次开播提醒我",
        "支持主播，打赏不能少",
        "网络恢复了吗？刚才好卡",
        "求问这个游戏有攻略吗？",
        "这个游戏多人玩吗？",
        "关注了，主播要常开播哦",
        "主播今天心情不错呀",
        "新来的，求问主播常玩什么游戏？",
        "主播技术比我想象中好太多",
        "礼物送上，祝主播越来越好",
        "卡了卡了，大家都卡吗？",
        "主播明天还播这个游戏吗？",
        "支持主播，会推荐朋友来看",
        "关注了，主播多玩点新游戏",
        "主播今天直播时长多久呀？",
        "礼物已送，主播辛苦了",
        "主播什么时候开粉丝群？",
        "求问怎么获得金币快？",
        "刚刚的打斗太精彩了！",
        "支持主播，每天都来看",
        "关注了，主播记得回关哦",
        "关注了，下次还来",
        "网络终于不卡了",
        "今天运气不错啊",
        "这个装备怎么获得的？",
        "主播技术真的很专业",
        "这个游戏有等级上限吗？",
        "哈哈哈，这个操作笑死我了",
        "支持主播，打赏走起",
        "新来的，觉得直播很精彩",
        "背景音乐是谁唱的",
        "关注了，主播多搞点福利活动",
        "主播今天吃的什么呀？",
        "新来的，关注了不后悔",
        "主播技术越来越好的",
        "这个游戏看起来好有趣",
        "刚刚的打斗太精彩了！",
        "主播技术真好",
        "求教学怎么快速转生",
        "关注了，下次还来",
        "礼物已送上，继续加油",
        "今天运气不错啊",
        "美女",
        "支持主播，永远是粉丝",
        "这个游戏怎么创建角色？",
        "这个游戏有公会系统吗？",
        "关注了，下次开播不见不散",
        "求教学怎么放风筝",
         "老公吃饭了吗",
        "老婆吃饭了吗",
        "牛逼",
        "好厉害",
       "CPDD",
        "画质好清晰啊",
        "主播我喜欢你！",
        "你好菜啊",
        "加油！支持主播！",
        "这个游戏看起来好有趣",
        "刚刚的打斗太精彩了！",
        "网络又卡了，服了",
        "支持主播，会一直陪伴",
        "关注了，下次还来",
        "礼物已送上，继续加油",
        "这个游戏画面风格我喜欢",
        "这个游戏怎么举报外挂？",
        "主播下次能早点直播吗？",
        "这个游戏有师徒系统吗？",
        "哈哈哈，这个操作笑死我了",
        "主播有女朋友吗？",
        "什么时候下次直播？",
        "求背景音乐名字",
        "画质好清晰啊",
        "卡了吗？怎么不动了",
        "礼物送上，主播越来越火",
        "加油！支持主播！",
        "这个装备怎么镶嵌宝石？",
        "新来的，关注了，主播多播哦",  
        "晚安，先睡了",
        "明天还直播吗？"
    ],
    aiNames: [
        "闫闫", "花花", "茶茶", "鱼鱼", "通元","叶子", "沉鱼", "探探", "凡", "尝试", "胖大仙", "水芙蓉", "亲情相爱一家人", "伍思凯", "吖晴儿", 
        "苏菲", "王荣", "瑶瑶", "悸声", "反骨仔", "冰糖红茶", "蝴蝶效应,", "悦悦", "老倪", "慕白", "轩辕", "阿孝", "yuan", "王北的北,", "我已经在拉扯了", "林贝", "慕白", "阿迪", "微软是你", "王汝刚", "刘禹锡", "艾夫华", "渥太华", "阿杰", "阿道夫", "豆腐花茜茜", "阿法和阿伟","峰", "好人", "奥格威", "阿睿", "星嗄","阿华田", "子女不能", "开膛手杰华", "埃弗阿福", "黑丝姐姐", "黑菲","爱喝牛奶", "骚粉", "王如玉", "血红女爵", "水果",
        "萩", "我不高兴", "山麒麟", "管者", "阿斯巴甜","圣光", "征服他哥", "字画大师", "诗人睡睡", "孙国辉",
        "君子不气", "空白", "香香", "浪荡丶", "啦喇菈辣","十分", "神烦狗", "张枫五", "偶见", "孙国伟","时迁", "Plan B", "冥王", "阿顺帆",
        "Tung", "迷雾", "源", "泯潮猫", "寻良","冰箭", "赵哥", "张德荣", "三国英", "清茶", 
        "有意思", "非酋本酋", "肝双", "氪金佬", "舍尔", "赵哥帅", "张宝华", "祝福鱼", "珍贵仁",
         "Cardiac", "战无极", "凹凸曼", "白饭鱼", "独钓寒江雪",
        "锅巴", "花海", "怀安", "金刚骷髅娃", "锦瑟笙箫落",
        "旧", "举着戒指对你笑i", "磊哥", "凛", "六号线",
        "Numb", "柠檬妖精", "PoRo", "随风", "墨清",
        "桃子姐姐", "温存i", "我叫MMT", "我呀我", "小末影", "风影", "笑气气", "炫月", "燁燁",
        "一梦千年", "佳音如期", "功不唐捐", "卡子哥", "晨曦",
        "帅到分手", "午夜飞升", "星君", "预言", "成",
        "红尘", "幻月", "幻雪", "山与海", "虾仁哥哥",
        "风之奇影", "爱上风", "Dddddddd", "珊迪", "木子升", "建议击毙", "潮起潮落", "风云祭", "100分",
        "谷丶然", "无敌的话", "勿忘", "Rayn", "哈哈哈哈哈",
        "钵钵鸡", "笑气气", "花海", "Æternø", "天赋与努力",
        "晨落", "徒手", "柠檬", "余晖", "隐",
        "D", "三都", "大白菜帮子", "佳南",  "休闲玩家"
    ],
    donationMessages: [
        "送上小心心！",
        "给你点鼓励！",
        "支持主播！",
        "继续加油！",
        "小小礼物不成敬意",
        "今天的表现太棒了！",
        "值得鼓励！",
        "希望主播越来越好",
        "这是你应得的！",
        "打赏一波，主播辛苦了！",
        "希望越来越好，礼物支持",
        "一点心意，买杯奶茶喝~！",
        "看得尽兴，打赏表示",
        "关注很久了，今天送个礼物",
        "今天的直播超赞，打赏！",
        "主播加油，礼物来了哦",
        "小小礼物，不成敬意，继续加油",
        "每天必看，今天打赏一下",
        "这波太秀了，送礼物！",
        "希望你一直播下去，礼物支持",
        "主播辛苦了，送个小礼物",
        "支持你到底，打赏一波",
        "感谢带来欢乐，礼物请查收",
        "主播越来越好了，送个礼物",
        "今天看得过瘾，必须打赏",
        "喜欢你的直播，送点心意",
        "感谢分享，礼物送上！",
        "这波操作值个礼物！",
        "主播真棒，必须鼓励！",
        "感谢你的直播陪伴"
    ]
};
const danmakuSystem = {
    active: true,
    speed: 5, // 1-10
    density: 3, // 1-10
    container: null,
    colors: {
        system: '#ff00ff',
        viewer: '#ffffff',
        player: '#4CAF50',
        donation: '#FFD700'
    },
    tracks: [], // 弹幕轨道
    trackHeight: 30, // 每条轨道的高度
    maxTracks: 10, // 最大轨道数
    fontSizes: [14, 16, 18, 20],
    styles: ['normal', 'bold', 'italic']
};
// 初始化弹幕系统
function initDanmakuSystem() {
    danmakuSystem.container = document.getElementById('danmakuContainer');
    
    // 初始化轨道
    const containerHeight = danmakuSystem.container.clientHeight;
    danmakuSystem.maxTracks = Math.floor(containerHeight / danmakuSystem.trackHeight);
    danmakuSystem.tracks = [];
    
    for (let i = 0; i < danmakuSystem.maxTracks; i++) {
        danmakuSystem.tracks.push({
            occupied: false,
            lastUsed: 0
        });
    }
    
    // 设置弹幕控制事件
    document.getElementById('danmakuToggle').addEventListener('change', function() {
        danmakuSystem.active = this.checked;
        if (!this.checked) {
            clearDanmaku();
        }
    });
    
    document.getElementById('danmakuSpeed').addEventListener('input', function() {
        danmakuSystem.speed = parseInt(this.value);
    });
    
    document.getElementById('danmakuDensity').addEventListener('input', function() {
        danmakuSystem.density = parseInt(this.value);
    });
}

// 清除弹幕函数（修复）
function clearDanmaku() {
    if (!danmakuSystem.container) return;
    
    // 获取所有弹幕元素
    const danmakuElements = danmakuSystem.container.querySelectorAll('.danmaku');
    
    // 遍历所有弹幕元素
    danmakuElements.forEach(danmaku => {
        // 获取所有正在运行的动画
        const animations = danmaku.getAnimations();
        
        // 取消所有动画
        animations.forEach(animation => {
            animation.cancel();
        });
        
        // 移除元素
        danmaku.remove();
    });
    
    // 重置所有轨道状态
    if (danmakuSystem.tracks) {
        for (let i = 0; i < danmakuSystem.tracks.length; i++) {
            danmakuSystem.tracks[i].occupied = false;
            danmakuSystem.tracks[i].lastUsed = Date.now();
        }
    }
}

// 添加弹幕到直播画面
function addDanmakuToScreen(sender, message, type) {
    if (!danmakuSystem.active || !player.liveStream.isLive || !danmakuSystem.container) return;
    
    // 找到可用的轨道
    const availableTrack = findAvailableTrack();
    if (availableTrack === -1) return;
    
    // 创建弹幕元素
    const danmaku = document.createElement('div');
    danmaku.className = 'danmaku';
    danmaku.style.position = 'absolute';
    danmaku.style.top = `${availableTrack * danmakuSystem.trackHeight}px`;
    danmaku.style.right = '0';
    danmaku.style.color = danmakuSystem.colors[type] || '#ffffff';
    danmaku.style.fontSize = `${danmakuSystem.fontSizes[Math.floor(Math.random() * danmakuSystem.fontSizes.length)]}px`;
    danmaku.style.fontWeight = Math.random() > 0.7 ? 'bold' : 'normal';
    danmaku.style.fontStyle = Math.random() > 0.8 ? 'italic' : 'normal';
    danmaku.style.textShadow = '1px 1px 2px rgba(0,0,0,0.7)';
    danmaku.style.whiteSpace = 'nowrap';
    danmaku.style.zIndex = '2';
    danmaku.style.opacity = '0.9';
    danmaku.style.transform = 'translateX(100%)';
    danmaku.innerHTML = `<span style="color: #aaa;">${sender}:</span> ${message}`;
    
    // 添加到容器
    danmakuSystem.container.appendChild(danmaku);
    
    // 标记轨道占用
    danmakuSystem.tracks[availableTrack].occupied = true;
    
    // 计算动画时间
    const containerWidth = danmakuSystem.container.clientWidth;
    const danmakuWidth = danmaku.offsetWidth;
    const distance = containerWidth + danmakuWidth;
    const duration = distance / (danmakuSystem.speed * 50);
    
    // 应用动画
    const animation = danmaku.animate(
        [
            { transform: 'translateX(100%)' },
            { transform: `translateX(-${danmakuWidth}px)` }
        ],
        {
            duration: duration * 1000,
            easing: 'linear'
        }
    );
    
    animation.onfinish = () => {
        // 动画完成后移除元素并释放轨道
        if (danmaku.parentNode === danmakuSystem.container) {
            danmaku.remove();
        }
        if (availableTrack < danmakuSystem.tracks.length) {
            danmakuSystem.tracks[availableTrack].occupied = false;
            danmakuSystem.tracks[availableTrack].lastUsed = Date.now();
        }
    };
}

// 查找可用轨道
function findAvailableTrack() {
    if (!danmakuSystem.tracks || danmakuSystem.tracks.length === 0) return -1;
    
    // 按最后使用时间排序
    const sortedTracks = [...danmakuSystem.tracks]
        .map((track, index) => ({ ...track, index }))
        .sort((a, b) => a.lastUsed - b.lastUsed);
    
    for (let i = 0; i < sortedTracks.length; i++) {
        if (!sortedTracks[i].occupied) {
            return sortedTracks[i].index;
        }
    }
    
    // 如果没有空闲轨道，尝试使用最久未使用的轨道
    const oldestTrack = sortedTracks[0];
    if (Date.now() - oldestTrack.lastUsed > 5000) {
        return oldestTrack.index;
    }
    
    return -1;
}


// 初始化直播系统
function initLiveStreamSystem() {
    if (!player.liveStream) {
        player.liveStream = {
            level: 1,
            exp: 0,
            totalEarnings: 1000,
            isLive: false,
            lastLiveStart: 0,
            totalLiveTime: 0,
            expMultiplier: 1,
            viewers: [],
            donationHistory: [],
            lastDanmaku: null
        };
    }
}

// 切换直播系统界面
function toggleLiveStreamSystem() {
    if (player.reincarnationCount < 500) {
        alert("需要达到500转才能开启直播系统！");
        return;
    }
    const overlay = document.getElementById('liveStreamSystemOverlay');
    const ui = document.getElementById('liveStreamSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initLiveStreamSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateLiveStreamUI();
    }
}

// 更新直播系统UI
function updateLiveStreamUI() {
    document.getElementById('liveStreamLevel').textContent = player.liveStream.level;
    document.getElementById('liveStreamExp').textContent = Math.floor(player.liveStream.exp);
    document.getElementById('liveStreamNextExp').textContent = liveStreamSystem.expToNextLevel[player.liveStream.level - 1] || 10000000000;
    document.getElementById('totalLiveEarnings').textContent = (player.liveStream.totalEarnings/10).toFixed(0);
    document.getElementById('liveViewerCount').textContent = player.liveStream.viewers.length;
    
    // 更新经验条
    const expPercent = Math.min(100, (player.liveStream.exp / (liveStreamSystem.expToNextLevel[player.liveStream.level - 1] || 10000000000)) * 100);
    document.getElementById('liveExpProgress').style.width = `${expPercent}%`;
    
    // 更新观众列表
    const viewerList = document.getElementById('viewerList');
    viewerList.innerHTML = '';
    
    if (player.liveStream.viewers.length === 0) {
        viewerList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px 0;">暂无观众</div>';
    } else {
        player.liveStream.viewers.forEach(viewer => {
            const viewerElement = document.createElement('div');
            viewerElement.style.marginBottom = '5px';
            viewerElement.style.padding = '5px';
            viewerElement.style.background = '#0a0a1a';
            viewerElement.style.borderRadius = '3px';
            viewerElement.innerHTML = `👤 ${viewer.name}`;
            viewerList.appendChild(viewerElement);
        });
    }
    
    // 更新打赏记录
    const donationHistory = document.getElementById('donationHistory');
    donationHistory.innerHTML = '';
    
    if (player.liveStream.donationHistory.length === 0) {
        donationHistory.innerHTML = '<div style="text-align: center; color: #666; padding: 20px 0;">暂无打赏记录</div>';
    } else {
        // 只显示最近10条记录
        const recentDonations = player.liveStream.donationHistory.slice(-10);
        recentDonations.forEach(donation => {
            const donationElement = document.createElement('div');
            donationElement.style.marginBottom = '5px';
            donationElement.style.padding = '5px';
            donationElement.style.background = '#0a0a1a';
            donationElement.style.borderRadius = '3px';
            donationElement.innerHTML = `🎁 ${donation.viewer} 打赏了 ${donation.amount} 朵玫瑰花 - ${donation.message}`;
            donationHistory.appendChild(donationElement);
        });
    }
    
    // 更新直播状态
    const liveStatus = document.getElementById('liveStatus');
    const startLiveBtn = document.getElementById('startLiveBtn');
    
    if (player.liveStream.isLive) {
        liveStatus.innerHTML = `<div style="font-size: 24px; color: #ff00ff;">直播中</div><div>已直播: ${formatTimew(Date.now() - player.liveStream.lastLiveStart)}</div>`;
        startLiveBtn.textContent = '结束直播';
        startLiveBtn.style.background = '#f44336';
    } else {
        liveStatus.textContent = '直播未开始';
        startLiveBtn.textContent = '开始直播';
        startLiveBtn.style.background = '#ff00ff';
    }
}
function generateAIDanmaku() {
    if (!player.liveStream.isLive || !danmakuSystem.active) {
        liveStreamSystem.danmakuGeneratorActive = false;
        return;
    }
    
const minInterval = 10000 - (danmakuSystem.density * 800);
    const maxInterval = 20000 - (danmakuSystem.density * 1500);
    const interval = Math.random() * (maxInterval - minInterval) + minInterval;
    
    liveStreamSystem.danmakuGeneratorTimer = setTimeout(() => {
        if (player.liveStream.isLive && player.liveStream.viewers.length > 0) {
            const viewerIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
            const viewer = player.liveStream.viewers[viewerIndex];
            const message = liveStreamSystem.aiMessages[Math.floor(Math.random() * liveStreamSystem.aiMessages.length)];
            addDanmakuMessageq(viewer.name, message, "viewer");
            
            // 有小概率打赏
            if (Math.random() < 0.05) {
                generateDonation(viewer);
            }
        }
        
        // 递归调用前检查直播状态
        if (player.liveStream.isLive) {
            generateAIDanmaku();
        } else {
            liveStreamSystem.danmakuGeneratorActive = false;
        }
    }, interval);
}

// 开始直播
function startLiveStream() {
    if (player.liveStream.isLive) {
        stopLiveStream();
        return;
    }
     // 清除可能存在的弹幕生成器
    if (liveStreamSystem.danmakuGeneratorActive) {
        clearDanmakuGenerator();
    }
    player.liveStream.isLive = true;
    player.liveStream.lastLiveStart = Date.now();
    player.liveStream.viewers = [];
     liveStreamSystem.maxViewers = 10 + Math.floor(player.liveStream.level * 5);
    // 添加初始观众
    addViewers(liveStreamSystem.maxViewers*0.86);
     
    // 开始观众和互动定时器
    player.liveStream.viewerInterval = setInterval(updateViewers, 10000); // 每10秒更新观众
    player.liveStream.interactionInterval = setInterval(generateInteractions, 10000); // 每10秒生成互动
   initDanmakuSystem();
 // 启动弹幕生成器（确保只启动一次）
    if (!liveStreamSystem.danmakuGeneratorActive) {
        generateAIDanmaku();
        liveStreamSystem.danmakuGeneratorActive = true;
    }
    updateLiveStreamUI();
    addDanmakuMessageq("系统", "直播开始了！欢迎大家来到直播间！", "system");
    logAction("开始直播", "success");
}

// 停止直播
function stopLiveStream() {
    if (!player.liveStream.isLive) return;
    
    player.liveStream.isLive = false;
    const liveTime = Date.now() - player.liveStream.lastLiveStart;
    player.liveStream.totalLiveTime += liveTime;
    
    // 计算经验
    const expGain = Math.floor(liveTime / 1000) * player.liveStream.expMultiplier;
    player.liveStream.exp += expGain;
     liveStreamSystem.maxViewers = 10 + Math.floor(player.liveStream.level * 5);
    // 检查升级
    checkLiveLevelUp();
    
    // 清除定时器
    clearInterval(player.liveStream.viewerInterval);
    clearInterval(player.liveStream.interactionInterval);
    clearDanmakuGenerator();
    // 清空观众
    player.liveStream.viewers = [];
    clearDanmaku();
    
    updateLiveStreamUI();
    addDanmakuMessageq("系统", "直播已结束，感谢观看！", "system");
    
    logAction(`结束直播，获得 ${expGain} 直播经验`, "success");
    
}
function clearDanmakuGenerator() {
    if (liveStreamSystem.danmakuGeneratorTimer) {
        clearTimeout(liveStreamSystem.danmakuGeneratorTimer);
        liveStreamSystem.danmakuGeneratorTimer = null;
    }
    liveStreamSystem.danmakuGeneratorActive = false;
}


// 推广流量
function boostLiveStream() {
    if (player.nightClub.starCoins < 1000) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 1000;
    player.liveStream.expMultiplier = 2;
    
    // 设置1小时的加速效果
    player.liveStream.boostEndTime = Date.now() + 1 * 60 * 60 * 1000;
    
    // 添加更多观众
    addViewers(liveStreamSystem.maxViewers*0.4);
    
    updateLiveStreamUI();
    addDanmakuMessageq("系统", "主播使用了流量推广，直播间人气上升！", "system");
    
    logAction("使用流量推广，直播经验获取速度提升2倍，持续1小时", "success");
}

// 添加观众
function addViewers(count) {
    if (!player.liveStream.isLive) return;
    
    for (let i = 0; i < count; i++) {
        if (player.liveStream.viewers.length >= liveStreamSystem.maxViewers) break;
        
        const viewerName = liveStreamSystem.aiNames[Math.floor(Math.random() * liveStreamSystem.aiNames.length)];
        player.liveStream.viewers.push({
            id: Date.now() + Math.random(),
            name: viewerName,
            joinTime: Date.now(),
            activity: Math.random() // 活跃度
        });
    }
    
    updateLiveStreamUI();
}

// 更新观众
function updateViewers() {
    if (!player.liveStream.isLive) return;
    
    // 随机有观众离开
    if (player.liveStream.viewers.length > 0 && Math.random() < 0.3) {
        const leaveIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
        const leaveViewer = player.liveStream.viewers[leaveIndex];
        player.liveStream.viewers.splice(leaveIndex, 1);
        
        addDanmakuMessageq("系统", `${leaveViewer.name} 离开了直播间`, "system");
    }
    
    // 随机有新观众加入
    if (player.liveStream.viewers.length < liveStreamSystem.maxViewers && Math.random() < 0.7) {
        addViewers(1);
        const newViewer = player.liveStream.viewers[player.liveStream.viewers.length - 1];
        addDanmakuMessageq("系统", `${newViewer.name} 进入了直播间`, "system");
    }
    
    updateLiveStreamUI();
}

// 生成互动消息
function generateInteractions() {
    if (!player.liveStream.isLive || player.liveStream.viewers.length === 0) return;
    
    // 随机生成1-8条互动消息
    const messageCount = Math.floor(Math.random() * 7) + 1;
    
    for (let i = 0; i < messageCount; i++) {
        const viewerIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
        const viewer = player.liveStream.viewers[viewerIndex];
        
        const message = liveStreamSystem.aiMessages[Math.floor(Math.random() * liveStreamSystem.aiMessages.length)];
        addDanmakuMessageq(viewer.name, message, "viewer");
        
        // 有小概率打赏
        if (Math.random() < 0.05) {
            generateDonation(viewer);
        }
    }
}

// 生成打赏
function generateDonation(viewer) {
    // 打赏金额基于直播等级
    const baseAmount = player.liveStream.level * 1;
    const amount = Math.floor(baseAmount * (1 + Math.random() * 50));
    
    player.items.rose += amount;
    player.liveStream.totalEarnings += amount;
    
    const message = liveStreamSystem.donationMessages[Math.floor(Math.random() * liveStreamSystem.donationMessages.length)];
    
    // 记录打赏
    player.liveStream.donationHistory.push({
        viewer: viewer.name,
        amount: amount,
        message: message,
        time: Date.now()
    });
    
    addDanmakuMessageq("系统", `🎉 ${viewer.name} 打赏了 ${amount} 朵玫瑰花！${message}`, "donation");
    updateLiveStreamUI();
    updateDisplay();
}

// 发送弹幕
function sendDanmaku() {
    const input = document.getElementById('danmakuInput');
    const message = input.value.trim();
    
    if (message === '') return;
    
    addDanmakuMessageq(player.name, message, "player");
    input.value = '';
    
    // 玩家发送消息后，AI观众有概率回应
    if (player.liveStream.viewers.length > 0 && Math.random() < 0.5) {
        setTimeout(() => {
            const viewerIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
            const viewer = player.liveStream.viewers[viewerIndex];
            
            let response;
            if (message.includes('?')) {
                response = "这个问题问得好！";
            } else if (message.includes('谢谢') || message.includes('感谢')) {
                response = "不客气~";
            } else {
                response = "同意主播！" ;
            }
            
            addDanmakuMessageq(viewer.name, response, "viewer");
        }, 1000 + Math.random() * 2000);
    }
}

// 添加弹幕消息
function addDanmakuMessageq(sender, message, type) {
    const container = document.getElementById('danmakuContainerq');
    const messageElement = document.createElement('div');
    messageElement.className = 'danmaku-message';
    
    // 根据消息类型设置样式
    switch(type) {
        case "system":
            messageElement.style.color = '#ff00ff';
            break;
        case "donation":
            messageElement.style.color = '#FFD700';
            messageElement.style.fontWeight = 'bold';
            break;
        case "player":
            messageElement.style.color = '#4CAF50';
            break;
        default:
            messageElement.style.color = '#ccc';
    }
    
    messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
    container.appendChild(messageElement);
      if (player.liveStream.isLive) {
        addDanmakuToScreen(sender, message, type);}
    // 自动滚动到底部
    container.scrollTop = container.scrollHeight;
   
    // 限制消息数量
    if (container.children.length > 30) {
        container.removeChild(container.children[0]);
    }
}

// 检查直播等级提升
function checkLiveLevelUp() {
    const nextLevelExp = liveStreamSystem.expToNextLevel[player.liveStream.level - 1] || 10000000000;
    
    if (player.liveStream.exp >= nextLevelExp) {
        player.liveStream.level++;
        player.liveStream.exp -= nextLevelExp;
        
        // 增加最大观众数
         liveStreamSystem.maxViewers = 10 + Math.floor(player.liveStream.level * 5);
        
        addDanmakuMessageq("系统", `恭喜！直播等级提升到 ${player.liveStream.level} 级！`, "system");
        logAction(`直播等级提升到 ${player.liveStream.level} 级！`, "success");
        
        // 递归检查是否还能升级
        checkLiveLevelUp();
    }
    
    updateLiveStreamUI();
}

// 格式化时间
function formatTimew(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    return `${hours.toString().padStart(2, '0')}:${(minutes % 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
}

// 在游戏主循环中更新直播经验
function updateLiveStreamExperience() {
    if (player.liveStream && player.liveStream.isLive) {
        const now = Date.now();
        const elapsed = now - player.liveStream.lastUpdate;
        player.liveStream.lastUpdate = now;
        
        // 检查加速是否结束
        if (player.liveStream.boostEndTime && now > player.liveStream.boostEndTime) {
            player.liveStream.expMultiplier = 1;
            player.liveStream.boostEndTime = null;
            addDanmakuMessageq("系统", "流量推广效果已结束", "system");
        }
        
        // 每秒获得1点经验乘以倍率
        const expGain = (elapsed / 1000) * player.liveStream.expMultiplier;
        player.liveStream.exp += expGain;
        
        // 检查升级
        checkLiveLevelUp();
        
        // 更新UI
        updateLiveStreamUI();
    }
}

// 礼物数据
const giftBoxSystem = {
    gifts: [
        { name: "鲜花", value: 10000, probability: 70, icon: "💐", color: "#4CAF50" },
        { name: "墨镜", value: 25000, probability: 19.889, icon: "🕶️", color: "#2196F3" },
        { name: "礼花筒", value: 50000, probability: 7, icon: "🎆", color: "#FFC107" },
        { name: "比心兔兔", value: 100000, probability: 3, icon: "🐰💖", color: "#E91E63" },
        { name: "热气球", value: 520000, probability: 0.1, icon: "🎈", color: "#9C27B0" },
        { name: "跑车", value: 1200000, probability: 0.01, icon: "🏎️", color: "#FF5722" },
        { name: "嘉年华", value: 2800000, probability: 0.001, icon: "🎪", color: "#00BCD4" }
    ],
    drawCost: 50
};

// 打开盲盒宝箱界面
function openGiftBox() {
    document.getElementById('giftBoxModal').style.display = 'flex';
    resetGiftBox();
}

// 关闭盲盒宝箱界面
function closeGiftBox() {
    document.getElementById('giftBoxModal').style.display = 'none';
}

// 重置盲盒显示
function resetGiftBox() {
    const boxInner = document.getElementById('boxInner');
    boxInner.style.transform = 'rotateY(0deg)';
    
    document.getElementById('giftIcon').textContent = '🎁';
    document.getElementById('giftName').textContent = '未知礼物';
    document.getElementById('giftValue').textContent = '价值: 0 玫瑰花';
}

// 抽取礼物
function drawGift() {
    if (player.nightClub.starCoins < 500) {
        logAction("星币不足！", "error");
        return;
    }
    
    // 扣除星币
    player.nightClub.starCoins -= 500;
   
    
    // 计算总概率
    const totalProbability = giftBoxSystem.gifts.reduce((sum, gift) => sum + gift.probability, 0);
    
    // 生成随机数
    const random = Math.random() * totalProbability;
    
    // 确定获得的礼物
    let cumulative = 0;
    let selectedGift = null;
    
    for (const gift of giftBoxSystem.gifts) {
        cumulative += gift.probability;
        if (random <= cumulative) {
            selectedGift = gift;
            break;
        }
    }
    
    // 如果没有选中礼物（理论上不会发生），默认给鲜花
    if (!selectedGift) {
        selectedGift = giftBoxSystem.gifts[0];
    }
    
    // 更新直播总收益
    player.liveStream.totalEarnings += selectedGift.value;
    
    // 记录打赏
    player.liveStream.donationHistory.push({
        viewer: "主播自己",
        amount: selectedGift.value,
        message: `获得${selectedGift.name}`,
        time: Date.now()
    });
    
    // 显示礼物结果
    showGiftResult(selectedGift);
    
    // 添加弹幕消息
    addDanmakuMessageq("系统", `恭喜主播从盲盒中，抽到了${selectedGift.name}`, "system");
    
    // 更新UI
    updateLiveStreamUI();
    updateDisplay();
    
    logAction(`开启盲盒获得${selectedGift.name}，价值${selectedGift.value}朵玫瑰花`, "success");
}

// 显示礼物结果
function showGiftResult(gift) {
    const boxInner = document.getElementById('boxInner');
    const giftIcon = document.getElementById('giftIcon');
    const giftName = document.getElementById('giftName');
    const giftValue = document.getElementById('giftValue');
    
    // 更新礼物信息
    giftIcon.textContent = gift.icon;
    giftName.textContent = gift.name;
    giftName.style.color = gift.color;
    giftValue.textContent = `价值: ${gift.value.toLocaleString()} 玫瑰花`;
    
    // 添加动画效果
    boxInner.style.transform = 'rotateY(180deg)';
    
    // 添加粒子效果
    createParticles();
}

// 创建粒子效果
function createParticles() {
    const giftBox = document.getElementById('giftBox');
    const colors = ['#ff9966', '#ff5e62', '#ffcc00', '#4CAF50', '#2196F3'];
    
    for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = '8px';
        particle.style.height = '8px';
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        particle.style.borderRadius = '50%';
        particle.style.zIndex = '10';
        
        // 随机位置
        const posX = Math.random() * 200;
        const posY = Math.random() * 200;
        particle.style.left = `${posX}px`;
        particle.style.top = `${posY}px`;
        
        giftBox.appendChild(particle);
        
        // 动画效果
        const angle = Math.random() * Math.PI * 2;
        const distance = 100 + Math.random() * 100;
        const duration = 1000 + Math.random() * 500;
        
        particle.animate(
            [
                { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`, opacity: 0 }
            ],
            {
                duration: duration,
                easing: 'ease-out'
            }
        ).onfinish = () => {
            particle.remove();
        };
    }
}



const worldZones = [
    {
        id: 'beginner',
        name: '新手村',
        minLevel: 1,
        maxLevel: 49,
        expRange: [1, 10],
        monsterNames: ['小妖', '小怪', '小兽', '小魔', '小精', '小灵', '小魂', '小魄'],
        modifiers: [
            { name: '普通', health: 1.0, attack: 2.0 },
            { name: '强壮', health: 1.5, attack: 3.2 },
            { name: '野蛮', health: 2.2, attack: 2.5 },
            { name: '弱小', health: 0.5, attack: 0.2 },
            { name: '强大', health: 5.2, attack: 5.5 },
            { name: '影子', health: 3.5, attack: 2.2 },
            { name: '敏捷', health: 2.2, attack: 10.5 },
            { name: '狂暴', health: 1.3, attack: 11.8 }
        ]
    },
    {
        id: 'forest',
        name: '落木林',
        minLevel: 50,
        maxLevel: 99,
        expRange: [10, 25],
        monsterNames: ['树妖', '木精', '叶魔', '根魂', '枝魄', '森灵', '林怪', '藤妖'],
        modifiers: [
            { name: '剧毒', health: 3.2, attack: 1.8 },
            { name: '缠绕', health: 5.8, attack: 31.2 },
            { name: '吸血', health: 7.5, attack: 5.5 },
            { name: '邪恶', health: 23.8, attack: 3.2 },
            { name: '幽魂', health: 6.5, attack: 7.5 },
            { name: '火焰', health: 7.8, attack: 8.2 },
            { name: '冰霜', health: 9.5, attack: 13.5 },   
            { name: '雷霆', health: 10.8, attack: 23.2 },
            { name: '闪电', health: 5.5, attack: 5.5 },
            { name: '再生', health: 7.0, attack: 1.0 }
            
        ]
    },
    {
        id: 'plains',
        name: '青风平原',
        minLevel: 100,
        maxLevel: 149,
        expRange: [25, 50],
        monsterNames: ['风灵', '草妖', '石魔', '土魂', '沙魄', '云精', '雾怪', '雨灵'],
        modifiers: [
            { name: '疾风', health: 21.0, attack: 12.0 },
            { name: '厚土', health: 12.0, attack: 13.0 },
            { name: '飞沙', health: 11.5, attack: 15.8 },
            { name: '风暴', health: 21.0, attack: 18.0 },
            { name: '流沙', health: 12.0, attack: 11.0 },
            { name: '魅影', health: 21.5, attack: 21.8 },
            { name: '龙卷风', health: 21.0, attack: 32.0 },
            { name: '法师', health: 12.0, attack: 41.0 },
            { name: '刺客', health: 12.5, attack: 51.8 },
            { name: '迷雾', health: 15.8, attack: 21.5 }

        ]
    },
    {
        id: 'swamp',
        name: '迷雾沼泽',
        minLevel: 150,
        maxLevel: 199,
        expRange: [50, 100],
        monsterNames: ['沼魔', '泥妖', '水精', '雾魂', '毒魄', '瘴灵', '腐怪', '湿妖'],
        modifiers: [
            { name: '剧毒', health: 10.5, attack: 20.0 },
            { name: '腐蚀', health: 20.0, attack: 10.8 },
            { name: '减速', health: 104.8, attack: 10.5 },
            { name: '灼烧', health: 10.5, attack: 70.0 },
            { name: '冰冻', health: 20.0, attack: 80.8 },
            { name: '野蛮', health: 100.8, attack: 380.5 },
            { name: '毒粉', health: 10.5, attack: 250.0 },
            { name: '妖化', health: 20.0, attack: 140.8 },
            { name: '电王', health: 140.8, attack: 130.5 },
            { name: '致盲', health: 100.5, attack: 200.2 }
        ]
    },
    {
        id: 'nest',
        name: '剧毒巢穴',
        minLevel: 200,
        maxLevel: 249,
        expRange: [100, 250],
        monsterNames: ['毒蛛', '蝎魔', '蛇妖', '蜈蚣精', '蟾蜍怪', '蜂后', '蚁王', '蝇魔'],
        modifiers: [
            { name: '致命毒液', health: 10.8, attack: 52.5 },
            { name: '麻痹毒素', health: 280.0, attack: 172.0 },
            { name: '神经毒素', health: 180.5, attack: 113.0 },
            { name: '灵魂毒液', health: 30.8, attack: 412.5 },
            { name: '肉体毒素', health: 280.0, attack: 221.0 },
            { name: '轻微毒素', health: 20.5, attack: 433.0 },
            { name: '智障毒液', health: 10.8, attack: 302.5 },
            { name: '雷雨毒素', health: 23.0, attack: 602.0 },
            { name: '闪电毒素', health: 101.5, attack: 333.0 },
            { name: '腐蚀酸液', health: 87.5, attack: 702.2 }
        ]
    },
    {
        id: 'wetland',
        name: '浅滩湿地',
        minLevel: 250,
        maxLevel: 299,
        expRange: [250, 500],
        monsterNames: ['水妖', '泽魔', '滩魂', '湿魄', '藻精', '贝怪', '蟹灵', '虾妖'],
        modifiers: [
            { name: '水之护盾', health: 32.0, attack: 12.5 },
            { name: '潮汐之力', health: 11.8, attack: 52.8 },
            { name: '深海恐惧', health: 21.5, attack: 23.5 },
            { name: '水之战舰', health: 341.0, attack: 123.5 },
            { name: '潮汐冰箭', health: 11.8, attack: 312.8 },
            { name: '深海咆哮', health: 21.5, attack: 232.5 },
            { name: '水王', health: 53.0, attack: 791.5 },
            { name: '水皇', health: 551.8, attack: 552.8 },
            { name: '水尊', health: 288.5, attack: 882.5 },
            { name: '漩涡牵引', health: 26.0, attack: 356.0 }
        ]
    },
    {
        id: 'canyon',
        name: '黑风峡谷',
        minLevel: 300,
        maxLevel: 349,
        expRange: [500, 1000],
        monsterNames: ['岩魔', '石怪', '山精', '谷魂', '崖魄', '壁妖', '穴灵', '洞魔'],
        modifiers: [
            { name: '岩甲', health: 40.0, attack: 100.8 },
            { name: '落石', health: 20.5, attack: 300.0 },
            { name: '地震', health: 30.5, attack: 200.8 },
            { name: '石小妖', health: 2.0, attack: 10.8 },
            { name: '石头怪', health: 20.5, attack: 30.0 },
            { name: '石帝', health: 30.5, attack: 310.8 },
            { name: '石妖', health: 100.0, attack: 120.8 },
            { name: '石王', health: 20.5, attack: 300.0 },
            { name: '石皇', health: 200.5, attack: 200.8 },
            { name: '山崩', health: 200.0, attack: 300.5 }
        ]
    },
    {
        id: 'swamp2',
        name: '迷雾沼泽深处',
        minLevel: 350,
        maxLevel: 399,
        expRange: [1000, 2500],
        monsterNames: ['沼王', '泥后', '水帝', '雾皇', '毒尊', '瘴圣', '腐神', '湿魔'],
        modifiers: [
            { name: '剧毒领域', health: 100.0, attack: 400.0 },
            { name: '腐蚀领域', health: 20.0, attack: 300.5 },
            { name: '迷雾领域', health: 30.5, attack: 200.5 },
            { name: '氧化领域', health: 30.0, attack: 400.0 },
            { name: '腐闪领域', health: 40.0, attack: 300.5 },
            { name: '蜂石领域', health: 30.5, attack: 800.5 },
            { name: '恶徒领域', health: 30.0, attack: 400.0 },
            { name: '螣神领域', health: 40.0, attack: 100.5 },
            { name: '山峰领域', health: 30.5, attack: 300.5 },
            { name: '死亡领域', health: 100.0, attack: 500.0 }
        ]
    },
    {
        id: 'abyss',
        name: '暗影深渊',
        minLevel: 400,
        maxLevel: 449,
        expRange: [2500, 5000],
        monsterNames: ['影魔', '暗妖', '渊魂', '冥魄', '夜精', '幽怪', '鬼灵', '魅魔'],
        modifiers: [
            { name: '暗影突袭', health: 30.5, attack: 700.0 },
            { name: '深渊凝视', health: 150.0, attack: 310.0 },
            { name: '虚空吞噬', health: 140.5, attack: 450.8 },
            { name: '时间回溯', health: 230.5, attack: 500.0 },
            { name: '精神屏障', health: 50.0, attack: 300.0 },
            { name: '晶体穿刺', health: 210.5, attack: 100.8 },
            { name: '空间封锁', health: 100.5, attack: 200.0 },
            { name: '声波共振', health: 50.0, attack: 200.0 },
            { name: '精神链接', health: 30.5, attack: 400.8 },
            { name: '永夜降临', health: 200.0, attack: 600.0 }
        ]
    },
    {
        id: 'rift',
        name: '混沌之隙',
        minLevel: 450,
        maxLevel: 499,
        expRange: [5000, 10000],
        monsterNames: ['混沌兽', '无序魔', '混乱妖', '虚空精', '扭曲魂', '裂痕魄', '次元怪', '位面灵'],
        modifiers: [
            { name: '混沌护盾', health: 80.0, attack: 500.0 },
            { name: '空间撕裂', health: 50.5, attack: 800.0 },
            { name: '时间扭曲', health: 70.0, attack: 700.0 },
            { name: '时间停滞', health: 200.0, attack: 500.0 },
            { name: '空间暗影', health: 100.5, attack: 100.0 },
            { name: '时间风暴', health: 70.0, attack: 200.0 },
            { name: '维度停滞', health: 20.0, attack: 500.0 },
            { name: '暗影风暴', health: 200.5, attack: 200.0 },
            { name: '混沌风暴', health: 70.0, attack: 700.0 },
            { name: '位面崩塌', health: 100.0, attack: 100.0 }
        ]
    },
    {
        id: 'battlefield',
        name: '血狱战场',
        minLevel: 500,
        maxLevel: 549,
        expRange: [10000, 15000],
        monsterNames: ['血魔', '狱妖', '战魂', '争魄', '杀精', '戮怪', '伐灵', '征魔'],
        modifiers: [
            { name: '嗜血', health: 400.0, attack: 10000.0 },
            { name: '狂战', health: 80.0, attack: 8000.0 },
            { name: '不屈', health: 10.0, attack: 5000.0 },
            { name: '血族', health: 300.0, attack: 10000.0 },
            { name: '狂战族', health: 50.0, attack: 3000.0 },
            { name: '不屈族', health: 150.0, attack: 2000.0 },
            { name: '嗜血族', health: 600.0, attack: 10000.0 },
            { name: '狂战血脉', health: 500.0, attack: 1800.0 },
            { name: '不屈血脉', health: 150.0, attack: 1500.0 },
            { name: '死战', health: 530.0, attack: 15000.0 }
        ]
    },
    {
        id: 'lair',
        name: '恶魔巢穴',
        minLevel: 550,
        maxLevel: 599,
        expRange: [15000, 25000],
        monsterNames: ['恶魔领主', '深渊魔王', '地狱公爵', '炼狱侯爵', '邪能伯爵', '堕落子爵', '腐化男爵', '扭曲骑士'],
        modifiers: [
            { name: '恶魔之怒', health: 100.0, attack: 3500.0 },
            { name: '深渊之力', health: 20.0, attack: 8200.0 },
            { name: '炼狱之力', health: 120.0, attack: 18000.0 },
            { name: '恶魔之力', health: 130.0, attack: 1500.0 },
            { name: '夜魔之力', health: 30.0, attack: 1200.0 },
            { name: '地狱之力', health: 120.0, attack: 18000.0 },
            { name: '魔神之力', health: 10.0, attack: 15000.0 },
            { name: '深渊核心', health: 110.0, attack: 12000.0 },
            { name: '地火核心', health: 120.0, attack: 1800.0 },
            { name: '邪能腐蚀', health: 480.0, attack: 38000.0 }
        ]
    },
    {
        id: 'throne',
        name: '冰封王座',
        minLevel: 600,
        maxLevel: 649,
        expRange: [25000, 50000],
        monsterNames: ['冰霜巨龙', '寒冰巫妖', '极地巨人', '雪域女王', '冰川领主', '冻土之王', '永冬守卫', '霜寒使者'],
        modifiers: [
            { name: '绝对零度', health: 20.0, attack: 1200.0 },
            { name: '冰封领域', health: 100.0, attack: 7000.0 },
            { name: '霜冻新星', health: 20.0, attack: 1300.0 },
            { name: '零度之力', health: 20.0, attack: 4800.0 },
            { name: '封神领域', health: 320.0, attack: 10000.0 },
            { name: '霜冻之力', health: 10.0, attack: 800.0 },
            { name: '霜寒死神', health: 200.0, attack: 3200.0 },
            { name: '冰封之力', health: 30.0, attack: 2200.0 },
            { name: '灵魂深王', health: 250.0, attack: 13020.0 },
            { name: '寒冰牢笼', health: 550.0, attack: 45000.0 }
        ]
    },
    {
        id: 'wasteland',
        name: '血月荒原',
        minLevel: 650,
        maxLevel: 699,
        expRange: [50000, 100000],
        monsterNames: ['血月狼王', '赤红巨蝎', '绯色狮鹫', '猩红飞龙', '朱红泰坦', '深红梦魇', '鲜红收割者', '暗红破坏神'],
        modifiers: [
            { name: '血月之力', health: 400.0, attack: 5000.0 },
            { name: '猩红狂暴', health: 90.0, attack: 7200.0 },
            { name: '赤红领域', health: 300.0, attack: 4400.0 },
            { name: '血月暗魔', health: 400.0, attack: 2000.0 },
            { name: '猩红之力', health: 70.0, attack: 31000.0 },
            { name: '血族领域', health: 61.0, attack: 14000.0 },
            { name: '血月战刃', health: 30.0, attack: 25000.0 },
            { name: '收割者领域', health: 40.0, attack: 5000.0 },
            { name: '梦魇领域', health: 69.0, attack: 41000.0 },
            { name: '深红诅咒', health: 390.0, attack: 60000.0 }
        ]
    },
    {
        id: 'ruins',
        name: '时空废墟',
        minLevel: 700,
        maxLevel: 749,
        expRange: [100000, 500000],
        monsterNames: ['时空守护者', '裂隙观察者', '维度旅行者', '位面穿梭者', '虚空漫步者', '次元监察者', '宇宙编织者', '现实扭曲者'],
        modifiers: [
            { name: '时间加速', health: 20.0, attack: 8000.0 },
            { name: '空间折叠', health: 280.0, attack: 7000.0 },
            { name: '维度撕裂', health: 190.0, attack: 4000.0 },
            { name: '量子隐身', health: 70.0, attack: 81000.0 },
            { name: '时间碎片', health: 380.0, attack: 23000.0 },
            { name: '维度错位', health: 90.0, attack: 18000.0 },
            { name: '中子星脉冲', health: 70.0, attack: 20000.0 },
            { name: '时间分流', health: 80.0, attack: 30000.0 },
            { name: '超声波攻击', health: 400.0, attack: 50000.0 },
            { name: '现实重构', health: 600.0, attack: 100000.0 }
        ]
    },
    {
        id: 'land',
        name: '星陨之地',
        minLevel: 750,
        maxLevel: 799,
        expRange: [500000, 1000000],
        monsterNames: ['星陨巨兽', '陨石领主', '彗星使者', '流星猎人', '行星吞噬者', '恒星毁灭者', '星系守护者', '宇宙创造者'],
        modifiers: [
            { name: '星辰坠落', health: 150.0, attack: 5800.0 },
            { name: '黑洞吞噬', health: 20.0, attack: 25000.0 },
            { name: '超新星爆发', health: 180.0, attack: 53000.0 },
            { name: '星辰碰撞', health: 150.0, attack: 70100.0 },
            { name: '流星吞噬', health: 200.0, attack: 15000.0 },
            { name: '毁灭爆发', health: 18.0, attack: 30000.0 },
            { name: '星辰爆炸', health: 150.0, attack: 80000.0 },
            { name: '银河吞噬', health: 200.0, attack: 45000.0 },
            { name: '超新爆风', health: 180.0, attack: 220000.0 },
            { name: '宇宙大爆炸', health: 700.0, attack: 300000.0 }
        ]
    },
    {
        id: 'temple',
        name: '永恒圣殿',
        minLevel: 800,
        maxLevel: 849,
        expRange: [1000000, 5000000],
        monsterNames: ['圣殿守卫', '永恒骑士', '不朽祭司', '神圣主教', '天界大天使', '神域审判者', '至高仲裁者', '创世神使'],
        modifiers: [
            { name: '神圣庇护', health: 50.0, attack: 10000.0 },
            { name: '永恒之光', health: 140.0, attack: 30100.0 },
            { name: '神之裁决', health: 310.0, attack: 151000.0 },
            { name: '神圣打击', health: 520.0, attack: 301020.0 },
            { name: '神圣之光', health: 240.0, attack: 60200.0 },
            { name: '神之神剑', health: 600.0, attack: 51000.0 },
            { name: '神圣护盾', health: 450.0, attack: 440000.0 },
            { name: '神王护体', health: 240.0, attack: 360000.0 },
            { name: '神尊破灭', health: 160.0, attack: 252000.0 },
            { name: '创世之力', health: 1000.0, attack: 800000.0 }
        ]
    },
    {
        id: 'realm',
        name: '万象界域',
        minLevel: 850,
        maxLevel: 899,
        expRange: [5000000, 10000000],
        monsterNames: ['万象之主', '元素皇帝', '法则掌控者', '秩序守护神', '混沌化身', '虚空君主', '位面主宰', '多元宇宙观察者'],
        modifiers: [
            { name: '元素风暴', health: 130.0, attack: 42000.0 },
            { name: '法则扭曲', health: 750.0, attack: 80000.0 },
            { name: '秩序崩坏', health: 420.0, attack: 65000.0 },
            { name: '元素至尊', health: 300.0, attack: 92000.0 },
            { name: '法则至尊', health: 280.0, attack: 100000.0 },
            { name: '秩序至尊', health: 240.0, attack: 250000.0 },
            { name: '万象至尊', health: 400.0, attack: 320000.0 },
            { name: '混沌至尊', health: 430.0, attack: 400000.0 },
            { name: '位面至尊', health: 320.0, attack: 750000.0 },
            { name: '混沌初开', health: 1000.0, attack: 1000000.0 }
        ]
    },
    {
        id: 'realm2',
        name: '鸿蒙秘境',
        minLevel: 900,
        maxLevel: 949,
        expRange: [10000000, 50000000],
        monsterNames: ['鸿蒙巨兽', '太初古神', '元始天尊', '造化之主', '命运编织者', '因果律者', '真理守护者', '终极观察者'],
        modifiers: [
            { name: '鸿蒙初开', health: 500.0, attack: 1100000.0 },
            { name: '太初之力', health: 700.0, attack: 2400000.0 },
            { name: '造化神功', health: 200.0, attack: 1100000.0 },
            { name: '鸿蒙尊者', health: 100.0, attack: 2050000.0 },
            { name: '太初尊者', health: 700.0, attack: 3020000.0 },
            { name: '未来尊者', health: 80.0, attack: 4001000.0 },
            { name: '命运尊者', health: 200.0, attack: 6000000.0 },
            { name: '太古尊者', health: 70.0, attack: 3000000.0 },
            { name: '九亥古神', health: 200.0, attack: 7000000.0 },
            { name: '终极真理', health: 1000.0, attack: 10000000.0 }
        ]
    },
    {
        id: 'domain',
        name: '终焉神域',
        minLevel: 950,
        maxLevel: 1000,
        expRange: [50000000, 100000000],
        monsterNames: ['终焉之主', '灭世魔神', '创世之神', '永恒终结者', '无限吞噬者', '绝对虚无', '最终答案', '一切之终'],
        modifiers: [
            { name: '终焉降临', health: 20.0, attack: 5000000.0 },
            { name: '灭世之力', health: 80.0, attack: 12000000.0 },
            { name: '创世之力', health: 20.0, attack: 8000000.0 },
            { name: '终焉之力', health: 240.0, attack: 27000000.0 },
            { name: '永恒之力', health: 310.0, attack: 12000000.0 },
            { name: '无限之力', health: 120.0, attack: 6000000.0 },
            { name: '绝对之力', health: 300.0, attack: 24000000.0 },
            { name: '灭世之力', health: 700.0, attack: 4200000.0 },
            { name: '灰烬之力', health: 550.0, attack: 20100000.0 },
            { name: '绝对虚无', health: 1000.0, attack: 50000000.0 }
        ]
    }
];
const dimensionConfig = {
    1: { cost: 1, expMultiplier: 1, attackMultiplier: 1, name: "次元1", ascentionRequired: 0 },
    2: { cost: 3, expMultiplier: 5, attackMultiplier: 100000, name: "次元2", ascentionRequired: 1 },
    3: { cost: 5, expMultiplier: 10, attackMultiplier: 1e10, name: "次元3", ascentionRequired: 2 },
    4: { cost: 25, expMultiplier: 50, attackMultiplier: 1e20, name: "次元4", ascentionRequired: 3 },
    5: { cost: 50, expMultiplier: 100, attackMultiplier: 1e30, name: "次元5", ascentionRequired: 4 }
};

        // 切换次元难度
      function changeDimension(level) {
    const config = dimensionConfig[level];
    
    // 检查轮回转生次数要求
    if (player.level.ascentionCounta < config.ascentionRequired) {
        logAction(`进入${config.name}需要轮回${config.ascentionRequired}转！当前轮回${player.level.ascentionCounta}转`, "error");
        return;
    }
    
    player.dimensionLevel = level;
    updateDimensionUI();
    saveGame();
    logAction(`已切换到${config.name}`, "success");
}

// 修改更新次元难度UI显示函数
function updateDimensionUI() {
    // 更新按钮激活状态和可用性
    document.querySelectorAll('.dimension-btn').forEach((btn, index) => {
        const level = index + 1;
        const config = dimensionConfig[level];
        const canAccess = player.level.ascentionCounta >= config.ascentionRequired;
        
        if (level === player.dimensionLevel) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
        
        // 根据是否可访问设置按钮样式
        if (!canAccess) {
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
            btn.title = `需要轮回${config.ascentionRequired}转`;
        } else {
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
            btn.title = '';
        }
    });
    
    // 更新难度信息
    const config = dimensionConfig[player.dimensionLevel];
    document.getElementById('currentDimension').textContent = config.name;
    document.getElementById('dimensionCost').textContent = config.cost;
    document.getElementById('dimensionExpMultiplier').textContent = config.expMultiplier;
    document.getElementById('dimensionAttackMultiplier').textContent = config.attackMultiplier.toExponential(1);
    
    // 显示轮回转生要求
    document.querySelector('.dimension-info').innerHTML = `
        当前难度: <span id="currentDimension">${config.name}</span><br>
        轮回要求: ${config.ascentionRequired}转<br>
        星币消耗: <span id="dimensionCost">${config.cost}</span><br>
        经验倍数: <span id="dimensionExpMultiplier">${config.expMultiplier}</span>倍<br>
        怪物攻击: <span id="dimensionAttackMultiplier">${config.attackMultiplier.toExponential(1)}</span>倍
    `;
}
// 切换世界地图界面
function toggleWorldMap() {
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启世界地图！");
        return;
    }
    
    // 关闭所有自动攻击（包括后台）
    stopAllWorldMapBattles();
    
    const overlay = document.getElementById('worldMapOverlay');
    const ui = document.getElementById('worldMapUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateWorldMapUI();
    }
}
function stopAllWorldMapBattles() {
    // 停止前台自动战斗
    if (player.worldMapBattle.autoBattleInterval) {
        clearInterval(player.worldMapBattle.autoBattleInterval);
        player.worldMapBattle.autoBattleInterval = null;
    }
    
    // 停止后台自动战斗
    stopBackgroundBattle();
    
    // 重置战斗状态
    player.backgroundBattle.active = false;
}
// 更新世界地图界面
function updateWorldMapUI() {
    const container = document.getElementById('zoneList');
    container.innerHTML = '';
    
    worldZones.forEach(zone => {
        const zoneElement = document.createElement('div');
        zoneElement.style.background = '#333';
        zoneElement.style.padding = '15px';
        zoneElement.style.borderRadius = '8px';
        zoneElement.style.textAlign = 'center';
        zoneElement.style.cursor = 'pointer';
        
        zoneElement.innerHTML = `
            <h3>${zone.name}</h3>
            <div>等级: ${zone.minLevel}-${zone.maxLevel}</div>
            <div>经验: ${zone.expRange[0]}-${zone.expRange[1]}*(VIP*10)</div>
        `;
        
        zoneElement.onclick = () => startBattleInZone(zone);
        container.appendChild(zoneElement);
    });
}

// 在指定区域开始战斗
function startBattleInZone(zone) {
    const dimension = dimensionConfig[player.dimensionLevel];
    
    // 检查轮回转生要求
    if (player.level.ascentionCounta < dimension.ascentionRequired) {
        logAction(`进入${dimension.name}需要轮回${dimension.ascentionRequired}转！当前轮回${player.level.ascentionCounta}转`, "error");
        toggleWorldMap();
        return;
    }
    
    if (player.nightClub.starCoins < dimension.cost) {
        logAction(`星币不足！需要${dimension.cost}个星币`, "error");
        toggleWorldMap();
        return;
    }
    
    player.nightClub.starCoins -= dimension.cost;
    logAction(`消耗${dimension.cost}个星币生成怪物（${dimension.name}）`, "info");
    player.battle.currentZone = zone;
    
    // 生成怪物（考虑次元难度）
    generateMonsterForZone(zone, dimension);
    
    // 初始化战斗状态
    player.battle.monsterResurrections = 0;
    
    // 显示战斗界面
    document.getElementById('worldMapUI').style.display = 'none';
    document.getElementById('worldMapOverlay').style.display = 'none';
    
    document.getElementById('battleUI').style.display = 'block';
    document.getElementById('battleOverlay').style.display = 'block';
    
    updateBattleUI();
}
// 为区域生成怪物
function generateMonsterForZone(zone, dimension) {
            // 随机选择怪物名字
            const name = zone.monsterNames[Math.floor(Math.random() * zone.monsterNames.length)];
            
            // 随机选择词条
            const modifier = zone.modifiers[Math.floor(Math.random() * zone.modifiers.length)];
            
            // 计算基础属性
            const stage = Math.floor((zone.minLevel + zone.maxLevel) / 2);
            const healthMultiplier = Math.pow(2, stage);
            const attackMultiplier = calculateAttackMultiplier(stage);
            
            // 应用词条加成和次元难度加成
            const health = 10000 * healthMultiplier * modifier.health;
            const attack = attackMultiplier * modifier.attack * dimension.attackMultiplier;
            
            player.battle.currentMonster = {
                name: `${name}`,
                rank: modifier.name,
                health: health,
                maxHealth: health,
                attack: attack,
                resurrections: 0,
                modifier: modifier
            };
        }

// 计算攻击乘数
function calculateAttackMultiplier(stage) {
    if (stage <= 5) return Math.floor(Math.random() * 3) + 1;
    if (stage <= 25) return 100 + (stage - 4) * 10;
    if (stage <= 50) return 1000 + (stage - 24) * 100;
    if (stage <= 100) return 5000 + (stage - 49) * 500;
    if (stage <= 150) return 50000 + (stage - 99) * 1000;
    if (stage <= 200) return 10000 + (stage - 149) * 10000;
    if (stage <= 250) return 500000 + (stage - 199) * 100000;
    if (stage <= 300) return 5000000 + (stage - 249) * 1000000;
    if (stage <= 350) return 10000000 + (stage - 299) * 100000000;
    if (stage <= 400) return 100000000 + (stage - 349) * 1000000000;
    if (stage <= 450) return 1000000000 + (stage - 399) * 100000000000;
    if (stage <= 500) return 10000000000 + (stage - 349) * 100000000000000;
    if (stage <= 550) return 100000000000 + (stage - 499) * 10000000000000000;
    if (stage <= 600) return 1000000000000 + (stage - 549) * 1000000000000000000;
    if (stage <= 650) return 10000000000000 + (stage - 599) * 1000000000000000000000;
    if (stage <= 700) return 100000000000000 + (stage - 649) * 1000000000000000000000000;
    if (stage <= 750) return 1000009000000000 + (stage - 699) * 10000000000000000000000000000;
    if (stage <= 800) return 10000000000000900 + (stage - 749) * 1000000000000000000000000000000000;
    if (stage <= 850) return 100000000000000900 + (stage - 799) * 10000000000000000000000000000000000000000;
    if (stage <= 900) return 10000000000000000900 + (stage - 849) * 10000000000000000000000000000000000000000000000;
    if (stage <= 950) return 6500000000000000000900 + (stage - 899) * 1000000000000000000000000000000000000000000000000000000;    
    return 650000000000000000000000000000000900 + (stage - 949) * 100000000000000000000000000000000000000000000000000000000000000;
}

// 更新战斗界面
function updateBattleUI() {
    // 玩家属性
    document.getElementById('battlePlayerHealth').textContent = player.battle.playerHealth.toExponential(3);
    document.getElementById('battlePlayerAttack').textContent = player.battle.playerAttack.toExponential(3);
    document.getElementById('battlePlayerCritRate').textContent = (player.battle.playerCritRate * 100).toFixed(2) + '%';
    document.getElementById('battlePlayerCritDamage').textContent = (player.battle.playerCritDamage * 100).toExponential(3) + '%';
    document.getElementById('battleRebornDanCount').textContent = (player.nightClub.starCoins || 0).toFixed(1);

    
    // 怪物属性
    const monster = player.battle.currentMonster;
    document.getElementById('battleMonsterName').textContent = monster.name;
    document.getElementById('battleMonsterHealth').textContent = formatNumber(monster.health);
    document.getElementById('battleMonsterMaxHealth').textContent = formatNumber(monster.maxHealth);
    document.getElementById('battleMonsterAttack').textContent = formatNumber(monster.attack);
    document.getElementById('battleMonsterModifier').textContent = ` ${monster.rank}`;
   document.getElementById('battleMonsterResurrections').textContent = player.battle.monsterResurrections;
}

// 切换自动战斗
function toggleWorldMapAutoBattle() {
    player.worldMapBattle.autoBattle = !player.worldMapBattle.autoBattle;
    document.getElementById('worldMapAutoBattleStatus').textContent = 
        player.worldMapBattle.autoBattle ? '开启' : '关闭';
    
    if (player.worldMapBattle.autoBattle) {
        // 如果战斗界面是打开的，则启动前台计时器
        if (document.getElementById('battleUI').style.display === 'block') {
            player.worldMapBattle.autoBattleInterval = setInterval(worldMapAttackMonster, 500);
        } else {
            // 否则，启动后台战斗
            player.backgroundBattle.active = true;
            startBackgroundBattle();
        }
    } else {
        // 停止所有战斗
        stopAllWorldMapBattles();
    }
    
    logAction(`世界地图自动战斗${player.worldMapBattle.autoBattle ? '开启' : '关闭'}`, "info");
}

// 攻击怪物
function worldMapAttackMonster() {
    const playerAttack = player.battle.playerAttack;
    const monster = player.battle.currentMonster;
    
    // 计算伤害（考虑暴击）
    let isCrit = Math.random() < player.battle.playerCritRate;
    let damage = isCrit ? playerAttack * player.battle.playerCritDamage : playerAttack;
    
    // 应用伤害
    monster.health -= damage;
    
    // 记录战斗日志
    addBattleLog(`你对${monster.name}造成了${damage.toExponential(2)}点${isCrit ? '暴击 ' : ''}伤害`);
    
    // 检查怪物是否死亡
    if (monster.health <= 0) {
        handleMonsterDefeated();
    } else {
        // 怪物反击
        monsterCounterAttack();
    }
    
    updateBattleUI();
}

// 怪物反击
function monsterCounterAttack() {
    const monster = player.battle.currentMonster;
    const damage = monster.attack;
    
    // 应用伤害
    player.battle.playerHealth -= damage;
    
    // 记录战斗日志
    addBattleLog(`${monster.name}对你造成了${damage.toExponential(2)}点伤害`);
    
    // 检查玩家是否死亡
    if (player.battle.playerHealth <= 0) {
        addBattleLog('你被怪物击败了！');
        closeBattle();
     updatePlayerBattleStats();
    }
    
    updateBattleUI();
}

// 处理怪物被击败
function handleMonsterDefeated() {
            const monster = player.battle.currentMonster;
            const zone = player.battle.currentZone;
            const dimension = dimensionConfig[player.dimensionLevel];
            
            // 增加复活次数
            player.battle.monsterResurrections++;
            
            if (player.battle.monsterResurrections < 3) {
                // 怪物复活（属性增强）
                monster.health = monster.maxHealth * Math.pow(2, player.battle.monsterResurrections);
                monster.attack *= 2;
                
                addBattleLog(`${monster.name}复活了！(第${player.battle.monsterResurrections}次)`);
                monsterCounterAttack();
            } else {
                // 怪物真正死亡
                addBattleLog(`你击败了${monster.name}！`);
                
                // 计算经验奖励（应用次元难度倍数）
                const expMin = zone.expRange[0];
                const expMax = zone.expRange[1];
                const exp = Math.floor(Math.random() * (expMax - expMin + 1)) + expMin;
               const runeBonuses = calculateRuneBonuses();
               const worldExpBonus = 1 + runeBonuses.worldExp;
                const finalExp =  (exp+(1+player.mining.gems.ruby)) * (player.vip.level * 10) * dimension.expMultiplier * worldExpBonus;
                
                // 添加经验
                addPlayerExp(finalExp);
                addBattleLog(`获得${finalExp.toLocaleString()}经验！`);
               dropRuneMaterials();
               dropMount();
                dropWing();
                if (Math.random() < 0.02) { // 2%掉落率
            dropItemsByDimension();
            }
                if (player.nightClub.starCoins < dimension.cost) {
                    addBattleLog("星币不足，无法生成新怪物！");
                    closeBattle();
                    return;
                }
                
                player.nightClub.starCoins -= dimension.cost;
                addBattleLog(`消耗${dimension.cost}个星币生成新怪物`);
                updateItemDisplay();
                
                // 生成新怪物
                generateMonsterForZone(zone, dimension);
                player.battle.monsterResurrections = 0;
                updatePlayerBattleStats();
            }
            
            updateBattleUI();
            updateLevelUI();
            updateDisplay();
        }
function dropItemsByDimension() {
    const dimension = player.dimensionLevel;
    let droppedItems = [];
    
    switch(dimension) {
        case 1:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            break;
        case 2:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou1');
            break;
        case 3:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou2');
            break;
        case 4:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou2');
            if (Math.random() < 0.2) droppedItems.push('yuzhou3');
            break;
        case 5:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou2');
            if (Math.random() < 0.2) droppedItems.push('yuzhou3');
            if (Math.random() < 0.1) droppedItems.push('yuzhou4');
            break;
    }
    
    // 处理掉落物品
    if (droppedItems.length > 0) {
        let dropMessage = "怪物掉落: ";
        droppedItems.forEach(item => {
            player.items[item] = (player.items[item] || 0) + 1;
            dropMessage += `${itemEffects[item].name} `;
        });
        
        addBattleLog(dropMessage);
        logAction(dropMessage, 'success');
        updateItemDisplay();
    }
}

// 添加战斗日志
function addBattleLog(message) {
    const logContainer = document.getElementById('addbattleLog');
    const logElement = document.createElement('div');
    logElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    
    // 添加到日志容器
    logContainer.appendChild(logElement);
    
    // 限制最多10条日志
    if (logContainer.children.length > 10) {
        logContainer.removeChild(logContainer.firstChild);
    }
    
    // 滚动到底部
    logContainer.scrollTop = logContainer.scrollHeight;
}

// 关闭战斗
function closeBattle() {
    // 停止前台自动战斗（界面上的战斗）
    if (player.worldMapBattle.autoBattle) {
        clearInterval(player.worldMapBattle.autoBattleInterval);
        // 不改变autoBattle的状态，因为我们要保持自动战斗的开启状态，以便在后台继续
    }
    
    // 关闭界面
    document.getElementById('battleUI').style.display = 'none';
    document.getElementById('battleOverlay').style.display = 'none';
    
    // 如果自动战斗是开启的，则启动后台战斗
    if (player.worldMapBattle.autoBattle) {
        player.backgroundBattle.active = true;
        startBackgroundBattle();
        logAction("已切换到后台自动战斗", "info");
    }
}
function startBackgroundBattle() {
    // 清除之前的后台战斗
    if (player.backgroundBattle.interval) {
        clearInterval(player.backgroundBattle.interval);
    }
    
    // 检查是否有足够的星币
    const dimension = dimensionConfig[player.dimensionLevel];
    if (player.nightClub.starCoins < dimension.cost) {
        logAction("星币不足，无法启动后台自动战斗", "warning");
        player.backgroundBattle.active = false;
        return;
    }
    
    // 每秒钟执行一次后台战斗
    player.backgroundBattle.interval = setInterval(() => {
        if (!player.backgroundBattle.active) {
            clearInterval(player.backgroundBattle.interval);
            return;
        }
        
        if (player.nightClub.starCoins < dimension.cost) {
            stopBackgroundBattle();
            logAction("星币不足，后台自动战斗已停止", "warning");
            return;
        }
        
        // 执行一次攻击
        backgroundWorldMapAttackMonster();
    }, 500);
    
    logAction("后台自动战斗已启动", "info");
}
function backgroundWorldMapAttackMonster() {
    const playerAttack = player.battle.playerAttack;
    const monster = player.battle.currentMonster;
    
    // 计算伤害（考虑暴击）
    let isCrit = Math.random() < player.battle.playerCritRate;
    let damage = isCrit ? playerAttack * player.battle.playerCritDamage : playerAttack;
    
    // 应用伤害
    monster.health -= damage;
    
    // 检查怪物是否死亡
    if (monster.health <= 0) {
        backgroundHandleMonsterDefeated();
    } else {
        // 怪物反击
        backgroundMonsterCounterAttack();
    }
}

// 后台怪物反击
function backgroundMonsterCounterAttack() {
    const monster = player.battle.currentMonster;
    const damage = monster.attack;
    
    // 应用伤害
    player.battle.playerHealth -= damage;
    
    // 检查玩家是否死亡
    if (player.battle.playerHealth <= 0) {
        stopBackgroundBattle();
        logAction("你在后台战斗中被怪物击败！", "error");
        updatePlayerBattleStats();
    }
}

// 后台处理怪物被击败
function backgroundHandleMonsterDefeated() {
    const monster = player.battle.currentMonster;
    const zone = player.battle.currentZone;
    const dimension = dimensionConfig[player.dimensionLevel]; // 获取当前次元配置
    
    // 增加复活次数
    player.battle.monsterResurrections++;
    
    if (player.battle.monsterResurrections < 3) {
        // 怪物复活（属性增强）
        monster.health = monster.maxHealth * Math.pow(2, player.battle.monsterResurrections);
        monster.attack *= 2;
        
        
        
        backgroundMonsterCounterAttack();
    } else {
        // 怪物真正死亡
        // 计算经验奖励（应用次元难度倍数）
        const expMin = zone.expRange[0];
        const expMax = zone.expRange[1];
        const exp = Math.floor(Math.random() * (expMax - expMin + 1)) + expMin;
         const runeBonuses = calculateRuneBonuses();
        const worldExpBonus = 1 + runeBonuses.worldExp;
        const finalExp = (exp+(1+player.mining.gems.ruby)) * (player.vip.level * 10) * dimension.expMultiplier * worldExpBonus;
        
        // 添加经验
        addPlayerExp(finalExp);
        dropRuneMaterials();
        dropMount();
        dropWing();
        // 2%概率掉落物品
        if (Math.random() < 0.02) {
            dropItemsByDimension();
        }
        
        if (player.nightClub.starCoins < dimension.cost) {
            stopBackgroundBattle();
            logAction("星币不足，后台自动战斗已停止", "warning");
            return;
        }
        
         player.nightClub.starCoins -= dimension.cost;
        
        // 生成新怪物（应用次元难度）
        generateMonsterForZone(zone, dimension);
        player.battle.monsterResurrections = 0;
        updatePlayerBattleStats();
    }
}

// 停止后台战斗
function stopBackgroundBattle() {
    if (player.backgroundBattle.interval) {
        clearInterval(player.backgroundBattle.interval);
        player.backgroundBattle.interval = null;
    }
    player.backgroundBattle.active = false;
}

function openBattleUI() {
    document.getElementById('battleUI').style.display = 'block';
    document.getElementById('battleOverlay').style.display = 'block';
    
    // 如果自动战斗是开启的，则停止后台战斗，启动前台计时器
    if (player.worldMapBattle.autoBattle) {
        stopBackgroundBattle();
        player.worldMapBattle.autoBattleInterval = setInterval(worldMapAttackMonster, 500);
    }
    
    // 更新界面显示
    updateBattleUI();
    
    // 显示后台战斗日志
    player.battleLog.forEach(log => {
        const logElement = document.createElement('div');
        logElement.textContent = log;
        document.getElementById('addbattleLog').appendChild(logElement);
    });
    
    // 滚动到底部
    document.getElementById('addbattleLog').scrollTop = document.getElementById('addbattleLog').scrollHeight;
}
// 车辆品牌配置
const vehicleBrands = [
    { id: 1, name: "大众", models: ["Polo", "Golf", "Passat"], rarity: 1 },
    { id: 2, name: "丰田", models: ["卡罗拉", "凯美瑞", "RAV4"], rarity: 2 },
    { id: 3, name: "本田", models: ["思域", "雅阁", "CR-V"], rarity: 3 },
    { id: 4, name: "福特", models: ["福克斯", "蒙迪欧", "探险者"], rarity: 4 },
    { id: 5, name: "日产", models: ["轩逸", "天籁", "奇骏"], rarity: 5 },
    { id: 6, name: "现代", models: ["伊兰特", "索纳塔", "途胜"], rarity: 6 },
    { id: 7, name: "宝马", models: ["3系", "5系", "X5"], rarity: 7 },
    { id: 8, name: "奔驰", models: ["C级", "E级", "GLC"], rarity: 8 },
    { id: 9, name: "奥迪", models: ["A4", "A6", "Q5"], rarity: 9 },
    { id: 10, name: "雷克萨斯", models: ["ES", "RX", "NX"], rarity: 10 },
    { id: 11, name: "沃尔沃", models: ["S60", "S90", "XC60"], rarity: 11 },
    { id: 12, name: "凯迪拉克", models: ["CT5", "XT5", "Escalade"], rarity: 12 },
    { id: 13, name: "保时捷", models: ["911", "Cayenne", "Panamera"], rarity: 13 },
    { id: 14, name: "玛莎拉蒂", models: ["Ghibli", "Levante", "Quattroporte"], rarity: 14 },
    { id: 15, name: "法拉利", models: ["Portofino", "Roma", "SF90"], rarity: 15 },
    { id: 16, name: "兰博基尼", models: ["Huracan", "Aventador", "Urus"], rarity: 16 },
    { id: 17, name: "宾利", models: ["飞驰", "添越", "欧陆"], rarity: 17 },
    { id: 18, name: "劳斯莱斯", models: ["古斯特", "幻影", "库里南"], rarity: 18 },
    { id: 19, name: "迈凯伦", models: ["GT", "720S", "Artura"], rarity: 19 },
    { id: 20, name: "阿斯顿马丁", models: ["DB11", "Vantage", "DBS"], rarity: 20 },
    { id: 21, name: "布加迪", models: ["Chiron", "Divo", "Centodieci"], rarity: 21 },
    { id: 22, name: "柯尼塞格", models: ["Jesko", "Gemera", "Regera"], rarity: 22 },
    { id: 23, name: "帕加尼", models: ["Huayra", "Zonda", "Utopia"], rarity: 23 },
    { id: 24, name: "世爵", models: ["C8", "D12", "B6"], rarity: 24 },
    { id: 25, name: "威兹曼", models: ["GT", "Roadster", "MF5"], rarity: 25 },
    { id: 26, name: "西尔贝", models: ["Tuatara", "Aero", "Ultimate"], rarity: 26 },
    { id: 27, name: "轩尼诗", models: ["Venom F5", "Venom GT", "Exorcist"], rarity: 27 },
    { id: 28, name: "里马克", models: ["C_Two", "Concept_One", "Nevera"], rarity: 28 },
    { id: 29, name: "阿波罗", models: ["IE", "Intensa", "Project Evo"], rarity: 29 },
    { id: 30, name: "Zenvo", models: ["TSR-S", "ST1", "TS1"], rarity: 30 },
    { id: 31, name: "锐马克", models: ["Nevera", "C_Two", "Concept Two"], rarity: 31 },
    { id: 32, name: "宾尼法利纳", models: ["Battista", "PF0", "PF1"], rarity: 32 },
    { id: 33, name: "克钦格", models: ["21C", "22C", "23C"], rarity: 33 },
    { id: 34, name: "SCG", models: ["007 LMH", "008 Stradale", "009 Hypercar"], rarity: 34 },
    { id: 35, name: "唐克沃特", models: ["D8 GTO", "D8 GT", "D8 Spider"], rarity: 35 },
    { id: 36, name: "凡克", models: ["Shield", "P60", "S1"], rarity: 36 },
    { id: 37, name: "梅尔库斯", models: ["RS2000", "RS3000", "RS4000"], rarity: 37 },
    { id: 38, name: "德托马索", models: ["P72", "Valerio", "Mangusta"], rarity: 38 },
    { id: 39, name: "向量", models: ["WX-8", "WX-12", "V12 Supercharged"], rarity: 39 },
    { id: 40, name: "帕诺兹", models: ["Evviva", "Abruzzi", "Roadster"], rarity: 40 },
    { id: 41, name: "阿尔派", models: ["A110 Stradale", "A110 GT", "A110 S"], rarity: 41 },
    { id: 42, name: "路特斯", models: ["Evija", "Emira", "Elise"], rarity: 42 },
    { id: 43, name: "赫尔姆", models: ["Fury", "GT", "Spider"], rarity: 43 },
    { id: 44, name: "泰格鲁斯·腾风", models: ["GT96 T Revival", "AT96 T", "GT96 T Electric"], rarity: 44 },
    { id: 45, name: "Vencer", models: ["Shield", "P60", "S1"], rarity: 45 },
    { id: 46, name: "比扎里尼", models: ["5000 GT", "Strada", "P538"], rarity: 46 },
    { id: 47, name: "BAC Mono", models: ["Mono", "Mono R", "Mono X"], rarity: 47 },
    { id: 48, name: "Panoz", models: ["Evviva", "Abruzzi", "Roadster"], rarity: 48 },
    { id: 49, name: "Fisker", models: ["Pearl", "Ronin", "Force E"], rarity: 49 },
    { id: 50, name: "Koenigsegg", models: ["Jesko Absolut", "Gemera", "Regera"], rarity: 50 }
];

// 初始化玩家停车位数据
function initParkingData() {
    if (!player.parking) {
        player.parking = {
            level: 1,
            exp: 0,
            maxSpots: 1,
            vehicles: [],
            parkedVehicles: [],
            lastUpdate: Date.now(),
            totalIncome: 0
        };
    }
}

// 切换停车位系统界面
function toggleParkingSystem() {
   if (player.reincarnationCount < 200) {
        alert("需要达到200转才能开启停车场系统！");
        return;
    }
    const ui = document.getElementById('parkingSystemUI');
    const overlay = document.getElementById('parkingSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initParkingData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateParkingUI();
    }
}

function closeParkingSystem() {
    document.getElementById('parkingSystemUI').style.display = 'none';
    document.getElementById('parkingSystemOverlay').style.display = 'none';
}

// 更新停车位界面
function updateParkingUI() {
    // 更新基本信息
    document.getElementById('parkingLevel').textContent = player.parking.level;
    document.getElementById('parkingSpotCount').textContent = player.parking.parkedVehicles.length;
    document.getElementById('maxParkingSpots').textContent = player.parking.maxSpots;
    document.getElementById('parkingExp').textContent = player.parking.exp.toFixed(1);
    document.getElementById('nextLevelExp').textContent = getNextLevelExpq();
    document.getElementById('totalParkingIncome').textContent = player.parking.totalIncome.toExponential(1);
    
    // 更新车辆列表
    updateVehicleList();
    
    // 更新停车位显示
    updateParkingSpots();
    
    // 更新分解界面
    updateDecomposeUI();
}

// 获取下一级所需经验
function getNextLevelExpq() {
    const expRequirements = [100, 200, 300, 400, 600, 800, 1000, 1300, 1700, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 15000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000, 125000, 150000, 200000, 400000, 600000, 800000, 1000000, 2500000, 5000000, 10000000, 100000000];
    const currentLevel = Math.min(player.parking.level, expRequirements.length);
    return expRequirements[currentLevel - 1];
}

// 更新车辆列表
function updateVehicleList() {
    const container = document.getElementById('vehicleList');
    container.innerHTML = '';
    
    player.parking.vehicles.forEach((vehicle, index) => {
        const vehicleCard = document.createElement('div');
        vehicleCard.className = 'vehicle-card';
        vehicleCard.style.background = '#444';
        vehicleCard.style.padding = '10px';
        vehicleCard.style.borderRadius = '5px';
        vehicleCard.style.textAlign = 'center';
        vehicleCard.style.cursor = 'pointer';
        vehicleCard.dataset.index = index;
        
        // 根据稀有度设置边框颜色
        const rarityColor = getRarityColor(vehicle.rarity);
        vehicleCard.style.border = `2px solid ${rarityColor}`;
        
        vehicleCard.innerHTML = `
            <div style="font-weight: bold; color: ${rarityColor}">${vehicle.brand}</div>
            <div>${vehicle.model}</div>
            <div style="font-size: 0.8em; margin-top: 5px;">稀有度: ${vehicle.rarity}</div>
        `;
        
        // 点击车辆进行停车操作
        vehicleCard.onclick = function() {
            parkVehicle(index);
        };
        
        container.appendChild(vehicleCard);
    });
}

// 根据稀有度获取颜色
function getRarityColor(rarity) {
    if (rarity <= 5) return '#1E90FF'; // 普通 - 蓝色
    if (rarity <= 10) return '#32CD32'; // 稀有 - 绿色
    if (rarity <= 15) return '#FFD700'; // 史诗 - 金色
    if (rarity <= 20) return '#9370DB'; // 传说 - 紫色
    if (rarity <= 25) return '#013220'; // 传说 - 紫色
    if (rarity <= 30) return '#C0C0C0'; // 传说 - 紫色
    if (rarity <= 35) return '#FF1493'; // 传说 - 紫色
    if (rarity <= 45) return '#FF4500'; // 神话 - 橙色
    return '#FF0000'; // 至尊 - 粉色
}

// 更新停车位显示
function updateParkingSpots() {
    const container = document.getElementById('parkingSpotsContainer');
    container.innerHTML = '';
    
    // 创建停车位卡片
    for (let i = 0; i < player.parking.maxSpots; i++) {
        const spotCard = document.createElement('div');
        spotCard.className = 'parking-spot';
        spotCard.style.border = '1px solid #ddd';
        spotCard.style.padding = '10px';
        spotCard.style.borderRadius = '5px';
        spotCard.style.textAlign = 'center';
        
        if (i < player.parking.parkedVehicles.length) {
            const vehicle = player.parking.parkedVehicles[i];
         const rarityColor = getRarityColor(vehicle.rarity);
            spotCard.innerHTML = `
               <div style="font-weight: bold; color: ${rarityColor}">${vehicle.brand}</div>
                <div>${vehicle.model}</div>
                <div>收益: ${calculateParkingIncome(vehicle)} 转生币</div>
                <div>经验: ${calculateParkingIncome(vehicle) / 10000} 经验值</div>
                <button onclick="unparkVehicle(${i})" style="margin-top: 10px; background: #ff9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">卸下</button>
            `;
        } else {
            spotCard.innerHTML = '<div>空闲车位</div>';
        }
        
        container.appendChild(spotCard);
    }
}
function unparkVehicle(spotIndex) {
    if (spotIndex >= player.parking.parkedVehicles.length) return;
    
    // 获取车辆信息
    const vehicle = player.parking.parkedVehicles[spotIndex];
    
    // 将车辆移回车辆列表
    player.parking.vehicles.push(vehicle);
    
    // 从停车位移除
    player.parking.parkedVehicles.splice(spotIndex, 1);
    
    // 计算并收取收益
    const income = calculateParkingIncome(vehicle);
    player.reincarnationCoin += income;
    player.parking.totalIncome += income;
    player.parking.exp += income / 10000;
    logAction(`卸下车辆: ${vehicle.brand} ${vehicle.model}, 获得收益 ${income} 转生币`, 'success');
    updateParkingUI();
    
    // 更新显示
    updateParkingDisplay();
    updateDisplay();
    checkTitleUnlocks();
    saveGame();
}

// 计算停车收益
function calculateParkingIncome(vehicle) {
    // 收益 = 车辆稀有度 * 停车时间(小时)
    const hoursParked = (Date.now() - vehicle.parkTime) / (100 * 60 * 60);
    return Math.floor(vehicle.rarity * hoursParked) * 1000;
}

// 停车操作
function parkVehicle(vehicleIndex) {
    // 检查是否有空闲车位
    if (player.parking.parkedVehicles.length >= player.parking.maxSpots) {
        logAction("没有空闲车位了！", "error");
        return;
    }
    
    const vehicle = player.parking.vehicles[vehicleIndex];
    
    // 将车辆移动到停车位
    player.parking.parkedVehicles.push({
        ...vehicle,
        parkTime: Date.now()
    });
    
    // 从车辆列表中移除
    player.parking.vehicles.splice(vehicleIndex, 1);
    
    logAction(`已将 ${vehicle.brand} ${vehicle.model} 停入车位`, "success");
    updateParkingUI();
    saveGame();
}

// 一键停车
function parkAllVehicles() {
    // 计算可停车数量
    const availableSpots = player.parking.maxSpots - player.parking.parkedVehicles.length;
    const vehiclesToPark = Math.min(availableSpots, player.parking.vehicles.length);
    
    if (vehiclesToPark === 0) {
        logAction("没有可停车的车辆或没有空闲车位", "info");
        return;
    }
    
    // 停车操作
    for (let i = 0; i < vehiclesToPark; i++) {
        const vehicle = player.parking.vehicles[0];
        player.parking.parkedVehicles.push({
            ...vehicle,
            parkTime: Date.now()
        });
        player.parking.vehicles.shift();
    }
    
    logAction(`已自动停放 ${vehiclesToPark} 辆车辆`, "success");
    updateParkingUI();
    saveGame();
}

// 收取单个车位收益
function collectParkingIncome(spotIndex) {
    const vehicle = player.parking.parkedVehicles[spotIndex];
    const income = calculateParkingIncome(vehicle);
    
    // 添加收益
    player.reincarnationCoin += income;
    player.parking.totalIncome += income;
    
    // 添加停车经验
    player.parking.exp += income / 10000;
    
    // 重置停车时间
    vehicle.parkTime = Date.now();
    
    logAction(`收取了 ${vehicle.brand} ${vehicle.model} 的停车收益: ${income} 转生币`, "success");
    updateParkingUI();
    updateDisplay();
    saveGame();
}

// 收取所有收益
function collectAllParkingIncome() {
    let totalIncome = 0;
    
    player.parking.parkedVehicles.forEach(vehicle => {
        const income = calculateParkingIncome(vehicle);
        totalIncome += income;
        
        // 添加停车经验
        player.parking.exp += income / 10000;
        
        // 重置停车时间
        vehicle.parkTime = Date.now();
    });
    
    // 添加收益
    player.reincarnationCoin += totalIncome;
    player.parking.totalIncome += totalIncome;
    
    logAction(`收取了所有停车收益: ${totalIncome} 转生币`, "success");
    updateParkingUI();
    updateDisplay();
   checkTitleUnlocks();
    saveGame();
}

// 按稀有度批量选择车辆
function selectByRarity(maxRarity) {
    player.parking.vehicles.forEach((vehicle, index) => {
        const checkbox = document.getElementById(`vehicleCheckbox${index}`);
        if (checkbox) {
            checkbox.checked = vehicle.rarity <= maxRarity;
        }
    });
    logAction(`已选择稀有度${maxRarity}及以下的车辆`, "info");
}

// 全选车辆
function selectAllVehicles() {
    player.parking.vehicles.forEach((vehicle, index) => {
        const checkbox = document.getElementById(`vehicleCheckbox${index}`);
        if (checkbox) {
            checkbox.checked = true;
        }
    });
    logAction("已选择所有车辆", "info");
}

// 取消全选
function deselectAllVehicles() {
    player.parking.vehicles.forEach((vehicle, index) => {
        const checkbox = document.getElementById(`vehicleCheckbox${index}`);
        if (checkbox) {
            checkbox.checked = false;
        }
    });
    logAction("已取消选择所有车辆", "info");
}

// 修改更新分解界面的函数，确保每个车辆都有唯一的checkbox ID
function updateDecomposeUI() {
    const container = document.getElementById('decomposeVehicleContainer');
    container.innerHTML = '';
    
    if (player.parking.vehicles.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">车库中没有可分解的车辆</div>';
        return;
    }
    
    // 添加车库中的车辆
    player.parking.vehicles.forEach((vehicle, index) => {
        const vehicleDiv = document.createElement('div');
        vehicleDiv.className = 'decompose-vehicle-item';
        vehicleDiv.style.display = 'flex';
        vehicleDiv.style.alignItems = 'center';
        vehicleDiv.style.justifyContent = 'space-between';
        vehicleDiv.style.marginBottom = '10px';
        vehicleDiv.style.padding = '10px';
        vehicleDiv.style.background = '#444';
        vehicleDiv.style.borderRadius = '5px';
        vehicleDiv.style.border = `2px solid ${getRarityColor(vehicle.rarity)}`;
        
        const rarityColor = getRarityColor(vehicle.rarity);
        const decomposeValue = vehicle.rarity * 10000;
        
        vehicleDiv.innerHTML = `
            <div style="display: flex; align-items: center; flex: 1;">
                <input type="checkbox" id="vehicleCheckbox${index}" 
                       style="margin-right: 10px; width: 16px; height: 16px;">
                <div style="flex: 1;">
                    <div style="font-weight: bold; color: ${rarityColor}; font-size: 14px;">
                        ${vehicle.brand} ${vehicle.model}
                    </div>
                    <div style="font-size: 12px; color: #ccc;">
                        稀有度: <span style="color: ${rarityColor};">${vehicle.rarity}</span>
                    </div>
                </div>
            </div>
            <div style="text-align: right;">
                <div style="font-size: 12px; color: #FFD700;">
                    价值: ${decomposeValue.toLocaleString()}
                </div>
                <div style="font-size: 10px; color: #888;">
                    转生币
                </div>
            </div>
        `;
        
        container.appendChild(vehicleDiv);
    });
}

// 修改分解选中车辆函数，增加确认对话框
function decomposeSelectedVehicle() {
    const vehiclesToDecompose = [];
    
    // 收集选中的车辆
    player.parking.vehicles.forEach((vehicle, index) => {
        const checkbox = document.getElementById(`vehicleCheckbox${index}`);
        if (checkbox && checkbox.checked) {
            vehiclesToDecompose.push({
                index,
                vehicle
            });
        }
    });
    
    if (vehiclesToDecompose.length === 0) {
        logAction("请选择要分解的车辆", "error");
        return;
    }
    
    // 计算总收益和显示信息
    let totalValue = 0;
    let vehicleList = "";
    
    vehiclesToDecompose.forEach(item => {
        totalValue += item.vehicle.rarity * 10000;
        vehicleList += `\n${item.vehicle.brand} ${item.vehicle.model} (稀有度${item.vehicle.rarity})`;
    });
    
    // 显示确认对话框
    showCustomConfirm(
        `确定要分解以下 ${vehiclesToDecompose.length} 辆车辆吗？${vehicleList}\n\n总计可获得: ${totalValue.toLocaleString()} 转生币`,
        (confirmed) => {
            if (confirmed) {
                // 从高索引到低索引删除，避免索引变化问题
                vehiclesToDecompose.sort((a, b) => b.index - a.index);
                vehiclesToDecompose.forEach(item => {
                    player.parking.vehicles.splice(item.index, 1);
                });
                
                // 添加收益
                player.reincarnationCoin += totalValue;
                
                logAction(`分解了 ${vehiclesToDecompose.length} 辆车辆，获得 ${totalValue.toLocaleString()} 转生币`, "success");
                updateParkingUI();
                updateDisplay();
                saveGame();
            }
        }
    );
}

// 升级停车位
function upgradeParking() {
    const requiredExp = getNextLevelExpq();
    
    if (player.parking.exp < requiredExp) {
        logAction(`经验不足！需要 ${requiredExp} 经验`, "error");
        return;
    }
    
    // 扣除经验
    player.parking.exp -= requiredExp;
    
    // 升级
    player.parking.level++;
    player.parking.maxSpots++;
    
    logAction(`停车位升级到 ${player.parking.level} 级！最大车位增加到 ${player.parking.maxSpots}`, "success");
    updateParkingUI();
    saveGame();
}
// 在农场收获时获得车辆
function onFarmHarvest() {
 if (Math.random() < 0.2) {
        // 根据品阶设置掉落概率
        const rand = Math.random();
        let rarityRange;
        
        if (rand < 0.70) {
            rarityRange = [1, 7];
        } else if (rand < 0.88) {
            rarityRange = [8, 14];
        } else if (rand < 0.96) {
           rarityRange = [15, 22];
            } else if (rand < 0.99) {
           rarityRange = [23, 30];
        } else if (rand < 0.998) {
            rarityRange = [31, 38];
        } else if (rand < 0.9999) {
            rarityRange = [39, 44];
        } else {
            rarityRange = [45, 50];
        }
        
        // 在指定品阶范围内筛选符合条件的车辆
        const eligibleBrands = vehicleBrands.filter(brand => 
            brand.rarity >= rarityRange[0] && brand.rarity <= rarityRange[1]
        );
        
        if (eligibleBrands.length > 0) {
            // 随机选择一个品牌
            const brand = eligibleBrands[Math.floor(Math.random() * eligibleBrands.length)];
            
            // 随机选择型号
            const model = brand.models[Math.floor(Math.random() * brand.models.length)];
            
            // 创建车辆对象
            const newVehicle = {
                id: 'vehicle_' + Date.now(),
                brand: brand.name,
                model: model,
                rarity: brand.rarity,
                parkTime: 0,
                income: 0
            };
            
            // 添加到车辆列表
            player.parking.vehicles.push(newVehicle);
            
            // 记录日志
            logAction(`收获时获得了一辆${brand.name} ${model}（品阶${brand.rarity}）！`, "success");
        }
    }
}
function calculateOfflineParkingIncome() {
    const now = Date.now();
    const elapsed = now - player.parking.lastUpdate;
    
    player.parking.parkedVehicles.forEach(vehicle => {
        const income = vehicle.rarity * (elapsed / (100 * 60 * 60)); // 每小时收益
        player.parking.totalIncome += income;
        player.parking.exp += income / 10000;
    });
    
    player.parking.lastUpdate = now;
}
// 星域探索系统数据
const explorationData = {
    speed: { level: 1, cost: 100 },
    capacity: { level: 1, cost: 100 },
    durability: { level: 1, cost: 100 },
    resources: {
        stardust: 0,
        darkMatter: 0,
        cosmicCrystal: 0,
        artifactFragment: 0
    },
    activeMission: null,
    missionEndTime: 0,
    logs: []
};

// 任务配置
const missions = {
    easy: {
        name: "近地星域",
        time: 120, // 分钟
        rewards: {
            stardust: { min: 1, max: 15 },
            darkMatter: { min: 1, max: 15 }
        },
        damageRisk: 50
    },
    medium: {
        name: "深空星域",
        time: 180,
        rewards: { 
            stardust: { min: 1, max: 25 },
            darkMatter: { min: 1, max: 30 },
             cosmicCrystal: { min: 1, max: 20 }
        },
        damageRisk: 60
    },
    hard: {
        name: "黑洞边缘",
        time: 240,
        rewards: {
            stardust: { min: 1, max: 50 },
            darkMatter: { min: 1, max: 50 },
            cosmicCrystal: { min: 1, max: 50 }
        },
        damageRisk: 70
    },
    extreme: {
        name: "宇宙边缘",
        time: 360,
        rewards: {
            cosmicCrystal: { min: 1, max: 50 },
            artifactFragment: { min: 1, max: 50 }
        },
        damageRisk: 80
    }
};

// 切换探索系统界面
function toggleExplorationSystem() {
    if (player.reincarnationCount < 300) {
        alert("需要达到300转才能开启星域探索！");
        return;
    }
    const ui = document.getElementById('explorationSystemUI');
    const overlay = document.getElementById('explorationSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateExplorationUI();
    }
}

// 更新探索系统界面
function updateExplorationUI() {
    // 更新资源仓库显示
    document.getElementById('speedLevel').textContent = explorationData.speed.level;
    document.getElementById('capacityLevel').textContent = explorationData.capacity.level;
    document.getElementById('durabilityLevel').textContent = explorationData.durability.level;
    
    // 计算属性效果
    const speedEffect = 60 - (explorationData.speed.level - 1) * 5;
    const capacityEffect = 100 + (explorationData.capacity.level - 1) * 20;
    const durabilityEffect = 5 + (explorationData.durability.level - 1) * 2;
    const damageReduction = 10 - (explorationData.durability.level - 1) * 1;
    
    document.getElementById('explorationTime').textContent = Math.max(10, speedEffect);
    document.getElementById('resourceGain').textContent = capacityEffect + '%';
    document.getElementById('rareRate').textContent = durabilityEffect + '%';
    document.getElementById('damageRate').textContent = Math.max(1, damageReduction) + '%';
    
    // 更新资源显示
    document.getElementById('stardustCount').textContent = explorationData.resources.stardust || 0;
    document.getElementById('darkMatterCount').textContent = explorationData.resources.darkMatter || 0;
    document.getElementById('cosmicCrystalCount').textContent = explorationData.resources.cosmicCrystal || 0;
    document.getElementById('artifactFragmentCount').textContent = explorationData.resources.artifactFragment || 0;
    
    // 更新任务按钮状态
    const missionButtons = document.querySelectorAll('.start-mission-btn');
    missionButtons.forEach(button => {
        if (explorationData.activeMission) {
            button.disabled = true;
            button.textContent = "任务进行中";
        } else {
            button.disabled = false;
            button.textContent = "开始探索";
        }
    });
    
    // 更新任务时间显示（应用速度加成）- 修复部分
    const missionCards = document.querySelectorAll('.mission-card');
    missionCards.forEach(card => {
        const difficulty = card.getAttribute('data-difficulty');
         // 添加安全检查
        if (!missions[difficulty]) {
            console.error("未找到任务配置:", difficulty);
            return; // 跳过这个卡片
        }
   
        
        const mission = missions[difficulty];
        const baseTime = mission.time;
        const actualTime = Math.max(10, baseTime - (explorationData.speed.level - 1) * 5);
        card.querySelector('.mission-time').textContent = actualTime + "分钟";
        
        // 应用耐久加成后的损坏率
        const baseRisk = mission.damageRisk;
        const actualRisk = Math.max(1, baseRisk - (explorationData.durability.level - 1));
        card.querySelector('.damage-risk').textContent = actualRisk + "%";
    });
    
    // 更新属性升级按钮的显示
    const attributes = ['speed', 'capacity', 'durability'];
    attributes.forEach(attr => {
        const btn = document.querySelector(`.upgrade-btn[data-attr="${attr}"]`);
        if (btn) {
            const cost = explorationData[attr].cost;
            btn.textContent = `升级 (${formatNumber(cost)}转生币)`;
            btn.disabled = player.reincarnationCoin < cost;
        }
    });

    // 更新日志
    updateExplorationLog();
    
    // 如果有进行中的任务，显示倒计时
    if (explorationData.activeMission) {
        const remaining = Math.max(0, explorationData.missionEndTime - Date.now());
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        
        addLog(`任务进行中: ${missions[explorationData.activeMission]?.name || '未知任务'} - 剩余: ${minutes}分${seconds}秒`);
        
        if (remaining <= 0) {
            completeMission();
        }
    }
}

// 升级属性
function upgradeAttribute(attribute) {
    const cost = explorationData[attribute].cost;
    
    if (player.reincarnationCoin >= cost) {
        player.reincarnationCoin -= cost;
        explorationData[attribute].level++;
        explorationData[attribute].cost = Math.floor(cost * 10);
        
        addLog(`${attribute === 'speed' ? '速度' : attribute === 'capacity' ? '容量' : '耐久'}升级到 ${explorationData[attribute].level}级`);
        updateExplorationUI();
        logAction(`星域探索: ${attribute}升级成功`, 'success');
    } else {
        logAction(`转生币不足！需要${formatNumber(cost)}转生币`, "error");
    }
}

// 一键升级全部属性
function upgradeAllAttributes() {
    const attributes = ['speed', 'capacity', 'durability'];
    let upgraded = false;
    
    attributes.forEach(attr => {
        while (player.reincarnationCoin >= explorationData[attr].cost) {
            const cost = explorationData[attr].cost;
            player.reincarnationCoin -= cost;
            explorationData[attr].level++;
            explorationData[attr].cost = Math.floor(cost * 10);
            upgraded = true;
        }
    });
    
    if (upgraded) {
        addLog("一键升级全部属性成功");
        updateExplorationUI();
        logAction("星域探索: 一键升级成功", 'success');
    } else {
        // 显示具体缺少的转生币数量
        const costs = attributes.map(attr => explorationData[attr].cost);
        const minCost = Math.min(...costs);
        logAction(`转生币不足，至少需要${formatNumber(minCost)}转生币才能升级任一属性`, "error");
    }
}

// 开始任务
function startMission(difficulty) {
    if (explorationData.activeMission) {
        logAction("已有任务进行中", "error");
        return;
    }
    
    // 计算实际任务时间（应用速度加成）
    const baseTime = missions[difficulty].time;
    const actualTime = Math.max(10, baseTime - (explorationData.speed.level - 1) * 5) * 60000;
    
    explorationData.activeMission = difficulty;
    explorationData.missionEndTime = Date.now() + actualTime;
    
    addLog(`开始探索: ${missions[difficulty].name} - 预计完成时间: ${new Date(explorationData.missionEndTime).toLocaleTimeString()}`);
    updateExplorationUI();
    
    // 设置任务完成检查
    setTimeout(completeMission, actualTime);
    
    // 立即保存游戏
    saveGame();
}

// 完成任务
function completeMission() {
    if (!explorationData.activeMission) return;
    
    const mission = missions[explorationData.activeMission];
    const difficulty = explorationData.activeMission;
    
    // 计算实际损坏率（应用耐久加成）
    const baseRisk = mission.damageRisk;
    const actualRisk = Math.max(1, baseRisk - (explorationData.durability.level - 1));
    
    // 检查是否发生损坏
    let damaged = false;
    if (Math.random() * 100 < actualRisk) {
        damaged = true;
        addLog(`任务完成，但舰队受到损坏！`);
    } else {
        addLog(`任务成功完成: ${mission.name}`);
    }
    
    // 计算资源获取（应用容量加成）
    const capacityMultiplier = 1 + (explorationData.capacity.level - 1) * 0.2;
    
    // 发放发票奖励（不再是直接发放资源）
    let rewards = "";
    for (const resource in mission.rewards) {
        const min = mission.rewards[resource].min;
        const max = mission.rewards[resource].max;
        let amount = Math.floor((Math.random() * (max - min + 1) + min) * capacityMultiplier);
    
        if (damaged) {
            amount = Math.floor(amount * 0.2); // 损坏时奖励减半
        }
        
        // 根据资源类型确定对应的发票类型
        let ticketType;
        switch(resource) {
            case 'stardust':
                ticketType = 'yuzhou1';
                break;
            case 'darkMatter':
                ticketType = 'yuzhou2';
                break;
            case 'cosmicCrystal':
                ticketType = 'yuzhou3';
                break;
            case 'artifactFragment':
                ticketType = 'yuzhou4';
                break;
            default:
                ticketType = null;
        }
        
        if (ticketType) {
            // 将发票数量加到player.items中
            player.items[ticketType] = (player.items[ticketType] || 0) + amount;
            rewards += `${getTicketName(ticketType)}: ${amount} `;
        }
    }
    
    addLog(`获得奖励: ${rewards}`);
    
    // 重置任务状态
    explorationData.activeMission = null;
    explorationData.missionEndTime = 0;
    
    updateExplorationUI();
    saveGame();
}

// 获取发票名称
function getTicketName(ticketType) {
    const names = {
        'yuzhou1': '星尘发票',
        'yuzhou2': '暗物质发票',
        'yuzhou3': '宇宙晶体发票',
        'yuzhou4': '神器碎片发票'
    };
    return names[ticketType] || ticketType;
}

// 添加日志
function addLog(message) {
    const timestamp = new Date().toLocaleTimeString();
    explorationData.logs.unshift(`[${timestamp}] ${message}`);
    
    if (explorationData.logs.length > 20) {
        explorationData.logs.pop();
    }
    
    updateExplorationLog();
}

// 更新日志显示
function updateExplorationLog() {
    const logContainer = document.getElementById('explorationLog');
    logContainer.innerHTML = explorationData.logs.map(log => 
        `<div class="log-entry">${log}</div>`
    ).join('');
}

function initExplorationSystem() {
    // 确保所有属性都有默认值
    explorationData.speed = explorationData.speed || { level: 1, cost: 100 };
    explorationData.capacity = explorationData.capacity || { level: 1, cost: 100 };
    explorationData.durability = explorationData.durability || { level: 1, cost: 100 };
    explorationData.resources = explorationData.resources || {
        stardust: 0,
        darkMatter: 0,
        cosmicCrystal: 0,
        artifactFragment: 0
    };
    explorationData.activeMission = explorationData.activeMission || null;
    explorationData.missionEndTime = explorationData.missionEndTime || 0;
    explorationData.logs = explorationData.logs || [];
    
    // 检查是否有进行中的任务
    if (explorationData.activeMission && explorationData.missionEndTime > Date.now()) {
        const remaining = explorationData.missionEndTime - Date.now();
        setTimeout(completeMission, remaining);
        addLog(`恢复进行中的探索任务: ${missions[explorationData.activeMission].name} - 剩余时间: ${Math.floor(remaining/60000)}分钟`);
    } else if (explorationData.activeMission && explorationData.missionEndTime <= Date.now()) {
        // 任务已经结束但未完成
        completeMission();
    }
}
// 切换兑换商店显示
function toggleExchangeShop() {
    const overlay = document.getElementById('exchangeShopOverlay');
    const ui = document.getElementById('exchangeShopUI');
    
    if (ui.style.display === 'none') {
        // 打开商店时更新显示
        updateExchangeDisplay();
        overlay.style.display = 'block';
        ui.style.display = 'block';
    } else {
        overlay.style.display = 'none';
        ui.style.display = 'none';
    }
}

// 更新兑换商店显示
function updateExchangeDisplay() {
    // 更新资源数量
    document.getElementById('currentStardustExchange').textContent = player.exploration.resources.stardust;
    document.getElementById('currentDarkMatterExchange').textContent = player.exploration.resources.darkMatter;
    document.getElementById('currentCosmicCrystalExchange').textContent = player.exploration.resources.cosmicCrystal;
    document.getElementById('currentArtifactFragmentExchange').textContent = player.exploration.resources.artifactFragment;
    
    // 更新发票数量
    document.getElementById('currentStardustTicket').textContent = player.items.yuzhou1 || 0;
    document.getElementById('currentDarkMatterTicket').textContent = player.items.yuzhou2 || 0;
    document.getElementById('currentCosmicCrystalTicket').textContent = player.items.yuzhou3 || 0;
    document.getElementById('currentArtifactFragmentTicket').textContent = player.items.yuzhou4 || 0;
}

// 资源兑换函数
function exchangeResource(resourceType, direction) {
    // 确定兑换数量和输入框
    let amountInput, amount;
    let ticketType;
    
    switch(resourceType) {
        case 'stardust':
            amountInput = document.getElementById('stardustAmount');
            ticketType = 'yuzhou1';
            break;
        case 'darkMatter':
            amountInput = document.getElementById('darkMatterAmount');
            ticketType = 'yuzhou2';
            break;
        case 'cosmicCrystal':
            amountInput = document.getElementById('cosmicCrystalAmount');
            ticketType = 'yuzhou3';
            break;
        case 'artifactFragment':
            amountInput = document.getElementById('artifactFragmentAmount');
            ticketType = 'yuzhou4';
            break;
    }
    
    amount = parseInt(amountInput.value);
    if (isNaN(amount) || amount < 1) {
        logAction("请输入有效的兑换数量", "error");
        return;
    }
    
    if (direction === 'toTicket') {
        // 资源兑换发票
        if (player.exploration.resources[resourceType] < amount) {
            logAction(`${getResourceName(resourceType)}不足`, "error");
            return;
        }
        
        player.exploration.resources[resourceType] -= amount;
        player.items[ticketType] = (player.items[ticketType] || 0) + amount;
        
        logAction(`成功将${amount}个${getResourceName(resourceType)}兑换为${amount}张${getTicketName(ticketType)}`, "success");
    } else {
        // 发票兑换资源
        if ((player.items[ticketType] || 0) < amount) {
            logAction(`${getTicketName(ticketType)}不足`, "error");
            return;
        }
        
        player.items[ticketType] -= amount;
        player.exploration.resources[resourceType] += amount;
        
        logAction(`成功将${amount}张${getTicketName(ticketType)}兑换为${amount}个${getResourceName(resourceType)}`, "success");
    }
    
    // 更新显示
    updateExchangeDisplay();
    saveGame();
}

// 获取资源名称
function getResourceName(type) {
    const names = {
        'stardust': '星尘',
        'darkMatter': '暗物质',
        'cosmicCrystal': '宇宙晶体',
        'artifactFragment': '神器碎片'
    };
    return names[type] || type;
}

// 获取发票名称
function getTicketName(type) {
    const names = {
        'yuzhou1': '星尘发票',
        'yuzhou2': '暗物质发票',
        'yuzhou3': '宇宙晶体发票',
        'yuzhou4': '神器碎片发票'
    };
    return names[type] || type;
}
// 神器部位配置
const artifactParts = [
    { id: "helmet", name: "头盔" },
    { id: "clothes", name: "衣服" },
    { id: "pants", name: "裤子" },
    { id: "shoes", name: "鞋子" },
    { id: "necklace", name: "项链" },
    { id: "weapon", name: "武器" }
];

// 神器品质配置
const artifactQualities = [
    { id: "common", name: "普通", color: "#FFFFFF", minBonus: 0.1, maxBonus: 1 },
    { id: "uncommon", name: "精良", color: "#1E90FF", minBonus: 0.5, maxBonus: 5 },
    { id: "rare", name: "稀有", color: "#9B30FF", minBonus: 1, maxBonus: 10 },
    { id: "epic", name: "史诗", color: "#FF4500", minBonus: 2, maxBonus: 20 },
    { id: "legendary", name: "传说", color: "#FFD700", minBonus: 5, maxBonus: 50 },
    { id: "mythic", name: "神话", color: "#FF1493", minBonus: 10, maxBonus: 100 }
];

// 神器套装配置
const artifactSets = [
    {
        name: "青龙套装",
        bonuses: {
            2: { health: 30, description: "生命加成+3000%" },
            4: { attack: 200, description: "攻击加成+20000%" },
            6: { critDamage: 1500, description: "爆伤加成+150000%" }
        }
    },
 {
        name: "新手套装",
        bonuses: {
            2: { health: 2, description: "生命加成+200%" },
            4: { attack: 20, description: "攻击加成+2000%" },
            6: { critDamage: 150, description: "爆伤加成+15000%" }
        }
    },
 {
        name: "废品套装",
        bonuses: {
            2: { health: 1, description: "生命加成+100%" },
            4: { attack: 1, description: "攻击加成+100%" },
            6: { critDamage: 1, description: "爆伤加成+100%" }
        }
},
 {
        name: "闫闫套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { health: 10, description: "生命加成+1000%" },
            6: { health: 10, description: "生命加成+1000%" }
        }
},
 {
        name: "茶茶套装",
        bonuses: {
            2: { attack: 20, description: "攻击加成+2000%" },
            4: { attack: 20, description: "攻击加成+2000%" },
            6: { attack: 20, description: "攻击加成+2000%" }
        }
    },
 {
        name: "幼儿园套装",
        bonuses: {
            2: { health: 2, description: "生命加成+200%" },
            4: { attack: 2, description: "攻击加成+200%" },
            6: { critDamage: 2, description: "爆伤加成+200%" }
        }
    },
 {
        name: "梦想套装",
        bonuses: {
            2: { health: 1, description: "生命加成+100%" },
            4: { attack: 10, description: "攻击加成+1000%" },
            6: { critDamage: 100, description: "爆伤加成+10000%" }
        }
    },
 {
        name: "堕入套装",
        bonuses: {
            2: { attack: 3, description: "攻击加成+300%" },
            4: { attack: 5, description: "攻击加成+500%" },
            6: { critDamage: 80, description: "爆伤加成+8000%" }
        }
    },
 {
        name: "邪恶套装",
        bonuses: {
            2: { critDamage: 2, description: "爆伤加成+200%" },
            4: { critDamage: 10, description: "爆伤加成+1000%" },
            6: { critDamage: 170, description: "爆伤加成+17000%" }
        }
    },
 {
        name: "猎人套装",
        bonuses: {
            2: { health: 2, description: "生命加成+200%" },
            4: { attack: 30, description: "攻击加成+3000%" },
            6: { critDamage: 150, description: "爆伤加成+15000%" }
        }
    },
 {
        name: "死神套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { attack: 500, description: "攻击加成+50000%" },
            6: { attack: 4000, description: "攻击加成+400000%" }
        }
    },
 {
        name: "冥王套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { attack: 300, description: "攻击加成+30000%" },
            6: { critDamage: 3000, description: "爆伤加成+300000%" }
        }
    },
 {
        name: "至尊套装",
        bonuses: {
            2: { attack: 30, description: "攻击加成+3000%" },
            4: { health: 500, description: "生命加成+50000%" },
            6: { critDamage: 1700, description: "爆伤加成+170000%" }
        }
    },
 {
        name: "雷霆套装",
        bonuses: {
            2: { attack: 100, description: "攻击加成+10000%" },
            4: { attack: 550, description: "攻击加成+55000%" },
            6: { critDamage: 1300, description: "爆伤加成+130000%" }
        }
    },
 {
        name: "堕落套装",
        bonuses: {
            2: { health: 5, description: "生命加成+500%" },
            4: { attack: 10, description: "攻击加成+1000%" },
            6: { critDamage: 53, description: "爆伤加成+5300%" }
        }
    },
 {
        name: "神话套装",
        bonuses: {
            2: { health: 22, description: "生命加成+2200%" },
            4: { critDamage: 400, description: "攻击加成+40000%" },
            6: { critDamage: 2000, description: "爆伤加成+200000%" }
        }
    },
 {
        name: "圣光套装",
        bonuses: {
            2: { health: 15, description: "生命加成+1500%" },
            4: { attack: 100, description: "攻击加成+10000%" },
            6: { critDamage: 1300, description: "爆伤加成+130000%" }
        }
    },
 {
        name: "混沌套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { attack: 300, description: "攻击加成+30000%" },
            6: { health: 1500, description: "生命加成+150000%" }
        }
    },
    {
        name: "白虎套装",
        bonuses: {
            2: { attack: 15, description: "攻击加成+1500%" },
            4: { attack: 400, description: "攻击加成+40000%" },
            6: { attack: 1850, description: "攻击加成+185000%" }
        }
    },
    {
        name: "朱雀套装",
        bonuses: {
            2: { critDamage: 20, description: "爆伤加成+2000%" },
            4: { critDamage: 250, description: "爆伤加成+25000%" },
            6: { attack: 1650, description: "攻击加成+165000%" }
        }
    },
    {
        name: "玄武套装",
        bonuses: {
            2: { health: 50, description: "生命加成+5000%" },
            4: { health: 500, description: "生命加成+50000%" },
            6: { health: 1800, description: "生命加成+180000%" }
        }
    },
    {
        name: "麒麟套装",
        bonuses: {
            2: { attack: 50, description: "攻击加成+5000%" },
            4: { attack: 550, description: "攻击加成+55000%" },
            6: { health: 1000, description: "生命加成+100000%" }
        }
    }
];

// 神器名字库
const artifactNames = {
    helmet: ["玄铁战盔", "流光宝冠", "暗影头盔", "烈焰头环", "凤羽冠", "圣光战盔", "疾风头盔", "雷霆战盔", "雷霆战盔", "守护者头盔", "幽魂头罩", "精灵之冠", "矮人战盔", "毒藤头环", "寒冰面甲", "荣耀战盔", "耻辱面甲", "刹那冠冕", "雨龙盔", "龟甲盔", "云龙盔", "饕餮头盔", "虬龙头盔", "青鸾头盔", "火凤头盔", "蛟龙头盔", "龙鳞头盔", "苍龙头盔", "虚无头盔"],
    clothes: ["龙鳞甲", "玄冰法袍", "暗影披风", "圣光铠甲", "大地之袍", "疾风劲装", "藤蔓风衣", "王者披风", "毁灭者战衣", "混沌战甲", "黎明法衣", "黄昏披风", "幽魂长衫", "泰坦铠甲", "矮人战甲", "恶魔披风", "磐石铠甲", "熔岩铠甲", "寒冰法袍", "静谧长衫", "狂怒战甲", "意志披风", "龙纹战甲", "流光战衣", "深渊战甲", "永恒战甲", "信仰战甲", "狂怒长衫", "闫闫内衣"],
    pants: ["星空护腿", "玄铁战裤", "暗影皮裤", "冰晶长裤", "圣光战裤", "幽冥长裤", "疾风短裤", "大地之裤", "藤蔓短裤", "混沌护腿", "雷霆战裤", "藤蔓护腿", "幻影护腿", "守护者护腿", "黎明护腿", "幽魂护腿", "恶魔护腿", "天使护腿", "毒藤护腿", "磐石护腿", "狂怒护腿", "勇气护腿", "雷神护腿", "火神护腿", "暗夜护腿", "星光护腿", "死神护腿", "闫闫黑丝"],
    shoes: ["流光战靴", "烈焰履", "黑麒麟战靴", "神玄武战靴", "邪白虎战靴", "圣朱雀羽靴", "灭世青龙战靴", "赫光圣靴", "疾风战靴", "混沌战靴", "死神战靴", "雷神战靴", "至尊战靴", "剑圣战靴", "剑神战靴", "灭神战靴", "永恒战靴", "火迷战靴", "镭射战靴", "冥王战靴", "仙人神靴", "风暴战靴", "荣耀圣靴", "暗夜神靴", "圣飒战靴", "强韧战靴", "傲世神靴"],
    necklace: ["星空项链", "烈焰项链", "王者项链", "玄德项链", "迪虎项链", "黎明项链", "幽魂项链", "黄昏圣链", "泰坦项链", "恶魔项链", "熔岩吊坠", "寒冰吊坠", "风暴吊坠", "狂怒吊坠", "力量吊坠", "勇气项链", "至尊项链", "荣耀项链", "凤羽项链", "流光项链", "顺神项链", "风日项链", "邪神吊坠", "睡神项链", "水神项链", "敖包吊坠", "死亡项链"],
    weapon: ["万古绝尘剑", "撼天动地斧", "焚天怒焰刀", "惊鸿掠影剑", "血狱幽冥枪", "破界陨星锤", "冰封千里杖", "地狱修罗刀", "九霄龙吟剑", "噬魂夺魄刃", "乾坤逆转戟", "裂地崩山斧", "焚天炽羽弓", "玄冰锁魂镰", "紫电灭魔剑", "血饮狂刀", "雷霆碎岳锤", "万劫不灭矛", "破空穿云箭", "寒霜冻世剑", "炎狱修罗枪", "星河碎影剑", "混沌开天斧", "白虎裂山刃", "炼狱修罗爪", "破天裂穹剑", "轩辕剑", "湛泸剑", "赤霄剑", "泰阿剑", "承影剑", "干将", "莫邪", "鱼肠剑", "无影剑艾雷诺", "破碎之命运", "光炎剑", "泰拉石手枪", "永恒之枪", "潘多拉魔盒", "三叉戟", "方天画戟", "草薙剑", "圣剑格拉墨", "命运之矛", "埃癸斯之盾", "杜蕾斯", "闫闫爱心锤", "茶茶小奶瓶"]
};
const advanceCosts = [5, 10, 20, 40, 80, 160, 320]; // 进阶1-7级所需神石
const advancePrefixes = [
    "", 
    "高·", 
    "超·", 
    "圣·", 
    "仙·", 
    "神·", 
    "荒·", 
    "帝·"
];
// 初始化神器系统
function initArtifactSystem() {
    if (!player.artifacts) {
        player.artifacts = {
            fragments: 0,
            crystals: 0,
            inventory: [],
            equipped: {
                helmet: null,
                clothes: null,
                pants: null,
                shoes: null,
                necklace: null,
                weapon: null
            },
            advanceLevels: {}, // 神器ID -> 进阶等级 (0-7)
            lockedArtifacts: []
        };
    }
    if (!player.artifacts.batchSelection) {
    player.artifacts.batchSelection = {
        selectedIds: [],
        filters: {
            quality: 'all',
            set: 'all',
            part: 'all'
        }
    };
}
    // 修复旧装备初始化问题
    if (!player.artifacts.advanceLevels) {
        player.artifacts.advanceLevels = {};
    }
     player.artifacts.inventory.forEach(artifact => {
        if (artifact.locked === undefined) {
            artifact.locked = false;
        }
    });
    
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact && artifact.locked === undefined) {
            artifact.locked = false;
        }
    });
    // 确保所有神器都有进阶等级
    player.artifacts.inventory.forEach(artifact => {
        if (!player.artifacts.advanceLevels[artifact.id]) {
            player.artifacts.advanceLevels[artifact.id] = 0;
        }
    });
    
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact && !player.artifacts.advanceLevels[artifact.id]) {
            player.artifacts.advanceLevels[artifact.id] = 0;
        }
    });
 player.artifacts.inventory.forEach(artifact => {
        if (!artifact.baseName) {
            artifact.baseName = artifact.name;
        }
    });
    
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact && !artifact.baseName) {
            artifact.baseName = artifact.name;
        }
    });
}
// 切换神器查看标签
function switchArtifactTab(tab) {
    const allTab = document.querySelector('.artifact-tab[onclick="switchArtifactTab(\'all\')"]');
    const setsTab = document.querySelector('.artifact-tab[onclick="switchArtifactTab(\'sets\')"]');
    
    if (tab === 'all') {
        document.getElementById('artifactInventory').style.display = 'grid';
        document.getElementById('artifactSetsView').style.display = 'none';
        allTab.classList.add('active');
        setsTab.classList.remove('active');
    } else {
        document.getElementById('artifactInventory').style.display = 'none';
        document.getElementById('artifactSetsView').style.display = 'block';
        allTab.classList.remove('active');
        setsTab.classList.add('active');
        updateArtifactSetsView();
    }
}

// 更新套装视图
function updateArtifactSetsView() {
    const container = document.getElementById('artifactSetsContainer');
    container.innerHTML = '';
    
    // 按套装分组
    const sets = {};
    player.artifacts.inventory.forEach(artifact => {
        const setName = artifact.set || '无套装';
        if (!sets[setName]) {
            sets[setName] = [];
        }
        sets[setName].push(artifact);
    });
    
    // 创建套装组
    Object.keys(sets).sort().forEach(setName => {
        const artifacts = sets[setName];
        const setGroup = document.createElement('div');
        setGroup.className = 'set-group set-collapsed';
        setGroup.id = `set-group-${setName.replace(/\s+/g, '-')}`;
        
        setGroup.innerHTML = `
            <div class="set-header" onclick="toggleSetGroup('${setName.replace(/\s+/g, '-')}')">
                <div class="set-name">${setName}</div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="set-count">${artifacts.length}件</span>
                    <span class="folder-arrow">▼</span>
                </div>
            </div>
            <div class="set-content">
                ${artifacts.map(artifact => createArtifactCardHTML(artifact)).join('')}
            </div>
        `;
        
        container.appendChild(setGroup);
    });
}

// 切换套装组展开/收起
function toggleSetGroup(setName) {
    const group = document.getElementById(`set-group-${setName}`);
    group.classList.toggle('set-collapsed');
}

// 创建神器卡片HTML（复用原有函数或创建新函数）
function createArtifactCardHTML(artifact) {
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const part = artifactParts.find(p => p.id === artifact.part);
    
    return `
        <div class="artifact-card" style="border: 2px solid ${quality.color};">
            <div style="color: ${quality.color}; font-weight: bold;">${artifact.name}</div>
            <div>${part.name}</div>
            <div style="font-size: 0.8em;">
                <div>等级: ${artifact.upgradeLevel}</div>
                <div>生命: +${(artifact.bonuses.health * 100).toFixed(1)}%</div>
                <div>攻击: +${(artifact.bonuses.attack * 100).toFixed(1)}%</div>
                <div>爆伤: +${(artifact.bonuses.critDamage * 100).toFixed(1)}%</div>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="equipArtifact('${artifact.id}')" style="background: #4CAF50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em; margin-right: 5px;">装备</button>
                <button onclick="showArtifactDetails('${artifact.id}')" style="background: #2196F3; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">详情</button>
               <button onclick="decomposeArtifactItem('${artifact.id}')" style="background: #f44336; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">分解</button>

            </div>
        </div>
    `;
}
// 切换神器系统界面
function toggleArtifactSystem() {
    if (player.reincarnationCount < 500) {
        alert("需要达到500转才能开启神器系统！");
        return;
    }
    const overlay = document.getElementById('artifactSystemOverlay');
    const ui = document.getElementById('artifactSystemUI');


    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initArtifactSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateArtifactUI();
    }
}

// 更新神器系统界面
   function updateArtifactUI() {
   

    
    // 更新装备部位
    updateArtifactSlots();
    
    // 更新神器仓库
    updateArtifactInventory();
    updateFilteredCount(); 
    // 更新套装效果
    updateSetBonuses();
}
function cleanupArtifactAdvanceLevels() {
    if (!player.artifacts || !player.artifacts.advanceLevels) return;
    
    // 获取所有有效的神器ID（仓库中的和装备中的）
    const validArtifactIds = new Set();
    
    // 添加仓库中的神器ID
    player.artifacts.inventory.forEach(artifact => {
        validArtifactIds.add(artifact.id);
    });
    
    // 添加装备中的神器ID
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            validArtifactIds.add(artifact.id);
        }
    });
    
    // 清理无效的进阶等级数据
    const oldCount = Object.keys(player.artifacts.advanceLevels).length;
    
    Object.keys(player.artifacts.advanceLevels).forEach(artifactId => {
        if (!validArtifactIds.has(artifactId)) {
            delete player.artifacts.advanceLevels[artifactId];
        }
    });
    
    const newCount = Object.keys(player.artifacts.advanceLevels).length;
    const removedCount = oldCount - newCount;
    
    if (removedCount > 0) {
        console.log(`清理了 ${removedCount} 个无效的进阶等级记录`);
    }
}
// 更新装备部位显示
function updateArtifactSlots() {
    const slotsContainer = document.getElementById('artifactSlots');
    slotsContainer.innerHTML = '';
    
    artifactParts.forEach(part => {
        const slot = document.createElement('div');
        slot.className = 'artifact-slot';
        slot.style.border = '1px solid #d4af37';
        slot.style.padding = '10px';
        slot.style.borderRadius = '5px';
        slot.style.textAlign = 'center';
        slot.style.backgroundColor = '#222';
        
        const equippedArtifact = player.artifacts.equipped[part.id];
        
        if (equippedArtifact) {
            const quality = artifactQualities.find(q => q.id === equippedArtifact.quality);
            const set = artifactSets.find(s => s.name === equippedArtifact.set);
            
            slot.innerHTML = `
                <div style="color: ${quality.color}; font-weight: bold;">${equippedArtifact.name}</div>
                <div>${part.name}</div>
                <div style="font-size: 0.8em; margin-top: 5px;">
                    <div>等级: ${equippedArtifact.upgradeLevel}</div>
                    <div>套装: <span style="color: #d4af37;">${equippedArtifact.set}</span></div>
                    <div>生命: +${(equippedArtifact.bonuses.health * 100).toFixed(1)}%</div>
                    <div>攻击: +${(equippedArtifact.bonuses.attack * 100).toFixed(1)}%</div>
                    <div>爆伤: +${(equippedArtifact.bonuses.critDamage * 100).toFixed(1)}%</div>
                </div>
                <button onclick="unequipArtifact('${part.id}')" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">卸下</button>
            `;
        } else {
            slot.innerHTML = `
                <div>${part.name}</div>
                <div style="color: #888; font-size: 0.9em; margin-top: 5px;">未装备</div>
            `;
        }
        
        slotsContainer.appendChild(slot);
    });
}

// 更新神器仓库显示
function updateArtifactInventory() {

    const inventoryContainer = document.getElementById('artifactInventory');
    const filterContainer = document.getElementById('artifactFilterUI');
    
    // 先创建筛选界面
    if (!filterContainer) {
        createFilterUI();
    }
    
    // 获取筛选后的神器列表
    const filteredArtifacts = getFilteredArtifacts();
    
    inventoryContainer.innerHTML = '';
    
    if (filteredArtifacts.length === 0) {
        inventoryContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">没有符合条件的神器</div>';
        return;
    }
    
    // 显示批量操作按钮
    inventoryContainer.innerHTML = `
     <div style="grid-column: 1 / -1; margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <strong style="color: #d4af37;">批量操作</strong>
            <button onclick="selectAllArtifacts()" style="margin: 0 5px; padding: 5px 10px;">全选</button>
            <button onclick="deselectAllArtifacts()" style="margin: 0 5px; padding: 5px 10px;">取消全选</button>
            <button onclick="batchLockArtifacts()" style="margin: 0 5px; padding: 5px 10px; background: #FF9800; color: white;">批量锁定选中神器</button>
            <button onclick="batchUnlockArtifacts()" style="margin: 0 5px; padding: 5px 10px; background: #666; color: white;">批量解锁选中神器</button>
            <button onclick="batchDecomposeArtifacts()" style="margin: 0 5px; padding: 5px 10px; background: #f44336; color: white;">批量分解选中神器 (${player.artifacts.batchSelection.selectedIds.length})</button>
            <span style="margin-left: 10px; color: #4CAF50;">选中: ${player.artifacts.batchSelection.selectedIds.length}/${filteredArtifacts.length}</span>
        </div>
    `;
    
    
    // 显示神器卡片
     filteredArtifacts.forEach(artifact => {
        const quality = artifactQualities.find(q => q.id === artifact.quality);
        const part = artifactParts.find(p => p.id === artifact.part);
        const isSelected = player.artifacts.batchSelection.selectedIds.includes(artifact.id);
        const isLocked = artifact.locked;
        
        const artifactCard = document.createElement('div');
        artifactCard.className = 'artifact-card';
        artifactCard.style.border = `2px solid ${isSelected ? '#4CAF50' : (isLocked ? '#FFD700' : quality.color)}`;
        artifactCard.style.padding = '10px';
        artifactCard.style.borderRadius = '5px';
        artifactCard.style.cursor = 'pointer';
        artifactCard.style.backgroundColor = isSelected ? '#2a2a2a' : '#1a1a1a';
        artifactCard.style.position = 'relative';
        artifactCard.onclick = (e) => {
            if (!e.target.closest('button')) {
                toggleArtifactSelection(artifact.id);
            }
        };
        
        // 添加锁定图标
        const lockIcon = isLocked ? '🔒' : '🔓';
        
        artifactCard.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <input type="checkbox" ${isSelected ? 'checked' : ''} 
                       onchange="toggleArtifactSelection('${artifact.id}')"
                       style="margin-right: 10px; transform: scale(1.2);">
                <div style="color: ${isLocked ? '#FFD700' : quality.color}; font-weight: bold; flex-grow: 1;">
                    ${artifact.name} ${lockIcon}
                </div>
            </div>
            <div>${part.name} | ${quality.name}</div>
            <div style="font-size: 0.8em; margin-top: 5px;">
                <div>等级: ${artifact.upgradeLevel}</div>
                <div>套装: <span style="color: #d4af37;">${artifact.set}</span></div>
                <div>生命: +${(artifact.bonuses.health * 100).toFixed(1)}%</div>
                <div>攻击: +${(artifact.bonuses.attack * 100).toFixed(1)}%</div>
                <div>爆伤: +${(artifact.bonuses.critDamage * 100).toFixed(1)}%</div>
            </div>
            <div style="margin-top: 10px; display: flex; gap: 5px; flex-wrap: wrap;">
                <button onclick="event.stopPropagation(); toggleArtifactLock('${artifact.id}')" 
                        style="background: ${isLocked ? '#FF9800' : '#666'}; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">
                    ${isLocked ? '解锁' : '锁定'}
                </button>
                <button onclick="event.stopPropagation(); showArtifactDetails('${artifact.id}')" 
                        style="background: #2196F3; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">详情</button>
                <button onclick="event.stopPropagation(); equipArtifact('${artifact.id}')" 
                        style="background: #4CAF50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">装备</button>
                <button onclick="event.stopPropagation(); upgradeArtifact('${artifact.id}')" 
                        style="background: #FF9800; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">升级</button>
                <button onclick="event.stopPropagation(); decomposeArtifactItem('${artifact.id}')" 
                        style="background: #f44336; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;"
                        ${isLocked ? 'disabled' : ''}>分解</button>
            </div>
        `;
        
        inventoryContainer.appendChild(artifactCard);
    });
}

 function createFilterUI() {
    const artifactSystemUI = document.getElementById('artifactSystemUI');
    
    // 在神器仓库标题前插入筛选界面
    const filterHTML = `
        <div id="artifactFilterUI" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 8px;">
            <h4 style="color: #d4af37; margin-top: 0;">筛选条件</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                <div>
                    <label>品质筛选:</label>
                    <select id="qualityFilter" onchange="updateArtifactFilter('quality', this.value)" style="width: 100%; padding: 5px;">
                        <option value="all">全部品质</option>
                        ${artifactQualities.map(q => `<option value="${q.id}">${q.name}</option>`).join('')}
                    </select>
                </div>
                <div>
                    <label>套装筛选:</label>
                    <select id="setFilter" onchange="updateArtifactFilter('set', this.value)" style="width: 100%; padding: 5px;">
                        <option value="all">全部套装</option>
                        ${[...new Set(artifactSets.map(s => s.name))].map(set => `<option value="${set}">${set}</option>`).join('')}
                    </select>
                </div>
                <div>
                    <label>部位筛选:</label>
                    <select id="partFilter" onchange="updateArtifactFilter('part', this.value)" style="width: 100%; padding: 5px;">
                        <option value="all">全部部位</option>
                        ${artifactParts.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                    </select>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="clearArtifactFilters()" style="background: #666; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 10px;">清除筛选</button>
                <span style="color: #888;">当前显示: <span id="filteredCount">0</span> 个神器</span>
            </div>
        </div>
    `;
    
    const inventoryTitle = artifactSystemUI.querySelector('h7');
    inventoryTitle.insertAdjacentHTML('afterend', filterHTML);
}

// 获取筛选后的神器列表
function getFilteredArtifacts() {
    const filters = player.artifacts.batchSelection.filters;
    
    return player.artifacts.inventory.filter(artifact => {
        // 品质筛选
        if (filters.quality !== 'all' && artifact.quality !== filters.quality) {
            return false;
        }
        
        // 套装筛选
        if (filters.set !== 'all' && artifact.set !== filters.set) {
            return false;
        }
        
        // 部位筛选
        if (filters.part !== 'all' && artifact.part !== filters.part) {
            return false;
        }
        
        return true;
    });
}

// 更新筛选条件
function updateArtifactFilter(type, value) {
    player.artifacts.batchSelection.filters[type] = value;
    
    // 清空选择（因为列表改变了）
    player.artifacts.batchSelection.selectedIds = [];
    
    updateArtifactInventory();
    updateFilteredCount();
}

// 清除所有筛选条件
function clearArtifactFilters() {
    player.artifacts.batchSelection.filters = {
        quality: 'all',
        set: 'all',
        part: 'all'
    };
    
    // 重置下拉菜单
    document.getElementById('qualityFilter').value = 'all';
    document.getElementById('setFilter').value = 'all';
    document.getElementById('partFilter').value = 'all';
    
    player.artifacts.batchSelection.selectedIds = [];
    updateArtifactInventory();
    updateFilteredCount();
}

// 更新筛选计数显示
function updateFilteredCount() {
    const filteredArtifacts = getFilteredArtifacts();
    document.getElementById('filteredCount').textContent = filteredArtifacts.length;
}
function batchLockArtifacts() {
    const selectedIds = player.artifacts.batchSelection.selectedIds;
    
    if (selectedIds.length === 0) {
        logAction("请先选择要锁定的神器", "error");
        return;
    }
    
    let lockedCount = 0;
    selectedIds.forEach(artifactId => {
        const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
        if (artifact && !artifact.locked) {
            artifact.locked = true;
            lockedCount++;
        }
    });
    
    if (lockedCount > 0) {
        logAction(`成功锁定 ${lockedCount} 个神器`, "success");
        updateArtifactUI();
    } else {
        logAction("选中的神器已经全部被锁定", "info");
    }
}

// 批量解锁函数
function batchUnlockArtifacts() {
    const selectedIds = player.artifacts.batchSelection.selectedIds;
    
    if (selectedIds.length === 0) {
        logAction("请先选择要解锁的神器", "error");
        return;
    }
    
    let unlockedCount = 0;
    selectedIds.forEach(artifactId => {
        const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
        if (artifact && artifact.locked) {
            artifact.locked = false;
            unlockedCount++;
        }
    });
    
    if (unlockedCount > 0) {
        logAction(`成功解锁 ${unlockedCount} 个神器`, "success");
        updateArtifactUI();
    } else {
        logAction("选中的神器已经全部未锁定", "info");
    }
}

// 新增锁定/解锁函数
function toggleArtifactLock(artifactId) {
    // 在仓库中查找神器
    let artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    
    // 如果在仓库中没找到，可能在装备中
    if (!artifact) {
        artifact = Object.values(player.artifacts.equipped).find(a => a && a.id === artifactId);
    }
    
    if (!artifact) return;
    
    artifact.locked = !artifact.locked;
    
    if (artifact.locked) {
        logAction(`已锁定神器：${artifact.name}`, 'success');
    } else {
        logAction(`已解锁神器：${artifact.name}`, 'success');
    }
    
    updateArtifactUI();
}
// 切换神器选择状态
function toggleArtifactSelection(artifactId) {
    const index = player.artifacts.batchSelection.selectedIds.indexOf(artifactId);
    
    if (index > -1) {
        // 如果已选中，则取消选择
        player.artifacts.batchSelection.selectedIds.splice(index, 1);
    } else {
        // 如果未选中，则选择
        player.artifacts.batchSelection.selectedIds.push(artifactId);
    }
    
    updateArtifactInventory();
}

// 全选当前筛选结果
function selectAllArtifacts() {
    const filteredArtifacts = getFilteredArtifacts();
    player.artifacts.batchSelection.selectedIds = filteredArtifacts.map(artifact => artifact.id);
    updateArtifactInventory();
}

// 取消全选
function deselectAllArtifacts() {
    player.artifacts.batchSelection.selectedIds = [];
    updateArtifactInventory();
}

// 批量分解选中的神器
function batchDecomposeArtifacts() {
    const selectedIds = player.artifacts.batchSelection.selectedIds;
    
    if (selectedIds.length === 0) {
        logAction("请先选择要分解的神器", "error");
        return;
    }
    
    // 过滤掉被锁定的神器
    const decomposableIds = selectedIds.filter(id => {
        const artifact = player.artifacts.inventory.find(a => a.id === id);
        return artifact && !artifact.locked;
    });
    
    const lockedCount = selectedIds.length - decomposableIds.length;
    
    if (lockedCount > 0) {
        logAction(`跳过 ${lockedCount} 个被锁定的神器`, "info");
    }
    
    if (decomposableIds.length === 0) {
        logAction("没有可分解的神器（所有选中的神器都被锁定）", "error");
        return;
    }
    
    showCustomConfirm(`确定要批量分解 ${decomposableIds.length} 个神器吗？${lockedCount > 0 ? `（跳过 ${lockedCount} 个被锁定的神器）` : ''}此操作不可撤销！`, (confirmed) => {
        if (confirmed) {
            let totalFragments = 0;
            let totalCrystals = 0;
            let decomposedCount = 0;
            
            // 分解选中的神器（只分解未锁定的）
            decomposableIds.forEach(artifactId => {
                const artifactIndex = player.artifacts.inventory.findIndex(a => a.id === artifactId);
                if (artifactIndex > -1) {
                    const artifact = player.artifacts.inventory[artifactIndex];
                    const rewards = calculateDecompositionReward(artifact);
                    
                    totalFragments += rewards.fragments;
                    totalCrystals += rewards.crystals;
                    decomposedCount++;
                    
                    // 从仓库中移除
                    player.artifacts.inventory.splice(artifactIndex, 1);
                }
            });
            
            // 添加资源
            player.exploration.resources.artifactFragment += totalFragments;
            player.exploration.resources.cosmicCrystal += totalCrystals;
            
            // 清空选择
            player.artifacts.batchSelection.selectedIds = [];
            
            // 更新显示
            updateArtifactUI();
            updateExplorationUI();
            
            // 显示分解结果
            showBatchDecompositionResult(decomposedCount, totalFragments, totalCrystals);
        }
    });
}

// 显示批量分解结果
function showBatchDecompositionResult(count, fragments, crystals) {
    const resultOverlay = document.createElement('div');
    resultOverlay.id = 'batchDecompositionResultOverlay';
    resultOverlay.style.position = 'fixed';
    resultOverlay.style.top = '0';
    resultOverlay.style.left = '0';
    resultOverlay.style.width = '100%';
    resultOverlay.style.height = '100%';
    resultOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    resultOverlay.style.zIndex = '2000';
    resultOverlay.style.display = 'flex';
    resultOverlay.style.justifyContent = 'center';
    resultOverlay.style.alignItems = 'center';
    
    const resultCard = document.createElement('div');
    resultCard.style.backgroundColor = '#1a1a1a';
    resultCard.style.padding = '30px';
    resultCard.style.borderRadius = '10px';
    resultCard.style.border = '3px solid #4CAF50';
    resultCard.style.width = '450px';
    resultCard.style.maxWidth = '90%';
    resultCard.style.textAlign = 'center';
    
    resultCard.innerHTML = `
        <h2 style="color: #4CAF50; margin-top: 0;">批量分解完成</h2>
        <div style="margin-bottom: 20px;">
            <div style="font-size: 1.2em; margin-bottom: 10px;">成功分解了 <span style="color: #4CAF50;">${count}</span> 个神器</div>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #d4af37;">获得资源</div>
            <div style="display: flex; justify-content: space-around; margin-top: 15px;">
                <div>
                    <div style="font-size: 1.2em; color: #FF9800;">${fragments}</div>
                    <div>神器碎片</div>
                </div>
                <div>
                    <div style="font-size: 1.2em; color: #2196F3;">${crystals}</div>
                    <div>宇宙晶体</div>
                </div>
            </div>
        </div>
        <button onclick="document.body.removeChild(document.getElementById('batchDecompositionResultOverlay'))" 
                style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 1.1em;">
            确认
        </button>
    `;
    
    resultOverlay.appendChild(resultCard);
    document.body.appendChild(resultOverlay);
    
    logAction(`批量分解了 ${count} 个神器，获得 ${fragments} 碎片和 ${crystals} 晶体`, "success");
}
// 更新套装效果显示
function updateSetBonuses() {
    const setContainer = document.getElementById('setBonuses');
    setContainer.innerHTML = '';
    
    // 计算当前装备的套装数量
    const setCounts = {};
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            if (!setCounts[artifact.set]) {
                setCounts[artifact.set] = 0;
            }
            setCounts[artifact.set]++;
        }
    });
    
    // 显示激活的套装效果
    Object.entries(setCounts).forEach(([setName, count]) => {
        const set = artifactSets.find(s => s.name === setName);
        if (!set) return;
        
        const setDiv = document.createElement('div');
        setDiv.style.marginBottom = '15px';
        setDiv.style.padding = '15px';
        setDiv.style.border = '1px solid #d4af37';
        setDiv.style.borderRadius = '5px';
        setDiv.style.backgroundColor = '#1a1a1a';
        
        let bonusesHtml = `<div style="font-weight: bold; color: #d4af37; font-size: 1.1em; margin-bottom: 10px;">${setName} (${count}/6)</div>`;
        
        // 显示已激活的效果
        Object.entries(set.bonuses).forEach(([pieceCount, bonus]) => {
            const pieceNum = parseInt(pieceCount);
            const isActive = count >= pieceNum;
            
            bonusesHtml += `
                <div style="margin-top: 8px; ${isActive ? 'color: #4CAF50;' : 'color: #888;'}">
                    ${isActive ? '✓ ' : ''}${pieceCount}件: ${bonus.description}
                </div>
            `;
        });
        
        setDiv.innerHTML = bonusesHtml;
        setContainer.appendChild(setDiv);
    });
    
    if (Object.keys(setCounts).length === 0) {
        setContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">未装备任何套装神器</div>';
    }
}
function showArtifactDetails(artifactId) {
   // 先移除可能已存在的详情弹窗
    const existingOverlay = document.getElementById('artifactDetailOverlay');
    if (existingOverlay) {
        document.body.removeChild(existingOverlay);
    }
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const part = artifactParts.find(p => p.id === artifact.part);
    
    // 创建详情弹窗
    const detailOverlay = document.createElement('div');
    detailOverlay.id = 'artifactDetailOverlay';
    detailOverlay.style.position = 'fixed';
    detailOverlay.style.top = '0';
    detailOverlay.style.left = '0';
    detailOverlay.style.width = '100%';
    detailOverlay.style.height = '100%';
    detailOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    detailOverlay.style.zIndex = '2000';
    detailOverlay.style.display = 'flex';
    detailOverlay.style.justifyContent = 'center';
    detailOverlay.style.alignItems = 'center';
    
    const detailCard = document.createElement('div');
    detailCard.style.backgroundColor = '#1a1a1a';
    detailCard.style.padding = '20px';
    detailCard.style.borderRadius = '10px';
    detailCard.style.border = `3px solid ${quality.color}`;
    detailCard.style.width = '400px';
    detailCard.style.maxWidth = '90%';
    

     // 在详情页面添加锁定按钮
    const isLocked = artifact.locked;
    
    detailCard.innerHTML = `
        <div style="text-align: right;">
            <button onclick="document.body.removeChild(document.getElementById('artifactDetailOverlay'))" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="color: ${quality.color}; font-size: 1.2em; font-weight: bold;">${artifact.name} ${isLocked ? '🔒' : '🔓'}</div>
            <div> ${part.name}</div>
            <div style="margin-top: 10px; font-size: 1.1em; color: #d4af37;">${artifact.set}套装</div>
        </div>
        <div style="margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>品质:</span>
                <span style="color: ${quality.color};">${quality.name}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>升级等级:</span>
                <span>${artifact.upgradeLevel}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>锁定状态:</span>
                <span style="color: ${isLocked ? '#FFD700' : '#666'};">${isLocked ? '已锁定' : '未锁定'}</span>
            </div>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #d4af37;">属性加成</div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>生命加成:</span>
                <span>+${(artifact.bonuses.health * 100).toFixed(1)}%</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>攻击加成:</span>
                <span>+${(artifact.bonuses.attack * 100).toFixed(1)}%</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>爆伤加成:</span>
                <span>+${(artifact.bonuses.critDamage * 100).toFixed(1)}%</span>
            </div>
        </div>
        <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
            <button onclick="toggleArtifactLock('${artifact.id}'); showArtifactDetails('${artifact.id}')" 
                    style="background: ${isLocked ? '#FF9800' : '#666'}; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                ${isLocked ? '解锁神器' : '锁定神器'}
            </button>
            <button onclick="equipArtifact('${artifact.id}')" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">装备</button>
            <button onclick="upgradeArtifact('${artifact.id}')" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">升级</button>
            <button onclick="decomposeArtifactItem('${artifact.id}')" 
                    style="background: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;"
                    ${isLocked ? 'disabled' : ''}>分解</button>
        </div>
    `;
     // 获取进阶等级
     const baseName = artifact.baseName || artifact.name;
    const advanceLevel = player.artifacts.advanceLevels[artifactId] || 0;
    
    // 更新进阶信息显示
    const advanceInfo = document.getElementById('artifactAdvanceInfo');
    const advanceBtn = document.getElementById('advanceArtifactBtn');
    advanceBtn.onclick = function() {
        advanceArtifact(artifactId);
    };
    
    if (advanceLevel < 7) {
        const cost = advanceCosts[advanceLevel];
        advanceInfo.innerHTML = `
            <div>当前进阶: ${advanceLevel}级 (${advancePrefixes[advanceLevel]}${baseName})</div>
            <div>下一进阶: ${advanceLevel + 1}级 (${advancePrefixes[advanceLevel + 1]}${baseName})</div>
            <div>消耗: ${cost} 进阶神石</div>
            <div>属性提升: ${Math.pow(2, advanceLevel + 1).toFixed(1)}倍</div>
        `;
        
        // 检查是否有足够进阶神石
        if (player.items.advanceStone >= cost) {
            advanceBtn.disabled = false;
            advanceBtn.textContent = "进阶神器";
        } else {
            advanceBtn.disabled = true;
            advanceBtn.textContent = "进阶神石不足";
        }
    } else {
        advanceInfo.innerHTML = `
            <div>当前进阶: 7级 (${advancePrefixes[7]}${baseName})</div>
            <div>已达最高进阶等级</div>
            <div>属性加成: ${Math.pow(2, 7).toFixed(1)}倍</div>
        `;
        advanceBtn.disabled = true;
        advanceBtn.textContent = "已达最高进阶";
    }

    detailOverlay.appendChild(detailCard);
    document.body.appendChild(detailOverlay);
}
function advanceArtifact(artifactId) {
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    const advanceLevel = player.artifacts.advanceLevels[artifactId] || 0;
    if (advanceLevel >= 7) return;
    
    const cost = advanceCosts[advanceLevel];
    if (player.items.advanceStone < cost) {
        logAction("进阶神石不足！", "error");
        return;
    }
    
    // 扣除进阶神石
    player.items.advanceStone -= cost;
    
    // 提升进阶等级
    player.artifacts.advanceLevels[artifactId] = advanceLevel + 1;
    
    // 更新名字前缀
    artifact.name = advancePrefixes[advanceLevel + 1] + artifact.baseName;
    
    logAction(`成功将${artifact.baseName}进阶到${advanceLevel + 1}级！`, "success");
    
    // 更新显示
    updateArtifactUI();
    showArtifactDetails(artifactId); // 重新加载详情页面
}

function decomposeArtifactItem(artifactId) {  
    // 检查是否被锁定
    if (artifact.locked) {
        logAction(`无法分解被锁定的神器：${artifact.name}`, "error");
        return;
    }
   
    const artifactIndex = player.artifacts.inventory.findIndex(a => a.id === artifactId);
    if (artifactIndex === -1) return;
    
    const artifact = player.artifacts.inventory[artifactIndex];
    
    // 计算分解收益
    const decompositionRewards = calculateDecompositionReward(artifact);
    
    // 添加资源
    player.exploration.resources.artifactFragment += decompositionRewards.fragments;
    player.exploration.resources.cosmicCrystal += decompositionRewards.crystals;
    
    // 从仓库中移除神器
    player.artifacts.inventory.splice(artifactIndex, 1);
    
    // 更新UI
    updateArtifactUI();
    updateExplorationUI();
    updateArtifactSetsView();
    // 显示分解结果
    showDecompositionResult(artifact, decompositionRewards);
}

// 计算分解收益
function calculateDecompositionReward(artifact) {
    // 基础收益基于品质
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const baseRewards = {
        common: { fragments: 1, crystals: 1 },
        uncommon: { fragments: 3, crystals: 2 },
        rare: { fragments: 5, crystals: 5 },
        epic: { fragments: 8, crystals: 8 },
        legendary: { fragments: 20, crystals: 10 },
        mythic: { fragments: 50, crystals: 20 }
    };
    
    // 获取基础收益
    const base = baseRewards[artifact.quality] || baseRewards.common;
    
    // 升级加成：每级增加20%收益
    const upgradeMultiplier = 1 + (artifact.upgradeLevel * 0.2);
    
    // 套装加成：套装神器额外增加50%收益
    const setMultiplier = artifact.set ? 1.5 : 1;
    
    // 计算最终收益
    const fragments = Math.floor(base.fragments * upgradeMultiplier * setMultiplier);
    const crystals = Math.floor(base.crystals * upgradeMultiplier * setMultiplier);
    
    return { fragments, crystals };
}

// 显示分解结果
function showDecompositionResult(artifact, rewards) {
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const part = artifactParts.find(p => p.id === artifact.part);
    
    // 创建结果弹窗
    const resultOverlay = document.createElement('div');
    resultOverlay.id = 'decompositionResultOverlay';
    resultOverlay.style.position = 'fixed';
    resultOverlay.style.top = '0';
    resultOverlay.style.left = '0';
    resultOverlay.style.width = '100%';
    resultOverlay.style.height = '100%';
    resultOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    resultOverlay.style.zIndex = '2000';
    resultOverlay.style.display = 'flex';
    resultOverlay.style.justifyContent = 'center';
    resultOverlay.style.alignItems = 'center';
    
    const resultCard = document.createElement('div');
    resultCard.style.backgroundColor = '#1a1a1a';
    resultCard.style.padding = '30px';
    resultCard.style.borderRadius = '10px';
    resultCard.style.border = `3px solid ${quality.color}`;
    resultCard.style.width = '450px';
    resultCard.style.maxWidth = '90%';
    resultCard.style.textAlign = 'center';
    
    resultCard.innerHTML = `
        <h2 style="color: ${quality.color}; margin-top: 0;">分解成功</h2>
        <div style="margin-bottom: 20px;">
            <div style="font-size: 1.1em; margin-bottom: 10px;">${artifact.name} (${part.name})</div>
            <div style="color: #d4af37; margin-bottom: 10px;">${artifact.set}套装</div>
            <div>品质: <span style="color: ${quality.color};">${quality.name}</span></div>
            <div>升级等级: ${artifact.upgradeLevel}</div>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #d4af37;">获得资源</div>
            <div style="display: flex; justify-content: space-around; margin-top: 15px;">
                <div>
                    <div style="font-size: 1.2em; color: #FF9800;">${rewards.fragments}</div>
                    <div>神器碎片</div>
                </div>
                <div>
                    <div style="font-size: 1.2em; color: #2196F3;">${rewards.crystals}</div>
                    <div>宇宙晶体</div>
                </div>
            </div>
        </div>
        <button onclick="document.body.removeChild(document.getElementById('decompositionResultOverlay'))" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 1.1em;">确认</button>
    `;
    
    resultOverlay.appendChild(resultCard);
    document.body.appendChild(resultOverlay);
}


// 锻造神器
function forgeArtifact(batchCount = 1) {
    const costPerForge = 10;
    const totalCost = costPerForge * batchCount;
    
    if (player.exploration.resources.artifactFragment < totalCost) {
        logAction(`神器碎片不足！需要 ${totalCost}，当前只有 ${player.exploration.resources.artifactFragment}`, "error");
        return;
    }
    
    player.exploration.resources.artifactFragment -= totalCost;
    
    // 记录获得的各品质神器数量
    const qualityCounts = {};
    artifactQualities.forEach(q => {
        qualityCounts[q.id] = 0;
    });
    
    // 批量锻造
    for (let i = 0; i < batchCount; i++) {
        // 随机选择部位
        const part = artifactParts[Math.floor(Math.random() * artifactParts.length)];
    // 随机选择品质（概率不同）
    const qualityRoll = Math.random();
    let quality;
    if (qualityRoll < 0.7) quality = artifactQualities[0]; 
    else if (qualityRoll < 0.95) quality = artifactQualities[1]; 
    else if (qualityRoll < 0.995) quality = artifactQualities[2]; 
    else if (qualityRoll < 0.9995) quality = artifactQualities[3]; 
    else if (qualityRoll < 0.99999) quality = artifactQualities[4]; 
    else quality = artifactQualities[5]; 
      // 记录品质数量
        qualityCounts[quality.id]++;
    // 随机选择名字
    const name = artifactNames[part.id][Math.floor(Math.random() * artifactNames[part.id].length)];
    
    // 随机选择套装
    const set = artifactSets[Math.floor(Math.random() * artifactSets.length)];
    
    // 生成随机属性（在品质范围内）
    const bonuses = {
        health: (Math.random() * (quality.maxBonus - quality.minBonus) + quality.minBonus).toFixed(3),
        attack: (Math.random() * (quality.maxBonus - quality.minBonus) + quality.minBonus).toFixed(3),
        critDamage: (Math.random() * (quality.maxBonus - quality.minBonus) + quality.minBonus).toFixed(3)
    };
    
    // 创建神器
    const artifact = {
        id: 'artifact_' + Date.now() + Math.random(),
        name: name,
        baseName: name,
        part: part.id,
        quality: quality.id,
        set: set.name,
        bonuses: bonuses,
        upgradeLevel: 0,
        advanceLevel: 0
    };
    
     player.artifacts.inventory.push(artifact);
        
        // 单次锻造时显示消息
        if (batchCount === 1) {
            logAction(`成功锻造 ${quality.name}品质${part.name}：${name}`, 'success');
        }
    }
    
    // 批量锻造时显示汇总消息
    if (batchCount > 1) {
        let summaryMessage = `批量锻造 ${batchCount} 次，消耗 ${totalCost} 神器碎片，获得：`;
        
        // 添加各品质数量
        artifactQualities.forEach(q => {
            if (qualityCounts[q.id] > 0) {
                summaryMessage += `${q.name}x${qualityCounts[q.id]} `;
            }
        });
        
        logAction(summaryMessage, 'success');
    }
    
    // 更新UI
    updateArtifactUI();
   updateArtifactSetsView();
}

// 装备神器
function equipArtifact(artifactId) {
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    // 检查该部位是否已装备
    if (player.artifacts.equipped[artifact.part]) {
        // 卸下当前装备
        const currentArtifact = player.artifacts.equipped[artifact.part];
        player.artifacts.inventory.push(currentArtifact);
    }
    
    // 装备新神器
    player.artifacts.equipped[artifact.part] = artifact;
    
    // 从仓库移除
    player.artifacts.inventory = player.artifacts.inventory.filter(a => a.id !== artifactId);
    
    logAction(`装备了神器：${artifact.name}`, 'success');
   updateExplorationUI();
  updateArtifactUI();
    updatePlayerBattleStats(); // 更新玩家战斗属性
}

// 卸下神器
function unequipArtifact(part) {
    const artifact = player.artifacts.equipped[part];
    if (!artifact) return;
    
    player.artifacts.inventory.push(artifact);
    player.artifacts.equipped[part] = null;
    
    logAction(`卸下了神器：${artifact.name}`, 'success');
    updateArtifactUI();
    updatePlayerBattleStats(); // 更新玩家战斗属性
}

// 升级神器
function upgradeArtifact(artifactId) {
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    const upgradeCost = 10 * (artifact.upgradeLevel + 1);
    if (player.exploration.resources.cosmicCrystal < upgradeCost) {
        logAction(`宇宙晶体不足！需要${upgradeCost}`, "error");
        return;
    }
    
    player.exploration.resources.cosmicCrystal -= upgradeCost;
    artifact.upgradeLevel++;
    
    // 提升属性（最多提升50%）
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const maxBonus = quality.maxBonus * 100000000; // 最大提升100%
    
    Object.keys(artifact.bonuses).forEach(key => {
        const currentBonus = parseFloat(artifact.bonuses[key]);
        const upgradeAmount = Math.min(
            maxBonus - currentBonus,
            quality.maxBonus * 0.1 // 每次升级提升10%的品质上限
        );
        
        if (upgradeAmount > 0) {
            artifact.bonuses[key] = (currentBonus + upgradeAmount).toFixed(3);
        }
    });
     // 在升级成功后，检查是否有打开的详情弹窗，如果有则刷新它
    const detailOverlay = document.getElementById('artifactDetailOverlay');
    if (detailOverlay) {
        // 先关闭现有弹窗
        document.body.removeChild(detailOverlay);
        // 重新打开详情弹窗显示最新数据
        showArtifactDetails(artifactId);
    }
    logAction(`成功升级 ${artifact.name} 到 Lv.${artifact.upgradeLevel}`, 'success');
updateArtifactUI();
  updateArtifactSetsView();
}

// 计算神器总加成
function calculateArtifactBonuses() {
    const bonuses = {
        health: 0,
        attack: 0,
        critDamage: 0
    };
    
    // 累加所有装备神器的加成
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            const advanceLevel = player.artifacts.advanceLevels[artifact.id] || 0;
            const advanceMultiplier = Math.pow(2, advanceLevel);
            bonuses.health += parseFloat(artifact.bonuses.health) * advanceMultiplier;
            bonuses.attack += parseFloat(artifact.bonuses.attack) * advanceMultiplier;
            bonuses.critDamage += parseFloat(artifact.bonuses.critDamage) * advanceMultiplier;
        }
    });
    
    // 应用套装效果
    const setCounts = {};
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            if (!setCounts[artifact.set]) {
                setCounts[artifact.set] = 0;
            }
            setCounts[artifact.set]++;
        }
    });
    
    Object.entries(setCounts).forEach(([setName, count]) => {
        const set = artifactSets.find(s => s.name === setName);
        if (!set) return;
        
        Object.entries(set.bonuses).forEach(([pieceCount, bonus]) => {
            if (count >= parseInt(pieceCount)) {
                bonuses.health += bonus.health || 0;
                bonuses.attack += bonus.attack || 0;
                bonuses.critDamage += bonus.critDamage || 0;
            }
        });
    });
    
    return bonuses;
}
function initSectData() {
    if (!player.sect) {
        player.sect = {
            created: false,
            name: "",
            level: 0,
            exp: 0,
            spiritStones: 0,
            members: [],
            missions: [],
            techniques: {},
            creationTime: 0,
            maxMembers: 5
        };
    }
}

// 切换宗门系统界面
function toggleSectSystem() {
    if (player.reincarnationCount < 1000) {
        alert("需要达到1000转才能开启宗门系统！");
        return;
    }
    
    const ui = document.getElementById('sectSystemUI');
    const overlay = document.getElementById('sectSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initSectData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateSectUI();
    }
}

// 创建宗门
function createSect() {
    if (player.sect.created) {
        logAction("你已经创建过宗门了！", "error");
        return;
    }
    
    if (player.items.zongmen < 1) {
        logAction("宗门令牌不足，无法创建宗门！", "error");
        return;
    }
    
    // 消耗宗门令牌
    player.items.zongmen--;
    
    // 初始化宗门数据
    player.sect = {
        created: true,
        name: "无名宗门",
        level: 1,
        exp: 0,
        spiritStones: 1000,
        members: [],
        missions: [],
        techniques: {},
        creationTime: Date.now(),
        maxMembers: 5
    };
    
    // 自动添加掌门（玩家自己）
    player.sect.members.push({
        id: "leader",
        name: player.name,
        aptitude: "SS",
        loyalty: 100,
        status: "idle",
        joinTime: Date.now()
    });
    
    logAction("成功创建宗门！", "success");
    updateSectUI();
   updateSectNameDisplay();
}

// 更新宗门界面
function updateSectUI() {
    if (!player.sect.created) {
        document.getElementById('sectInfoContainer').innerHTML = `
            <div style="text-align: center; padding: 20px;">
                <h3 style="color: #8B4513;">尚未创建宗门</h3>
                <p>创建宗门需要消耗1个宗门令牌</p>
                <button onclick="createSect()" style="background: #8B4513; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">创建宗门</button>
            </div>
        `;
        return;
    }
    
    // 更新宗门信息
    document.getElementById('sectInfoContainer').innerHTML = `
        <div style="display: flex; justify-content: space-between;">
            <div>
                <h3 style="color: #8B4513; margin: 0;">${player.sect.name}</h3>
                <div>等级: ${player.sect.level} | 声望: ${player.sect.exp.toFixed(0)}/${getNextLevelExp().toFixed(0)}</div>
                <div>成员: ${player.sect.members.length}/${player.sect.maxMembers}</div>
            </div>
            <div style="text-align: right;">
                <div>灵石: <span style="color: #FFD700;">${player.sect.spiritStones.toFixed(0)}</span></div>
                <div>功法数量: ${Object.keys(player.sect.techniques).length}</div>
            </div>
        </div>
    `;
     // 更新招募消耗显示
    document.getElementById('recruitCost').textContent = calculateRecruitCost().toFixed(0);
    // 更新成员列表
    updateMemberList();
    
    // 更新任务列表
    updateMissionList();
    
    // 更新功法列表
    updateTechniqueList();
    
    // 更新设置页面
    document.getElementById('sectNameInput').value = player.sect.name;
    document.getElementById('sectCreationDate').textContent = new Date(player.sect.creationTime).toLocaleDateString();
}

// 更新成员列表
function updateMemberList() {
    const container = document.getElementById('memberList');
    container.innerHTML = '';
    
    player.sect.members.forEach(member => {
        const memberCard = document.createElement('div');
        memberCard.className = 'member-card';
        memberCard.style.background = '#444';
        memberCard.style.padding = '10px';
        memberCard.style.borderRadius = '5px';
        
        // 根据资质设置颜色
        let aptitudeColor = '#ccc';
        if (member.aptitude === 'SSS') aptitudeColor = '#FFD700';
        else if (member.aptitude === 'SS') aptitudeColor = '#FF6B6B';
        else if (member.aptitude === 'S') aptitudeColor = '#4ECDC4';
        else if (member.aptitude === 'A') aptitudeColor = '#FF9FF3';
        else if (member.aptitude === 'B') aptitudeColor = '#FECA57';
        else if (member.aptitude === 'C') aptitudeColor = '#54A0FF';
        
        // 检查成员是否在任务中
        const isOnMission = member.status === 'onMission';
        
        memberCard.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
                <div style="font-weight: bold;">${member.name}</div>
                <div style="color: ${aptitudeColor};">${member.aptitude}</div>
            </div>
            <div>忠诚度: ${member.loyalty}</div>
            <div>状态: ${isOnMission ? '<span style="color: #FF9800;">任务中</span>' : '空闲'}</div>
            ${member.id !== 'leader' && !isOnMission ? `
            <button onclick="expelMember('${member.id}')" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">驱逐</button>
            <button onclick="giftMember('${member.id}')" style="background: #4CAF50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 12px; flex: 1;">赠礼</button>
            ` : ''}
        `;
        
        container.appendChild(memberCard);
    });
}
function updateSectNameDisplay() {
    const sectNameDisplay = document.getElementById('sectNameDisplay');
    
    if (player.sect && player.sect.created) {
        sectNameDisplay.textContent = `宗门: ${player.sect.name}`;
        sectNameDisplay.style.display = 'block';
    } else {
        sectNameDisplay.style.display = 'none';
    }
}
function giftMember(memberId) {
    const member = player.sect.members.find(m => m.id === memberId);
    if (!member) return;
    
    // 检查玫瑰花数量
    if (player.items.roseq < 1) {
        logAction("香囊不足！", "error");
        return;
    }
    
    // 检查忠诚度是否已达上限
    if (member.loyalty >= 100) {
        logAction(`${member.name}的忠诚度已达上限！`, "info");
        return;
    }
    
    // 消耗香囊
    player.items.roseq--;
    
    // 增加忠诚度
    member.loyalty += 5;
    if (member.loyalty > 100) member.loyalty = 100;
    
    logAction(`赠送给${member.name}一个香囊，忠诚度提升5点！`, "success");
    updateSectUI();
    updateDisplay();
}
// 招募弟子
function recruitMember() {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    if (player.sect.members.length >= player.sect.maxMembers) {
        logAction("宗门成员已满！", "error");
        return;
    }
    
    const cost = calculateRecruitCost();
    if (player.sect.spiritStones < cost) {
        logAction(`灵石不足！需要 ${cost} 灵石`, "error");
        return;
    }
    
    // 消耗灵石
    player.sect.spiritStones -= cost;
    
    // 随机生成弟子属性
    const aptitudes = ['C', 'B', 'A', 'S', 'SS', 'SSS'];
    const weights = [0.60, 0.25, 0.10, 0.039, 0.01, 0.001]; 
    
    let rand = Math.random();
    let aptitude = 'C';
    for (let i = 0; i < weights.length; i++) {
        rand -= weights[i];
        if (rand <= 0) {
            aptitude = aptitudes[i];
            break;
        }
    }
    
    // 生成随机名字
    const familyNames = ['赵', '钱', '孙', '李', '周', '吴', '郑', '王', '冯', '陈', '褚', '卫'];
    const givenNames = ['明', '华', '强', '伟', '芳', '娜', '秀英', '勇', '军', '杰', '磊', '超', '鹏', '婷'];
    const name = familyNames[Math.floor(Math.random() * familyNames.length)] + 
                 givenNames[Math.floor(Math.random() * givenNames.length)];
    
    // 添加新成员
    const newMember = {
        id: 'member_' + Date.now(),
        name: name,
        aptitude: aptitude,
        loyalty: 70 + Math.floor(Math.random() * 20), // 70-89的忠诚度
        status: 'idle',
        joinTime: Date.now()
    };
    
    player.sect.members.push(newMember);
    
    logAction(`成功招募弟子: ${name} (${aptitude}资质)`, "success");
    document.getElementById('recruitCost').textContent = calculateRecruitCost().toFixed(0);
    updateSectUI();
}

// 计算招募成本
function calculateRecruitCost() {
    return 100 * Math.pow(1.15, player.sect.members.length);
}

// 驱逐弟子
function expelMember(memberId) {
    const memberIndex = player.sect.members.findIndex(m => m.id === memberId);
    if (memberIndex === -1) return;
    
    const member = player.sect.members[memberIndex];
    
    // 移除成员
    player.sect.members.splice(memberIndex, 1);
    
    // 降低其他成员忠诚度（1-5点）
    player.sect.members.forEach(m => {
        if (m.id !== 'leader') {
            m.loyalty -= 1 + Math.floor(Math.random() * 4);
            if (m.loyalty < 0) m.loyalty = 0;
        }
    });
    
    logAction(`已驱逐弟子: ${member.name}`, "info");
    updateSectUI();
}

// 切换宗门标签页
function openSectTab(tabName) {
    // 隐藏所有标签内容
    document.querySelectorAll('.sect-tabcontent').forEach(tab => {
        tab.style.display = 'none';
    });
    
    // 移除所有标签的active类
    document.querySelectorAll('.sect-tablink').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // 显示选中的标签内容并添加active类
    document.getElementById('sect' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).style.display = 'block';
    event.currentTarget.classList.add('active');
}

// 初始化宗门任务
function initSectMissions() {
    return [
        {
            id: "gather_stones",
            name: "采集灵石",
            description: "派遣弟子前往灵脉采集灵石",
            requiredAptitude: "C",
            duration: 21600000, // 6小时
            reward: { stones: 600, exp: 300 },
            difficulty: 1
        },
        {
            id: "hunt_demon",
            name: "剿灭妖兽",
            description: "清除宗门附近的低阶妖兽",
            requiredAptitude: "B",
            duration: 21600000, // 6小时
            reward: { stones: 800, exp: 400 },
            difficulty: 2
        },
        {
            id: "explore_ruins",
            name: "探索遗迹",
            description: "探索古代修士遗留的洞府遗迹",
            requiredAptitude: "A",
            duration: 21600000, // 6小时
            reward: { stones: 1200, exp: 500, itemChance: 0.3 },
            difficulty: 3
        },
        {
            id: "guard_caravan",
            name: "护送商队",
            description: "护送商队通过危险区域",
            requiredAptitude: "S",
            duration: 21600000, // 6小时
            reward: { stones: 1700, exp: 750, itemChance: 0.5 },
            difficulty: 4
        },
        {
            id: "compete_tournament",
            name: "参加论道大会",
            description: "代表宗门参加修仙界论道大会",
            requiredAptitude: "SS",
            duration: 21600000, // 6小时
            reward: { stones: 2500, exp: 1000, itemChance: 0.7 },
            difficulty: 5
        },
        {
            id: "slay_ancient_demon",
            name: "讨伐上古魔头",
            description: "讨伐苏醒的上古魔头，维护修仙界和平",
            requiredAptitude: "SSS",
            duration: 21600000, // 6小时
            reward: { stones: 6000, exp: 2000, itemChance: 0.9 },
            difficulty: 6
        }
    ];
}

// 更新任务列表
function updateMissionList() {
    const missionContainer = document.getElementById('missionList');
    const activeMissionContainer = document.getElementById('activeMissionList');
    
    missionContainer.innerHTML = '';
    activeMissionContainer.innerHTML = '';
    
    // 获取任务列表
    const missions = initSectMissions();
    
    // 显示可用任务
    missions.forEach(mission => {
        const missionCard = document.createElement('div');
        missionCard.className = 'mission-card';
        missionCard.style.background = '#444';
        missionCard.style.padding = '10px';
        missionCard.style.borderRadius = '5px';
        
        missionCard.innerHTML = `
            <h4 style="margin: 0 0 10px 0; color: #8B4513;">${mission.name}</h4>
            <p style="margin: 0 0 10px 0; font-size: 0.9em;">${mission.description}</p>
            <div style="font-size: 0.9em; margin-bottom: 10px;">
                <div>要求资质: ${mission.requiredAptitude}</div>
                <div>耗时: ${formatTimes(mission.duration)}</div>
                <div>奖励: ${mission.reward.stones}灵石, ${mission.reward.exp}声望</div>
            </div>
            <button onclick="startMissionq('${mission.id}')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; width: 100%;">派遣弟子</button>
        `;
        
        missionContainer.appendChild(missionCard);
    });
    
    // 显示进行中的任务
    if (player.sect.missions.length === 0) {
        activeMissionContainer.innerHTML = '<p>当前没有进行中的任务</p>';
    } else {
        player.sect.missions.forEach(mission => {
            const missionItem = document.createElement('div');
            missionItem.style.marginBottom = '10px';
            missionItem.style.padding = '10px';
            missionItem.style.background = '#555';
            missionItem.style.borderRadius = '5px';
            
            const remaining = mission.startTime + mission.duration - Date.now();
            const progress = remaining > 0 ? 100 - (remaining / mission.duration * 100) : 100;
            
            missionItem.innerHTML = `
                <div style="display: flex; justify-content: space-between;">
                    <div>${mission.name}</div>
                    <div>${formatTimes(remaining > 0 ? remaining : 0)}</div>
                </div>
                <div style="height: 5px; background: #444; border-radius: 3px; margin-top: 5px;">
                    <div style="height: 100%; background: #8B4513; border-radius: 3px; width: ${progress}%;"></div>
                </div>
            `;
            
            activeMissionContainer.appendChild(missionItem);
        });
    }
}

// 开始任务
function startMissionq(missionId) {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    // 获取任务详情
    const missions = initSectMissions();
    const mission = missions.find(m => m.id === missionId);
    if (!mission) return;
    
    // 查找符合条件的空闲弟子
    const aptitudesOrder = { 'C': 1, 'B': 2, 'A': 3, 'S': 4, 'SS': 5, 'SSS': 6 };
    const requiredLevel = aptitudesOrder[mission.requiredAptitude];
    
    const availableMembers = player.sect.members.filter(member => 
        member.status === 'idle' && aptitudesOrder[member.aptitude] >= requiredLevel
    );
    
    if (availableMembers.length === 0) {
        logAction("没有符合条件的空闲弟子！", "error");
        return;
    }
    
    // 选择忠诚度最高的弟子
    availableMembers.sort((a, b) => b.loyalty - a.loyalty);
    const member = availableMembers[0];
    
    // 更新弟子状态
    member.status = 'onMission';
    
    // 添加任务
    player.sect.missions.push({
        id: missionId,
        name: mission.name,
        memberId: member.id,
        startTime: Date.now(),
        duration: mission.duration,
        reward: mission.reward
    });
 // 计算预计加成
    const loyaltyBonus = calculateLoyaltyBonus(member.loyalty);
    const bonusPercent = (loyaltyBonus * 100 - 100).toFixed(1);
    
    logAction(`派遣 ${member.name} 执行任务: ${mission.name} (预计忠诚度${loyaltyBonus >= 1 ? '+' : ''}${bonusPercent}%奖励)`, "success");
    updateSectUI();
    
    // 设置任务完成计时器
    setTimeout(() => completeMissionq(missionId), mission.duration);
}

function completeMissionq(missionId) {
    const missionIndex = player.sect.missions.findIndex(m => m.id === missionId);
    if (missionIndex === -1) return;
    
    const mission = player.sect.missions[missionIndex];
    const member = player.sect.members.find(m => m.id === mission.memberId);
    
    if (member) {
        // 恢复弟子状态
        member.status = 'idle';
        
      // 计算忠诚度加成/减成
        const loyaltyBonus = calculateLoyaltyBonus(member.loyalty);
        
        // 发放奖励（应用忠诚度加成）
        const stonesReward = Math.floor(mission.reward.stones * loyaltyBonus);
        const expReward = Math.floor(mission.reward.exp * loyaltyBonus);
        
        player.sect.spiritStones += stonesReward;
        player.sect.exp += expReward;
        
       if (mission.reward.itemChance && Math.random() < mission.reward.itemChance) {
            // 随机获得一种物品
            const items = ['primaryGem', 'advancedGem', 'rebornDan', 'cultivationPill'];
            const randomItem = items[Math.floor(Math.random() * items.length)];
            player.items[randomItem] = (player.items[randomItem] || 0) + 1;
            
            logAction(`${member.name}完成任务带回${getItemName(randomItem)}！(忠诚度加成: ${(loyaltyBonus * 100 - 100).toFixed(1)}%)`, "success");
        } else {
            logAction(`${member.name}完成任务，获得${stonesReward}灵石和${expReward}声望！(忠诚度加成: ${(loyaltyBonus * 100 - 100).toFixed(1)}%)`, "success");
        }
        // 根据忠诚度变化调整忠诚度
        // 高奖励会增加忠诚度，低奖励会减少忠诚度
        const loyaltyChange = Math.floor((loyaltyBonus - 1) * 5);
        member.loyalty += loyaltyChange;
        
        // 确保忠诚度在合理范围内
        if (member.loyalty < 0) member.loyalty = 0;
        if (member.loyalty > 100) member.loyalty = 100;
        
        if (loyaltyChange > 0) {
            logAction(`${member.name}的忠诚度提升了${loyaltyChange}点！`, "info");
        } else if (loyaltyChange < 0) {
            logAction(`${member.name}的忠诚度降低了${Math.abs(loyaltyChange)}点！`, "warning");
        }
        // 检查升级
        checkSectLevelUp();
        
        // 移除任务
        player.sect.missions.splice(missionIndex, 1);
        
        // 更新UI - 这会重新渲染成员列表，显示驱逐按钮
        updateSectUI();
    }
}
function calculateLoyaltyBonus(loyalty) {
    if (loyalty >= 50) {
        // 高于50忠诚度，每点增加1.5%奖励
        return 1 + (loyalty - 50) * 0.015;
    } else {
        // 低于50忠诚度，每点减少1.5%奖励
        return 1 - (50 - loyalty) * 0.015;
    }
}
// 检查宗门升级
function checkSectLevelUp() {
    const nextLevelExp = getNextLevelExp();
    if (player.sect.exp >= nextLevelExp) {
        player.sect.level++;
        player.sect.exp -= nextLevelExp;
        
        // 升级奖励
        player.sect.maxMembers += 2;
        player.sect.spiritStones += 500 * player.sect.level;
        
        logAction(`宗门升级至${player.sect.level}级！成员上限增加至${player.sect.maxMembers}`, "success");
    }
}

// 获取下一级所需经验
function getNextLevelExp() {
    return 1000 * Math.pow(1.5, player.sect.level - 1);
}

// 更新功法列表
function updateTechniqueList() {
    const container = document.getElementById('techniqueList');
    container.innerHTML = '';
    
    // 获取玩家所有功法
    const techniques = Object.keys(player.techniques).filter(t => t !== 'none');
    
    if (techniques.length === 0) {
        container.innerHTML = '<p>尚未习得任何功法</p>';
        return;
    }
    
    techniques.forEach(techId => {
        const techLevel = player.techniques[techId] || 1;
        const sectTechLevel = player.sect.techniques[techId] || 1;
        
        // 获取功法配置
        const techConfig = techniqueConfig[techId];
        const techName = techConfig ? techConfig.name : techId;
        
        // 计算当前加成效果
        const baseEffect = techConfig ? techConfig.effect : 0;
        const sectMultiplier = 1 + (sectTechLevel * 2); // 每级增加2倍效果
        const totalEffect = techLevel * baseEffect * sectMultiplier;
        
        // 格式化效果显示
        let effectDisplay = '';
        if (techConfig && techConfig.type) {
            switch (techConfig.type) {
                case 'health':
                    effectDisplay = `生命加成: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'attack':
                    effectDisplay = `攻击加成: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'critRate':
                    effectDisplay = `暴击率: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'critDamage':
                    effectDisplay = `爆伤加成: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'multiAttack':
                    effectDisplay = `连击次数: +${totalEffect.toFixed(1)}`;
                    break;
                default:
                    effectDisplay = `效果: +${(totalEffect * 100).toFixed(1)}%`;
            }
        }
        
        const techCard = document.createElement('div');
        techCard.className = 'tech-card';
        techCard.style.background = '#444';
        techCard.style.padding = '10px';
        techCard.style.borderRadius = '5px';
        
        techCard.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h4 style="margin: 0; color: #8B4513;">${techName}</h4>
                <div style="font-size: 0.9em;">宗门等级: ${sectTechLevel}</div>
            </div>
            <div style="margin: 10px 0; font-size: 0.9em;">
                <div>个人等级: ${techLevel}</div>
                <div>${effectDisplay}</div>
                <div>升级消耗: ${calculateUpgradeCost(techId).toFixed(0)}灵石</div>
            </div>
            <button onclick="upgradeTechnique('${techId}')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; width: 100%;">升级功法</button>
        `;
        
        container.appendChild(techCard);
    });
    

    
    // 更新一键升级成本
    document.getElementById('upgradeAllCost').textContent = calculateUpgradeAllCost().toFixed(0);
}

// 升级功法
function upgradeTechnique(techName) {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    const cost = calculateUpgradeCost(techName);
    if (player.sect.spiritStones < cost) {
        logAction(`灵石不足！需要 ${cost} 灵石`, "error");
        return;
    }
    
    // 消耗灵石
    player.sect.spiritStones -= cost;
    
    // 升级功法
    if (!player.sect.techniques[techName]) {
        player.sect.techniques[techName] = 1;
    } else {
        player.sect.techniques[techName]++;
    }
     
       

    logAction(`成功升级功法: ${techName} (当前宗门等级: ${player.sect.techniques[techName]})`, "success");
   updatePlayerBattleStats();
    updateSectUI();
}

// 计算功法升级成本
function calculateUpgradeCost(techName) {
    const currentLevel = player.sect.techniques[techName] || 0;
    return 100 * Math.pow(1.2, currentLevel);
}

// 一键升级所有功法
function upgradeAllTechniques() {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    const totalCost = calculateUpgradeAllCost();
    if (player.sect.spiritStones < totalCost) {
        logAction(`灵石不足！需要 ${totalCost} 灵石`, "error");
        return;
    }
    
    // 消耗灵石
    player.sect.spiritStones -= totalCost;
    
    // 升级所有功法
    Object.keys(player.techniques).forEach(techName => {
        if (techName !== 'none') {
            if (!player.sect.techniques[techName]) {
                player.sect.techniques[techName] = 1;
            } else {
                player.sect.techniques[techName]++;
            }
        }
    });
    
    logAction("成功一键升级所有功法！", "success");
   updatePlayerBattleStats();
    updateSectUI();
}

// 计算一键升级总成本
function calculateUpgradeAllCost() {
    let totalCost = 0;
    Object.keys(player.techniques).forEach(techName => {
        if (techName !== 'none') {
            totalCost += calculateUpgradeCost(techName);
        }
    });
    return totalCost;
}

// 修改宗门名称
function changeSectName() {
    const newName = document.getElementById('sectNameInput').value.trim();
    
    if (!newName) {
        logAction("宗门名称不能为空！", "error");
        return;
    }
    
    if (newName.length > 20) {
        logAction("宗门名称过长（最多20字符）！", "error");
        return;
    }
    
    player.sect.name = newName;
    logAction(`宗门名称已修改为: ${newName}`, "success");
    updateSectUI();
  updateSectNameDisplay();
}

// 解散宗门
function disbandSect() {
    if (!confirm("确定要解散宗门吗？将会失去所有宗门成员和等级！")) {
        return;
    }
    
    // 返还部分资源
    const refund = Math.floor(player.sect.spiritStones * 0.5);
    player.spiritStones += refund;
    
    // 重置宗门数据
    player.sect = {
        created: false,
        name: "",
        level: 0,
        exp: 0,
        spiritStones: 0,
        members: [],
        missions: [],
        techniques: {},
        creationTime: 0,
        maxMembers: 5
    };
    
    logAction(`宗门已解散，返还${refund}灵石`, "info");
    updateSectUI();
   updateSectNameDisplay();
}

// 辅助函数：格式化时间
function formatTimes(ms) {
    if (ms <= 0) return "已完成";
    
    const hours = Math.floor(ms / 3600000);
    const minutes = Math.floor((ms % 3600000) / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    
    return `${hours}小时 ${minutes}分钟 ${seconds}秒`;
}

// 辅助函数：获取物品名称
function getItemName(itemKey) {
    const names = {
        'superiorGem': '极品宝石',
        'baitCount': '鱼饵',
        'rebornDan': '洗髓丹',
        'companionKey': '伴侣钥匙'
    };
    return names[itemKey] || itemKey;
}

// 每秒检查任务完成情况
setInterval(() => {
    if (player.sect && player.sect.created) {
        player.sect.missions.forEach(mission => {
            if (Date.now() - mission.startTime >= mission.duration) {
                completeMissionq(mission.id);
            }
        });
    }
}, 1000);
// 夜店系统数据结构
const nightClubConfig = {
    staffTypes: [
        { id: 'waiter', name: '服务员', baseExp: 0.5, baseCoins: 0.2, expPerLevel: 0.1, coinsPerLevel: 0.05, baseCost: 10 },
        { id: 'guard', name: '保安', baseExp: 0.3, baseCoins: 0.1, expPerLevel: 0.05, coinsPerLevel: 0.03, baseCost: 8 },
        { id: 'dj', name: 'DJ师', baseExp: 1.0, baseCoins: 0.5, expPerLevel: 0.2, coinsPerLevel: 0.1, baseCost: 20 },
        { id: 'chef', name: '厨师', baseExp: 0.4, baseCoins: 0.3, expPerLevel: 0.08, coinsPerLevel: 0.07, baseCost: 15 },
        { id: 'hostess', name: '小妹', baseExp: 0.7, baseCoins: 0.4, expPerLevel: 0.15, coinsPerLevel: 0.08, baseCost: 18 }
    ],
    equipmentTypes: [
        { id: 'sound', name: '音响系统', baseBonus: 1.05, bonusPerLevel: 0.05, baseCost: 50 },
        { id: 'light', name: '灯光系统', baseBonus: 1.03, bonusPerLevel: 0.03, baseCost: 40 },
        { id: 'bar', name: '吧台', baseBonus: 1.02, bonusPerLevel: 0.02, baseCost: 30 },
        { id: 'dancefloor', name: '舞池', baseBonus: 1.04, bonusPerLevel: 0.04, baseCost: 45 }
    ],
    vipConfig: {
        baseInterval: 30, // 分钟
        baseExp: 50,
        baseCoins: 25,
        levelMultiplier: 1.1
    },
    events: [
        { 
            name: "周末狂欢夜", 
            description: "激情音乐、炫酷灯光，打造周末不眠之夜！吸引大量年轻顾客涌入，现场气氛火爆。收益：经验获取速度3倍！", 
            effect: { expMultiplier: 3.0, duration: 60 },
            cost: 100 
        },
        { 
            name: "啤酒狂欢节", 
            description: "精选全球特色啤酒买一送一，搭配德式香肠拼盘，带来纯正欧陆风情体验。收益：金币收益提升50%！", 
            effect: { coinsMultiplier: 1.5, duration: 45 },
            cost: 75 
        },
     { 
            name: "闫闫魅惑之夜", 
            description: "国际超模闫闫领衔内衣大秀，水晶舞台搭配梦幻泡泡机，打造视觉盛宴。收益：金币收益暴涨400%！", 
            effect: { coinsMultiplier: 5.0, duration: 30 },
            cost: 100 
        },
      { 
            name: "茶茶烈焰舞台", 
            description: "亚洲舞后茶茶带来全新编舞，钢管舞与灯光艺术完美融合，限定特调鸡尾酒同步上市。收益：金币收益提升150%！", 
            effect: { coinsMultiplier: 2.5, duration: 30 },
            cost: 50 
        },
    { 
            name: "午夜折扣狂欢", 
            description: "零点后所有酒水买二送一，深夜食堂特色小食买一送一，打造深夜聚会圣地。收益：金币收益提升80%！", 
            effect: { coinsMultiplier: 1.8, duration: 40 },
            cost: 70 
        },
    { 
            name: "电音风暴派对", 
            description: "国际知名DJ现场打碟，激光矩阵与干冰特效，配备专业舞池震动装置。收益：经验获取7.5倍！", 
            effect: { expMultiplier: 7.5, duration: 30 },
            cost: 100 
        },
   { 
            name: "威士忌品鉴会", 
            description: "精选单一麦芽威士忌五折畅饮，配雪茄套餐，专业品酒师现场讲解。收益：金币收益提升120%！", 
            effect: { coinsMultiplier: 2.2, duration: 35 },
            cost: 50 
        },
      { 
            name: "泳池派对季", 
            description: "屋顶泳池派对限时开放，比基尼时装秀、水上飞人表演，特调热带鸡尾酒无限供应。收益：金币收益提升200%！", 
            effect: { coinsMultiplier: 3.0, duration: 40 },
            cost: 100 
        },
      { 
            name: "精英商务酒会", 
            description: "高端雪茄吧限时开放，陈年干邑买一送一，配备私人管家服务。收益：金币收益提升180%！", 
            effect: { coinsMultiplier: 2.8, duration: 35 },
            cost: 50 
        },
      { 
            name: "校园青春派对", 
            description: "学生证专属优惠，廉价啤酒畅饮套餐，街机游戏区免费开放。收益：经验获取3.2倍！", 
            effect: { expMultiplier: 3.2, duration: 55 },
            cost: 50 
        },
     { 
            name: "极光梦幻之夜", 
            description: "全息极光投影覆盖整个场馆，搭配空灵电子音乐，打造迷幻视觉盛宴。收益：经验获取7.2倍+金币收益2.8倍！", 
            effect: { expMultiplier: 7.2, coinsMultiplier: 2.8, duration: 35 },
            cost: 150 
        },
     { 
            name: "拳王争霸观赛", 
            description: "大型投影直播拳击赛事，拳击台造型卡座，能量饮料无限供应。收益：经验获取3.3倍！", 
            effect: { expMultiplier: 3.3, duration: 45 },
            cost: 60 
        },
     { 
            name: "黑色礼服之夜", 
            description: "正式着装限定派对， 茶茶在喷泉里洗澡，交响乐团现场演奏。收益：金币收益提升220%！", 
            effect: { coinsMultiplier: 3.2, duration: 40 },
            cost: 100 
        },
     { 
            name: "热带雨林探险", 
            description: "真实植物墙与人工瀑布，丛林动物音效，特色热带鸡尾酒。收益：经验获取5.7倍+金币收益1.9倍！", 
            effect: { expMultiplier: 5.7, coinsMultiplier: 1.9, duration: 55 },
            cost: 100 
        },
      { 
            name: "魔术大师秀", 
            description: "国际魔术冠军近距离表演，神秘道具展示，魔术主题特饮。收益：金币收益提升190%！", 
            effect: { coinsMultiplier: 2.9, duration: 35 },
            cost: 100 
        },
      { 
            name: "啤酒花园节", 
            description: "露天花园派对，30种精酿啤酒品尝，德式烤肠与pretzel。收益：经验获取5.0倍！", 
            effect: { expMultiplier: 5.0, duration: 60 },
            cost: 50 
        },
      { 
            name: "1920黄金时代", 
            description: "盖茨比风格派对，女郎表演，古董车展示。收益：金币收益提升240%！", 
            effect: { coinsMultiplier: 3.4, duration: 30 },
            cost: 60 
        },
       { 
            name: "高空露台电影", 
            description: "屋顶露天电影院，经典电影放映，懒人沙发与毛毯服务。收益：经验获取2.5倍！", 
            effect: { expMultiplier: 2.5, duration: 60 },
            cost: 40 
        },
       { 
            name: "龙舌兰日出", 
            description: "墨西哥主题派对，龙舌兰shot免费续杯，墨西哥卷饼自助。收益：金币收益提升170%！", 
            effect: { coinsMultiplier: 2.7, duration: 45 },
            cost: 100 
        },
      { 
            name: "科幻赛博朋克夜", 
            description: "赛博朋克未来风装饰，VR游戏体验，发光鸡尾酒。收益：经验获取6.8倍+金币收益2.5倍！", 
            effect: { expMultiplier: 6.8, coinsMultiplier: 2.5, duration: 40 },
            cost: 150 
        },
      { 
            name: "葡萄酒庄之旅", 
            description: "纳帕谷葡萄酒品尝，奶酪拼盘无限续，品酒师讲座。收益：金币收益提升210%！", 
            effect: { coinsMultiplier: 3.1, duration: 40 },
            cost: 50 
        },
      { 
            name: "卡拉OK冠军赛", 
            description: "专业级KTV设备，歌唱比赛有奖竞猜，气泡酒免费续杯。收益：经验获取3.9倍！", 
            effect: { expMultiplier: 3.9, duration: 60 },
            cost: 60 
        },
      { 
            name: "白色派对庆典", 
            description: "全白着装主题派对，泡沫机与雪花特效，冰雕vodka吧台。收益：金币收益提升190%！", 
            effect: { coinsMultiplier: 2.9, duration: 45 },
            cost: 100 
        },
      { 
            name: "密室逃脱之夜", 
            description: "真人密室游戏联动，线索收集换优惠，神秘特调隐藏菜单。收益：经验获取4.3倍！", 
            effect: { expMultiplier: 4.3, duration: 60 },
            cost: 70 
        },
       { 
            name: "生蚝生鲜吧", 
            description: "空运新鲜生蚝半价，专业开蚝师表演，白葡萄酒搭配。收益：金币收益提升130%！", 
            effect: { coinsMultiplier: 2.3, duration: 30 },
            cost: 60 
        },
      { 
            name: "哈利波特魔法夜", 
            description: "分院帽体验，黄油啤酒特供，魔杖决斗大赛。收益：经验获取6.0倍！", 
            effect: { expMultiplier: 6.0, duration: 30 },
            cost: 200 
        },
        { 
            name: "夏日冲浪派对", 
            description: "人工波浪机体验，比基尼时装秀，热带水果鸡尾酒。收益：金币收益提升180%！", 
            effect: { coinsMultiplier: 2.8, duration: 30 },
            cost: 70 
        },
     { 
            name: "爵士灵魂之夜", 
            description: "蓝调爵士乐队演出，复古唱片点播，经典马提尼。收益：经验获取4.8倍+金币收益2.1倍！", 
            effect: { expMultiplier: 4.8, coinsMultiplier: 2.1, duration: 50 },
            cost: 200 
        },
     { 
            name: "万圣惊魂夜", 
            description: "恐怖主题装饰，化妆比赛，限量血袋鸡尾酒。收益：金币收益提升140%！", 
            effect: { coinsMultiplier: 2.4, duration: 50 },
            cost: 80 
        },
       { 
            name: "威士忌收藏家", 
            description: "稀有威士忌品尝，雪茄套餐买一送一，专家讲解。收益：金币收益提升250%！", 
            effect: { coinsMultiplier: 3.5, duration: 30 },
            cost: 120 
        },
      { 
            name: "电子竞技联赛", 
            description: "大型赛事直播，电竞椅专属区，游戏主题特饮。收益：经验获取4.4倍！", 
            effect: { expMultiplier: 4.4, duration: 50 },
            cost: 150 
        },
     { 
            name: "极限运动嘉年华", 
            description: "室内滑板表演区，攀岩墙挑战，能量饮料赞助与运动明星见面会。收益：经验获取5.9倍+金币收益2.4倍！", 
            effect: { expMultiplier: 5.9, coinsMultiplier: 2.4, duration: 45 },
            cost: 200 
        },
     { 
            name: "白色情人节", 
            description: "浪漫装饰，情侣套餐买一送一，玫瑰花瓣雨。收益：金币收益提升230%！", 
            effect: { coinsMultiplier: 3.3, duration: 30 },
            cost: 70 
        },
       { 
            name: "睡衣派对", 
            description: "舒适睡衣主题，床头鸡尾酒，枕头大战区。收益：经验获取3.3倍！", 
            effect: { expMultiplier: 3.3, duration: 40 },
            cost: 50 
        },
        { 
            name: "黑金会员专属", 
            description: "会员专属通道，稀有威士忌品尝，手工雪茄免费派送。收益：金币收益提升260%！", 
            effect: { coinsMultiplier: 3.6, duration: 30 },
            cost: 100 
        },
       { 
            name: "夏威夷草裙舞", 
            description: "草裙舞表演教学，鲜花项链迎宾，热带水果鸡尾酒。收益：金币收益提升70%！", 
            effect: { coinsMultiplier: 1.7, duration: 30 },
            cost: 60 
        },
        { 
            name: "午夜拉面食堂", 
            description: "日式拉面宵夜，清酒买一送一，午夜限定菜单。收益：金币收益提升110%！", 
            effect: { coinsMultiplier: 2.1, duration: 30 },
            cost: 70 
        },
      { 
            name: "终极单身派对", 
            description: "速配游戏活动，爱情灵药特调，约会基金抽奖。收益：金币收益提升350%！", 
            effect: { coinsMultiplier: 4.5, duration: 30 },
            cost: 100 
        },
       { 
            name: "复古迪斯科之夜", 
            description: "70年代复古装扮派对，disco球与霓虹灯装饰，经典老歌串烧狂欢。收益：经验1.8倍+金币1.6倍！", 
            effect: { expMultiplier: 1.8, coinsMultiplier: 1.6, duration: 45 },
            cost: 150 
        },
        { 
            name: "巨星闪耀夜", 
            description: "特邀顶流明星驻场表演，红毯入场仪式+签名合影环节，钻石香槟塔无限供应。收益：经验获取4倍+金币收益2倍！", 
            effect: { expMultiplier: 4.0, coinsMultiplier: 2.0, duration: 30 },
            cost: 200 
        }
    ],
    levelExpRequirements: [200, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000, 50000000, 100000000]
};

// 初始化夜店系统
function initNightClubSystem() {
    if (!player.nightClub) {
        player.nightClub = {
            level: 1,
            exp: 0,
            starCoins: 0,
            staff: nightClubConfig.staffTypes.map(type => ({
                type: type.id,
                level: 1,
                expOutput: type.baseExp,
                coinsOutput: type.baseCoins
            })),
            equipment: nightClubConfig.equipmentTypes.map(type => ({
                type: type.id,
                level: 1,
                bonus: type.baseBonus
            })),
            vip: {
                lastVisit: 0,
                nextVisit: 0
            },
            activeEvent: null,
            lastUpdate: Date.now()
        };
    }
}

// 切换夜店系统界面
function toggleNightClubSystem() {
      if (player.reincarnationCount < 600) {
        alert("需要达到600转才能开启夜店系统！");
        return;
    }
    const overlay = document.getElementById('nightClubOverlay');
    const ui = document.getElementById('nightClubUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initNightClubSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        openNightClubTab('staff');
        updateNightClubUI();
    }
}

// 切换标签页
function openNightClubTab(tabName) {
    // 隐藏所有标签内容
    const tabcontents = document.getElementsByClassName('nightclub-tabcontent');
    for (let i = 0; i < tabcontents.length; i++) {
        tabcontents[i].style.display = 'none';
    }
    
    // 移除所有标签的活动状态
    const tablinks = document.getElementsByClassName('tablink');
    for (let i = 0; i < tablinks.length; i++) {
        tablinks[i].classList.remove('active');
    }
    
    // 显示当前标签内容并添加活动类
    document.getElementById('nightClub' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).style.display = 'block';
    event.currentTarget.classList.add('active');
    
    // 更新标签内容
    if (tabName === 'staff') {
        updateStaffTab();
    } else if (tabName === 'equipment') {
        updateEquipmentTab();
    } else if (tabName === 'special') {
        updateSpecialTab();
    } else if (tabName === 'events') {
        updateEventsTab();
    }
}

// 更新夜店系统UI
function updateNightClubUI() {
    // 更新店铺信息
    document.getElementById('nightClubLevel').textContent = player.nightClub.level;
    document.getElementById('nightClubExp').textContent = player.nightClub.exp.toFixed(1);
    
    const nextLevelExp = nightClubConfig.levelExpRequirements[player.nightClub.level - 1] || 
                         nightClubConfig.levelExpRequirements[nightClubConfig.levelExpRequirements.length - 1];
    document.getElementById('nightClubExpNext').textContent = nextLevelExp;
    
    const expPercent = Math.min(100, (player.nightClub.exp / nextLevelExp) * 100);
    document.getElementById('nightClubExpBar').style.width = expPercent + '%';
    
    document.getElementById('starCoinCount').textContent = player.nightClub.starCoins.toFixed(1);
    

    // 计算每分钟收益
    let totalExpPerMin = 0;
    let totalCoinsPerMin = 0;
    
    // 店员收益
    player.nightClub.staff.forEach(staff => {
        totalExpPerMin += staff.expOutput;
        totalCoinsPerMin += staff.coinsOutput;
    });
    
    // 设备加成
    let bonusMultiplier = 1;
    player.nightClub.equipment.forEach(eq => {
        bonusMultiplier *= eq.bonus;
    });
    
    // 活动加成
    if (player.nightClub.activeEvent) {
        if (player.nightClub.activeEvent.effect.expMultiplier) {
            totalExpPerMin *= player.nightClub.activeEvent.effect.expMultiplier;
        }
        if (player.nightClub.activeEvent.effect.coinsMultiplier) {
            totalCoinsPerMin *= player.nightClub.activeEvent.effect.coinsMultiplier;
        }
    }
    
    totalExpPerMin *= bonusMultiplier;
    totalCoinsPerMin *= bonusMultiplier;
    
    document.getElementById('expPerMinuteq').textContent = totalExpPerMin.toFixed(2);
    document.getElementById('coinsPerMinute').textContent = totalCoinsPerMin.toFixed(2);
}

// 更新店员标签页
function updateStaffTab() {
    const container = document.getElementById('nightClubStaff');
    container.innerHTML = '';
    
    player.nightClub.staff.forEach(staff => {
        const config = nightClubConfig.staffTypes.find(t => t.id === staff.type);
        const cost = calculateStaffUpgradeCost(staff.type);
        
        container.innerHTML += `
            <div class="staff-card" style="background: #222; border-radius: 8px; padding: 15px; border: 1px solid #444;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 style="margin: 0; color: #9C27B0;">${config.name}</h3>
                    <span>Lv.${staff.level}</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <div>经验产出: ${staff.expOutput.toFixed(3)}/分钟</div>
                    <div>星币产出: ${staff.coinsOutput.toFixed(3)}/分钟</div>
                </div>
                <button onclick="upgradeStaff('${staff.type}')" 
                        style="width: 100%; background: ${player.nightClub.starCoins >= cost ? '#4CAF50' : '#f44336'}; 
                               color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;"
                        ${player.nightClub.starCoins < cost ? 'disabled' : ''}>
                    升级 (${cost}星币)
                </button>
            </div>
        `;
    });
}

// 计算店员升级成本
function calculateStaffUpgradeCost(staffType) {
    const staff = player.nightClub.staff.find(s => s.type === staffType);
    const config = nightClubConfig.staffTypes.find(t => t.id === staffType);
    return Math.floor(config.baseCost * Math.pow(1.5, staff.level - 1));
}

// 升级店员
function upgradeStaff(staffType) {
    const staff = player.nightClub.staff.find(s => s.type === staffType);
    const config = nightClubConfig.staffTypes.find(t => t.id === staffType);
    const cost = calculateStaffUpgradeCost(staffType);
    
    if (player.nightClub.starCoins < cost) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= cost;
    staff.level++;
    staff.expOutput = config.baseExp + (config.expPerLevel * (staff.level - 1));
    staff.coinsOutput = config.baseCoins + (config.coinsPerLevel * (staff.level - 1));
    
    logAction(`${config.name}升级到Lv.${staff.level}！`, "success");
    updateNightClubUI();
    updateStaffTab();
}

// 更新设备标签页
function updateEquipmentTab() {
    const container = document.getElementById('nightClubEquipment');
    container.innerHTML = '';
    
    player.nightClub.equipment.forEach(eq => {
        const config = nightClubConfig.equipmentTypes.find(t => t.id === eq.type);
        const cost = calculateEquipmentUpgradeCost(eq.type);
        
        container.innerHTML += `
            <div class="equipment-card" style="background: #222; border-radius: 8px; padding: 15px; border: 1px solid #444;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 style="margin: 0; color: #9C27B0;">${config.name}</h3>
                    <span>Lv.${eq.level}</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <div>全局加成: ${(eq.bonus * 100 - 100).toFixed(1)}%</div>
                </div>
                <button onclick="upgradeEquipment('${eq.type}')" 
                        style="width: 100%; background: ${player.nightClub.starCoins >= cost ? '#4CAF50' : '#f44336'}; 
                               color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;"
                        ${player.nightClub.starCoins < cost ? 'disabled' : ''}>
                    升级 (${cost}星币)
                </button>
            </div>
        `;
    });
}

// 计算设备升级成本
function calculateEquipmentUpgradeCost(eqType) {
    const eq = player.nightClub.equipment.find(e => e.type === eqType);
    const config = nightClubConfig.equipmentTypes.find(t => t.id === eqType);
    return Math.floor(config.baseCost * Math.pow(1.8, eq.level - 1));
}

// 升级设备
function upgradeEquipment(eqType) {
    const eq = player.nightClub.equipment.find(e => e.type === eqType);
    const config = nightClubConfig.equipmentTypes.find(t => t.id === eqType);
    const cost = calculateEquipmentUpgradeCost(eqType);
    
    if (player.nightClub.starCoins < cost) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= cost;
    eq.level++;
    eq.bonus = config.baseBonus + (config.bonusPerLevel * (eq.level - 1));
    
    logAction(`${config.name}升级到Lv.${eq.level}！`, "success");
    updateNightClubUI();
    updateEquipmentTab();
}

// 更新特殊人群标签页
function updateSpecialTab() {
    const container = document.getElementById('nightClubSpecial');
    const vipInfo = document.getElementById('vipInfo');
    
    // 计算VIP下次到访时间
    const now = Date.now();
    const timeSinceLastVisit = (now - player.nightClub.vip.lastVisit) / (1000 * 60); // 分钟
    const timeUntilNextVisit = Math.max(0, player.nightClub.vip.nextVisit - now);
    
    vipInfo.innerHTML = `
        <div style="margin-bottom: 10px;">
            <strong>下次VIP到访:</strong> 
            ${timeUntilNextVisit > 0 ? 
                `<span id="vipTimer">${formatTime(timeUntilNextVisit)}</span>` : 
                "VIP随时可能光临！"}
        </div>
    `;
    
    // 如果VIP即将到来，启动计时器
    if (timeUntilNextVisit > 0) {
        startVipTimer();
    }
}

// 格式化时间
function formatTime(ms) {
    const minutes = Math.floor(ms / (1000 * 60));
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    return `${minutes}分${seconds}秒`;
}

// 启动VIP计时器
function startVipTimer() {
    if (window.vipTimer) clearInterval(window.vipTimer);
    
    window.vipTimer = setInterval(() => {
        const now = Date.now();
        const timeUntilNextVisit = Math.max(0, player.nightClub.vip.nextVisit - now);
        
        if (timeUntilNextVisit <= 0) {
            clearInterval(window.vipTimer);
            document.getElementById('vipTimer').textContent = "VIP已到达！";
            triggerVipVisit();
        } else {
            document.getElementById('vipTimer').textContent = formatTime(timeUntilNextVisit);
        }
    }, 1000);
}

// 触发VIP访问
function triggerVipVisit() {
    const baseExp = nightClubConfig.vipConfig.baseExp;
    const baseCoins = nightClubConfig.vipConfig.baseCoins;
    const multiplier = Math.pow(nightClubConfig.vipConfig.levelMultiplier, player.nightClub.level - 1);
    
    const expGain = Math.floor(baseExp * multiplier);
    const coinsGain = Math.floor(baseCoins * multiplier);
    
    player.nightClub.exp += expGain;
    player.nightClub.starCoins += coinsGain;
    
    // 设置下次访问时间
    const now = Date.now();
    player.nightClub.vip.lastVisit = now;
    player.nightClub.vip.nextVisit = now + (nightClubConfig.vipConfig.baseInterval * 60 * 1000);
    
    logAction(`VIP光临！获得${expGain}经验和${coinsGain}星币！`, "success");
    updateNightClubUI();
    updateSpecialTab();
    checkNightClubLevelUp();
}

// 更新事件标签页
function updateEventsTab() {
    const container = document.getElementById('nightClubEvents');
    const currentEventDiv = document.getElementById('currentEvent');
    
    if (player.nightClub.activeEvent) {
        const timeLeft = Math.max(0, player.nightClub.activeEvent.endTime - Date.now());
        currentEventDiv.innerHTML = `
            <div style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <h4 style="margin-top: 0; color: #FFD700;">${player.nightClub.activeEvent.name}</h4>
                <p>${player.nightClub.activeEvent.description}</p>
                <div>剩余时间: ${formatTime(timeLeft)}</div>
            </div>
        `;
    } else {
        currentEventDiv.innerHTML = "<p>当前没有活跃事件</p>";
    }
}

// 触发随机事件
function triggerRandomEventa() {
    if (player.nightClub.activeEvent) {
        logAction("当前已有活跃事件！", "error");
        return;
    }
    
    const randomEvent = nightClubConfig.events[Math.floor(Math.random() * nightClubConfig.events.length)];
    
    if (player.nightClub.starCoins < randomEvent.cost) {
        logAction(`星币不足！需要${randomEvent.cost}星币`, "error");
        return;
    }
    
    player.nightClub.starCoins -= randomEvent.cost;
    player.nightClub.activeEvent = {
        name: randomEvent.name,
        description: randomEvent.description,
        effect: randomEvent.effect,
        startTime: Date.now(),
        endTime: Date.now() + (randomEvent.effect.duration * 60 * 1000)
    };
    
    logAction(`已启动事件: ${randomEvent.name}！`, "success");
    updateNightClubUI();
    updateEventsTab();
}

// 检查店铺升级
function checkNightClubLevelUp() {
    const nextLevelExp = nightClubConfig.levelExpRequirements[player.nightClub.level - 1];
    
    if (player.nightClub.exp >= nextLevelExp && player.nightClub.level < nightClubConfig.levelExpRequirements.length) {
        player.nightClub.level++;
        player.nightClub.exp -= nextLevelExp;
        logAction(`店铺升级到Lv.${player.nightClub.level}！`, "success");
        updateNightClubUI();
    }
}

// 每分钟计算夜店收益
function calculateNightClubIncome() {
    if (!player.nightClub) return;
    
    const now = Date.now();
    const elapsedMinutes = (now - player.nightClub.lastUpdate) / (1000 * 60);
    
    if (elapsedMinutes < 1) return;
    
    let totalExp = 0;
    let totalCoins = 0;
    
    // 计算店员收益
    player.nightClub.staff.forEach(staff => {
        totalExp += staff.expOutput * elapsedMinutes;
        totalCoins += staff.coinsOutput * elapsedMinutes;
    });
    
    // 应用设备加成
    let bonusMultiplier = 1;
    player.nightClub.equipment.forEach(eq => {
        bonusMultiplier *= eq.bonus;
    });
    
    // 应用活动加成
    if (player.nightClub.activeEvent) {
        if (player.nightClub.activeEvent.effect.expMultiplier) {
            totalExp *= player.nightClub.activeEvent.effect.expMultiplier;
        }
        if (player.nightClub.activeEvent.effect.coinsMultiplier) {
            totalCoins *= player.nightClub.activeEvent.effect.coinsMultiplier;
        }
        
        // 检查事件是否结束
        if (now > player.nightClub.activeEvent.endTime) {
            logAction(`事件"${player.nightClub.activeEvent.name}"已结束`, "info");
            player.nightClub.activeEvent = null;
        }
    }
    
    totalExp *= bonusMultiplier;
    totalCoins *= bonusMultiplier;
    
    player.nightClub.exp += totalExp;
    player.nightClub.starCoins += totalCoins;
    player.nightClub.lastUpdate = now;
    
    // 检查VIP访问
    if (now > player.nightClub.vip.nextVisit) {
        triggerVipVisit();
    }
    
    // 检查店铺升级
    checkNightClubLevelUp();
    
    // 更新UI（如果界面打开）
    if (document.getElementById('nightClubUI').style.display === 'block') {
        updateNightClubUI();
    }
}

// 杂货铺功能
function toggleGroceriesUI() {
if (player.reincarnationCount < 400) {
        alert("需要达到400转才能开启杂货铺！");
        return;
    }
    const ui = document.getElementById('groceriesUI');
    const overlay = document.getElementById('groceriesOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateGroceriesUI();
    }
}

function updateGroceriesUI() {
    // 更新星尘数量显示
    document.getElementById('currentStardust').textContent = player.exploration.resources.stardust;
}

function exchangeStardust(type) {
    const exchangeRates = {
        bait: { cost: 100, item: 'baitCount', amount: parseInt(document.getElementById('baitAmount').value), coinRate: 2 },
        key: { cost: 200, item: 'companionKey', amount: parseInt(document.getElementById('keyAmount').value) },
        rose: { cost: 100, item: 'rose', amount: parseInt(document.getElementById('roseAmount').value), coinRate: 20 },
        vip: { cost: 100, item: 'vipPower', amount: parseInt(document.getElementById('vipAmount').value), coinRate: 10 },
        gem: { cost: 5000, item: 'divineGem', amount: parseInt(document.getElementById('gemAmount').value) },
        root: { cost: 500, item: 'rootDetector', amount: parseInt(document.getElementById('rootAmount').value) },
        blood: { cost: 500, item: 'bloodlineDetector', amount: parseInt(document.getElementById('bloodAmount').value) },
        coin: { cost: 100, item: 'reincarnationCoin', amount: parseInt(document.getElementById('coinAmount').value), coinRate: 1000000 }
    };
    
    const config = exchangeRates[type];
    if (!config) return;
    
    // 输入验证
    if (isNaN(config.amount) || config.amount <= 0) {
        logAction("请输入有效的兑换数量！", "error");
        return;
    }
    
    const totalCost = config.cost * config.amount;
    const stardust = player.exploration.resources.stardust;
    
    if (stardust < totalCost) {
        logAction("星尘不足！", "error");
        return;
    }
    
    player.exploration.resources.stardust -= totalCost;
    
    // 修复点：所有带coinRate的物品都应用倍数
    const multiplier = config.coinRate || 1;
    const actualAmount = config.amount * multiplier;
    
    if (type === 'coin') {
        player[config.item] += actualAmount;
    } else {
        player.items[config.item] = (player.items[config.item] || 0) + actualAmount;
    }
    
    logAction(`成功兑换: ${actualAmount}${getItemName(type)}`, "success");
    updateGroceriesUI();
    updateDisplay();
    saveGame();
}

function getItemName(type) {
    const names = {
        bait: "鱼饵",
        key: "伴侣钥匙",
        rose: "玫瑰花",
        vip: "VIP能力值",
        gem: "神级宝石",
       root: "灵根检测器",
       blood: "血脉检测剂",
        coin: "转生币"
    };
    return names[type] || "物品";
}
// 切换等级系统界面
function toggleLevelSystem() {
   if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启玩家等级！");
        return;
    }
    const overlay = document.getElementById('levelSystemOverlay');
    const ui = document.getElementById('levelSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateLevelUI();
        updateDisplay();
    }
}
function ascendPlayer() {
    // 计算下次飞升所需等级
    const nextAscentionLevel = (player.level.ascentionCount + 1) * 100;
    
    // 检查是否满足飞升条件
    if (player.level.current < nextAscentionLevel) {
        logAction(`飞升需要等级${nextAscentionLevel}！当前等级${player.level.current}。`, "error");
        return;
    }
    
    // 执行飞升
    player.level.ascentionCount++;
    player.level.ascentionMultiplier =player.level.ascentionCount+1; // 属性加成
    player.level.current = 1; // 等级重置为1
    player.level.exp = 0;
    player.level.nextLevelExp = 10000;
    
    // 更新加成
    player.level.clickBonus = 1 * player.level.ascentionMultiplier* player.level.ascentionMultipliera;
    player.level.gpsBonus = 1 * player.level.ascentionMultiplier* player.level.ascentionMultipliera;
    
    logAction(`飞升成功！当前飞升次数：${player.level.ascentionCount}，加成倍数：${player.level.ascentionMultiplier}`, "success");
    updateLevelUI();
    updateDisplay();
}
function ascendPlayera() {
    // 计算下次轮回所需等级
    const nextAscentionLevela = (player.level.ascentionCounta + 1) * 10;
    
    // 检查是否满足轮回条件
    if (player.level.ascentionCount < nextAscentionLevela) {
        logAction(`轮回需要飞升次数${nextAscentionLevela}！当前飞升次数${player.level.ascentionCounta}。`, "error");
        return;
    }
    
    // 执行飞升
    player.level.ascentionCounta++;
    player.level.ascentionMultipliera =player.level.ascentionCounta*2; // 属性加成
    player.level.current = 1; // 等级重置为1
    player.level.ascentionCount= 0;
    player.level.ascentionMultiplier= 1;
    player.level.exp = 0;
    player.level.nextLevelExp = 10000;
    
    // 更新加成
    player.level.clickBonus = 1 * player.level.ascentionMultiplier* player.level.ascentionMultipliera;
    player.level.gpsBonus = 1 * player.level.ascentionMultiplier* player.level.ascentionMultipliera;
    
    logAction(`飞升成功！当前轮回次数：${player.level.ascentionCounta}，加成倍数：${player.level.ascentionMultipliera}`, "success");
    updateLevelUI();
    updateDisplay();
}
// 更新等级界面
function updateLevelUI() {
    document.getElementById('currentPlayerLevel').textContent = player.level.current;
    document.getElementById('currentPlayerExp').textContent = player.level.exp;
    document.getElementById('nextLevelExpq').textContent = player.level.nextLevelExp;
    document.getElementById('clickBonus').textContent = player.level.clickBonus.toFixed(0) + '倍';
    document.getElementById('gpsBonus').textContent =  player.level.gpsBonus.toFixed(0) + '倍';
     document.getElementById("ascentionCount").textContent = player.level.ascentionCount;
    document.getElementById("ascentionMultiplier").textContent = player.level.ascentionMultiplier + "倍";
    document.getElementById("nextAscentionRequirement").textContent = (player.level.ascentionCount + 1) * 100;
     document.getElementById("ascentionCounta").textContent = player.level.ascentionCounta;
    document.getElementById("ascentionMultipliera").textContent = player.level.ascentionMultipliera + "倍";
    document.getElementById("nextAscentionRequirementa").textContent = (player.level.ascentionCounta + 1) * 10;
    const progress = (player.level.exp / player.level.nextLevelExp) * 100;
    document.getElementById('playerExpProgress').style.width = progress + '%';
}

// 升级玩家等级
function upgradePlayerLevel(amount) {
    for (let i = 0; i < amount; i++) {
        if (player.level.exp >= player.level.nextLevelExp) {
            player.level.exp -= player.level.nextLevelExp;
            player.level.current++;
            
            // 计算下一级所需经验
            player.level.nextLevelExp = (10000 * player.level.current) * (1+player.level.ascentionCounta*2) ;
            
            // 计算加成，考虑飞升倍数
            player.level.clickBonus = player.level.current * 1 * player.level.ascentionMultiplier * player.level.ascentionMultipliera;
            player.level.gpsBonus = player.level.current * 1 * player.level.ascentionMultiplier * player.level.ascentionMultipliera;
            
            logAction(`玩家等级提升至 ${player.level.current}级！`, 'success');
             // 检查轮回条件
            const nextAscentionLevela = (player.level.ascentionCounta + 1) * 10;
            if (player.level.ascentionCounta === nextAscentionLevela) {
                logAction(`已达到第${player.level.ascentionCounta + 1}次轮回条件，可进行轮回！`, 'info');
            }
            // 检查飞升条件
            const nextAscentionLevel = (player.level.ascentionCount + 1) * 100;
            if (player.level.current === nextAscentionLevel) {
                logAction(`已达到第${player.level.ascentionCount + 1}次飞升条件，可进行飞升！`, 'info');
            }
        } else {
            logAction("经验不足，无法升级！", "error");
            break;
        }
    }
    updateLevelUI();
    updateDisplay();
}

// 添加经验
function addPlayerExp(amount) {
    player.level.exp += amount;
    
    // 检查是否可以升级
    while (player.level.exp >= player.level.nextLevelExp) {
        upgradePlayerLevel(1);
    }
    
    updateLevelUI();
}
// 翅膀品阶配置
const wingRarities = {
    "劣质级": { healthRange: [0.01, 0.20], color: "gray", namePrefix: "破损的" },
    "普通级": { healthRange: [0.10, 0.50], color: "white", namePrefix: "普通的" },
    "优秀级": { healthRange: [0.15, 1.00], color: "green", namePrefix: "优秀的" },
    "精良级": { healthRange: [0.20, 2.00], color: "blue", namePrefix: "精良的" },
    "卓越级": { healthRange: [0.30, 3.00], color: "purple", namePrefix: "卓越的" },
    "史诗级": { healthRange: [0.50, 4.00], color: "gold", namePrefix: "史诗的" },
    "传说级": { healthRange: [1.00, 5.00], color: "orange", namePrefix: "传说的" },
    "神圣级": { healthRange: [1.00, 7.00], color: "pink", namePrefix: "神圣的" },
    "不朽级": { healthRange: [2.00, 10.00], color: "red", namePrefix: "不朽的" }
};

// 翅膀名字词库
const wingNameParts = {
    prefixes: ["暗影", "光明", "烈焰", "冰霜", "雷霆", "风暴", "星辰", "月光", "太阳", "虚空", "黑暗", "邪恶", "未来", "米白色"],
    suffixes: ["之翼", "翅膀", "羽翼", "飞翼", "光翼", "暗翼", "龙翼", "凤翼", "天使翼", "恶魔翼", "神翼", "魔翼", "背包", "飞艇"]
};

// 次元掉落概率配置
const wingDropRates = {
    2: { // 次元2
        "劣质级": 0.9,
        "普通级": 0.09,
        "优秀级": 0.01
    },
    3: { // 次元3
        "劣质级": 0.6,
        "普通级": 0.3,
        "优秀级": 0.07,
        "精良级": 0.02,
        "卓越级": 0.01
    },
    4: { // 次元4
        "优秀级": 0.56,
        "精良级": 0.3,
        "卓越级": 0.1,
        "史诗级": 0.03,
        "传说级": 0.01
    },
    5: { // 次元5
        "精良级": 0.5,
        "卓越级": 0.3,
        "史诗级": 0.14,
        "传说级": 0.05,
        "神圣级": 0.009,
        "不朽级": 0.001
    }
};
// 切换翅膀系统界面
function toggleWingSystem() {
    if (player.level.ascentionCounta < 1) {
        alert("需要达到轮回1转才能开启翅膀系统！");
        return;
    }
    const overlay = document.getElementById('wingSystemOverlay');
    const ui = document.getElementById('wingSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateWingUI();
    }
}

// 生成随机翅膀名字
function generateWingName(rarity) {
    const prefix = wingNameParts.prefixes[Math.floor(Math.random() * wingNameParts.prefixes.length)];
    const suffix = wingNameParts.suffixes[Math.floor(Math.random() * wingNameParts.suffixes.length)];
    return wingRarities[rarity].namePrefix + prefix + suffix;
}

// 生成随机翅膀
function generateRandomWing(dimensionLevel) {
    if (dimensionLevel === 1) return null; // 次元1不掉落翅膀
    
    const dropRates = wingDropRates[dimensionLevel];
    if (!dropRates) return null;
    
    // 根据概率随机选择品阶
    let rand = Math.random();
    let cumulativeProb = 0;
    
    for (const [rarity, prob] of Object.entries(dropRates)) {
        cumulativeProb += prob;
        if (rand < cumulativeProb) {
            const rarityConfig = wingRarities[rarity];
            const healthBonus = Math.random() * (rarityConfig.healthRange[1] - rarityConfig.healthRange[0]) + rarityConfig.healthRange[0];
            
            return {
                id: 'wing_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                name: generateWingName(rarity),
                rarity: rarity,
                healthBonus: healthBonus,
                color: rarityConfig.color,
               locked: false
            };
        }
    }
    
    return null;
}
function toggleWingLock(wingId) {
    const wing = player.wings.inventory.find(w => w.id === wingId);
    if (wing) {
        wing.locked = !wing.locked;
        const action = wing.locked ? "锁定" : "解锁";
        logAction(`${action}了翅膀：${wing.name}`, 'success');
        updateWingUI();
    }
}
// 掉落翅膀（在世界地图怪物死亡时调用）
function dropWing() {
    const dimensionLevel = player.dimensionLevel;
    if (dimensionLevel === 1) return; // 次元1不掉落
    
    if (Math.random() < 0.01) { // 1%掉落几率
        const newWing = generateRandomWing(dimensionLevel);
        if (newWing) {
            player.wings.inventory.push(newWing);
            logAction(`获得翅膀：${newWing.name}（${newWing.rarity}）`, 'success');
            updateWingUI();
        }
    }
}
// 装备翅膀
function equipWing(wingId) {
    const wing = player.wings.inventory.find(w => w.id === wingId);
    if (wing) {
        player.wings.equipped = wingId;
        logAction(`装备了翅膀：${wing.name}`, 'success');
        updateWingUI();
        updatePlayerBattleStats(); // 更新玩家属性
    }
}

// 卸下翅膀
function unequipWing() {
    player.wings.equipped = null;
    logAction("已卸下翅膀", 'info');
    updateWingUI();
    updatePlayerBattleStats();
}
// 当前筛选条件
let currentWingFilter = 'all';

// 筛选翅膀
function filterWings() {
    currentWingFilter = document.getElementById('wingRarityFilter').value;
    updateWingUI();
}

// 一键分解当前筛选条件下的所有翅膀（不包括已装备的）
function decomposeAllFilteredWings() {
    // 获取当前筛选条件下的翅膀
    let wingsToDecompose = [];
    if (currentWingFilter === 'all') {
        wingsToDecompose = player.wings.inventory.filter(wing => 
            wing.id !== player.wings.equipped && !wing.locked
        );
    } else {
        wingsToDecompose = player.wings.inventory.filter(wing => 
            wing.rarity === currentWingFilter && wing.id !== player.wings.equipped && !wing.locked
        );
    }
    
    if (wingsToDecompose.length === 0) {
        logAction("没有可分解的翅膀", "info");
        return;
    }
    
    // 计算总奖励
    let totalRebornDan = 0;
    wingsToDecompose.forEach(wing => {
        totalRebornDan += getRebornDanByRarity(wing.rarity);
    });
    
    // 显示确认对话框
    showCustomConfirm(`确定要分解${wingsToDecompose.length}个${currentWingFilter === 'all' ? '' : currentWingFilter}翅膀吗？将获得${totalRebornDan}个洗髓丹`, (confirmed) => {
        if (confirmed) {
            // 执行分解
            wingsToDecompose.forEach(wing => {
                const wingIndex = player.wings.inventory.findIndex(w => w.id === wing.id);
                if (wingIndex !== -1) {
                    player.wings.inventory.splice(wingIndex, 1);
                }
            });
            
            // 添加奖励
            player.items.rebornDan = (player.items.rebornDan || 0) + totalRebornDan;
            
            logAction(`一键分解了${wingsToDecompose.length}个翅膀，获得${totalRebornDan}个洗髓丹`, 'success');
            updateWingUI();
            updateItemDisplay();
        }
    });
}

// 根据翅膀品质获取洗髓丹数量
function getRebornDanByRarity(rarity) {
    switch(rarity) {
        case '劣质级': return 1;
        case '普通级': return 1;
        case '优秀级': return 2;
        case '精良级': return 3;
        case '卓越级': return 5;
        case '史诗级': return 10;
        case '传说级': return 20;
        case '神圣级': return 50;
        case '不朽级': return 100;
        default: return 1;
    }
}
// 分解翅膀
function decomposeWing(wingId) {
    const wingIndex = player.wings.inventory.findIndex(w => w.id === wingId);
    if (wingIndex === -1) return;
    
    const wing = player.wings.inventory[wingIndex];
    
    if (wing.locked) {
        logAction("翅膀已锁定，无法分解", "error");
        return;
    }
        
        // 根据品阶获得不同数量的洗髓丹
        let rebornDanReward = 1;
        switch(wing.rarity) {
            case '普通级': rebornDanReward = 1; break;
            case '优秀级': rebornDanReward = 2; break;
            case '精良级': rebornDanReward = 3; break;
            case '卓越级': rebornDanReward = 5; break;
            case '史诗级': rebornDanReward = 10; break;
            case '传说级': rebornDanReward = 20; break;
            case '神圣级': rebornDanReward = 50; break;
            case '不朽级': rebornDanReward = 100; break;
        }
        
        player.items.rebornDan = (player.items.rebornDan || 0) + rebornDanReward;
        
        // 如果分解的是当前装备的翅膀，先卸下
        if (player.wings.equipped === wingId) {
            player.wings.equipped = null;
        }
        
        player.wings.inventory.splice(wingIndex, 1);
        
        logAction(`分解了翅膀：${wing.name}，获得${rebornDanReward}个洗髓丹`, 'success');
        updateWingUI();
        updatePlayerBattleStats();
        updateItemDisplay();
    }


// 升级翅膀等级
function upgradeWing() {
    const cost = player.wings.upgradeCost;
    
    if ((player.items.chiban1 || 0) >= cost) {
        player.items.chiban1 -= cost;
        player.wings.level++;
        player.wings.upgradeCost += 5; // 每次升级增加5个消耗
        
        logAction(`翅膀等级提升至 ${player.wings.level}级，属性加成提升至 ${player.wings.level * 100}%`, 'success');
        updateWingUI();
        updatePlayerBattleStats();
        updateItemDisplay();
    } else {
        logAction(`黑龙王翅膀不足！需要${cost}个`, 'error');
    }
}

// 更新翅膀界面显示
function updateWingUI() {
    // 更新当前装备的翅膀信息
    const currentWingInfo = document.getElementById('currentWingInfo');
    if (player.wings.equipped) {
        const equippedWing = player.wings.inventory.find(w => w.id === player.wings.equipped);
        if (equippedWing) {
            currentWingInfo.innerHTML = `
                <div style="color: ${equippedWing.color}">
                    ${equippedWing.name}（${equippedWing.rarity}）
                </div>
                <div>生命加成: +${(equippedWing.healthBonus * 100).toFixed(1)}%</div>
                <div>总加成: +${(equippedWing.healthBonus * player.wings.level * 100).toFixed(1)}%</div>
                <button onclick="unequipWing()" style="margin-top: 5px;">卸下</button>
            `;
        }
    } else {
        currentWingInfo.innerHTML = '无装备的翅膀';
    }
    
    // 更新翅膀等级信息
    document.getElementById('wingLevel').textContent = player.wings.level;
    document.getElementById('wingBonus').textContent = (player.wings.level * 100) + '%';
    document.getElementById('wingUpgradeCost').textContent = player.wings.upgradeCost;
    
    // 更新翅膀仓库（根据筛选条件）
    const wingInventory = document.getElementById('wingInventory');
    wingInventory.innerHTML = '';
    
    let filteredWings = player.wings.inventory;
    if (currentWingFilter !== 'all') {
        filteredWings = player.wings.inventory.filter(wing => wing.rarity === currentWingFilter);
    }
    
    if (filteredWings.length === 0) {
        wingInventory.innerHTML = '<div style="text-align: center; color: #888;">暂无翅膀</div>';
    } else {
         filteredWings.forEach(wing => {
        const isEquipped = player.wings.equipped === wing.id;
        const wingElement = document.createElement('div');
        wingElement.style.cssText = `
            padding: 10px;
            margin: 5px 0;
            background: #444;
            border-radius: 5px;
            border-left: 4px solid ${wing.color};
            ${isEquipped ? 'border: 2px solid gold;' : ''}
            ${wing.locked ? 'border-right: 4px solid red;' : ''}
        `;
        
        wingElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="color: ${wing.color}; font-weight: bold;">
                    ${wing.name}（${wing.rarity}）
                </div>
                <div>
                    <button onclick="toggleWingLock('${wing.id}')" style="background: ${wing.locked ? '#f44336' : '#4CAF50'}; color: white; border: none; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                        ${wing.locked ? '已锁定' : '未锁定'}
                    </button>
                </div>
            </div>
            <div>生命加成: +${(wing.healthBonus * 100).toFixed(1)}%</div>
            <div>总加成: +${(wing.healthBonus * player.wings.level * 100).toFixed(1)}%</div>
            <div style="margin-top: 5px;">
                ${!isEquipped ? `<button onclick="equipWing('${wing.id}')">装备</button>` : '<span style="color: gold;">已装备</span>'}
                <button onclick="decomposeWing('${wing.id}')" style="margin-left: 5px; background: #f44336;" ${wing.locked ? 'disabled' : ''}>分解</button>
            </div>
        `;
        
        wingInventory.appendChild(wingElement);
    });
    }
}
// 坐骑配置
const mountRarities = {
    "劣质级": { 
        name: "劣质", 
        color: "gray", 
        statRange: { health: [0.01, 0.10], attack: [0.01, 0.10], critDamage: [0.01, 0.10] },
        statChance: 0.2 // 20%几率获得额外词条
    },
    "普通级": { 
        name: "普通", 
        color: "white", 
        statRange: { health: [0.05, 0.20], attack: [0.05, 0.20], critDamage: [0.05, 0.20] },
        statChance: 0.3
    },
    "优秀级": { 
        name: "优秀", 
        color: "green", 
        statRange: { health: [0.10, 0.30], attack: [0.10, 0.30], critDamage: [0.10, 0.30] },
        statChance: 0.4
    },
    "精良级": { 
        name: "精良", 
        color: "blue", 
        statRange: { health: [0.20, 0.40], attack: [0.20, 0.40], critDamage: [0.20, 0.40] },
        statChance: 0.5
    },
    "卓越级": { 
        name: "卓越", 
        color: "purple", 
        statRange: { health: [0.30, 0.50], attack: [0.30, 0.50], critDamage: [0.30, 0.50] },
        statChance: 0.6
    },
    "史诗级": { 
        name: "史诗", 
        color: "gold", 
        statRange: { health: [0.40, 0.80], attack: [0.40, 0.80], critDamage: [0.40, 0.80] },
        statChance: 0.7
    },
    "传说级": { 
        name: "传说", 
        color: "orange", 
        statRange: { health: [0.50, 1.00], attack: [0.50, 1.00], critDamage: [0.50, 1.00] },
        statChance: 0.8
    },
    "神圣级": { 
        name: "神圣", 
        color: "pink", 
        statRange: { health: [1.00, 2.00], attack: [1.00, 2.00], critDamage: [1.00, 2.00] },
        statChance: 0.9
    },
    "不朽级": { 
        name: "不朽", 
        color: "red", 
        statRange: { health: [2.00, 3.00], attack: [2.00, 3.00], critDamage: [2.00, 3.00] },
        statChance: 1.0
    }
};

// 坐骑名字部件
const mountNameParts = {
    prefixes: ["暗影", "光明", "烈焰", "冰霜", "雷霆", "风暴", "星辰", "月光", "太阳", "虚空", "黑暗", "邪恶", "未来", "米白色"],
    types: ["战马", "龙驹", "麒麟", "狮鹫", "猛虎", "巨狼", "神鹰", "灵狐", "玄龟", "凤凰", "独角兽", "梦魇", "地狱", "天界"],
    suffixes: ["之王", "之后", "之魂", "之灵", "之怒", "之翼", "之爪", "之牙", "之心", "之眼"]
};

// 坐骑掉落概率配置
const mountDropRates = {
    3: { // 次元3
        "劣质级": 0.6,
        "普通级": 0.3,
        "优秀级": 0.07,
        "精良级": 0.02,
        "卓越级": 0.01
    },
    4: { // 次元4
        "优秀级": 0.56,
        "精良级": 0.3,
        "卓越级": 0.1,
        "史诗级": 0.03,
        "传说级": 0.01
    },
    5: { // 次元5
        "精良级": 0.5,
        "卓越级": 0.3,
        "史诗级": 0.14,
        "传说级": 0.05,
        "神圣级": 0.009,
        "不朽级": 0.001
    }
};

// 初始化玩家坐骑数据
function initMountData() {
    if (!player.mounts) {
        player.mounts = {
            inventory: [], // 拥有的坐骑列表
            equipped: null, // 当前装备的坐骑ID
            level: 1, // 坐骑等级
            upgradeCost: 5 // 升级所需远古圣兽精魄数量
        };
    }
   
    // 确保items中有远古圣兽精魄
    if (player.items.zuoqi1 === undefined) {
        player.items.zuoqi1 = 0;
    }
}

// 切换坐骑系统界面
function toggleMountSystem() {
   if (player.level.ascentionCounta < 2) {
        alert("需要达到轮回2转才能开启坐骑系统！");
        return;
    }
    const overlay = document.getElementById("mountSystemOverlay");
    const ui = document.getElementById("mountSystemUI");
    
    if (ui.style.display === "block") {
        ui.style.display = "none";
        overlay.style.display = "none";
    } else {
        ui.style.display = "block";
        overlay.style.display = "block";
        updateMountUI();
    }
}

// 生成随机坐骑名字
function generateMountName() {
    const prefix = mountNameParts.prefixes[Math.floor(Math.random() * mountNameParts.prefixes.length)];
    const type = mountNameParts.types[Math.floor(Math.random() * mountNameParts.types.length)];
    const suffix = mountNameParts.suffixes[Math.floor(Math.random() * mountNameParts.suffixes.length)];
    return prefix + type + suffix;
}

// 生成随机坐骑
function generateRandomMount(dimensionLevel) {
    if (dimensionLevel < 3) return null; // 次元3以下不掉落坐骑
    
    const dropRates = mountDropRates[dimensionLevel];
    if (!dropRates) return null;
    
    // 根据概率随机选择品阶
    let rand = Math.random();
    let cumulativeProb = 0;
    let selectedRarity = null;
    
    for (const [rarity, prob] of Object.entries(dropRates)) {
        cumulativeProb += prob;
        if (rand < cumulativeProb) {
            selectedRarity = rarity;
            break;
        }
    }
    
    if (!selectedRarity) return null;
    
    const rarityConfig = mountRarities[selectedRarity];
    const stats = {};
    let statCount = 1; // 至少1个词条
    
    // 随机决定词条数量(1-5)
    for (let i = 0; i < 4; i++) {
        if (Math.random() < rarityConfig.statChance) {
            statCount++;
        }
    }
    
    // 随机选择词条类型
    const statTypes = ["health", "attack", "critDamage"];
    const selectedStats = [];
    
    for (let i = 0; i < statCount; i++) {
        const statType = statTypes[Math.floor(Math.random() * statTypes.length)];
        if (!selectedStats.includes(statType)) {
            selectedStats.push(statType);
            
            // 生成随机属性值
            const range = rarityConfig.statRange[statType];
            stats[statType] = Math.random() * (range[1] - range[0]) + range[0];
        }
    }
    
    return {
        id: 'mount_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: generateMountName(),
        rarity: selectedRarity,
        stats: stats,
        color: rarityConfig.color,
       locked: false
    };
}
function toggleMountLock(mountId) {
    const mount = player.mounts.inventory.find(m => m.id === mountId);
    if (mount) {
        mount.locked = !mount.locked;
        const action = mount.locked ? "锁定" : "解锁";
        logAction(`${action}了坐骑：${mount.name}`, 'success');
        updateMountUI();
    }
}
// 掉落坐骑（在怪物死亡时调用）
function dropMount() {
    const dimensionLevel = player.dimensionLevel;
    if (dimensionLevel < 3) return; // 次元3以下不掉落
    
    if (Math.random() < 0.01) { // 1%掉落几率
        const newMount = generateRandomMount(dimensionLevel);
        if (newMount) {
            player.mounts.inventory.push(newMount);
            logAction(`获得坐骑：${newMount.name}（${newMount.rarity}）`, 'success');
            updateMountUI();
        }
    }
}

// 装备坐骑
function equipMount(mountId) {
    const mount = player.mounts.inventory.find(m => m.id === mountId);
    if (mount) {
        player.mounts.equipped = mountId;
        logAction(`装备了坐骑：${mount.name}`, 'success');
        updateMountUI();
        updatePlayerBattleStats(); // 更新玩家属性
    }
}

// 卸下坐骑
function unequipMount() {
    player.mounts.equipped = null;
    logAction("已卸下坐骑", 'info');
    updateMountUI();
    updatePlayerBattleStats();
}

// 分解坐骑
function decomposeMount(mountId) {
   const mount = player.mounts.inventory.find(m => m.id === mountId);
    if (!mount) return;
    
    if (mount.locked) {
        logAction("坐骑已锁定，无法分解", "error");
        return;
    }

    const mountIndex = player.mounts.inventory.findIndex(m => m.id === mountId);
    if (mountIndex !== -1) {
        const mount = player.mounts.inventory[mountIndex];
        
        // 根据品阶获得不同数量的星币
        let starCoinsReward = 1;
        switch(mount.rarity) {
             case "劣质级": starCoinsReward = 10; break;
            case "普通级": starCoinsReward = 20; break;
            case "优秀级": starCoinsReward = 30; break;
            case "精良级": starCoinsReward = 50; break;
            case "卓越级": starCoinsReward = 100; break;
            case "史诗级": starCoinsReward = 250; break;
            case "传说级": starCoinsReward = 500; break;
            case "神圣级": starCoinsReward = 1000; break;
            case "不朽级": starCoinsReward = 2000; break;
        }
        
        player.nightClub.starCoins += starCoinsReward;
        
        // 如果分解的是当前装备的坐骑，先卸下
        if (player.mounts.equipped === mountId) {
            player.mounts.equipped = null;
        }
        
        player.mounts.inventory.splice(mountIndex, 1);
        
        logAction(`分解了坐骑：${mount.name}，获得${starCoinsReward}星币`, 'success');
        updateMountUI();
        updatePlayerBattleStats();
        updateDisplay();
    }
}

// 升级坐骑等级
function upgradeMount() {
    const cost = player.mounts.upgradeCost;
    
    if (player.items.zuoqi1 >= cost) {
        player.items.zuoqi1 -= cost;
        player.mounts.level++;
        player.mounts.upgradeCost += 5; // 每次升级增加5个消耗
        
        logAction(`坐骑等级提升至 ${player.mounts.level}级，属性加成提升至 ${player.mounts.level * 100}%`, 'success');
        updateMountUI();
        updatePlayerBattleStats();
        updateItemDisplay();
    } else {
        logAction(`远古圣兽精魄不足！需要${cost}个`, 'error');
    }
}

// 更新坐骑界面显示
function updateMountUI() {
    // 更新当前装备的坐骑信息
    const currentMountInfo = document.getElementById("currentMountInfo");
    if (player.mounts.equipped) {
        const equippedMount = player.mounts.inventory.find(m => m.id === player.mounts.equipped);
        if (equippedMount) {
            let statsHTML = "";
            for (const [stat, value] of Object.entries(equippedMount.stats)) {
                const statName = {
                    "health": "生命",
                    "attack": "攻击",
                    "critDamage": "爆伤"
                }[stat];
                statsHTML += `<div>${statName}加成: +${(value * 100).toFixed(1)}%</div>`;
            }
            
            currentMountInfo.innerHTML = `
                <div style="color: ${equippedMount.color}">
                    ${equippedMount.name}（${equippedMount.rarity}）
                </div>
                ${statsHTML}
                <div>总加成: +${(calculateMountBonus(equippedMount) * 100).toFixed(1)}%</div>
                <button onclick="unequipMount()" style="margin-top: 5px;">卸下</button>
            `;
        }
    } else {
        currentMountInfo.innerHTML = '无装备的坐骑';
    }
    
    // 更新坐骑等级信息
    document.getElementById("mountLevel").textContent = player.mounts.level;
    document.getElementById("mountBonus").textContent = (player.mounts.level * 100) + '%';
    document.getElementById("mountUpgradeCost").textContent = player.mounts.upgradeCost;
    
    // 更新坐骑仓库
    const mountInventory = document.getElementById("mountInventory");
    mountInventory.innerHTML = '';
    
    // 获取当前筛选条件
    const filter = document.getElementById("mountRarityFilter").value;
    let filteredMounts = player.mounts.inventory;
    if (filter !== "all") {
        filteredMounts = player.mounts.inventory.filter(mount => mount.rarity === filter);
    }
    
    if (filteredMounts.length === 0) {
        mountInventory.innerHTML = '<div style="text-align: center; color: #888;">暂无坐骑</div>';
    } else {
        filteredMounts.forEach(mount => {
        const isEquipped = player.mounts.equipped === mount.id;
        const mountElement = document.createElement("div");
        mountElement.style.cssText = `
            padding: 10px;
            margin: 5px 0;
            background: #444;
            border-radius: 5px;
            border-left: 4px solid ${mount.color};
            ${isEquipped ? 'border: 2px solid gold;' : ''}
            ${mount.locked ? 'border-right: 4px solid red;' : ''}
        `;
        
        let statsHTML = "";
        for (const [stat, value] of Object.entries(mount.stats)) {
            const statName = {
                "health": "生命",
                "attack": "攻击",
                "critDamage": "爆伤"
            }[stat];
            statsHTML += `<div>${statName}: +${(value * 100).toFixed(1)}%</div>`;
        }
        
        mountElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="color: ${mount.color}; font-weight: bold;">
                    ${mount.name}（${mount.rarity}）
                </div>
                <div>
                    <button onclick="toggleMountLock('${mount.id}')" style="background: ${mount.locked ? '#f44336' : '#4CAF50'}; color: white; border: none; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                        ${mount.locked ? '已锁定' : '未锁定'}
                    </button>
                </div>
            </div>
            ${statsHTML}
            <div>总加成: +${(calculateMountBonus(mount) * 100).toFixed(1)}%</div>
            <div style="margin-top: 5px;">
                ${!isEquipped ? `<button onclick="equipMount('${mount.id}')">装备</button>` : '<span style="color: gold;">已装备</span>'}
                <button onclick="decomposeMount('${mount.id}')" style="margin-left: 5px; background: #f44336;" ${mount.locked ? 'disabled' : ''}>分解</button>
            </div>
        `;
        
        mountInventory.appendChild(mountElement);
    });
    }
}

// 计算坐骑总加成
function calculateMountBonus(mount) {
    let totalBonus = 0;
    for (const value of Object.values(mount.stats)) {
        totalBonus += value;
    }
    return totalBonus * player.mounts.level;
}

// 筛选坐骑
function filterMounts() {
    updateMountUI();
}

// 一键分解当前筛选条件下的所有坐骑（不包括已装备的）
function decomposeAllFilteredMounts() {
    // 获取当前筛选条件下的坐骑
    const filter = document.getElementById("mountRarityFilter").value;
    let mountsToDecompose = [];
    
    if (filter === "all") {
        mountsToDecompose = player.mounts.inventory.filter(mount => 
            mount.id !== player.mounts.equipped && !mount.locked
        );
    } else {
        mountsToDecompose = player.mounts.inventory.filter(mount => 
            mount.rarity === filter && mount.id !== player.mounts.equipped && !mount.locked
        );
    }
    
    if (mountsToDecompose.length === 0) {
        logAction("没有可分解的坐骑", "info");
        return;
    }
    
    // 计算总奖励
    let totalStarCoins = 0;
    mountsToDecompose.forEach(mount => {
        let reward = 0;
        switch(mount.rarity) {
           case "劣质级": reward = 10; break;
            case "普通级": reward = 20; break;
            case "优秀级": reward = 30; break;
            case "精良级": reward = 50; break;
            case "卓越级": reward = 100; break;
            case "史诗级": reward = 250; break;
            case "传说级": reward = 500; break;
            case "神圣级": reward = 1000; break;
            case "不朽级": reward = 2000; break;
        }
        totalStarCoins += reward;
    });
    
    // 显示确认对话框
    showCustomConfirm(`确定要分解${mountsToDecompose.length}个${filter === "all" ? "" : filter}坐骑吗？将获得${totalStarCoins}星币`, (confirmed) => {
        if (confirmed) {
            // 执行分解
            mountsToDecompose.forEach(mount => {
                const mountIndex = player.mounts.inventory.findIndex(m => m.id === mount.id);
                if (mountIndex !== -1) {
                    player.mounts.inventory.splice(mountIndex, 1);
                }
            });
            
            // 添加奖励
            player.nightClub.starCoins += totalStarCoins;
            
            logAction(`一键分解了${mountsToDecompose.length}个坐骑，获得${totalStarCoins}星币`, 'success');
            updateMountUI();
            updateDisplay();
        }
    });
}

// 宝石系统初始化
function initGemSystem() {
    if (!player.gems) {
        player.gems = {
            red: {1: 0},   // 初始化为0个1级红宝石
            blue: {1: 0},   // 初始化为0个1级蓝宝石
            black: {1: 0}  // 初始化为0个1级黑宝石

        };
    }
}

// 切换宝石系统界面
function toggleGemSystem() {
   if (player.reincarnationCount < 800) {
        alert("需要达到800转才能开启宝石系统！");
        return;
    }
    const overlay = document.getElementById('gemSystemOverlay');
    const ui = document.getElementById('gemSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initGemSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateGemUI();
    }
}

// 更新宝石界面
function updateGemUI() {
    updateGemInventory();
    updateGemBonuses();
}

// 更新宝石仓库显示
function updateGemInventory() {
    const container = document.getElementById('gemInventory');
    container.innerHTML = '';
    
    // 红宝石
    addGemTypeToUI('red', '红宝石 (攻击加成)', container);
    // 蓝宝石
    addGemTypeToUI('blue', '蓝宝石 (生命加成)', container);
    // 黑宝石
    addGemTypeToUI('black', '黑宝石 (爆伤加成)', container);

}

// 添加宝石类型到UI
function addGemTypeToUI(type, name, container) {
    const gemTypeDiv = document.createElement('div');
    gemTypeDiv.className = 'gem-type-section';
    gemTypeDiv.innerHTML = `<h4>${name}</h4>`;
    
    const gemsContainer = document.createElement('div');
    gemsContainer.style.display = 'grid';
    gemsContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
    gemsContainer.style.gap = '10px';
    gemsContainer.style.marginTop = '10px';
    
    // 显示该类型的所有宝石
    let hasGems = false;
    for (const level in player.gems[type]) {
        const count = player.gems[type][level];
        if (count > 0) {
            hasGems = true;
            const gemDiv = document.createElement('div');
            gemDiv.className = 'gem-item';
            gemDiv.innerHTML = `
                <div class="gem-icon ${type}">${type.charAt(0).toUpperCase()}</div>
                <div class="gem-level">${level}</div>
                <div>数量: ${count}</div>
                <button onclick="upgradeGem('${type}', ${level})" ${count < 3 ? 'disabled' : ''}>合成</button>
            `;
            gemsContainer.appendChild(gemDiv);
        }
    }
    
    // 如果没有宝石，显示提示
    if (!hasGems) {
        gemsContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888;">暂无宝石</div>';
    }
    
    gemTypeDiv.appendChild(gemsContainer);
    container.appendChild(gemTypeDiv);
}

// 更新宝石加成显示
function updateGemBonuses() {
    const bonuses = calculateGemBonuses();
    
    document.getElementById('attackBonus').textContent = `${bonuses.attack.toFixed(1)}%`;
    document.getElementById('healthBonus').textContent = `${bonuses.health.toFixed(1)}%`;
    document.getElementById('critDamageBonus').textContent = `${bonuses.critDamage.toFixed(1)}%`;

}


// 计算宝石总加成
function calculateGemBonuses() {
    return {
        attack: calculateGemBonus('red'),
        health: calculateGemBonus('blue'),
        critDamage: calculateGemBonus('black')


    };
}
// 计算单个宝石类型的加成
function calculateGemBonus(type) {
    let totalBonus = 0;
    
    for (const level in player.gems[type]) {
        const count = player.gems[type][level];
        const levelInt = parseInt(level);
        
        // 不同宝石类型有不同的加成计算方式
        switch (type) {
            case 'red': // 攻击加成: 100% * 2^(等级-1)
                totalBonus += count * 100 * (Math.pow(3, levelInt) - 1) / 2;
                break;
            case 'blue': // 生命加成: 5% * 2^(等级-1)
                totalBonus += count * 5 * (Math.pow(3, levelInt) - 1) / 2;
                break;
            case 'black': // 爆伤加成: 100% * 2^(等级-1)
                totalBonus += count * 100 * (Math.pow(3, levelInt) - 1) / 2;
                break;

        }
    }
    
    return totalBonus;
}

// 购买宝石
function buyGem(type, level) {
    if (player.exploration.resources.darkMatter >= 100) {
        player.exploration.resources.darkMatter -= 100;
        
        // 确保宝石类型存在
        if (!player.gems[type]) {
            player.gems[type] = {};
        }
        
        // 确保宝石等级存在
        if (!player.gems[type][level]) {
            player.gems[type][level] = 0;
        }
        
        player.gems[type][level]++;
        logAction(`购买了1个${getGemName(type)}宝石`, 'success');
        updateGemUI();
        updateDisplay();
    } else {
        logAction("暗物质不足！", "error");
    }
}

// 添加宝石
function addGem(type, level) {
    if (!player.gems[type][level]) {
        player.gems[type][level] = 0;
    }
    player.gems[type][level]++;
}

// 获取宝石名称
function getGemName(type) {
    const names = {
        red: "红",
        blue: "蓝",
        black: "黑"

    };
    return names[type] || "未知";
}

// 宝石合成
function upgradeGem(type, level) {
    const currentLevel = parseInt(level);
    const nextLevel = currentLevel + 1;
    
    // 检查是否有足够的宝石合成
    if (player.gems[type][currentLevel] >= 3) {
        player.gems[type][currentLevel] -= 3;
        
        // 如果数量为0，删除该等级
        if (player.gems[type][currentLevel] === 0) {
            delete player.gems[type][currentLevel];
        }
        
        // 添加高一级宝石
        if (!player.gems[type][nextLevel]) {
            player.gems[type][nextLevel] = 0;
        }
        player.gems[type][nextLevel]++;
        
        logAction(`成功合成${getGemName(type)}宝石 Lv.${nextLevel}`, 'success');
        updateGemUI();
    } else {
        logAction("宝石数量不足，无法合成！", "error");
    }
}
// 打开藏宝图商店
    function openTreasureShop() {
        document.getElementById('treasureShopOverlay').style.display = 'block';
        document.getElementById('treasureShopUI').style.display = 'block';
        updateGemDisplay();
    }
    
    // 关闭藏宝图商店
    function closeTreasureShop() {
        document.getElementById('treasureShopOverlay').style.display = 'none';
        document.getElementById('treasureShopUI').style.display = 'none';
    }
    
    // 更新宝石数量显示
    function updateGemDisplay() {
        document.getElementById('currentPrimaryGemqCount').textContent = player.items.primaryGemq || 0;
    }
    
    // 兑换物品函数
    function exchangeItem(type) {
        let cost, item, amount;
        
        switch(type) {
            case 1: // 玫瑰花
                cost = 1;
                item = 'rose';
                amount = 50;
                break;
            case 2: // VIP能力值
                cost = 1;
                item = 'vipPower';
                amount = 10;
                break;
            case 3: // 鱼饵
                cost = 1;
                item = 'baitCount';
                amount = 1;
                break;
            case 4: // 伴侣钥匙
                cost = 2;
                item = 'companionKey';
                amount = 1;
                break;
            case 5: // 灵根检测器
                cost = 5;
                item = 'rootDetector';
                amount = 1;
                break;
            case 6: // 血脉检测剂
                cost = 5;
                item = 'bloodlineDetector';
                amount = 1;
                break;
            case 7: // 进阶神石
                cost = 20;
                item = 'advanceStone';
                amount = 1;
                break;
           case 8: // 宗门令牌
                cost = 50;
                item = 'zongmen';
                amount = 1;
                break;
            case 9: // 副本令牌
                cost = 10;
                item = 'fuben1';
                amount = 1;
                break;
             case 10: // 职业转换书
                cost = 10;
                item = 'zhiye1';
                amount = 1;
                break;
            default:
                return;
        }
        
        // 检查金币数量
        if (player.items.primaryGemq >= cost) {
            // 扣除金币
            player.items.primaryGemq -= cost;
            
            // 添加物品
            if (!player.items[item]) player.items[item] = 0;
            player.items[item] += amount;
            
            // 更新显示
            updateGemDisplay();
            updateDisplay();
            
            // 显示成功消息
            let itemName = '';
            switch(item) {
                case 'rose': itemName = '玫瑰花'; break;
                case 'vipPower': itemName = 'VIP能力值'; break;
                case 'baitCount': itemName = '鱼饵'; break;
                case 'companionKey': itemName = '伴侣钥匙'; break;
                case 'rootDetector': itemName = '灵根检测器'; break;
                case 'bloodlineDetector': itemName = '血脉检测剂'; break;
                case 'advanceStone': itemName = '进阶神石'; break;
               case 'zongmen': itemName = '宗门令牌'; break;
               case 'zhiye1': itemName = '职业转换书'; break;
               case 'fuben1': itemName = '副本令牌'; break;
            }
            
            logAction(`宝藏金币成功兑换: ${amount}${itemName}`, 'success');
        } else {
            logAction('宝藏金币不足！', 'error');
        }
    }




// 藏宝图等级配置
const treasureMapLevels = [
    { level: 1, name: "一级藏宝图", monsterMinStage: 50, monsterMaxStage: 200, expReward: 10000, rewards: [
        { type: "baitCount", amount: 1 },
        { type: "companionKey", amount: 1 },
        { type: "vipPower", amount: 2 },
        { type: "rose", amount: 20 },
        { type: "primaryGem", amount: 1 },
        { type: "advancedGem", amount: 1 },
        { type: "yuzhou1", amount: 3 },
        { type: "yuzhou2", amount: 3 },
         { type: "banlv1", amount: 1 },
        { type: "banlv2", amount: 1 }
    ]},
    { level: 2, name: "二级藏宝图", monsterMinStage: 200, monsterMaxStage: 400, expReward: 50000, rewards: [
        { type: "baitCount", amount: 2 },
        { type: "companionKey", amount: 2 },
        { type: "vipPower", amount: 5 },
        { type: "rose", amount: 50 },
        { type: "advancedGem", amount: 2 },
        { type: "primaryGem", amount: 2 },
        { type: "rebornDan", amount: 3 },
        { type: "advanceStone", amount: 1 },
        { type: "yuzhou1", amount: 5 },
        { type: "yuzhou2", amount: 5 },
        { type: "banlv1", amount: 2 },
        { type: "banlv2", amount: 2 }
    ]},
    { level: 3, name: "三级藏宝图", monsterMinStage: 400, monsterMaxStage: 600, expReward: 100000, rewards: [
        { type: "baitCount", amount: 5 },
        { type: "companionKey", amount: 3 },
        { type: "vipPower", amount: 10 },
        { type: "rose", amount: 100 },
        { type: "advancedGem", amount: 3 },
        { type: "superiorGem", amount: 3 },
        { type: "rebornDan", amount: 5 },
        { type: "rootDetector", amount: 1 },
        { type: "bloodlineDetector", amount: 1 },
        { type: "advanceStone", amount: 1 },
              { type: "yuzhou1", amount: 10 },
        { type: "yuzhou2", amount: 5 },
        { type: "yuzhou3", amount: 5 },
         { type: "yuzhou4", amount: 5 },
        { type: "banlv1", amount: 5 },
        { type: "banlv2", amount: 5 },  
        { type: "banlv7", amount: 1 },
       { type: "banlv8", amount: 1 },      
      { type: "banlv9", amount: 1 }       
    ]},
    { level: 4, name: "四级藏宝图", monsterMinStage: 600, monsterMaxStage: 800, expReward: 500000, rewards: [
        { type: "baitCount", amount: 5 },
        { type: "companionKey", amount: 5 },
        { type: "vipPower", amount: 20 },
        { type: "rose", amount: 200 },
        { type: "superiorGem", amount: 3 },
        { type: "divineGem", amount: 3 },
        { type: "rebornDan", amount: 10 },
        { type: "rootDetector", amount: 3 },
        { type: "bloodlineDetector", amount: 3 },
        { type: "advanceStone", amount: 2 },
        { type: "yuzhou1", amount: 10 },
        { type: "yuzhou2", amount: 10 },
        { type: "yuzhou3", amount: 10 },
        { type: "yuzhou4", amount: 10 },
        { type: "banlv1", amount: 10 },
        { type: "banlv2", amount: 10 }, 
        { type: "banlv7", amount: 10 },
       { type: "banlv8", amount: 2 },  
       { type: "fuben1", amount: 1 },
       { type: "zhiye1", amount: 1 },        
      { type: "banlv9", amount: 2 }  
    ]},
    { level: 5, name: "五级藏宝图", monsterMinStage: 800, monsterMaxStage: 1000, expReward: 1000000, rewards: [
        { type: "baitCount", amount: 10 },
        { type: "companionKey", amount: 10 },
        { type: "vipPower", amount: 50 },
        { type: "rose", amount: 500 },
        { type: "superiorGem", amount: 5 },
        { type: "divineGem", amount: 5 },
        { type: "rebornDan", amount: 20 },
        { type: "rootDetector", amount: 5 },
        { type: "bloodlineDetector", amount: 5 },
       { type: "advanceStone", amount: 3 },
       { type: "yuzhou1", amount: 30 },
       { type: "yuzhou2", amount: 30 },
       { type: "yuzhou3", amount: 30 },
       { type: "yuzhou4", amount: 30 },
       { type: "banlv1", amount: 20 },
       { type: "banlv2", amount: 20 },  
         { type: "banlv7", amount: 3 },
       { type: "banlv8", amount: 3 },
       { type: "fuben1", amount: 1 },  
       { type: "zhiye1", amount: 1 },    
      { type: "banlv9", amount: 3 }  
    ]}
];

// 藏宝图品质配置
const treasureMapQualities = [
    { quality: 1, name: "普通", multiplier: 1.0 },
    { quality: 2, name: "精良", multiplier: 2.0 },
    { quality: 3, name: "稀有", multiplier: 3.0 },
    { quality: 4, name: "史诗", multiplier: 5.0 },
    { quality: 5, name: "传说", multiplier: 10.0 },
    { quality: 6, name: "神话", multiplier: 20.0 }
];

// 切换藏宝图系统显示
function toggleTreasureMapSystem() {
    if (player.reincarnationCount < 600) {
        alert("需要达到600转才能开启宝图系统！");
        return;
    }
    const ui = document.getElementById('treasureMapSystemUI');
    const overlay = document.getElementById('treasureMapSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateTreasureMapDisplay();
        // 初始化合成界面
    updateCraftingDisplay();
    
    // 添加选择框变化监听
    document.getElementById('craftLevel').addEventListener('change', updateCraftingDisplay);
    document.getElementById('craftQuality').addEventListener('change', updateCraftingDisplay);
    }
}

// 更新藏宝图系统显示
function updateTreasureMapDisplay() {
     // 更新钥匙数量
    document.getElementById('treasureKeyCount').textContent = player.treasure.keys;
    const container = document.getElementById('treasureMapList');
    container.innerHTML = '';
    
    if (player.treasure.maps.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888;">暂无藏宝图</div>';
        return;
    }
    
    // 按等级和品质排序
    player.treasure.maps.sort((a, b) => {
        if (a.level !== b.level) return b.level - a.level;
        return b.quality - a.quality;
    });
    
    player.treasure.maps.forEach((map, index) => {
        const levelConfig = treasureMapLevels.find(l => l.level === map.level);
        const qualityConfig = treasureMapQualities.find(q => q.quality === map.quality);
        
        const card = document.createElement('div');
        card.style.background = '#444';
        card.style.padding = '10px';
        card.style.borderRadius = '5px';
        card.style.border = `2px solid ${map.quality >= 4 ? '#d4af37' : '#4CAF50'}`;
        
        card.innerHTML = `
            <div style="font-weight: bold; color: ${map.quality >= 4 ? '#d4af37' : '#4CAF50'};">${levelConfig.name}</div>
            <div>品质: ${qualityConfig.name} (x${qualityConfig.multiplier})</div>
            <div>获得时间: ${new Date(map.obtainedAt).toLocaleDateString()}</div>
            <button onclick="useTreasureMap(${index})" style="margin-top: 10px; width: 100%; background: #2196F3; color: white; border: none; padding: 5px; border-radius: 3px; cursor: pointer;">使用</button>
        `;
        
        container.appendChild(card);
    });
    
    // 更新合成界面
    updateCraftingDisplay();
}

// 兑换藏宝图钥匙
function buyTreasureKey() {
    if (player.exploration.resources.stardust < 100) {
        logAction("星尘不足！", "error");
        return;
    }
    
    player.exploration.resources.stardust -= 100;
    player.treasure.keys++;
    updateTreasureMapDisplay();
    logAction("成功兑换1个藏宝图钥匙", "success");
}
function buyTreasureKey1() {
    if (player.nightClub.starCoins < 100) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 100;
    player.treasure.keys++;
    updateTreasureMapDisplay();
    logAction("成功兑换1个藏宝图钥匙", "success");
}
function buyTreasureKey2() {
    if (player.nightClub.starCoins < 1000) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 1000;
    player.treasure.keys+=10;
    updateTreasureMapDisplay();
    logAction("成功兑换10个藏宝图钥匙", "success");
}
function buyTreasureKey3() {
    if (player.nightClub.starCoins < 5000) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 5000;
    player.treasure.keys+=50;
    updateTreasureMapDisplay();
    logAction("成功兑换50个藏宝图钥匙", "success");
}
function openTreasureChestBatch(count) {
    if (player.treasure.keys < count) {
        logAction(`藏宝图钥匙不足！需要${count}个钥匙`, "error");
        return;
    }
    
    player.treasure.keys -= count;
    
    // 统计获得的藏宝图
    const results = {
        total: 0,
        byLevel: {},
        byQuality: {}
    };
    
    for (let i = 0; i < count; i++) {
        // 随机生成藏宝图等级
        const levelRand = Math.random();
        let level;
        if (levelRand < 0.7) level = 1;
        else if (levelRand < 0.92) level = 2;
        else if (levelRand < 0.98) level = 3;
        else if (levelRand < 0.995) level = 4;
        else level = 5;
        
        // 随机生成藏宝图品质
        const qualityRand = Math.random();
        let quality;
        if (qualityRand < 0.7) quality = 1;
        else if (qualityRand < 0.95) quality = 2;
        else if (qualityRand < 0.99889) quality = 3;
        else if (qualityRand < 0.99989) quality = 4;
        else if (qualityRand < 0.99999) quality = 5;
        else quality = 6;
        
        // 创建藏宝图
        const newMap = {
            level: level,
            quality: quality,
            obtainedAt: Date.now()
        };
        
        player.treasure.maps.push(newMap);
        
        // 统计结果
        results.total++;
        results.byLevel[level] = (results.byLevel[level] || 0) + 1;
        results.byQuality[quality] = (results.byQuality[quality] || 0) + 1;
    }
    
    // 更新显示
    updateTreasureMapDisplay();
    
    // 生成汇总消息
    let message = `批量开启了${count}个宝箱，获得${results.total}张藏宝图：`;
    
    // 按等级统计
    message += " 等级分布:";
    for (let lvl = 1; lvl <= 5; lvl++) {
        if (results.byLevel[lvl]) {
            const levelName = treasureMapLevels.find(l => l.level === lvl).name;
            message += ` ${levelName}×${results.byLevel[lvl]}`;
        }
    }
    
    // 按品质统计
    message += " 品质分布:";
    for (let q = 1; q <= 6; q++) {
        if (results.byQuality[q]) {
            const qualityName = treasureMapQualities.find(qual => qual.quality === q).name;
            message += ` ${qualityName}×${results.byQuality[q]}`;
        }
    }
    
    logAction(message, 'success');
}




// 开启藏宝图宝箱
function openTreasureChest() {
    if (player.treasure.keys < 1) {
        logAction("藏宝图钥匙不足！", "error");
        return;
    }
    
    player.treasure.keys--;
    
    // 随机生成藏宝图等级
    const levelRand = Math.random();
    let level;
    if (levelRand < 0.7) level = 1;
    else if (levelRand < 0.92) level = 2;
    else if (levelRand < 0.98) level = 3;
    else if (levelRand < 0.995) level = 4;
    else level = 5;
    
    // 随机生成藏宝图品质
    const qualityRand = Math.random();
    let quality;
    if (qualityRand < 0.7) quality = 1;
    else if (qualityRand < 0.95) quality = 2;
    else if (qualityRand < 0.99889) quality = 3;
    else if (qualityRand < 0.99989) quality = 4;
    else if (qualityRand < 0.99999) quality = 5;
    else quality = 6;
    
    // 创建藏宝图
    const newMap = {
        level: level,
        quality: quality,
        obtainedAt: Date.now()
    };
    
    player.treasure.maps.push(newMap);
    updateTreasureMapDisplay();
    
    const levelName = treasureMapLevels.find(l => l.level === level).name;
    const qualityName = treasureMapQualities.find(q => q.quality === quality).name;
    logAction(`获得${levelName}（${qualityName}品质）`, "success");
}
function updateCraftingDisplay() {
    const levelSelect = document.getElementById('craftLevel');
    const qualitySelect = document.getElementById('craftQuality');
    const countDisplay = document.getElementById('craftCount');
    
    if (!levelSelect || !qualitySelect || !countDisplay) return;
    
    // 获取当前选择的等级和品质
    const selectedLevel = parseInt(levelSelect.value);
    const selectedQuality = parseInt(qualitySelect.value);
    
    // 计算当前拥有的符合条件的藏宝图数量
    const count = player.treasure.maps.filter(map => 
        map.level === selectedLevel && map.quality === selectedQuality
    ).length;
    
    countDisplay.textContent = count;
    
    // 更新品质选择框，隐藏无法合成的选项（神话品质）
    while (qualitySelect.options.length > 0) {
        qualitySelect.remove(0);
    }
    
    const maxQuality = 5; // 最高可合成到传说品质
    for (let q = 1; q <= maxQuality; q++) {
        const option = document.createElement('option');
        option.value = q;
        option.textContent = treasureMapQualities.find(qual => qual.quality === q).name;
        qualitySelect.appendChild(option);
    }
    
    // 恢复之前的选择
    qualitySelect.value = Math.min(selectedQuality, maxQuality);
}

// 合成藏宝图
function craftTreasureMap() {
    const level = parseInt(document.getElementById('craftLevel').value);
    const quality = parseInt(document.getElementById('craftQuality').value);
    
    // 检查是否可以合成（神话品质无法继续合成）
    if (quality >= 6) {
        logAction("神话品质无法继续合成！", "error");
        return;
    }
    
    // 获取符合条件的藏宝图
    const matchingMaps = player.treasure.maps.filter(map => 
        map.level === level && map.quality === quality
    );
    
    // 检查数量是否足够
    if (matchingMaps.length < 2) {
        logAction(`需要2张${treasureMapLevels.find(l => l.level === level).name}（${treasureMapQualities.find(q => q.quality === quality).name}品质）才能合成！`, "error");
        return;
    }
    
    // 移除2张原材料
    for (let i = 0; i < 2; i++) {
        const index = player.treasure.maps.findIndex(map => 
            map.level === level && map.quality === quality
        );
        if (index !== -1) {
            player.treasure.maps.splice(index, 1);
        }
    }
    
    // 添加1张更高品质的同等级藏宝图
    const newMap = {
        level: level,
        quality: quality + 1,
        obtainedAt: Date.now()
    };
    
    player.treasure.maps.push(newMap);
    
    // 更新显示
    updateTreasureMapDisplay();
    updateCraftingDisplay();
    
    const levelName = treasureMapLevels.find(l => l.level === level).name;
    const oldQualityName = treasureMapQualities.find(q => q.quality === quality).name;
    const newQualityName = treasureMapQualities.find(q => q.quality === quality + 1).name;
    
    logAction(`成功将2张${levelName}（${oldQualityName}品质）合成为1张${levelName}（${newQualityName}品质）`, "success");
}

// 一键合成全部可合成的藏宝图
function craftAllTreasureMaps() {
    let craftedCount = 0;
    
    // 遍历所有等级和品质（除了神话品质）
    for (let level = 1; level <= 5; level++) {
        for (let quality = 1; quality <= 5; quality++) { // 最高合成到传说品质
            let craftedInThisCategory = 0;
            
            // 获取符合条件的藏宝图
            const matchingMaps = player.treasure.maps.filter(map => 
                map.level === level && map.quality === quality
            );
            
            // 计算可合成的次数
            const craftTimes = Math.floor(matchingMaps.length / 2);
            
            if (craftTimes > 0) {
                // 移除原材料
                for (let i = 0; i < craftTimes * 2; i++) {
                    const index = player.treasure.maps.findIndex(map => 
                        map.level === level && map.quality === quality
                    );
                    if (index !== -1) {
                        player.treasure.maps.splice(index, 1);
                    }
                }
                
                // 添加合成后的藏宝图
                for (let i = 0; i < craftTimes; i++) {
                    const newMap = {
                        level: level,
                        quality: quality + 1,
                        obtainedAt: Date.now()
                    };
                    player.treasure.maps.push(newMap);
                    craftedCount++;
                }
                
                craftedInThisCategory += craftTimes;
            }
            
            if (craftedInThisCategory > 0) {
                const levelName = treasureMapLevels.find(l => l.level === level).name;
                const oldQualityName = treasureMapQualities.find(q => q.quality === quality).name;
                const newQualityName = treasureMapQualities.find(q => q.quality === quality + 1).name;
                
                logAction(`一键合成了${craftedInThisCategory}组${levelName}（${oldQualityName}品质）→ ${levelName}（${newQualityName}品质）`, "info");
            }
        }
    }
    
    if (craftedCount > 0) {
        logAction(`一键合成完成，共合成${craftedCount}张藏宝图`, "success");
    } else {
        logAction("没有可合成的藏宝图", "info");
    }
    
    // 更新显示
    updateTreasureMapDisplay();
    updateCraftingDisplay();
}




// 使用藏宝图
function useTreasureMap(index) {
    if (index < 0 || index >= player.treasure.maps.length) return;
    
    const map = player.treasure.maps[index];
    const levelConfig = treasureMapLevels.find(l => l.level === map.level);
    const qualityConfig = treasureMapQualities.find(q => q.quality === map.quality);
    
    // 移除藏宝图
    player.treasure.maps.splice(index, 1);
    updateTreasureMapDisplay();
    
    // 随机决定事件类型
    const eventRand = Math.random();
    
    if (eventRand < 0.6) {
        // 60% 遇到怪物
        startTreasureBattle(map);
    } else if (eventRand < 0.8) {
        // 20% 直接获得奖励
        giveTreasureRewards(map, false);
    } else {
        // 20% 没有奖励
        showTreasureReward("没有获得任何奖励");
    }
}

function generateTreasureMonster(minStage, maxStage) {
    // 随机选择关卡
    const stage = Math.floor(Math.random() * (maxStage - minStage + 1)) + minStage;
    
    // 复制打怪模式的属性生成逻辑
    const monsterRanks = ['普通', '精英', '普通BOSS', '特殊BOSS', '领主BOSS', '霸主级BOSS', '王级BOSS', '皇级BOSS', '帝级BOSS', '神级BOSS', '圣级BOSS'];
    const rankProbabilities = [0.45, 0.20, 0.10, 0.06, 0.05, 0.04, 0.03, 0.03, 0.02, 0.015, 0.005];
    
    // 随机生成怪物品阶
    let rankIndex = 0;
    let rand = Math.random();
    for (let i = 0; i < rankProbabilities.length; i++) {
        rand -= rankProbabilities[i];
        if (rand < 0) {
            rankIndex = i;
            break;
        }
    }
    const rank = monsterRanks[rankIndex];
    
    // 根据品阶选择词条
    const modifierPool = monsterRankModifiers[rank].pool;
    const selectCount = monsterRankModifiers[rank].selectCount;
    const selectedModifiers = [];
    const usedModifiers = new Set();
    
    for (let i = 0; i < selectCount; i++) {
        let modifier;
        do {
            modifier = modifierPool[Math.floor(Math.random() * modifierPool.length)];
        } while (usedModifiers.has(modifier));
        usedModifiers.add(modifier);
        selectedModifiers.push(modifier);
    }
    
    // 计算怪物属性
    const healthMultiplier = Math.pow(2, stage);
    let attackMultiplier;
  
    if (stage <= 5) {
        attackMultiplier = Math.floor(Math.random() * 3) + 1;
    } else if (stage <= 15) {
        attackMultiplier = 35 + (stage - 10) * 1000;
    } else if (stage <= 25) {
        attackMultiplier = 50 + (stage - 10) * 100000;
    } else if (stage <= 40) {
        attackMultiplier = 100 + (stage - 10) * 1e70;
    } else if (stage <= 65) {
        attackMultiplier = 1000 + (stage - 9) * 1e80;
    } else if (stage <= 90) {
        attackMultiplier = 3500 + (stage - 64) * 1e90;
    } else if (stage <= 120) {
        attackMultiplier = 35000 + (stage - 89) * 1e100;
    } else if (stage <= 250) {
        attackMultiplier = 350000 + (stage - 119) * 1e110;
    } else if (stage <= 350) {
        attackMultiplier = 3500000 + (stage - 249) * 1e120;
    } else if (stage <= 450) {
        attackMultiplier = 450000000 + (stage - 349) * 1e130;
    } else if (stage <= 550) {
        attackMultiplier = 5500009000 + (stage - 449) * 1e140;
    } else if (stage <= 650) {
        attackMultiplier = 650000000900 + (stage - 549) * 1e150;
    } else if (stage <= 700) {
        attackMultiplier = 6500000000900 + (stage - 649) * 1e160;
    } else if (stage <= 750) {
        attackMultiplier = 6500000000000900 + (stage - 699) * 1e170;
    } else if (stage <= 790) {
        attackMultiplier = 6500000000000000900 + (stage - 549) * 1e180;
    } else if (stage <= 820) {
        attackMultiplier = 65000000000000000000900 + (stage - 549) * 1e190;
    } else if (stage <= 840) {
        attackMultiplier = 6500000000000000000000000900 + (stage - 549) * 1e200;
    } else if (stage <= 860) {
        attackMultiplier = 10000000000000000000000000000000 + (stage - 649) * 1e210;
    } else if (stage <= 900) {
        attackMultiplier = 100000000000000000000000000000000000 + (stage - 749) * 1e230;
    } else {
        attackMultiplier = 1000000000000000000000000000000000000000 + (stage - 849) * 1e250;
    }
    
    // 应用词条效果
    let attack = attackMultiplier;
    let damageReduction = 0;
    let dodgeChance = 0;
    let blockCount = 0;
    let attackCount = 1;
    let damageTakenMultiplier = 1;
    
    selectedModifiers.forEach(modifier => {
        const effect = monsterModifiers[modifier];
        if (effect.attackMultiplier) attack *= effect.attackMultiplier;
        if (effect.damageReduction) damageReduction += effect.damageReduction;
        if (effect.dodgeChance) dodgeChance += effect.dodgeChance;
        if (effect.blockCount) blockCount += effect.blockCount;
        if (effect.attackCount) attackCount = effect.attackCount;
        if (effect.damageTakenMultiplier) damageTakenMultiplier *= effect.damageTakenMultiplier;
    });
    
    // 生成怪物
    return {
        name: "宝藏守卫者",
        rank: rank,
        health: 10000 * healthMultiplier,
        attack: attack,
        modifiers: selectedModifiers,
        damageReduction: damageReduction,
        dodgeChance: dodgeChance,
        blockCount: blockCount,
        attackCount: attackCount,
        damageTakenMultiplier: damageTakenMultiplier
    };
}

// 在宝藏守卫者战斗中使用独立的属性生成
function startTreasureBattle(map) {
    const levelConfig = treasureMapLevels.find(l => l.level === map.level);
    
    // 使用独立的属性生成函数
    const monster = generateTreasureMonster(levelConfig.monsterMinStage, levelConfig.monsterMaxStage);
    
    // 保存战斗信息
    player.treasure.currentBattle = {
        map: map,
        monster: monster,
        playerHealth: player.battle.playerHealth,
        playerAttack: player.battle.playerAttack,
        playerCritRate: player.battle.playerCritRate,
        playerCritDamage: player.battle.playerCritDamage,
        battleEnded: false
    };
    
    // 更新战斗界面
    document.getElementById('treasurePlayerHealth').textContent = player.battle.playerHealth.toExponential(3);
    document.getElementById('treasurePlayerAttack').textContent = player.battle.playerAttack.toExponential(3);
    document.getElementById('treasurePlayerCritRate').textContent = (player.battle.playerCritRate * 100).toFixed(1) + "%";
    document.getElementById('treasurePlayerCritDamage').textContent = (player.battle.playerCritDamage * 100).toFixed(1) + "%";
    
    document.getElementById('treasureMonsterName').textContent = monster.name;
    document.getElementById('treasureMonsterRank').textContent = monster.rank;
    document.getElementById('treasureMonsterHealth').textContent = monster.health.toExponential(3);
    document.getElementById('treasureMonsterAttack').textContent = monster.attack.toExponential(3);
    document.getElementById('treasureMonsterModifiers').textContent = monster.modifiers.join(', ') || '无';
    
    document.getElementById('treasureBattleLog').innerHTML = "";
    
    // 显示战斗界面
    document.getElementById('treasureBattleOverlay').style.display = 'block';
    document.getElementById('treasureBattleUI').style.display = 'block';
}

// 攻击宝藏守卫者
function attackTreasureMonster() {
    if (!player.treasure.currentBattle) return;
    
    const battle = player.treasure.currentBattle;
   if (!battle || battle.battleEnded) return; // 检查战斗是否结束
    const logContainer = document.getElementById('treasureBattleLog');
    
    // 玩家攻击
    let playerDamage = battle.playerAttack;
    
    // 暴击判断
    if (Math.random() < battle.playerCritRate) {
        playerDamage *= battle.playerCritDamage;
        logContainer.innerHTML += `<div>你发动暴击，造成${Math.floor(playerDamage)}点伤害！</div>`;
    } else {
        logContainer.innerHTML += `<div>你造成${Math.floor(playerDamage)}点伤害</div>`;
    }
    
    battle.monster.health -= playerDamage;
    document.getElementById('treasureMonsterHealth').textContent = Math.max(0, battle.monster.health);
    
    // 检查怪物是否被击败
    if (battle.monster.health <= 0) {
        logContainer.innerHTML += `<div style="color: #4CAF50;">你击败了宝藏守卫者！</div>`;
        battle.battleEnded = true; // 标记战斗结束
        
        // 禁用攻击按钮
        const attackBtn = document.querySelector('#treasureBattleUI button');
        if (attackBtn) {
            attackBtn.disabled = true;
            attackBtn.style.background = '#999';
        }
        setTimeout(() => {
            giveTreasureRewards(battle.map, true);
            closeTreasureBattle();
           updateTreasureBattleStatus();
        }, 1000);
        return;
    }
    
    // 怪物反击
    let monsterDamage = battle.monster.attack;
    battle.playerHealth -= monsterDamage;
    document.getElementById('treasurePlayerHealth').textContent = Math.max(0, battle.playerHealth);
    logContainer.innerHTML += `<div>宝藏守卫者对你造成${Math.floor(monsterDamage)}点伤害</div>`;
    
    // 滚动到底部
    logContainer.scrollTop = logContainer.scrollHeight;
    
    // 检查玩家是否被击败
    if (battle.playerHealth <= 0) {
        logContainer.innerHTML += `<div style="color: #f44336;">你被宝藏守卫者击败了！</div>`;
          battle.battleEnded = true; // 标记战斗结束
        
        // 禁用攻击按钮
        const attackBtn = document.querySelector('#treasureBattleUI button');
        if (attackBtn) {
            attackBtn.disabled = true;
            attackBtn.style.background = '#999';
        }
        setTimeout(() => {
            showTreasureReward("战斗失败，没有获得任何奖励");
            closeTreasureBattle();     
        }, 1000);
    }
}

// 关闭宝藏战斗界面
function closeTreasureBattle() {
    document.getElementById('treasureBattleOverlay').style.display = 'none';
    document.getElementById('treasureBattleUI').style.display = 'none';
    player.treasure.currentBattle = null;
  const attackBtn = document.querySelector('#treasureBattleUI button');
        if (attackBtn) {
            attackBtn.disabled = false;
            attackBtn.style.background = '#999';
        }
}

// 给予藏宝图奖励
function giveTreasureRewards(map, isBattleWin) {
    const levelConfig = treasureMapLevels.find(l => l.level === map.level);
    const qualityConfig = treasureMapQualities.find(q => q.quality === map.quality);
    
    let rewardText = "";
    
    if (isBattleWin) {
        // 战斗胜利奖励：修仙经验
        const exp = levelConfig.expReward * qualityConfig.multiplier;
        player.cultivation.exp += exp;
      
        rewardText = `战斗胜利！获得${exp}点修仙经验`;
    if (Math.random() < 0.1) {
            player.items.roseq = (player.items.roseq || 0) + 1;
            rewardText += "<br>获得香囊x1！";
        }
    if (Math.random() < 0.01) {
            player.items.fuben1 = (player.items.fuben1 || 0) + 1;
            rewardText += "<br>获得副本令牌x1！";
        }
      if (Math.random() < 0.1) {
            player.items.fuben2 = (player.items.fuben2 || 0) + 1;
            rewardText += "<br>获得秘境钥匙x1！";
        }
      if (Math.random() < 0.01) {
            player.items.zhiye1 = (player.items.zhiye1 || 0) + 1;
            rewardText += "<br>获得职业转换书x1！";
        }
    if (Math.random() < 0.1) {
            player.items.primaryGemq = (player.items.primaryGemq || 0) + 1;
            rewardText += "<br>获得宝藏金币x1！";
        }
    } else {
        // 直接获得奖励：随机选择2个奖励
        const rewards = [];
        const rewardCount = 2;
        
        for (let i = 0; i < rewardCount; i++) {
            const rewardIndex = Math.floor(Math.random() * levelConfig.rewards.length);
            const reward = levelConfig.rewards[rewardIndex];
            const amount = Math.ceil(reward.amount * qualityConfig.multiplier);
            
            // 添加奖励到玩家物品
            player.items[reward.type] = (player.items[reward.type] || 0) + amount;
            
            // 获取奖励名称
            let rewardName = "";
            switch (reward.type) {
                case "baitCount": rewardName = "鱼饵"; break;
                case "companionKey": rewardName = "伴侣钥匙"; break;
                case "vipPower": rewardName = "VIP能力值"; break;
                case "rose": rewardName = "玫瑰花"; break;
                case "primaryGem": rewardName = "初级宝石"; break;
                case "advancedGem": rewardName = "高级宝石"; break;
                case "superiorGem": rewardName = "极品宝石"; break;
                case "divineGem": rewardName = "神级宝石"; break;
                case "rebornDan": rewardName = "洗髓丹"; break;
                case "rootDetector": rewardName = "灵根检测器"; break;
                case "bloodlineDetector": rewardName = "血脉检测剂"; break;
              case "advanceStone": rewardName = "进阶神石"; break;
             case "yuzhou1": rewardName = "星尘发票"; break;
                case "yuzhou2": rewardName = "暗物质发票"; break;
                case "yuzhou3": rewardName = "宇宙晶体发票"; break;
              case "yuzhou4": rewardName = "神器碎片发票"; break;
            case "banlv1": rewardName = "普通伴侣灵魂"; break;
             case "banlv2": rewardName = "稀有伴侣灵魂"; break;
             case "banlv7": rewardName = "天使伴侣灵魂"; break;
          case "banlv8": rewardName = "恶魔伴侣灵魂"; break;
          case "fuben1": rewardName = "副本令牌"; break;
         case "zhiye1": rewardName = "职业转换书"; break;
              case "banlv9": rewardName = "精灵伴侣灵魂"; break;       
            }
            
            rewards.push(`${rewardName} x${amount}`);
        }
        
        rewardText = `获得奖励：${rewards.join("，")}`;
    }
    
    showTreasureReward(rewardText);
}

// 显示藏宝图奖励
function showTreasureReward(message) {
    document.getElementById('treasureRewardContent').innerHTML = message;
    document.getElementById('treasureRewardOverlay').style.display = 'block';
    document.getElementById('treasureRewardUI').style.display = 'block';
}

// 关闭藏宝图奖励界面
function closeTreasureReward() {
    document.getElementById('treasureRewardOverlay').style.display = 'none';
    document.getElementById('treasureRewardUI').style.display = 'none';
}

// 在游戏加载时初始化藏宝图系统
function initTreasureMapSystem() {
    if (!player.treasure) {
        player.treasure = {
            keys: 0,
            maps: [],
            currentBattle: null
        };
    }
}
// 在战斗状态变化时更新状态提示
function updateTreasureBattleStatus() {
    const statusElement = document.getElementById('treasureBattleStatus');
    if (!statusElement) return;
    
    const battle = player.treasure.currentBattle;
    if (!battle) return;
    
    if (battle.battleEnded) {
        if (battle.monster.health <= 0) {
            statusElement.textContent = "战斗胜利";
            statusElement.style.color = "#4CAF50";
        } else if (battle.playerHealth <= 0) {
            statusElement.textContent = "战斗失败";
            statusElement.style.color = "#f44336";
        }
    } else {
        statusElement.textContent = "战斗中...";
        statusElement.style.color = "#FFC107";
    }
}
// 灵根配置
const rootConfig = {
    // 110%品阶
    tier1: [
        { name: "金灵根", bonus: 1.2 },
        { name: "木灵根", bonus: 1.2 },
        { name: "水灵根", bonus: 1.2 },
        { name: "火灵根", bonus: 1.25 },
        { name: "土灵根", bonus: 1.25 },
        { name: "雷灵根", bonus: 1.25 },
        { name: "杂灵根", bonus: 1.25 },
        { name: "钝金根", bonus: 1.2 },
        { name: "弱木根", bonus: 1.3 },
        { name: "浅水灵根", bonus: 1.3 },
        { name: "微火灵根", bonus: 1.3 },
        { name: "散土灵根", bonus: 1.4 },
        { name: "青禾根", bonus: 1.4 },
        { name: "溪水灵根", bonus: 1.4 },
        { name: "岩土根", bonus: 1.2 },
        { name: "铜铁根", bonus: 1.2 },
        { name: "三杂灵根", bonus: 1.2 },
        { name: "脆金根", bonus: 1.2 }
    ],
    // 200%品阶
    tier2: [
        { name: "深水灵根", bonus: 2.0 },
        { name: "炽火根", bonus: 2.0 },
        { name: "雷灵根", bonus: 2.0 },
        { name: "风灵根", bonus: 2.0 },
        { name: "冰灵根", bonus: 2.1 },
        { name: "沙灵根", bonus: 2.0 },
        { name: "雾灵根", bonus: 2.0 },
        { name: "藤木根", bonus: 2.0 },
        { name: "熔岩根", bonus: 2.0 },
        { name: "霜水灵根", bonus: 2.0 },
        { name: "晶金根", bonus: 2.0 },
        { name: "腐木根", bonus: 2.0 },
        { name: "冥水灵根", bonus: 2.1 },
        { name: "焦土根", bonus: 2.1 },
        { name: "双灵根", bonus: 2.1 },
        { name: "云灵根", bonus: 2.1 },
        { name: "毒木根", bonus: 2.1 },
        { name: "罡风根", bonus: 2.1 },
        { name: "寒铁根", bonus: 2.0 },
        { name: "焰木根", bonus: 2.1 },
        { name: "磁金根", bonus: 2.1 },
        { name: "酸水灵根", bonus: 2.0 }
    ],
    // 250%品阶
    tier3: [
        { name: "天灵根光", bonus: 2.5 },
        { name: "暗灵根", bonus: 2.5 },
        { name: "音灵根", bonus: 2.5 },
        { name: "影灵根", bonus: 2.5 },
        { name: "星辰灵根", bonus: 2.5 },
        { name: "月华灵根", bonus: 2.5 },
        { name: "日曦灵根", bonus: 2.5 },
        { name: "虚空灵根", bonus: 2.5 },
        { name: "时间灵根", bonus: 2.5 },
        { name: "圣灵根", bonus: 2.5 },
        { name: "魔灵根", bonus: 2.5 },
        { name: "晶玉灵根", bonus: 2.5 },
        { name: "云雾灵根", bonus: 2.5 },
        { name: "生死灵根", bonus: 2.5 },
        { name: "风火灵根", bonus: 2.5 },
        { name: "光暗灵根", bonus: 2.5 },
        { name: "山海灵根", bonus: 2.5 },
        { name: "混元灵根", bonus: 2.5 },
        { name: "灵植根", bonus: 2.5 },
        { name: "魂灵根", bonus: 2.5 }
    ],
    // 300%品阶
    tier4: [
        { name: "混沌灵根", bonus: 3.0 },
        { name: "鸿蒙灵根", bonus: 3.0 },
        { name: "先天灵根", bonus: 3.0 },
        { name: "虚无灵根", bonus: 3.0 },
        { name: "永恒灵根", bonus: 3.0 },
        { name: "本源灵根", bonus: 3.0 },
        { name: "万物灵根", bonus: 3.0 },
        { name: "太初灵根", bonus: 3.0 },
        { name: "轮回灵根", bonus: 3.0 }
    ],
    // 400%品阶
    tier5: [
        { name: "天道灵根", bonus: 4.0 },
        { name: "星辰本源根", bonus: 4.0 },
        { name: "混沌雷灵根", bonus: 4.0 },
        { name: "寂灭灵根", bonus: 4.0 },
        { name: "太极灵根", bonus: 4.0 }
    ],
    // 500%品阶
    tier6: [
        { name: "大道灵根", bonus: 5.0 },
        { name: "虚空混沌根", bonus: 5.0 },
        { name: "万化灵根", bonus: 5.0 },
        { name: "创世灵根", bonus: 5.0 }
    ],
    // 1000%品阶
    tier7: [
        { name: "无垢灵根", bonus: 10.0 }
    ]
};
const bloodlineConfig = {
    tier1: [
        { name: "凡骨血脉", bonus: 1.0 },
        { name: "麻瓜血脉", bonus: 1.0 },
        { name: "健魄血脉", bonus: 1.0 },
        { name: "灵慧血脉", bonus: 1.0 },
        { name: "野猪血脉", bonus: 1.0 },
        { name: "捷足血脉", bonus: 1.2 },
        { name: "锐目血脉", bonus: 1.2 },
        { name: "佩奇血脉", bonus: 1.2 },
        { name: "稳心血脉", bonus: 1.2 },
        { name: "厚土血脉", bonus: 1.2 }
    ],
    tier2: [
        { name: "天雷血脉", bonus: 1.3 },
        { name: "雷霆血脉", bonus: 1.3 },
        { name: "妖皇血脉", bonus: 1.3 },
        { name: "格斗神血脉", bonus: 1.3 },
        { name: "法神血脉", bonus: 1.3 },
        { name: "拳神血脉", bonus: 1.3 },
        { name: "命运血脉", bonus: 1.3 },
        { name: "太古大妖血脉", bonus: 1.3 },
        { name: "龙族血脉", bonus: 1.4 },
        { name: "邪神血脉", bonus: 1.4 },
        { name: "金龙王血脉", bonus: 1.4 },
        { name: "吞天血脉", bonus: 1.4 },
        { name: "鲲鹏血脉", bonus: 1.4 },
        { name: "穷奇血脉", bonus: 1.4 },
        { name: "灵狐血脉", bonus: 1.4 },
        { name: "烛龙血脉", bonus: 1.4 },
        { name: "神羽血脉", bonus: 1.4 }
    ],
    tier3: [
        { name: "瑞兽血脉", bonus: 1.5 },
        { name: "涅槃血脉", bonus: 1.5 },
        { name: "混沌神魔血脉", bonus: 1.5 },
        { name: "万界诸神血脉", bonus: 1.5 },
        { name: "剑神血脉", bonus: 1.5 },
        { name: "冥魂血脉", bonus: 1.5 },
        { name: "御世血脉", bonus: 1.6 },
        { name: "陆吾血脉", bonus: 1.6 },
        { name: "破邪血脉", bonus: 1.6 },
        { name: "蛟龙血脉", bonus: 1.6 },
        { name: "太阳之子血脉", bonus: 1.6 },
        { name: "大帝血脉", bonus: 1.6 }
    ],
    tier4: [
        { name: "麒麟血脉", bonus: 1.8 },
        { name: "玄武血脉", bonus: 1.8 },
        { name: "白虎血脉", bonus: 1.8 },
        { name: "齐天大圣血脉", bonus: 1.8 },
        { name: "黑山老妖血脉", bonus: 1.8 },
        { name: "神鸡血脉", bonus: 1.8 },
        { name: "宇智波血脉", bonus: 1.8 },
        { name: "漩涡血脉", bonus: 1.8 },
        { name: "疾风迅雷血脉", bonus: 1.8 }
    ],
    tier5: [
        { name: "朱雀血脉", bonus: 2.1 },
        { name: "青龙血脉", bonus: 2.1 },
        { name: "金刚不坏血脉", bonus: 2.5 },
        { name: "万钧巨力血脉", bonus: 2.1 },
        { name: "瞬影血脉", bonus: 2.5 },
        { name: "破妄真瞳血脉", bonus: 2.0 }
    ],
    tier6: [
        { name: "吞天噬地血脉", bonus: 2.5 },
        { name: "星辰之力血脉", bonus: 3.0 },
        { name: "大地脉动血脉", bonus: 3.0 },
        { name: "九天罡风血脉", bonus: 3.0 },
        { name: "幽冥暗影血脉", bonus: 3.0 }
    ],
    tier7: [
        { name: "鸿蒙紫气血脉", bonus: 4.0 },
        { name: "混沌本源血脉", bonus: 4.0 },
        { name: "万象森罗血脉", bonus: 4.0 },
        { name: "诸天法则血脉", bonus: 4.0 }
    ],
    tier8: [
        { name: "永恒不朽血脉", bonus: 5.0 },
        { name: "创世之光血脉", bonus: 5.0 },
        { name: "灭世之影血脉", bonus: 5.0 }
    ],
    tier9: [
        { name: "至高无上血脉", bonus: 10.0 }
    ]
};
// 修仙阶段配置
const cultivationStages = [
    { name: "凡人", expRequired: 0, multiplier: 1 },
    { name: "练气", expRequired: 10000, multiplier: 2 },
    { name: "筑基", expRequired: 20000, multiplier: 3 },
    { name: "灵动", expRequired: 40000, multiplier: 4 },
    { name: "灵虚", expRequired: 60000, multiplier: 5 },
    { name: "灵寂", expRequired: 80000, multiplier: 6 },
    { name: "开光", expRequired: 100000, multiplier: 7 },
    { name: "融合", expRequired: 200000, multiplier: 8 },
    { name: "聚丹", expRequired: 300000, multiplier: 9 },
    { name: "凝丹", expRequired: 400000, multiplier: 10 },
    { name: "韵丹", expRequired: 500000, multiplier: 15 },
    { name: "结丹", expRequired: 600000, multiplier: 20 },
    { name: "金丹", expRequired: 700000, multiplier: 25 },
    { name: "聚婴", expRequired: 800000, multiplier: 30 },
    { name: "凝婴", expRequired: 900000, multiplier: 35 },
    { name: "结婴", expRequired: 1000000, multiplier: 40 },
    { name: "元婴", expRequired: 1250000, multiplier: 45 },
    { name: "婴变", expRequired: 1500000, multiplier: 50 },
    { name: "出窍", expRequired: 1750000, multiplier: 55 },
    { name: "元神", expRequired: 2000000, multiplier: 60 },
    { name: "分神", expRequired: 2250000, multiplier: 65 },
    { name: "化神", expRequired: 2500000, multiplier: 70 },
    { name: "洞虚", expRequired: 2750000, multiplier: 75 },
    { name: "化虚", expRequired: 3000000, multiplier: 80 },
    { name: "返虚", expRequired: 3250000, multiplier: 85 },
    { name: "合体", expRequired: 3500000, multiplier: 90 },
    { name: "合灵", expRequired: 4000000, multiplier: 95 },
    { name: "合魂", expRequired: 4500000, multiplier: 100 },
    { name: "空冥", expRequired: 5000000, multiplier: 150 },
    { name: "寂灭", expRequired: 5250000, multiplier: 200 },
    { name: "问鼎", expRequired: 5500000, multiplier: 250 },
    { name: "问道", expRequired: 5750000, multiplier: 300 },
    { name: "合道", expRequired: 6000000, multiplier: 350 },
    { name: "大帝", expRequired: 6250000, multiplier: 400 },
    { name: "半仙", expRequired: 6500000, multiplier: 450 },
    { name: "渡劫", expRequired: 6750000, multiplier: 500 },
    { name: "人仙", expRequired: 7000000, multiplier: 550 },
    { name: "真仙", expRequired: 7250000, multiplier: 600 },
    { name: "上仙", expRequired: 7500000, multiplier: 650 },
    { name: "地仙", expRequired: 7750000, multiplier: 700 },
    { name: "天仙", expRequired: 8000000, multiplier: 750 },
    { name: "玄仙", expRequired: 8250000, multiplier: 800 },
    { name: "太乙", expRequired: 8500000, multiplier: 850 },
    { name: "九天", expRequired: 8750000, multiplier: 900 },
    { name: "金仙", expRequired: 9000000, multiplier: 950 },
    { name: "仙将", expRequired: 9250000, multiplier: 1000 },
    { name: "仙君", expRequired: 9500000, multiplier: 1500 },
    { name: "仙王", expRequired: 9750000, multiplier: 2000 },
    { name: "仙皇", expRequired: 10000000, multiplier: 2500 },
    { name: "仙尊", expRequired: 15000000, multiplier: 3000 },
    { name: "仙帝", expRequired: 20000000, multiplier: 3500 },
    { name: "半圣", expRequired: 25000000, multiplier: 4000 },
    { name: "真圣", expRequired: 30000000, multiplier: 4500 },
    { name: "人圣", expRequired: 35000000, multiplier: 5000 },
    { name: "地圣", expRequired: 40000000, multiplier: 5500 },
    { name: "天圣", expRequired: 45000000, multiplier: 6000 },
    { name: "玄圣", expRequired: 50000000, multiplier: 6500 },
    { name: "大圣", expRequired: 55000000, multiplier: 7000 },
    { name: "金圣", expRequired: 60000000, multiplier: 7500 },
    { name: "圣将", expRequired: 65000000, multiplier: 8000 },
    { name: "圣君", expRequired: 70000000, multiplier: 8500 },
    { name: "圣王", expRequired: 75000000, multiplier: 9000 },
    { name: "圣皇", expRequired: 80000000, multiplier: 9500 },
    { name: "圣尊", expRequired: 85000000, multiplier: 10000 },
    { name: "圣帝", expRequired: 90000000, multiplier: 12000 },
    { name: "半神", expRequired: 95000000, multiplier: 14000 },
    { name: "真神", expRequired: 100000000, multiplier: 16000 },
    { name: "人神", expRequired: 150000000, multiplier: 18000 },
    { name: "地神", expRequired: 200000000, multiplier: 20000 },
    { name: "天神", expRequired: 250000000, multiplier: 22000 },
    { name: "玄神", expRequired: 300000000, multiplier: 24000 },
    { name: "金神", expRequired: 350000000, multiplier: 26000 },
    { name: "神将", expRequired: 400000000, multiplier: 28000 },
    { name: "神灵", expRequired: 450000000, multiplier: 30000 },
    { name: "神王", expRequired: 500000000, multiplier: 32000 },
    { name: "神皇", expRequired: 550000000, multiplier: 34000 },
    { name: "神宗", expRequired: 600000000, multiplier: 36000 },
    { name: "神尊", expRequired: 650000000, multiplier: 38000 },
    { name: "神帝", expRequired: 700000000, multiplier: 40000 },
    { name: "荒帝", expRequired: 750000000, multiplier: 42000 },
    { name: "太荒", expRequired: 800000000, multiplier: 44000 },
    { name: "仙荒", expRequired: 850000000, multiplier: 46000 },
    { name: "神荒", expRequired: 900000000, multiplier: 48000 },
    { name: "荒古", expRequired: 1000000000, multiplier: 50000 },
    { name: "荒祖", expRequired: 1500000000, multiplier: 52000 },
    { name: "始荒", expRequired: 2000000000, multiplier: 54000 },
    { name: "人道", expRequired: 2500000000, multiplier: 56000 },
    { name: "天道", expRequired: 3000000000, multiplier: 58000 },
    { name: "仙道", expRequired: 3500000000, multiplier: 60000 },
    { name: "神道", expRequired: 4000000000, multiplier: 62000 },
    { name: "帝道", expRequired: 4500000000, multiplier: 64000 },
    { name: "轮回", expRequired: 5000000000, multiplier: 66000 },
    { name: "时空", expRequired: 5500000000, multiplier: 68000 },
    { name: "乾坤", expRequired: 6000000000, multiplier: 70000 },
    { name: "规则", expRequired: 6500000000, multiplier: 72000 },
    { name: "始祖", expRequired: 7000000000, multiplier: 74000 },
    { name: "元神", expRequired: 7500000000, multiplier: 76000 },
    { name: "人神", expRequired: 8000000000, multiplier: 78000 },
    { name: "仙神", expRequired: 8500000000, multiplier: 80000 },
    { name: "帝神", expRequired: 9000000000, multiplier: 82000 },
    { name: "主宰", expRequired: 9500000000, multiplier: 84000 },
    { name: "统治者", expRequired: 10000000000, multiplier: 86000 }

];

// 初始化修仙系统
function initCultivationSystem() {
    if (!player.cultivation) {
        player.cultivation = {
            stage: 0, // 当前阶段索引
            exp: 0,   // 当前经验值
            root: null, // 当前灵根
            bloodline: null,
           bonus: 1 
        };
    }
}

// 切换修仙系统界面
function toggleCultivationSystem() {
    if (player.reincarnationCount < 500) {
        alert("需要达到500转才能开启修仙系统！");
        return;
    }
    initCultivationSystem();
    
    const ui = document.getElementById('cultivationSystemUI');
    const overlay = document.getElementById('cultivationSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateCultivationUI();
    }
}


function updateCultivationUI() {
    // 获取当前阶段信息
    const stageIndex = player.cultivation.stage;
    const stage = cultivationStages[stageIndex];
    
    // 确保阶段信息存在
    if (!stage) {
        console.error("无效的修仙阶段索引:", stageIndex);
        return;
    }
    
    // 更新当前阶段显示
    document.getElementById('currentStageq').textContent = stage.name;
    
    // 其他更新逻辑保持不变...
    const nextStage = cultivationStages[stageIndex + 1];
    
    // 更新灵根信息
    const rootInfo = document.getElementById('currentRootInfo');
    if (player.cultivation.root) {
        rootInfo.innerHTML = `
            <div style="font-size: 18px; font-weight: bold; color: #FFD700;">${player.cultivation.root.name}</div>
            <div>加成: ${player.cultivation.root.bonus * 100}%</div>
        `;
    } else {
        rootInfo.textContent = "尚未检测灵根";
    }
     const bloodlineInfo = document.getElementById('currentBloodlineInfo');
    if (player.cultivation.bloodline) {
        bloodlineInfo.innerHTML = `
            <div style="font-size: 18px; font-weight: bold; color: #d4af37;">${player.cultivation.bloodline.name}</div>
            <div>加成: ${player.cultivation.bloodline.bonus * 100}%</div>
        `;
    } else {
        bloodlineInfo.textContent = "尚未检测血脉";
    }
    // 更新阶段信息
    document.getElementById('stageLevel').textContent = stageIndex;
    document.getElementById('currentExp').textContent = player.cultivation.exp.toFixed(0);
    
    if (nextStage) {
        document.getElementById('nextExp').textContent = nextStage.expRequired;
        
        // 计算经验进度
        const progress = Math.min(100, (player.cultivation.exp / nextStage.expRequired) * 100);
        document.getElementById('expProgress').style.width = `${progress}%`;
    } else {
        document.getElementById('nextExp').textContent = "已达最高境界";
        document.getElementById('expProgress').style.width = '100%';
    }
    
    // 更新加成信息
    document.getElementById('gpsMultiplier').textContent = stage.multiplier;
}
// 打开灵根宝箱界面
function openRootBox() {
    if (player.items.rootDetector < 1) {
        logAction("灵根检测器不足！", "error");
        return;
    }
    
    document.getElementById('rootBoxUI').style.display = 'block';
    document.getElementById('rootBoxOverlay').style.display = 'block';
    document.getElementById('rootResult').textContent = "点击开启获取灵根";
}

// 关闭灵根宝箱界面
function closeRootBox() {
    document.getElementById('rootBoxUI').style.display = 'none';
    document.getElementById('rootBoxOverlay').style.display = 'none';
}

// 抽取灵根
function drawRoot() {
    if (player.items.rootDetector < 1) {
        logAction("灵根检测器不足！", "error");
        return;
    }
    
    player.items.rootDetector--;
    
    // 根据概率抽取灵根品阶
    const rand = Math.random();
    let tier;
    
    if (rand < 0.8) {
        tier = "tier1"; // 80%
    } else if (rand < 0.95) {
        tier = "tier2"; // 15%
    } else if (rand < 0.998889) {
        tier = "tier3"; // 4.8889%
    } else if (rand < 0.999889) {
        tier = "tier4"; // 0.1%
    } else if (rand < 0.999989) {
        tier = "tier5"; // 0.01%
    } else if (rand < 0.999999) {
        tier = "tier6"; // 0.001%
    } else {
        tier = "tier7"; // 0.0001%
    }
    
    // 随机选择该品阶中的一个灵根
    const roots = rootConfig[tier];
    const root = roots[Math.floor(Math.random() * roots.length)];
    
    // 更新玩家灵根
    player.cultivation.root = root;
    
    // 显示结果
    document.getElementById('rootResult').innerHTML = `
        <div style="font-size: 20px; font-weight: bold; color: #FFD700;">获得${root.name}!</div>
        <div>加成: ${root.bonus * 100}%</div>
    `;
    
    logAction(`获得灵根: ${root.name} (加成${root.bonus * 100}%)`, "success");
    updateCultivationUI();
    updateDisplay();
}
// 打开血脉宝箱
function openBloodlineBox() {
    if (player.items.bloodlineDetector < 1) {
        logAction("血脉检测剂不足！", "error");
        return;
    }
    
    document.getElementById('bloodlineBoxUI').style.display = 'block';
    document.getElementById('bloodlineBoxOverlay').style.display = 'block';
    document.getElementById('bloodlineResult').textContent = "点击开启获取血脉";
}

// 关闭血脉宝箱
function closeBloodlineBox() {
    document.getElementById('bloodlineBoxUI').style.display = 'none';
    document.getElementById('bloodlineBoxOverlay').style.display = 'none';
}

// 抽取血脉
function drawBloodline() {
    if (player.items.bloodlineDetector < 1) {
        logAction("血脉检测剂不足！", "error");
        return;
    }
    
    player.items.bloodlineDetector--;
    
    // 根据概率抽取血脉品阶
    const rand = Math.random();
    let tier;
    
    if (rand < 0.8) {
        tier = "tier1"; // 80%
    } else if (rand < 0.95) {
        tier = "tier2"; // 15%
    } else if (rand < 0.998889) {
        tier = "tier3"; // 4.8889%
    } else if (rand < 0.999889) {
        tier = "tier4"; // 0.1%
    } else if (rand < 0.999989) {
        tier = "tier5"; // 0.01%
    } else if (rand < 0.999999) {
        tier = "tier6"; // 0.001%
    } else if (rand < 0.9999999) {
        tier = "tier7"; // 0.0001%
    } else if (rand < 0.99999999) {
        tier = "tier8"; // 0.00001%
    } else {
        tier = "tier9"; // 0.000001%
    }
    
    // 随机选择该品阶中的一个血脉
    const bloodlines = bloodlineConfig[tier];
    const bloodline = bloodlines[Math.floor(Math.random() * bloodlines.length)];
    
    // 更新玩家血脉
    player.cultivation.bloodline = bloodline;
    
    // 显示结果
    document.getElementById('bloodlineResult').innerHTML = `
        <div style="font-size: 20px; font-weight: bold; color: #FFD700;">获得${bloodline.name}!</div>
        <div>加成: ${bloodline.bonus * 100}%</div>
    `;
    
    logAction(`获得血脉: ${bloodline.name} (加成${bloodline.bonus * 100}%)`, "success");
    updateCultivationUI();
    updateDisplay();
}
// 升级修仙阶段
function upgradeCultivation() {
    console.log("升级前阶段:", player.cultivation.stage);
    
    const nextStageIndex = player.cultivation.stage + 1;
    
    // 检查是否有下一阶段
    if (nextStageIndex >= cultivationStages.length) {
        logAction("已达最高境界，无法继续升级", "info");
        return;
    }
    
    const nextStage = cultivationStages[nextStageIndex];
    
    // 检查经验是否足够
    if (player.cultivation.exp < nextStage.expRequired) {
        logAction("经验不足，无法升级", "error");
        return;
    }
    
    // 扣除经验并升级
    player.cultivation.exp -= nextStage.expRequired;
    player.cultivation.stage = nextStageIndex;
    
    console.log("升级后阶段:", player.cultivation.stage);
    logAction(`成功晋升${nextStage.name}境界！`, "success");
    
    // 更新显示
    updateDisplay();
    updateCultivationUI(); // 如果修仙界面打开，也需要更新
}

// 每分钟获取经验
function gainCultivationExp() {
   if (!player.cultivation || !player.cultivation.root || !player.cultivation.bloodline) return;
    
    // 每分钟经验 = 转生次数 × 灵根加成
   const rootBonus = player.cultivation.root.bonus;
    const bloodlineBonus = player.cultivation.bloodline.bonus;
    const expGain = (rootBonus * bloodlineBonus) * player.reincarnationCount;
    player.cultivation.exp += expGain/60;
    const stage = cultivationStages[player.cultivation.stage];
    player.cultivation.bonus = stage.multiplier;
    // 更新UI
 document.getElementById('currentExpPerMinute').textContent = expGain.toFixed(2);
  updateDisplay();
    updateCultivationUI();
}
// 计算离线经验
function calculateOfflineCultivationExp(offlineMinutes) {
    if (!player.cultivation || !player.cultivation.root || !player.cultivation.bloodline) return;
     const rootBonus = player.cultivation.root.bonus;
    const bloodlineBonus = player.cultivation.bloodline.bonus;
    const expGain = offlineMinutes * (rootBonus * bloodlineBonus) * player.reincarnationCount;
    player.cultivation.exp += expGain;
    
    logAction(`离线获得${expGain}点修仙经验`, "info");
}

// 称号配置（按分支分组）
const titleConfig = {
     towerBranyy: [
    { name: "钓竿初握", condition: (p) => p.fishing.level > 2, bonus: { attackMultiplier: 1.1 } },
    { name: "河塘渔夫", condition: (p) => p.fishing.level > 5, bonus: { attackMultiplier: 1.1 } },
    { name: "渔获大师", condition: (p) => p.fishing.level > 7, bonus: { attackMultiplier: 1.1 } },
    { name: "万鱼臣服", condition: (p) => p.fishing.level > 10, bonus: { attackMultiplier: 1.2 } },
    { name: "钓尽乾坤", condition: (p) => p.fishing.level > 14, bonus: { attackMultiplier: 1.2 } },
    { name: "小农夫", condition: (p) => p.farm.level > 2, bonus: { attackMultiplier: 1.1 } },
    { name: "田园熟手", condition: (p) => p.farm.level > 5, bonus: { attackMultiplier: 1.1 } },
    { name: "农耕大师", condition: (p) => p.farm.level > 15, bonus: { attackMultiplier: 1.1 } },
    { name: "庄园尊主", condition: (p) => p.farm.level > 25, bonus: { attackMultiplier: 1.2 } },
    { name: "大地主宰", condition: (p) => p.farm.level > 35, bonus: { attackMultiplier: 1.2 } },
    { name: "车途学徒", condition: (p) => p.parking.level > 2, bonus: { attackMultiplier: 1.1 } },
    { name: "赛道枭雄", condition: (p) => p.parking.level > 7, bonus: { attackMultiplier: 1.1 } },
    { name: "车坛至尊", condition: (p) => p.parking.level > 14, bonus: { attackMultiplier: 1.1 } },
    { name: "巅峰车皇", condition: (p) => p.parking.level > 24, bonus: { attackMultiplier: 1.2 } },
    { name: "寰宇车神", condition: (p) => p.parking.level > 34, bonus: { attackMultiplier: 1.2 } },
    { name: "创世车帝", condition: (p) => p.parking.level > 39, bonus: { attackMultiplier: 1.2 } },
    { name: "百万元户", condition: (p) => p.landlord.stats.totalCoinsEarned > 1000000, bonus: { healthMultiplier: 1.1 } },
    { name: "千万富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 10000000, bonus: { healthMultiplier: 1.1 } },
    { name: "亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 100000000, bonus: { healthMultiplier: 1.1 } },
    { name: "十亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 1000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "百亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 10000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "千亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 100000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "万亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 1000000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "高富帅", condition: (p) => p.landlord.stats.totalCoinsEarned > 10000000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "股侠", condition: (p) => p.investmentGame.userData.availableFunds > 100000, bonus: { healthMultiplier: 1.1 } },
    { name: "股霸", condition: (p) => p.investmentGame.userData.availableFunds > 10000000, bonus: { healthMultiplier: 1.1 } },
    { name: "股王", condition: (p) => p.investmentGame.userData.availableFunds > 1000000000, bonus: { healthMultiplier: 1.1 } },
    { name: "股圣", condition: (p) => p.investmentGame.userData.availableFunds > 100000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "股神", condition: (p) => p.investmentGame.userData.availableFunds > 10000000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "股仙", condition: (p) => p.investmentGame.userData.availableFunds > 1000000000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "萌新矿工", condition: (p) => p.mining.depth > 1000, bonus: { attackMultiplier: 1.1 } },
    { name: "勤奋矿工", condition: (p) => p.mining.depth > 10000, bonus: { attackMultiplier: 1.1 } },
    { name: "黄金矿工", condition: (p) => p.mining.depth > 100000, bonus: { attackMultiplier: 1.1 } },
    { name: "钻石矿工", condition: (p) => p.mining.depth > 1000000, bonus: { attackMultiplier: 1.2 } },
    { name: "星辰矿工", condition: (p) => p.mining.depth > 10000000, bonus: { attackMultiplier: 1.2 } },
    { name: "创世矿工神", condition: (p) => p.mining.depth > 100000000, bonus: { attackMultiplier: 1.2 } }
   ], 
     towerBranch: [
    { name: "关破厉鬼", condition: (p) => p.tower.maxFloor > 10, bonus: { healthMultiplier: 1.1 } },
    { name: "阶碎无常", condition: (p) => p.tower.maxFloor > 500, bonus: { healthMultiplier: 1.1 } },
    { name: "踏塔马面", condition: (p) => p.tower.maxFloor > 1000, bonus: { healthMultiplier: 1.1 } },
    { name: "魔修夜叉", condition: (p) => p.tower.maxFloor > 5000, bonus: { healthMultiplier: 1.1 } },
    { name: "破阶修罗", condition: (p) => p.tower.maxFloor > 7500, bonus: { healthMultiplier: 1.1 } },
    { name: "千层煞主", condition: (p) => p.tower.maxFloor > 10000, bonus: { healthMultiplier: 1.1 } },
    { name: "踏关煞神", condition: (p) => p.tower.maxFloor > 25000, bonus: { healthMultiplier: 1.1 } },
    { name: "关前冥王", condition: (p) => p.tower.maxFloor > 50000, bonus: { healthMultiplier: 1.1 } },
    { name: "踏塔狂魔", condition: (p) => p.tower.maxFloor > 75000, bonus: { healthMultiplier: 1.1 } },
    { name: "混世魔王", condition: (p) => p.tower.maxFloor > 100000, bonus: { healthMultiplier: 1.1 } },
    { name: "屠戮之主", condition: (p) => p.tower.maxFloor > 150000, bonus: { healthMultiplier: 1.2 } },
    { name: "杀戮之神", condition: (p) => p.tower.maxFloor > 200000, bonus: { healthMultiplier: 1.2 } },
    { name: "十殿阎罗", condition: (p) => p.tower.maxFloor > 250000, bonus: { healthMultiplier: 1.2 } },
    { name: "弑神修罗", condition: (p) => p.tower.maxFloor > 300000, bonus: { healthMultiplier: 1.2 } },
    { name: "九幽魔尊", condition: (p) => p.tower.maxFloor > 350000, bonus: { healthMultiplier: 1.2 } },
    { name: "永夜君主", condition: (p) => p.tower.maxFloor > 400000, bonus: { healthMultiplier: 1.2 } },
    { name: "深渊主宰", condition: (p) => p.tower.maxFloor > 450000, bonus: { healthMultiplier: 1.2 } }
],
    // 关卡分支
    stageBranch: [
        { name: "探险者", condition: (p) => p.battle.maxStage > 10, bonus: { attackMultiplier: 1.1 } },
        { name: "银翼斥候", condition: (p) => p.battle.maxStage > 100, bonus: { attackMultiplier: 1.1 } },
        { name: "圣域行者", condition: (p) => p.battle.maxStage > 250, bonus: { attackMultiplier: 1.1 } },
        { name: "苍穹之主", condition: (p) => p.battle.maxStage > 500, bonus: { attackMultiplier: 1.1 } },
        { name: "九天至尊", condition: (p) => p.battle.maxStage > 1000, bonus: { attackMultiplier: 1.2 } },
        { name: "万域之主", condition: (p) => p.battle.maxStage > 1500, bonus: { attackMultiplier: 1.2 } },
        { name: "寰宇独尊", condition: (p) => p.battle.maxStage > 2000, bonus: { attackMultiplier: 1.2 } },
        { name: "万界臣服", condition: (p) => p.battle.maxStage > 2500, bonus: { attackMultiplier: 1.3 } },
        { name: "天地共主", condition: (p) => p.battle.maxStage > 3000, bonus: { attackMultiplier: 1.4 } },
        { name: "星河主宰", condition: (p) => p.battle.maxStage > 3500, bonus: { attackMultiplier: 1.4 } },
        { name: "太虚之皇", condition: (p) => p.battle.maxStage > 4000, bonus: { attackMultiplier: 1.5 } },
        { name: "六道归一", condition: (p) => p.battle.maxStage > 4500, bonus: { attackMultiplier: 1.5 } }
    ],
    // 转生分支
    reincarnationBranch: [
        { name: "初涉江湖", condition: (p) => p.reincarnationCount > 5, bonus: { healthMultiplier: 1.2 } },
        { name: "俗世门徒", condition: (p) => p.reincarnationCount > 10, bonus: { healthMultiplier: 1.2 } },
        { name: "人中龙凤", condition: (p) => p.reincarnationCount > 50, bonus: { healthMultiplier: 1.2 } },
        { name: "一方翘楚", condition: (p) => p.reincarnationCount > 100, bonus: { healthMultiplier: 1.2 } },
        { name: "超凡入圣", condition: (p) => p.reincarnationCount > 250, bonus: { healthMultiplier: 1.2 } },
        { name: "一代宗师", condition: (p) => p.reincarnationCount > 500, bonus: { healthMultiplier: 1.2 } },
        { name: "盖世之才", condition: (p) => p.reincarnationCount > 1000, bonus: { healthMultiplier: 1.2 } },
        { name: "众仙之师", condition: (p) => p.reincarnationCount > 2000, bonus: { healthMultiplier: 1.2 } },
        { name: "创世之灵", condition: (p) => p.reincarnationCount > 3000, bonus: { healthMultiplier: 1.2 } },
        { name: "万神之主", condition: (p) => p.reincarnationCount > 5000, bonus: { healthMultiplier: 1.2 } },
        { name: "无上真神", condition: (p) => p.reincarnationCount > 10000, bonus: { healthMultiplier: 1.2 } },
        { name: "寰宇神尊", condition: (p) => p.reincarnationCount > 50000, bonus: { healthMultiplier: 1.2 } },
        { name: "创世神帝", condition: (p) => p.reincarnationCount > 100000, bonus: { healthMultiplier: 1.2 } }
    ],
    // 驯兽师分支
    tamerBranch: [
        { name: "初级驯兽师", condition: (p) => p.pets?.thunderKirin?.level > 50, bonus: { critMultiplier: 1.1 } },
        { name: "中级驯兽师", condition: (p) => p.pets?.netherQiongqi?.level > 30, bonus: { critMultiplier: 1.1 } },
        { name: "高级驯兽师", condition: (p) => p.pets?.primordialZhuLong?.level > 10, bonus: { critMultiplier: 1.2 } },
        { name: "圣级驯兽师", condition: (p) => p.pets?.yanYuBiAn?.level > 10, bonus: { critMultiplier: 1.2 } },
        { name: "神级驯兽师", condition: (p) => p.pets?.yuyu2?.level > 10, bonus: { critMultiplier: 1.3 } },
        { name: "人级驯兽师", condition: (p) => p.pets?.yuyu3?.level > 10, bonus: { critMultiplier: 1.3 } },
        { name: "地级驯兽师", condition: (p) => p.pets?.yuyu4?.level > 10, bonus: { critMultiplier: 1.4 } },
        { name: "天级驯兽师", condition: (p) => p.pets?.yuyu5?.level > 10, bonus: { critMultiplier: 1.4 } },
        { name: "帝级驯兽师", condition: (p) => p.pets?.yuyu6?.level > 10, bonus: { critMultiplier: 1.4 } },
        { name: "仙级驯兽师", condition: (p) => p.pets?.yuyu7?.level > 10, bonus: { critMultiplier: 1.5 } },
        { name: "创世级驯兽师", condition: (p) => p.pets?.yuyu8?.level > 10, bonus: { critMultiplier: 1.5 } }
    ],
    // 魂环分支
    soulRingBranch: [
        { name: "魂士", condition: (p) => hasSoulRing(p, "year1"), bonus: { attackMultiplier: 1.1 } },
        { name: "魂师", condition: (p) => hasSoulRing(p, "year100"), bonus: { attackMultiplier: 1.1 } },
        { name: "大魂师", condition: (p) => hasSoulRing(p, "year10000"), bonus: { attackMultiplier: 1.2 } },
        { name: "魂尊", condition: (p) => hasSoulRing(p, "year1000000"), bonus: { attackMultiplier: 1.2 } },
        { name: "魂宗", condition: (p) => hasSoulRing(p, "year3"), bonus: { attackMultiplier: 1.3 } },
        { name: "魂王", condition: (p) => hasSoulRing(p, "year7"), bonus: { attackMultiplier: 1.3 } },
        { name: "魂帝", condition: (p) => hasSoulRing(p, "year13"), bonus: { attackMultiplier: 1.3 } },
        { name: "魂圣", condition: (p) => hasSoulRing(p, "year18"), bonus: { attackMultiplier: 1.4 } },
        { name: "魂斗罗", condition: (p) => hasSoulRing(p, "year23"), bonus: { attackMultiplier: 1.4 } },
        { name: "普通封号斗罗", condition: (p) => hasSoulRing(p, "year28"), bonus: { attackMultiplier: 1.5 } },
        { name: "巅峰斗罗", condition: (p) => hasSoulRing(p, "year33"), bonus: { attackMultiplier: 1.5 } },
        { name: "绝世斗罗", condition: (p) => hasSoulRing(p, "year37"), bonus: { attackMultiplier: 1.5 } }
    ],
    // 特殊分支
    specialBranch: [
        { name: "萌新", condition: (p) => p.gold > 100000000000000, bonus: { attackMultiplier: 1.1 } },
        { name: "公测玩家", condition: (p) => p.usedActivationCodes.includes("VIP666777"), bonus: { attackMultiplier: 1.2 } },
        { name: "持剑学徒", condition: (p) => getEquipLevel(p, "废品") > 1, bonus: { attackMultiplier: 1.1 } },
        { name: "疾风剑者", condition: (p) => getEquipLevel(p, "废品") > 1000, bonus: { attackMultiplier: 1.1 } },
        { name: "断水剑师", condition: (p) => getEquipLevel(p, "废品") > 10000, bonus: { attackMultiplier: 1.1 } },
        { name: "九霄剑王", condition: (p) => getEquipLevel(p, "废品") > 100000, bonus: { attackMultiplier: 1.1 } },
        { name: "独孤剑皇", condition: (p) => getEquipLevel(p, "废品") > 500000, bonus: { attackMultiplier: 1.1 } },
        { name: "剑域之主", condition: (p) => getEquipLevel(p, "废品") > 1000000, bonus: { attackMultiplier: 1.2 } },
        { name: "万剑之神", condition: (p) => getEquipLevel(p, "废品") > 5000000, bonus: { attackMultiplier: 1.2 } },
        { name: "鸿蒙剑祖", condition: (p) => getEquipLevel(p, "废品") > 10000000, bonus: { attackMultiplier: 1.2 } },
        { name: "万劫剑神", condition: (p) => getEquipLevel(p, "废品") > 50000000, bonus: { attackMultiplier: 1.3 } },
        { name: "无上剑神", condition: (p) => getEquipLevel(p, "废品") > 100000000, bonus: { attackMultiplier: 1.3 } },
        { name: "剑狱之尊", condition: (p) => getEquipLevel(p, "废品") > 200000000, bonus: { attackMultiplier: 1.3 } },
        { name: "剑主洪荒", condition: (p) => getEquipLevel(p, "废品") > 300000000, bonus: { attackMultiplier: 1.3 } },
        { name: "御诸剑神", condition: (p) => getEquipLevel(p, "废品") > 400000000, bonus: { attackMultiplier: 1.4 } },
        { name: "创造剑神", condition: (p) => getEquipLevel(p, "废品") > 1000000000, bonus: { attackMultiplier: 1.4 } },
        { name: "位面剑荒", condition: (p) => getEquipLevel(p, "废品") > 5000000000, bonus: { attackMultiplier: 1.5 } },
        { name: "八荒之剑我为尊", condition: (p) => getEquipLevel(p, "废品") > 10000000000, bonus: { attackMultiplier: 1.5 } }
    ]
};
// 辅助函数：检查是否拥有指定魂环
function hasSoulRing(player, typeName) {
return player.soulRings.some(ring => ring.type === typeName);
}

// 辅助函数：获取指定类型装备的最高等级
function getEquipLevel(player, equipName) {
return player.dungeonEquipment
.filter(eq => eq.name === equipName)
.reduce((max, eq) => Math.max(max, eq.level || 0), 0);
}

// 显示称号界面
function showTitleDialog() {
   if (player.reincarnationCount < 10) {
        alert("需要达到10转才能开启称号系统！");
        return;
    }
    checkTitleUnlocks(); // 先检查解锁状态
    renderTitleBranches(); // 渲染称号
    document.getElementById("titleDialog").style.display = "block";
    document.getElementById("titleOverlay").style.display = "block";
}

// 关闭称号界面
function closeTitleDialog() {
    document.getElementById("titleDialog").style.display = "none";
    document.getElementById("titleOverlay").style.display = "none";
}

// 检查并解锁称号
function checkTitleUnlocks() {
    let newlyUnlocked = false;
    // 遍历所有分支的称号
    Object.values(titleConfig).forEach(branch => {
        branch.forEach(title => {
            if (!player.titles.unlocked.includes(title.name) && title.condition(player)) {
                player.titles.unlocked.push(title.name);
                newlyUnlocked = true;
                
                // 应用称号加成
                if (title.bonus) {
                    applyTitleBonus(title.bonus);
                }
                
                logAction(`解锁新称号：${title.name}`, 'success');
            }
        });
    });
    if (newlyUnlocked) {
        saveGame();
    }
}

// 应用称号加成
function applyTitleBonus(bonus) {
    // 直接修改玩家属性
    if (bonus.attackMultiplier) {
        player.battle.playerAttack *= bonus.attackMultiplier;
    }
    if (bonus.healthMultiplier) {
        player.battle.playerHealth *= bonus.healthMultiplier;
    }
    if (bonus.critMultiplier) {
        player.battle.playerCritDamage *= bonus.critMultiplier;
    }
    // 其他属性...
    
    logAction(`称号加成生效: ${JSON.stringify(bonus)}`, 'success');
    updatePlayerBattleStats();
}

// 渲染称号分支
function renderTitleBranches() {
    // 遍历每个分支并渲染
    Object.entries(titleConfig).forEach(([branchKey, titles]) => {
        const container = document.getElementById(`${branchKey}Container`);
        if (!container) return;
        
        container.innerHTML = "";
        titles.forEach(title => {
            // 只显示已解锁的称号
            if (player.titles.unlocked.includes(title.name)) {
                const isSelected = player.titles.current === title.name;
                const titleEl = document.createElement("div");
                titleEl.className = `titleItem unlocked ${isSelected ? 'selected' : ''}`;
                titleEl.textContent = title.name;
                titleEl.onclick = () => selectTitle(title.name);
                container.appendChild(titleEl);
            }
        });
    });
}

// 选择称号
function selectTitle(titleName) {
    if (player.titles.unlocked.includes(titleName)) {
        player.titles.current = titleName;
        logAction(`已选择称号：${titleName}`, 'info');
        renderTitleBranches(); // 更新选中状态
        updateDisplay(); // 更新玩家名字旁的称号显示
        saveGame();
    }
}
// 计算称号总加成（在属性计算处调用）
function calculateTotalBonuses() {
    const bonuses = {
        attackMultiplier: 1,
        healthMultiplier: 1,
        critMultiplier: 1
    };
    
    // 累加所有已解锁称号的加成
    player.titles.unlocked.forEach(titleName => {
        // 查找对应的称号配置
        for (const branch of Object.values(titleConfig)) {
            for (const title of branch) {
                if (title.name === titleName && title.bonus) {
                    // 累乘加成
                    if (title.bonus.attackMultiplier) {
                        bonuses.attackMultiplier *= title.bonus.attackMultiplier;
                    }
                    if (title.bonus.healthMultiplier) {
                        bonuses.healthMultiplier *= title.bonus.healthMultiplier;
                    }
                    if (title.bonus.critMultiplier) {
                        bonuses.critMultiplier *= title.bonus.critMultiplier;
                    }
                    break;
                }
            }
        }
    });
    
    return bonuses;
}


// 伴侣品阶配置
const companionRarities = {
    white: { 
        name: "普通", 
        color: "#FFFFFF", 
        baseScore: 100,
        upgradeMultiplier: 1,
        talentCount: 4,
        talentRange: [0, 3], // 初级到终极
        decomposeRose: 5,
         soulItem: "banlv1"
    },
    blue: { 
        name: "稀有", 
        color: "#0000FF", 
        baseScore: 500,
        upgradeMultiplier: 3,
        talentCount: 5,
        talentRange: [0, 4], // 初级到圣级
        decomposeRose: 20,
         soulItem: "banlv2"
    },
    epic: { 
        name: "史诗", 
        color: "#800080", 
        baseScore: 1000,
        upgradeMultiplier: 10,
        talentCount: 6,
        talentRange: [0, 5], // 初级到神级
        decomposeRose: 50,
         soulItem: "banlv3"
    },
    pink: { 
        name: "卓越", 
        color: "#FF69B4", 
        baseScore: 3000,
        upgradeMultiplier: 20,
        talentCount: 7,
        talentRange: [0, 6], // 初级到远古
        decomposeRose: 100,
         soulItem: "banlv4"
    },
    orange: { 
        name: "完美", 
        color: "#FFA500", 
        baseScore: 5000,
        upgradeMultiplier: 50,
        talentCount: 8,
        talentRange: [0, 7], // 初级到太古
        decomposeRose: 200,
         soulItem: "banlv5"
    },
    red: { 
        name: "神赐", 
        color: "#FF0000", 
        baseScore: 8000,
        upgradeMultiplier: 100,
        talentCount: 10,
        talentRange: [0, 8], // 初级到洪荒
        decomposeRose: 1000,
         soulItem: "banlv6"
    },
   angel: { 
        name: '天使', 
        color: '#87CEEB',
        baseScore: 1000,
        upgradeMultiplier: 30,
        talentCount: 0, // 动态计算
        talentRange: [0, 8], // 可达到洪荒级别
        decomposeRose: 100,
         soulItem: "banlv7"
    },
  emyyyy: { 
        name: '恶魔', 
        color: '#E63946',
        baseScore: 1000,
        upgradeMultiplier: 25,
        talentCount: 0, // 动态计算
        talentRange: [0, 8], // 可达到洪荒级别
        decomposeRose: 100,
         soulItem: "banlv8"
    },
  jlyyyy: { 
        name: '妖精', 
        color: '#7CFC00',
        baseScore: 1000,
        upgradeMultiplier: 20,
        talentCount: 0, // 动态计算
        talentRange: [0, 8], // 可达到洪荒级别
        decomposeRose: 100,
         soulItem: "banlv9"
    }
};

// 天赋类型配置
const talentTypes = [
    {
        name: "攻击",
        base: 1,
        perLevel: 5,
        description: (level) => `玩家总和攻击+${(0.1 + 0.2 * level).toFixed(1)}倍`
    },
    {
        name: "爆伤",
        base: 1,
        perLevel: 5,
        description: (level) => `玩家总和爆伤+${(0.1 + 0.2 * level).toFixed(1)}倍`
    },
    {
        name: "生命",
        base: 0.001,
        perLevel: 0.001,
        description: (level) => `玩家总和生命+${(0.001 + 0.001 * level).toFixed(3)}倍`
    },
    {
        name: "全属性",
        base: 0.5,
        perLevel: 2.5,
        description: (level) => `玩家总和全属性+${(0.1 + 0.11 * level).toFixed(2)}倍`
    },
    {
        name: "连击",
        base: 1,
        perLevel: 5,
        description: (level) => `玩家连击+${1 + 1 * level}`
    },
    {
        name: "暴击率",
        base: 0.001,
        perLevel: 0.001,
        description: (level) => `玩家暴击率+${(0.001 + 0.001 * level).toFixed(3)}倍`
    }
];

// 天赋品阶名称
const talentRanks = ["初级", "中级", "高级", "终极", "圣级", "神级", "远古", "太古", "洪荒"];

// 伴侣名字库
const companionNames = ["闫闫", "茶茶", "沈砚山", "苏绾月", "林清瑶", "楚棠溪", "慕玄尘", "许清尘", "温玉珞", "林灵枢", "叶棠音", "陆剑尘", "楚絮晚", "陆星辞", "王富贵", "洛千尘", "白小纯", "白芷晴", "顾长歌", "沈青岚", "慕雨柔", "陆天行", "乔曦", "柳如烟", "香香", "尝试", "小萝莉", "通元", "鱼鱼", "花花"];

// 抽奖概率
const drawProbabilities = [
    {rarity: "white", prob: 0.8},
    {rarity: "blue", prob: 0.15},
    {rarity: "epic", prob: 0.01889},
    {rarity: "pink", prob: 0.001},
    {rarity: "orange", prob: 0.0001},
    {rarity: "red", prob: 0.00001}
];
const guaranteeThresholds = {
    epic: 100,   // 100次保底史诗
    pink: 500,   // 500次保底卓越
    orange: 1000, // 1000次保底完美
    red: 5000    // 5000次保底神赐
};

// 打开伴侣系统
function openCompanionSystem() {
 if (player.reincarnationCount < 30) {
        alert("需要达到30转才能开启伴侣系统！");
        return;
    }
    document.getElementById('companionSystem').style.display = 'block';
    document.getElementById('companionOverlay').style.display = 'block';
    updateCompanionDisplay();
   calculateOfflineExpeditionRewards();
    updateExpeditionUI();
}

// 关闭伴侣系统
function closeCompanionSystem() {
    document.getElementById('companionSystem').style.display = 'none';
    document.getElementById('companionOverlay').style.display = 'none';
}

// 更新伴侣系统显示
function updateCompanionDisplay() {
    // 更新等级和消耗
    document.getElementById('companionLevel').textContent = player.companionLevel;
    document.getElementById('upgradeCost').textContent = 10 * player.companionLevel;
    document.getElementById('companionKeyCount').textContent = player.items.companionKey;
    // 更新保底计数器显示
    document.getElementById('epicGuarantee').textContent = player.companionChestGuarantee.epic;
    document.getElementById('pinkGuarantee').textContent = player.companionChestGuarantee.pink;
    document.getElementById('orangeGuarantee').textContent = player.companionChestGuarantee.orange;
    document.getElementById('redGuarantee').textContent = player.companionChestGuarantee.red;
    // 更新伴侣列表
    const listContainer = document.getElementById('companionList');
    listContainer.innerHTML = '';
    const companion = player.companions.find(c => c.id === player.equippedCompanionId);
    if (companion) {
        const rarityConfig = companionRarities[companion.rarity] || {};
        const bonuses = getCompanionBonuses();
        
        // 更新显示
        document.getElementById('qualityMultiplier').textContent = 
    `${(Math.floor(companion.score / 100) + companionRarities[companion.rarity].upgradeMultiplier).toFixed(2)}x`;
        document.getElementById('attackTotalBonus').textContent = `${bonuses.attackMultiplier.toFixed(3)}倍`;
        document.getElementById('healthTotalBonus').textContent = `${bonuses.healthMultiplier.toFixed(3)}倍`;
        document.getElementById('critRateTotalBonus').textContent = `${bonuses.critRateMultiplier.toFixed(3)}倍`;
        document.getElementById('critDamageTotalBonus').textContent = `${bonuses.critDamageMultiplier.toFixed(3)}倍`;
        document.getElementById('comboTotalBonus').textContent = bonuses.combo;
        document.getElementById('allStatsTotalBonus').textContent = `${bonuses.allStatsMultiplier.toFixed(3)}倍`;
    } else {
        // 未装备伴侣时显示默认值
        const defaultText = '未装备';
        document.getElementById('qualityMultiplier').textContent = defaultText;
        document.getElementById('attackTotalBonus').textContent = defaultText;
        document.getElementById('healthTotalBonus').textContent = defaultText;
        document.getElementById('critRateTotalBonus').textContent = defaultText;
        document.getElementById('critDamageTotalBonus').textContent = defaultText;
        document.getElementById('comboTotalBonus').textContent = defaultText;
        document.getElementById('allStatsTotalBonus').textContent = defaultText;
    }

    player.companions.forEach(companion => {
        const isEquipped = player.equippedCompanionId === companion.id;
const rarityConfig = companionRarities[companion.rarity] || {};
        const rarityName = rarityConfig.name || "未知";
        const rarityColor = rarityConfig.color || "#CCCCCC";
        
        // 特殊处理天使品质的显示
        let displayName = companion.name;
        if (companion.rarity === 'angel') {
            displayName = `天使·${companion.name}`;
        }
        const stars = '★'.repeat(Math.min(10, Math.floor(companion.score / 1000)));
        const emptyStars = '☆'.repeat(10 - Math.min(10, Math.floor(companion.score / 1000)));
        
        const card = document.createElement('div');
        card.style = `background: #222; border: 2px solid ${companionRarities[companion.rarity].color}; border-radius: 5px; padding: 10px; position: relative;`;
        card.innerHTML = `
            <div style="position: absolute; top: 5px; right: 5px; color: ${companionRarities[companion.rarity].color};">
                ${companionRarities[companion.rarity].name}
            </div>
            <h4 style="color: ${companionRarities[companion.rarity].color}; margin-top: 0;">
                ${companion.name}
                <span style="margin-left: 5px; color: #FFD700;">+${companion.advanceLevel || 0}</span>
                ${companion.locked ? '🔒' : ''}
            </h4>
            </div>
    <div>${stars}${emptyStars} (${companion.score}/10000)</div>
            <div style="margin: 5px -2; font-size: 0.8em; max-height: 190px; overflow-y: auto;">
                ${companion.talents.map(t => `${talentRanks[t.rank]}${talentTypes[t.type].name}: ${talentTypes[t.type].description(t.rank)}`).join('<br>')}
            </div>
            <div style="margin-top: 10px; display: flex; gap: 5px;">
                <button onclick="equipCompanion('${companion.id}')" style="flex: 1; background: ${isEquipped ? '#4CAF50' : '#555'}; color: white; border: none; padding: 3px; border-radius: 2px; font-size: 0.8em;">
                    ${isEquipped ? '已装备' : '装备'}
                </button>
                <button onclick="toggleCompanionLock('${companion.id}')" style="width: 30px; background: ${companion.locked ? '#f44336' : '#555'}; color: white; border: none; padding: 3px; border-radius: 2px;">
                    ${companion.locked ? '已锁' : '开锁'}
                </button>
                <button onclick="decomposeCompanion('${companion.id}')" style="width: 30px; background: #f44336; color: white; border: none; padding: 3px; border-radius: 2px;" ${companion.locked ? 'disabled' : ''}>
                    分解
                </button>
       <button onclick="advanceCompanion('${companion.id}')" style="width: 30px; background: #FFD700; color: black; border: none; padding: 3px; border-radius: 2px; margin-left: 2px;" 
    ${companion.locked || !['white','blue','epic','pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity) ? 'disabled' : ''}>
    进阶
</button>
 <button onclick="openWashPanel('${companion.id}')" style="width: 30px; background: #2196F3; color: white; border: none; padding: 3px; border-radius: 2px; margin-left: 2px;"
    ${companion.locked || !['epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity) ? 'disabled' : ''}>
    洗练
</button>
   <button onclick="openCombinePanel('${companion.id}')" style="width: 30px; background: #9C27B0; color: white; border: none; padding: 3px; border-radius: 2px; margin-left: 2px;"
    ${companion.locked || !['epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity) ? 'disabled' : ''}>
    合成
</button>
            </div>
        `;
        listContainer.appendChild(card);
    });
}
const expeditionConfig = {
    tasks: [
        {
            id: "forest",
            name: "迷雾森林",
            difficulty: "简单",
            duration: 30, // 分钟
            baseReward: {
                rose: 30,
                vipPower: 1,
                bait: 1
            },
            description: "探索神秘的迷雾森林，寻找稀有资源",
            companionRequirement: 3000 
        },
        {
            id: "mountain",
            name: "远古山脉",
            difficulty: "中等",
            duration: 60,
            baseReward: {
                rose: 80,
                vipPower: 3,
                bait: 3
            },
            description: "攀登危险的远古山脉，挑战极限",
            companionRequirement: 5000
        },
        {
            id: "ocean",
            name: "深渊海洋",
            difficulty: "困难",
            duration: 120,
            baseReward: {
                rose: 200,
                vipPower: 10,
                bait: 10
            },
            description: "潜入神秘的深渊海洋，探索未知领域",
            companionRequirement: 10000
        },
       {
            id: "volcano",
            name: "熔岩火山",
            difficulty: "极难",
            duration: 240,
            baseReward: {
                rose: 500,
                vipPower: 35,
                bait: 35
            },
            description: "穿越危险的熔岩火山，寻找传说宝藏",
            companionRequirement: 15000
        },
        {
            id: "emshen",
            name: "虚空裂缝",
            difficulty: "噩梦",
            duration: 480,
            baseReward: {
                rose: 1200,
                vipPower: 120,
                bait: 120
            },
            description: "穿越不稳定的虚空裂缝，直面维度之外的恐怖",
            companionRequirement: 20000
        },
        {
            id: "emyuan",
            name: "星际深渊",
            difficulty: "地狱",
            duration: 960,
            baseReward: {
                rose: 3000,
                vipPower: 480,
                bait: 480
            },
            description: "勇闯无尽的星际深渊，挑战宇宙终极奥秘",
            companionRequirement: 25000
        }
    ]
};

// 初始化伴侣探险数据
function initExpeditionData() {
    if (!player.companionExpedition) {
        player.companionExpedition = {
            currentExpedition: null,
            history: [],
            lastUpdate: Date.now()
        };
    }
}

// 切换探险系统显示
function toggleExpeditionSystem() {
    const ui = document.getElementById('expeditionSystemUI');
    const overlay = document.getElementById('expeditionSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initExpeditionData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateExpeditionUI();
    }
}

// 更新探险系统UI
function updateExpeditionUI() {
    // 更新任务列表
    const tasksContainer = document.getElementById('expeditionTasks');
    tasksContainer.innerHTML = '';
    
    expeditionConfig.tasks.forEach(task => {
        const taskElement = document.createElement('div');
        taskElement.style.background = '#333';
        taskElement.style.padding = '15px';
        taskElement.style.borderRadius = '8px';
        taskElement.innerHTML = `
            <h4>${task.name} (${task.difficulty})</h4>
            <p>${task.description}</p>
            <div style="margin: 10px 0;">
                <div>所需时间: ${task.duration}分钟</div>
                <div>最低伴侣评分: ${task.companionRequirement}</div>
            </div>
            <div style="margin: 10px 0;">
                <strong>基础奖励:</strong>
                <div>玫瑰花: ${task.baseReward.rose}</div>
                <div>VIP能力值: ${task.baseReward.vipPower}</div>
                <div>鱼饵: ${task.baseReward.bait}</div>
            </div>
            <button onclick="startExpedition('${task.id}')" 
                    style="background: #9C27B0; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;"
                    ${player.companionExpedition.currentExpedition ? 'disabled' : ''}>
                开始探险
            </button>
        `;
        tasksContainer.appendChild(taskElement);
    });
    
    // 更新当前探险状态
    const currentContainer = document.getElementById('currentExpedition');
    if (player.companionExpedition.currentExpedition) {
        const task = expeditionConfig.tasks.find(t => t.id === player.companionExpedition.currentExpedition.taskId);
        const startTime = player.companionExpedition.currentExpedition.startTime;
        const duration = task.duration * 60 * 1000; // 转换为毫秒
        const endTime = startTime + duration;
        const remainingTime = Math.max(0, endTime - Date.now());
        const remainingMinutes = Math.ceil(remainingTime / (60 * 1000));
        
        currentContainer.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4>${task.name} (${task.difficulty})</h4>
                    <div>伴侣: ${player.companionExpedition.currentExpedition.companionName}</div>
                    <div>伴侣评分: ${player.companionExpedition.currentExpedition.companionScore}</div>
                </div>
                <div>
                    <div>剩余时间: ${remainingMinutes}分钟</div>
                </div>
            </div>
        `;
    } else {
        currentContainer.innerHTML = '<p>没有进行中的探险</p>';
    }
    
    // 更新探险历史
    const historyContainer = document.getElementById('expeditionHistory');
    historyContainer.innerHTML = '';
    
    if (player.companionExpedition.history.length === 0) {
        historyContainer.innerHTML = '<p>暂无探险记录</p>';
    } else {
        player.companionExpedition.history.slice(0, 5).forEach(record => {
            const task = expeditionConfig.tasks.find(t => t.id === record.taskId);
            const recordElement = document.createElement('div');
            recordElement.style.marginBottom = '10px';
            recordElement.style.paddingBottom = '10px';
            recordElement.style.borderBottom = '1px solid #444';
            recordElement.innerHTML = `
                <div><strong>${task.name}</strong> (${record.companionName})</div>
                <div>评分: ${record.companionScore} | 奖励倍数: ${record.rewardMultiplier.toFixed(2)}x</div>
                <div>获得: 玫瑰花 x${record.rewards.rose}, VIP能力值 x${record.rewards.vipPower}, 鱼饵 x${record.rewards.bait}</div>
                <div style="color: #aaa; font-size: 0.9em;">${new Date(record.endTime).toLocaleString()}</div>
            `;
            historyContainer.appendChild(recordElement);
        });
    }
}

// 开始探险
// 伴侣数据结构增强
class Companion {
    constructor(id, name, rarity, score, talents) {
        this.id = id;
        this.name = name;
        this.rarity = rarity;
        this.score = score;
        this.talents = talents;
        this.locked = false; // 用户设置的锁定状态
        this.onExpedition = false; // 是否在探险中
        this.originalLockedState = false; // 原始锁定状态（用于恢复）
    }
}

// 开始探险
function startExpedition(taskId) {
    if (player.companionExpedition.currentExpedition) {
        logAction("已有进行中的探险", "error");
        return;
    }
    
    const task = expeditionConfig.tasks.find(t => t.id === taskId);
    if (!task) return;
    
    // 检查是否有符合条件的伴侣
    const eligibleCompanions = player.companions.filter(c => 
        c.score >= task.companionRequirement && !c.onExpedition
    );
    
    if (eligibleCompanions.length === 0) {
        logAction("没有符合条件的伴侣", "error");
        return;
    }
    
    // 选择评分最高的伴侣
    const companion = eligibleCompanions.reduce((max, c) => 
        c.score > max.score ? c : max, eligibleCompanions[0]
    );
    
    // 保存原始锁定状态
    companion.originalLockedState = companion.locked;
    
    // 强制锁定伴侣
    companion.locked = true;
    
    // 标记伴侣为探险中
    companion.onExpedition = true;
    
    // 开始探险
    player.companionExpedition.currentExpedition = {
        taskId: task.id,
        companionId: companion.id,
        companionName: companion.name,
        companionScore: companion.score,
        startTime: Date.now()
    };
    
    player.companionExpedition.lastUpdate = Date.now();
    
    logAction(`派遣${companion.name}进行${task.name}探险，伴侣已自动锁定`, "success");
    updateExpeditionUI();
    updateCompanionDisplay();
}

// 完成探险
function completeExpedition(forceComplete = false) {
    if (!player.companionExpedition.currentExpedition) return;
    
    const expedition = player.companionExpedition.currentExpedition;
    const task = expeditionConfig.tasks.find(t => t.id === expedition.taskId);
    const companion = player.companions.find(c => c.id === expedition.companionId);
    
    if (!task || !companion) return;
    
    // 计算实际探险时间
    const startTime = expedition.startTime;
    const duration = task.duration * 60 * 1000; // 转换为毫秒
    const endTime = startTime + duration;
    const currentTime = Date.now();
    
    // 如果强制提前结束，计算实际探险时间比例
    const timeRatio = forceComplete ? 
        Math.min(1, (currentTime - startTime) / duration) : 1;
    
    // 计算奖励倍数（基于伴侣评分）
    const scoreRatio = expedition.companionScore / task.companionRequirement;
    const rewardMultiplier = Math.min(5, Math.max(1, scoreRatio * timeRatio));
    
    // 计算实际奖励
    const rewards = {
        rose: Math.floor(task.baseReward.rose * rewardMultiplier),
        vipPower: Math.floor(task.baseReward.vipPower * rewardMultiplier),
        bait: Math.floor(task.baseReward.bait * rewardMultiplier)
    };
    
    // 发放奖励
    player.items.rose += rewards.rose;
    player.items.vipPower += rewards.vipPower;
    player.items.baitCount += rewards.bait;
    
    // 添加历史记录
    player.companionExpedition.history.unshift({
        taskId: task.id,
        companionId: companion.id,
        companionName: companion.name,
        companionScore: companion.score,
        rewardMultiplier: rewardMultiplier,
        rewards: rewards,
        startTime: startTime,
        endTime: currentTime,
        duration: (currentTime - startTime) / (60 * 1000) // 分钟
    });
    
    // 限制历史记录数量
    if (player.companionExpedition.history.length > 10) {
        player.companionExpedition.history.pop();
    }
    
    // 清除当前探险
    player.companionExpedition.currentExpedition = null;
    
    // 解除伴侣的探险状态
    companion.onExpedition = false;
    
    // 恢复原始锁定状态
    companion.locked = companion.originalLockedState;
    
    logAction(
        `${companion.name}完成${task.name}探险，获得奖励: 玫瑰花x${rewards.rose}, VIP能力值x${rewards.vipPower}, 鱼饵x${rewards.bait}`,
        "success"
    );
    
    logAction(
        `${companion.name}已恢复${companion.locked ? "锁定" : "解锁"}状态`,
        "info"
    );
    
    updateExpeditionUI();
    updateCompanionDisplay();
    updateItemDisplay();
}

// 计算离线探险奖励
function calculateOfflineExpeditionRewards() {
    if (!player.companionExpedition || !player.companionExpedition.currentExpedition) return;
    
    const expedition = player.companionExpedition.currentExpedition;
    const task = expeditionConfig.tasks.find(t => t.id === expedition.taskId);
    const companion = player.companions.find(c => c.id === expedition.companionId);
    
    if (!task || !companion) return;
    
    const startTime = expedition.startTime;
    const duration = task.duration * 60 * 1000; // 转换为毫秒
    const endTime = startTime + duration;
    const currentTime = Date.now();
    
    // 如果探险已经完成
    if (currentTime >= endTime) {
        completeExpedition();
    }
}
// 伴侣商店相关函数
function toggleCompanionShop() {
    const shopUI = document.getElementById('companionShopUI');
    const overlay = document.getElementById('companionShopOverlay');
    
    if (shopUI.style.display === 'block') {
        shopUI.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        shopUI.style.display = 'block';
        overlay.style.display = 'block';
        updateSoulCounts();
    }
}

// 更新灵魂道具数量显示
function updateSoulCounts() {
    document.getElementById('soulCount1').textContent = player.items.banlv1 || 0;
    document.getElementById('soulCount2').textContent = player.items.banlv2 || 0;
    document.getElementById('soulCount3').textContent = player.items.banlv3 || 0;
    document.getElementById('soulCount4').textContent = player.items.banlv4 || 0;
    document.getElementById('soulCount5').textContent = player.items.banlv5 || 0;
    document.getElementById('soulCount6').textContent = player.items.banlv6 || 0;
    document.getElementById('soulCount7').textContent = player.items.banlv7 || 0;
    document.getElementById('soulCount8').textContent = player.items.banlv8 || 0;
    document.getElementById('soulCount9').textContent = player.items.banlv9 || 0;
}

// 灵魂道具兑换函数
function exchangeSoul(fromSoul, toSoul, fromAmount, toAmount) {
    // 确保灵魂道具字段存在
    if (player.items[fromSoul] === undefined) {
        player.items[fromSoul] = 0;
    }
    if (player.items[toSoul] === undefined) {
        player.items[toSoul] = 0;
    }
    
    // 检查是否有足够的灵魂道具
    if (player.items[fromSoul] < fromAmount) {
        const fromName = itemEffects[fromSoul]?.name || fromSoul;
        logAction(`${fromName}不足，需要${fromAmount}个`, "error");
        return;
    }
    
    // 执行兑换
    player.items[fromSoul] -= fromAmount;
    player.items[toSoul] += toAmount;
    
    // 获取道具名称
    const fromName = itemEffects[fromSoul]?.name || fromSoul;
    const toName = itemEffects[toSoul]?.name || toSoul;
    
    // 记录日志
    logAction(`成功兑换：${fromAmount}个${fromName} → ${toAmount}个${toName}`, "success");
    
    // 更新显示
    updateSoulCounts();
    updateItemDisplay();
    saveGame();
}
// 批量开启伴侣宝箱
function drawCompanionMultiple(count) {
    if (player.items.companionKey < count) {
        logAction("伴侣钥匙不足！", "error");
        return;
    }
    player.items.companionKey -= count;
    updateItemDisplay();
    // 用于统计各品质获得数量
    const rarityCount = {
        white: 0,
        blue: 0,
        epic: 0,
        pink: 0,
        orange: 0,
        red: 0,
        angel: 0,
        emyyyy: 0,
        jlyyyy: 0
    };
    
    // 保存获得的伴侣，用于最后显示
    const companionsObtained = [];
    
    // 执行多次开启
    for (let i = 0; i < count; i++) {
        const result = drawOneCompanion();
        if (result) {
            rarityCount[result.rarity]++;
            companionsObtained.push(result);
        }
    }
    
   
    
    // 生成汇总消息
    let message = `开启${count}次伴侣宝箱，获得：`;
    let hasCompanion = false;
    
    for (const rarity in rarityCount) {
        if (rarityCount[rarity] > 0) {
            const rarityName = companionRarities[rarity].name;
            message += `${rarityName}x${rarityCount[rarity]} `;
            hasCompanion = true;
        }
    }
    
    if (!hasCompanion) {
        message += "未获得任何伴侣";
    }
    
    logAction(message, 'success');
    
    // 更新显示
    updateCompanionDisplay();
}
// 提取单次开启逻辑到独立函数
function drawOneCompanion() {
    // 更新所有保底计数器
    player.companionChestGuarantee.epic++;
    player.companionChestGuarantee.pink++;
    player.companionChestGuarantee.orange++;
    player.companionChestGuarantee.red++;
    
    let selectedRarity;
    let isGuaranteed = false;
    
    // 检查保底机制（优先级从高到低）
    if (player.companionChestGuarantee.red >= guaranteeThresholds.red) {
        selectedRarity = "red";
        isGuaranteed = true;
        player.companionChestGuarantee.red = 0;
    } else if (player.companionChestGuarantee.orange >= guaranteeThresholds.orange) {
        selectedRarity = "orange";
        isGuaranteed = true;
        player.companionChestGuarantee.orange = 0;
    } else if (player.companionChestGuarantee.pink >= guaranteeThresholds.pink) {
        selectedRarity = "pink";
        isGuaranteed = true;
        player.companionChestGuarantee.pink = 0;
    } else if (player.companionChestGuarantee.epic >= guaranteeThresholds.epic) {
        selectedRarity = "epic";
        isGuaranteed = true;
        player.companionChestGuarantee.epic = 0;
    } else {
        // 没有触发保底，按原概率抽取
        let rand = Math.random();
        let cumulativeProb = 0;
        for (const { rarity, prob } of drawProbabilities) {
            cumulativeProb += prob;
            if (rand < cumulativeProb) {
                selectedRarity = rarity;
                break;
            }
        }
    }
    
    // 生成天赋
    const config = companionRarities[selectedRarity];
    const talentCount = config.talentCount;
    const [minRank, maxRank] = config.talentRange;
    const talents = [];
    
    while (talents.length < talentCount) {
        const type = Math.floor(Math.random() * talentTypes.length);
        const rank = Math.floor(Math.random() * (maxRank - minRank + 1)) + minRank;
        talents.push({ type, rank });
    }
    
    // 计算评分
    const baseScore = config.baseScore;
    const talentScore = talents.reduce((sum, t) => sum + (t.rank + 1) * 50, 0);
    const totalScore = Math.min(10000, baseScore + talentScore);
    
    // 生成伴侣
    const companion = {
        id: 'comp_' + Date.now() + Math.floor(Math.random() * 1000),
        name: companionNames[Math.floor(Math.random() * companionNames.length)],
        rarity: selectedRarity,
        talents,
        score: totalScore,
        locked: false,
        advanceLevel: 0,
        qualityMultiplier: 1.0
    };
    
    player.companions.push(companion);
    
    // 返回获得的伴侣信息
    return {
        rarity: selectedRarity,
        name: companion.name,
        isGuaranteed: isGuaranteed
    };
}

// 抽取伴侣
function drawCompanion() {
    if (player.items.companionKey < 1) {
        logAction("伴侣钥匙不足！", "error");
        return;
    }
    
     player.items.companionKey--;
    updateItemDisplay();
    
    const result = drawOneCompanion();
    if (result) {
        const rarityName = companionRarities[result.rarity].name;
        logAction(`获得了${rarityName}品质伴侣：${result.name}${result.isGuaranteed ? " (保底)" : ""}`, 'success');
        
        updateCompanionDisplay();
        
    }
}
// 添加伴侣进阶函数
function advanceCompanion(id) {
     const companion = player.companions.find(c => c.id === id);
    if (!companion) return;
    
    // 检查伴侣是否在探险中
    if (companion && companion.onExpedition) {
        logAction(`${companion.name}正在探险中，无法进阶！`, "error");
        return;
    }

    // 检查是否为可进阶品质
    if (!['white','blue','epic','pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity)) {
        logAction("品质的伴侣可以进阶！", "error");
        return;
    }

     // 获取对应的灵魂道具配置
    const rarityConfig = companionRarities[companion.rarity];
    if (!rarityConfig || !rarityConfig.soulItem) {
        logAction("未找到该品质的进阶配置！", "error");
        return;
    }
    
    // 计算当前进阶等级和所需消耗
    const currentLevel = companion.advanceLevel || 0;
    const requiredCount = Math.pow(2, currentLevel); // 1, 2, 4, 8...
    
    // 检查是否有足够的灵魂道具
    const soulItemKey = rarityConfig.soulItem;
    if (!player.items[soulItemKey] || player.items[soulItemKey] < requiredCount) {
        const itemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
        logAction(`需要${requiredCount}个${itemName}才能进阶！`, "error");
        return;
    }
    
    // 消耗灵魂道具
    player.items[soulItemKey] -= requiredCount;
    
    // 提升进阶等级
    companion.advanceLevel = (companion.advanceLevel || 0) + 1;
    companion.score += Math.floor(companion.score * 0.1) + 100;
    updateCompanionStats(companion);
    
    // 提示信息
    const rarityName = companionRarities[companion.rarity].name;
    const itemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
    logAction(`${companion.name}使用${requiredCount}个${itemName}进阶成功！当前进阶等级+${companion.advanceLevel}`, "success");
    
    updateCompanionDisplay();
}
// 升级伴侣等级
function upgradeCompanion() {
    const cost = 10 * player.companionLevel;
    if (player.items.rose < cost) {
        logAction("玫瑰花不足！", "error");
        return;
    }
    
    player.items.rose -= cost;
    player.companionLevel++;
    logAction(`伴侣等级提升至Lv.${player.companionLevel}`, 'success');
    updateCompanionDisplay();
}

// 装备伴侣
function equipCompanion(id) {
    player.equippedCompanionId = id;
    logAction(`已装备伴侣：${player.companions.find(c => c.id === id).name}`, 'success');
    updateCompanionDisplay();
}
// 新增洗练面板相关函数
let currentWashCompanionId = null;

function openWashPanel(companionId) {
    const companion = player.companions.find(c => c.id === companionId);
    if (!companion) return;
    
    currentWashCompanionId = companionId;
    document.getElementById('washPanel').style.display = 'block';
    document.getElementById('settingsOverlay').style.display = 'block';
    document.getElementById('rebornDanCount').textContent = player.items.rebornDan || 0;
    
    // 显示当前伴侣信息
    const infoElement = document.getElementById('washCompanionInfo');
    infoElement.innerHTML = `
        <p>名称: ${companion.name}</p>
        <p>品阶: <span style="color: ${companionRarities[companion.rarity].color}">${companionRarities[companion.rarity].name}</span></p>
        <p>天赋数量: ${companion.talents.length}</p>
    `;
    
    // 生成天赋列表和锁定选项
    updateTalentList(companion);
    
    // 隐藏之前的洗练结果
    document.getElementById('washResult').style.display = 'none';
    
    // 更新洗练消耗显示
    updateWashCost(companion);
}
// 更新天赋列表和锁定选项
function updateTalentList(companion) {
    const talentListElement = document.getElementById('talentList');
    talentListElement.innerHTML = '';
    
    companion.talents.forEach((talent, index) => {
        const talentElement = document.createElement('div');
        talentElement.style.marginBottom = '10px';
        talentElement.style.padding = '5px';
        talentElement.style.borderBottom = '1px solid #555';
        talentElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span>${index + 1}. ${talentRanks[talent.rank]}${talentTypes[talent.type].name}: ${talentTypes[talent.type].description(talent.rank)}</span>
                <label>
                    <input type="checkbox" ${talent.locked ? 'checked' : ''} 
                           onchange="toggleTalentLock(${index}, this.checked)">
                    锁定
                </label>
            </div>
        `;
        talentListElement.appendChild(talentElement);
    });
}

// 切换天赋锁定状态
function toggleTalentLock(talentIndex, isLocked) {
    const companion = player.companions.find(c => c.id === currentWashCompanionId);
    if (companion && companion.talents[talentIndex]) {
        companion.talents[talentIndex].locked = isLocked;
        updateWashCost(companion);
        // 可选：立即更新界面显示
        updateTalentList(companion);
    }
}

// 更新洗练消耗显示
function updateWashCost(companion) {
    const lockedCount = companion.talents.filter(t => t.locked).length;
    const totalCost = 1 + lockedCount * 2;
    
    document.getElementById('totalWashCost').textContent = 
        `本次洗练总消耗：${totalCost} 洗髓丹 (基础1 + 锁定${lockedCount}×2)`;
}

function closeWashPanel() {
    document.getElementById('washPanel').style.display = 'none';
    document.getElementById('settingsOverlay').style.display = 'none';
    currentWashCompanionId = null;
}

function washCompanion() {
    if (!currentWashCompanionId) return;
    
    const companion = player.companions.find(c => c.id === currentWashCompanionId);
    if (!companion) {
        closeWashPanel();
        return;
    }
    
    // 检查伴侣是否在探险中
    if (companion.onExpedition) {
        logAction(`${companion.name}正在探险中，无法洗练！`, "error");
        return;
    }
    
    // 计算消耗
    const lockedCount = companion.talents.filter(t => t.locked).length;
    const totalCost = 1 + lockedCount * 2;
    
    // 检查洗髓丹数量
    if ((player.items.rebornDan || 0) < totalCost) {
        logAction(`洗髓丹不足！需要${totalCost}个`, "error");
        return;
    }
    
    // 消耗洗髓丹
    player.items.rebornDan -= totalCost;
    document.getElementById('rebornDanCount').textContent = player.items.rebornDan;
    
    // 洗练逻辑：只重新生成未锁定的天赋
    let resultText = '洗练结果：<br>';
    
    companion.talents.forEach((talent, index) => {
        if (!talent.locked) {
            const oldType = talent.type;
            const oldRank = talent.rank;
            const oldTalentText = `${talentRanks[oldRank]}${talentTypes[oldType].name}`;
            
            // 生成新天赋 - 但保留锁定状态
            const newType = Math.floor(Math.random() * talentTypes.length);
            const newRank = Math.floor(Math.random() * 9); // 0-8级
            talent.type = newType;
            talent.rank = newRank;
            // 注意：这里不修改 talent.locked 状态，保持原样
            
            const newTalentText = `${talentRanks[newRank]}${talentTypes[newType].name}`;
            resultText += `天赋#${index + 1}: ${oldTalentText} → ${newTalentText}<br>`;
        } else {
            resultText += `天赋#${index + 1}: [已锁定] ${talentRanks[talent.rank]}${talentTypes[talent.type].name}<br>`;
        }
    });
    updateTalentList(companion);
   
    
    // 显示洗练结果
    const resultElement = document.getElementById('washResult');
    resultElement.innerHTML = resultText;
    resultElement.style.display = 'block';
    
   
    
    
    // 更新洗练消耗显示
    updateWashCost(companion);
    
    logAction(`伴侣${companion.name}洗练完成，消耗${totalCost}洗髓丹`, 'success');
}
// 切换锁定状态
function toggleCompanionLock(id) {
    const companion = player.companions.find(c => c.id === id);
     if (companion.onExpedition) {
        logAction("伴侣在探险中，无法更改锁定状态", "error");
        return;
    }
    if (companion) {
        companion.locked = !companion.locked;
        logAction(`${companion.name}已${companion.locked ? '锁定' : '解锁'}`, 'success');
        updateCompanionDisplay();
    }
}
// 切换自动分解状态
function toggleAutoDecompose() {
    player.autoDecompose.enabled = !player.autoDecompose.enabled;
    const btn = document.getElementById('toggleAutoDecompose');
    btn.textContent = `自动分解：${player.autoDecompose.enabled ? '开启' : '关闭'}`;
    btn.style.background = player.autoDecompose.enabled ? '#4CAF50' : '#ff9800';
    logAction(`${player.autoDecompose.enabled ? '开启' : '关闭'}自动分解低于${getRarityName(player.autoDecompose.belowRarity)}的伴侣`, 'info');
    
    // 如果开启则立即检查一次
    if (player.autoDecompose.enabled) {
        checkAutoDecompose();
    }
}

// 设置自动分解的品阶阈值
function setAutoDecomposeRarity() {
    const rarity = document.getElementById('autoDecomposeBelowRarity').value;
    player.autoDecompose.belowRarity = rarity;
    logAction(`设置自动分解低于${getRarityName(rarity)}的伴侣`, 'info');
}

// 获取品阶名称
function getRarityName(rarity) {
    const names = {
        'white': '普通(白色)',
        'blue': '稀有(蓝色)',
        'epic': '史诗(紫色)',
        'pink': '卓越(粉色)',
        'orange': '完美(橙色)',
        'red': '神赐(红色)',
        'angel': '天使(彩色)',
        'emyyyy': '恶魔(深红色)',
        'jlyyyy': '精灵(绿色)'
    };
    return names[rarity] || '普通(白色)';
}

// 自动分解检查逻辑
function checkAutoDecompose() {
    if (!player.autoDecompose.enabled) return;
    
    const rarityOrder = ['white', 'blue', 'epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'];
    const targetIndex = rarityOrder.indexOf(player.autoDecompose.belowRarity);
    if (targetIndex === -1) return;
    
    // 找出所有低于等于目标品阶且未锁定的伴侣
    const toDecompose = player.companions.filter(c => 
        rarityOrder.indexOf(c.rarity) <= targetIndex && !c.locked
    );
     
    if (toDecompose.length > 0) {
        // 按品质分组统计
        const decomposeByRarity = {};
        toDecompose.forEach(companion => {
            const rarity = companion.rarity;
            if (!decomposeByRarity[rarity]) {
                decomposeByRarity[rarity] = [];
            }
            decomposeByRarity[rarity].push(companion);
        });
        
        // 计算总玫瑰花奖励
        const totalRoses = toDecompose.reduce((sum, c) => sum + companionRarities[c.rarity].decomposeRose, 0);
        player.items.rose += totalRoses;
        
        // 计算并添加灵魂道具
        for (const rarity in decomposeByRarity) {
            const companionsOfRarity = decomposeByRarity[rarity];
            const soulItemKey = companionRarities[rarity]?.soulItem;
            
            if (soulItemKey) {
                // 初始化灵魂道具数量（如果不存在）
                if (player.items[soulItemKey] === undefined) {
                    player.items[soulItemKey] = 0;
                }
                // 添加灵魂道具
                player.items[soulItemKey] += companionsOfRarity.length;
                
                const soulItemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
                logAction(`自动分解获得${companionsOfRarity.length}个${soulItemName}`, 'info');
            }
        }
        
        // 过滤掉分解的伴侣
        player.companions = player.companions.filter(c => 
            !(rarityOrder.indexOf(c.rarity) <= targetIndex && !c.locked)
        );
      
        // 如果装备的伴侣被分解，取消装备
        if (toDecompose.some(c => c.id === player.equippedCompanionId)) {
            player.equippedCompanionId = null;
        }
        
        logAction(`自动分解${toDecompose.length}个低于${getRarityName(player.autoDecompose.belowRarity)}的伴侣，获得${totalRoses}玫瑰花`, 'success');
        updateCompanionDisplay();
        updateItemDisplay();
        saveGame(); // 保存游戏
    }
}

// 添加到页面初始化函数中
function initAutoDecomposeUI() {
    const raritySelect = document.getElementById('autoDecomposeBelowRarity');
    raritySelect.value = player.autoDecompose.belowRarity;
    raritySelect.onchange = setAutoDecomposeRarity;
    
    const btn = document.getElementById('toggleAutoDecompose');
    btn.textContent = `自动分解：${player.autoDecompose.enabled ? '开启' : '关闭'}`;
    btn.style.background = player.autoDecompose.enabled ? '#4CAF50' : '#ff9800';
}



// 添加定时检查（每5秒一次）
setInterval(checkAutoDecompose, 5000);
// 分解单个伴侣
function decomposeCompanion(id) {
    const companion = player.companions.find(c => c.id === id);
    if (!companion) return;
    
    if (companion.locked) {
        logAction("伴侣已锁定，无法分解！", "error");
        return;
    }
    
    // 获取分解奖励
    const rarityConfig = companionRarities[companion.rarity];
    const roses = rarityConfig ? rarityConfig.decomposeRose : 5; // 默认5朵玫瑰
    
    // 获取对应的灵魂道具
    const soulItemKey = rarityConfig.soulItem;
    const soulItemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
    
    // 移除伴侣
    player.companions = player.companions.filter(c => c.id !== id);
    
    // 如果分解的是装备的伴侣，取消装备
    if (player.equippedCompanionId === id) {
        player.equippedCompanionId = null;
    }
    
    // 添加奖励
    player.items.rose += roses;
    
    // 确保灵魂道具字段存在，然后增加1
    if (soulItemKey) {
        // 初始化灵魂道具数量（如果不存在）
        if (player.items[soulItemKey] === undefined) {
            player.items[soulItemKey] = 0;
        }
        player.items[soulItemKey] += 1;
    }
    
    logAction(`分解${companion.name}获得${roses}朵玫瑰花和1个${soulItemName}`, "success");
    updateCompanionDisplay();
    updateItemDisplay();
}

// 批量分解
function batchDecompose() {
    const rarity = document.getElementById('decomposeRarity').value;
    const toDecompose = player.companions.filter(c => c.rarity === rarity && !c.locked);
   
    if (toDecompose.length === 0) {
        logAction("没有可分解的伴侣", "error");
        return;
    }
    
    const totalRoses = toDecompose.reduce((sum, c) => sum + companionRarities[c.rarity].decomposeRose, 0);
    player.items.rose += totalRoses;
    
    // 获取对应的灵魂道具
    const soulItemKey = companionRarities[rarity].soulItem;
    const soulItemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
    
    // 添加灵魂道具
    if (soulItemKey) {
        // 初始化灵魂道具数量（如果不存在）
        if (player.items[soulItemKey] === undefined) {
            player.items[soulItemKey] = 0;
        }
        player.items[soulItemKey] += toDecompose.length;
    }
    
    // 过滤掉分解的伴侣
    player.companions = player.companions.filter(c => !(c.rarity === rarity && !c.locked));
    
    // 如果装备的伴侣被分解，取消装备
    if (toDecompose.some(c => c.id === player.equippedCompanionId)) {
        player.equippedCompanionId = null;
    }
    
    logAction(`批量分解${toDecompose.length}个${companionRarities[rarity].name}伴侣，获得${totalRoses}玫瑰花和${toDecompose.length}个${soulItemName}`, 'success');
    updateCompanionDisplay();
    updateItemDisplay();
}
// 打开合成面板
function openCombinePanel(mainId = null) {
    // 显示面板
    document.getElementById('combinePanel').style.display = 'block';
    
    // 填充可选伴侣列表
    const mainSelect = document.getElementById('mainCompanionSelect');
    const secondarySelect = document.getElementById('secondaryCompanionSelect');
    
    // 清空现有选项
    mainSelect.innerHTML = '';
    secondarySelect.innerHTML = '';
    
    // 只显示可合成的伴侣（史诗及以上且未锁定）
    const eligibleCompanions = player.companions.filter(c => 
        ['epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(c.rarity) && !c.locked
    );
    
    eligibleCompanions.forEach(companion => {
        const option = document.createElement('option');
        option.value = companion.id;
        option.textContent = `${companion.name} (${companionRarities[companion.rarity].name} +${companion.advanceLevel || 0})`;
        mainSelect.appendChild(option.cloneNode(true));
        secondarySelect.appendChild(option);
    });
    
    // 如果有传入主伴侣ID，设置为主选
    if (mainId && eligibleCompanions.some(c => c.id === mainId)) {
        mainSelect.value = mainId;
    }
    
    // 添加选择事件监听
    mainSelect.onchange = updateCombinePreview;
    secondarySelect.onchange = updateCombinePreview;
    
    // 初始更新预览
    updateCombinePreview();
}

// 关闭合成面板
function closeCombinePanel() {
    document.getElementById('combinePanel').style.display = 'none';
}

// 更新合成预览
function updateCombinePreview() {
    const mainId = document.getElementById('mainCompanionSelect').value;
    const secondaryId = document.getElementById('secondaryCompanionSelect').value;
    
    // 清除相同选择
    if (mainId && secondaryId && mainId === secondaryId) {
        document.getElementById('secondaryCompanionSelect').value = '';
    }
    
    const mainCompanion = player.companions.find(c => c.id === mainId);
   // 显示随机品质加成预览
    document.getElementById('previewQualityMultiplier').textContent = 
        `${(Math.random() * 0.6 + 0.7).toFixed(2)}x`;
    const secondaryCompanion = player.companions.find(c => c.id === secondaryId);
    
    // 更新伴侣信息显示
    updateCompanionInfo('mainCompanionInfo', mainCompanion);
    updateCompanionInfo('secondaryCompanionInfo', secondaryCompanion);
    
    // 更新预览信息
    const previewGeneration = document.getElementById('previewGeneration');
    const previewTalentCount = document.getElementById('previewTalentCount');
    const previewScoreRange = document.getElementById('previewScoreRange');
    
    if (mainCompanion && secondaryCompanion) {
        // 计算可能的代数
        const mainGen = getCompanionGeneration(mainCompanion);
        const secondaryGen = getCompanionGeneration(secondaryCompanion);
        const newGen = Math.max(mainGen, secondaryGen) + 1;
        previewGeneration.textContent = `${newGen}代`;
        
        // 计算可能的天赋数量范围
        const totalTalents = mainCompanion.talents.length + secondaryCompanion.talents.length;
        const minT1 = Math.floor(totalTalents * 0.01);
        const maxT1 = Math.floor(totalTalents * 0.5);
        const minT2 = Math.floor(maxT1 + 1);
        const maxT2 = Math.floor(totalTalents * 0.75);
        const minT3 = maxT2 + 1;
        const maxT3 = Math.floor(totalTalents * 1.0);
        previewTalentCount.textContent = `${minT1}-${maxT3} (80%概率 ${minT1}-${maxT1}, 18%概率 ${minT2}-${maxT2}, 2%概率 ${minT3}-${maxT3})`;
        
        // 计算可能的评分范围
        const minScore = Math.min(mainCompanion.score, secondaryCompanion.score);
        const maxScore = Math.max(mainCompanion.score, secondaryCompanion.score);
        const finalMin = Math.floor(minScore * 0.7); // 最低70%
        const finalMax = Math.ceil(maxScore * 1.3); // 最高130%
        previewScoreRange.textContent = `${finalMin}-${finalMax}`;
    } else {
        previewGeneration.textContent = '--';
        previewTalentCount.textContent = '--';
        previewScoreRange.textContent = '--';
    }
}

// 获取伴侣代数
function getCompanionGeneration(companion) {
    // 检查名字中是否包含代数信息
    const match = companion.name.match(/(\d+)代/);
    if (match) {
        return parseInt(match[1]);
    }
    return 1; // 默认1代
}

// 更新伴侣信息显示
function updateCompanionInfo(elementId, companion) {
    const element = document.getElementById(elementId);
    if (!companion) {
        element.innerHTML = '<p>未选择</p>';
        return;
    }
    
    element.innerHTML = `
        <p>名称: ${companion.name}</p>
        <p>品阶: <span style="color: ${companionRarities[companion.rarity].color}">${companionRarities[companion.rarity].name}</span></p>
        <p>评分: ${companion.score}</p>
        <p>天赋数量: ${companion.talents.length}</p>
        <p>进阶等级: +${companion.advanceLevel || 0}</p>
    `;
}

// 合成伴侣
function combineCompanions() {
    const mainId = document.getElementById('mainCompanionSelect').value;
    const secondaryId = document.getElementById('secondaryCompanionSelect').value;
    
    if (!mainId || !secondaryId || mainId === secondaryId) {
        logAction('请选择不同的主副伴侣', 'error');
        return;
    }
    
    const mainCompanion = player.companions.find(c => c.id === mainId);
    const secondaryCompanion = player.companions.find(c => c.id === secondaryId);
     // 检查伴侣是否在探险中
    if (mainCompanion && mainCompanion.onExpedition) {
        logAction(`${mainCompanion.name}正在探险中，无法合成！`, "error");
        return;
    }
    
    if (secondaryCompanion && secondaryCompanion.onExpedition) {
        logAction(`${secondaryCompanion.name}正在探险中，无法合成！`, "error");
        return;
    }
    if (!mainCompanion || !secondaryCompanion) {
        logAction('选择的伴侣不存在', 'error');
        return;
    }


    // 计算新一代数
    const mainGen = getCompanionGeneration(mainCompanion);
    const secondaryGen = getCompanionGeneration(secondaryCompanion);
    const newGen = Math.max(mainGen, secondaryGen) + 1;
    
    // 随机选择新名字（主或副的名字 + 代数）
    const newName = Math.random() > 0.5 ? 
        `${mainCompanion.name.replace(/ \d+代$/, '')} ${newGen}代` : 
        `${secondaryCompanion.name.replace(/ \d+代$/, '')} ${newGen}代`;
    
    // 计算天赋数量
    const totalTalents = mainCompanion.talents.length + secondaryCompanion.talents.length;
    let newTalentCount;
    const rand = Math.random();
    
    if (rand < 0.80) {
        // 80% 概率：1-50%
        newTalentCount = Math.floor(Math.random() * (totalTalents * 0.5) + totalTalents * 0.2);
    } else if (rand < 0.97) {
        // 18% 概率：50-75%
        newTalentCount = Math.floor(Math.random() * (totalTalents * 0.25) + totalTalents * 0.5);
    } else {
        // 2% 概率：75-100%
        newTalentCount = Math.floor(Math.random() * (totalTalents * 0.25) + totalTalents * 0.75);
    }
    newTalentCount = Math.max(1, newTalentCount); // 至少1个天赋
    
    // 计算新评分（基于主副评分范围，上下浮动30%）
    const minScore = Math.min(mainCompanion.score, secondaryCompanion.score);
    const maxScore = Math.max(mainCompanion.score, secondaryCompanion.score);
    const scoreRange = maxScore * 1.3 - minScore * 0.7;
    const newScore = Math.floor(Math.random() * scoreRange + minScore * 0.7);
    
    // 生成新天赋（结合主副天赋的类型，有几率生成新类型）
    const allTalentTypes = [...mainCompanion.talents.map(t => t.type), ...secondaryCompanion.talents.map(t => t.type), ...Array.from({length: 3}, () => Math.floor(Math.random() * talentTypes.length))];
    const newTalents = [];
    
    for (let i = 0; i < newTalentCount; i++) {
        // 随机选择天赋类型（优先从主副天赋中选择）
        const type = allTalentTypes[Math.floor(Math.random() * allTalentTypes.length)];
        
        // 天赋天赋等级（基于主副天赋等级范围）
        const mainRanks = mainCompanion.talents.filter(t => t.type === type).map(t => t.rank);
        const secondaryRanks = secondaryCompanion.talents.filter(t => t.type === type).map(t => t.rank);
        const allRanks = [...mainRanks, ...secondaryRanks];
        
        let rank;
        if (allRanks.length > 0) {
            const minRank = Math.min(...allRanks);
            const maxRank = Math.max(...allRanks);
            // 上下浮动30%
            const newMin = Math.max(0, Math.floor(minRank * 0.7));
            const newMax = Math.min(8, Math.ceil(maxRank * 1.3));
            rank = Math.floor(Math.random() * (newMax - newMin + 1)) + newMin;
        } else {
            // 如果没有相同类型的天赋，随机生成
            rank = Math.floor(Math.random() * 9); // 0-8级
        }
        
        newTalents.push({ type, rank });
    }
   const newAdvanceLevel = Math.max(
        mainCompanion.advanceLevel || 0,
        secondaryCompanion.advanceLevel || 0
    );
  
    const rarities = ['angel', 'emyyyy', 'jlyyyy'];
    const randomIndex = Math.floor(Math.random() * rarities.length);
    const selectedRarity = rarities[randomIndex];
    // 创建新伴侣
    const newCompanion = {
        id: 'comp_' + Date.now() + Math.floor(Math.random() * 1000),
        name: newName,
        rarity: selectedRarity,// 合成后为天使品质
        talents: newTalents,
        score: Math.min(50000, newScore), // 天使品质上限更高
        locked: false,
        advanceLevel: newAdvanceLevel,
       qualityMultiplier: qualityMultiplier // 添加品质加成
    };
    
    // 移除主副伴侣
    player.companions = player.companions.filter(c => c.id !== mainId && c.id !== secondaryId);
    
    // 如果装备的是被合成的伴侣，取消装备
    if (player.equippedCompanionId === mainId || player.equippedCompanionId === secondaryId) {
        player.equippedCompanionId = null;
    }
    
    // 添加新伴侣
    player.companions.push(newCompanion);
    
    // 提示信息
   logAction(`成功合成${newGen}代特殊伴侣：${newName}（保留最高进阶等级${newAdvanceLevel}）`, 'success');
    
    // 更新显示
    updateCompanionDisplay();
    closeCombinePanel();
}
// 计算伴侣天赋加成（需要整合到属性计算中）
function getCompanionBonuses() {
    if (!player.equippedCompanionId) return {
        attackMultiplier: 1,
        critDamageMultiplier: 1,
        healthMultiplier: 1,
        allStatsMultiplier: 1,
        combo: 0,
        critRateMultiplier: 1
    };
    
    const companion = player.companions.find(c => c.id === player.equippedCompanionId);
    if (!companion) return {
        attackMultiplier: 1,
        critDamageMultiplier: 1,
        healthMultiplier: 1,
        allStatsMultiplier: 1,
        combo: 0,
        critRateMultiplier: 1
    };
    
    // 基础加成
    let bonuses = {
        attackMultiplier: 1,
        critDamageMultiplier: 1,
        healthMultiplier: 1,
        allStatsMultiplier: 1,
        combo: 0,
        critRateMultiplier: 1
    };
    
    
    const effectiveScore = Math.min(companion.score, 30000);
    
    // 应用天赋，最多25个
    const maxTalents = 25;
    const effectiveTalents = companion.talents.slice(0, maxTalents);
    
    effectiveTalents.forEach(talent => {
        const rank = talent.rank;
        const type = talentTypes[talent.type];
        const baseMultiplier = companionRarities[companion.rarity].upgradeMultiplier;
        const scoreDivided = Math.floor(effectiveScore / 100);
        const qualityMultiplier = (scoreDivided + baseMultiplier) * player.companionLevel;
        const advanceMultiplier = 1 + (companion.advanceLevel * 1);
        switch (talent.type) {
            case 0: // 攻击
                bonuses.attackMultiplier += (type.base + type.perLevel * rank) * (1+qualityMultiplier*0.01) * advanceMultiplier;
                break;
            case 1: // 爆伤
                bonuses.critDamageMultiplier += (type.base + type.perLevel * rank) *  (1+qualityMultiplier*0.01)  * advanceMultiplier;
                break;
            case 2: // 生命
                bonuses.healthMultiplier += (type.base + type.perLevel * rank) *  (1+qualityMultiplier*0.01)  * advanceMultiplier;
                break;
            case 3: // 全属性
                bonuses.allStatsMultiplier += (type.base + type.perLevel * rank) *  (1+qualityMultiplier*0.01)  * advanceMultiplier;
                break;
            case 4: // 连击
                bonuses.combo += (type.base + type.perLevel * rank) * 2 * advanceMultiplier ;
                break;
            case 5: // 暴击率
                bonuses.critRateMultiplier += (type.base + type.perLevel * rank) *  (1+qualityMultiplier*0.01)  * (1+advanceMultiplier*0.1) ;
                break;
        }
    });
    
    // 全属性加成应用到攻击和爆伤
    bonuses.attackMultiplier += bonuses.allStatsMultiplier;
    bonuses.critDamageMultiplier += bonuses.allStatsMultiplier;
    
    return bonuses;
}

// 切换通天塔UI
function toggleTowerUI() {
    // 检查转生次数是否达到100次（和普通打怪模式一致）
    if (player.reincarnationCount < 100) {
        alert("需要达到100转才能开启通天塔模式！");
        return;
    }
  
    const towerUI = document.getElementById('towerUI');
    towerUI.style.display = towerUI.style.display === 'none' ? 'block' : 'none';
    if (towerUI.style.display === 'block') {
        // 初始化玩家属性
        generateTowerMonster();
        initTowerPlayerStats();
        player.tower.playerHealth = player.battle.playerHealth;
    player.tower.playerAttack = player.battle.playerAttack;
    player.tower.playerCritRate = player.battle.playerCritRate;
    player.tower.playerCritDamage = player.battle.playerCritDamage;
    player.tower.playerAccuracy = player.battle.playerAccuracy;
    player.tower.playerDodge = player.battle.playerDodge;
        // 如果没有当前怪物，生成一个
        if (!player.tower.monster) {
            generateTowerMonster();
        }
        updateTowerUI();
    }
}

// 初始化通天塔玩家属性
function initTowerPlayerStats() {
    player.tower.playerHealth = player.battle.playerHealth;
    player.tower.playerAttack = player.battle.playerAttack;
    player.tower.playerCritRate = player.battle.playerCritRate;
    player.tower.playerCritDamage = player.battle.playerCritDamage;
    player.tower.playerMultiAttack = player.battle.playerMultiAttack;
}

// 生成通天塔怪物
function generateTowerMonster() {
    const floor = player.tower.currentFloor;
    const monsterRanks = ['普通', '精英', '普通BOSS', '特殊BOSS', '领主BOSS', '霸主级BOSS', '王级BOSS', '皇级BOSS', '帝级BOSS', '神级BOSS', '圣级BOSS'];
    const rankProbabilities = [0.45, 0.20, 0.10, 0.06, 0.05, 0.04, 0.03, 0.03, 0.02, 0.015, 0.005];

    // 随机生成怪物品阶
    let rankIndex = 0;
    let rand = Math.random();
    for (let i = 0; i < rankProbabilities.length; i++) {
        rand -= rankProbabilities[i];
        if (rand < 0) {
            rankIndex = i;
            break;
        }
    }
    const rank = monsterRanks[rankIndex];

    // 根据品阶选择词条
    const modifierPool = monsterRankModifiers[rank].pool;
    const selectCount = monsterRankModifiers[rank].selectCount;
    const selectedModifiers = [];
    const usedModifiers = new Set();

    for (let i = 0; i < selectCount; i++) {
        let modifier;
        do {
            modifier = modifierPool[Math.floor(Math.random() * modifierPool.length)];
        } while (usedModifiers.has(modifier));
        usedModifiers.add(modifier);
        selectedModifiers.push(modifier);
    }

    // 计算怪物属性（通天塔特殊逻辑）
    const baseHealth = 10000000000; // 初始1亿血量
    const healthMultiplier = Math.pow(1.001386, floor); // 每层乘以1.001386
    let attackMultiplier;
    
    if (floor <= 5) {
      attackMultiplier = Math.floor(Math.random() * 50) + 10;
    } else if (floor <= 1500) {
      attackMultiplier = Math.floor(Math.random() * 100) + 100;
    } else if (floor <= 3000) {
      attackMultiplier = 300 + (floor - 1499) * 200;
    } else if (floor <= 10000) {
      attackMultiplier = 1000 + (floor - 2999) * 1000;
    } else if (floor <= 25000) {
      attackMultiplier = 5000 + (floor - 9999) * 10000;
    } else if (floor <= 50000) {
      attackMultiplier = 10000 + (floor - 24999) * 1000000;
    } else if (floor <= 75000) {
      attackMultiplier = 10000 + (floor - 49999) * 1e9;
    } else if (floor <= 100000) {
      attackMultiplier = 10000 + (floor - 74999) * 1e12;
    } else if (floor <= 125000) {
      attackMultiplier = 10000 + (floor - 99999) * 1e15;
    } else if (floor <= 150000) {
      attackMultiplier = 10000 + (floor - 124999) * 1e18;
    } else if (floor <= 175000) {
      attackMultiplier = 10000 + (floor - 149999) * 1e21;
    } else if (floor <= 200000) {
      attackMultiplier = 200000 + (floor - 164999) * 1e24;
    } else if (floor <= 225000) {
      attackMultiplier = 200000 + (floor - 199999) * 1e27;
    } else if (floor <= 250000) {
      attackMultiplier = 3000000 + (floor - 224999) * 1e30;
    } else if (floor <= 275000) {
      attackMultiplier = 3000000 + (floor - 249999) * 1e35;
    } else if (floor <= 300000) {
      attackMultiplier = 3000000 + (floor - 274999) * 1e40;
    } else if (floor <= 325000) {
      attackMultiplier = 50000000 + (floor - 299999) * 1e50;
    } else if (floor <= 350000) {
      attackMultiplier = 60000000 + (floor - 324999) * 1e60;
    } else if (floor <= 375000) {
      attackMultiplier = 60000000 + (floor - 349999) * 1e80;
   }  else if (floor <= 400000) {
     attackMultiplier = 70000000 + (floor - 374999) * 1e100;
    } else if (floor <= 425000) {
     attackMultiplier = 80000000 + (floor - 399999) * 1e120;
    } else if (floor <= 450000) {
     attackMultiplier = 80000000 + (floor - 424999) * 1e150;
    } else {
      attackMultiplier = 90000000 + (floor - 409999) * 1e200;
    }

    let attack = attackMultiplier * (3 + floor * 50);
    let damageReduction = 0;
    let dodgeChance = 0;
    let blockCount = 0;
    let attackCount = 1;
    let damageTakenMultiplier = 1;

    selectedModifiers.forEach(modifier => {
        const effect = monsterModifiers[modifier];
        if (effect.attackMultiplier) attack *= effect.attackMultiplier;
        if (effect.damageReduction) damageReduction += effect.damageReduction;
        if (effect.dodgeChance) dodgeChance += effect.dodgeChance;
        if (effect.blockCount) blockCount += effect.blockCount;
        if (effect.attackCount) attackCount = effect.attackCount;
        if (effect.damageTakenMultiplier) damageTakenMultiplier *= effect.damageTakenMultiplier;
    });

    // 生成怪物，包含复活次数
    player.tower.monster = {
        name: `${getRandomMonsterName()} 等级${Math.floor(floor * 3 + 7)}`,
        rank: rank,
        health: baseHealth * healthMultiplier,
        maxHealth: baseHealth * healthMultiplier,
        attack: attack,
        modifiers: selectedModifiers,
        damageReduction: damageReduction,
        dodgeChance: dodgeChance,
        blockCount: blockCount,
        attackCount: attackCount,
        damageTakenMultiplier: damageTakenMultiplier,
        resurrectionsLeft: 3 // 3次复活机会
    };
}

// 攻击通天塔怪物
function attackTowerMonster() {
const now = Date.now();
            // 移除超过1秒的点击记录
            player.clickTimestamps = player.clickTimestamps.filter(timestamp => now - timestamp < 1000);

            const clickLimit = 10 + player.reincarnationStats.clickLimitBonus.level; // 每级增加1次点击上限
            if (player.clickTimestamps.length >= clickLimit) {
                logAction("点击速度过快，请稍后再试！", "error");
                return;
            }

            player.clickTimestamps.push(now);
// 使用打怪模式属性
    const playerAttack = player.battle.playerAttack;
    const playerCritRate = player.battle.playerCritRate;
    const playerCritDamage = player.battle.playerCritDamage;
    const playerMultiAttack = player.battle.playerMultiAttack;

    if (!player.tower.monster) return;
    
    const monster = player.tower.monster;
    let totalDamage = 0;
    let normalDamage = 0;
    let critDamage = 0;
    let critCount = 0;
    let dodgeCount = 0;
    let totalAttacks = player.tower.playerMultiAttack || 1;
    let battleLogs = [];
    let monsterDefeated = false;

    // 玩家攻击
    for (let i = 0; i < totalAttacks; i++) {
        // 检查是否已被击败
        if (monster.health <= 0) break;
        
        // 检查闪避
        if (Math.random() < monster.dodgeChance) {
            dodgeCount++;
            battleLogs.push(`${monster.name}闪避了你的攻击！`);
            continue;
        }
        
        // 计算基础伤害
        let damage = player.tower.playerAttack;
        
        // 应用伤害减免
        damage *= (1 - monster.damageReduction);
        
        // 应用伤害乘数
        damage *= monster.damageTakenMultiplier;
        
        // 检查暴击
        let isCrit = Math.random() < player.tower.playerCritRate;
        if (isCrit) {
            damage *= player.tower.playerCritDamage;
            critCount++;
            critDamage += damage;
        } else {
            normalDamage += damage;
        }
        
        // 应用伤害
        monster.health -= damage;
        totalDamage += damage;
        
        battleLogs.push(`你对${monster.name}造成了${Math.floor(damage)}点伤害${isCrit ? '（暴击！）' : ''}`);
        
        // 检查怪物是否被击败
        if (monster.health <= 0) {
            // 检查是否还有复活次数
            if (monster.resurrectionsLeft > 0) {
                monster.resurrectionsLeft--;
                monster.health = monster.maxHealth; // 复活回满血
                battleLogs.push(`${monster.name}复活了！剩余复活次数: ${monster.resurrectionsLeft}`);
                
                // BOSS复活后立刻攻击玩家1次
                towerMonsterCounterAttack();
            } else {
                battleLogs.push(`你击败了${monster.name}！`);
                monsterDefeated = true;
            }
            break; // 结束当前连击
          initTowerPlayerStats();
         updateOfficialSystemDisplay();
        updateMonsterUI(); // 更新UI显示
        }
    }

    // 输出综合攻击日志
    battleLogs.push(`你造成了${Math.floor(totalDamage)}点伤害 (${totalAttacks}连击) - 普通伤害: ${Math.floor(normalDamage)}, 闪避x${dodgeCount}, 暴击x${critCount}`);
    
    // 添加到战斗日志
    battleLogs.forEach(log => {
        addTowerBattleLog(log);
    });

    // 如果怪物被彻底击败（无复活次数）
    if (monsterDefeated) {
        player.tower.currentFloor++;
        player.tower.maxFloor = Math.max(player.tower.maxFloor, player.tower.currentFloor);
        addTowerBattleLog(`通关通天塔第${player.tower.currentFloor}层！`);
        checkTitleUnlocks();
        // 更新总属性点
        player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
        player.attributes.remainingPoints++; // 每通关一层增加1点剩余属性点
        initTowerPlayerStats();
        // 自动进入下一关
        generateTowerMonster();
        updateTowerUI();
        return;
    }

    // 怪物反击（如果还活着）
    if (monster.health > 0) {
        towerMonsterCounterAttack();
    }

    // 检查玩家是否被击败
    if (player.tower.playerHealth <= 0) {
        addTowerBattleLog('你被怪物击败了！');
       // 重置当前层怪物
        generateTowerMonster();
        // 重置玩家状态
        initTowerPlayerStats();
      
      
    }

    updateTowerUI();

}

// 通天塔怪物反击
function towerMonsterCounterAttack() {
    const monster = player.tower.monster;
    if (!monster || monster.health <= 0) return;
    
    for (let i = 0; i < monster.attackCount; i++) {
        // 检查玩家闪避
        if (Math.random() < (player.attributes.dodge * 0.001 || 0)) {
            addTowerBattleLog(`你闪避了${monster.name}的攻击！`);
            continue;
        }        
        
        // 玩家受到伤害
        player.tower.playerHealth -= monster.attack;
        addTowerBattleLog(`${monster.name}对你造成了${monster.attack}点伤害`);
        
        // 检查玩家是否被击败
        if (player.tower.playerHealth <= 0) {
            break;
        }
    }
}

// 切换通天塔自动攻击
function toggleTowerAutoAttack() {
    player.tower.isAutoAttacking = !player.tower.isAutoAttacking;
    document.getElementById('towerAutoAttackStatus').textContent = player.tower.isAutoAttacking ? '开' : '关';
    
    if (player.tower.isAutoAttacking) {
        startTowerAutoAttack();
    } else {
        stopTowerAutoAttack();
    }
}

// 开始通天塔自动攻击
function startTowerAutoAttack() {
    // 先停止现有的自动攻击
    stopTowerAutoAttack();
    
    // 每秒攻击10次
    player.tower.autoAttackInterval = setInterval(() => {
        if (player.tower.isAutoAttacking && player.tower.monster) {
            attackTowerMonster();
        }
    }, 100);
}

// 停止通天塔自动攻击
function stopTowerAutoAttack() {
    if (player.tower.autoAttackInterval) {
        clearInterval(player.tower.autoAttackInterval);
        player.tower.autoAttackInterval = null;
    }
}

// 添加通天塔战斗日志
function addTowerBattleLog(message) {
    player.tower.battleLog.push({
        time: new Date(),
        message: message
    });
    
    // 限制日志长度
    if (player.tower.battleLog.length > 10) {
        player.tower.battleLog.shift();
    }
    
    // 更新UI显示
    updateTowerBattleLog();
}

// 更新通天塔战斗日志UI
function updateTowerBattleLog() {
    const logElement = document.getElementById('towerBattleLog');
    logElement.innerHTML = '';
    
    player.tower.battleLog.forEach(entry => {
        const logItem = document.createElement('div');
        logItem.className = 'battle-log-entry';
        logItem.textContent = entry.message;
        logElement.appendChild(logItem);
    });
    
    // 滚动到底部
    logElement.scrollTop = logElement.scrollHeight;
}

// 更新通天塔UI
function updateTowerUI() {
    // 更新玩家信息
    document.getElementById('towerPlayerHealth').textContent = Math.floor(player.tower.playerHealth).toExponential(3);
    document.getElementById('towerPlayerAttack').textContent = player.tower.playerAttack.toExponential(3);
    document.getElementById('towerPlayerCritRate').textContent = (player.tower.playerCritRate * 100).toFixed(1) + '%';
    document.getElementById('towerPlayerCritDamage').textContent = ((player.tower.playerCritDamage - 1) * 100).toFixed(1) + '%';

    // 更新通天塔层数显示
    document.getElementById('towerFloor').textContent = player.tower.currentFloor;
    document.getElementById('towerCurrentFloor').textContent = player.tower.currentFloor;
    
    const bonus = player.tower.currentFloor * 0.01; // 每层增加0.01%
    document.getElementById("towerBonus").textContent = bonus.toFixed(2) + "倍";
    // 更新怪物信息
    if (player.tower.monster) {
        const monster = player.tower.monster;
        document.getElementById('towerMonsterName').textContent = monster.name;
        document.getElementById('towerMonsterRank').textContent = monster.rank;
        document.getElementById('towerMonsterHealth').textContent = Math.floor(monster.health).toExponential(3); + '/' + Math.floor(monster.maxHealth).toExponential(3);
        document.getElementById('towerMonsterAttack').textContent = monster.attack.toExponential(3);
        document.getElementById('towerMonsterModifiers').textContent = monster.modifiers.join(', ');
        document.getElementById('towerMonsterResurrections').textContent = monster.resurrectionsLeft;
    }
    
    // 更新自动攻击状态
    document.getElementById('towerAutoAttackStatus').textContent = player.tower.isAutoAttacking ? '开' : '关';
    // 更新战斗日志
    updateTowerBattleLog();
}
// 老虎机配置
const slotMachineConfig = {
    symbols: ["🍒", "🍋", "🍊", "🍇", "🍉", "🍎", "7️⃣"],
    symbolProbabilities: [0.3, 0.25, 0.2, 0.15, 0.07, 0.02, 0.01],
    payouts: {
        "🍒🍒🍒": 5,
        "🍋🍋🍋": 10,
        "🍊🍊🍊": 15,
        "🍇🍇🍇": 20,
        "🍉🍉🍉": 25,
        "🍎🍎🍎": 50,
        "7️⃣7️⃣7️⃣": 100
    },
    minBet: 10,
    maxBet: 1000,
    autoSpinDelay: 2000 // 自动旋转间隔(毫秒)
};

// 初始化老虎机数据
function initSlotMachine() {
    if (!player.slotMachine) {
        player.slotMachine = {
            bet: 10,
            autoSpin: false,
            history: [],
            lastResult: null
        };
    }
}

// 切换老虎机界面
function toggleSlotMachine() {
    const overlay = document.getElementById("slotMachineOverlay");
    const ui = document.getElementById("slotMachineUI");
    
    if (ui.style.display === "block") {
        ui.style.display = "none";
        overlay.style.display = "none";
        
        // 停止自动旋转
        if (player.slotMachine.autoSpin) {
            toggleAutoSpin();
        }
    } else {
        ui.style.display = "block";
        overlay.style.display = "block";
        updateSlotMachineUI();
        
        // 初始化转轴符号
        initReels();
    }
}

// 初始化转轴符号
function initReels() {
    for (let i = 1; i <= 3; i++) {
        const reel = document.getElementById(`reel${i}`);
        reel.innerHTML = "";
        reel.style.top = "0px";
        
        // 为每个转轴添加符号
        for (let j = 0; j < 20; j++) {
            const symbolIndex = Math.floor(Math.random() * slotMachineConfig.symbols.length);
            const symbol = document.createElement("div");
            symbol.style.height = "100px";
            symbol.style.display = "flex";
            symbol.style.alignItems = "center";
            symbol.style.justifyContent = "center";
            symbol.style.fontSize = "40px";
            symbol.textContent = slotMachineConfig.symbols[symbolIndex];
            reel.appendChild(symbol);
        }
    }
}

// 更新老虎机界面
function updateSlotMachineUI() {
    document.getElementById("slotMachineBalance").textContent = formatNumber(player.items.yuzhou1);
    document.getElementById("currentBet").textContent = player.slotMachine.bet;
    
    const autoSpinButton = document.getElementById("autoSpinButton");
    autoSpinButton.textContent = `自动旋转: ${player.slotMachine.autoSpin ? "开启" : "关闭"}`;
    autoSpinButton.style.background = player.slotMachine.autoSpin ? 
        "linear-gradient(45deg, #FFD700, #FF8C00)" : "#444";
    
    // 更新历史记录
    const historyContainer = document.getElementById("slotHistory");
    historyContainer.innerHTML = "";
    
    player.slotMachine.history.slice(-5).forEach(result => {
        const historyItem = document.createElement("div");
        historyItem.style.fontSize = "12px";
        historyItem.style.marginBottom = "3px";
        
        if (result.win > 0) {
            historyItem.style.color = "#90EE90"; // 绿色表示赢
            historyItem.textContent = `${result.combination} - 赢得 ${formatNumber(result.win)} 星尘发票`;
        } else {
            historyItem.style.color = "#FF6B6B"; // 红色表示输
            historyItem.textContent = `${result.combination} - 未中奖`;
        }
        
        historyContainer.appendChild(historyItem);
    });
}

// 改变下注金额
function changeBet(amount) {
    const newBet = player.slotMachine.bet + amount * 10;
    
    if (newBet >= slotMachineConfig.minBet && newBet <= slotMachineConfig.maxBet) {
        player.slotMachine.bet = newBet;
        updateSlotMachineUI();
    }
}

// 旋转老虎机
function spinSlotMachine() {
    if (player.items.yuzhou1 < player.slotMachine.bet) {
        logAction("转生币不足，无法旋转老虎机", "error");
        return;
    }
    
    // 扣除下注金额
    player.items.yuzhou1 -= player.slotMachine.bet;
    
    // 禁用旋转按钮
    const spinButton = document.getElementById("spinButton");
    spinButton.disabled = true;
    spinButton.textContent = "旋转中...";
    
    // 生成随机结果
    const results = [];
    for (let i = 0; i < 3; i++) {
        const rand = Math.random();
        let cumulativeProb = 0;
        
        for (let j = 0; j < slotMachineConfig.symbolProbabilities.length; j++) {
            cumulativeProb += slotMachineConfig.symbolProbabilities[j];
            if (rand <= cumulativeProb) {
                results.push(slotMachineConfig.symbols[j]);
                break;
            }
        }
    }
    
    // 动画效果
    animateReels(results);
    
    // 检查中奖
    setTimeout(() => {
        checkWin(results);
        
        // 重新启用旋转按钮
        spinButton.disabled = false;
        spinButton.textContent = "旋转";
        
        // 如果自动旋转开启，继续旋转
        if (player.slotMachine.autoSpin) {
            setTimeout(() => {
                if (player.items.yuzhou1 >= player.slotMachine.bet) {
                    spinSlotMachine();
                } else {
                    toggleAutoSpin(); // 余额不足，停止自动旋转
                    logAction("星尘发票不足，自动旋转已停止", "warning");
                }
            }, slotMachineConfig.autoSpinDelay);
        }
    }, 3500); // 等待动画完成
}

// 转轴动画
function animateReels(results) {
    for (let i = 1; i <= 3; i++) {
        const reel = document.getElementById(`reel${i}`);
        const symbolHeight = 100; // 每个符号的高度
        
        // 随机停止位置，确保显示正确的符号
        const targetPosition = -((Math.floor(Math.random() * 5) + 5) * symbolHeight);
        
        // 设置动画
        reel.style.transition = "top 3s cubic-bezier(0.17, 0.67, 0.83, 0.67)";
        reel.style.top = `${targetPosition}px`;
    }
}

// 检查中奖
function checkWin(results) {
    const combination = results.join("");
    let winAmount = 0;
    
    // 检查是否中奖
    if (slotMachineConfig.payouts[combination]) {
        winAmount = player.slotMachine.bet * slotMachineConfig.payouts[combination];
        player.items.yuzhou1 += winAmount;
        
        // 显示中奖信息
        const resultElement = document.getElementById("slotResult");
        resultElement.textContent = `恭喜！${combination} 赢得 ${formatNumber(winAmount)} 星尘发票！`;
        resultElement.style.color = "#90EE90";
        resultElement.style.fontSize = "18px";
        
        // 中奖动画
        resultElement.animate([
            { transform: 'scale(1)', opacity: 1 },
            { transform: 'scale(1.2)', opacity: 0.8 },
            { transform: 'scale(1)', opacity: 1 }
        ], {
            duration: 500,
            iterations: 3
        });
        
        logAction(`老虎机中奖：${combination}，赢得 ${formatNumber(winAmount)} 星尘发票`, "success");
    } else {
        const resultElement = document.getElementById("slotResult");
        resultElement.textContent = "未中奖，再试一次！";
        resultElement.style.color = "#FF6B6B";
        
        logAction(`老虎机未中奖：${combination}`, "info");
    }
    
    // 保存结果历史
    player.slotMachine.history.push({
        combination: combination,
        win: winAmount,
        timestamp: Date.now()
    });
    
    // 限制历史记录数量
    if (player.slotMachine.history.length > 10) {
        player.slotMachine.history.shift();
    }
    
    updateSlotMachineUI();
    updateDisplay();
}

// 切换自动旋转
function toggleAutoSpin() {
    player.slotMachine.autoSpin = !player.slotMachine.autoSpin;
    updateSlotMachineUI();
    
    if (player.slotMachine.autoSpin && player.items.yuzhou1 >= player.slotMachine.bet) {
        spinSlotMachine();
    }
}

// 格式化数字显示
function formatNumber(num) {
    if (num >= 1e6) {
        return (num / 1e6).toFixed(2) + "M";
    } else if (num >= 1e3) {
        return (num / 1e3).toFixed(2) + "K";
    }
    return Math.floor(num);
}






// 官职配置
const officialConfig = [
    { level: 1, name: "将仕郎（九品）", attackMultiplier: 2, cost: 100 },
    { level: 2, name: "文林郎（九品）", attackMultiplier: 3, cost: 1000 },
    { level: 3, name: "登仕郎（九品）", attackMultiplier: 4, cost: 10000 },
    { level: 4, name: "儒林郎（九品）", attackMultiplier: 5, cost: 100000 },
    { level: 5, name: "承务郎（八品）", attackMultiplier: 6, cost: 1000000 },
    { level: 6, name: "承奉郎（八品）", attackMultiplier: 7, cost: 1000000 },
    { level: 7, name: "征事郎（八品）", attackMultiplier: 8, cost: 10000000 },
    { level: 8, name: "给事郎（八品）", attackMultiplier: 9, cost: 100000000 },
    { level: 9, name: "宣议郎（七品）", attackMultiplier: 10, cost: 1000000000 },
    { level: 10, name: "朝散郎（七品）", attackMultiplier: 15, cost: 1000000000 },
    { level: 11, name: "武骑尉（七品）", attackMultiplier: 20, cost: 10000000000 },
    { level: 12, name: "宣德郎（七品）", attackMultiplier: 25, cost: 100000000000 },
    { level: 13, name: "朝请郎（七品）", attackMultiplier: 30, cost: 1000000000000 },
    { level: 14, name: "云骑尉（七品）", attackMultiplier: 35, cost: 10000000000000 },
    { level: 15, name: "通直郎（六品）", attackMultiplier: 40, cost: 100000000000000 },
    { level: 16, name: "奉议郎（六品）", attackMultiplier: 45, cost: 1000000000000000 },
    { level: 17, name: "飞骑尉（六品）", attackMultiplier: 50, cost: 10000000000000000 },
    { level: 18, name: "飞骑尉（六品）", attackMultiplier: 55, cost: 100000000000000000 },
    { level: 19, name: "承议郎（六品）", attackMultiplier: 60, cost: 1000000000000000000 },
    { level: 20, name: "承议郎（六品）", attackMultiplier: 65, cost: 10000000000000000000 },
    { level: 21, name: "朝议郎（六品）", attackMultiplier: 70, cost: 100000000000000000000 },
    { level: 22, name: "晓骑尉（六品）", attackMultiplier: 75, cost: 1000000000000000000000 },
    { level: 23, name: "游击将军（五品）", attackMultiplier: 80, cost: 10000000000000000000000 },
    { level: 24, name: "游击将军（五品）", attackMultiplier: 85, cost: 100000000000000000000000 },
    { level: 25, name: "游骑将军（五品）", attackMultiplier: 90, cost: 1000000000000000000000000 },
    { level: 26, name: "骑都尉（五品）", attackMultiplier: 95, cost: 10000000000000000000000000 },
    { level: 27, name: "怀化郎将（五品）", attackMultiplier: 100, cost: 100000000000000000000000000 },
    { level: 28, name: "宁远将军（五品）", attackMultiplier: 150, cost: 1000000000000000000000000000 },
    { level: 29, name: "定远将军（五品）", attackMultiplier: 200, cost: 10000000000000000000000000000 },
    { level: 30, name: "归德中郎将（四品）", attackMultiplier: 250, cost: 100000000000000000000000000000 },
    { level: 31, name: "明威将军（四品）", attackMultiplier: 300, cost: 1000000000000000000000000000000 },
    { level: 32, name: "宣威将军（四品）", attackMultiplier: 350, cost: 10000000000000000000000000000000 },
    { level: 33, name: "轻车都尉（四品）", attackMultiplier: 400, cost: 100000000000000000000000000000000 },
    { level: 34, name: "怀化中郎将（四品）", attackMultiplier: 450, cost: 1000000000000000000000000000000000 },
    { level: 35, name: "忠武将军（四品）", attackMultiplier: 500, cost: 10000000000000000000000000000000000 },
    { level: 36, name: "归德将军（三品）", attackMultiplier: 550, cost: 100000000000000000000000000000000000 },
    { level: 37, name: "云麾将军（三品）", attackMultiplier: 600, cost: 1000000000000000000000000000000000000 },
    { level: 38, name: "护军（三品）", attackMultiplier: 650, cost: 10000000000000000000000000000000000000 },
    { level: 39, name: "怀化大将军（三品）", attackMultiplier: 700, cost: 100000000000000000000000000000000000000 },
    { level: 40, name: "冠军大将军（三品）", attackMultiplier: 750, cost: 1000000000000000000000000000000000000000 },
    { level: 41, name: "镇军大将军（二品）", attackMultiplier: 800, cost: 10000000000000000000000000000000000000000 },
    { level: 42, name: "辅国大将军（二品）", attackMultiplier: 850, cost: 100000000000000000000000000000000000000000 },
    { level: 43, name: "骠骑大将军（一品）", attackMultiplier: 900, cost: 1000000000000000000000000000000000000000000 },
    { level: 44, name: "异地王（特品）", attackMultiplier: 950, cost: 10000000000000000000000000000000000000000000 },
    { level: 45, name: "王爷（特品）", attackMultiplier: 1000, cost: 100000000000000000000000000000000000000000000 },
    { level: 46, name: "国师（特品）", attackMultiplier: 1500, cost: 1000000000000000000000000000000000000000000000 },
    { level: 47, name: "丞相（特品）", attackMultiplier: 2000, cost: 10000000000000000000000000000000000000000000000 },
    { level: 48, name: "辅佐王（特品）", attackMultiplier: 2500, cost: 100000000000000000000000000000000000000000000000 },
    { level: 49, name: "监证（圣品）", attackMultiplier: 3000, cost: 1000000000000000000000000000000000000000000000000 },
    { level: 50, name: "七皇子（圣品）", attackMultiplier: 3500, cost: 10000000000000000000000000000000000000000000000000 },
    { level: 51, name: "六皇子（圣品）", attackMultiplier: 4000, cost: 100000000000000000000000000000000000000000000000000 },
    { level: 52, name: "五皇子（圣品）", attackMultiplier: 4500, cost: 1000000000000000000000000000000000000000000000000000 },
    { level: 53, name: "四皇子（圣品）", attackMultiplier: 5000, cost: 10000000000000000000000000000000000000000000000000000 },
    { level: 54, name: "三皇子（神品）", attackMultiplier: 5500, cost: 100000000000000000000000000000000000000000000000000000 },
    { level: 55, name: "二皇子（神品）", attackMultiplier: 6000, cost: 1000000000000000000000000000000000000000000000000000000 },
    { level: 56, name: "一皇子（神品）", attackMultiplier: 6500, cost: 10000000000000000000000000000000000000000000000000000000 },
    { level: 57, name: "大殿下（神品）", attackMultiplier: 7000, cost: 100000000000000000000000000000000000000000000000000000000 },
    { level: 58, name: "太子爷（仙品）", attackMultiplier: 7500, cost: 1000000000000000000000000000000000000000000000000000000000 },
    { level: 59, name: "皇帝（仙品）", attackMultiplier: 8000, cost: 10000000000000000000000000000000000000000000000000000000000 },
    { level: 60, name: "太上皇（仙品）", attackMultiplier: 8500, cost: 100000000000000000000000000000000000000000000000000000000000 },
  { level: 61, name: "仙兵（帝品）", attackMultiplier: 9000, cost: 1000000000000000000000000000000000000000000000000000000000000000 },
 { level: 62, name: "仙君（帝品）", attackMultiplier: 9500, cost: 100000000000000000000000000000000000000000000000000000000000000000000 },
 { level: 63, name: "仙皇（帝品）", attackMultiplier: 10000, cost: 10000000000000000000000000000000000000000000000000000000000000000000000000 },
 { level: 64, name: "仙王（帝品）", attackMultiplier: 15000, cost: 1000000000000000000000000000000000000000000000000000000000000000000000000000000 },
 { level: 65, name: "仙帝（帝品）", attackMultiplier: 20000, cost: 100000000000000000000000000000000000000000000000000000000000000000000000000000000000 }

];

// 切换官职系统界面显示
function toggleOfficialSystem() {
   if (player.reincarnationCount < 10) {
        alert("需要达到10转才能开启官职系统！");
        return;
    }
    const ui = document.getElementById('officialSystemUI');
    const overlay = document.getElementById('officialSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateOfficialSystemDisplay();
    }
}

// 更新官职系统界面显示
function updateOfficialSystemDisplay() {
    const currentLevel = player.officialLevel;
    let currentOfficial = null;
    let nextOfficial = null;
    
    if (currentLevel > 0) {
        currentOfficial = officialConfig.find(oc => oc.level === currentLevel);
    }
    
    if (currentLevel < 65) {
        nextOfficial = officialConfig.find(oc => oc.level === currentLevel + 1);
    }
    
    // 更新当前官职显示
    document.getElementById('officialTitleDisplay').textContent = currentOfficial ? currentOfficial.name : '无';
    document.getElementById('officialLevelDisplay').textContent = currentLevel;
    document.getElementById('officialBonusDisplay').textContent = currentOfficial ? currentOfficial.attackMultiplier : 1;
    document.getElementById('currentOfficialTitle').textContent = currentOfficial ? currentOfficial.name : '无';
    
    // 更新下一阶官职信息
    const nextOfficialEl = document.getElementById('nextOfficialInfo');
    if (nextOfficial) {
        nextOfficialEl.innerHTML = `${nextOfficial.name} - 攻击加成: ${nextOfficial.attackMultiplier}倍, 消耗: ${formatNumber(nextOfficial.cost)}转生币`;
    } else if (currentLevel >= 65) {
        nextOfficialEl.textContent = '已达到最高官职';
    } else {
        nextOfficialEl.textContent = '请升级官职';
    }
}

// 按指定次数升级官职
function upgradeOfficialByAmount() {
    const amount = parseInt(document.getElementById('officialUpgradeAmount').value) || 1;
    let upgraded = 0;
    
    for (let i = 0; i < amount; i++) {
        if (!upgradeOfficial()) {
            break;
        }
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级官职！`, 'success');
        updateOfficialSystemDisplay();
        updateDisplay();
    }
}        

// 一键升级到最大可能等级
function upgradeOfficialMaxPossible() {
    let upgraded = 0;
    
    while (upgradeOfficial()) {
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级官职！`, 'success');
        updateOfficialSystemDisplay();
        updateDisplay();
    }
}

// 升级一级官职
function upgradeOfficial() {
    const nextLevel = player.officialLevel + 1;
    if (nextLevel > 65) {
        logAction("已达到最高官职！", "error");
        return false;
    }
    
    const nextOfficial = officialConfig.find(oc => oc.level === nextLevel);
    if (!nextOfficial) {
        logAction("无法找到下一阶官职配置！", "error");
        return false;
    }
    
    if (player.reincarnationCoin >= nextOfficial.cost) {
        player.reincarnationCoin -= nextOfficial.cost;
        player.officialLevel = nextLevel;
        return true;
    } else {
        logAction("转生币不足，无法升级官职！", "error");
        return false;
    }
}

// 添加格式化大数字的函数（如果没有的话）
function formatNumber(num) {
    if (num >= 1e8) {
        return num.toExponential(3);
    } else {
        return num.toLocaleString();
    }
}
function getOfficialBonus() {
    if (player.officialLevel === 0) return 1;
    
    const official = officialConfig.find(oc => oc.level === player.officialLevel);
    return official ? official.attackMultiplier : 1;
}
// 跑商系统配置和数据
const tradingConfig = {
    cities: {
        '绿叶镇': { region: '森林区', connections: ['林荫城', '精灵之都'], travelTime: 10 },
        '林荫城': { region: '森林区', connections: ['绿叶镇', '精灵之都', '铁石堡'], travelTime: 15 },
        '精灵之都': { region: '森林区', connections: ['绿叶镇', '林荫城', '王都'], travelTime: 20 },
        '铁石堡': { region: '山区', connections: ['林荫城', '高山城', '矿石镇'], travelTime: 12 },
        '高山城': { region: '山区', connections: ['铁石堡', '矿石镇', '金沙城'], travelTime: 18 },
        '矿石镇': { region: '山区', connections: ['铁石堡', '高山城', '平原镇'], travelTime: 15 },
        '海港城': { region: '沿海区', connections: ['渔村', '珍珠港', '贸易中心'], travelTime: 10 },
        '渔村': { region: '沿海区', connections: ['海港城', '珍珠港'], travelTime: 8 },
        '珍珠港': { region: '沿海区', connections: ['海港城', '渔村', '香料市'], travelTime: 12 },
        '谷物乡': { region: '平原区', connections: ['牧野城', '平原镇'], travelTime: 10 },
        '牧野城': { region: '平原区', connections: ['谷物乡', '平原镇', '王都'], travelTime: 15 },
        '平原镇': { region: '平原区', connections: ['谷物乡', '牧野城', '矿石镇'], travelTime: 12 },
        '金沙城': { region: '沙漠区', connections: ['高山城', '绿洲镇', '香料市'], travelTime: 20 },
        '绿洲镇': { region: '沙漠区', connections: ['金沙城', '香料市'], travelTime: 15 },
        '香料市': { region: '沙漠区', connections: ['金沙城', '绿洲镇', '珍珠港'], travelTime: 18 },
        '王都': { region: '都市区', connections: ['精灵之都', '牧野城', '商盟总部', '贸易中心'], travelTime: 5 },
        '商盟总部': { region: '都市区', connections: ['王都', '贸易中心', '工艺之都'], travelTime: 8 },
        '贸易中心': { region: '都市区', connections: ['王都', '商盟总部', '海港城'], travelTime: 6 },
        '工艺之都': { region: '都市区', connections: ['商盟总部', '魔法学院'], travelTime: 10 },
        '魔法学院': { region: '都市区', connections: ['工艺之都'], travelTime: 12 }
    },

    goods: {
        '木材': { basePrice: 100, type: '资源', slots: 1, shelfLife: Infinity, fluctuation: '小', 
                production: ['绿叶镇', '林荫城', '精灵之都'], scarcity: ['金沙城', '绿洲镇', '香料市'] },
        '铁矿': { basePrice: 150, type: '资源', slots: 2, shelfLife: Infinity, fluctuation: '中',
                production: ['铁石堡', '高山城', '矿石镇'], scarcity: ['海港城', '渔村', '珍珠港'] },
        '谷物': { basePrice: 80, type: '农产品', slots: 1, shelfLife: 15, fluctuation: '中',
                production: ['谷物乡', '牧野城', '平原镇'], scarcity: ['铁石堡', '高山城', '矿石镇'] },
        '棉花': { basePrice: 180, type: '农产品', slots: 1, shelfLife: 30, fluctuation: '中',
                production: ['平原镇', '谷物乡'], scarcity: ['铁石堡', '高山城', '矿石镇'] },
        '盐': { basePrice: 300, type: '必需品', slots: 1, shelfLife: Infinity, fluctuation: '小',
                production: ['渔村', '海港城'], scarcity: ['铁石堡', '高山城', '矿石镇', '金沙城', '绿洲镇', '香料市'] },
        '鱼类': { basePrice: 280, type: '食品', slots: 1, shelfLife: 7, fluctuation: '大',
                production: ['渔村', '珍珠港'], scarcity: ['铁石堡', '高山城', '矿石镇', '金沙城', '绿洲镇', '香料市'] },
        '皮毛': { basePrice: 400, type: '特产', slots: 1, shelfLife: 90, fluctuation: '中',
                production: ['牧野城', '绿叶镇'], scarcity: ['海港城', '渔村', '珍珠港'] },
        '草药': { basePrice: 250, type: '特产', slots: 1, shelfLife: 30, fluctuation: '大',
                production: ['林荫城', '香料市'], scarcity: ['海港城', '渔村', '珍珠港', '金沙城', '绿洲镇'] },
        '陶器': { basePrice: 350, type: '工艺品', slots: 1, shelfLife: Infinity, fluctuation: '中',
                production: ['绿洲镇', '工艺之都'], scarcity: ['绿叶镇', '林荫城', '精灵之都'] },
        '香料': { basePrice: 500, type: '奢侈品', slots: 1, shelfLife: 180, fluctuation: '极大',
                production: ['香料市', '金沙城'], scarcity: ['绿叶镇', '林荫城', '精灵之都', '铁石堡', '高山城', '矿石镇'] },
        '丝绸': { basePrice: 900, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '大',
                production: ['平原镇', '工艺之都'], scarcity: ['绿叶镇', '林荫城', '精灵之都', '铁石堡', '高山城', '矿石镇'] },
        '珠宝': { basePrice: 1300, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['高山城', '王都'], scarcity: ['渔村', '海港城', '珍珠港', '谷物乡', '牧野城', '平原镇'] },
        '葡萄酒': { basePrice: 400, type: '特产', slots: 2, shelfLife: 60, fluctuation: '中',
                production: ['精灵之都', '王都'], scarcity: ['铁石堡', '高山城', '矿石镇', '金沙城', '绿洲镇'] },
        '牲畜': { basePrice: 600, type: '活物', slots: 3, shelfLife: Infinity, fluctuation: '小',
                production: ['牧野城', '平原镇'], scarcity: ['王都', '商盟总部', '贸易中心', '工艺之都', '魔法学院'] },
        '魔法水晶': { basePrice: 1000, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['魔法学院', '高山城'], scarcity: ['渔村', '海港城', '珍珠港', '谷物乡', '牧野城', '平原镇'] }
    },

    warehouseLevels: [
        { level: 1, capacity: 20, cost: 0 },
        { level: 2, capacity: 30, cost: 300000 },
        { level: 3, capacity: 40, cost: 1000000 },
        { level: 4, capacity: 50, cost: 5000000 },
        { level: 5, capacity: 60, cost: 10000000 },
        { level: 6, capacity: 70, cost: 50000000 },
        { level: 7, capacity: 80, cost: 100000000 },
        { level: 8, capacity: 90, cost: 500000000 },
        { level: 9, capacity: 100, cost: 1000000000 },
        { level: 10, capacity: 120, cost: 5000000000 }
    ],

    transports: [
        { name: '手推车', capacityBonus: 5, speedBonus: 0, cost: 10, maintenance: 0 },
        { name: '驴车', capacityBonus: 10, speedBonus: 1, cost: 200000, maintenance: 10000 },
        { name: '马队', capacityBonus: 20, speedBonus: 2, cost: 1000000, maintenance: 20000 },
        { name: '商队', capacityBonus: 30, speedBonus: 3, cost: 5000000, maintenance: 40000 },
        { name: 'A级战队', capacityBonus: 40, speedBonus: 4, cost: 50000000, maintenance: 50000 },
        { name: '王国商队', capacityBonus: 60, speedBonus: 5, cost: 100000000, maintenance: 800000 },
        { name: '帝国商队', capacityBonus: 80, speedBonus: 6, cost: 1000000000, maintenance: 100000 },
        { name: '皇国商队', capacityBonus: 100, speedBonus: 7, cost: 5000000000, maintenance: 200000 }
    ],

    employees: [
        { type: '初级商贩', efficiencyBonus: 5, cost: 5000, salary: 1000, requirement: 'warehouse30' },
        { type: '资深掌柜', efficiencyBonus: 15, cost: 20000, salary: 5000, requirement: 'warehouse50' },
        { type: '商业间谍', intelligenceDiscount: 30, cost: 50000, salary: 10000, requirement: 'reputation3' },
        { type: '保镖队长', robberyReduction: 50, cost: 30000, salary: 8000, requirement: 'experiencedRobbery' }
    ]
};

// 初始化玩家跑商数据
function initTradingData() {
    if (!player.trading) {
        player.trading = {
            currentCity: '王都',
            warehouse: {
                level: 1,
                capacity: 20,
                used: 0
            },
            transport: {
                type: '手推车',
                capacityBonus: 5,
                speedBonus: 0
            },
            inventory: {}, // 改为对象结构，记录每个商品的详细数据
           autoTrade: {
                enabled: false,
                routes: [],
                efficiency: 0.6,
                currentRoute: null,
                currentState: 'idle',
                currentProgress: 0,
                totalTravelTime: 0,
                lastUpdate: Date.now(),
                logs: [], // 新增：自动贸易日志
                stats: { // 新增：统计信息
                    totalProfit: 0,
                    totalTrades: 0,
                    successfulTrades: 0,
                    failedTrades: 0,
                    totalTravelTime: 0,
                    startTime: Date.now()
                },
            purchaseSettings: {
                    maxGoods: 5, // 最多采购5种商品
                    purchaseStrategy: 'priceDesc', // 价格降序策略
                    minProfitMargin: 10, // 最小利润率
                    maxWarehouseUsage: 0.8, // 最大货仓使用率
                    priceTolerance: 0.2 // 价格容忍度（超过最大买入价20%仍可购买）
                },
             flexibleTrade: {
                    enabled: true, // 启用灵活贸易
                    minProfitThreshold: 5, // 最小利润阈值
                    maxCityStayTime: 3600000, // 最大城市停留时间（1小时）
                    explorationChance: 0.2, // 探索新城市的概率
                    returnToBaseChance: 0.3, // 返回基地的概率
                    priceMonitoring: true // 启用价格监控
                },
            backgroundMode: false,
                lastBackgroundUpdate: Date.now(),
                backgroundInterval: null, 
                 currentCityStayStart: Date.now()
            },
            employees: [],
            tradeHistory: [],
             lastTradeTime: player.lastUpdate || Date.now(),
            tradeVolumeToday: 0,
            tradeCountToday: 0,
            cityPrices: {},
           lastPriceUpdate: player.lastUpdate || Date.now(), 
            isTraveling: false,
            travelStartTime: 0,
            travelEndTime: 0,
            travelDestination: '',
            insurance: {
                goods: false,
                transport: false
            },
            intelligence: {
                basic: true,
                advanced: false,
                full: false
            }
        };
        
        // 初始化城市价格
        initCityPrices();
    } else {
        // 兼容旧数据：如果inventory是简单数量形式，转换为新格式
        if (player.trading.inventory && typeof player.trading.inventory === 'object') {
            let needsConversion = false;
            Object.keys(player.trading.inventory).forEach(good => {
                if (typeof player.trading.inventory[good] === 'number') {
                    needsConversion = true;
                }
            });
            
            if (needsConversion) {
                const oldInventory = {...player.trading.inventory};
                player.trading.inventory = {};
                Object.keys(oldInventory).forEach(good => {
                    if (oldInventory[good] > 0) {
                        // 使用当前价格作为估算成本（因为没有历史记录）
                        const estimatedCost = player.trading.cityPrices[player.trading.currentCity][good] || tradingConfig.goods[good].basePrice;
                        player.trading.inventory[good] = {
                            quantity: oldInventory[good],
                            averageCost: estimatedCost,
                            totalCost: estimatedCost * oldInventory[good]
                        };
                    }
                });
                logAction("库存数据已升级为新格式", "info");
            }
        }
        
        // 检查是否有未完成的旅行
        if (player.trading.isTraveling) {
            const now = Date.now();
            if (now >= player.trading.travelEndTime) {
                completeTravel();
            } else {
                player.trading.travelInterval = setInterval(checkTravelStatus, 1000);
            }
        }
    }
}

// 初始化城市价格
function initCityPrices() {
    Object.keys(tradingConfig.cities).forEach(city => {
        player.trading.cityPrices[city] = {};
        Object.keys(tradingConfig.goods).forEach(good => {
            player.trading.cityPrices[city][good] = calculateCurrentPrice(city, good);
        });
    });
}
function calculateCurrentPrice(city, good) {
    const goodConfig = tradingConfig.goods[good];
    let price = goodConfig.basePrice;
    
    // 地区修正
    if (goodConfig.production.includes(city)) {
        price *= 0.75; // 产地价格-25%
    } else if (goodConfig.scarcity.includes(city)) {
        price *= 1.3; // 稀缺地价格+30%
    } else {
        price *= 1.1; // 普通地区+10%
    }
    
    // 随机波动 (-30% 到 +50%)
    const randomFluctuation = Math.random() * 0.8 - 0.3;
    price *= (1 + randomFluctuation);
    
    return Math.round(price);
}

// 更新城市价格（每小时）
function updateCityPrices() {
    const now = Date.now();
    const hoursSinceUpdate = (now - player.trading.lastPriceUpdate) / (1000 * 60 * 60);
    
    if (hoursSinceUpdate >= 1) {
        Object.keys(tradingConfig.cities).forEach(city => {
            Object.keys(tradingConfig.goods).forEach(good => {
                player.trading.cityPrices[city][good] = calculateCurrentPrice(city, good);
            });
        });
        player.trading.lastPriceUpdate = now;
    }
}

function addAutoTradeLog(message, type = 'info') {
    // 确保消息有效
    if (!message || typeof message !== 'string') {
        console.error("无效的日志消息:", message);
        return;
    }
    
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = {
        timestamp,
        message,
        type,
        city: player.trading.currentCity,
        state: player.trading.autoTrade.currentState,
        funds: player.nightClub.starCoins,
        warehouseUsage: calculateWarehouseUsage(),
        isTraveling: player.trading.isTraveling,
        purchaseOpportunities: getAllPurchasableGoods().length,
        saleOpportunities: getAllSalableGoods().length
    };
    
    player.trading.autoTrade.logs.unshift(logEntry);
    
    // 限制日志数量
    if (player.trading.autoTrade.logs.length > 50) {
        player.trading.autoTrade.logs.pop();
    }
    
    // 如果日志界面打开，实时更新
    const logModal = document.getElementById('autoTradeLogModal');
    if (logModal && logModal.style.display === 'block') {
        updateAutoTradeLogDisplay();
    }
    
    // 更新界面状态显示
    updateAutoTradeTab();
}


function withRetry(func, maxRetries = 3, delay = 100) {
    return function(...args) {
        let retries = 0;
        
        function attempt() {
            try {
                return func.apply(this, args);
            } catch (error) {
                if (retries < maxRetries) {
                    retries++;
                    console.warn(`操作失败，第${retries}次重试:`, error);
                    setTimeout(attempt, delay * retries);
                } else {
                    console.error(`操作失败，已达到最大重试次数:`, error);
                    throw error;
                }
            }
        }
        
        return attempt();
    };
}
const safeUpdateAutoTradeProgressBar = withRetry(updateAutoTradeProgressBar);
const safeUpdateAutoTradeTab = withRetry(updateAutoTradeTab);
const safeRunAutoTrade = withRetry(runAutoTrade);
// 切换跑商系统界面
function toggleTradingSystem() {
    if (player.reincarnationCount < 1000) {
        alert("需要达到1000转才能开启跑商系统！");
        return;
    }
    
    initTradingData();
    updateCityPrices();
    
    const overlay = document.getElementById('tradingSystemOverlay');
    const ui = document.getElementById('tradingSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateTradingUI();
    }
}

// 更新跑商界面显示
function updateTradingUI() {
    // 更新状态栏
    document.getElementById('currentCity').textContent = player.trading.currentCity;
    document.getElementById('tradingStarCoins').textContent = player.nightClub.starCoins.toFixed(0);
    document.getElementById('warehouseCapacity').textContent = 
        `${player.trading.warehouse.used}/${player.trading.warehouse.capacity + player.trading.transport.capacityBonus}`;
    document.getElementById('transportType').textContent = player.trading.transport.type;
    addCancelTravelButton();
    // 添加库存统计按钮
    addInventorySummaryButton();

    // 更新市场标签页
    updateMarketTab();
    
    // 更新地图标签页
    updateMapTab();
    
    // 更新自动贸易标签页
    updateAutoTradeTab();
    
    // 更新经营管理标签页
    updateManagementTab();
}

// 更新市场标签页
function updateMarketTab() {
    const city = player.trading.currentCity;
    const goodsList = document.getElementById('cityGoodsList');
    const inventoryList = document.getElementById('playerInventory');
    
    // 清空现有内容
    goodsList.innerHTML = '';
    inventoryList.innerHTML = '';
    
    // 生成商品列表（市场商品）
    Object.keys(tradingConfig.goods).forEach(good => {
        const price = player.trading.cityPrices[city][good];
        const goodConfig = tradingConfig.goods[good];
        
        const goodElement = document.createElement('div');
        goodElement.className = 'good-item';
        goodElement.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr; gap: 10px; padding: 5px; border-bottom: 1px solid #444; align-items: center;">
                <div><strong>${good}</strong></div>
                <div>${price.toLocaleString()}星币</div>
                <div>${goodConfig.type}</div>
                <div>${goodConfig.slots}格</div>
                <div style="color: ${getPriceTrendColor(good, city)}">${getPriceTrend(good, city)}</div>
                <div>
                    <button onclick="buyGood('${good}', 1)" style="padding: 2px 8px; margin: 1px;">买1</button>
                    <button onclick="buyGood('${good}', 10)" style="padding: 2px 8px; margin: 1px;">买10</button>
                </div>
            </div>
        `;
        goodsList.appendChild(goodElement);
    });
    
    // 生成库存列表（玩家库存）
    Object.keys(player.trading.inventory).forEach(good => {
        const inventoryItem = player.trading.inventory[good];
        const quantity = inventoryItem.quantity;
        const currentPrice = player.trading.cityPrices[city][good];
        const averageCost = inventoryItem.averageCost;
        const totalCost = inventoryItem.totalCost;
        
        // 计算盈亏
        const currentValue = currentPrice * quantity;
        const profit = currentValue - totalCost;
        const profitRate = totalCost > 0 ? (profit / totalCost) * 100 : 0;
        
        const goodConfig = tradingConfig.goods[good];
        const profitColor = profit >= 0 ? '#4CAF50' : '#f44336'; // 绿色盈利，红色亏损
        const profitSign = profit >= 0 ? '+' : '';
        
        const inventoryElement = document.createElement('div');
        inventoryElement.className = 'inventory-item';
        inventoryElement.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr; gap: 10px; padding: 5px; border-bottom: 1px solid #444; align-items: center;">
                <div><strong>${good}</strong></div>
                <div>${quantity}个</div>
                <div>${currentPrice.toLocaleString()}星币</div>
                <div title="平均成本：${averageCost.toFixed(0)}星币">${averageCost.toFixed(0)}星币</div>
                <div style="color: ${profitColor}; font-weight: bold;">
                    ${profitSign}${profitRate.toFixed(1)}%
                </div>
                <div style="color: ${profitColor};">
                    ${profitSign}${Math.abs(profit).toFixed(0)}
                </div>
                <div>
                    <button onclick="sellGood('${good}', 1)" style="padding: 2px 8px; margin: 1px;">卖1</button>
                    <button onclick="sellGood('${good}', 10)" style="padding: 2px 8px; margin: 1px;">卖10</button>
                </div>
            </div>
        `;
        inventoryList.appendChild(inventoryElement);
    });
    
    // 如果没有库存，显示提示
    if (Object.keys(player.trading.inventory).length === 0) {
        inventoryList.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">暂无库存商品</div>';
    }
}
function getPriceTrend(good, city) {
    // 简化实现：随机生成趋势（实际应该基于历史价格）
    const trends = ['↑↑↑', '↑↑', '↑', '→', '↓', '↓↓', '↓↓↓'];
    const randomTrend = trends[Math.floor(Math.random() * trends.length)];
    return randomTrend;
}

// 获取价格趋势颜色（辅助函数）
function getPriceTrendColor(good, city) {
    const trend = getPriceTrend(good, city);
    if (trend.includes('↑')) return '#4CAF50'; // 绿色上涨
    if (trend.includes('↓')) return '#f44336'; // 红色下跌
    return '#FFC107'; // 黄色平稳
}
// 更新地图标签页
function updateMapTab() {
    const mapContainer = document.getElementById('mapTab');
    if (!mapContainer) return;
    
    mapContainer.innerHTML = `
        <div style="text-align: center; margin-bottom: 15px;">
            <h3>世界地图</h3>
            <div style="font-size: 0.9em; color: #aaa;">点击城市选择目的地</div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
            ${generateRegionMap()}
        </div>
        
        <div id="travelInfo" style="margin-top: 15px; padding: 15px; background: #333; border-radius: 5px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div><strong>当前位置:</strong> <span id="currentLocation">${player.trading.currentCity}</span></div>
                <div><strong>目标城市:</strong> <span id="targetCity">${player.trading.travelDestination || '-'}</span></div>
                <div><strong>预计时间:</strong> <span id="travelTime">${calculateTravelTime()}</span></div>
                <div><strong>状态:</strong> <span id="travelStatus">${getTravelStatus()}</span></div>
            </div>
            
            <div id="travelProgressContainer" style="${player.trading.isTraveling ? '' : 'display: none;'}">
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>旅行进度</span>
                    <span id="progressPercentage">0%</span>
                </div>
                <div style="width: 100%; height: 10px; background: #444; border-radius: 5px;">
                    <div id="travelProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 5px; transition: width 0.5s;"></div>
                </div>
            </div>
            
            <div style="margin-top: 15px; display: flex; gap: 10px;">
                <button id="startTravelBtn" onclick="startTravel()" style="flex: 1; padding: 8px; ${getStartTravelButtonStyle()}">${getTravelButtonText()}</button>
                <button id="cancelTravelBtn" onclick="cancelTravel()" style="flex: 1; padding: 8px; background: #f44336; ${!player.trading.isTraveling ? 'display: none;' : ''}">取消旅行</button>
             <button onclick="showIntelligencePurchaseOptions('${player.trading.currentCity}')" style="flex: 1; padding: 8px; background: #9C27B0; color: white; border: none; border-radius: 3px; cursor: pointer;">购买情报</button>
            </div>
            
            ${player.trading.autoTrade.enabled ? `
                <div style="margin-top: 10px; padding: 8px; background: #2a2a2a; border-radius: 3px; border-left: 3px solid #FF9800;">
                    <div style="color: #FF9800; font-size: 0.9em; text-align: center;">
                        ⚠️ 自动贸易已启用，手动旅行已禁用
                    </div>
                </div>
            ` : ''}
        </div>
    <!-- 显示当前城市的情报信息 -->
        <div style="margin-top: 20px;">
            <h4>当前情报信息</h4>
            ${generateCurrentIntelligenceInfo()}
        </div>
    `;
    
    // 更新旅行进度（如果正在旅行中）
    if (player.trading.isTraveling) {
        updateTravelProgress();
    }
}
// 生成当前情报信息
function generateCurrentIntelligenceInfo() {
    if (!player.trading.intelligence || !player.trading.intelligence[player.trading.currentCity]) {
        return `
            <div style="text-align: center; color: #aaa; padding: 20px; background: #2a2a2a; border-radius: 5px;">
                <p>暂无可用情报</p>
                <p style="font-size: 0.9em;">点击上方"购买情报"按钮获取市场信息</p>
            </div>
        `;
    }
    
    const cityIntelligence = player.trading.intelligence[player.trading.currentCity];
    let infoHtml = '';
    
    Object.keys(cityIntelligence).forEach(type => {
        const intel = cityIntelligence[type];
        const titles = {
            'marketPrices': '市场价格',
            'supplyDemand': '供需情况',
            'futureTrends': '未来趋势',
            'specialEvents': '特殊事件'
        };
        
        // 检查情报是否过期
        const isExpired = Date.now() > intel.expiryTime;
        
        infoHtml += `
            <div style="background: #2a2a2a; border-radius: 5px; padding: 15px; margin-bottom: 10px; border-left: 4px solid ${isExpired ? '#f44336' : '#4CAF50'};">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div style="font-weight: bold; color: ${isExpired ? '#f44336' : '#4CAF50'};">${titles[type]}</div>
                    <div style="font-size: 0.8em; color: ${isExpired ? '#f44336' : '#aaa'};">${isExpired ? '已过期' : '有效中'}</div>
                </div>
                <div style="font-size: 0.9em; color: #aaa;">
                    购买时间: ${new Date(intel.purchaseTime).toLocaleString()}
                    ${!isExpired ? `<br>剩余时间: ${Math.ceil((intel.expiryTime - Date.now()) / (60 * 1000))}分钟` : ''}
                </div>
                <div style="margin-top: 10px;">
                    <button onclick="viewIntelligenceDetails('${player.trading.currentCity}', '${type}')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">
                        查看详情
                    </button>
                </div>
            </div>
        `;
    });
    
    return infoHtml;
}

// 查看情报详情
function viewIntelligenceDetails(city, type) {
    const intelligence = player.trading.intelligence[city][type];
    showIntelligenceDetails(city, type, intelligence.data, intelligence.isFake);
}

// 添加情报配置到游戏配置
function initTradingConfig() {
    if (!tradingConfig.intelligence) {
        tradingConfig.intelligence = {
            marketPrices: {
                price: 5000,
                duration: 60, // 60分钟
                description: "获取所有商品的当前市场价格"
            },
            supplyDemand: {
                price: 8000,
                duration: 45, // 45分钟
                description: "了解市场供需情况，发现潜在机会"
            },
            futureTrends: {
                price: 12000,
                duration: 30, // 30分钟
                description: "预测未来价格趋势，把握市场动向"
            },
            specialEvents: {
                price: 15000,
                duration: 20, // 20分钟
                description: "获取特殊市场事件信息，抢占先机"
            }
        };
    }
}
function getStartTravelButtonStyle() {
    if (player.trading.autoTrade.enabled) {
        return 'background: #666; color: #999; cursor: not-allowed;';
    } else if (player.trading.isTraveling) {
        return 'background: #666; cursor: not-allowed;';
    } else {
        return 'background: #4CAF50; color: white; cursor: pointer;';
    }
}
function generateRegionMap() {
    const regions = {
        '森林区': ['绿叶镇', '林荫城', '精灵之都'],
        '山区': ['铁石堡', '高山城', '矿石镇'],
        '沿海区': ['海港城', '渔村', '珍珠港'],
        '平原区': ['谷物乡', '牧野城', '平原镇'],
        '沙漠区': ['金沙城', '绿洲镇', '香料市'],
        '都市区': ['王都', '商盟总部', '贸易中心', '工艺之都', '魔法学院']
    };
    
    let html = '';
    Object.keys(regions).forEach(region => {
        html += `
            <div class="region" style="background: #2a2a2a; padding: 10px; border-radius: 5px;">
                <h4 style="color: #FFD700; margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 5px;">${region}</h4>
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    ${regions[region].map(city => generateCityButton(city)).join('')}
                </div>
            </div>
        `;
    });
    
    return html;
}

// 生成城市按钮
function generateCityButton(city) {
    const isCurrentCity = player.trading.currentCity === city;
    const isSelected = player.trading.travelDestination === city;
    const isConnected = tradingConfig.cities[player.trading.currentCity].connections.includes(city);
    
    let buttonStyle = 'padding: 8px; border-radius: 3px; border: none; cursor: pointer;';
    
    // 如果自动贸易启用，禁用所有城市按钮
    if (player.trading.autoTrade.enabled) {
        buttonStyle += 'background: #666; color: #999; cursor: not-allowed;';
    } else if (isCurrentCity) {
        buttonStyle += 'background: #FFD700; color: black; font-weight: bold;';
    } else if (isSelected) {
        buttonStyle += 'background: #4CAF50; color: white;';
    } else if (isConnected) {
        buttonStyle += 'background: #2196F3; color: white;';
    } else {
        buttonStyle += 'background: #666; color: white; cursor: not-allowed;';
    }
    
    return `
        <button 
            onclick="selectDestination('${city}')" 
            style="${buttonStyle}"
            ${(player.trading.autoTrade.enabled || !isConnected && !isCurrentCity) ? 'disabled' : ''}
            title="${player.trading.autoTrade.enabled ? '自动贸易已启用，无法手动选择' : (!isConnected && !isCurrentCity ? '未连接到此城市' : `点击选择${city}作为目的地`)}"
        >
            ${city}
        </button>
    `;
}
function calculateTravelTime() {
    if (!player.trading.travelDestination) return '-';
    
    const baseTime = tradingConfig.cities[player.trading.travelDestination].travelTime;
    const speedBonus = player.trading.transport.speedBonus;
    const actualTime = baseTime * (100 - speedBonus) / 100;
    
    return `${actualTime.toFixed(1)}分钟`;
}

function getTravelStatus() {
    if (player.trading.isTraveling) {
        const now = Date.now();
        const progress = Math.min(100, ((now - player.trading.travelStartTime) / (player.trading.travelEndTime - player.trading.travelStartTime)) * 100);
        return `旅行中... ${progress.toFixed(1)}%`;
    }
    return player.trading.travelDestination ? '准备出发' : '选择目的地';
}

// 获取旅行按钮文本
function getTravelButtonText() {
    if (player.trading.autoTrade.enabled) {
        return '自动贸易中';
    } else if (player.trading.isTraveling) {
        return '旅行中';
    } else {
        return player.trading.travelDestination ? '开始旅行' : '选择目的地';
    }
}
function selectDestination(city) {
    // 如果自动贸易启用，禁用手动选择目的地
    if (player.trading.autoTrade.enabled) {
        logAction("自动贸易已启用，无法手动选择目的地", "warning");
        return;
    }
    
    if (player.trading.isTraveling) {
        logAction("当前正在旅行中，无法更改目的地", "error");
        return;
    }
    
    if (city === player.trading.currentCity) {
        logAction("已经在当前城市", "info");
        return;
    }
    
    // 检查是否连接
    if (!tradingConfig.cities[player.trading.currentCity].connections.includes(city)) {
        logAction(`无法直接前往${city}，需要先连接到该城市`, "error");
        return;
    }
    
    player.trading.travelDestination = city;
    logAction(`已选择目的地：${city}`, "info");
    
    // 更新界面
    updateMapTab();
}

// 更新自动贸易标签页

// 修改自动贸易界面HTML
function updateAutoTradeTab() {
    const autoTab = document.getElementById('autoTab');
    if (!autoTab) return;
    
    // 检查是否有保存的路线
    const hasRoutes = player.trading.autoTrade.routes && player.trading.autoTrade.routes.length > 0;
    
    // 获取当前城市的采购和销售机会数量
    const purchaseOpportunities = getAllPurchasableGoods().length;
    const saleOpportunities = getAllSalableGoods().length;
    
    autoTab.innerHTML = `
        <div style="margin-bottom: 20px;">
            <h3>智能灵活贸易系统 ${player.trading.autoTrade.backgroundMode ? '(后台运行中)' : ''}</h3>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <label>
                    <input type="checkbox" id="autoTradeEnabled" onchange="toggleAutoTrade()" ${player.trading.autoTrade.enabled ? 'checked' : ''} ${!hasRoutes ? 'disabled' : ''}>
                    启用自动贸易
                </label>
                <span id="autoTradeState" style="color: #FFD700; font-weight: bold;">${getAutoTradeStateText()}</span>
                <span id="backgroundIndicator" style="color: #4CAF50; font-size: 0.9em; ${player.trading.autoTrade.backgroundMode ? '' : 'display: none;'}">
                    ✓ 后台运行中
                </span>
                <button onclick="showAutoTradeLog()" style="margin-left: auto; background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">查看日志</button>
            </div>
            
            ${!hasRoutes ? `
                <div style="background: #2a2a2a; border-left: 4px solid #FF9800; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                    <h4 style="color: #FF9800; margin-top: 0;">⚠️ 未设置自动贸易路线</h4>
                    <p style="margin: 0; color: #aaa;">请先设置自动贸易路线才能启用自动贸易功能。</p>
                </div>
            ` : generateAutoTradeProgressBar()}
            
            <div id="autoTradeStatus" class="auto-trade-status" style="${player.trading.autoTrade.enabled ? '' : 'display: none;'}">
                <h4>当前状态 - ${player.trading.currentCity}</h4>
                
                <!-- 机会概览 -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div style="background: rgba(76,175,80,0.1); border-left: 4px solid #4CAF50; padding: 10px; border-radius: 4px;">
                        <div style="font-size: 0.9em; color: #aaa;">采购机会</div>
                        <div style="font-size: 1.2em; font-weight: bold; color: #4CAF50;">${purchaseOpportunities}</div>
                    </div>
                    <div style="background: rgba(33,150,243,0.1); border-left: 4px solid #2196F3; padding: 10px; border-radius: 4px;">
                        <div style="font-size: 0.9em; color: #aaa;">销售机会</div>
                        <div style="font-size: 1.2em; font-weight: bold; color: #2196F3;">${saleOpportunities}</div>
                    </div>
                </div>
                
                <div class="auto-trade-stats">
                    <div class="stat-item">
                        <div class="stat-label">当前城市</div>
                        <div class="stat-value">${player.trading.currentCity}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">运行模式</div>
                        <div class="stat-value">${player.trading.autoTrade.backgroundMode ? '后台运行' : '前台运行'}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">贸易状态</div>
                        <div class="stat-value">${getFlexibleTradeStateText()}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">城市停留</div>
                        <div class="stat-value">${formatTimeInCity()}分钟</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">货仓使用率</div>
                        <div class="stat-value">${calculateWarehouseUsage()}%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">可用资金</div>
                        <div class="stat-value">${player.nightClub.starCoins.toLocaleString()}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">今日利润</div>
                        <div class="stat-value" style="color: ${player.trading.tradeVolumeToday >= 0 ? '#4CAF50' : '#f44336'}">
                            ${player.trading.tradeVolumeToday >= 0 ? '+' : ''}${player.trading.tradeVolumeToday.toLocaleString()}
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">总利润</div>
                        <div class="stat-value" style="color: ${player.trading.autoTrade.stats.totalProfit >= 0 ? '#4CAF50' : '#f44336'}">
                            ${player.trading.autoTrade.stats.totalProfit >= 0 ? '+' : ''}${player.trading.autoTrade.stats.totalProfit.toLocaleString()}
                        </div>
                    </div>
                </div>
                 
                <div class="auto-trade-controls">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;">
                        <button onclick="pauseAutoTrade()" class="control-btn warning">${player.trading.autoTrade.backgroundMode ? '暂停后台' : '暂停'}</button>
                        <div class="auto-trade-controls">
                        <button onclick="stopAutoTrade()" class="control-btn danger">停止</button>
                         
                        <button onclick="showAutoTradeLog()" class="control-btn primary">查看日志</button>
                        ${player.trading.autoTrade.backgroundMode ? 
                         '<button onclick="forceForeground()" class="control-btn secondary">切换到前台</button>' : ''}
                        <button onclick="forceMoveToNewCity()" class="control-btn info">前往新城市</button>
                        <button onclick="forceStayInCurrentCity()" class="control-btn success">停留当前城市</button>
                        <button onclick="resetAutoTradeState()" class="control-btn default">重置状态</button>
                        <button onclick="forceCheckOpportunities()" class="control-btn primary">立即检查机会</button>
                    </div>
                </div>
                
                ${isFrequentTravelDetected() ? `
                    <div style="margin-top: 15px; padding: 10px; background: #f44336; border-radius: 5px; text-align: center;">
                        <strong style="color: white;">⚠️ 检测到频繁旅行，建议重置状态或停留当前城市</strong>
                    </div>
                ` : ''}
            </div>
        </div>
        
        
        <div id="autoTradeSettings" style="${player.trading.autoTrade.enabled ? 'display: none;' : 'display: block;'}">
            <h4>设置灵活贸易路线</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div>
                    <label>最小利润率:</label>
                    <input type="number" id="minProfitMargin" value="10">%
                </div>
                <div>
                    <label>单次资金:</label>
                    <input type="number" id="tradeCapital" value="10000">
                </div>
            </div>
            
            <h4>选择贸易商品（最多5种）</h4>
            <div id="goodsSelection" style="margin-bottom: 15px;">
                ${generateGoodsSelection()}
            </div>
            
            <h4>采购策略设置</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div>
                    <label>采购策略:</label>
                    <select id="purchaseStrategy">
                        <option value="priceDesc">价格降序（先买最贵的）</option>
                        <option value="priceAsc">价格升序（先买最便宜的）</option>
                        <option value="profitMargin">利润率优先</option>
                    </select>
                </div>
                <div>
                    <label>最大货仓使用率:</label>
                    <input type="number" id="maxWarehouseUsage" value="80" min="50" max="95">%
                </div>
                <div>
                    <label>价格容忍度:</label>
                    <input type="number" id="priceTolerance" value="20" min="0" max="50">%
                </div>
            </div>
            
            <h4>灵活贸易设置</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div>
                    <label>最大城市停留时间:</label>
                    <input type="number" id="maxCityStayTime" value="60" min="10" max="240">分钟
                </div>
                <div>
                    <label>探索新城市概率:</label>
                    <input type="number" id="explorationChance" value="20" min="0" max="100">%
                </div>
                <div>
                    <label>最小利润阈值:</label>
                    <input type="number" id="minProfitThreshold" value="5" min="0" max="50">%
                </div>
                <div>
                    <label>价格监控:</label>
                    <select id="priceMonitoring">
                        <option value="true">启用</option>
                        <option value="false">禁用</option>
                    </select>
                </div>
            </div>
            
            <button onclick="saveAutoTradeRoute()" style="background: #4CAF50; padding: 8px 16px;">保存路线</button>
        </div>
        
       <div id="autoTradeRoutes" style="margin-top: 20px;">
            <h4>已保存的路线 ${hasRoutes ? `(${player.trading.autoTrade.routes.length}条)` : ''}</h4>
            ${hasRoutes ? generateAutoTradeRoutes() : `
                <div style="text-align: center; color: #aaa; padding: 20px; background: #2a2a2a; border-radius: 5px;">
                    <p>暂无保存的路线</p>
                    <p style="font-size: 0.9em;">请在下方设置贸易路线</p>
                </div>
            `}
        </div>
        
        <div style="margin-top: 20px; padding: 10px; background: #2a2a2a; border-radius: 5px; border-left: 4px solid #4CAF50;">
            <h4 style="color: #4CAF50; margin-top: 0;">灵活贸易说明</h4>
            <ul style="margin: 0; padding-left: 20px; font-size: 0.9em;">
                <li>系统会在任何城市寻找采购和销售机会</li>
                <li>到达新城市后会同时检查采购和销售机会</li>
                <li>货仓满了或资金不足时会自动前往其他城市</li>
                <li>会根据价格自动决定最佳行动</li>
                <li>会自动探索新城市寻找更好的机会</li>
                <li>可以手动控制前往新城市或停留当前城市</li>
                <li>检测到频繁旅行时会自动重置状态</li>
            </ul>
        </div>
    `;
    
    // 如果自动贸易启用且界面打开，启动进度条更新定时器
    if (player.trading.autoTrade.enabled && !player.trading.autoTrade.backgroundMode) {
        startProgressUpdateTimer();
    }
}

function isFrequentTravelDetected() {
    const recentLogs = player.trading.autoTrade.logs.slice(0, 10);
    const travelLogs = recentLogs.filter(log => log.message.includes("前往") || log.message.includes("旅行"));
    
    // 如果最近10条日志中有5条以上是关于旅行的，认为是频繁旅行
    return travelLogs.length >= 5;
}
function forceCheckOpportunities() {
    if (!player.trading.autoTrade.enabled) {
        logAction("自动贸易未启用", "error");
        return;
    }
    
    addAutoTradeLog("手动触发检查采购和销售机会", "info");
    checkBothPurchaseAndSaleOpportunities();
}


function resetAutoTradeState() {
    addAutoTradeLog("手动重置自动贸易状态", "info");
    
    // 停止所有旅行
    if (player.trading.isTraveling) {
        if (player.trading.travelInterval) {
            clearInterval(player.trading.travelInterval);
            player.trading.travelInterval = null;
        }
        player.trading.isTraveling = false;
        player.trading.travelDestination = '';
    }
    
    // 重置自动贸易状态
    player.trading.autoTrade.currentState = 'monitoring';
    player.trading.autoTrade.currentProgress = 0;
    player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes.length > 0 ? player.trading.autoTrade.routes[0] : null;
    player.trading.autoTrade.currentCityStayStart = Date.now();
    player.trading.autoTrade.lastUpdate = Date.now();
    player.trading.autoTrade.nextMonitorTime = Date.now() + 30000; // 30秒后再开始监控
    
    // 清除频繁旅行的检测标志
    if (player.trading.autoTrade.frequentTravelDetection) {
        delete player.trading.autoTrade.frequentTravelDetection;
    }
    
    addAutoTradeLog("自动贸易状态已重置，将在当前城市重新开始监控", "success");
    
    // 更新界面
    updateAutoTradeTab();
    updateMapTab();
}
function forceStayInCurrentCity() {
    addAutoTradeLog("手动设置为停留在当前城市", "info");
    
    // 重置当前城市停留时间
    player.trading.autoTrade.currentCityStayStart = Date.now();
    
    // 设置较长的停留时间阈值
    player.trading.autoTrade.nextMonitorTime = Date.now() + 600000; // 10分钟后再检查是否移动
    
    // 强制设置为监控状态
    player.trading.autoTrade.currentState = 'monitoring';
    
    addAutoTradeLog("将在当前城市停留至少10分钟，深入寻找机会", "success");
    updateAutoTradeTab();
}


function getFlexibleTradeStateText() {
    if (!player.trading.autoTrade.enabled) return '未启用';
    
    switch (player.trading.autoTrade.currentState) {
        case 'idle': return '空闲';
        case 'buying': return '采购中';
        case 'traveling': return `旅行中 (${getTravelProgress()}%)`;
        case 'selling': return '销售中';
        case 'monitoring': return '监控价格';
        default: return '未知';
    }
}
function getTravelProgress() {
    if (!player.trading.isTraveling) return 0;
    
    const now = Date.now();
    const totalTime = player.trading.travelEndTime - player.trading.travelStartTime;
    const elapsedTime = now - player.trading.travelStartTime;
    const progress = Math.min(100, (elapsedTime / totalTime) * 100);
    
    return progress.toFixed(1);
}
function formatTimeInCity() {
    const now = Date.now();
    const timeInCity = now - player.trading.autoTrade.currentCityStayStart;
    const minutes = Math.floor(timeInCity / (1000 * 60));
    return minutes;
}
function forceMoveToNewCity() {
    if (!player.trading.autoTrade.enabled) {
        logAction("自动贸易未启用", "error");
        return;
    }
    
    if (player.trading.isTraveling) {
        logAction("当前正在旅行中，无法更改目的地", "error");
        return;
    }
    
    addAutoTradeLog("手动触发前往新城市", "info");
    decideNextDestination();
}

function forceForeground() {
    if (player.trading.autoTrade.backgroundMode) {
        exitBackgroundMode();
    }
}
function generateGoodsSelection() {
    let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">';
    
    Object.keys(tradingConfig.goods).forEach(good => {
        const goodConfig = tradingConfig.goods[good];
        const basePrice = goodConfig.basePrice;
        
        html += `
            <div class="good-selection-item" style="border: 1px solid #444; border-radius: 5px; padding: 10px; background: #2a2a2a;">
                <div style="display: flex; align-items: center; margin-bottom: 8px;">
                    <input type="checkbox" id="good_${good}" value="${good}" onchange="toggleGoodSelection('${good}')">
                    <label for="good_${good}" style="margin-left: 5px; font-weight: bold;">${good}</label>
                </div>
                <div style="font-size: 0.9em; color: #aaa;">
                    <div>类型: ${goodConfig.type}</div>
                    <div>基础价格: ${basePrice.toLocaleString()}</div>
                    <div>占用空间: ${goodConfig.slots}格</div>
                </div>
                <div id="priceInput_${good}" style="display: none; margin-top: 8px;">
                    <label style="font-size: 0.9em;">最大买入价:</label>
                    <input type="number" id="maxPrice_${good}" value="${Math.round(basePrice * 1.2)}" style="width: 100%; padding: 3px; background: #333; color: white; border: 1px solid #555;">
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    html += '<div id="selectedGoodsCount" style="margin-top: 10px; color: #aaa;">已选择 0/5 种商品</div>';
    
    return html;
}

function toggleGoodSelection(good) {
    const checkbox = document.getElementById(`good_${good}`);
    const priceInput = document.getElementById(`priceInput_${good}`);
    
    // 检查已选择的商品数量
    const selectedCount = document.querySelectorAll('#goodsSelection input[type="checkbox"]:checked').length;
    
    if (selectedCount > 5) {
        // 超过限制，取消选择
        checkbox.checked = false;
        priceInput.style.display = 'none';
        updateSelectedGoodsCount();
        logAction("最多只能选择5种商品", "error");
        return;
    }
    
    // 显示或隐藏价格输入框
    priceInput.style.display = checkbox.checked ? 'block' : 'none';
    
    // 更新已选择商品计数
    updateSelectedGoodsCount();
}

// 更新已选择商品计数
function updateSelectedGoodsCount() {
    const selectedCount = document.querySelectorAll('#goodsSelection input[type="checkbox"]:checked').length;
    document.getElementById('selectedGoodsCount').textContent = `已选择 ${selectedCount}/5 种商品`;
}
function calculateWarehouseUsage() {
    const totalCapacity = player.trading.warehouse.capacity + player.trading.transport.capacityBonus;
    if (totalCapacity === 0) return 0;
    
    const usageRate = (player.trading.warehouse.used / totalCapacity) * 100;
    return usageRate.toFixed(1);
}

// 获取自动贸易目标
function getAutoTradeTarget() {
    if (!player.trading.autoTrade.currentRoute) return '-';
    
    switch (player.trading.autoTrade.currentState) {
        case 'buying':
            return `在${player.trading.autoTrade.currentRoute.buyCity}采购`;
        case 'traveling':
            return `前往${player.trading.travelDestination}`;
        case 'selling':
            return `在${player.trading.autoTrade.currentRoute.sellCity}销售`;
        default:
            return '等待指令';
    }
}
function savePurchaseStrategy() {
    const maxGoods = parseInt(document.getElementById('maxGoods').value);
    const purchaseStrategy = document.getElementById('purchaseStrategy').value;
    const maxWarehouseUsage = parseInt(document.getElementById('maxWarehouseUsage').value) / 100;
    const priceTolerance = parseInt(document.getElementById('priceTolerance').value) / 100;
    
    player.trading.autoTrade.purchaseSettings.maxGoods = maxGoods;
    player.trading.autoTrade.purchaseSettings.purchaseStrategy = purchaseStrategy;
    player.trading.autoTrade.purchaseSettings.maxWarehouseUsage = maxWarehouseUsage;
    player.trading.autoTrade.purchaseSettings.priceTolerance = priceTolerance;
    
    logAction("采购策略设置已保存", "success");
}


function generateAutoTradeProgressBar() {
    if (!player.trading.autoTrade.enabled) {
        return '<div style="text-align: center; color: #aaa; padding: 10px;">自动贸易未启用</div>';
    }
    
    let progressPercent = 0;
    let statusText = '';
    
    if (player.trading.isTraveling) {
        progressPercent = getTravelProgress();
        statusText = `前往 ${player.trading.travelDestination}`;
    } else {
        switch (player.trading.autoTrade.currentState) {
            case 'buying':
                progressPercent = 50;
                statusText = `在 ${player.trading.currentCity} 采购`;
                break;
            case 'selling':
                progressPercent = 50;
                statusText = `在 ${player.trading.currentCity} 销售`;
                break;
            case 'monitoring':
                progressPercent = 25;
                statusText = `在 ${player.trading.currentCity} 监控价格`;
                break;
            default:
                progressPercent = 0;
                statusText = '等待开始';
        }
    }
    
    return `
        <div class="auto-trade-progress" style="margin-bottom: 15px;">
            <div class="progress-label">
                <span>${statusText}</span>
                <span id="autoTravelPercentage">${progressPercent}%</span>
            </div>
            <div class="progress-bar">
                <div id="autoTravelProgress" class="progress-fill" style="width: ${progressPercent}%;"></div>
            </div>
        </div>
    `;
}
function startProgressUpdateTimer() {
    // 清除现有定时器
    stopProgressUpdateTimer();
    
    // 启动新定时器
    window.autoTradeProgressInterval = setInterval(() => {
        safeUpdateAutoTradeProgressBar();
    }, 500);
}


function generateCityOptions(currentCity) {
    const connectedCities = tradingConfig.cities[currentCity].connections;
    let options = `<option value="${currentCity}">${currentCity}</option>`;
    
    connectedCities.forEach(city => {
        options += `<option value="${city}">${city}</option>`;
    });
    
    return options;
}

// 生成商品选项
function generateGoodsOptions() {
    let options = '';
    Object.keys(tradingConfig.goods).forEach(good => {
        options += `<option value="${good}">${good}</option>`;
    });
    return options;
}

// 生成自动贸易进度显示
function generateAutoTradeProgress() {
    if (player.trading.autoTrade.currentState === 'traveling') {
        const progressPercent = Math.min(100, (player.trading.autoTrade.currentProgress / player.trading.autoTrade.totalTravelTime) * 100);
        return `
            <div style="margin-top: 10px;">
                <div style="display: flex; justify-content: space-between;">
                    <span>旅行进度</span>
                    <span>${progressPercent.toFixed(1)}%</span>
                </div>
                <div style="width: 100%; height: 10px; background: #444; border-radius: 5px;">
                    <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 5px; transition: width 0.5s;"></div>
                </div>
                <div style="text-align: center; margin-top: 5px; font-size: 0.8em; color: #aaa;">
                    前往 ${player.trading.travelDestination}
                </div>
            </div>
        `;
    }
    
    if (player.trading.autoTrade.currentState === 'buying' || player.trading.autoTrade.currentState === 'selling') {
        const action = player.trading.autoTrade.currentState === 'buying' ? '采购' : '销售';
        const city = player.trading.autoTrade.currentState === 'buying' ? 
            player.trading.autoTrade.currentRoute.buyCity : 
            player.trading.autoTrade.currentRoute.sellCity;
        const good = player.trading.autoTrade.currentRoute.good;
        
        return `
            <div style="text-align: center; margin-top: 10px;">
                <div style="color: #FFD700; font-weight: bold;">${action}中...</div>
                <div style="font-size: 0.9em; color: #aaa;">
                    在${city}${action}${good}
                </div>
            </div>
        `;
    }
    
    return '<div style="text-align: center; color: #aaa; margin-top: 10px;">等待开始...</div>';
}

// 生成自动贸易路线列表
function generateAutoTradeRoutes() {
    if (!player.trading.autoTrade.routes || player.trading.autoTrade.routes.length === 0) {
        return '<div style="text-align: center; color: #aaa; padding: 20px;">暂无保存的路线</div>';
    }
    
    let routesHtml = '';
    player.trading.autoTrade.routes.forEach((route, index) => {
        const isActive = player.trading.autoTrade.currentRoute === route;
        
        routesHtml += `
            <div class="auto-trade-route ${isActive ? 'active' : ''}" style="border: 1px solid #444; border-radius: 5px; padding: 15px; margin-bottom: 10px; background: #2a2a2a;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h5 style="margin: 0; color: #FFD700;">灵活贸易路线 ${index + 1}</h5>
                    <span style="color: ${isActive ? '#4CAF50' : '#aaa'}">${isActive ? '运行中' : '已保存'}</span>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <div style="font-weight: bold; margin-bottom: 5px;">贸易商品:</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 5px;">
                        ${route.goods.map(item => `
                            <div style="background: #333; padding: 5px; border-radius: 3px; font-size: 0.9em;">
                                <div>${item.good}</div>
                                <div style="color: #aaa; font-size: 0.8em;">最大买入: ${item.maxBuyPrice.toLocaleString()}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px;">
                    <div>
                        <div style="font-size: 0.9em; color: #aaa;">最小利润率</div>
                        <div>${route.minProfitMargin}%</div>
                    </div>
                    <div>
                        <div style="font-size: 0.9em; color: #aaa;">单次资金</div>
                        <div>${route.tradeCapital.toLocaleString()}</div>
                    </div>
                    <div>
                        <div style="font-size: 0.9em; color: #aaa;">状态</div>
                        <div>${isActive ? getFlexibleTradeStateText() : '等待中'}</div>
                    </div>
                </div>
                
                <div style="text-align: right;">
                    ${!isActive ? `
                        <button onclick="setActiveRoute(${index})" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">设为活动</button>
                    ` : ''}
                    <button onclick="deleteRoute(${index})" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">删除</button>
                </div>
            </div>
        `;
    });
    
    return routesHtml;
}
// 获取自动贸易状态文本
function getAutoTradeStateText() {
    if (!player.trading.autoTrade.enabled) return '未启用';
    
    switch (player.trading.autoTrade.currentState) {
        case 'idle': return '空闲';
        case 'buying': return '采购中';
        case 'traveling': return '旅行中';
        case 'selling': return '销售中';
        default: return '未知';
    }
}
function validateTradingData() {
    // 验证自动贸易数据
    if (!player.trading.autoTrade) {
        player.trading.autoTrade = {
            enabled: false,
            routes: [],
            efficiency: 0.6,
            currentRoute: null,
            currentState: 'idle',
            currentProgress: 0,
            totalTravelTime: 0,
            lastUpdate: Date.now(),
            logs: [],
            stats: {
                totalProfit: 0,
                totalTrades: 0,
                successfulTrades: 0,
                failedTrades: 0,
                totalTravelTime: 0,
                startTime: Date.now()
            },
            purchaseSettings: {
                maxGoods: 5,
                purchaseStrategy: 'priceDesc',
                minProfitMargin: 10,
                maxWarehouseUsage: 0.8,
                priceTolerance: 0.2
            },
            backgroundMode: false,
            lastBackgroundUpdate: Date.now(),
            backgroundInterval: null
        };
    }
    
    // 验证路线数据
    if (!Array.isArray(player.trading.autoTrade.routes)) {
        player.trading.autoTrade.routes = [];
    }
    
    // 清理无效路线
    player.trading.autoTrade.routes = player.trading.autoTrade.routes.filter(route => {
        return route && route.buyCity && route.sellCity && Array.isArray(route.goods);
    });
    
    // 验证当前路线
    if (player.trading.autoTrade.currentRoute && 
        !player.trading.autoTrade.routes.includes(player.trading.autoTrade.currentRoute)) {
        player.trading.autoTrade.currentRoute = null;
    }
    
    // 验证日志
    if (!Array.isArray(player.trading.autoTrade.logs)) {
        player.trading.autoTrade.logs = [];
    }
}

// 设置活动路线
function setActiveRoute(index) {
    if (!player.trading.autoTrade.routes || index >= player.trading.autoTrade.routes.length) {
        logAction("无效的路线索引", "error");
        return;
    }
    
    player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[index];
    player.trading.autoTrade.currentState = 'idle';
    logAction(`已设置活动路线：灵活贸易路线${index + 1}`, "success");
    updateAutoTradeTab();
}

// 删除路线
function deleteRoute(index) {
    if (!player.trading.autoTrade.routes || index >= player.trading.autoTrade.routes.length) {
        logAction("无效的路线索引", "error");
        return;
    }
    
    const route = player.trading.autoTrade.routes[index];
    
    showCustomConfirm(`确定要删除灵活贸易路线${index + 1}吗？`, (confirmed) => {
        if (confirmed) {
            player.trading.autoTrade.routes.splice(index, 1);
            
            // 如果删除的是当前活动路线，重置状态
            if (player.trading.autoTrade.currentRoute === route) {
                player.trading.autoTrade.currentRoute = null;
                player.trading.autoTrade.currentState = 'idle';
                
                // 如果自动贸易已启用，停用它
                if (player.trading.autoTrade.enabled) {
                    player.trading.autoTrade.enabled = false;
                    stopAutoTradeSystem();
                    stopProgressUpdateTimer();
                    logAction("活动路线已删除，自动贸易已停用", "info");
                }
            }
            
            logAction("贸易路线已删除", "success");
            updateAutoTradeTab();
        }
    });
}

// 暂停自动贸易
function pauseAutoTrade() {
    player.trading.autoTrade.enabled = false;
    
    // 停止进度条更新定时器
    if (window.autoTradeProgressInterval) {
        clearInterval(window.autoTradeProgressInterval);
        window.autoTradeProgressInterval = null;
    }
    
    logAction("自动贸易已暂停", "info");
    
    // 更新自动贸易界面
    updateAutoTradeTab();
    
    // 如果世界地图界面打开，也更新它
    if (document.getElementById('mapTab').style.display !== 'none') {
        updateMapTab();
    }
}

function stopAutoTrade() {
    player.trading.autoTrade.enabled = false;
    player.trading.autoTrade.currentState = 'idle';
    player.trading.autoTrade.currentRoute = null;
    player.trading.autoTrade.currentProgress = 0;
    
    // 停止进度条更新定时器
    if (window.autoTradeProgressInterval) {
        clearInterval(window.autoTradeProgressInterval);
        window.autoTradeProgressInterval = null;
    }
    
    logAction("自动贸易已停止", "info");
    
    // 更新自动贸易界面
    updateAutoTradeTab();
    
    // 如果世界地图界面打开，也更新它
    if (document.getElementById('mapTab').style.display !== 'none') {
        updateMapTab();
    }
}


// 显示自动贸易日志
function showAutoTradeLog() {
    createAutoTradeLogModal();
    updateAutoTradeLogDisplay();
    updateAutoTradeStats();
    
    document.getElementById('autoTradeLogModal').style.display = 'block';
    document.getElementById('autoTradeLogOverlay').style.display = 'block';
}
// 关闭自动贸易日志
function closeAutoTradeLog() {
    document.getElementById('autoTradeLogModal').style.display = 'none';
    document.getElementById('autoTradeLogOverlay').style.display = 'none';
}

// 更新自动贸易日志显示
function updateAutoTradeLogDisplay() {
    const container = document.getElementById('autoTradeLogContainer');
    const searchTerm = document.getElementById('logSearch')?.value || '';
    const filterType = document.getElementById('logFilter')?.value || 'all';
    
    let filteredLogs = player.trading.autoTrade.logs;
    
    // 应用筛选
    if (filterType !== 'all') {
        filteredLogs = filteredLogs.filter(log => log.type === filterType);
    }
    
    // 应用搜索
    if (searchTerm) {
        filteredLogs = filteredLogs.filter(log => 
            log.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
            log.timestamp.includes(searchTerm) ||
            log.city.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }
    
    container.innerHTML = '';
    
    if (filteredLogs.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">暂无日志记录</div>';
        return;
    }
    
    filteredLogs.forEach(log => {
        const logElement = document.createElement('div');
        logElement.className = 'log-entry';
        logElement.style.cssText = `
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            border-left: 4px solid ${getLogColor(log.type)};
            background: #2a2a2a;
            font-size: 0.9em;
        `;
        
        logElement.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #aaa;">[${log.timestamp}] ${log.city}</span>
                <span style="color: ${getLogColor(log.type)}; font-weight: bold;">${getLogTypeText(log.type)}</span>
            </div>
            <div style="margin-top: 5px;">${log.message}</div>
            <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                资金: ${log.funds.toLocaleString()} | 货仓: ${log.warehouseUsage}% | 状态: ${log.state}
                ${log.purchaseOpportunities > 0 ? `| 采购: ${log.purchaseOpportunities}` : ''}
                ${log.saleOpportunities > 0 ? `| 销售: ${log.saleOpportunities}` : ''}
            </div>
        `;
        
        container.appendChild(logElement);
    });
}

// 获取日志颜色
function getLogColor(type) {
    switch (type) {
        case 'success': return '#4CAF50';
        case 'warning': return '#FF9800';
        case 'error': return '#f44336';
        default: return '#2196F3';
    }
}

// 获取日志类型文本
function getLogTypeText(type) {
    switch (type) {
        case 'success': return '成功';
        case 'warning': return '警告';
        case 'error': return '错误';
        default: return '信息';
    }
}
// 更新自动贸易统计信息
function updateAutoTradeStats() {
    const statsContainer = document.getElementById('autoTradeStats');
    const stats = player.trading.autoTrade.stats;
    
    // 计算运行时间
    const runTime = Date.now() - stats.startTime;
    const hours = Math.floor(runTime / (1000 * 60 * 60));
    const minutes = Math.floor((runTime % (1000 * 60 * 60)) / (1000 * 60));
    
    // 计算成功率
    const successRate = stats.totalTrades > 0 ? 
        (stats.successfulTrades / stats.totalTrades * 100).toFixed(1) : 0;
    
    statsContainer.innerHTML = `
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">总利润</div>
            <div style="font-size: 1.2em; font-weight: bold; color: ${stats.totalProfit >= 0 ? '#4CAF50' : '#f44336'}">
                ${stats.totalProfit >= 0 ? '+' : ''}${stats.totalProfit.toLocaleString()}
            </div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">交易次数</div>
            <div style="font-size: 1.2em; font-weight: bold;">${stats.totalTrades}</div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">成功率</div>
            <div style="font-size: 1.2em; font-weight: bold;">${successRate}%</div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">运行时间</div>
            <div style="font-size: 1.2em; font-weight: bold;">${hours}h ${minutes}m</div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">当前状态</div>
            <div style="font-size: 1.2em; font-weight: bold;">${getAutoTradeStateText()}</div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">贸易效率</div>
            <div style="font-size: 1.2em; font-weight: bold;">${(player.trading.autoTrade.efficiency * 100).toFixed(0)}%</div>
        </div>
    `;
}

// 清空自动贸易日志
function clearAutoTradeLogs() {
    showCustomConfirm("确定要清空所有自动贸易日志吗？此操作不可撤销。", (confirmed) => {
        if (confirmed) {
            player.trading.autoTrade.logs = [];
            updateAutoTradeLogDisplay();
            addAutoTradeLog("日志已清空", "info");
        }
    });
}


function updateAutoTradeStatus() {
    const state = player.trading.autoTrade.currentState;
    let stateText = '';
    let progressHtml = '';
    
    switch (state) {
        case 'idle':
            stateText = '空闲';
            break;
        case 'buying':
            stateText = `在${player.trading.autoTrade.currentRoute?.buyCity || '-'}采购`;
            break;
        case 'traveling':
            const progressPercent = (player.trading.autoTrade.currentProgress / player.trading.autoTrade.totalTravelTime) * 100;
            stateText = `前往${player.trading.travelDestination}`;
            progressHtml = `
                <div style="margin-top: 10px;">
                    <div style="display: flex; justify-content: space-between;">
                        <span>旅行进度</span>
                        <span id="autoTravelPercentage">${progressPercent.toFixed(1)}%</span>
                    </div>
                    <div style="width: 100%; height: 10px; background: #444; border-radius: 5px;">
                        <div id="autoTravelProgress" style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 5px;"></div>
                    </div>
                </div>
            `;
            break;
        case 'selling':
            stateText = `在${player.trading.autoTrade.currentRoute?.sellCity || '-'}销售`;
            break;
    }
    
    document.getElementById('autoTradeState').textContent = stateText;
    document.getElementById('autoTradeProgress').innerHTML = progressHtml;
    document.getElementById('autoTradeEfficiency').textContent = `${(player.trading.autoTrade.efficiency * 100).toFixed(0)}%`;
    
    // 今日利润可能是负数（如果买入多于卖出），但我们只显示净收入
    const todayProfit = player.trading.tradeVolumeToday;
    document.getElementById('todayProfit').textContent = 
        `${todayProfit >= 0 ? '+' : ''}${todayProfit.toLocaleString()}星币`;
}

// 更新经营管理标签页
function updateManagementTab() {
    // 货仓信息
    const currentLevel = player.trading.warehouse.level;
    const nextLevel = Math.min(currentLevel + 1, tradingConfig.warehouseLevels.length);
    const nextLevelConfig = tradingConfig.warehouseLevels[nextLevel - 1];
    
    document.getElementById('warehouseLevel').textContent = currentLevel;
    document.getElementById('currentCapacity').textContent = player.trading.warehouse.capacity;
    document.getElementById('upgradeCosta').textContent = nextLevelConfig.cost.toLocaleString();
    
    // 运输工具
    const transportList = document.getElementById('transportList');
    transportList.innerHTML = '';
    
    tradingConfig.transports.forEach(transport => {
        const canBuy = player.nightClub.starCoins >= transport.cost;
        const isOwned = player.trading.transport.type === transport.name;
        
        const transportElement = document.createElement('div');
        transportElement.innerHTML = `
            <div style="border: 1px solid #444; padding: 10px; margin: 5px 0;">
                <strong>${transport.name}</strong><br>
                容量: +${transport.capacityBonus}格<br>
                速度: +${transport.speedBonus}%<br>
                价格: ${transport.cost.toLocaleString()}星币<br>
                ${isOwned ? 
                    '<span style="color: green;">已拥有</span>' : 
                    `<button onclick="buyTransport('${transport.name}')" ${!canBuy ? 'disabled' : ''}>购买</button>`
                }
            </div>
        `;
        transportList.appendChild(transportElement);
    });
    
    // 雇员管理
    const employeeList = document.getElementById('employeeList');
    employeeList.innerHTML = '';
    
    player.trading.employees.forEach(employee => {
        const employeeElement = document.createElement('div');
        employeeElement.innerHTML = `
            <div style="border: 1px solid #444; padding: 10px; margin: 5px 0;">
                <strong>${employee.type}</strong><br>
                效率加成: +${employee.efficiencyBonus}%<br>
                月薪: ${employee.salary}星币/天
            </div>
        `;
        employeeList.appendChild(employeeElement);
    });
    
    // 保险状态
    document.getElementById('goodsInsurance').checked = player.trading.insurance.goods;
    document.getElementById('transportInsurance').checked = player.trading.insurance.transport;
}

// 切换标签页
function switchTradingTab(tabName) {
    // 隐藏所有标签页
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // 移除所有标签按钮的激活状态
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // 显示选中的标签页
    document.getElementById(tabName + 'Tab').classList.add('active');
    
    // 激活对应的标签按钮
    event.target.classList.add('active');
}

// 购买商品
function buyGood(good, quantity) {
    // 确保商品名称有效
    if (!good || typeof good !== 'string') {
        addAutoTradeLog("无法购买无效的商品", "error");
        return;
    }
    
    const city = player.trading.currentCity;
    const price = player.trading.cityPrices[city][good];
    const totalCost = price * quantity;
    const goodConfig = tradingConfig.goods[good];
    const slotsNeeded = goodConfig.slots * quantity;
    
    // 检查资金
    if (player.nightClub.starCoins < totalCost) {
        logAction(`星币不足！需要${totalCost.toLocaleString()}星币`, "error");
        return;
    }
    
    // 检查货仓空间
    const availableSlots = player.trading.warehouse.capacity + player.trading.transport.capacityBonus - player.trading.warehouse.used;
    if (slotsNeeded > availableSlots) {
        logAction(`货仓空间不足！需要${slotsNeeded}格，可用${availableSlots}格`, "error");
        return;
    }
    
    // 执行购买
    player.nightClub.starCoins -= totalCost;
    
    // 更新库存（计算平均成本）
    if (!player.trading.inventory[good]) {
        // 第一次购买此商品
        player.trading.inventory[good] = {
            quantity: quantity,
            averageCost: price,
            totalCost: totalCost,
            lastBuyPrice: price
        };
    } else {
        // 已有库存，计算新的平均成本
        const current = player.trading.inventory[good];
        const newTotalCost = current.totalCost + totalCost;
        const newQuantity = current.quantity + quantity;
        const newAverageCost = newTotalCost / newQuantity;
        
        player.trading.inventory[good] = {
            quantity: newQuantity,
            averageCost: newAverageCost,
            totalCost: newTotalCost,
            lastBuyPrice: price
        };
    }
    
    player.trading.warehouse.used += slotsNeeded;
    
    // 记录交易
    recordTrade('buy', good, quantity, price, totalCost);
    
    logAction(`购买了${quantity}个${good}，花费${totalCost.toLocaleString()}星币`, "success");
    updateTradingUI();
    updateDisplay();
}

// 出售商品
function sellGood(good, quantity) {
    const city = player.trading.currentCity;
    const price = player.trading.cityPrices[city][good];
    const totalRevenue = price * quantity;
    const goodConfig = tradingConfig.goods[good];
    
    // 检查库存
    if (!player.trading.inventory[good] || player.trading.inventory[good].quantity < quantity) {
        logAction(`库存不足！只有${player.trading.inventory[good] ? player.trading.inventory[good].quantity : 0}个${good}`, "error");
        return;
    }
    
    const inventoryItem = player.trading.inventory[good];
    const costOfGoodsSold = inventoryItem.averageCost * quantity;
    const profit = totalRevenue - costOfGoodsSold;
    const profitRate = (profit / costOfGoodsSold) * 100;
    
    // 执行出售
    player.nightClub.starCoins += totalRevenue;
    
    // 更新库存
    if (inventoryItem.quantity === quantity) {
        // 全部售出
        delete player.trading.inventory[good];
    } else {
        // 部分售出（平均成本不变，因为采用加权平均法）
        inventoryItem.quantity -= quantity;
        inventoryItem.totalCost -= costOfGoodsSold;
        // 平均成本保持不变，因为我们采用先进先出或加权平均
    }
    
    player.trading.warehouse.used -= goodConfig.slots * quantity;
    
    // 记录交易
    recordTrade('sell', good, quantity, price, totalRevenue);
    
    // 显示盈亏信息
    const profitSign = profit >= 0 ? '+' : '';
    logAction(`出售了${quantity}个${good}，获得${totalRevenue.toLocaleString()}星币（${profitSign}${profit.toFixed(0)}星币，${profitSign}${profitRate.toFixed(1)}%）`, "success");
    
    updateTradingUI();
    updateDisplay();
}

// 记录交易
function recordTrade(type, good, quantity, price, amount) {
    const trade = {
        type: type,
        good: good,
        quantity: quantity,
        price: price,
        amount: amount,
        city: player.trading.currentCity,
        timestamp: Date.now()
    };
    
    player.trading.tradeHistory.unshift(trade);
    
    // 买入是支出（减少利润），卖出是收入（增加利润）
    if (type === 'buy') {
        player.trading.tradeVolumeToday -= amount; // 买入减少利润
    } else if (type === 'sell') {
        player.trading.tradeVolumeToday += amount; // 卖出增加利润
    }
    
    player.trading.tradeCountToday++;
    
    // 限制交易记录数量
    if (player.trading.tradeHistory.length > 100) {
        player.trading.tradeHistory.pop();
    }
}

// 旅行到其他城市
function travelToCity(city) {
    updateMapTab();
    if (player.trading.isTraveling) {
        logAction("当前正在旅行中，无法更改目的地", "error");
        return;
    }
    
    if (city === player.trading.currentCity) {
        logAction("已经在目标城市", "info");
        return;
    }
    
    player.trading.travelDestination = city;
    
    // 显示旅行信息
    const baseTime = tradingConfig.cities[city].travelTime;
    const speedBonus = player.trading.transport.speedBonus;
    const actualTime = baseTime * (100 - speedBonus) / 100;
       
    logAction(`已选择目的地：${city}，预计需要${actualTime.toFixed(1)}分钟`, "info");
    updateMapTab();
     
}
function cancelTravel() {
    // 如果自动贸易启用，禁用手动取消旅行
    if (player.trading.autoTrade.enabled) {
        logAction("自动贸易已启用，无法手动取消旅行", "warning");
        return;
    }
    
    if (!player.trading.isTraveling) {
        logAction("当前没有进行中的旅行", "info");
        return;
    }
    
    showCustomConfirm("确定要取消当前旅行吗？已花费的时间将不会返还。", (confirmed) => {
        if (confirmed) {
            if (player.trading.travelInterval) {
                clearInterval(player.trading.travelInterval);
                player.trading.travelInterval = null;
            }
            
            player.trading.isTraveling = false;
            player.trading.travelDestination = '';
            
            logAction("已取消旅行", "info");
            updateMapTab();
        }
    });
}
function addCancelTravelButton() {
    const travelInfo = document.getElementById('travelInfo');
    if (!document.getElementById('cancelTravelBtn')) {
        const cancelBtn = document.createElement('button');
        cancelBtn.id = 'cancelTravelBtn';
        cancelBtn.textContent = '取消旅行';
        cancelBtn.style.marginLeft = '10px';
        cancelBtn.style.background = '#f44336';
        cancelBtn.onclick = cancelTravel;
        travelInfo.appendChild(cancelBtn);
    }
}
// 开始旅行
function startTravel() {
    // 如果自动贸易启用，禁用手动旅行
    if (player.trading.autoTrade.enabled) {
        logAction("自动贸易已启用，无法手动旅行", "warning");
        return;
    }
    
    if (!player.trading.travelDestination) {
        logAction("请先选择目的地", "error");
        return;
    }
    
    if (player.trading.isTraveling) {
        logAction("当前正在旅行中", "error");
        return;
    }
    
    const destination = player.trading.travelDestination;
    const baseTime = tradingConfig.cities[destination].travelTime;
    const speedBonus = player.trading.transport.speedBonus;
    const actualTime = baseTime * (100 - speedBonus) / 100;
    
    player.trading.isTraveling = true;
    player.trading.travelStartTime = Date.now();
    player.trading.travelEndTime = Date.now() + actualTime * 60 * 1000;
    
    logAction(`开始前往${destination}，预计需要${actualTime.toFixed(1)}分钟`, "info");
    
    // 确保清除之前的计时器
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
    }
    
    // 启动旅行计时器
    player.trading.travelInterval = setInterval(checkTravelStatus, 1000);
    
    updateMapTab();
}

// 检查旅行状态
function checkTravelStatus() {
    if (!player.trading.isTraveling) return;
    
    const now = Date.now();
    if (now >= player.trading.travelEndTime) {
        // 到达目的地
        completeAutoTravel();
    } else {
        // 更新旅行进度显示
        updateTravelProgress();
    }
}
// 完成旅行
function completeTravel() {
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
        player.trading.travelInterval = null;
    }
    
    player.trading.currentCity = player.trading.travelDestination;
    player.trading.isTraveling = false;
    player.trading.travelDestination = '';
    
    logAction(`已到达${player.trading.currentCity}`, "success");
    
    // 更新界面
    updateMapTab();
    updateTradingUI();
    
    // 触发随机事件
    triggerRandomEvent();
}

function updateTravelProgress() {
    const now = Date.now();
    const elapsed = now - player.trading.travelStartTime;
    const total = player.trading.travelEndTime - player.trading.travelStartTime;
    const progress = Math.min(100, (elapsed / total) * 100);
    
    // 更新UI显示
    const minutesRemaining = Math.ceil((player.trading.travelEndTime - now) / (1000 * 60));
    
    // 更新自动贸易进度条
    updateAutoTradeProgressBar();
    
    // 如果世界地图界面打开，也更新那里的进度条
    if (document.getElementById('travelProgressBar')) {
        document.getElementById('travelProgressBar').style.width = `${progress}%`;
        document.getElementById('travelTime').textContent = `${minutesRemaining}分钟`;
        document.getElementById('travelStatus').textContent = `旅行中... ${progress.toFixed(1)}%`;
    }
}


// 触发随机事件
function triggerRandomEvent() {
    const eventChance = Math.random();
    
    if (eventChance < 0.2) { // 20%概率正面事件
        triggerPositiveEvent();
    } else if (eventChance < 0.45) { // 25%概率负面事件
        triggerNegativeEvent();
    } else if (eventChance < 0.55) { // 10%概率机遇事件
        triggerOpportunityEvent();
    }
}

// 正面事件
function triggerPositiveEvent() {
    const events = [
        {
            type: 'discount',
            message: '特价采购！所有商品临时降价40%，持续1小时',
            effect: () => {
                // 临时降价逻辑
                logAction("特价采购事件触发！商品价格下降40%", "success");
            }
        },
        {
            type: 'demand',
            message: '豪商收购！随机商品临时涨价50%，持续1小时',
            effect: () => {
                const goods = Object.keys(tradingConfig.goods);
                const randomGood = goods[Math.floor(Math.random() * goods.length)];
                logAction(`豪商收购事件触发！${randomGood}价格上涨50%`, "success");
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    event.effect();
    logAction(event.message, "event");
}

// 负面事件
function triggerNegativeEvent() {
    const events = [
        {
            type: 'robbery',
            message: '遭遇强盗！损失部分货物',
            effect: () => {
                if (player.trading.insurance.goods) {
                    logAction("强盗事件触发！但货物已投保，损失由保险公司承担", "event");
                    return;
                }
                
                // 随机损失20%-40%货物
                const lossPercentage = 0.1 + Math.random() * 0.2;
                let totalLoss = 0;
                
                Object.keys(player.trading.inventory).forEach(good => {
                    const lossQuantity = Math.floor(player.trading.inventory[good] * lossPercentage);
                    if (lossQuantity > 0) {
                        player.trading.inventory[good] -= lossQuantity;
                        const goodConfig = tradingConfig.goods[good];
                        player.trading.warehouse.used -= goodConfig.slots * lossQuantity;
                        totalLoss += lossQuantity;
                        
                        if (player.trading.inventory[good] === 0) {
                            delete player.trading.inventory[good];
                        }
                    }
                });
                
                logAction(`强盗事件触发！损失了约${Math.round(lossPercentage * 100)}%的货物`, "event");
            }
        },
        {
            type: 'spoilage',
            message: '商品腐败！部分易腐商品价值归零',
            effect: () => {
                // 检查有保质期的商品
                Object.keys(tradingConfig.goods).forEach(good => {
                    const goodConfig = tradingConfig.goods[good];
                    if (goodConfig.shelfLife !== Infinity && player.trading.inventory[good]) {
                        const spoilChance = 0.000000000001; // 10%腐败概率
                        if (Math.random() < spoilChance) {
                            const spoilQuantity = Math.floor(player.trading.inventory[good] * 0.0000002); // 腐败一半
                            player.trading.inventory[good] -= spoilQuantity;
                            player.trading.warehouse.used -= goodConfig.slots * spoilQuantity;
                            
                            if (player.trading.inventory[good] === 0) {
                                delete player.trading.inventory[good];
                            }
                            
                            logAction(`${good}腐败了${spoilQuantity}个`, "event");
                        }
                    }
                });
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    event.effect();
    logAction(event.message, "event");
}

// 机遇事件
function triggerOpportunityEvent() {
    const events = [
        {
            type: 'limitedOffer',
            message: '发现限时商机！特定商品利润丰厚',
            effect: () => {
                const goods = Object.keys(tradingConfig.goods);
                const randomGood = goods[Math.floor(Math.random() * goods.length)];
                logAction(`限时商机：${randomGood}当前利润丰厚！`, "opportunity");
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    event.effect();
    logAction(event.message, "opportunity");
}

// 自动贸易功能
function toggleAutoTrade() {
    // 检查是否有保存的路线
    if (player.trading.autoTrade.routes.length === 0) {
        logAction("请先设置自动贸易路线", "error");
        
        // 显示设置界面
        document.getElementById('autoTradeSettings').style.display = 'block';
        document.getElementById('autoTradeStatus').style.display = 'none';
        
        return;
    }
    
    player.trading.autoTrade.enabled = !player.trading.autoTrade.enabled;
    
    if (player.trading.autoTrade.enabled) {
        // 重置状态
        player.trading.autoTrade.currentState = 'idle';
        player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0]; // 使用第一条路线
        player.trading.autoTrade.currentProgress = 0;
        player.trading.autoTrade.lastUpdate = Date.now();
        
        // 启动自动贸易系统
        startAutoTradeSystem();
        
        // 启动进度条更新定时器（如果界面打开）
        if (document.getElementById('autoTab').style.display !== 'none') {
            startProgressUpdateTimer();
        }
        
        logAction("自动贸易已启用", "success");
    } else {
        // 停止自动贸易系统
        stopAutoTradeSystem();
        
        // 停止进度条更新定时器
        stopProgressUpdateTimer();
        
        logAction("自动贸易已停用", "info");
    }
    
    updateAutoTradeTab();
}


// 运行自动贸易
function runAutoTrade() {
    if (!player.trading.autoTrade.enabled) return;
    
    const now = Date.now();
    const elapsed = now - player.trading.autoTrade.lastUpdate;
    
    // 更严格的频率控制：至少间隔10秒才执行一次
    if (elapsed < 10000) return;
    
    player.trading.autoTrade.lastUpdate = now;
    
    // 检查是否正在旅行中，如果是则跳过其他逻辑
    if (player.trading.isTraveling) {
        updateAutoTravel(elapsed);
        return;
    }
    
    // 检查是否有下一次监控的时间设置
    if (player.trading.autoTrade.nextMonitorTime && now < player.trading.autoTrade.nextMonitorTime) {
        return; // 等待下一次监控时间
    }
    
    // 验证数据
    validateAutoTradeData();
    
    // 检查状态是否有效
    validateAutoTradeState();
    
    switch (player.trading.autoTrade.currentState) {
        case 'idle':
            startFlexibleTrade();
            break;
        case 'buying':
            executeFlexibleBuying();
            break;
        case 'selling':
            executeFlexibleSelling();
            break;
        case 'monitoring':
            monitorPricesAndDecide();
            break;
    }
    
    // 实时更新进度条
    updateAutoTradeProgressBar();
}

function startFlexibleTrade() {
    if (player.trading.autoTrade.routes.length === 0) {
        addAutoTradeLog("没有设置自动贸易路线", "warning");
        player.trading.autoTrade.enabled = false;
        updateAutoTradeTab();
        return;
    }
    
    // 选择一条路线
    player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0];
    
    // 开始在当前城市寻找机会
    player.trading.autoTrade.currentState = 'monitoring';
    addAutoTradeLog(`开始在${player.trading.currentCity}寻找贸易机会`, "info");
}

function executeFlexibleBuying() {
    // 检查是否正在旅行中
    if (player.trading.isTraveling) {
        return;
    }
    
    const city = player.trading.currentCity;
    
    // 检查货仓使用率
    const totalCapacity = player.trading.warehouse.capacity + player.trading.transport.capacityBonus;
    const usageRate = player.trading.warehouse.used / totalCapacity;
    
    if (usageRate >= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage) {
        addAutoTradeLog("货仓已满，开始寻找销售机会", "info");
        player.trading.autoTrade.currentState = 'selling';
        return;
    }
    
    // 检查可用资金
    const availableFunds = player.nightClub.starCoins;
    if (availableFunds < player.trading.autoTrade.currentRoute.tradeCapital * 0.1) {
        addAutoTradeLog("资金不足，开始寻找其他城市的机会", "info");
        decideNextDestination();
        return;
    }
    
    // 获取所有可购买的商品
    const allPurchasableGoods = getAllPurchasableGoods();
    
    if (allPurchasableGoods.length === 0) {
        addAutoTradeLog("当前没有价格合适的商品可购买，开始寻找其他城市的机会", "info");
        decideNextDestination();
        return;
    }
    
    // 根据策略选择商品
    const targetGood = selectGoodForPurchase(allPurchasableGoods);
    
    if (!targetGood) {
        addAutoTradeLog("无法确定要购买的商品，开始寻找其他城市的机会", "warning");
        decideNextDestination();
        return;
    }
    
    const price = player.trading.cityPrices[city][targetGood];
    const quantity = calculateOptimalPurchaseQuantity(targetGood, player.trading.autoTrade.currentRoute.tradeCapital);
    
    if (quantity > 0) {
        buyGood(targetGood, quantity);
        addAutoTradeLog(`购买了${quantity}个${targetGood}，花费${(price * quantity).toLocaleString()}星币`, "success");
        
        // 购买后检查是否需要转为销售模式
        if (usageRate >= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage * 0.8) {
            addAutoTradeLog("货仓接近满载，开始寻找销售机会", "info");
            player.trading.autoTrade.currentState = 'selling';
        }
    } else {
        addAutoTradeLog(`无法购买${targetGood}，资金或空间不足，开始寻找其他城市的机会`, "warning");
        decideNextDestination();
    }
}

function executeFlexibleSelling() {
    // 检查是否正在旅行中
    if (player.trading.isTraveling) {
        return;
    }
    
    const city = player.trading.currentCity;
    
    // 获取所有可销售的商品
    const allSalableGoods = getAllSalableGoods();
    
    if (allSalableGoods.length === 0) {
        addAutoTradeLog("当前没有利润率合适的商品可销售，开始寻找其他城市的机会", "info");
        decideNextDestination();
        return;
    }
    
    // 选择利润率最高的商品
    const targetGood = allSalableGoods[0].good;
    const price = player.trading.cityPrices[city][targetGood];
    const averageCost = player.trading.inventory[targetGood].averageCost;
    const profitMargin = ((price - averageCost) / averageCost) * 100;
    
    // 计算销售数量
    const quantity = calculateOptimalSaleQuantity(targetGood);
    
    if (quantity > 0) {
        sellGood(targetGood, quantity);
        addAutoTradeLog(`出售了${quantity}个${targetGood}，利润率${profitMargin.toFixed(1)}%`, "success");
        
        // 销售后检查是否需要转为采购模式
        const totalCapacity = player.trading.warehouse.capacity + player.trading.transport.capacityBonus;
        const usageRate = player.trading.warehouse.used / totalCapacity;
        
        if (usageRate <= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage * 0.3) {
            addAutoTradeLog("货仓空间充足，开始寻找采购机会", "info");
            player.trading.autoTrade.currentState = 'buying';
        }
    } else {
        addAutoTradeLog(`无法销售${targetGood}，库存不足，开始寻找其他城市的机会`, "warning");
        decideNextDestination();
    }
}

function validateAutoTradeState() {
    // 检查是否处于无效状态循环
    const recentLogs = player.trading.autoTrade.logs.slice(0, 10);
    const travelLogs = recentLogs.filter(log => log.message.includes("前往") || log.message.includes("旅行"));
    
    // 如果最近10条日志中有6条以上是关于旅行的，自动重置状态
    if (travelLogs.length >= 6) {
        addAutoTradeLog("检测到频繁旅行，自动重置为监控状态", "warning");
        player.trading.autoTrade.currentState = 'monitoring';
        player.trading.autoTrade.nextMonitorTime = Date.now() + 120000; // 等待2分钟再检查
        
        // 如果当前正在旅行，取消旅行
        if (player.trading.isTraveling) {
            if (player.trading.travelInterval) {
                clearInterval(player.trading.travelInterval);
                player.trading.travelInterval = null;
            }
            player.trading.isTraveling = false;
            player.trading.travelDestination = '';
        }
        
        // 标记频繁旅行检测
        player.trading.autoTrade.frequentTravelDetection = true;
    }
}

function monitorPricesAndDecide() {
    const city = player.trading.currentCity;
    
    // 检查是否正在旅行中
    if (player.trading.isTraveling) {
        return;
    }
    
    // 同时检查采购和销售机会
    checkBothPurchaseAndSaleOpportunities();
}


function getAllPurchasableGoods() {
    const city = player.trading.currentCity;
    const allGoods = Object.keys(tradingConfig.goods);
    const purchasableGoods = [];
    
    allGoods.forEach(good => {
        const price = player.trading.cityPrices[city][good];
        let maxBuyPrice = Infinity;
        
        // 检查是否有设置该商品的最大买入价
        if (player.trading.autoTrade.currentRoute) {
            const routeGood = player.trading.autoTrade.currentRoute.goods.find(g => g.good === good);
            if (routeGood) {
                maxBuyPrice = routeGood.maxBuyPrice * (1 + player.trading.autoTrade.purchaseSettings.priceTolerance);
            }
        }
        
        // 检查价格是否合适
        if (price <= maxBuyPrice) {
            const basePrice = tradingConfig.goods[good].basePrice;
            const priceRatio = price / basePrice;
            
            purchasableGoods.push({
                good: good,
                price: price,
                basePrice: basePrice,
                priceRatio: priceRatio,
                maxBuyPrice: maxBuyPrice
            });
        }
    });
    
    // 根据策略排序
    const strategy = player.trading.autoTrade.purchaseSettings.purchaseStrategy;
    switch (strategy) {
        case 'priceDesc':
            purchasableGoods.sort((a, b) => b.price - a.price);
            break;
        case 'priceAsc':
            purchasableGoods.sort((a, b) => a.price - b.price);
            break;
        case 'profitMargin':
            purchasableGoods.sort((a, b) => {
                const aProfitPotential = 1 / a.priceRatio;
                const bProfitPotential = 1 / b.priceRatio;
                return bProfitPotential - aProfitPotential;
            });
            break;
    }
    
    return purchasableGoods;
}

function getAllSalableGoods() {
    const city = player.trading.currentCity;
    const salableGoods = [];
    
    // 检查库存中的商品
    Object.keys(player.trading.inventory).forEach(good => {
        if (player.trading.inventory[good].quantity > 0) {
            const price = player.trading.cityPrices[city][good];
            const averageCost = player.trading.inventory[good].averageCost;
            
            if (averageCost > 0) {
                const profitMargin = ((price - averageCost) / averageCost) * 100;
                const minProfitMargin = player.trading.autoTrade.currentRoute?.minProfitMargin || 
                                      player.trading.autoTrade.purchaseSettings.minProfitMargin;
                
                if (profitMargin >= minProfitMargin) {
                    salableGoods.push({
                        good: good,
                        profitMargin: profitMargin,
                        price: price,
                        cost: averageCost,
                        quantity: player.trading.inventory[good].quantity
                    });
                }
            }
        }
    });
    
    // 按利润率降序排序
    salableGoods.sort((a, b) => b.profitMargin - a.profitMargin);
    
    return salableGoods;
}


function selectGoodForPurchase(goodsList) {
    if (goodsList.length === 0) return null;
    
    const strategy = player.trading.autoTrade.purchaseSettings.purchaseStrategy;
    
    switch (strategy) {
        case 'priceDesc':
            return goodsList[0].good; // 最贵的商品
        case 'priceAsc':
            return goodsList[goodsList.length - 1].good; // 最便宜的商品
        case 'profitMargin':
            return goodsList[0].good; // 利润率潜力最高的商品
        default:
            return goodsList[0].good;
    }
}

// 决定下一个目的地
function decideNextDestination() {
    const currentCity = player.trading.currentCity;
    const connectedCities = tradingConfig.cities[currentCity].connections;
    
    if (connectedCities.length === 0) {
        addAutoTradeLog("没有可连接的城市，继续在当前城市监控", "warning");
        player.trading.autoTrade.currentState = 'monitoring';
        return;
    }
    
    // 评估每个城市的潜在机会
    const cityScores = [];
    
    connectedCities.forEach(city => {
        let score = 0;
        
        // 基本分数：随机性
        score += Math.random() * 20;
        
        // 检查采购机会
        const purchasableGoods = evaluateCityPurchasePotential(city);
        score += purchasableGoods.length * 15;
        
        // 检查销售机会
        const salableGoods = evaluateCitySalePotential(city);
        score += salableGoods.length * 20;
        
        // 检查城市类型（优先选择不同类型的城市）
        const currentCityType = tradingConfig.cities[currentCity].region;
        const targetCityType = tradingConfig.cities[city].region;
        if (currentCityType !== targetCityType) {
            score += 25; // 不同类型城市加分
        }
        
        // 最近访问过的城市分数降低
        if (isRecentlyVisited(city)) {
            score -= 30;
        }
        
        // 检查是否有库存商品在该城市有高利润
        const highProfitGoods = getHighProfitGoodsInCity(city);
        score += highProfitGoods.length * 30;
        
        // 检查是否有便宜的商品可购买
        const cheapGoods = getCheapGoodsInCity(city);
        score += cheapGoods.length * 10;
        
        cityScores.push({
            city: city,
            score: score,
            purchasePotential: purchasableGoods.length,
            salePotential: salableGoods.length,
            highProfitGoods: highProfitGoods.length,
            cheapGoods: cheapGoods.length
        });
    });
    
    // 选择分数最高的城市
    cityScores.sort((a, b) => b.score - a.score);
    const bestCity = cityScores[0].city;
    const bestCityScore = cityScores[0];
    
    // 记录决策原因
    let decisionReason = "决定前往";
    if (bestCityScore.purchasePotential > 0) {
        decisionReason += ` ${bestCityScore.purchasePotential}个采购机会`;
    }
    if (bestCityScore.salePotential > 0) {
        decisionReason += ` ${bestCityScore.salePotential}个销售机会`;
    }
    if (bestCityScore.highProfitGoods > 0) {
        decisionReason += ` ${bestCityScore.highProfitGoods}个高利润商品`;
    }
    if (bestCityScore.cheapGoods > 0) {
        decisionReason += ` ${bestCityScore.cheapGoods}个低价商品`;
    }
    if (bestCityScore.purchasePotential === 0 && bestCityScore.salePotential === 0) {
        decisionReason += " 探索新城市";
    }
    
    addAutoTradeLog(`${decisionReason}，前往${bestCity}`, "info");
    startAutoTravel(bestCity);
}
function getHighProfitGoodsInCity(city) {
    const highProfitGoods = [];
    
    // 检查库存中的商品
    Object.keys(player.trading.inventory).forEach(good => {
        if (player.trading.inventory[good].quantity > 0) {
            const price = player.trading.cityPrices[city][good];
            const averageCost = player.trading.inventory[good].averageCost;
            
            if (averageCost > 0) {
                const profitMargin = ((price - averageCost) / averageCost) * 100;
                const highProfitThreshold = (player.trading.autoTrade.currentRoute?.minProfitMargin || 
                                           player.trading.autoTrade.purchaseSettings.minProfitMargin) * 2;
                
                if (profitMargin >= highProfitThreshold) {
                    highProfitGoods.push({
                        good: good,
                        profitMargin: profitMargin
                    });
                }
            }
        }
    });
    
    return highProfitGoods;
}

function getCheapGoodsInCity(city) {
    const cheapGoods = [];
    const allGoods = Object.keys(tradingConfig.goods);
    
    allGoods.forEach(good => {
        const price = player.trading.cityPrices[city][good];
        const basePrice = tradingConfig.goods[good].basePrice;
        const priceRatio = price / basePrice;
        
        // 价格低于基础价格的商品认为是便宜的
        if (priceRatio < 0.9) {
            cheapGoods.push({
                good: good,
                price: price,
                basePrice: basePrice,
                discount: (1 - priceRatio) * 100
            });
        }
    });
    
    return cheapGoods;
}

function evaluateCityPurchasePotential(city) {
    const goods = Object.keys(tradingConfig.goods);
    const purchasableGoods = [];
    
    goods.forEach(good => {
        const price = player.trading.cityPrices[city][good];
        let maxBuyPrice = Infinity;
        
        if (player.trading.autoTrade.currentRoute) {
            const routeGood = player.trading.autoTrade.currentRoute.goods.find(g => g.good === good);
            if (routeGood) {
                maxBuyPrice = routeGood.maxBuyPrice * (1 + player.trading.autoTrade.purchaseSettings.priceTolerance);
            }
        }
        
        if (price <= maxBuyPrice) {
            purchasableGoods.push(good);
        }
    });
    
    return purchasableGoods;
}

// 评估城市的销售潜力
function evaluateCitySalePotential(city) {
    const salableGoods = [];
    
    Object.keys(player.trading.inventory).forEach(good => {
        if (player.trading.inventory[good].quantity > 0) {
            const price = player.trading.cityPrices[city][good];
            const averageCost = player.trading.inventory[good].averageCost;
            
            if (averageCost > 0) {
                const profitMargin = ((price - averageCost) / averageCost) * 100;
                const minProfitMargin = player.trading.autoTrade.currentRoute?.minProfitMargin || 
                                      player.trading.autoTrade.purchaseSettings.minProfitMargin;
                
                if (profitMargin >= minProfitMargin) {
                    salableGoods.push(good);
                }
            }
        }
    });
    
    return salableGoods;
}

// 检查城市是否最近访问过
function isRecentlyVisited(city) {
    // 简化实现：检查最近5条日志中是否提到该城市
    const recentLogs = player.trading.autoTrade.logs.slice(0, 5);
    return recentLogs.some(log => log.message.includes(city));
}
function updateAutoTradeProgressBar() {
    // 检查进度条元素是否存在
    const progressBar = document.getElementById('autoTravelProgress');
    const percentageText = document.getElementById('autoTravelPercentage');
    const statusElement = document.querySelector('#autoTradeProgress .progress-label span:first-child');
    
    // 如果元素不存在，直接返回
    if (!progressBar || !percentageText || !statusElement) {
        return;
    }
    
    let progressPercent = 0;
    let statusText = '';
    
    switch (player.trading.autoTrade.currentState) {
        case 'traveling':
            progressPercent = Math.min(100, (player.trading.autoTrade.currentProgress / player.trading.autoTrade.totalTravelTime) * 100);
            statusText = `前往 ${player.trading.travelDestination}`;
            break;
        case 'buying':
            progressPercent = 50;
            statusText = `在 ${player.trading.autoTrade.currentRoute?.buyCity || '-'} 采购`;
            break;
        case 'selling':
            progressPercent = 50;
            statusText = `在 ${player.trading.autoTrade.currentRoute?.sellCity || '-'} 销售`;
            break;
        default:
            progressPercent = 0;
            statusText = '等待开始';
    }
    
    // 更新进度条
    progressBar.style.width = `${progressPercent}%`;
    percentageText.textContent = `${progressPercent.toFixed(1)}%`;
    
    // 更新状态文本
    statusElement.textContent = statusText;
}
// 智能采购逻辑
function executeSmartBuying() {
    // 确保当前城市有效
    if (!player.trading.currentCity || !tradingConfig.cities[player.trading.currentCity]) {
        logAction("当前城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都'; // 默认城市
        return;
    }
    
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    
    // 检查货仓使用率
    const totalCapacity = player.trading.warehouse.capacity + player.trading.transport.capacityBonus;
    const usageRate = player.trading.warehouse.used / totalCapacity;
    
    if (usageRate >= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage) {
        addAutoTradeLog("货仓使用率超过设定值，开始前往销售城市", "info");
        startAutoTravel(route.sellCity);
        return;
    }
    
    // 获取可购买的商品列表（按策略排序）
    const availableGoods = getAvailableGoodsForPurchase(route);
    
    if (availableGoods.length === 0) {
        addAutoTradeLog("没有价格合适的商品可购买，开始前往销售城市", "info");
        startAutoTravel(route.sellCity);
        return;
    }
    
    // 购买策略选择的商品
    const targetGood = availableGoods[0];
    
    // 确保商品名称有效
    if (!targetGood || typeof targetGood !== 'string') {
        addAutoTradeLog("无法确定要购买的商品，开始前往销售城市", "error");
        startAutoTravel(route.sellCity);
        return;
    }
    
    const price = player.trading.cityPrices[city][targetGood];
    const quantity = calculateOptimalPurchaseQuantity(targetGood, route.tradeCapital);
    
    if (quantity > 0) {
        buyGood(targetGood, quantity);
        addAutoTradeLog(`购买了${quantity}个${targetGood}，花费${(price * quantity).toLocaleString()}星币`, "success");
    } else {
        addAutoTradeLog(`无法购买${targetGood}，资金或空间不足`, "warning");
        
        // 尝试购买下一个商品
        if (availableGoods.length > 1) {
            player.trading.autoTrade.currentRoute.currentGoodIndex = 
                (player.trading.autoTrade.currentRoute.currentGoodIndex + 1) % availableGoods.length;
        } else {
            // 没有其他商品可买，开始旅行
            addAutoTradeLog("所有商品都无法购买，开始前往销售城市", "info");
            startAutoTravel(route.sellCity);
        }
    }
}

function getAvailableGoodsForPurchase(route) {
    const city = player.trading.currentCity;
    const availableGoods = [];
    const strategy = player.trading.autoTrade.purchaseSettings.purchaseStrategy;
    
    // 确保route和route.goods存在
    if (!route || !route.goods || !Array.isArray(route.goods)) {
        return [];
    }
    
    route.goods.forEach(item => {
        // 确保item和item.good存在
        if (!item || !item.good) return;
        
        const good = item.good;
        const price = player.trading.cityPrices[city][good];
        const maxPrice = item.maxBuyPrice * (1 + player.trading.autoTrade.purchaseSettings.priceTolerance);
        
        // 确保价格有效
        if (price && price <= maxPrice) {
            const basePrice = tradingConfig.goods[good].basePrice;
            const priceRatio = price / basePrice;
            
            availableGoods.push({
                good: good,
                price: price,
                basePrice: basePrice,
                priceRatio: priceRatio,
                maxBuyPrice: item.maxBuyPrice
            });
        }
    });
    
    // 根据策略排序
    switch (strategy) {
        case 'priceDesc':
            // 价格降序（先买最贵的）
            availableGoods.sort((a, b) => b.price - a.price);
            break;
        case 'priceAsc':
            // 价格升序（先买最便宜的）
            availableGoods.sort((a, b) => a.price - b.price);
            break;
        case 'profitMargin':
            // 利润率优先（基于基础价格计算潜在利润率）
            availableGoods.sort((a, b) => {
                // 价格接近基础价格的商品有更高潜在利润率
                const aProfitPotential = 1 / a.priceRatio;
                const bProfitPotential = 1 / b.priceRatio;
                return bProfitPotential - aProfitPotential;
            });
            break;
    }
    
    return availableGoods.map(item => item.good);
}


// 计算最优购买数量
function calculateOptimalPurchaseQuantity(good, availableCapital) {
    const city = player.trading.currentCity;
    const price = player.trading.cityPrices[city][good];
    const goodConfig = tradingConfig.goods[good];
    
    // 基于可用资金计算
    const maxByFunds = Math.floor(Math.min(availableCapital, player.nightClub.starCoins) / price);
    
    // 基于货仓空间计算
    const totalCapacity = player.trading.warehouse.capacity + player.trading.transport.capacityBonus;
    const availableSlots = totalCapacity - player.trading.warehouse.used;
    const maxBySlots = Math.floor(availableSlots / goodConfig.slots);
    
    // 基于策略计算（价格高的商品少买，价格低的商品多买）
    const basePrice = goodConfig.basePrice;
    const priceRatio = price / basePrice;
    const strategyMultiplier = priceRatio > 1.5 ? 0.5 : 1; // 价格过高时减少购买量
    
    // 计算最优数量
    const optimalQuantity = Math.min(maxByFunds, maxBySlots, 10) * strategyMultiplier;
    
    return Math.max(1, Math.floor(optimalQuantity));
}

function executeSmartSelling() {
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    
    // 获取可销售的商品列表（按利润率降序）
    const availableGoods = getAvailableGoodsForSale(route);
    
    if (availableGoods.length === 0) {
        addAutoTradeLog("没有利润率合适的商品可销售", "info");
        
        // 决定下一步行动
        decideNextAction();
         
        return;
    }
    
    // 销售利润率最高的商品
    const targetGood = availableGoods[0];
    const price = player.trading.cityPrices[city][targetGood.good];
    const averageCost = player.trading.inventory[targetGood.good].averageCost;
    const profitMargin = ((price - averageCost) / averageCost) * 100;
    
    // 计算销售数量（基于库存和策略）
    const quantity = calculateOptimalSaleQuantity(targetGood.good);
    
    if (quantity > 0) {
        sellGood(targetGood.good, quantity);
        addAutoTradeLog(`出售了${quantity}个${targetGood.good}，利润率${profitMargin.toFixed(1)}%`, "success");
    } else {
        addAutoTradeLog(`无法销售${targetGood.good}，库存不足`, "warning");
        
        // 尝试销售下一个商品
        if (availableGoods.length > 1) {
            availableGoods.shift(); // 移除当前商品
            const nextGood = availableGoods[0];
            // 继续尝试销售下一个商品
        } else {
            // 没有其他商品可卖，决定下一步行动
            decideNextAction();
        }
    }
}
function getAvailableGoodsForSale(route) {
    const city = player.trading.currentCity;
    const availableGoods = [];
    
    // 检查库存中的商品
    Object.keys(player.trading.inventory).forEach(good => {
        if (player.trading.inventory[good].quantity > 0) {
            const price = player.trading.cityPrices[city][good];
            const averageCost = player.trading.inventory[good].averageCost;
            
            if (averageCost > 0) {
                const profitMargin = ((price - averageCost) / averageCost) * 100;
                
                if (profitMargin >= route.minProfitMargin) {
                    availableGoods.push({
                        good: good,
                        profitMargin: profitMargin,
                        price: price,
                        cost: averageCost
                    });
                }
            }
        }
    });
    
    // 按利润率降序排序
    availableGoods.sort((a, b) => b.profitMargin - a.profitMargin);
    
    return availableGoods;
}
function calculateOptimalSaleQuantity(good) {
    const inventory = player.trading.inventory[good];
    if (!inventory) return 0;
    
    const quantity = inventory.quantity;
    
    // 销售策略：利润率越高，销售比例越大
    const currentPrice = player.trading.cityPrices[player.trading.currentCity][good];
    const profitMargin = ((currentPrice - inventory.averageCost) / inventory.averageCost) * 100;
    
    let saleRatio = 0.5; // 默认销售50%
    
    if (profitMargin >= 50) {
        saleRatio = 0.8; // 高利润率时销售80%
    } else if (profitMargin >= 20) {
        saleRatio = 0.6; // 中等利润率时销售60%
    } else if (profitMargin >= 10) {
        saleRatio = 0.4; // 低利润率时销售40%
    }
    
    // 确保至少销售1个，最多销售库存数量
    return Math.max(1, Math.min(quantity, Math.floor(quantity * saleRatio)));
}


// 决定下一步行动（智能决策）
function decideNextAction() {
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    
    // 确保当前城市有效
    if (!city || !tradingConfig.cities[city]) {
        logAction("当前城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都'; // 默认城市
        return;
    }
    
    // 检查当前城市是否有库存
    const hasInventory = Object.keys(player.trading.inventory).some(good => 
        player.trading.inventory[good].quantity > 0
    );
    
    // 检查当前城市是否有可购买的商品
    const hasPurchasableGoods = getAvailableGoodsForPurchase(route).length > 0;
    
    // 决策逻辑
    if (city === route.buyCity) {
        // 在采购城市
        if (hasPurchasableGoods) {
            // 有商品可买，继续采购
            player.trading.autoTrade.currentState = 'buying';
            addAutoTradeLog("继续在采购城市寻找可购买的商品", "info");
        } else {
            // 没有商品可买，前往销售城市
            startAutoTravel(route.sellCity);
        }
    } else if (city === route.sellCity) {
        // 在销售城市
        if (hasInventory) {
            // 有库存但利润率不足，随机决定下一步
            const randomDecision = Math.random();
            
            if (randomDecision < 0.3) {
                // 30%概率：前往随机城市
                goToRandomCity();
            } else if (randomDecision < 0.6) {
                // 30%概率：返回采购城市
                startAutoTravel(route.buyCity);
            } else {
                // 40%概率：等待价格变化
                addAutoTradeLog("利润率不足，等待价格变化", "info");
                // 停留一段时间（模拟等待）
                setTimeout(() => {
                    if (player.trading.autoTrade.currentState === 'selling') {
                        executeSmartSelling(); // 重新尝试销售
                    }
                }, 30000); // 等待30秒
            }
        } else {
            // 没有库存，返回采购城市
            startAutoTravel(route.buyCity);
        }
    } else {
        // 在其他城市，返回采购城市
        startAutoTravel(route.buyCity);
    }
}
function goToRandomCity() {
    const currentCity = player.trading.currentCity;
    
    // 确保当前城市有效
    if (!currentCity || !tradingConfig.cities[currentCity]) {
        logAction("当前城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都'; // 默认城市
        return;
    }
    
    const connectedCities = tradingConfig.cities[currentCity].connections;
    
    if (connectedCities.length === 0) {
        addAutoTradeLog("没有可连接的城市，返回采购城市", "warning");
        startAutoTravel(player.trading.autoTrade.currentRoute.buyCity);
        return;
    }
    
    // 随机选择一个城市
    const randomIndex = Math.floor(Math.random() * connectedCities.length);
    const randomCity = connectedCities[randomIndex];
    
    // 确保随机城市有效
    if (!randomCity || !tradingConfig.cities[randomCity]) {
        addAutoTradeLog("随机选择的城市无效，返回采购城市", "error");
        startAutoTravel(player.trading.autoTrade.currentRoute.buyCity);
        return;
    }
    
    addAutoTradeLog(`随机选择前往${randomCity}`, "info");
    startAutoTravel(randomCity);
}

function startAutoTradeRoute() {
    if (player.trading.autoTrade.routes.length === 0) {
        addAutoTradeLog("没有设置自动贸易路线", "warning");
        player.trading.autoTrade.enabled = false;
        updateAutoTradeTab();
        return;
    }
    
    // 选择一条路线（简单实现：选择第一条）
    player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0];
    
    // 确保路线有效
    if (!player.trading.autoTrade.currentRoute) {
        addAutoTradeLog("自动贸易路线无效", "error");
        player.trading.autoTrade.enabled = false;
        updateAutoTradeTab();
        return;
    }
    
    // 检查是否已经在采购城市
    if (player.trading.currentCity === player.trading.autoTrade.currentRoute.buyCity) {
        player.trading.autoTrade.currentState = 'buying';
        
        // 修复日志显示 - 不指定具体商品，因为可能采购多种商品
        addAutoTradeLog(`开始在${player.trading.currentCity}采购商品`, "info");
    } else {
        // 需要旅行到采购城市
        startAutoTravel(player.trading.autoTrade.currentRoute.buyCity);
    }
}
function startAutoTravel(destination) {
    // 确保当前城市有效
    if (!player.trading.currentCity || !tradingConfig.cities[player.trading.currentCity]) {
        logAction("当前城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都'; // 默认城市
        return;
    }
    
    // 确保目标城市有效
    if (!destination || !tradingConfig.cities[destination]) {
        addAutoTradeLog("目标城市无效，无法开始旅行", "error");
        player.trading.autoTrade.currentState = 'monitoring';
        return;
    }
    
    if (player.trading.currentCity === destination) {
        // 已经在目的地
        player.trading.autoTrade.currentState = player.trading.autoTrade.currentState === 'buying' ? 'buying' : 'selling';
        return;
    }
    
    // 检查是否连接
    if (!tradingConfig.cities[player.trading.currentCity].connections.includes(destination)) {
        addAutoTradeLog(`无法直接前往${destination}，需要先连接到该城市`, "error");
        player.trading.autoTrade.currentState = 'monitoring';
        return;
    }
    
    const baseTime = tradingConfig.cities[destination].travelTime;
    const speedBonus = player.trading.transport.speedBonus;
    const actualTime = baseTime * (100 - speedBonus) / 100;
    
    player.trading.autoTrade.currentState = 'traveling';
    player.trading.autoTrade.totalTravelTime = actualTime * 60 * 1000;
    player.trading.autoTrade.currentProgress = 0;
    player.trading.travelDestination = destination;
    player.trading.isTraveling = true;
    player.trading.travelStartTime = Date.now();
    player.trading.travelEndTime = Date.now() + actualTime * 60 * 1000;
    
    addAutoTradeLog(`开始前往${destination}，预计需要${actualTime.toFixed(1)}分钟`, "info");
    
    // 确保清除之前的计时器
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
    }
    
    // 启动旅行计时器
    player.trading.travelInterval = setInterval(checkTravelStatus, 1000);
}



function updateAutoTravel(elapsed) {
    player.trading.autoTrade.currentProgress += elapsed;
    
    // 更新旅行进度显示
    updateTravelProgress();
    
    // 检查是否到达目的地
    if (player.trading.autoTrade.currentProgress >= player.trading.autoTrade.totalTravelTime) {
        completeAutoTravel();
    }
}

function completeAutoTravel() {
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
        player.trading.travelInterval = null;
    }
    
    player.trading.currentCity = player.trading.travelDestination;
    player.trading.isTraveling = false;
    player.trading.travelDestination = '';
    player.trading.autoTrade.currentProgress = 0;
    
    // 重置当前城市停留时间
    player.trading.autoTrade.currentCityStayStart = Date.now();
    
    addAutoTradeLog(`已到达${player.trading.currentCity}，开始寻找贸易机会`, "success");
    
    // 到达新城市后，同时检查采购和销售机会
    checkBothPurchaseAndSaleOpportunities();
    
    // 更新界面
    updateMapTab();
    updateTradingUI();
}
function checkBothPurchaseAndSaleOpportunities() {
    const city = player.trading.currentCity;
    
    // 检查是否有销售机会（优先检查，因为可能已有库存）
    const salableGoods = getAllSalableGoods();
    if (salableGoods.length > 0) {
        addAutoTradeLog(`发现${salableGoods.length}个销售机会，开始销售`, "info");
        player.trading.autoTrade.currentState = 'selling';
        return;
    }
    
    // 检查是否有采购机会
    const purchasableGoods = getAllPurchasableGoods();
    if (purchasableGoods.length > 0) {
        addAutoTradeLog(`发现${purchasableGoods.length}个采购机会，开始采购`, "info");
        player.trading.autoTrade.currentState = 'buying';
        return;
    }
    
    // 如果都没有机会，进入监控模式
    addAutoTradeLog("当前城市没有发现采购或销售机会，开始监控价格", "info");
    player.trading.autoTrade.currentState = 'monitoring';
    player.trading.autoTrade.nextMonitorTime = Date.now() + 30000; // 30秒后再次检查
}

function executeAutoBuy() {
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    const price = player.trading.cityPrices[city][route.good];
    
    if (price > route.maxBuyPrice) {
        addAutoTradeLog(`${route.good}价格${price}高于最大购买价${route.maxBuyPrice}，等待降价`, "info");
        return;
    }
    
    // 计算可购买数量
    const availableFunds = Math.min(player.nightClub.starCoins, route.tradeCapital);
    const maxByFunds = Math.floor(availableFunds / price);
    const goodConfig = tradingConfig.goods[route.good];
    const availableSlots = player.trading.warehouse.capacity + player.trading.transport.capacityBonus - player.trading.warehouse.used;
    const maxBySlots = Math.floor(availableSlots / goodConfig.slots);
    
    const quantity = Math.min(maxByFunds, maxBySlots, 10);
    
    if (quantity > 0) {
        buyGood(route.good, quantity);
        addAutoTradeLog(`购买了${quantity}个${route.good}，花费${(price * quantity).toLocaleString()}星币`, "success");
        
        // 购买完成后，前往销售城市
        startAutoTravel(route.sellCity);
    } else {
        addAutoTradeLog("资金或货仓空间不足，无法购买", "warning");
    }
}

function validateCity(cityName) {
    return cityName && tradingConfig.cities[cityName];
}
function validateAutoTradeData() {
    // 确保routes数组存在
    if (!player.trading.autoTrade.routes) {
        player.trading.autoTrade.routes = [];
    }
    
    // 确保当前路线有效
    if (player.trading.autoTrade.currentRoute && 
        !player.trading.autoTrade.routes.includes(player.trading.autoTrade.currentRoute)) {
        // 当前路线不在保存的路线中，重置
        player.trading.autoTrade.currentRoute = null;
        player.trading.autoTrade.currentState = 'idle';
        addAutoTradeLog("当前路线无效，已重置", "warning");
    }
    
    // 如果没有当前路线但有保存的路线，选择第一条
    if (!player.trading.autoTrade.currentRoute && player.trading.autoTrade.routes.length > 0) {
        player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0];
        addAutoTradeLog("已选择第一条路线作为活动路线", "info");
    }
}

function executeAutoSell() {
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    const price = player.trading.cityPrices[city][route.good];
    
    // 检查库存
    if (!player.trading.inventory[route.good] || player.trading.inventory[route.good].quantity === 0) {
        addAutoTradeLog("没有库存可出售，返回采购城市", "info");
        startAutoTravel(route.buyCity);
        return;
    }
    
    // 计算利润率
    const averageCost = player.trading.inventory[route.good].averageCost;
    const profitMargin = ((price - averageCost) / averageCost) * 100;
    
    if (profitMargin < route.minProfitMargin) {
        addAutoTradeLog(`${route.good}利润率${profitMargin.toFixed(1)}%低于最低要求${route.minProfitMargin}%，等待价格上涨`, "info");
        return;
    }
    
    // 出售部分库存
    const quantity = Math.min(player.trading.inventory[route.good].quantity, 5);
    const revenue = price * quantity;
    const cost = averageCost * quantity;
    const profit = revenue - cost;
    
    sellGood(route.good, quantity);
    
    // 更新统计信息
    player.trading.autoTrade.stats.totalProfit += profit;
    player.trading.autoTrade.stats.totalTrades++;
    player.trading.autoTrade.stats.successfulTrades++;
    
    addAutoTradeLog(`出售了${quantity}个${route.good}，获得${revenue.toLocaleString()}星币，利润${profit.toLocaleString()}星币，利润率${profitMargin.toFixed(1)}%`, "success");
    
    // 出售完成后，返回采购城市继续采购
    startAutoTravel(route.buyCity);
}

function createAutoTradeLogModal() {
    const modalHTML = `
    <div id="autoTradeLogModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1002; width: 800px; max-height: 80vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="color: #FFD700; margin: 0;">自动贸易日志</h2>
            <button onclick="closeAutoTradeLog()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        
        <div style="margin-bottom: 15px;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" id="logSearch" placeholder="搜索日志..." style="flex: 1; padding: 5px; background: #333; color: white; border: 1px solid #444; border-radius: 3px;">
                <select id="logFilter" style="padding: 5px; background: #333; color: white; border: 1px solid #444; border-radius: 3px;">
                    <option value="all">所有类型</option>
                    <option value="info">信息</option>
                    <option value="success">成功</option>
                    <option value="warning">警告</option>
                    <option value="error">错误</option>
                </select>
                <button onclick="clearAutoTradeLogs()" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">清空日志</button>
            </div>
        </div>
        
        <div id="autoTradeLogContainer" style="max-height: 400px; overflow-y: auto; background: #222; border-radius: 5px; padding: 10px;">
            <!-- 日志内容将在这里动态生成 -->
        </div>
        
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #444;">
            <h3 style="color: #FFD700;">统计信息</h3>
            <div id="autoTradeStats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <!-- 统计信息将在这里动态生成 -->
            </div>
        </div>
    </div>
    <div id="autoTradeLogOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1001;"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

// 尝试自动买入
function tryAutoBuy(route) {
    const good = route.good;
    const maxPrice = route.maxBuyPrice;
    const currentPrice = player.trading.cityPrices[player.trading.currentCity][good];
    
    if (currentPrice <= maxPrice) {
        // 计算可购买数量
        const availableFunds = player.nightClub.starCoins * 0.1;
        const maxByFunds = Math.floor(availableFunds / currentPrice);
        const goodConfig = tradingConfig.goods[good];
        const availableSlots = player.trading.warehouse.capacity + player.trading.transport.capacityBonus - player.trading.warehouse.used;
        const maxBySlots = Math.floor(availableSlots / goodConfig.slots);
        
        const quantity = Math.min(maxByFunds, maxBySlots, 10);
        
        if (quantity > 0) {
            buyGood(good, quantity);
        }
    }
}

// 尝试自动卖出
function tryAutoSell(route) {
    const good = route.good;
    const minProfitMargin = route.minProfitMargin;
    
    if (player.trading.inventory[good] && player.trading.inventory[good].quantity > 0) {
        const currentPrice = player.trading.cityPrices[player.trading.currentCity][good];
        const averageCost = player.trading.inventory[good].averageCost;
        const profitMargin = ((currentPrice - averageCost) / averageCost) * 100;
        
        if (profitMargin >= minProfitMargin) {
            const quantity = Math.min(player.trading.inventory[good].quantity, 5);
            sellGood(good, quantity);
        }
    }
}

function createInventorySummaryModal() {
    // 检查是否已存在弹窗，避免重复创建
    if (document.getElementById('inventorySummaryModal')) {
        return;
    }
    
    const modalHTML = `
    <div id="inventorySummaryModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1002; width: 800px; max-height: 80vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="color: #FFD700; margin: 0;">库存统计详情</h2>
            <button onclick="closeInventorySummary()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h3>总体统计</h3>
            <div id="overallStats" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; background: #333; padding: 10px; border-radius: 5px;">
                <!-- 总体统计数据将在这里动态生成 -->
            </div>
        </div>
        
        <div>
            <h3>商品详情</h3>
            <div style="max-height: 400px; overflow-y: auto;">
                <table id="inventoryDetails" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #333;">
                            <th style="padding: 10px; text-align: left; border-bottom: 1px solid #444;">商品</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">数量</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">当前价格</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">平均成本</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">总成本</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">当前价值</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">盈亏金额</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">盈亏率</th>
                        </tr>
                    </thead>
                    <tbody id="inventoryDetailsBody">
                        <!-- 商品详情将在这里动态生成 -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <div style="margin-top: 20px; text-align: center;">
            <button onclick="sortInventoryBy('profitRate')" style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 3px; cursor: pointer;">按盈亏率排序</button>
        </div>
    </div>
    <div id="inventorySummaryOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1001;"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function showInventorySummary() {
    // 确保弹窗已创建
    createInventorySummaryModal();
    
    // 计算库存统计数据
    const stats = calculateInventoryStats();
    
    // 更新总体统计
    updateOverallStats(stats);
    
    // 更新商品详情
    updateInventoryDetails(stats);
    
    // 显示弹窗
    document.getElementById('inventorySummaryModal').style.display = 'block';
    document.getElementById('inventorySummaryOverlay').style.display = 'block';
}

// 关闭库存统计弹窗
function closeInventorySummary() {
    document.getElementById('inventorySummaryModal').style.display = 'none';
    document.getElementById('inventorySummaryOverlay').style.display = 'none';
}

// 计算库存统计数据
function calculateInventoryStats() {
    let totalValue = 0;
    let totalCost = 0;
    let totalProfit = 0;
    let itemCount = 0;
    let bestPerformer = { name: '', profitRate: -Infinity };
    let worstPerformer = { name: '', profitRate: Infinity };
    
    const items = [];
    
    Object.keys(player.trading.inventory).forEach(good => {
        const item = player.trading.inventory[good];
        const currentPrice = player.trading.cityPrices[player.trading.currentCity][good];
        const itemValue = currentPrice * item.quantity;
        const itemCost = item.totalCost;
        const itemProfit = itemValue - itemCost;
        const itemProfitRate = itemCost > 0 ? (itemProfit / itemCost) * 100 : 0;
        
        totalValue += itemValue;
        totalCost += itemCost;
        totalProfit += itemProfit;
        itemCount++;
        
        // 更新最佳和最差表现者
        if (itemProfitRate > bestPerformer.profitRate) {
            bestPerformer = { name: good, profitRate: itemProfitRate };
        }
        if (itemProfitRate < worstPerformer.profitRate) {
            worstPerformer = { name: good, profitRate: itemProfitRate };
        }
        
        // 添加商品详情
        items.push({
            name: good,
            quantity: item.quantity,
            currentPrice: currentPrice,
            averageCost: item.averageCost,
            totalCost: itemCost,
            currentValue: itemValue,
            profit: itemProfit,
            profitRate: itemProfitRate
        });
    });
    
    const overallProfitRate = totalCost > 0 ? (totalProfit / totalCost) * 100 : 0;
    
    return {
        totalValue,
        totalCost,
        totalProfit,
        overallProfitRate,
        itemCount,
        bestPerformer,
        worstPerformer,
        items
    };
}
function updateOverallStats(stats) {
    const overallStats = document.getElementById('overallStats');
    const profitColor = stats.totalProfit >= 0 ? '#4CAF50' : '#f44336';
    const profitSign = stats.totalProfit >= 0 ? '+' : '';
    
    overallStats.innerHTML = `
        <div style="text-align: center;">
            <div style="font-size: 0.9em; color: #aaa;">商品种类</div>
            <div style="font-size: 1.2em; font-weight: bold;">${stats.itemCount}</div>
        </div>
        <div style="text-align: center;">
            <div style="font-size: 0.9em; color: #aaa;">总成本</div>
            <div style="font-size: 1.2em; font-weight: bold;">${stats.totalCost.toLocaleString()}</div>
        </div>
        <div style="text-align: center;">
            <div style="font-size: 0.9em; color: #aaa;">总价值</div>
            <div style="font-size: 1.2em; font-weight: bold;">${stats.totalValue.toLocaleString()}</div>
        </div>
        <div style="text-align: center;">
            <div style="font-size: 0.9em; color: #aaa;">总盈亏</div>
            <div style="font-size: 1.2em; font-weight: bold; color: ${profitColor};">${profitSign}${stats.totalProfit.toLocaleString()}</div>
            <div style="font-size: 0.9em; color: ${profitColor};">${profitSign}${stats.overallProfitRate.toFixed(2)}%</div>
        </div>
    `;
    
    // 添加最佳和最差表现者
    if (stats.itemCount > 0) {
        overallStats.innerHTML += `
            <div style="text-align: center; grid-column: 1 / span 2;">
                <div style="font-size: 0.9em; color: #aaa;">最佳表现</div>
                <div style="font-size: 1em; color: #4CAF50;">${stats.bestPerformer.name}</div>
                <div style="font-size: 0.9em; color: #4CAF50;">+${stats.bestPerformer.profitRate.toFixed(2)}%</div>
            </div>
            <div style="text-align: center; grid-column: 3 / span 2;">
                <div style="font-size: 0.9em; color: #aaa;">最差表现</div>
                <div style="font-size: 1em; color: #f44336;">${stats.worstPerformer.name}</div>
                <div style="font-size: 0.9em; color: #f44336;">${stats.worstPerformer.profitRate.toFixed(2)}%</div>
            </div>
        `;
    }
}
function updateInventoryDetails(stats) {
    const tbody = document.getElementById('inventoryDetailsBody');
    tbody.innerHTML = '';
    
    if (stats.items.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="8" style="text-align: center; padding: 20px; color: #888;">暂无库存商品</td>
            </tr>
        `;
        return;
    }
    
    stats.items.forEach(item => {
        const profitColor = item.profit >= 0 ? '#4CAF50' : '#f44336';
        const profitSign = item.profit >= 0 ? '+' : '';
        
        const row = document.createElement('tr');
        row.style.borderBottom = '1px solid #444';
        row.innerHTML = `
            <td style="padding: 8px;">${item.name}</td>
            <td style="padding: 8px; text-align: right;">${item.quantity}</td>
            <td style="padding: 8px; text-align: right;">${item.currentPrice.toLocaleString()}</td>
            <td style="padding: 8px; text-align: right;">${item.averageCost.toFixed(0)}</td>
            <td style="padding: 8px; text-align: right;">${item.totalCost.toLocaleString()}</td>
            <td style="padding: 8px; text-align: right;">${item.currentValue.toLocaleString()}</td>
            <td style="padding: 8px; text-align: right; color: ${profitColor};">${profitSign}${item.profit.toLocaleString()}</td>
            <td style="padding: 8px; text-align: right; color: ${profitColor};">${profitSign}${item.profitRate.toFixed(2)}%</td>
        `;
        tbody.appendChild(row);
    });
}

// 按指定字段排序库存
function sortInventoryBy(field) {
    const stats = calculateInventoryStats();
    
    stats.items.sort((a, b) => {
        if (field === 'profitRate') {
            return b.profitRate - a.profitRate; // 降序排列
        } else if (field === 'name') {
            return a.name.localeCompare(b.name);
        } else if (field === 'quantity') {
            return b.quantity - a.quantity;
        } else if (field === 'profit') {
            return b.profit - a.profit;
        }
        return 0;
    });
    
    updateInventoryDetails(stats);
}
function addInventorySummaryButton() {
    const inventoryList = document.getElementById('playerInventory');
    if (!document.getElementById('inventorySummaryBtn')) {
        const summaryBtn = document.createElement('button');
        summaryBtn.id = 'inventorySummaryBtn';
        summaryBtn.textContent = '库存统计';
        summaryBtn.style.marginTop = '10px';
        summaryBtn.style.padding = '5px 15px';
        summaryBtn.onclick = showInventorySummary; // 改为显示弹窗
        inventoryList.parentNode.insertBefore(summaryBtn, inventoryList.nextSibling);
    }
}

// 保存自动贸易路线
function saveAutoTradeRoute() {
    const minProfitMargin = parseInt(document.getElementById('minProfitMargin').value);
    const tradeCapital = parseInt(document.getElementById('tradeCapital').value);
    const purchaseStrategy = document.getElementById('purchaseStrategy').value;
    const maxWarehouseUsage = parseInt(document.getElementById('maxWarehouseUsage').value) / 100;
    const priceTolerance = parseInt(document.getElementById('priceTolerance').value) / 100;
    
    // 获取灵活贸易设置
    const maxCityStayTime = parseInt(document.getElementById('maxCityStayTime').value) * 60 * 1000; // 转换为毫秒
    const explorationChance = parseInt(document.getElementById('explorationChance').value) / 100;
    const minProfitThreshold = parseInt(document.getElementById('minProfitThreshold').value);
    const priceMonitoring = document.getElementById('priceMonitoring').value === 'true';
    
    // 获取选择的商品和对应的最大买入价
    const selectedGoods = [];
    const selectedCheckboxes = document.querySelectorAll('#goodsSelection input[type="checkbox"]:checked');
    
    if (selectedCheckboxes.length === 0) {
        logAction("请至少选择一种商品", "error");
        return;
    }
    
    selectedCheckboxes.forEach(checkbox => {
        const good = checkbox.value;
        const maxPrice = parseInt(document.getElementById(`maxPrice_${good}`).value);
        
        selectedGoods.push({
            good: good,
            maxBuyPrice: maxPrice
        });
    });
    
    // 保存采购策略设置
    player.trading.autoTrade.purchaseSettings.purchaseStrategy = purchaseStrategy;
    player.trading.autoTrade.purchaseSettings.maxWarehouseUsage = maxWarehouseUsage;
    player.trading.autoTrade.purchaseSettings.priceTolerance = priceTolerance;
    
    // 保存灵活贸易设置
    player.trading.autoTrade.flexibleTrade.maxCityStayTime = maxCityStayTime;
    player.trading.autoTrade.flexibleTrade.explorationChance = explorationChance;
    player.trading.autoTrade.flexibleTrade.minProfitThreshold = minProfitThreshold;
    player.trading.autoTrade.flexibleTrade.priceMonitoring = priceMonitoring;
    
    const route = {
        goods: selectedGoods,
        minProfitMargin: minProfitMargin,
        tradeCapital: tradeCapital
    };
    
    // 确保routes数组存在
    if (!player.trading.autoTrade.routes) {
        player.trading.autoTrade.routes = [];
    }
    
    player.trading.autoTrade.routes.push(route);
    logAction(`灵活贸易路线已保存，包含${selectedGoods.length}种商品`, "success");
    
    // 如果自动贸易已启用，设置为当前路线
    if (player.trading.autoTrade.enabled) {
        player.trading.autoTrade.currentRoute = route;
        player.trading.autoTrade.currentState = 'idle';
        addAutoTradeLog("已切换到新保存的路线", "info");
    }
    
    // 更新界面
    updateAutoTradeTab();
}

// 货仓升级
function upgradeWarehouse() {
    const currentLevel = player.trading.warehouse.level;
    if (currentLevel >= tradingConfig.warehouseLevels.length) {
        logAction("货仓已达最高等级", "info");
        return;
    }
    
    const nextLevelConfig = tradingConfig.warehouseLevels[currentLevel];
    
    if (player.nightClub.starCoins < nextLevelConfig.cost) {
        logAction(`星币不足！升级需要${nextLevelConfig.cost.toLocaleString()}星币`, "error");
        return;
    }
    
    player.nightClub.starCoins -= nextLevelConfig.cost;
    player.trading.warehouse.level++;
    player.trading.warehouse.capacity = nextLevelConfig.capacity;
    
    logAction(`货仓升级到${player.trading.warehouse.level}级，容量增加到${nextLevelConfig.capacity}格`, "success");
    updateTradingUI();
    updateDisplay();
}
function buyTransport(transportName) {
    const transport = tradingConfig.transports.find(t => t.name === transportName);
    
    if (!transport) {
        logAction("无效的运输工具", "error");
        return;
    }
    
    if (player.nightClub.starCoins < transport.cost) {
        logAction(`星币不足！购买需要${transport.cost.toLocaleString()}星币`, "error");
        return;
    }
    
    player.nightClub.starCoins -= transport.cost;
    // 购买运输工具是一次性支出，减少今日利润
    player.trading.tradeVolumeToday -= transport.cost;
    
    player.trading.transport = {
        type: transport.name,
        capacityBonus: transport.capacityBonus,
        speedBonus: transport.speedBonus
    };
    
    logAction(`购买了${transport.name}，容量增加${transport.capacityBonus}格，速度提升${transport.speedBonus}%`, "success");
    updateTradingUI();
    updateDisplay();
}

// 雇佣雇员
function hireEmployee(employeeType) {
    const employee = tradingConfig.employees.find(e => e.type === employeeType);
    
    if (!employee) {
        logAction("无效的雇员类型", "error");
        return;
    }
    
    // 检查雇佣条件
    if (employee.requirement === 'warehouse30' && player.trading.warehouse.capacity < 30) {
        logAction("需要货仓达到30格才能雇佣此雇员", "error");
        return;
    }
    
    if (employee.requirement === 'warehouse50' && player.trading.warehouse.capacity < 50) {
        logAction("需要货仓达到50格才能雇佣此雇员", "error");
        return;
    }
    
    if (employee.requirement === 'reputation3' && player.reputation < 3) {
        logAction("需要声望达到3级才能雇佣此雇员", "error");
        return;
    }
    
    if (employee.requirement === 'experiencedRobbery' && !player.trading.hasExperiencedRobbery) {
        logAction("需要经历过强盗事件才能雇佣此雇员", "error");
        return;
    }
    
    if (player.nightClub.starCoins < employee.cost) {
        logAction(`星币不足！雇佣需要${employee.cost.toLocaleString()}星币`, "error");
        return;
    }
    
    // 检查是否已经雇佣
    if (player.trading.employees.some(e => e.type === employeeType)) {
        logAction("已经雇佣了此类型的雇员", "error");
        return;
    }
    
    player.nightClub.starCoins -= employee.cost;
    // 雇佣雇员是一次性支出，减少今日利润
    player.trading.tradeVolumeToday -= employee.cost;
    
    player.trading.employees.push({
        type: employee.type,
        efficiencyBonus: employee.efficiencyBonus || 0,
        intelligenceDiscount: employee.intelligenceDiscount || 0,
        robberyReduction: employee.robberyReduction || 0,
        salary: employee.salary
    });
    
    // 应用雇员效果
    if (employee.efficiencyBonus) {
        player.trading.autoTrade.efficiency += employee.efficiencyBonus / 100;
    }
    
    logAction(`雇佣了${employee.type}，每日工资${employee.salary}星币`, "success");
    updateTradingUI();
    updateDisplay();
}

// 切换保险
function toggleInsurance(type) {
    player.trading.insurance[type] = !player.trading.insurance[type];
    
    const insuranceCost = type === 'goods' ? 0.05 : 0.03;
    const message = player.trading.insurance[type] ? 
        `已购买${type === 'goods' ? '货物' : '运输'}险，保费${insuranceCost * 100}%` : 
        `已取消${type === 'goods' ? '货物' : '运输'}险`;
    
    logAction(message, "info");
}

// 购买情报
function buyIntelligence(city, intelligenceType) {
    const intelligenceConfig = tradingConfig.intelligence[intelligenceType];
    const price = intelligenceConfig.price;
    
    // 检查资金
    if (player.nightClub.starCoins < price) {
        logAction(`星币不足！需要${price.toLocaleString()}星币购买情报`, "error");
        return;
    }
    
    // 扣除费用
    player.nightClub.starCoins -= price;
    
    // 生成情报（有40%概率是假情报）
    const isFake = Math.random() < 0.4;
    const intelligenceData = generateIntelligenceData(city, intelligenceType, isFake);
    
    // 保存情报
    if (!player.trading.intelligence) {
        player.trading.intelligence = {};
    }
    
    if (!player.trading.intelligence[city]) {
        player.trading.intelligence[city] = {};
    }
    
    player.trading.intelligence[city][intelligenceType] = {
        data: intelligenceData,
        isFake: isFake,
        purchaseTime: Date.now(),
        expiryTime: Date.now() + intelligenceConfig.duration * 60 * 1000,
        price: price
    };
    
    // 显示情报详情弹窗
    showIntelligenceDetails(city, intelligenceType, intelligenceData, isFake);
    
    // 记录购买日志（不透露真假信息）
    logAction(`购买了${city}的${intelligenceType}情报，花费${price.toLocaleString()}星币`, "success");
    
    // 更新界面
    updateTradingUI();
}
function generateIntelligenceData(city, intelligenceType, isFake) {
    const data = {};
    
    switch (intelligenceType) {
        case 'marketPrices':
            // 市场价格情报
            Object.keys(tradingConfig.goods).forEach(good => {
                const realPrice = player.trading.cityPrices[city][good];
                
                if (isFake) {
                    // 生成假价格（±20-50%的随机波动）
                    const fluctuation = 0.2 + Math.random() * 0.3;
                    const direction = Math.random() > 0.5 ? 1 : -1;
                    data[good] = Math.round(realPrice * (1 + direction * fluctuation));
                } else {
                    // 真实价格
                    data[good] = realPrice;
                }
            });
            break;
            
        case 'supplyDemand':
            // 供需情况情报
            Object.keys(tradingConfig.goods).forEach(good => {
                const baseData = tradingConfig.goods[good].supplyDemand;
                
                if (isFake) {
                    // 生成假供需数据
                    data[good] = {
                        supply: Math.max(0, Math.min(100, baseData.supply + Math.round((Math.random() - 0.5) * 40))),
                        demand: Math.max(0, Math.min(100, baseData.demand + Math.round((Math.random() - 0.5) * 40)))
                    };
                } else {
                    // 真实供需数据
                    data[good] = baseData;
                }
            });
            break;
            
        case 'futureTrends':
            // 未来趋势情报
            const trends = ['上涨', '下跌', '平稳'];
            Object.keys(tradingConfig.goods).forEach(good => {
                if (isFake) {
                    // 随机趋势
                    data[good] = trends[Math.floor(Math.random() * trends.length)];
                } else {
                    // 基于真实数据的趋势预测
                    const currentPrice = player.trading.cityPrices[city][good];
                    const basePrice = tradingConfig.goods[good].basePrice;
                    const ratio = currentPrice / basePrice;
                    
                    if (ratio > 1.2) {
                        data[good] = '下跌';
                    } else if (ratio < 0.8) {
                        data[good] = '上涨';
                    } else {
                        data[good] = '平稳';
                    }
                }
            });
            break;
            
        case 'specialEvents':
            // 特殊事件情报
            const events = [
                "商会促销活动",
                "货物运输延误",
                "市场需求激增",
                "供应商提价",
                "政府征税调整",
                "天气影响收成",
                "新贸易路线开通",
                "库存积压处理"
            ];
            
            if (isFake) {
                // 随机虚假事件
                const randomEvent = events[Math.floor(Math.random() * events.length)];
                data.event = randomEvent;
                data.impact = Math.random() > 0.5 ? "正面" : "负面";
                data.confidence = Math.round(60 + Math.random() * 35); // 60-95%可信度
            } else {
                // 基于真实数据的特殊事件
                // 这里简化处理，实际可以根据游戏状态生成真实事件
                data.event = "市场正常波动";
                data.impact = "中性";
                data.confidence = 85;
            }
            break;
    }
    
    return data;
}
function showIntelligenceDetails(city, intelligenceType, intelligenceData, isFake) {
    // 创建模态框
    const modalId = 'intelligenceModal';
    const overlayId = 'intelligenceOverlay';
    
    // 移除已存在的模态框
    removeElement(modalId);
    removeElement(overlayId);
    
    // 创建覆盖层
    const overlay = document.createElement('div');
    overlay.id = overlayId;
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    // 创建模态框
    const modal = document.createElement('div');
    modal.id = modalId;
    modal.style.cssText = `
        background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
        border: 2px solid #FFD700;
        border-radius: 10px;
        padding: 20px;
        width: 80%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        color: white;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        position: relative;
    `;
    
    // 生成情报内容
    let intelligenceContent = '';
    const intelligenceTitles = {
        'marketPrices': '市场价格情报',
        'supplyDemand': '供需情况情报',
        'futureTrends': '未来趋势预测',
        'specialEvents': '特殊事件情报'
    };
    
    // 标题
    intelligenceContent += `
        <div style="text-align: center; margin-bottom: 20px;">
            <h2 style="color: #FFD700; margin: 0; border-bottom: 2px solid #444; padding-bottom: 10px;">${city} - ${intelligenceTitles[intelligenceType]}</h2>
            <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                获取时间: ${new Date().toLocaleString()}
            </div>
        </div>
    `;
    
    // 根据情报类型生成不同内容
    switch (intelligenceType) {
        case 'marketPrices':
            intelligenceContent += generateMarketPricesContent(intelligenceData);
            break;
        case 'supplyDemand':
            intelligenceContent += generateSupplyDemandContent(intelligenceData);
            break;
        case 'futureTrends':
            intelligenceContent += generateFutureTrendsContent(intelligenceData);
            break;
        case 'specialEvents':
            intelligenceContent += generateSpecialEventsContent(intelligenceData);
            break;
    }
    
    // 添加可信度指示器（但不透露真假）
    intelligenceContent += `
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #444;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #aaa;">情报可信度评估</span>
                <div style="display: flex; align-items: center;">
                    <div style="width: 100px; height: 6px; background: #333; border-radius: 3px; margin-right: 10px;">
                        <div style="width: ${isFake ? (70 + Math.random() * 25) : (80 + Math.random() * 15)}%; height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 3px;"></div>
                    </div>
                    <span style="color: #4CAF50; font-weight: bold;">${isFake ? '高' : '很高'}</span>
                </div>
            </div>
            <div style="font-size: 0.8em; color: #666; margin-top: 5px;">
                基于多方来源交叉验证，仅供参考
            </div>
        </div>
    `;
    
    // 添加免责声明
    intelligenceContent += `
        <div style="margin-top: 15px; padding: 10px; background: rgba(255, 215, 0, 0.1); border-radius: 5px; border-left: 3px solid #FFD700;">
            <div style="font-size: 0.8em; color: #FFD700;">
                <strong>免责声明:</strong> 市场情报基于多方来源收集，实际市场情况可能有所变化。本情报仅供参考，不构成投资建议。
            </div>
        </div>
    `;
    
    // 添加关闭按钮
    intelligenceContent += `
        <div style="text-align: center; margin-top: 20px;">
            <button onclick="closeIntelligenceModal()" style="background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                关闭情报
            </button>
        </div>
    `;
    
    modal.innerHTML = intelligenceContent;
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // 添加动画效果
    setTimeout(() => {
        modal.style.transform = 'scale(1)';
        modal.style.opacity = '1';
    }, 10);
}

// 生成市场价格情报内容
function generateMarketPricesContent(data) {
    let content = `
        <div style="margin-bottom: 15px;">
            <h3 style="color: #FFD700; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">商品价格信息</h3>
            <div style="max-height: 300px; overflow-y: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: rgba(255, 215, 0, 0.1);">
                            <th style="padding: 8px; text-align: left; border-bottom: 1px solid #333;">商品</th>
                            <th style="padding: 8px; text-align: right; border-bottom: 1px solid #333;">价格 (星币)</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">状态</th>
                        </tr>
                    </thead>
                    <tbody>
    `;
    
    Object.keys(data).forEach(good => {
        const price = data[good];
        const basePrice = tradingConfig.goods[good].basePrice;
        const ratio = price / basePrice;
        
        let status = '';
        let statusColor = '';
        
        if (ratio > 1.2) {
            status = '偏高';
            statusColor = '#f44336';
        } else if (ratio < 0.8) {
            status = '偏低';
            statusColor = '#4CAF50';
        } else {
            status = '正常';
            statusColor = '#FFC107';
        }
        
        content += `
            <tr style="border-bottom: 1px solid #333;">
                <td style="padding: 8px;">${good}</td>
                <td style="padding: 8px; text-align: right; font-weight: bold;">${price.toLocaleString()}</td>
                <td style="padding: 8px; text-align: center; color: ${statusColor};">${status}</td>
            </tr>
        `;
    });
    
    content += `
                    </tbody>
                </table>
            </div>
        </div>
    `;
    
    return content;
}

// 生成供需情况情报内容
function generateSupplyDemandContent(data) {
    let content = `
        <div style="margin-bottom: 15px;">
            <h3 style="color: #FFD700; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">市场供需情况</h3>
            <div style="max-height: 300px; overflow-y: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: rgba(255, 215, 0, 0.1);">
                            <th style="padding: 8px; text-align: left; border-bottom: 1px solid #333;">商品</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">供应量</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">需求量</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">市场状况</th>
                        </tr>
                    </thead>
                    <tbody>
    `;
    
    Object.keys(data).forEach(good => {
        const supply = data[good].supply;
        const demand = data[good].demand;
        const balance = supply - demand;
        
        let condition = '';
        let conditionColor = '';
        
        if (balance > 20) {
            condition = '供过于求';
            conditionColor = '#f44336';
        } else if (balance < -20) {
            condition = '供不应求';
            conditionColor = '#4CAF50';
        } else {
            condition = '供需平衡';
            conditionColor = '#FFC107';
        }
        
        content += `
            <tr style="border-bottom: 1px solid #333;">
                <td style="padding: 8px;">${good}</td>
                <td style="padding: 8px; text-align: center;">
                    <div style="display: inline-block; width: 50px; height: 10px; background: #333; border-radius: 5px; position: relative;">
                        <div style="width: ${supply}%; height: 100%; background: linear-gradient(90deg, #2196F3, #03A9F4); border-radius: 5px;"></div>
                    </div>
                    <span style="margin-left: 5px;">${supply}%</span>
                </td>
                <td style="padding: 8px; text-align: center;">
                    <div style="display: inline-block; width: 50px; height: 10px; background: #333; border-radius: 5px; position: relative;">
                        <div style="width: ${demand}%; height: 100%; background: linear-gradient(90deg, #E91E63, #AD1457); border-radius: 5px;"></div>
                    </div>
                    <span style="margin-left: 5px;">${demand}%</span>
                </td>
                <td style="padding: 8px; text-align: center; color: ${conditionColor}; font-weight: bold;">${condition}</td>
            </tr>
        `;
    });
    
    content += `
                    </tbody>
                </table>
            </div>
        </div>
    `;
    
    return content;
}

// 生成未来趋势情报内容
function generateFutureTrendsContent(data) {
    let content = `
        <div style="margin-bottom: 15px;">
            <h3 style="color: #FFD700; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">价格趋势预测</h3>
            <div style="max-height: 300px; overflow-y: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: rgba(255, 215, 0, 0.1);">
                            <th style="padding: 8px; text-align: left; border-bottom: 1px solid #333;">商品</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">预期趋势</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">建议操作</th>
                        </tr>
                    </thead>
                    <tbody>
    `;
    
    Object.keys(data).forEach(good => {
        const trend = data[good];
        
        let trendColor = '';
        let suggestion = '';
        
        switch (trend) {
            case '上涨':
                trendColor = '#4CAF50';
                suggestion = '考虑买入';
                break;
            case '下跌':
                trendColor = '#f44336';
                suggestion = '考虑卖出';
                break;
            case '平稳':
                trendColor = '#FFC107';
                suggestion = '持有观望';
                break;
        }
        
        content += `
            <tr style="border-bottom: 1px solid #333;">
                <td style="padding: 8px;">${good}</td>
                <td style="padding: 8px; text-align: center; color: ${trendColor}; font-weight: bold;">${trend}</td>
                <td style="padding: 8px; text-align: center;">${suggestion}</td>
            </tr>
        `;
    });
    
    content += `
                    </tbody>
                </table>
            </div>
        </div>
    `;
    
    return content;
}

// 生成特殊事件情报内容
function generateSpecialEventsContent(data) {
    let content = `
        <div style="margin-bottom: 15px;">
            <h3 style="color: #FFD700; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">特殊市场事件</h3>
            <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">${data.event}</div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span>预期影响: <strong style="color: ${data.impact === '正面' ? '#4CAF50' : data.impact === '负面' ? '#f44336' : '#FFC107'}">${data.impact}</strong></span>
                    <span>可信度: <strong>${data.confidence}%</strong></span>
                </div>
                <div style="font-size: 0.9em; color: #aaa;">
                    ${generateEventDescription(data.event, data.impact)}
                </div>
            </div>
        </div>
    `;
    
    return content;
}

// 生成事件描述
function generateEventDescription(event, impact) {
    const descriptions = {
        "商会促销活动": "本地商会即将举办大型促销活动，预计将刺激消费者需求。",
        "货物运输延误": "主要贸易路线出现运输问题，可能导致商品短缺。",
        "市场需求激增": "近期市场需求异常增长，价格可能上涨。",
        "供应商提价": "主要供应商宣布提高批发价格，成本将增加。",
        "政府征税调整": "政府计划调整贸易税率，可能影响商品价格。",
        "天气影响收成": "不利天气条件影响农作物收成，供应可能减少。",
        "新贸易路线开通": "新贸易路线即将开通，可能带来新的商机。",
        "库存积压处理": "商家处理积压库存，可能提供折扣优惠。",
        "市场正常波动": "市场处于正常波动周期，无明显特殊事件。"
    };
    
    return descriptions[event] || "市场情报显示特殊事件可能影响贸易环境。";
}
function closeIntelligenceModal() {
    const modal = document.getElementById('intelligenceModal');
    const overlay = document.getElementById('intelligenceOverlay');
    
    if (modal) {
        modal.style.transform = 'scale(0.9)';
        modal.style.opacity = '0';
        setTimeout(() => {
            if (modal.parentNode) {
                modal.parentNode.removeChild(modal);
            }
        }, 300);
    }
    
    if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        }, 300);
    }
}

// 添加移除元素的辅助函数
function removeElement(elementId) {
    const element = document.getElementById(elementId);
    if (element && element.parentNode) {
        element.parentNode.removeChild(element);
    }
}


// 添加情报购买界面
function showIntelligencePurchaseOptions(city) {
    const modalId = 'intelligencePurchaseModal';
    const overlayId = 'intelligencePurchaseOverlay';
    
    // 移除已存在的模态框
    removeElement(modalId);
    removeElement(overlayId);
    
    // 创建覆盖层
    const overlay = document.createElement('div');
    overlay.id = overlayId;
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    // 创建模态框
    const modal = document.createElement('div');
    modal.id = modalId;
    modal.style.cssText = `
        background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
        border: 2px solid #FFD700;
        border-radius: 10px;
        padding: 20px;
        width: 80%;
        max-width: 500px;
        color: white;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    `;
    
    // 生成情报购买选项
    modal.innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
            <h2 style="color: #FFD700; margin: 0;">${city} - 情报购买</h2>
            <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                选择您需要的情报类型
            </div>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr; gap: 10px; margin-bottom: 20px;">
            ${generateIntelligenceOptions(city)}
        </div>
        
        <div style="text-align: center;">
            <button onclick="closeIntelligencePurchaseModal()" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                取消
            </button>
        </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // 添加动画效果
    setTimeout(() => {
        modal.style.transform = 'scale(1)';
        modal.style.opacity = '1';
    }, 10);
}

// 生成情报选项
function generateIntelligenceOptions(city) {
    const intelligenceTypes = tradingConfig.intelligence;
    let optionsHtml = '';
    
    Object.keys(intelligenceTypes).forEach(type => {
        const config = intelligenceTypes[type];
        const titles = {
            'marketPrices': '市场价格情报',
            'supplyDemand': '供需情况情报',
            'futureTrends': '未来趋势预测',
            'specialEvents': '特殊事件情报'
        };
        
        optionsHtml += `
            <div style="background: rgba(255,255,255,0.05); border-radius: 5px; padding: 15px; cursor: pointer; transition: all 0.3s ease; border-left: 4px solid #FFD700;" 
                 onclick="buyIntelligence('${city}', '${type}')">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-weight: bold; color: #FFD700;">${titles[type]}</div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">${config.description}</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 1.2em; font-weight: bold; color: #4CAF50;">${config.price.toLocaleString()}</div>
                        <div style="font-size: 0.8em; color: #aaa;">星币</div>
                    </div>
                </div>
                <div style="margin-top: 10px; font-size: 0.8em; color: #666;">
                    有效期: ${config.duration}分钟
                </div>
            </div>
        `;
    });
    
    return optionsHtml;
}

// 关闭情报购买模态框
function closeIntelligencePurchaseModal() {
    const modal = document.getElementById('intelligencePurchaseModal');
    const overlay = document.getElementById('intelligencePurchaseOverlay');
    
    if (modal) {
        modal.style.transform = 'scale(0.9)';
        modal.style.opacity = '0';
        setTimeout(() => {
            if (modal.parentNode) {
                modal.parentNode.removeChild(modal);
            }
        }, 300);
    }
    
    if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        }, 300);
    }
}

// 检查情报过期
function checkIntelligenceExpiry() {
    const now = Date.now();
    
    if (player.trading.intelligence.advanced && player.trading.intelligence.advancedExpire < now) {
        player.trading.intelligence.advanced = false;
        logAction("高级情报已过期", "info");
    }
    
    if (player.trading.intelligence.full && player.trading.intelligence.fullExpire < now) {
        player.trading.intelligence.full = false;
        logAction("全境情报已过期", "info");
    }
}

// 每日重置
function resetDailyTrading() {
    player.trading.tradeVolumeToday = 0; // 重置为0，而不是正数
    player.trading.tradeCountToday = 0;
    
    // 支付雇员工资
    let totalSalary = 0;
    player.trading.employees.forEach(employee => {
        totalSalary += employee.salary;
    });
    
    if (totalSalary > 0) {
        if (player.nightClub.starCoins >= totalSalary) {
            player.nightClub.starCoins -= totalSalary;
            // 工资支出也减少今日利润
            player.trading.tradeVolumeToday -= totalSalary;
            logAction(`支付雇员工资${totalSalary.toLocaleString()}星币`, "info");
        } else {
            // 资金不足，解雇所有雇员
            logAction("资金不足支付工资，所有雇员已被解雇", "warning");
            player.trading.employees = [];
        }
    }
    
    // 支付运输工具维护费
    const transport = tradingConfig.transports.find(t => t.name === player.trading.transport.type);
    if (transport && transport.maintenance > 0) {
        if (player.nightClub.starCoins >= transport.maintenance) {
            player.nightClub.starCoins -= transport.maintenance;
            // 维护费支出也减少今日利润
            player.trading.tradeVolumeToday -= transport.maintenance;
            logAction(`支付${transport.name}维护费${transport.maintenance.toLocaleString()}星币`, "info");
        } else {
            // 降级到免费运输工具
            logAction("资金不足支付维护费，运输工具降级为手推车", "warning");
            player.trading.transport = {
                type: '手推车',
                capacityBonus: 5,
                speedBonus: 0
            };
        }
    }
}

// 跑商系统主循环
function tradingSystemLoop() {
    // 每小时更新一次价格
    updateCityPrices();
    
    // 检查情报过期
    checkIntelligenceExpiry();
    
    // 检查旅行状态
    if (player.trading.isTraveling) {
        checkTravelStatus();
    }
    
    // 更新自动贸易（如果启用）
    if (player.trading.autoTrade.enabled) {
        runAutoTrade();
        
        // 更新界面显示（每秒更新一次进度）
        if (Date.now() % 1000 < 50) { // 大约每秒更新一次
            updateAutoTradeTab();
        }
    }
    
    
}

function startAutoTradeSystem() {
    if (player.trading.autoTrade.enabled && !window.autoTradeInterval) {
        window.autoTradeInterval = setInterval(() => {
            try {
                if (player.trading.autoTrade.enabled) {
                    // 定期验证数据
                    validateAutoTradeData();
                    
                    // 运行自动贸易
                    runAutoTrade();
                }
            } catch (error) {
                console.error("自动贸易系统错误:", error);
                // 发生错误时尝试恢复
                handleTradingError(error, "autoTradeSystem");
            }
        }, 1000); // 每秒执行一次
    }
}
function safeUpdateUI() {
    // 检查自动贸易界面是否可见
    if (isElementVisible('autoTab')) {
        updateAutoTradeTab();
    }
    
    // 检查世界地图界面是否可见
    if (isElementVisible('mapTab')) {
        updateMapTab();
    }
    
    // 检查市场界面是否可见
    if (isElementVisible('marketTab')) {
        updateMarketTab();
    }
}
// 停止自动贸易系统
function stopAutoTradeSystem() {
    if (window.autoTradeInterval) {
        clearInterval(window.autoTradeInterval);
        window.autoTradeInterval = null;
    }
}
function isElementVisible(elementId) {
    const element = document.getElementById(elementId);
    return element && element.offsetParent !== null;
}
function stopProgressUpdateTimer() {
    if (window.autoTradeProgressInterval) {
        clearInterval(window.autoTradeProgressInterval);
        window.autoTradeProgressInterval = null;
    }
}
// 初始化跑商系统
function initTradingSystem() {
    // 确保玩家数据存在
    if (!player.trading) {
        initTradingData();
    }
    
    // 启动主循环（每分钟检查一次）
    if (!window.tradingInterval) {
        window.tradingInterval = setInterval(tradingSystemLoop, 60000);
    }
}
window.addEventListener('error', function(event) {
    console.error("全局错误:", event.error);
    // 可以在这里添加错误报告或用户通知
});

// 添加页面卸载时的清理函数
window.addEventListener('beforeunload', function() {
    // 保存游戏状态
    saveGame();
    
    // 停止所有定时器
    stopProgressUpdateTimer();
    stopAutoTradeSystem();
    
    // 停止后台定时器
    if (player.trading.autoTrade.backgroundInterval) {
        clearInterval(player.trading.autoTrade.backgroundInterval);
        player.trading.autoTrade.backgroundInterval = null;
    }
});

// 修改页面可见性变化处理
document.addEventListener('visibilitychange', function() {
    const game = player.investmentGame;
    if (!game) return;
    
    if (document.hidden) {
        // 页面隐藏时停止定时器
        if (game.priceUpdateTimer) {
            clearInterval(game.priceUpdateTimer);
            game.priceUpdateTimer = null;
        }
        if (game.chartUpdateTimer) {
            clearInterval(game.chartUpdateTimer);
            game.chartUpdateTimer = null;
        }
    } else {
        // 页面显示时重新开始定时器
        if (document.getElementById('investmentGameUI').style.display === 'block') {
            startPriceSimulation();
        }
    }
});
function enterBackgroundMode() {
    if (!player.trading.autoTrade.enabled) return;
    
    try {
        player.trading.autoTrade.backgroundMode = true;
        player.trading.autoTrade.lastBackgroundUpdate = Date.now();
        
        // 停止前台定时器
        stopProgressUpdateTimer();
        
        // 启动后台定时器（频率较低，节省资源）
        if (!player.trading.autoTrade.backgroundInterval) {
            player.trading.autoTrade.backgroundInterval = setInterval(() => {
                try {
                    updateBackgroundTrade();
                } catch (error) {
                    console.error("后台贸易更新错误:", error);
                    // 发生错误时停止后台定时器
                    if (player.trading.autoTrade.backgroundInterval) {
                        clearInterval(player.trading.autoTrade.backgroundInterval);
                        player.trading.autoTrade.backgroundInterval = null;
                    }
                }
            }, 5000); // 每5秒更新一次
        }
        
        addAutoTradeLog("自动贸易已切换到后台模式", "info");
    } catch (error) {
        console.error("进入后台模式错误:", error);
    }
}

// 退出后台模式
function exitBackgroundMode() {
    if (!player.trading.autoTrade.enabled) return;
    
    try {
        player.trading.autoTrade.backgroundMode = false;
        
        // 停止后台定时器
        if (player.trading.autoTrade.backgroundInterval) {
            clearInterval(player.trading.autoTrade.backgroundInterval);
            player.trading.autoTrade.backgroundInterval = null;
        }
        
        // 启动前台定时器
        startProgressUpdateTimer();
        
        // 更新界面
        updateAutoTradeTab();
        
        addAutoTradeLog("自动贸易已切换到前台模式", "info");
    } catch (error) {
        console.error("退出后台模式错误:", error);
    }
}
function updateBackgroundTrade() {
    if (!player.trading.autoTrade.enabled || !player.trading.autoTrade.backgroundMode) return;
    
    const now = Date.now();
    const elapsed = now - player.trading.autoTrade.lastBackgroundUpdate;
    player.trading.autoTrade.lastBackgroundUpdate = now;
    
    // 模拟时间流逝，处理后台运行
    simulateBackgroundTrade(elapsed);
}

// 模拟后台贸易
function simulateBackgroundTrade(elapsed) {
    // 验证数据
    validateAutoTradeData();
    
    // 根据时间流逝模拟贸易活动
    const timeScale = elapsed / 1000; // 转换为秒
    
    switch (player.trading.autoTrade.currentState) {
        case 'traveling':
            // 模拟旅行进度
            player.trading.autoTrade.currentProgress += elapsed;
            
            // 检查是否到达目的地
            if (player.trading.autoTrade.currentProgress >= player.trading.autoTrade.totalTravelTime) {
                completeBackgroundTravel();
            }
            break;
            
        case 'buying':
            // 模拟采购（简化处理）
            if (Math.random() < 0.3 * timeScale) { // 30%概率每秒
                simulateBackgroundPurchase();
            }
            break;
            
        case 'selling':
            // 模拟销售（简化处理）
            if (Math.random() < 0.4 * timeScale) { // 40%概率每秒
                simulateBackgroundSale();
            }
            break;
            
        default:
            // 空闲状态，尝试开始新的贸易路线
            if (Math.random() < 0.1 * timeScale) { // 10%概率每秒
                startAutoTradeRoute();
            }
    }
    
    // 保存游戏状态（后台运行期间定期保存）
    if (Math.random() < 0.05) { // 5%概率每次更新时保存
        saveGame();
    }
}
function completeBackgroundTravel() {
    // 确保目标城市有效
    if (!player.trading.travelDestination || !tradingConfig.cities[player.trading.travelDestination]) {
        logAction("后台旅行：目标城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都';
        player.trading.travelDestination = '';
        player.trading.isTraveling = false;
        return;
    }
    
    const route = player.trading.autoTrade.currentRoute;
    if (!route) return;
    
    player.trading.currentCity = player.trading.travelDestination;
    player.trading.isTraveling = false;
    player.trading.travelDestination = '';
    player.trading.autoTrade.currentProgress = 0;
    
    // 根据目的地决定下一步行动
    if (player.trading.currentCity === route.buyCity) {
        player.trading.autoTrade.currentState = 'buying';
        addAutoTradeLog(`后台运行：已到达${route.buyCity}，开始采购`, "info");
    } else if (player.trading.currentCity === route.sellCity) {
        player.trading.autoTrade.currentState = 'selling';
        addAutoTradeLog(`后台运行：已到达${route.sellCity}，开始销售`, "info");
    }
    
    // 触发随机事件（简化版）
    if (Math.random() < 0.2) {
        triggerBackgroundRandomEvent();
    }
}
// 模拟后台采购
function simulateBackgroundPurchase() {
    const route = player.trading.autoTrade.currentRoute;
    if (!route || player.trading.autoTrade.currentState !== 'buying') return;
    
    const city = player.trading.currentCity;
    
    // 随机选择一个商品
    const availableGoods = getAvailableGoodsForPurchase(route);
    if (availableGoods.length === 0) {
        // 没有可购买的商品，开始旅行
        startAutoTravel(route.sellCity);
        return;
    }
    
    const randomGood = availableGoods[Math.floor(Math.random() * availableGoods.length)];
    const price = player.trading.cityPrices[city][randomGood];
    const quantity = Math.floor(Math.random() * 5) + 1; // 随机购买1-5个
    
    // 模拟购买
    if (player.nightClub.starCoins >= price * quantity) {
        buyGood(randomGood, quantity);
        addAutoTradeLog(`后台运行：购买了${quantity}个${randomGood}，花费${(price * quantity).toLocaleString()}星币`, "success");
        
        // 检查货仓使用率
        const totalCapacity = player.trading.warehouse.capacity + player.trading.transport.capacityBonus;
        const usageRate = player.trading.warehouse.used / totalCapacity;
        
        if (usageRate >= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage) {
            addAutoTradeLog("后台运行：货仓已满，开始前往销售城市", "info");
            startAutoTravel(route.sellCity);
        }
    }
}

// 模拟后台销售
function simulateBackgroundSale() {
    const route = player.trading.autoTrade.currentRoute;
    if (!route || player.trading.autoTrade.currentState !== 'selling') return;
    
    const city = player.trading.currentCity;
    
    // 检查库存
    const availableGoods = getAvailableGoodsForSale(route);
    if (availableGoods.length === 0) {
        // 没有库存可卖，返回采购城市
        startAutoTravel(route.buyCity);
        return;
    }
    
    const targetGood = availableGoods[0].good;
    const price = player.trading.cityPrices[city][targetGood];
    const quantity = Math.min(player.trading.inventory[targetGood].quantity, Math.floor(Math.random() * 3) + 1); // 随机销售1-3个
    
    // 模拟销售
    if (quantity > 0) {
        sellGood(targetGood, quantity);
        addAutoTradeLog(`后台运行：出售了${quantity}个${targetGood}，获得${(price * quantity).toLocaleString()}星币`, "success");
        
        // 检查是否还有库存
        if (Object.keys(player.trading.inventory).every(good => player.trading.inventory[good].quantity === 0)) {
            addAutoTradeLog("后台运行：库存已清空，返回采购城市", "info");
            startAutoTravel(route.buyCity);
        }
    }
}

// 触发后台随机事件
function triggerBackgroundRandomEvent() {
    const events = [
        {
            type: 'priceChange',
            message: "市场价格波动",
            effect: () => {
                // 随机调整一些商品价格
                Object.keys(tradingConfig.goods).forEach(good => {
                    if (Math.random() < 0.3) {
                        const change = (Math.random() - 0.5) * 0.2; // ±10%变化
                        player.trading.cityPrices[player.trading.currentCity][good] *= (1 + change);
                    }
                });
                addAutoTradeLog("后台运行：市场价格发生波动", "info");
            }
        },
        {
            type: 'specialOffer',
            message: "特价优惠",
            effect: () => {
                // 随机选择一个商品打折
                const goods = Object.keys(tradingConfig.goods);
                const randomGood = goods[Math.floor(Math.random() * goods.length)];
                const discount = 0.1 + Math.random() * 0.2; // 10%-30%折扣
                player.trading.cityPrices[player.trading.currentCity][randomGood] *= (1 - discount);
                
                addAutoTradeLog(`后台运行：${randomGood}特价优惠，降价${(discount * 100).toFixed(0)}%`, "success");
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    if (Math.random() < 0.1) { // 10%概率触发事件
        event.effect();
    }
}
function handleTradingError(error, context) {
    console.error(`自动贸易错误 (${context}):`, error);
    addAutoTradeLog(`自动贸易系统遇到问题: ${error.message}`, "error");
    
    // 尝试恢复系统
    try {
        recoverFromAutoTradeError();
        updateAutoTradeTab();
    } catch (recoveryError) {
        console.error("自动贸易恢复失败:", recoveryError);
        player.trading.autoTrade.enabled = false;
        addAutoTradeLog("自动贸易已停用，请重新设置路线", "error");
    }
}

// 在游戏加载时初始化
window.addEventListener('load', function() {
    // 延迟初始化，确保玩家数据已加载
    setTimeout(() => {
        initTradingData();
          initTradingConfig();
        // 验证自动贸易数据
        validateAutoTradeData();
        
        // 检查是否有后台运行的自动贸易
        if (player.trading.autoTrade.enabled) {
            // 自动贸易在运行，检查是否在后台模式
            if (document.hidden) {
                player.trading.autoTrade.backgroundMode = true;
            } else {
                player.trading.autoTrade.backgroundMode = false;
                startProgressUpdateTimer();
            }
            
            // 启动自动贸易系统
            startAutoTradeSystem();
        }
        
        updateAutoTradeTab();
    }, 1000);
});
function recoverFromAutoTradeError() {
    logAction("自动贸易系统遇到问题，正在尝试恢复", "warning");
    
    // 重置自动贸易状态
    player.trading.autoTrade.currentState = 'idle';
    player.trading.autoTrade.currentProgress = 0;
    
    // 验证并修复城市数据
    validateAutoTradeData();
    
    // 如果当前城市无效，设置为默认城市
    if (!validateCity(player.trading.currentCity)) {
        player.trading.currentCity = '王都';
    }
    
    // 清除无效的旅行目的地
    if (player.trading.travelDestination && !validateCity(player.trading.travelDestination)) {
        player.trading.travelDestination = '';
    }
    
    // 停止所有旅行
    player.trading.isTraveling = false;
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
        player.trading.travelInterval = null;
    }
    
    // 尝试重新开始自动贸易
    if (player.trading.autoTrade.enabled && player.trading.autoTrade.routes.length > 0) {
        player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0];
        startAutoTradeRoute();
    }
    
    logAction("自动贸易系统已恢复", "success");
}

// 符文属性配置
const runeAttributes = {
    types: ['critRate', 'health', 'critDamage','critRate', 'combo', 'attack', 'critRate', 'critDamage', 'combo', 'worldExp', 'combo'],
    ranges: {
        attack: { min: 0.01, max: 2.00 }, // 1% - 200%
        health: { min: 0.01, max: 2.00 },
        critDamage: { min: 0.01, max: 2.00 },
        combo: { min: 1, max: 10 }, // 1-10次连击
        critRate: { min: 0.01, max: 0.05 },
        worldExp: { min: 0.01, max: 0.20 } // 1% - 20%
    },
    names: {
        attack: '攻击加成',
        health: '生命加成',
        critDamage: '爆伤加成',
        combo: '连击次数',
        critRate: '暴击率',
        worldExp: '世界经验'
    }
};

// 材料名称映射
const materialNames = {
    gold: '金',
    wood: '木',
    water: '水',
    fire: '火',
    earth: '土',
    light: '光',
    dark: '暗',
    wind: '风',
    ice: '冰',
    electric: '电'
};

// 切换符文系统界面
function toggleRuneSystem() {
     if (player.level.ascentionCounta < 3) {
        alert("需要达到轮回3转才能开启符文系统！");
        return;
    }
    const overlay = document.getElementById('runeSystemOverlay');
    const ui = document.getElementById('runeSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateRuneSystemUI();
    }
}

// 更新符文系统界面
function updateRuneSystemUI() {
    // 更新材料数量显示
    Object.keys(player.runes.materials).forEach(material => {
        document.getElementById(`runeMaterial${material.charAt(0).toUpperCase() + material.slice(1)}`).textContent = 
            player.runes.materials[material];
    });
    
    // 更新材料选择界面
    updateMaterialSelection();
    
    // 更新已选材料显示
    updateSelectedMaterials();
    
    // 更新装备的符文显示
    updateEquippedRune();
    
    // 更新符文背包显示
    updateRuneInventory();
    
    // 更新符文升级信息
    updateRuneUpgradeInfo();
}

// 更新材料选择界面
function updateMaterialSelection() {
    const container = document.getElementById('runeMaterialSelection');
    container.innerHTML = '';
    
    // 材料掉落概率配置
    const materialDropRates = {
        gold: 0.50,
        wood: 0.25,
        water: 0.125,
        fire: 0.0625,
        earth: 0.03125,
        light: 0.015625,
        dark: 0.0078125,
        wind: 0.00390625,
        ice: 0.001953125,
        electric: 0.0009765625
    };
    
    Object.keys(player.runes.materials).forEach(material => {
        const count = player.runes.materials[material];
        const selectedCount = player.runes.selectedMaterials.filter(m => m === material).length;
        const remainingCount = count - selectedCount;
        const dropRate = materialDropRates[material] * 100; // 转换为百分比
        
        const button = document.createElement('button');
        button.innerHTML = `
            <div>${materialNames[material]}</div>
            <div>拥有: ${remainingCount}</div>
            <div style="font-size: 10px; color: #d8bfd8;">掉落率: ${dropRate.toFixed(4)}%</div>
        `;
        button.style.cssText = `
            padding: 5px;
            border: 1px solid #9370db;
            background: ${remainingCount > 0 ? 'rgba(147, 112, 219, 0.3)' : 'rgba(128, 128, 128, 0.3)'};
            color: ${remainingCount > 0 ? '#e6e6fa' : '#888'};
            border-radius: 3px;
            cursor: ${remainingCount > 0 ? 'pointer' : 'not-allowed'};
            width: 80px;
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        `;
        
        if (remainingCount > 0) {
            button.onclick = () => selectMaterial(material);
        }
        
        container.appendChild(button);
    });
}


// 选择材料
function selectMaterial(material) {
    if (player.runes.selectedMaterials.length >= 5) {
        logAction('最多只能选择5个材料！', 'error');
        return;
    }
    
    // 检查该材料是否还有剩余
    const selectedCount = player.runes.selectedMaterials.filter(m => m === material).length;
    const totalCount = player.runes.materials[material];
    
    if (selectedCount >= totalCount) {
        logAction(`${materialNames[material]}材料不足！`, 'error');
        return;
    }
    
    player.runes.selectedMaterials.push(material);
    updateSelectedMaterials();
    updateMaterialSelection();
}

// 更新已选材料显示
function updateSelectedMaterials() {
    const container = document.getElementById('selectedMaterials');
    
    if (player.runes.selectedMaterials.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center;">请选择5个材料</div>';
        return;
    }
    
    // 统计每种材料的数量
    const materialCounts = {};
    player.runes.selectedMaterials.forEach(material => {
        materialCounts[material] = (materialCounts[material] || 0) + 1;
    });
    
    container.innerHTML = Object.entries(materialCounts).map(([material, count]) => `
        <div style="display: inline-block; background: rgba(147, 112, 219, 0.5); padding: 5px 10px; margin: 2px; border-radius: 3px; border: 1px solid #9370db;">
            ${materialNames[material]} ×${count}
            <button onclick="removeMaterial('${material}')" style="background: none; border: none; color: #ff6b6b; cursor: pointer; margin-left: 5px;">×</button>
        </div>
    `).join('');
    addClearMaterialsButton();
    // 显示可能的属性预览（隐藏具体数值）
    if (player.runes.selectedMaterials.length === 5) {
        const preview = generateRunePreview(player.runes.selectedMaterials);
        container.innerHTML += `
            <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; border: 1px dashed #9370db;">
                <div style="color: #ffd700; font-weight: bold;">符文预览: ${preview.name}</div>
                ${preview.attributes.map(attr => `
                    <div style="font-size: 12px;">${attr.name}: ${attr.displayValue}</div>
                `).join('')}
                <div style="font-size: 10px; color: #d8bfd8; margin-top: 5px;">
                    合成后显示具体数值
                </div>
            </div>
        `;
    }
}

// 移除已选材料
function removeMaterial(material) {
    // 找到最后一个该材料的索引
    const lastIndex = player.runes.selectedMaterials.lastIndexOf(material);
    if (lastIndex !== -1) {
        player.runes.selectedMaterials.splice(lastIndex, 1);
        updateSelectedMaterials();
        updateMaterialSelection();
    }
}
// 生成符文预览（不实际创建符文）
function generateRunePreview(materials) {
    const seed = materials.sort().join('');
    const hash = stringHash(seed);
    const random = seededRandom(hash);
    
    // 确保属性类型数组不为空
    const attributeTypes = [...runeAttributes.types];
    if (attributeTypes.length === 0) {
        console.error("属性类型数组为空！");
        return { name: "未知符文", attributes: [] };
    }
    
    const selectedAttributes = [];
    
    // 确保总是生成5种属性类型
    for (let i = 0; i < 5; i++) {
        const index = Math.floor(random() * attributeTypes.length);
        // 确保索引在有效范围内
        const safeIndex = Math.max(0, Math.min(index, attributeTypes.length - 1));
        selectedAttributes.push(attributeTypes[safeIndex]);
    }
    
    const attributes = selectedAttributes.map(type => {
        return {
            type: type,
            name: runeAttributes.names[type],
            // 预览时不显示具体数值，只显示属性类型
            displayValue: '???'
        };
    });
    
    // 生成预览名称
    const previewName = generateRuneName(materials, hash);
    
    return {
        name: previewName,
        attributes: attributes
    };
}

// 合成符文
function synthesizeRune() {
    if (player.runes.selectedMaterials.length !== 5) {
        logAction('需要选择5个材料才能合成符文！', 'error');
        return;
    }
    
    // 验证材料组合
    if (!validateMaterialCombination(player.runes.selectedMaterials)) {
        logAction('无效的材料组合！', 'error');
        return;
    }
    
    // 检查材料是否足够（考虑重复材料）
    const materialCounts = {};
    player.runes.selectedMaterials.forEach(material => {
        materialCounts[material] = (materialCounts[material] || 0) + 1;
    });
    
    for (const [material, needed] of Object.entries(materialCounts)) {
        if (player.runes.materials[material] < needed) {
            logAction(`${materialNames[material]}材料不足！需要${needed}个，只有${player.runes.materials[material]}个`, 'error');
            return;
        }
    }
    
    // 消耗材料（考虑重复材料）
    for (const [material, needed] of Object.entries(materialCounts)) {
        player.runes.materials[material] -= needed;
    }
    
    // 生成符文
    const newRune = generateRune(player.runes.selectedMaterials);
    
    // 检查符文是否生成成功
    if (!newRune) {
        logAction('符文生成失败！', 'error');
        return;
    }
    
    player.runes.inventory.push(newRune);
    
    // 清空已选材料
    player.runes.selectedMaterials = [];
    
    logAction(`成功合成符文: ${newRune.name}`, 'success');
    updateRuneSystemUI();
    saveGame();
}
function generateRune(materials) {
    // 根据材料组合生成种子
    const seed = materials.sort().join('');
    const hash = stringHash(seed);
    
    // 使用种子生成确定性随机属性类型
    const random = seededRandom(hash);
    
    // 确保属性类型数组不为空
    const attributeTypes = [...runeAttributes.types];
    if (attributeTypes.length === 0) {
        console.error("属性类型数组为空！");
        return null;
    }
    
    const selectedAttributes = [];
    
    // 确保总是生成5种属性类型
    for (let i = 0; i < 5; i++) {
        const index = Math.floor(random() * attributeTypes.length);
        // 确保索引在有效范围内
        const safeIndex = Math.max(0, Math.min(index, attributeTypes.length - 1));
        selectedAttributes.push(attributeTypes[safeIndex]);
    }
    
    // 生成属性值（保持类型固定，数值有随机幅度）
    const attributes = selectedAttributes.map(type => {
        const range = runeAttributes.ranges[type];
        let value;
        
        if (type === 'combo') {
            // 连击次数为整数，确保在范围内
            value = Math.floor(range.min + Math.random() * (range.max - range.min + 1));
            value = Math.max(range.min, Math.min(range.max, value));
        } else {
            // 其他属性为百分比，确保在范围内
            value = range.min + Math.random() * (range.max - range.min);
            value = Math.max(range.min, Math.min(range.max, value));
            value = Math.round(value * 100) / 100; // 保留两位小数
        }
        
        return {
            type: type,
            value: value,
            displayValue: type === 'combo' ? `${value}次` : `${(value * 100).toFixed(1)}%`,
            name: runeAttributes.names[type]
        };
    });
    
    // 生成符文名称（基于材料组合）
    const runeName = generateRuneName(materials, hash);
    
    // 创建符文对象
    return {
        id: 'rune_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: runeName,
        materials: [...materials],
        attributes: attributes,
        level: player.runes.level,
        isLocked: false,
        createdAt: Date.now()
    };
}

// 生成符文名称
function generateRuneName(materials, hash) {
    // 神秘符文前缀
    const mysticalPrefixes = [
        '虚空', '混沌', '永恒', '不朽', '星辰', '命运', '时空', '创世', '灭世', '轮回',
        '天界', '冥界', '神域', '魔域', '圣光', '暗影', '元素', '本源', '真理', '法则',
        '秩序', '混沌', '起源', '终焉', '无限', '绝对', '至高', '无上', '至尊', '究极',
        '洪荒', '太古', '鸿蒙', '太初', '元始', '造化', '玄黄', '阴阳', '五行', '八卦',
        '天道', '地道', '人道', '神道', '魔道', '仙道', '佛道', '妖道', '鬼道', '圣道'
    ];
    
    // 神秘符文中缀
    const mysticalInfixes = [
        '吞噬', '湮灭', '创造', '毁灭', '平衡', '秩序', '混沌', '时间', '空间', '命运',
        '生命', '死亡', '光明', '黑暗', '火焰', '寒冰', '风暴', '大地', '雷霆', '海洋',
        '灵魂', '精神', '意志', '力量', '智慧', '勇气', '荣耀', '信仰', '希望', '绝望',
        '真理', '谎言', '现实', '虚幻', '过去', '未来', '现在', '因果', '轮回', '宿命',
        '天命', '劫难', '造化', '机缘', '气运', '功德', '业力', '报应', '涅槃', '超脱'
    ];
    
    // 神秘符文后缀
    const mysticalSuffixes = [
        '符文', '印记', '徽记', '圣印', '咒文', '法印', '图腾', '刻印', '符石', '神印',
        '宝珠', '晶石', '灵珠', '魂石', '魔印', '道符', '灵符', '神符', '天符', '地符',
        '龙符', '凤印', '麒麟印', '白虎符', '朱雀印', '玄武符', '青龙印', '白虎印',
        '之眼', '之心', '之魂', '之灵', '之源', '之核', '之种', '之泪', '之血', '之骨',
        '圣典', '秘典', '天书', '地书', '人书', '神书', '魔书', '仙书', '佛书', '妖书'
    ];
    
    // 使用哈希值选择前缀、中缀和后缀
    const prefixIndex = Math.abs(hash % mysticalPrefixes.length);
    const infixIndex = Math.abs((hash >> 8) % mysticalInfixes.length);
    const suffixIndex = Math.abs((hash >> 16) % mysticalSuffixes.length);
    
    // 根据重复材料的数量决定是否使用中缀
    const materialCounts = {};
    materials.forEach(material => {
        materialCounts[material] = (materialCounts[material] || 0) + 1;
    });
    
    const maxRepeat = Math.max(...Object.values(materialCounts));
    const useInfix = maxRepeat >= 3; // 如果有材料重复3次或以上，使用中缀
    
    if (useInfix) {
        return `${mysticalPrefixes[prefixIndex]}${mysticalInfixes[infixIndex]}${mysticalSuffixes[suffixIndex]}`;
    } else {
        return `${mysticalPrefixes[prefixIndex]}${mysticalSuffixes[suffixIndex]}`;
    }
}

// 字符串哈希函数
function stringHash(str) {
    let hash = 0;
    if (str.length === 0) return hash;
    
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // 转换为32位整数
    }
    
    // 确保哈希值不为0
    if (hash === 0) hash = 1;
    
    return hash;
}

// 种子随机数生成器
function seededRandom(seed) {
    // 确保种子不为0
    if (seed === 0) seed = 1;
    
    return function() {
        seed = (seed * 9301 + 49297) % 233280;
        // 确保返回值不为0
        return Math.max(0.0001, seed / 233280);
    };
}  
// 添加符文品质颜色系统
function getRuneQualityColor(rune) {
    // 根据符文等级和属性数量决定品质颜色
    const totalValue = rune.attributes.reduce((sum, attr) => {
        if (attr.type === 'combo') {
            return sum + attr.value * 10; // 连击次数价值较高
        } else {
            return sum + attr.value * 100; // 百分比属性价值
        }
    }, 0);
    
    const averageValue = totalValue / rune.attributes.length;
    
    if (averageValue > 80) {
        return '#ffd700'; // 传说品质（金色）
    } else if (averageValue > 60) {
        return '#9370db'; // 史诗品质（紫色）
    } else if (averageValue > 40) {
        return '#1e90ff'; // 稀有品质（蓝色）
    } else if (averageValue > 20) {
        return '#32cd32'; // 优秀品质（绿色）
    } else {
        return '#ffffff'; // 普通品质（白色）
    }
}
// 添加材料组合验证函数
function validateMaterialCombination(materials) {
    if (!materials || materials.length !== 5) {
        console.error("无效的材料组合：材料数量不正确");
        return false;
    }
    
    // 检查所有材料是否有效
    for (const material of materials) {
        if (!player.runes.materials.hasOwnProperty(material)) {
            console.error("无效的材料：", material);
            return false;
        }
    }
    
    return true;
}
// 更新装备的符文显示
function updateEquippedRune() {
    const container = document.getElementById('equippedRune');
    
    if (!player.runes.equipped) {
        container.innerHTML = '<div style="color: #888; text-align: center;">未装备符文</div>';
        return;
    }
    
    const rune = player.runes.equipped;
    const runeBonuses = calculateRuneBonuses();
    const qualityColor = getRuneQualityColor(rune);
    
    // 统计属性重复次数
    const attributeCounts = {};
    rune.attributes.forEach(attr => {
        attributeCounts[attr.type] = (attributeCounts[attr.type] || 0) + 1;
    });
    
    container.innerHTML = `
        <div style="font-size: 18px; font-weight: bold; color: ${qualityColor}; margin-bottom: 10px; text-shadow: 0 0 5px ${qualityColor};">${rune.name}</div>
        <div style="margin-bottom: 10px; max-height: 120px; overflow-y: auto;">
            ${rune.attributes.map((attr, index) => {
                const count = attributeCounts[attr.type];
                const countText = count > 1 ? ` (x${count})` : '';
                return `<div>${attr.name}: ${attr.displayValue}${countText}</div>`;
            }).join('')}
        </div>
        <div style="font-size: 12px; color: #d8bfd8; margin-bottom: 5px;">
            等级: ${rune.level} (${(rune.level * 100).toFixed(0)}%加成)
        </div>
        <div style="font-size: 11px; color: #90ee90; margin-bottom: 10px;">
            当前总加成:<br>
            ${runeBonuses.attack > 0 ? `攻击: +${(runeBonuses.attack * 100).toFixed(1)}%<br>` : ''}
            ${runeBonuses.health > 0 ? `生命: +${(runeBonuses.health * 100).toFixed(1)}%<br>` : ''}
            ${runeBonuses.critRate > 0 ? `暴击率: +${(runeBonuses.critRate * 100).toFixed(2)}%<br>` : ''}
            ${runeBonuses.critDamage > 0 ? `爆伤: +${(runeBonuses.critDamage * 100).toFixed(1)}%<br>` : ''}
            ${runeBonuses.combo > 0 ? `连击: +${runeBonuses.combo.toFixed(0)}次<br>` : ''}
            ${runeBonuses.worldExp > 0 ? `世界经验: +${(runeBonuses.worldExp * 100).toFixed(1)}%<br>` : ''}
        </div>
        <button onclick="unequipRune()" style="background: linear-gradient(to bottom, #dc143c, #8b0000); color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-top: 5px;">卸下</button>
    `;
}
function showRuneSynthesisHelp() {
    showCustomConfirm(`
        <div style="text-align: left;">
            <h3 style="color: #ffd700;">符文合成说明</h3>
            <p><strong>材料选择:</strong> 选择5个材料（可以重复使用同一种材料）</p>
            <p><strong>重复材料:</strong> 使用重复材料会影响符文属性和名称</p>
            <ul>
                <li>重复材料会增加符文分解价值</li>
                <li>重复3次以上的材料会生成更复杂的符文名称</li>
                <li>重复材料组合会生成独特的符文属性</li>
            </ul>
            <p><strong>属性生成:</strong> 每个符文有5条属性，可能重复</p>
            <p><strong>符文命名:</strong> 使用神秘词汇组合，不包含材料名称</p>
            <p><strong>属性范围:</strong></p>
            <ul>
                <li>攻击/生命/爆伤/暴击率: 1% - 100%</li>
                <li>连击次数: 1-10次</li>
                <li>世界经验: 1% - 10%</li>
            </ul>
            <p><strong>符文升级:</strong> 使用秘法符文升级，每级提升100%属性</p>
            <p><strong>重复属性:</strong> 相同属性会叠加，分解时价值更高</p>
            <p><strong>预览隐藏:</strong> 合成前只显示属性类型，不显示具体数值</p>
        </div>
    `, () => {});
}
function addClearMaterialsButton() {
    const container = document.getElementById('selectedMaterials');
    if (player.runes.selectedMaterials.length > 0) {
        container.innerHTML += `
            <div style="margin-top: 10px;">
                <button onclick="clearSelectedMaterials()" style="background: #dc143c; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">清空已选材料</button>
            </div>
        `;
    }
}

// 清空已选材料函数
function clearSelectedMaterials() {
    player.runes.selectedMaterials = [];
    updateSelectedMaterials();
    updateMaterialSelection();
}

// 更新符文背包显示
function updateRuneInventory() {
    const container = document.getElementById('runeInventory');
    container.innerHTML = '';
    
    let filteredRunes = player.runes.inventory;
    
    // 应用过滤器
    if (player.runes.currentFilter !== 'all') {
        filteredRunes = filteredRunes.filter(rune => {
            return rune.attributes.some(attr => attr.type === player.runes.currentFilter);
        });
    }
    
    if (filteredRunes.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; grid-column: 1 / -1;">符文背包为空</div>';
        return;
    }
    
    filteredRunes.forEach(rune => {
        const runeElement = document.createElement('div');
        runeElement.style.cssText = `
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
            border: 2px solid ${rune.isLocked ? '#ffd700' : '#9370db'};
            position: relative;
            box-shadow: 0 0 10px ${rune.isLocked ? '#ffd700' : '#9370db'};
        `;
        
        // 统计属性重复次数
        const attributeCounts = {};
        rune.attributes.forEach(attr => {
            attributeCounts[attr.type] = (attributeCounts[attr.type] || 0) + 1;
        });
        
        runeElement.innerHTML = `
            <div style="font-weight: bold; color: ${rune.isLocked ? '#ffd700' : '#e6e6fa'}; margin-bottom: 5px; text-shadow: 0 0 5px ${rune.isLocked ? '#ffd700' : '#9370db'};">${rune.name}</div>
            <div style="font-size: 12px; margin-bottom: 5px; max-height: 100px; overflow-y: auto;">
                ${rune.attributes.map((attr, index) => {
                    const count = attributeCounts[attr.type];
                    const countText = count > 1 ? ` (x${count})` : '';
                    return `<div>${attr.name}: ${attr.displayValue}${countText}</div>`;
                }).join('')}
            </div>
            <div style="font-size: 11px; color: #d8bfd8;">
                等级: ${rune.level} (${(rune.level * 100).toFixed(0)}%加成)
            </div>
            <div style="margin-top: 10px; display: flex; justify-content: space-between;">
                <button onclick="equipRune('${rune.id}')" style="background: #9370db; color: white; border: none; padding: 3px 8px; border-radius: 2px; cursor: pointer; font-size: 11px;">装备</button>
                <button onclick="toggleLockRune('${rune.id}')" style="background: ${rune.isLocked ? '#ffd700' : '#6a5acd'}; color: white; border: none; padding: 3px 8px; border-radius: 2px; cursor: pointer; font-size: 11px;">
                    ${rune.isLocked ? '解锁' : '锁定'}
                </button>
                <button onclick="decomposeRune('${rune.id}')" style="background: #dc143c; color: white; border: none; padding: 3px 8px; border-radius: 2px; cursor: pointer; font-size: 11px;">分解</button>
            </div>
        `;
        
        container.appendChild(runeElement);
    });
}

// 装备符文
function equipRune(runeId) {
    const runeIndex = player.runes.inventory.findIndex(r => r.id === runeId);
    if (runeIndex === -1) return;
    
    player.runes.equipped = player.runes.inventory[runeIndex];
    logAction(`装备了符文: ${player.runes.equipped.name}`, 'success');
    updatePlayerBattleStats();
    updateRuneSystemUI();
    saveGame();
}

// 卸下符文
function unequipRune() {
    if (!player.runes.equipped) return;
    
    logAction(`卸下了符文: ${player.runes.equipped.name}`, 'info');
    player.runes.equipped = null;
    updatePlayerBattleStats();
    updateRuneSystemUI();
    saveGame();
}

// 切换符文锁定状态
function toggleLockRune(runeId) {
    const runeIndex = player.runes.inventory.findIndex(r => r.id === runeId);
    if (runeIndex === -1) return;
    
    player.runes.inventory[runeIndex].isLocked = !player.runes.inventory[runeIndex].isLocked;
    logAction(`${player.runes.inventory[runeIndex].isLocked ? '锁定' : '解锁'}了符文: ${player.runes.inventory[runeIndex].name}`, 'info');
    updateRuneSystemUI();
    saveGame();
}

// 分解符文
function decomposeRune(runeId) {
    const runeIndex = player.runes.inventory.findIndex(r => r.id === runeId);
    if (runeIndex === -1) return;
    
    const rune = player.runes.inventory[runeIndex];
    
    if (rune.isLocked) {
        logAction('无法分解已锁定的符文！', 'error');
        return;
    }
    
    // 计算分解奖励（星币）
    const starCoins = calculateRuneDecomposeValue(rune);
    player.nightClub.starCoins += starCoins;
    
    // 从背包中移除
    player.runes.inventory.splice(runeIndex, 1);
    
    logAction(`分解了符文: ${rune.name}，获得${starCoins}星币`, 'success');
    updateRuneSystemUI();
    updateDisplay();
    saveGame();
}

// 计算符文分解价值
function calculateRuneDecomposeValue(rune) {
    // 基础价值 + 属性价值 + 等级价值 + 重复材料奖励
    let value = 1; // 基础价值
    
    // 统计材料重复次数
    const materialCounts = {};
    rune.materials.forEach(material => {
        materialCounts[material] = (materialCounts[material] || 0) + 1;
    });
    
    // 材料重复奖励
    const maxRepeat = Math.max(...Object.values(materialCounts));
    if (maxRepeat > 1) {
        value *= Math.pow(1.2, maxRepeat - 1); // 每重复一次增加20%基础价值
    }
    
    // 统计属性重复次数
    const attributeCounts = {};
    rune.attributes.forEach(attr => {
        attributeCounts[attr.type] = (attributeCounts[attr.type] || 0) + 1;
    });
    
    // 属性价值
    rune.attributes.forEach(attr => {
        let attrValue;
        
        if (attr.type === 'combo') {
            attrValue = attr.value * 5; // 每次连击价值5星币
        } else {
            attrValue = attr.value * 1; // 每1%属性价值1星币
        }
        
        // 重复属性奖励
        const count = attributeCounts[attr.type];
        if (count > 1) {
            attrValue *= Math.pow(1.5, count - 1); // 每重复一次增加50%价值
        }
        
        value += attrValue;
    });
    
    // 等级价值
    value *= rune.level;
    
    return Math.floor(value);
}


// 一键分解所有未锁定的符文
function decomposeAllRunes() {
    const unlockedRunes = player.runes.inventory.filter(rune => !rune.isLocked);
    
    if (unlockedRunes.length === 0) {
        logAction('没有可分解的符文！', 'error');
        return;
    }
    
    showCustomConfirm(`确定要分解所有未锁定的符文吗？共${unlockedRunes.length}个，将获得大量星币！`, (confirmed) => {
        if (confirmed) {
            let totalStarCoins = 0;
            
            // 分解所有未锁定的符文
            player.runes.inventory = player.runes.inventory.filter(rune => {
                if (rune.isLocked) {
                    return true; // 保留锁定的符文
                }
                
                totalStarCoins += calculateRuneDecomposeValue(rune);
                return false; // 移除未锁定的符文
            });
            
            player.nightClub.starCoins += totalStarCoins;
            
            logAction(`一键分解了${unlockedRunes.length}个符文，获得${totalStarCoins}星币`, 'success');
            updateRuneSystemUI();
            updateDisplay();
            saveGame();
        }
    });
}

// 切换符文过滤器
function toggleRuneFilter() {
    const filterBtn = document.getElementById('runeFilterBtn');
    const filters = ['all', 'attack', 'health', 'critDamage', 'combo', 'critRate', 'worldExp'];
    const filterNames = {
        all: '显示全部',
        attack: '攻击加成',
        health: '生命加成',
        critDamage: '爆伤加成',
        combo: '连击次数',
        critRate: '暴击率',
        worldExp: '世界经验'
    };
    
    const currentIndex = filters.indexOf(player.runes.currentFilter);
    const nextIndex = (currentIndex + 1) % filters.length;
    player.runes.currentFilter = filters[nextIndex];
    
    filterBtn.textContent = filterNames[player.runes.currentFilter];
    updateRuneInventory();
}

// 更新符文升级信息
function updateRuneUpgradeInfo() {
    document.getElementById('runeLevel').textContent = player.runes.level;
    document.getElementById('runeUpgradeCost').textContent = player.runes.upgradeCost;
    
    // 检查是否有足够的秘法符文
    const upgradeBtn = document.getElementById('upgradeRuneBtn');
    if (player.items.fuwen1 >= player.runes.upgradeCost) {
        upgradeBtn.disabled = false;
        upgradeBtn.style.opacity = '1';
    } else {
        upgradeBtn.disabled = true;
        upgradeBtn.style.opacity = '0.5';
    }
}

// 升级符文
function upgradeRune() {
    if (player.items.fuwen1 < player.runes.upgradeCost) {
        logAction('秘法符文不足！', 'error');
        return;
    }
    
    player.items.fuwen1 -= player.runes.upgradeCost;
    player.runes.level++;
    player.runes.upgradeCost += 10;
    
    // 更新所有符文的等级
    player.runes.inventory.forEach(rune => {
        rune.level = player.runes.level;
    });
    
    if (player.runes.equipped) {
        player.runes.equipped.level = player.runes.level;
    }
    
    logAction(`符文等级提升至 ${player.runes.level}级，所有符文属性提升100%！`, 'success');
     updatePlayerBattleStats();
    updateRuneSystemUI();
    updateDisplay();
    saveGame();
}

// 在次元4以上掉落材料
function dropRuneMaterials() {
    if (player.dimensionLevel < 4) return;
    
    // 只有1%的几率触发材料掉落
    if (Math.random() >= 0.01) return;
    
    // 材料掉落概率配置（从50%到0.01%）
    const materialDropRates = {
        gold: 0.50,      // 50%
        wood: 0.25,      // 25%
        water: 0.125,    // 12.5%
        fire: 0.0625,    // 6.25%
        earth: 0.03125,  // 3.125%
        light: 0.015625, // 1.5625%
        dark: 0.0078125, // 0.78125%
        wind: 0.00390625, // 0.390625%
        ice: 0.001953125, // 0.1953125%
        electric: 0.0009765625 // 0.09765625% (约0.1%)
    };
    
    // 计算总概率（用于归一化）
    const totalRate = Object.values(materialDropRates).reduce((sum, rate) => sum + rate, 0);
    
    // 生成随机数决定掉落哪个材料
    const rand = Math.random() * totalRate;
    let cumulativeRate = 0;
    let droppedMaterial = null;
    
    // 选择掉落的材料
    for (const [material, rate] of Object.entries(materialDropRates)) {
        cumulativeRate += rate;
        if (rand <= cumulativeRate) {
            droppedMaterial = material;
            break;
        }
    }
    
    // 增加材料数量
    if (droppedMaterial) {
        player.runes.materials[droppedMaterial]++;
        
        // 记录掉落日志
        logAction(`获得了符文材料: ${materialNames[droppedMaterial]}`, 'success');
        
        // 更新界面显示
        updateRuneSystemUI();
    }
}
function calculateRuneBonuses() {
    const bonuses = {
        attack: 0,
        health: 0,
        critDamage: 0,
        combo: 0,
        critRate: 0,
        worldExp: 0
    };
    
    if (player.runes.equipped) {
        const rune = player.runes.equipped;
        const levelMultiplier = rune.level; // 等级加成倍数
        
        rune.attributes.forEach(attr => {
            // 应用等级加成
            const baseValue = Math.max(0, attr.value);
            const finalValue = baseValue * levelMultiplier;
            
            switch(attr.type) {
                case 'attack':
                    bonuses.attack += finalValue;
                    break;
                case 'health':
                    bonuses.health += finalValue;
                    break;
                case 'critDamage':
                    bonuses.critDamage += finalValue;
                    break;
                case 'combo':
                    bonuses.combo +=  Math.floor(finalValue);
                    break;
                case 'critRate':
                    bonuses.critRate += finalValue;
                    break;
                case 'worldExp':
                    bonuses.worldExp += finalValue;
                    break;
            }
        });
    }
    
    return bonuses;
}
// 职业配置
const classConfig = {
    warrior: {
        name: "战士",
        branches: [
            {
                requiredStage: 20,
                options: [
                    {desc: "玩家攻击加成总和提升2倍", type: "attackMultiplier", value: 2},
                    {desc: "玩家爆伤总和提升2倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 2}},
                    {desc: "玩家生命加成总和提升1.1倍", type: "healthMultiplier", value: 1.1}
                ]
            },
            {
                requiredStage: 200,
                options: [
                    {desc: "玩家攻击加成总和提升5倍", type: "attackMultiplier", value: 5},
                    {desc: "玩家爆伤总和提升5倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 5}},
                    {desc: "玩家生命加成总和提升1.5倍", type: "healthMultiplier", value: 1.5}
                ]
            },
            {
                requiredStage: 500,
                options: [
                    {desc: "玩家攻击加成总和提升10倍", type: "attackMultiplier", value: 10},
                    {desc: "玩家爆伤总和提升10倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 10}},
                    {desc: "玩家生命加成总和提升3倍", type: "healthMultiplier", value: 3}
                ]
            },
            {
                requiredStage: 1000,
                options: [
                    {desc: "玩家攻击加成总和提升20倍", type: "attackMultiplier", value: 20},
                    {desc: "玩家爆伤总和提升20倍伤害", type: "critMultiplier", value: {chance: 0.01, multiplier: 20}},
                    {desc: "玩家生命加成总和提升5倍", type: "healthMultiplier", value: 5}
                ]
            },
            {
                requiredStage: 1500,
                options: [
                    {desc: "玩家攻击加成总和提升30倍", type: "attackMultiplier", value: 30},
                    {desc: "玩家爆伤总和提升40倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 40}},
                    {desc: "玩家生命加成总和提升7倍", type: "healthMultiplier", value: 7}
                ]
            },
            {
                requiredStage: 2000,
                options: [
                    {desc: "玩家攻击加成总和提升80倍", type: "attackMultiplier", value: 80},
                    {desc: "玩家爆伤总和提升100倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 100}},
                    {desc: "玩家生命加成总和提升10倍", type: "healthMultiplier", value: 10}
                ]
            },
            {
                requiredStage: 2500,
                options: [
                    {desc: "玩家攻击加成总和提升150倍", type: "attackMultiplier", value: 150},
                    {desc: "玩家爆伤总和提升180倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 180}},
                    {desc: "玩家生命加成总和提升14倍", type: "healthMultiplier", value: 13}
               ]
            },
            {
                requiredStage: 3000,
                options: [
                    {desc: "玩家攻击加成总和提升300倍", type: "attackMultiplier", value: 300},
                    {desc: "玩家爆伤总和提升330倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 330}},
                    {desc: "玩家生命加成总和提升18倍", type: "healthMultiplier", value: 18}
               ]
            },
            {
                requiredStage: 3500,
                options: [
                    {desc: "玩家攻击加成总和提升600倍", type: "attackMultiplier", value: 600},
                    {desc: "玩家爆伤总和提升620倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 620}},
                    {desc: "玩家生命加成总和提升25倍", type: "healthMultiplier", value: 25}
             ]
            },
            {
                requiredStage: 4000,
                options: [
                    {desc: "玩家攻击加成总和提升1200倍", type: "attackMultiplier", value: 1200},
                    {desc: "玩家爆伤总和提升1300倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 1300}},
                    {desc: "玩家生命加成总和提升30倍", type: "healthMultiplier", value: 30}
               ]
            },
            {
                requiredStage: 4500,
                options: [
                    {desc: "玩家攻击加成总和提升2200倍", type: "attackMultiplier", value: 2200},
                    {desc: "玩家爆伤总和提升2500倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 2500}},
                    {desc: "玩家生命加成总和提升35倍", type: "healthMultiplier", value: 35}
                ]
            }
        ],
        // 二转职业配置
        secondJobs: {
            berserker: {
                name: "狂战士",
                requiredTower: 150000,
                bonus: { attackMultiplier: 10 }
            },
            swordSoul: {
                name: "剑魂", 
                requiredTower: 150000,
                bonus: { critMultiplier: 10 }
            },
            asura: {
                name: "阿修罗",
                requiredTower: 150000, 
                bonus: { healthMultiplier: 5 }
            }
        },
        // 三转职业配置
        thirdJobs: {
            bloodGod: {
                name: "狱血魔神",
                requiredTower: 300000,
                baseJob: "berserker",
                bonus: { attackMultiplier: 100 }
            },
            swordSaint: {
                name: "剑圣",
                requiredTower: 300000,
                baseJob: "swordSoul", 
                bonus: { critMultiplier: 100 }
            },
            darkLord: {
                name: "大暗黑天",
                requiredTower: 300000,
                baseJob: "asura",
                bonus: { healthMultiplier: 25 }
            }
        },
        // 四转职业配置
        fourthJobs: {
            bloodEmperor: {
                name: "帝血弑天",
                requiredTower: 400000,
                baseJob: "bloodGod",
                bonus: { attackMultiplier: 1000 }
            },
            swordGod: {
                name: "剑神",
                requiredTower: 400000,
                baseJob: "swordSaint",
                bonus: { critMultiplier: 1000 }
            },
            heavenlyEmperor: {
                name: "天帝",
                requiredTower: 400000,
                baseJob: "darkLord",
                bonus: { healthMultiplier: 50 }
            }
        }
    },
    mage: {
        name: "法师",
        branches: [
            {
                requiredStage: 20,
                options: [
                    {desc: "玩家生命加成总和提升1.1倍", type: "healthMultiplier", value: 1.1},
                    {desc: "副本装备加成总和提升1.2倍", type: "dungeonEquipMultiplier", value: 1.2},
                    {desc: "魂环加成总和提升1.5倍", type: "soulRingMultiplier", value: 1.5}
                ]
            },
            {
                requiredStage: 200,
                options: [
                    {desc: "玩家生命加成总和提升1.3倍", type: "healthMultiplier", value: 1.3},
                    {desc: "副本装备加成总和提升1.8倍", type: "dungeonEquipMultiplier", value: 1.8},
                    {desc: "魂环加成总和提升2倍", type: "soulRingMultiplier", value: 2}
                ]
            },
            {
                requiredStage: 500,
                options: [
                    {desc: "玩家生命加成总和提升2.5倍", type: "healthMultiplier", value: 2.5},
                    {desc: "副本装备加成总和提升3倍", type: "dungeonEquipMultiplier", value: 3},
                    {desc: "魂环加成总和提升4倍", type: "soulRingMultiplier", value: 4}
                ]
            },
            {
                requiredStage: 1000,
                options: [
                    {desc: "玩家生命加成总和提升4倍", type: "healthMultiplier", value: 4},
                    {desc: "副本装备加成总和提升4倍", type: "dungeonEquipMultiplier", value: 4},
                    {desc: "魂环加成总和提升5倍", type: "soulRingMultiplier", value: 5}
                ]
            },
            {
                requiredStage: 1500,
                options: [
                    {desc: "玩家生命加成总和提升5倍", type: "healthMultiplier", value: 5},
                    {desc: "副本装备加成总和提升8倍", type: "dungeonEquipMultiplier", value: 8},
                    {desc: "魂环加成总和提升10倍", type: "soulRingMultiplier", value: 10}
                ]
            },
            {
                requiredStage: 2000,
                options: [
                    {desc: "玩家生命加成总和提升9倍", type: "healthMultiplier", value: 9},
                    {desc: "副本装备加成总和提升15倍", type: "dungeonEquipMultiplier", value: 15},
                    {desc: "魂环加成总和提升20倍", type: "soulRingMultiplier", value: 20}
                ]
            },
            {
                requiredStage: 2500,
                options: [
                    {desc: "玩家生命加成总和提升12倍", type: "healthMultiplier", value: 12},
                    {desc: "副本装备加成总和提升20倍", type: "dungeonEquipMultiplier", value: 20},
                    {desc: "魂环加成总和提升30倍", type: "soulRingMultiplier", value: 30}
                ]
            },
            {
                requiredStage: 3000,
                options: [
                    {desc: "玩家生命加成总和提升15倍", type: "healthMultiplier", value: 15},
                    {desc: "副本装备加成总和提升30倍", type: "dungeonEquipMultiplier", value: 30},
                    {desc: "魂环加成总和提升50倍", type: "soulRingMultiplier", value: 50}
                ]
            },
            {
                requiredStage: 3500,
                options: [
                    {desc: "玩家生命加成总和提升18倍", type: "healthMultiplier", value: 18},
                    {desc: "副本装备加成总和提升50倍", type: "dungeonEquipMultiplier", value: 50},
                    {desc: "魂环加成总和提升60倍", type: "soulRingMultiplier", value: 60}
                ]
            },
            {
                requiredStage: 4000,
                options: [
                    {desc: "玩家生命加成总和提升20倍", type: "healthMultiplier", value: 20},
                    {desc: "副本装备加成总和提升70倍", type: "dungeonEquipMultiplier", value: 70},
                    {desc: "魂环加成总和提升80倍", type: "soulRingMultiplier", value: 80}
                ]
            },
            {
                requiredStage: 4500,
                options: [
                    {desc: "玩家生命加成总和提升25倍", type: "healthMultiplier", value: 25},
                    {desc: "副本装备加成总和提升80倍", type: "dungeonEquipMultiplier", value: 80},
                    {desc: "魂环加成总和提升100倍", type: "soulRingMultiplier", value: 100}
                ]
            }
        ],
        // 二转职业配置
        secondJobs: {
            elementalist: {
                name: "元素师",
                requiredTower: 100000,
                bonus: { dungeonEquipMultiplier: 3 }
            },
            magicScholar: {
                name: "魔道学者",
                requiredTower: 100000,
                bonus: { soulRingMultiplier: 5 }
            },
            battleMage: {
                name: "战斗法师",
                requiredTower: 100000,
                bonus: { healthMultiplier: 4 }
            }
        },
        // 三转职业配置
        thirdJobs: {
            archmage: {
                name: "大魔导师",
                requiredTower: 200000,
                baseJob: "elementalist",
                bonus: { dungeonEquipMultiplier: 10 }
            },
            magician: {
                name: "魔术师",
                requiredTower: 200000,
                baseJob: "magicScholar",
                bonus: { soulRingMultiplier: 15 }
            },
            battleGoddess: {
                name: "贝亚娜斗神",
                requiredTower: 200000,
                baseJob: "battleMage",
                bonus: { healthMultiplier: 15 }
            }
        },
        // 四转职业配置
        fourthJobs: {
            darkGod: {
                name: "黑暗之神",
                requiredTower: 300000,
                baseJob: "archmage",
                bonus: { dungeonEquipMultiplier: 50 }
            },
            magicSovereign: {
                name: "魔道至尊",
                requiredTower: 300000,
                baseJob: "magician",
                bonus: { soulRingMultiplier: 50 }
            },
            lightGod: {
                name: "光明之神",
                requiredTower: 300000,
                baseJob: "battleGoddess",
                bonus: { healthMultiplier: 30 }
            }
        }
    }
};

// 切换职业系统界面显示
function toggleClassSystem() {
 if (player.reincarnationCount < 20) {
        alert("需要达到20转才能开启职业系统！");
        return;
    }
    const ui = document.getElementById('classSystemUI');
    const overlay = document.getElementById('classSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateClassSystemDisplay();
    }
}

// 选择职业
function selectClass(classType) {
    // 检查是否需要消耗职业转换书
    if (player.class && player.class !== classType) {
        if (player.items.zhiye1 < 1) {
            alert("职业转换书不足，更换职业需要1本职业转换书！");
            return;
        }
        
        player.items.zhiye1 -= 1;
        
        // 重置所有转职状态
        player.classBranches = [];
        player.classSecond = null;
        player.classThird = null;
        player.classFourth = null;
        
        logAction(`消耗1职业转换书，更换职业为${classConfig[classType].name}，所有转职状态已重置`, 'success');
    }
    
    // 设置职业
    player.class = classType;
    
    // 更新显示
    updateClassSystemDisplay();
    updatePlayerClassNameDisplay();
    updateDisplay(); // 更新整体显示
}

// 更新职业系统界面显示
function updateClassSystemDisplay() {
    const className = player.class ? classConfig[player.class].name : "无";
    let fullClassName = className;
    
    // 构建完整的职业名称
    if (player.classFourth) {
        fullClassName += `·${classConfig[player.class].fourthJobs[player.classFourth].name}`;
    } else if (player.classThird) {
        fullClassName += `·${classConfig[player.class].thirdJobs[player.classThird].name}`;
    } else if (player.classSecond) {
        fullClassName += `·${classConfig[player.class].secondJobs[player.classSecond].name}`;
    }
    
    document.getElementById('currentClassName').textContent = fullClassName;
    
    const branchesContainer = document.getElementById('classBranches');
    const branchPointsContainer = document.getElementById('branchPointsContainer');
    
    if (player.class) {
        branchesContainer.style.display = 'block';
        branchPointsContainer.innerHTML = '';
        
        // 显示一转分支（原有逻辑）
        const branches = classConfig[player.class].branches;
        branches.forEach((branch, index) => {
            const isUnlocked = player.battle.maxStage >= branch.requiredStage;
            const selectedOption = player.classBranches[index] !== undefined ? player.classBranches[index] : -1;
            
            let branchHtml = `<div style="margin: 15px 0; padding: 10px; border: 1px solid #ccc;">`;
            branchHtml += `<div>第${index + 1}排 (需要最高关卡: ${branch.requiredStage})</div>`;
            
            if (!isUnlocked) {
                branchHtml += `<div style="color: #999;">未解锁，需要达到${branch.requiredStage}关</div>`;
            } else {
                branch.options.forEach((option, optIndex) => {
                    const isSelected = selectedOption === optIndex;
                    branchHtml += `
                        <div style="margin: 5px 0; padding: 5px; ${isSelected ? 'background: #ccf;' : ''}">
                            <button onclick="selectBranch(${index}, ${optIndex})" 
                                style="${isSelected ? 'background: #00f; color: white;' : ''}">
                                ${isSelected ? '✓ ' : ''}选择
                            </button>
                            ${option.desc}
                        </div>
                    `;
                });
            }
            
            branchHtml += `</div>`;
            branchPointsContainer.innerHTML += branchHtml;
        });
        
        // 新增：显示二转职业选择
        if (player.tower.currentFloor >= 100000 && !player.classSecond) {
            let secondJobHtml = `<div style="margin: 20px 0; padding: 15px; border: 2px solid #ff9900; background: #fff9e6;">`;
            secondJobHtml += `<h4 style="color: #ff9900;">二转职业选择（需要通天塔10万层）</h4>`;
            
            Object.entries(classConfig[player.class].secondJobs).forEach(([key, job]) => {
                secondJobHtml += `
                    <div style="margin: 10px 0; padding: 10px; border: 1px solid #ddd;">
                        <strong>${job.name}</strong><br>
                        ${getJobBonusDescription(job.bonus)}<br>
                        <button onclick="selectSecondJob('${key}')" style="margin-top: 5px;">选择此职业</button>
                    </div>
                `;
            });
            secondJobHtml += `</div>`;
            branchPointsContainer.innerHTML += secondJobHtml;
        }
        
        // 显示已选择的二转职业
        if (player.classSecond) {
            const job = classConfig[player.class].secondJobs[player.classSecond];
            let jobHtml = `<div style="margin: 15px 0; padding: 10px; border: 2px solid #00aa00; background: #f0fff0;">`;
            jobHtml += `<h4 style="color: #00aa00;">二转职业：${job.name}</h4>`;
            jobHtml += `<div>加成：${getJobBonusDescription(job.bonus)}</div>`;
            jobHtml += `</div>`;
            branchPointsContainer.innerHTML += jobHtml;
        }
        
        // 显示三转职业信息
        if (player.tower.currentFloor >= 200000 && player.classSecond && !player.classThird) {
            const thirdJobs = classConfig[player.class].thirdJobs;
            let availableThirdJob = null;
            
            // 找到对应的三转职业
            for (const [key, job] of Object.entries(thirdJobs)) {
                if (job.baseJob === player.classSecond) {
                    availableThirdJob = job;
                    break;
                }
            }
            
            if (availableThirdJob) {
                let thirdJobHtml = `<div style="margin: 15px 0; padding: 15px; border: 2px solid #aa00aa; background: #faf0ff;">`;
                thirdJobHtml += `<h4 style="color: #aa00aa;">三转职业晋升（需要通天塔20万层）</h4>`;
                thirdJobHtml += `<div><strong>${availableThirdJob.name}</strong></div>`;
                thirdJobHtml += `<div>加成：${getJobBonusDescription(availableThirdJob.bonus)}</div>`;
                thirdJobHtml += `<button onclick="selectThirdJob()" style="margin-top: 10px;">晋升为三转</button>`;
                thirdJobHtml += `</div>`;
                branchPointsContainer.innerHTML += thirdJobHtml;
            }
        }
        
        // 显示已选择的三转职业
        if (player.classThird) {
            const job = classConfig[player.class].thirdJobs[player.classThird];
            let jobHtml = `<div style="margin: 15px 0; padding: 10px; border: 2px solid #aa00aa; background: #faf0ff;">`;
            jobHtml += `<h4 style="color: #aa00aa;">三转职业：${job.name}</h4>`;
            jobHtml += `<div>加成：${getJobBonusDescription(job.bonus)}</div>`;
            jobHtml += `</div>`;
            branchPointsContainer.innerHTML += jobHtml;
        }
        
        // 显示四转职业信息
        if (player.tower.currentFloor >= 300000 && player.classThird && !player.classFourth) {
            const fourthJobs = classConfig[player.class].fourthJobs;
            let availableFourthJob = null;
            
            // 找到对应的四转职业
            for (const [key, job] of Object.entries(fourthJobs)) {
                if (job.baseJob === player.classThird) {
                    availableFourthJob = job;
                    break;
                }
            }
            
            if (availableFourthJob) {
                let fourthJobHtml = `<div style="margin: 15px 0; padding: 15px; border: 2px solid #ff0000; background: #fff0f0;">`;
                fourthJobHtml += `<h4 style="color: #ff0000;">四转职业晋升（需要通天塔30万层）</h4>`;
                fourthJobHtml += `<div><strong>${availableFourthJob.name}</strong></div>`;
                fourthJobHtml += `<div>加成：${getJobBonusDescription(availableFourthJob.bonus)}</div>`;
                fourthJobHtml += `<button onclick="selectFourthJob()" style="margin-top: 10px;">晋升为四转</button>`;
                fourthJobHtml += `</div>`;
                branchPointsContainer.innerHTML += fourthJobHtml;
            }
        }
        
        // 显示已选择的四转职业
        if (player.classFourth) {
            const job = classConfig[player.class].fourthJobs[player.classFourth];
            let jobHtml = `<div style="margin: 15px 0; padding: 10px; border: 2px solid #ff0000; background: #fff0f0;">`;
            jobHtml += `<h4 style="color: #ff0000;">四转职业：${job.name}</h4>`;
            jobHtml += `<div>加成：${getJobBonusDescription(job.bonus)}</div>`;
            jobHtml += `</div>`;
            branchPointsContainer.innerHTML += jobHtml;
        }
    } else {
        branchesContainer.style.display = 'none';
    }
    
    // 更新玩家名字旁的职业显示
    updatePlayerClassNameDisplay();
}
// 辅助函数：获取职业加成描述
function getJobBonusDescription(bonus) {
    const descriptions = [];
    if (bonus.attackMultiplier) descriptions.push(`攻击加成${bonus.attackMultiplier}倍`);
    if (bonus.critMultiplier) descriptions.push(`爆伤加成${bonus.critMultiplier}倍`);
    if (bonus.healthMultiplier) descriptions.push(`生命加成${bonus.healthMultiplier}倍`);
    if (bonus.dungeonEquipMultiplier) descriptions.push(`副本装备加成${bonus.dungeonEquipMultiplier}倍`);
    if (bonus.soulRingMultiplier) descriptions.push(`魂环加成${bonus.soulRingMultiplier}倍`);
    return descriptions.join('，');
}
// 选择二转职业
function selectSecondJob(jobKey) {
    if (player.tower.currentFloor < 100000) {
        alert("需要通天塔达到10万层才能进行二转！");
        return;
    }
    
    player.classSecond = jobKey;
    logAction(`成功转职为${classConfig[player.class].secondJobs[jobKey].name}！`, 'success');
    updateClassSystemDisplay();
    updatePlayerBattleStats();
}

// 选择三转职业
function selectThirdJob() {
    if (player.tower.currentFloor < 200000) {
        alert("需要通天塔达到20万层才能进行三转！");
        return;
    }
    
    if (!player.classSecond) {
        alert("需要先完成二转才能进行三转！");
        return;
    }
    
    // 自动确定三转职业
    const thirdJobs = classConfig[player.class].thirdJobs;
    for (const [key, job] of Object.entries(thirdJobs)) {
        if (job.baseJob === player.classSecond) {
            player.classThird = key;
            logAction(`成功晋升为三转${job.name}！`, 'success');
            break;
        }
    }
    
    updateClassSystemDisplay();
    updatePlayerBattleStats();
}

// 选择四转职业
function selectFourthJob() {
    if (player.tower.currentFloor < 300000) {
        alert("需要通天塔达到30万层才能进行四转！");
        return;
    }
    
    if (!player.classThird) {
        alert("需要先完成三转才能进行四转！");
        return;
    }
    
    // 自动确定四转职业
    const fourthJobs = classConfig[player.class].fourthJobs;
    for (const [key, job] of Object.entries(fourthJobs)) {
        if (job.baseJob === player.classThird) {
            player.classFourth = key;
            logAction(`成功晋升为四转${job.name}！`, 'success');
            break;
        }
    }
    
    updateClassSystemDisplay();
    updatePlayerBattleStats();
}
// 选择分支选项
function selectBranch(branchIndex, optionIndex) {
    // 检查是否解锁
    const branch = classConfig[player.class].branches[branchIndex];
    if (player.battle.maxStage < branch.requiredStage) {
        alert(`需要达到${branch.requiredStage}关才能解锁此分支！`);
        return;
    }
    
    // 保存选择
    player.classBranches[branchIndex] = optionIndex;
    logAction(`选择了${classConfig[player.class].name}第${branchIndex + 1}排第${optionIndex + 1}个分支`, 'success');
    
    // 更新显示
    updateClassSystemDisplay();
    updatePlayerBattleStats();
}

 
// 更新玩家名字旁的职业显示
function updatePlayerClassNameDisplay() {
    const classNameElement = document.getElementById('playerClassName');
    if (player.class) {
        let displayName = classConfig[player.class].name;
        
        // 添加转职后缀
        if (player.classFourth) {
            displayName += `·${classConfig[player.class].fourthJobs[player.classFourth].name}`;
        } else if (player.classThird) {
            displayName += `·${classConfig[player.class].thirdJobs[player.classThird].name}`;
        } else if (player.classSecond) {
            displayName += `·${classConfig[player.class].secondJobs[player.classSecond].name}`;
        }
        
        classNameElement.textContent = `[${displayName}]`;
    } else {
        classNameElement.textContent = '';
    }
}
// 新增：计算魂环总加成（含职业分支乘数）
function getTotalSoulRingBonus() {
  let total = 0;
  player.soulRings.forEach(ring => {
    // 基础加成：等级 × 单级倍率
    total += ring.level * ring.multiplier;
  });
  // 应用职业分支的魂环加成乘数
  return total * player.classBonuses.soulRingMultiplier;
}
// 新增：计算副本装备总加成（含职业分支乘数）
function getTotalDungeonEquipBonus() {
  let total = 0;
  player.dungeonEquipment.forEach(eq => {
    // 基础加成：等级 × 成长率（示例，需结合实际装备效果逻辑）
    total += eq.level * eq.growthRate;
  });
  // 应用职业分支的副本装备加成乘数
  return total * player.classBonuses.dungeonEquipMultiplier;
}
// 计算职业加成 (需要在战斗计算相关函数中调用)
function calculateClassBonuses() {
    const bonuses = {
        attackMultiplier: 1,
        healthMultiplier: 1,
        critChance: 0,
        critMultiplier: 1,
        collectionMultiplier: 1,
        dungeonEquipMultiplier: 1,
        soulRingMultiplier: 1
    };
    
    if (!player.class) return bonuses;
    
    const classData = classConfig[player.class];
    
    // 累加一转分支加成（原有逻辑）
    player.classBranches.forEach((optionIndex, branchIndex) => {
        if (optionIndex === undefined) return;
        
        const branch = classData.branches[branchIndex];
        const option = branch.options[optionIndex];
        
        switch (option.type) {
            case 'attackMultiplier':
                bonuses.attackMultiplier *= (1 + option.value);
                break;
            case 'healthMultiplier':
                bonuses.healthMultiplier *= (1 + option.value);
                break;
            case 'critMultiplier':
                if (option.value.multiplier) {
                    bonuses.critMultiplier *= (1 + option.value.multiplier);
                } else {
                    bonuses.critMultiplier *= (1 + option.value);
                }
                break;
            case 'dungeonEquipMultiplier':
                bonuses.dungeonEquipMultiplier *= (1 + option.value);
                break;
            case 'soulRingMultiplier':
                bonuses.soulRingMultiplier *= (1 + option.value);
                break;
        }
    });
    
    // 新增：应用二转职业加成
    if (player.classSecond) {
        const secondJob = classData.secondJobs[player.classSecond];
        if (secondJob && secondJob.bonus) {
            for (const [key, value] of Object.entries(secondJob.bonus)) {
                if (bonuses[key] !== undefined) {
                    bonuses[key] *= value;
                }
            }
        }
    }
    
    // 新增：应用三转职业加成
    if (player.classThird) {
        const thirdJob = classData.thirdJobs[player.classThird];
        if (thirdJob && thirdJob.bonus) {
            for (const [key, value] of Object.entries(thirdJob.bonus)) {
                if (bonuses[key] !== undefined) {
                    bonuses[key] *= value;
                }
            }
        }
    }
    
    // 新增：应用四转职业加成
    if (player.classFourth) {
        const fourthJob = classData.fourthJobs[player.classFourth];
        if (fourthJob && fourthJob.bonus) {
            for (const [key, value] of Object.entries(fourthJob.bonus)) {
                if (bonuses[key] !== undefined) {
                    bonuses[key] *= value;
                }
            }
        }
    }
    
    return bonuses;
}
// 黑龙潭副本数据
const blackDragonAbyss = {
    bossLevel: 1,
    bossHealth: 1e50,
    bossMaxHealth: 1e50,
    bossAttack: 1e5,
    bossResurrections: 0,
    isBattleActive: false,
    playerHealth: 0,
    playerMaxHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
};

// 初始化黑龙潭副本
function initBlackDragonAbyss() {
    // 确保玩家数据中有副本令牌
    if (player.items.fuben1 === undefined) {
        player.items.fuben1 = 0;
    }
}

// 切换黑龙潭副本界面
function toggleBlackDragonAbyss() {
    if (player.level.ascentionCounta < 1) {
        alert("需要达到轮回1转才能开启黑龙潭副本！");
        return;
    }
    const overlay = document.getElementById('blackDragonAbyssOverlay');
    const ui = document.getElementById('blackDragonAbyssUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateBlackDragonAbyssUI();
    }
}

// 更新黑龙潭副本UI
function updateBlackDragonAbyssUI() {
    // 更新副本令牌数量
    document.getElementById('dungeonTokenCount').textContent = player.items.fuben1 || 0;
    
    // 更新玩家属性
    document.getElementById('bdaPlayerHealth').textContent = formatSci(blackDragonAbyss.playerHealth);
    document.getElementById('bdaPlayerAttack').textContent = formatSci(blackDragonAbyss.playerAttack);
    document.getElementById('bdaPlayerCritRate').textContent = (blackDragonAbyss.playerCritRate * 100).toFixed(2) + '%';
    document.getElementById('bdaPlayerCritDamage').textContent = (blackDragonAbyss.playerCritDamage * 100).toFixed(2) + '%';
    
    // 更新BOSS属性
    document.getElementById('bdaBossLevel').textContent = blackDragonAbyss.bossLevel;
    document.getElementById('bdaBossHealth').textContent = formatSci(blackDragonAbyss.bossHealth);
    document.getElementById('bdaBossMaxHealth').textContent = formatSci(blackDragonAbyss.bossMaxHealth);
    document.getElementById('bdaBossAttack').textContent = formatSci(blackDragonAbyss.bossAttack);
    document.getElementById('bdaBossResurrections').textContent = blackDragonAbyss.bossResurrections;
}

// 开始黑龙王战斗
function startBlackDragonBattle() {
    // 检查是否有副本令牌
    if (player.items.fuben1 < 1) {
        logAction("副本令牌不足！", "error");
        return;
    }
    
    // 消耗副本令牌
    player.items.fuben1--;
    
    // 重置BOSS状态
    blackDragonAbyss.bossLevel = 1;
    blackDragonAbyss.bossHealth = 1e50;
    blackDragonAbyss.bossMaxHealth = 1e50;
    blackDragonAbyss.bossAttack = 1e5;
    blackDragonAbyss.bossResurrections = 0;
    
    // 设置玩家战斗属性
    blackDragonAbyss.playerMaxHealth = player.battle.playerHealth;
    blackDragonAbyss.playerHealth = player.battle.playerHealth;
    blackDragonAbyss.playerAttack = player.battle.playerAttack;
    blackDragonAbyss.playerCritRate = player.battle.playerCritRate;
    blackDragonAbyss.playerCritDamage = player.battle.playerCritDamage;
    
    // 开始战斗
    blackDragonAbyss.isBattleActive = true;
    
    // 更新UI
    document.getElementById('startBattleBtn').style.display = 'none';
    document.getElementById('attackBossBtn').style.display = 'inline-block';
    document.getElementById('fleeBossBtn').style.display = 'inline-block';
    
    // 清空战斗日志
    document.getElementById('bdaBattleLog').innerHTML = '';
    
    // 添加战斗开始日志
    addBdaBattleLog("战斗开始！挑战黑龙王(Lv.1)");
    addBdaBattleLog("黑龙王: 蝼蚁，也敢挑战本王？");
    
    updateBlackDragonAbyssUI();
}

// 攻击黑龙王
function attackBlackDragon() {
    if (!blackDragonAbyss.isBattleActive) return;
    
    // 玩家攻击
    let isCrit = Math.random() < blackDragonAbyss.playerCritRate;
    let damage = blackDragonAbyss.playerAttack * (isCrit ? blackDragonAbyss.playerCritDamage : 1);
    
    blackDragonAbyss.bossHealth -= damage;
    
    addBdaBattleLog(`你对黑龙王造成${formatSci(damage)}点${isCrit ? "暴击 " : ""}伤害`);
    
    // 检查BOSS是否死亡
    if (blackDragonAbyss.bossHealth <= 0) {
        handleBossDefeated();
        return; // 直接返回，不执行后续的BOSS反击
    }
    
    // BOSS反击（仅在BOSS未死亡时执行）
    let bossDamage = blackDragonAbyss.bossAttack;
    blackDragonAbyss.playerHealth -= bossDamage;
    
    addBdaBattleLog(`黑龙王对你造成${formatSci(bossDamage)}点伤害`);
    
    // 检查玩家是否死亡
    if (blackDragonAbyss.playerHealth <= 0) {
        handlePlayerDefeated();
        return;
    }
    
    updateBlackDragonAbyssUI();
}

// 处理BOSS被击败
function handleBossDefeated() {
    // 检查BOSS复活次数
    if (blackDragonAbyss.bossResurrections < 10) {
        // BOSS复活
        blackDragonAbyss.bossResurrections++;
        blackDragonAbyss.bossHealth = blackDragonAbyss.bossMaxHealth * Math.pow(2, blackDragonAbyss.bossResurrections);
        blackDragonAbyss.bossAttack *= 2;
        
        addBdaBattleLog(`黑龙王复活了！(第${blackDragonAbyss.bossResurrections}次复活)`);
        addBdaBattleLog("黑龙王: 你无法杀死我！");
        
        // 新增：BOSS复活后立即攻击玩家
        bossResurrectionAttack();
    } else {
        // BOSS真正死亡，升级
        blackDragonAbyss.bossLevel++;
        blackDragonAbyss.bossMaxHealth = 1e50 * Math.pow(1e10, blackDragonAbyss.bossLevel - 1);
        blackDragonAbyss.bossHealth = blackDragonAbyss.bossMaxHealth;
        blackDragonAbyss.bossAttack = 1e5 * Math.pow(1e5, blackDragonAbyss.bossLevel - 1);
        blackDragonAbyss.bossResurrections = 0;
        
        addBdaBattleLog(`恭喜！你击败了黑龙王，等级提升至${blackDragonAbyss.bossLevel}`);
        addBdaBattleLog("黑龙王: 不...这不可能...");
    }
    
    updateBlackDragonAbyssUI();
}

// 新增：BOSS复活后立即攻击玩家的函数
function bossResurrectionAttack() {
    // BOSS复活后立即攻击玩家
    let bossDamage = blackDragonAbyss.bossAttack;
    blackDragonAbyss.playerHealth -= bossDamage;
    
    addBdaBattleLog(`黑龙王复活后立即对你造成${formatSci(bossDamage)}点伤害`);
    
    // 检查玩家是否死亡
    if (blackDragonAbyss.playerHealth <= 0) {
        handlePlayerDefeated();
        return;
    }
    
    updateBlackDragonAbyssUI();
}

// 处理玩家被击败
function handlePlayerDefeated() {
    blackDragonAbyss.isBattleActive = false;
    
    addBdaBattleLog("你被黑龙王击败了！");
    addBdaBattleLog("战斗结束");
    
    // 隐藏攻击按钮
    document.getElementById('attackBossBtn').style.display = 'none';
    document.getElementById('fleeBossBtn').style.display = 'none';
    document.getElementById('startBattleBtn').style.display = 'inline-block';
    
    // 显示奖励
    showBdaRewards();
}

// 从黑龙王战斗逃跑
function fleeBlackDragonBattle() {
    blackDragonAbyss.isBattleActive = false;
    
    addBdaBattleLog("你逃离了战斗");
    
    // 隐藏攻击按钮
    document.getElementById('attackBossBtn').style.display = 'none';
    document.getElementById('fleeBossBtn').style.display = 'none';
    document.getElementById('startBattleBtn').style.display = 'inline-block';
    
    // 显示奖励
    showBdaRewards();
}

// 显示奖励
function showBdaRewards() {
   // 如果BOSS等级为1，则没有奖励
    if (blackDragonAbyss.bossLevel === 1) {
        addBdaBattleLog("黑龙王等级1，没有获得任何奖励。");
        // 直接返回，不显示奖励界面
        return;
    }
    const multiplier = blackDragonAbyss.bossLevel;
    
    // 计算奖励
    const rewards = {
        // 这里使用游戏内已有的道具字段，如果没有需要先定义
        chiban1: Math.floor(randomBetween(1, 3) * multiplier), // 黑龙王翅膀
        rebornDan: Math.floor(randomBetween(1, 5) * multiplier), // 洗髓丹
        rootDetector: Math.floor(randomBetween(1, 2) * multiplier), // 灵根检测器
        bloodlineDetector: Math.floor(randomBetween(1, 2) * multiplier), // 血脉检测剂
        roseq: Math.floor(randomBetween(1, 2) * multiplier), // 香囊
        banlv1: Math.floor(randomBetween(1, 3) * multiplier), // 普通灵魂伴侣
        yuzhou1: Math.floor(randomBetween(10, 50) * multiplier), // 星辰发票
        yuzhou2: Math.floor(randomBetween(10, 50) * multiplier), // 暗物质发票
        yuzhou3: Math.floor(randomBetween(1, 5) * multiplier), // 宇宙结晶发票
        yuzhou4: Math.floor(randomBetween(1, 5) * multiplier) // 神器碎片发票
    };
    
    // 更新奖励UI
    document.getElementById('rewardBossLevel').textContent = blackDragonAbyss.bossLevel;
    document.getElementById('rewardMultiplier').textContent = multiplier;
    
    let rewardHtml = '';
    for (const [item, amount] of Object.entries(rewards)) {
        // 添加到玩家物品
        player.items[item] = (player.items[item] || 0) + amount;
        
        // 生成奖励显示
        rewardHtml += `<div>${getItemName(item)}: ${amount}</div>`;
    }
    
    document.getElementById('rewardItems').innerHTML = rewardHtml;
    
    // 显示奖励UI
    document.getElementById('bdaRewardOverlay').style.display = 'block';
    document.getElementById('bdaRewardUI').style.display = 'block';
}

// 关闭奖励界面
function closeBdaReward() {
    document.getElementById('bdaRewardOverlay').style.display = 'none';
    document.getElementById('bdaRewardUI').style.display = 'none';
}

// 添加战斗日志
function addBdaBattleLog(message) {
    const logElement = document.createElement('div');
    logElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    document.getElementById('bdaBattleLog').appendChild(logElement);
    document.getElementById('bdaBattleLog').scrollTop = document.getElementById('bdaBattleLog').scrollHeight;
}

// 辅助函数：生成随机数范围
function randomBetween(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// 辅助函数：获取物品名称
function getItemName(itemKey) {
    const itemNames = {
        chiban1: "黑龙王翅膀",
        rebornDan: "洗髓丹",
        rootDetector: "灵根检测器",
        bloodlineDetector: "血脉检测剂",
        roseq: "香囊",
        banlv1: "普通灵魂伴侣",
        yuzhou1: "星辰发票",
        yuzhou2: "暗物质发票",
        yuzhou3: "宇宙结晶发票",
        yuzhou4: "神器碎片发票"
    };
    
    return itemNames[itemKey] || itemKey;
}

// 辅助函数：科学计数法格式化
function formatSci(number) {
    if (number < 1000000) {
        return Math.floor(number).toLocaleString();
    }
    return number.toExponential(3).replace(/(\.\d+?)0+e/, '$1e').replace(/\.?e\+?/, 'e');
}
initBlackDragonAbyss();

// 圣兽岛奖励配置
const hbiRewards = {
    baseRewards: {
        '远古圣兽精魄': { min: 1, max: 3 },
        '神兽蛋': { min: 1, max: 2 },
        '洗髓丹': { min: 3, max: 7 },
        '香囊': { min: 3, max: 5 },
        '星辰发票': { min: 100, max: 200 },
        '暗物质发票': { min: 100, max: 200 },
        '宇宙结晶发票': { min: 20, max: 30 },
        '神器碎片': { min: 20, max: 30 }
    },
    itemMapping: {
        '远古圣兽精魄': 'zuoqi1',
        '神兽蛋': 'shenshou1',
        '洗髓丹': 'rebornDan',
        '香囊': 'roseq',
        '星辰发票': 'yuzhou1',
        '暗物质发票': 'yuzhou2',
        '宇宙结晶发票': 'yuzhou3',
        '神器碎片': 'yuzhou4'
    }
};

// 切换圣兽岛副本界面
function toggleHolyBeastIsland() {
   if (player.level.ascentionCounta < 2) {
        alert("需要达到轮回2转才能开启圣兽岛副本！");
        return;
    }
    const overlay = document.getElementById('holyBeastIslandOverlay');
    const ui = document.getElementById('holyBeastIslandUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        // 停止自动战斗
        if (player.holyBeastIsland.autoBattleInterval) {
            clearInterval(player.holyBeastIsland.autoBattleInterval);
            player.holyBeastIsland.autoBattleInterval = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateHolyBeastIslandUI();
    }
}

// 更新圣兽岛界面显示
function updateHolyBeastIslandUI() {
    // 更新令牌数量
    document.getElementById('hbiTokenCount').textContent = player.items.fuben1 || 0;
    
    // 更新玩家属性
    const playerStats = calculatePlayerBattleStats();
    document.getElementById('hbiPlayerHealth').textContent = formatSci(playerStats.health);
    document.getElementById('hbiPlayerAttack').textContent = formatSci(playerStats.attack);
    document.getElementById('hbiPlayerCritRate').textContent = (playerStats.critRate * 100).toFixed(2) + '%';
    document.getElementById('hbiPlayerCritDamage').textContent = (playerStats.critDamage * 100).toFixed(2) + '%';
    
    // 更新BOSS属性
    document.getElementById('hbiBossLevel').textContent = player.holyBeastIsland.bossLevel;
    document.getElementById('hbiBossHealth').textContent = formatSci(player.holyBeastIsland.bossHealth);
    document.getElementById('hbiBossMaxHealth').textContent = formatSci(player.holyBeastIsland.bossMaxHealth);
    document.getElementById('hbiBossAttack').textContent = formatSci(player.holyBeastIsland.bossAttack);
    document.getElementById('hbiBossResurrections').textContent = player.holyBeastIsland.bossResurrections;
    
    // 更新按钮状态
    const startBtn = document.getElementById('startHbiBattleBtn');
    const attackBtn = document.getElementById('attackHbiBossBtn');
    const fleeBtn = document.getElementById('fleeHbiBossBtn');
    
    if (player.holyBeastIsland.isBattling) {
        startBtn.style.display = 'none';
        attackBtn.style.display = 'inline-block';
        fleeBtn.style.display = 'inline-block';
    } else {
        startBtn.style.display = 'inline-block';
        attackBtn.style.display = 'none';
        fleeBtn.style.display = 'none';
    }
}

// 开始圣兽岛战斗
function startHolyBeastBattle() {
    // 检查副本令牌
    if (!player.items.fuben1 || player.items.fuben1 < 1) {
        logAction('副本令牌不足！', 'error');
        return;
    }
    
    // 消耗副本令牌
    player.items.fuben1--;
    
    // 初始化BOSS属性（每次重新挑战都从1级开始）
    player.holyBeastIsland.bossLevel = 1;
    player.holyBeastIsland.bossMaxHealth = 1e100;
    player.holyBeastIsland.bossHealth = 1e100;
    player.holyBeastIsland.bossAttack = 1e10;
    player.holyBeastIsland.bossResurrections = 0;
    player.holyBeastIsland.isBattling = true;
    
    // 初始化玩家战斗属性
    const playerStats = calculatePlayerBattleStats();
    player.holyBeastIsland.playerHealth = playerStats.health;
    player.holyBeastIsland.playerAttack = playerStats.attack;
    player.holyBeastIsland.playerCritRate = playerStats.critRate;
    player.holyBeastIsland.playerCritDamage = playerStats.critDamage;
    
    // 清空战斗日志
    document.getElementById('hbiBattleLog').innerHTML = '';
    
    // 添加战斗开始日志
    addHbiBattleLog('=== 圣兽岛副本挑战开始 ===');
    addHbiBattleLog(`挑战上古火麒麟 Lv.${player.holyBeastIsland.bossLevel}`);
    addHbiBattleLog(`BOSS生命: ${formatSci(player.holyBeastIsland.bossHealth)}`);
    addHbiBattleLog(`BOSS攻击: ${formatSci(player.holyBeastIsland.bossAttack)}`);
    
    updateHolyBeastIslandUI();
    logAction('开始挑战圣兽岛副本上古火麒麟！', 'success');
}

// 攻击圣兽岛BOSS
function attackHolyBeastBoss() {
    if (!player.holyBeastIsland.isBattling) return;
    
    const playerAttack = player.holyBeastIsland.playerAttack;
    const critRate = player.holyBeastIsland.playerCritRate;
    const critDamage = player.holyBeastIsland.playerCritDamage;
    
    // 计算伤害（考虑暴击）
    const isCrit = Math.random() < critRate;
    let damage = playerAttack;
    
    if (isCrit) {
        damage *= critDamage;
    }
    
    // 应用伤害
    player.holyBeastIsland.bossHealth -= damage;
    
    // 记录攻击日志
    addHbiBattleLog(`你对上古火麒麟造成了${formatSci(damage)}点${isCrit ? '暴击 ' : ''}伤害`);
    addHbiBattleLog(`BOSS剩余生命: ${formatSci(player.holyBeastIsland.bossHealth)}/${formatSci(player.holyBeastIsland.bossMaxHealth)}`);
    
    // 检查BOSS是否死亡
    if (player.holyBeastIsland.bossHealth <= 0) {
        handleHbiBossDefeated();
    } else {
        // BOSS反击
        hbiBossCounterAttack();
    }
    
    updateHolyBeastIslandUI();
}

// BOSS反击
function hbiBossCounterAttack() {
    const bossAttack = player.holyBeastIsland.bossAttack;
    
    // 应用伤害
    player.holyBeastIsland.playerHealth -= bossAttack;
    
    // 记录反击日志
    addHbiBattleLog(`上古火麒麟对你造成了${formatSci(bossAttack)}点伤害`);
    addHbiBattleLog(`你剩余生命: ${formatSci(player.holyBeastIsland.playerHealth)}`);
    
    // 检查玩家是否死亡
    if (player.holyBeastIsland.playerHealth <= 0) {
        handleHbiPlayerDefeated();
    }
    
    updateHolyBeastIslandUI();
}

// 处理BOSS被击败
function handleHbiBossDefeated() {
    player.holyBeastIsland.bossResurrections++;
    
    if (player.holyBeastIsland.bossResurrections < 10) {
        // BOSS复活（属性提升3倍）
        player.holyBeastIsland.bossHealth = player.holyBeastIsland.bossMaxHealth * Math.pow(3, player.holyBeastIsland.bossResurrections);
        player.holyBeastIsland.bossAttack *= 3;
        
        addHbiBattleLog(`上古火麒麟复活了！(第${player.holyBeastIsland.bossResurrections}次复活)`);
        addHbiBattleLog(`BOSS属性提升3倍！`);
        
        // BOSS复活后立即反击
        hbiBossCounterAttack();
    } else {
        // BOSS真正死亡，进入下一级
        addHbiBattleLog(`上古火麒麟被彻底击败！`);
        player.holyBeastIsland.bossLevel++;
        
        // 计算下一级BOSS属性（每级提升1e10倍）
        const levelMultiplier = Math.pow(1e10, player.holyBeastIsland.bossLevel - 1);
        player.holyBeastIsland.bossMaxHealth = 1e100 * levelMultiplier;
        player.holyBeastIsland.bossHealth = player.holyBeastIsland.bossMaxHealth;
        player.holyBeastIsland.bossAttack = 1e10 * levelMultiplier;
        player.holyBeastIsland.bossResurrections = 0;
        
        addHbiBattleLog(`上古火麒麟晋升至 Lv.${player.holyBeastIsland.bossLevel}`);
        addHbiBattleLog(`BOSS属性提升${formatSci(levelMultiplier)}倍！`);
        
        // 新等级BOSS立即反击
        hbiBossCounterAttack();
    }
}

// 处理玩家被击败
function handleHbiPlayerDefeated() {
    addHbiBattleLog('=== 你被上古火麒麟击败了！ ===');
    player.holyBeastIsland.isBattling = false;
    
    // 显示奖励界面
    if (player.holyBeastIsland.bossLevel >= 2) {
        showHbiRewards();
    } else {
        addHbiBattleLog('等级1没有奖励，请继续挑战！');
    }
    
    updateHolyBeastIslandUI();
}

// 逃跑函数
function fleeHolyBeastBattle() {
    addHbiBattleLog('=== 你选择逃离战斗 ===');
    player.holyBeastIsland.isBattling = false;
    
    // 显示奖励界面（即使逃跑也结算当前进度奖励）
    if (player.holyBeastIsland.bossLevel >= 2) {
        showHbiRewards();
    } else {
        addHbiBattleLog('等级1没有奖励，请继续挑战！');
    }
    
    updateHolyBeastIslandUI();
}

// 显示奖励界面
function showHbiRewards() {
if (player.holyBeastIsland.bossLevel < 2) {
        return;
    }

    const rewardMultiplier = player.holyBeastIsland.bossLevel-1;
    const rewards = calculateHbiRewards(rewardMultiplier);
    
    // 更新奖励界面显示
    document.getElementById('hbiRewardBossLevel').textContent = player.holyBeastIsland.bossLevel;
    document.getElementById('hbiRewardMultiplier').textContent = rewardMultiplier;
    
    // 显示奖励物品
    const rewardItemsContainer = document.getElementById('hbiRewardItems');
    rewardItemsContainer.innerHTML = '';
    
    Object.entries(rewards).forEach(([itemName, quantity]) => {
        const itemDiv = document.createElement('div');
        itemDiv.style.margin = '5px 0';
        itemDiv.innerHTML = `<span style="color: #ffd700;">${itemName}</span>: ${quantity}个`;
        rewardItemsContainer.appendChild(itemDiv);
    });
    
    // 显示奖励界面
    document.getElementById('hbiRewardOverlay').style.display = 'block';
    document.getElementById('hbiRewardUI').style.display = 'block';
}

// 计算奖励
function calculateHbiRewards(multiplier) {
    const rewards = {};
    
    Object.entries(hbiRewards.baseRewards).forEach(([itemName, range]) => {
        const baseQuantity = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        const finalQuantity = baseQuantity * multiplier;
        rewards[itemName] = finalQuantity;
        
        // 添加到玩家物品
        const itemKey = hbiRewards.itemMapping[itemName];
        if (itemKey) {
            player.items[itemKey] = (player.items[itemKey] || 0) + finalQuantity;
        }
    });
    
    return rewards;
}

// 关闭奖励界面
function closeHbiReward() {
    document.getElementById('hbiRewardOverlay').style.display = 'none';
    document.getElementById('hbiRewardUI').style.display = 'none';
    
    // 记录奖励日志
    logAction('圣兽岛副本挑战结束，获得丰厚奖励！', 'success');
    updateDisplay();
}

// 添加战斗日志
function addHbiBattleLog(message) {
    const logContainer = document.getElementById('hbiBattleLog');
    const logEntry = document.createElement('div');
    logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logEntry.style.margin = '2px 0';
    logEntry.style.padding = '2px 5px';
    
    // 根据消息类型添加颜色
    if (message.includes('击败') || message.includes('奖励')) {
        logEntry.style.color = '#00ff00';
    } else if (message.includes('伤害')) {
        logEntry.style.color = '#ffa500';
    } else if (message.includes('复活')) {
        logEntry.style.color = '#ff0000';
    }
    
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

// 计算玩家战斗属性（需要根据你的游戏系统实现）
function calculatePlayerBattleStats() {
    // 这里需要根据你的游戏系统计算玩家属性
    // 返回格式：{ health: number, attack: number, critRate: number, critDamage: number }
    return {
        health: player.battle.playerHealth || 1e10,
        attack: player.battle.playerAttack || 1e8,
        critRate: player.battle.playerCritRate || 0.1,
        critDamage: player.battle.playerCritDamage || 1.5
    };
}

// 科学计数法格式化函数
function formatSci(number) {
    if (number >= 1e6) {
        return number.toExponential(3);
    }
    return Math.floor(number).toLocaleString();
}
// 蓬莱仙岛奖励配置
const penglaiRewards = {
    baseRewards: {
        '秘法符文': { min: 1, max: 3 },
        '洗髓丹': { min: 5, max: 10 },
        '香囊': { min: 10, max: 20 },
        '星辰发票': { min: 300, max: 500 },
        '暗物质发票': { min: 300, max: 500 },
        '宇宙结晶发票': { min: 100, max: 200 },
        '神器碎片': { min: 100, max: 200 }
    },
    itemMapping: {
        '秘法符文': 'fuwen1',
        '洗髓丹': 'rebornDan',
        '香囊': 'roseq',
        '星辰发票': 'yuzhou1',
        '暗物质发票': 'yuzhou2',
        '宇宙结晶发票': 'yuzhou3',
        '神器碎片': 'yuzhou4'
    }
};

// 切换蓬莱仙岛副本界面
function togglePenglaiIsland() {
    if (player.level.ascentionCounta < 3) {
        alert("需要达到轮回3转才能开启蓬莱仙岛副本！");
        return;
    }
    const overlay = document.getElementById('penglaiIslandOverlay');
    const ui = document.getElementById('penglaiIslandUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        // 停止自动战斗
        if (player.penglaiIsland.autoBattleInterval) {
            clearInterval(player.penglaiIsland.autoBattleInterval);
            player.penglaiIsland.autoBattleInterval = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updatePenglaiIslandUI();
    }
}

// 更新蓬莱仙岛界面显示
function updatePenglaiIslandUI() {
    // 更新令牌数量
    document.getElementById('penglaiTokenCount').textContent = player.items.fuben1 || 0;
    
    // 更新玩家属性
    const playerStats = calculatePlayerBattleStats();
    document.getElementById('penglaiPlayerHealth').textContent = formatSci(playerStats.health);
    document.getElementById('penglaiPlayerAttack').textContent = formatSci(playerStats.attack);
    document.getElementById('penglaiPlayerCritRate').textContent = (playerStats.critRate * 100).toFixed(2) + '%';
    document.getElementById('penglaiPlayerCritDamage').textContent = (playerStats.critDamage * 100).toFixed(2) + '%';
    
    // 更新BOSS属性
    document.getElementById('penglaiBossLevel').textContent = player.penglaiIsland.bossLevel;
    document.getElementById('penglaiBossHealth').textContent = formatSci(player.penglaiIsland.bossHealth);
    document.getElementById('penglaiBossMaxHealth').textContent = formatSci(player.penglaiIsland.bossMaxHealth);
    document.getElementById('penglaiBossAttack').textContent = formatSci(player.penglaiIsland.bossAttack);
    document.getElementById('penglaiBossResurrections').textContent = player.penglaiIsland.bossResurrections;
    
    // 更新按钮状态
    const startBtn = document.getElementById('startPenglaiBattleBtn');
    const attackBtn = document.getElementById('attackPenglaiBossBtn');
    const fleeBtn = document.getElementById('fleePenglaiBossBtn');
    
    if (player.penglaiIsland.isBattling) {
        startBtn.style.display = 'none';
        attackBtn.style.display = 'inline-block';
        fleeBtn.style.display = 'inline-block';
    } else {
        startBtn.style.display = 'inline-block';
        attackBtn.style.display = 'none';
        fleeBtn.style.display = 'none';
    }
}

// 开始蓬莱仙岛战斗
function startPenglaiBattle() {
    // 检查副本令牌
    if (!player.items.fuben1 || player.items.fuben1 < 1) {
        logAction('副本令牌不足！', 'error');
        return;
    }
    
    // 消耗副本令牌
    player.items.fuben1--;
    
    // 初始化BOSS属性（每次重新挑战都从1级开始）
    player.penglaiIsland.bossLevel = 1;
    player.penglaiIsland.bossMaxHealth = 1e120;
    player.penglaiIsland.bossHealth = 1e120;
    player.penglaiIsland.bossAttack = 1e20;
    player.penglaiIsland.bossResurrections = 0;
    player.penglaiIsland.isBattling = true;
    
    // 初始化玩家战斗属性
    const playerStats = calculatePlayerBattleStats();
    player.penglaiIsland.playerHealth = playerStats.health;
    player.penglaiIsland.playerAttack = playerStats.attack;
    player.penglaiIsland.playerCritRate = playerStats.critRate;
    player.penglaiIsland.playerCritDamage = playerStats.critDamage;
    
    // 清空战斗日志
    document.getElementById('penglaiBattleLog').innerHTML = '';
    
    // 添加战斗开始日志
    addPenglaiBattleLog('=== 蓬莱仙岛副本挑战开始 ===');
    addPenglaiBattleLog(`挑战太古饕鬄 Lv.${player.penglaiIsland.bossLevel}`);
    addPenglaiBattleLog(`BOSS生命: ${formatSci(player.penglaiIsland.bossHealth)}`);
    addPenglaiBattleLog(`BOSS攻击: ${formatSci(player.penglaiIsland.bossAttack)}`);
    
    updatePenglaiIslandUI();
    logAction('开始挑战蓬莱仙岛副本太古饕鬄！', 'success');
}

// 攻击蓬莱仙岛BOSS
function attackPenglaiBoss() {
    if (!player.penglaiIsland.isBattling) return;
    
    const playerAttack = player.penglaiIsland.playerAttack;
    const critRate = player.penglaiIsland.playerCritRate;
    const critDamage = player.penglaiIsland.playerCritDamage;
    
    // 计算伤害（考虑暴击）
    const isCrit = Math.random() < critRate;
    let damage = playerAttack;
    
    if (isCrit) {
        damage *= critDamage;
    }
    
    // 应用伤害
    player.penglaiIsland.bossHealth -= damage;
    
    // 记录攻击日志
    addPenglaiBattleLog(`你对太古饕鬄造成了${formatSci(damage)}点${isCrit ? '暴击 ' : ''}伤害`);
    addPenglaiBattleLog(`BOSS剩余生命: ${formatSci(player.penglaiIsland.bossHealth)}/${formatSci(player.penglaiIsland.bossMaxHealth)}`);
    
    // 检查BOSS是否死亡
    if (player.penglaiIsland.bossHealth <= 0) {
        handlePenglaiBossDefeated();
    } else {
        // BOSS反击
        penglaiBossCounterAttack();
    }
    
    updatePenglaiIslandUI();
}

// BOSS反击
function penglaiBossCounterAttack() {
    const bossAttack = player.penglaiIsland.bossAttack;
    
    // 应用伤害
    player.penglaiIsland.playerHealth -= bossAttack;
    
    // 记录反击日志
    addPenglaiBattleLog(`太古饕鬄对你造成了${formatSci(bossAttack)}点伤害`);
    addPenglaiBattleLog(`你剩余生命: ${formatSci(player.penglaiIsland.playerHealth)}`);
    
    // 检查玩家是否死亡
    if (player.penglaiIsland.playerHealth <= 0) {
        handlePenglaiPlayerDefeated();
    }
    
    updatePenglaiIslandUI();
}

// 处理BOSS被击败
function handlePenglaiBossDefeated() {
    player.penglaiIsland.bossResurrections++;
    
    if (player.penglaiIsland.bossResurrections < 10) {
        // BOSS复活（属性提升3倍）
        player.penglaiIsland.bossHealth = player.penglaiIsland.bossMaxHealth * Math.pow(3, player.penglaiIsland.bossResurrections);
        player.penglaiIsland.bossAttack *= 3;
        
        addPenglaiBattleLog(`太古饕鬄复活了！(第${player.penglaiIsland.bossResurrections}次复活)`);
        addPenglaiBattleLog(`BOSS属性提升3倍！`);
        
        // BOSS复活后立即反击
        penglaiBossCounterAttack();
    } else {
        // BOSS真正死亡，进入下一级
        addPenglaiBattleLog(`太古饕鬄被彻底击败！`);
        player.penglaiIsland.bossLevel++;
        
        // 计算下一级BOSS属性（每级提升1e20倍）
        const levelMultiplier = Math.pow(1e20, player.penglaiIsland.bossLevel - 1);
        player.penglaiIsland.bossMaxHealth = 1e120 * levelMultiplier;
        player.penglaiIsland.bossHealth = player.penglaiIsland.bossMaxHealth;
        player.penglaiIsland.bossAttack = 1e15 * levelMultiplier;
        player.penglaiIsland.bossResurrections = 0;
        
        addPenglaiBattleLog(`太古饕鬄晋升至 Lv.${player.penglaiIsland.bossLevel}`);
        addPenglaiBattleLog(`BOSS属性提升${formatSci(levelMultiplier)}倍！`);
        
        // 新等级BOSS立即反击
        penglaiBossCounterAttack();
    }
}

// 处理玩家被击败
function handlePenglaiPlayerDefeated() {
    addPenglaiBattleLog('=== 你被太古饕鬄击败了！ ===');
    player.penglaiIsland.isBattling = false;
    
    // 只在等级2及以上显示奖励界面
    if (player.penglaiIsland.bossLevel >= 2) {
        showPenglaiRewards();
    } else {
        addPenglaiBattleLog('等级1没有奖励，请继续挑战！');
    }
    
    updatePenglaiIslandUI();
}

// 逃跑函数
function fleePenglaiBattle() {
    addPenglaiBattleLog('=== 你选择逃离战斗 ===');
    player.penglaiIsland.isBattling = false;
    
    // 只在等级2及以上显示奖励界面
    if (player.penglaiIsland.bossLevel >= 2) {
        showPenglaiRewards();
    } else {
        addPenglaiBattleLog('等级1没有奖励，请继续挑战！');
    }
    
    updatePenglaiIslandUI();
}

// 显示奖励界面
function showPenglaiRewards() {
    // 只在等级2及以上计算奖励
    if (player.penglaiIsland.bossLevel < 2) {
        return;
    }
    
    const rewardMultiplier = player.penglaiIsland.bossLevel - 1; // 等级2开始有奖励，倍数为1
    const rewards = calculatePenglaiRewards(rewardMultiplier);
    
    // 更新奖励界面显示
    document.getElementById('penglaiRewardBossLevel').textContent = player.penglaiIsland.bossLevel;
    document.getElementById('penglaiRewardMultiplier').textContent = rewardMultiplier;
    
    // 显示奖励物品
    const rewardItemsContainer = document.getElementById('penglaiRewardItems');
    rewardItemsContainer.innerHTML = '';
    
    Object.entries(rewards).forEach(([itemName, quantity]) => {
        const itemDiv = document.createElement('div');
        itemDiv.style.margin = '5px 0';
        itemDiv.innerHTML = `<span style="color: #ffd700;">${itemName}</span>: ${quantity}个`;
        rewardItemsContainer.appendChild(itemDiv);
    });
    
    // 显示奖励界面
    document.getElementById('penglaiRewardOverlay').style.display = 'block';
    document.getElementById('penglaiRewardUI').style.display = 'block';
}

// 计算奖励
function calculatePenglaiRewards(multiplier) {
    const rewards = {};
    
    Object.entries(penglaiRewards.baseRewards).forEach(([itemName, range]) => {
        const baseQuantity = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        const finalQuantity = baseQuantity * multiplier;
        rewards[itemName] = finalQuantity;
        
        // 添加到玩家物品
        const itemKey = penglaiRewards.itemMapping[itemName];
        if (itemKey) {
            player.items[itemKey] = (player.items[itemKey] || 0) + finalQuantity;
        }
    });
    
    return rewards;
}

// 关闭奖励界面
function closePenglaiReward() {
    document.getElementById('penglaiRewardOverlay').style.display = 'none';
    document.getElementById('penglaiRewardUI').style.display = 'none';
    
    // 记录奖励日志
    logAction('蓬莱仙岛副本挑战结束，获得丰厚奖励！', 'success');
    updateDisplay();
}

// 添加战斗日志
function addPenglaiBattleLog(message) {
    const logContainer = document.getElementById('penglaiBattleLog');
    const logEntry = document.createElement('div');
    logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logEntry.style.margin = '2px 0';
    logEntry.style.padding = '2px 5px';
    
    // 根据消息类型添加颜色
    if (message.includes('击败') || message.includes('奖励')) {
        logEntry.style.color = '#00ff00';
    } else if (message.includes('伤害')) {
        logEntry.style.color = '#ffa500';
    } else if (message.includes('复活')) {
        logEntry.style.color = '#ff0000';
    }
    
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

// 科学计数法格式化函数
function formatSci(number) {
    if (number >= 1e6) {
        return number.toExponential(3);
    }
    return Math.floor(number).toLocaleString();
}
// 切换时光秘境界面
function toggleTimeSecretRealm() {
   if (player.reincarnationCount < 2000) {
        alert("需要达到2000转才能开启秘境系统！");
        return;
    }
    const overlay = document.getElementById('timeSecretRealmOverlay');
    const ui = document.getElementById('timeSecretRealmUI');
    
    if (ui.style.display === 'block') {
        // 关闭界面
        ui.style.display = 'none';
        overlay.style.display = 'none';
        if (player.timeSecretRealm.timer) {
            clearInterval(player.timeSecretRealm.timer);
            player.timeSecretRealm.timer = null;
        }
    } else {
        // 打开界面
        ui.style.display = 'block';
        overlay.style.display = 'block';
        
        // 根据是否在冒险中显示不同的界面
        const tsr = player.timeSecretRealm;
        if (tsr.currentRun && tsr.currentRun.isActive) {
            // 冒险进行中，显示冒险界面
            document.getElementById('tsrDifficultySelection').style.display = 'none';
            document.getElementById('startTsrBtn').style.display = 'none';
            document.getElementById('openTsrShopBtn').style.display = 'none';
            document.getElementById('tsrStatusDisplay').style.display = 'block';
            document.getElementById('tsrRoomDisplay').style.display = 'block';
            document.getElementById('tsrActionControls').style.display = 'block';
            document.getElementById('tsrBuffsDisplay').style.display = 'block';
            document.getElementById('tsrSkillsDisplay').style.display = 'block';
            document.getElementById('tsrHealthBar').style.display = 'block';
        } else {
            // 不在冒险中，显示难度选择界面
            document.getElementById('tsrDifficultySelection').style.display = 'block';
            document.getElementById('startTsrBtn').style.display = 'inline-block';
            document.getElementById('openTsrShopBtn').style.display = 'inline-block';
            document.getElementById('tsrStatusDisplay').style.display = 'none';
            document.getElementById('tsrRoomDisplay').style.display = 'none';
            document.getElementById('tsrActionControls').style.display = 'none';
            document.getElementById('tsrBuffsDisplay').style.display = 'none';
            document.getElementById('tsrSkillsDisplay').style.display = 'none';
            document.getElementById('tsrHealthBar').style.display = 'none';
        }
        
        updateTimeSecretRealmUI();
    }
}


// 更新时光秘境界面
function updateTimeSecretRealmUI() {
    const tsr = player.timeSecretRealm;
    
    // 更新永久数据
    document.getElementById('tsrCurrency').textContent = tsr.currency.toFixed(0);
    document.getElementById('tsrBestFloor').textContent = tsr.bestFloor;
    document.getElementById('tsrClearCount').textContent = tsr.clearCount;
    
    // 更新难度选择界面
    updateDifficultyUI();
    
    // 更新当前冒险数据（仅在冒险进行时显示）
    if (tsr.currentRun.isActive) {
        const difficulty = tsr.difficulty.levels[tsr.currentRun.difficulty];
        const clearFloor = difficulty.clearFloor;
        const progress = Math.min(100, (tsr.currentRun.currentFloor / clearFloor) * 100);
        
        document.getElementById('tsrCurrentFloor').textContent = `${tsr.currentRun.currentFloor}/${clearFloor}`;
        document.getElementById('tsrTimeLeft').textContent = tsr.currentRun.timeLeft + '秒';
        document.getElementById('tsrTempBuffs').textContent = tsr.currentRun.tempBuffs.length + '个';
        document.getElementById('tsrCurrentCurrency').textContent = tsr.currentRun.currencyEarned;
        
        // 添加通关进度显示
        const progressElement = document.getElementById('tsrProgress');
        if (!progressElement) {
            // 如果进度条不存在，创建一个
            const statusDisplay = document.getElementById('tsrStatusDisplay');
            const progressHTML = `
                <div id="tsrProgress" style="margin-top: 10px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span>通关进度:</span>
                        <span>${tsr.currentRun.currentFloor}/${clearFloor} (${progress.toFixed(1)}%)</span>
                    </div>
                    <div style="background: #333; height: 10px; border-radius: 5px; overflow: hidden;">
                        <div style="background: linear-gradient(to right, #00bfff, #ffd700); height: 100%; width: ${progress}%; transition: width 0.3s;"></div>
                    </div>
                </div>
            `;
            statusDisplay.insertAdjacentHTML('beforeend', progressHTML);
        } else {
            // 更新现有进度条
            progressElement.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>通关进度:</span>
                    <span>${tsr.currentRun.currentFloor}/${clearFloor} (${progress.toFixed(1)}%)</span>
                </div>
                <div style="background: #333; height: 10px; border-radius: 5px; overflow: hidden;">
                    <div style="background: linear-gradient(to right, #00bfff, #ffd700); height: 100%; width: ${progress}%; transition: width 0.3s;"></div>
                </div>
            `;
        }
        
        updateCurrentRoomDisplay();
        updateBuffsDisplay();
        updateSkillsDisplay();
    }
}
// 难度选择函数
function selectTsrDifficulty(difficulty) {
    const tsr = player.timeSecretRealm;
    
    // 检查是否已解锁该难度
    if (!tsr.difficulty.unlocked.includes(difficulty)) {
        const condition = tsr.difficulty.levels[difficulty].unlockCondition;
        logAction(`尚未解锁${tsr.difficulty.levels[difficulty].name}难度！需要：${condition}`, 'error');
        return;
    }
    
    tsr.difficulty.current = difficulty;
    updateDifficultyUI();
    logAction(`已选择${tsr.difficulty.levels[difficulty].name}难度`, 'success');
}

// 更新难度UI显示
function updateDifficultyUI() {
    const tsr = player.timeSecretRealm;
    const difficulty = tsr.difficulty.levels[tsr.difficulty.current];
    
    // 更新按钮状态
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.style.opacity = '0.6';
        btn.style.transform = 'scale(0.95)';
        btn.style.boxShadow = 'none';
    });
    
    const currentBtn = document.getElementById(`difficulty${tsr.difficulty.current.charAt(0).toUpperCase() + tsr.difficulty.current.slice(1)}`);
    if (currentBtn) {
        currentBtn.style.opacity = '1';
        currentBtn.style.transform = 'scale(1.05)';
        currentBtn.style.boxShadow = '0 0 15px currentColor';
    }
    
    // 更新难度信息
    document.getElementById('difficultyDescription').innerHTML = `
        <strong>${difficulty.name}难度</strong>: ${difficulty.description}<br>
        <span style="color: #ff6b6b;">怪物强度: ${difficulty.multiplier}x</span> | 
        <span style="color: #ffd700;">奖励倍数: ${difficulty.rewardMultiplier}x</span><br>
        <span style="color: #00bfff;">通关要求: ${difficulty.clearFloor}层</span>
    `;
    
    // 更新解锁条件显示
    let unlockInfo = '<strong>已解锁难度:</strong> ';
    tsr.difficulty.unlocked.forEach((diff, index) => {
        unlockInfo += `${tsr.difficulty.levels[diff].name}${index < tsr.difficulty.unlocked.length - 1 ? ', ' : ''}`;
    });
    document.getElementById('difficultyUnlockCondition').innerHTML = unlockInfo;
}

// 检查难度解锁条件
function checkDifficultyUnlocks() {
    const tsr = player.timeSecretRealm;
    const levels = tsr.difficulty.levels;
    const unlocked = tsr.difficulty.unlocked;
    
    // 检查普通难度解锁
    if (!unlocked.includes('normal') && tsr.clearCount >= 3) {
        unlocked.push('normal');
        logAction('解锁了普通难度！', 'success');
    }
    
    // 检查困难难度解锁
    if (!unlocked.includes('hard') && tsr.clearCount >= 5) {
        unlocked.push('hard');
        logAction('解锁了困难难度！', 'success');
    }
    
    // 检查噩梦难度解锁
    if (!unlocked.includes('nightmare') && tsr.clearCount >= 10) {
        unlocked.push('nightmare');
        logAction('解锁了噩梦难度！', 'success');
    }
    
    // 检查地狱难度解锁
    if (!unlocked.includes('hell') && tsr.clearCount >= 20) {
        unlocked.push('hell');
        logAction('解锁了地狱难度！', 'success');
    }
    
    updateDifficultyUI();
}




// 开始时光秘境冒险
function startTimeSecretRealm() {
    if (player.items.fuben2 < 1) {
        alert("需要秘境钥匙大于1！");
        return;
    }
    const tsr = player.timeSecretRealm;
    const difficulty = tsr.difficulty.levels[tsr.difficulty.current];
    
    // 检查是否已选择难度
    if (!tsr.difficulty.current) {
        logAction("请先选择难度！", "error");
        return;
    }    
    // 消耗秘境钥匙
    player.items.fuben2--;
    // 隐藏难度选择界面
    document.getElementById('tsrDifficultySelection').style.display = 'none';
    document.getElementById('startTsrBtn').style.display = 'none';
    document.getElementById('openTsrShopBtn').style.display = 'none';
    
    // 计算基础时间（应用永久加成）
    const baseTime = 300 + (tsr.permanentBonuses?.baseTime || 0);
    const adjustedTime = Math.floor(baseTime * (1 / difficulty.multiplier));
    
    // 初始化当前冒险数据
    tsr.currentRun = {
        isActive: true,
        currentFloor: 1,
        difficulty: tsr.difficulty.current,
        difficultyMultiplier: difficulty.multiplier,
        rewardMultiplier: difficulty.rewardMultiplier,
        clearFloor: difficulty.clearFloor,
        timeLeft: adjustedTime, // 应用永久时间加成
        tempBuffs: [],
        currentRoom: null,
        exploredRooms: 0,
        currencyEarned: 0,
        playerHealth: calculateTsrPlayerHealth(),
        playerAttack: calculateTsrPlayerAttack(),
        consecutiveFloors: 0,
        lastAction: null
    };
    
    // 应用起始祝福效果
    applyStartingBuffs();
    
    // 生成第一个房间
    generateNewRoom();
    
    // 开始计时器
    startTsrTimer();
    
    // 显示冒险界面元素
    document.getElementById('tsrStatusDisplay').style.display = 'block';
    document.getElementById('tsrRoomDisplay').style.display = 'block';
    document.getElementById('tsrActionControls').style.display = 'block';
    document.getElementById('tsrBuffsDisplay').style.display = 'block';
    document.getElementById('tsrSkillsDisplay').style.display = 'block';
    document.getElementById('tsrHealthBar').style.display = 'block';
    
    // 更新界面
    updateTimeSecretRealmUI();
    updateHealthBar();
    
    // 添加开始日志
    addTsrLog(`=== ${difficulty.name}难度冒险开始 ===`);
    addTsrLog(`时间限制: ${tsr.currentRun.timeLeft}秒（基础${baseTime}秒 + 永久加成${tsr.permanentBonuses?.baseTime || 0}秒）`);
    addTsrLog(`怪物强度: ${difficulty.multiplier}x`);
    addTsrLog(`奖励倍数: ${difficulty.rewardMultiplier}x`);
    addTsrLog(`通关要求: ${difficulty.clearFloor}层`);
}
// 应用起始祝福效果
function applyStartingBuffs() {
    const tsr = player.timeSecretRealm;
    const startingBuffCount = tsr.permanentBonuses?.startingBuffs || 0;
    
    if (startingBuffCount <= 0) return;
    
    // 可用的起始增益类型
    const availableBuffTypes = ['attack', 'health', 'critRate', 'critDamage', 'speed'];
    
    for (let i = 0; i < startingBuffCount; i++) {
        // 随机选择一个增益类型
        const randomType = availableBuffTypes[Math.floor(Math.random() * availableBuffTypes.length)];
        const buff = getStartingBuffByType(randomType);
        
        if (buff) {
            addTempBuff(buff);
            addTsrLog(`起始祝福生效！获得${buff.name}`, 'success');
        }
    }
}

// 根据类型获取起始增益
function getStartingBuffByType(type) {
    const tsr = player.timeSecretRealm;
    const buffs = tsr.tempBuffs;
    
    switch(type) {
        case 'attack':
            return {
                name: '起始攻击强化',
                effect: 'attack',
                value: 0.3, // 起始效果稍弱
                timeBonus: 30,
                duration: 0,
                isDebuff: false
            };
        case 'health':
            return {
                name: '起始生命强化',
                effect: 'health',
                value: 0.3,
                timeBonus: 60,
                duration: 0,
                isDebuff: false
            };
        case 'critRate':
            return {
                name: '起始暴击强化',
                effect: 'critRate',
                value: 0.05,
                timeBonus: 90,
                duration: 0,
                isDebuff: false
            };
        case 'critDamage':
            return {
                name: '起始爆伤强化',
                effect: 'critDamage',
                value: 0.3,
                timeBonus: 120,
                duration: 0,
                isDebuff: false
            };
        case 'speed':
            return {
                name: '起始速度强化',
                effect: 'speed',
                value: 5,
                timeBonus: 150,
                duration: 0,
                isDebuff: false
            };
        default:
            return null;
    }
}
// 生成新房间
function generateNewRoom() {
    const tsr = player.timeSecretRealm;
    const difficultyMultiplier = tsr.currentRun.difficultyMultiplier;
    
    // 根据难度调整房间类型权重
    const roomWeights = {
        battle: Math.floor(40 * difficultyMultiplier), // 难度越高战斗房间越多
        event: 25,
        treasure: Math.floor(20 / difficultyMultiplier), // 难度越高宝箱越少
        rest: Math.floor(10 / difficultyMultiplier), // 难度越高休息房间越少
        shop: Math.floor(5 / difficultyMultiplier) // 难度越高商店越少
    };
    
    // 根据权重随机选择房间类型
    const totalWeight = Object.values(roomWeights).reduce((sum, weight) => sum + weight, 0);
    let randomValue = Math.random() * totalWeight;
    
    let selectedType = null;
    for (const [type, weight] of Object.entries(roomWeights)) {
        randomValue -= weight;
        if (randomValue <= 0) {
            selectedType = type;
            break;
        }
    }
    
    // 决定是否包含陷阱（难度越高陷阱越多）
    let hasTrap = false;
    let trap = null;
    if (selectedType !== 'rest' && Math.random() < (0.3 * difficultyMultiplier)) {
        hasTrap = true;
        trap = generateRandomTrap();
        // 难度越高陷阱越强
        if (trap.damageType === 'percentage' || trap.damageType === 'fixed') {
            trap.damage *= difficultyMultiplier;
        }
    }
    
    // 创建房间对象
    tsr.currentRun.currentRoom = {
        type: selectedType,
        name: tsr.roomTypes[selectedType].name,
        explored: false,
        hasTrap: hasTrap,
        trap: trap,
        trapDetected: false,
        trapDisarmed: false,
        rewards: generateRoomRewards(selectedType, difficultyMultiplier)
    };
    
    updateCurrentRoomDisplay();
}

// 生成随机陷阱
function generateRandomTrap() {
    const traps = player.timeSecretRealm.traps.types;
    const totalWeight = Object.values(traps).reduce((sum, trap) => sum + trap.weight, 0);
    let randomValue = Math.random() * totalWeight;
    
    for (const [trapType, config] of Object.entries(traps)) {
        randomValue -= config.weight;
        if (randomValue <= 0) {
            return {
                type: trapType,
                name: config.name,
                damageType: config.damageType,
                damage: config.damage,
                effect: config.effect,
                value: config.value,
                duration: config.duration
            };
        }
    }
    
    // 默认返回毒液陷阱
    return {
        type: 'poison',
        name: '毒液陷阱',
        damageType: 'percentage',
        damage: 0.15,
        duration: 3
    };
}

// 更新当前房间显示
function updateCurrentRoomDisplay() {
    const room = player.timeSecretRealm.currentRun.currentRoom;
    const container = document.getElementById('tsrCurrentRoom');
    
    if (!room) return;
    
    let roomContent = '';
    let roomColor = '#00bfff';
    
    switch(room.type) {
        case 'battle':
            roomContent = `
                <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间充满了危险的怪物...</div>
            `;
            roomColor = '#ff6b6b';
            break;
            
        case 'event':
            roomContent = `
                <div style="color: #00bfff; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间有一个神秘的事件...</div>
            `;
            roomColor = '#00bfff';
            break;
            
        case 'treasure':
            roomContent = `
                <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间有一个宝箱...</div>
            `;
            roomColor = '#ffd700';
            break;
            
        case 'rest':
            roomContent = `
                <div style="color: #32cd32; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间可以休息恢复...</div>
            `;
            roomColor = '#32cd32';
            break;
            
        case 'shop':
            roomContent = `
                <div style="color: #9370db; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间有一个神秘商店...</div>
            `;
            roomColor = '#9370db';
            break;
    }
    
    // 添加陷阱信息
    if (room.hasTrap && !room.trapDisarmed) {
        if (room.trapDetected) {
            roomContent += `
                <div style="margin-top: 10px; padding: 5px; background: rgba(255, 0, 0, 0.2); border: 1px solid #ff0000; border-radius: 3px;">
                    <div style="color: #ff6b6b; font-weight: bold;">⚠️ 发现陷阱: ${room.trap.name}</div>
                    <div style="font-size: 12px; color: #ff6b6b;">${getTrapDescription(room.trap)}</div>
                </div>
            `;
        } else {
            roomContent += `
                <div style="margin-top: 10px; padding: 5px; background: rgba(255, 165, 0, 0.2); border: 1px dashed #ffa500; border-radius: 3px;">
                    <div style="color: #ffa500; font-size: 12px;">⚠️ 这个房间可能有陷阱...</div>
                </div>
            `;
        }
    }
    
    // 添加奖励信息
    roomContent += `
        <div style="margin-top: 10px; color: ${roomColor};">
            奖励: ${room.rewards.currency}秘境币
        </div>
    `;
    
    container.innerHTML = roomContent;
    
    // 更新行动按钮
    updateActionButtons();
}
// 获取陷阱描述
function getTrapDescription(trap) {
    switch(trap.damageType) {
        case 'percentage':
            return `造成${(trap.damage * 100)}%生命值的伤害，持续${trap.duration}回合`;
        case 'fixed':
            return `造成${formatSci(trap.damage)}点固定伤害`;
        case 'debuff':
            return `${trap.effect === 'attack' ? '攻击力' : '暴击率'}降低${(trap.value * 100)}%，持续${trap.duration}回合`;
        case 'time':
            return `减少${trap.damage}秒探索时间`;
        case 'random':
            return `随机造成${(trap.damage * 100)}%生命值的伤害`;
        default:
            return '未知效果的陷阱';
    }
}
function updateActionButtons() {
    const actionContainer = document.getElementById('tsrActionControls');
    
    // 添加侦查和解除按钮
    actionContainer.innerHTML = `
        <button onclick="tsrDetectTrap()" id="tsrDetectBtn" style="display: none; background: linear-gradient(to bottom, #ffa500, #daa520); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">侦查陷阱</button>
        <button onclick="tsrDisarmTrap()" id="tsrDisarmBtn" style="display: none; background: linear-gradient(to bottom, #32cd32, #228b22); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">解除陷阱</button>
        <button onclick="tsrExploreRoom()" id="tsrExploreBtn" style="display: inline-block; background: linear-gradient(to bottom, #1e90ff, #006994); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">探索房间</button>
        <button onclick="tsrRest()" id="tsrRestBtn" style="background: linear-gradient(to bottom, #9370db, #6a5acd); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">休息恢复</button>
        <button onclick="tsrNextFloor()" id="tsrNextFloorBtn" style="background: linear-gradient(to bottom, #ffa500, #daa520); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">前往下一层</button>
        <button onclick="tsrExitRealm()" id="tsrExitBtn" style="background: linear-gradient(to bottom, #dc143c, #8b0000); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">退出秘境</button>
    `;
    
    // 更新按钮状态
    const room = player.timeSecretRealm.currentRun.currentRoom;
    const exploreBtn = document.getElementById('tsrExploreBtn');
    const detectBtn = document.getElementById('tsrDetectBtn');
    const disarmBtn = document.getElementById('tsrDisarmBtn');
    
    if (room.hasTrap && !room.trapDisarmed) {
        if (room.trapDetected) {
            exploreBtn.style.display = 'none';
            detectBtn.style.display = 'none';
            disarmBtn.style.display = 'inline-block';
        } else {
            exploreBtn.style.display = 'none';
            detectBtn.style.display = 'inline-block';
            disarmBtn.style.display = 'none';
        }
    } else {
        exploreBtn.style.display = 'inline-block';
        detectBtn.style.display = 'none';
        disarmBtn.style.display = 'none';
    }
}
// 更新增益效果显示
function updateBuffsDisplay() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrCurrentBuffs');
    container.innerHTML = '';
    
    if (!tsr.currentRun.tempBuffs || tsr.currentRun.tempBuffs.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; grid-column: 1 / -1;">无增益效果</div>';
        return;
    }
    
    tsr.currentRun.tempBuffs.forEach((buff, index) => {
        const buffElement = document.createElement('div');
        buffElement.style.cssText = `
            background: ${buff.isDebuff ? 'rgba(255, 0, 0, 0.2)' : 'rgba(0, 255, 0, 0.2)'};
            padding: 10px;
            border-radius: 5px;
            border: 1px solid ${buff.isDebuff ? '#ff6b6b' : '#32cd32'};
            position: relative;
        `;
        
        let effectText = '';
        let valueText = '';
        let effectDescription = '';
        
        // 修复：正确显示各种增益效果
        switch(buff.effect) {
            case 'attack':
                effectText = '攻击力';
                valueText = `${buff.value > 0 ? '+' : ''}${(buff.value * 100).toFixed(0)}%`;
                effectDescription = `攻击力提升${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'health':
                effectText = '生命值';
                valueText = `${buff.value > 0 ? '+' : ''}${(buff.value * 100).toFixed(0)}%`;
                effectDescription = `生命值提升${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'critRate':
                effectText = '暴击率';
                valueText = `${buff.value > 0 ? '+' : ''}${(buff.value * 100).toFixed(1)}%`;
                effectDescription = `暴击率提升${(buff.value * 100).toFixed(1)}%`;
                break;
            case 'critDamage':
                effectText = '爆伤';
                valueText = `${buff.value > 0 ? '+' : ''}${(buff.value * 100).toFixed(0)}%`;
                effectDescription = `爆伤提升${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'speed':
                effectText = '探索速度';
                valueText = `${buff.value > 0 ? '+' : ''}${buff.value}秒`;
                effectDescription = `探索时间减少${buff.value}秒`;
                break;
            case 'luck':
                effectText = '幸运';
                valueText = '双倍秘境币';
                effectDescription = '获得双倍秘境币';
                break;
            default:
                effectText = '未知效果';
                valueText = '';
                effectDescription = buff.name;
        }
        
        buffElement.innerHTML = `
            <div style="font-weight: bold; color: ${buff.isDebuff ? '#ff6b6b' : '#32cd32'}; margin-bottom: 5px;">
                ${buff.name}
            </div>
            <div style="font-size: 12px; color: ${buff.isDebuff ? '#ff6b6b' : '#32cd32'}; margin-bottom: 3px;">
                ${effectDescription}
            </div>
            ${buff.duration ? `
                <div style="font-size: 11px; color: #d8bfd8; margin-top: 5px;">
                    剩余: ${buff.duration}回合
                </div>
            ` : ''}
            ${buff.isDebuff ? `
                <div style="position: absolute; top: 5px; right: 5px; color: #ff6b6b;">⚠️</div>
            ` : `
                <div style="position: absolute; top: 5px; right: 5px; color: #32cd32;">✨</div>
            `}
        `;
        
        container.appendChild(buffElement);
    });
}
// 更新技能效果显示
function updateSkillsDisplay() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrCurrentSkills');
    container.innerHTML = '';
    
    const detectionSkill = tsr.traps.detectionSkills[tsr.traps.playerSkills.detection];
    const disarmSkill = tsr.traps.disarmSkills[tsr.traps.playerSkills.disarm];
    
    // 侦查技能显示
    const detectElement = document.createElement('div');
    detectElement.style.cssText = `
        background: rgba(0, 191, 255, 0.2);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #00bfff;
    `;
    
    detectElement.innerHTML = `
        <div style="font-weight: bold; color: #00bfff; margin-bottom: 5px;">
            ${detectionSkill.name}
        </div>
        <div style="font-size: 12px; color: #00bfff;">
            成功率: ${(detectionSkill.successRate * 100).toFixed(0)}%
        </div>
        <div style="font-size: 11px; color: #d8bfd8;">
            消耗: ${detectionSkill.cost}秒
        </div>
    `;
    
    // 解除技能显示
    const disarmElement = document.createElement('div');
    disarmElement.style.cssText = `
        background: rgba(50, 205, 50, 0.2);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #32cd32;
    `;
    
    disarmElement.innerHTML = `
        <div style="font-weight: bold; color: #32cd32; margin-bottom: 5px;">
            ${disarmSkill.name}
        </div>
        <div style="font-size: 12px; color: #32cd32;">
            成功率: ${(disarmSkill.successRate * 100).toFixed(0)}%
        </div>
        <div style="font-size: 11px; color: #d8bfd8;">
            消耗: ${disarmSkill.cost}秒
        </div>
    `;
    
    container.appendChild(detectElement);
    container.appendChild(disarmElement);
    
    // 如果有侦查加成，显示额外信息
    if (tsr.currentRun.detectionBoost) {
        const boostElement = document.createElement('div');
        boostElement.style.cssText = `
            background: rgba(255, 215, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ffd700;
        `;
        
        boostElement.innerHTML = `
            <div style="font-weight: bold; color: #ffd700; margin-bottom: 5px;">
                陷阱感知药水
            </div>
            <div style="font-size: 12px; color: #ffd700;">
                侦查成功率 +30%
            </div>
            <div style="font-size: 11px; color: #d8bfd8;">
                本次冒险有效
            </div>
        `;
        
        container.appendChild(boostElement);
    }
}
// 在每次行动后更新增益持续时间
function updateBuffDurations() {
    const tsr = player.timeSecretRealm;
    
    // 更新增益持续时间
    tsr.currentRun.tempBuffs = tsr.currentRun.tempBuffs.filter(buff => {
        if (buff.duration) {
            buff.duration--;
            return buff.duration > 0;
        }
        return true; // 没有持续时间的增益永久有效
    });
    
    // 更新显示
    updateBuffsDisplay();
}
// 在探索房间、战斗等行动后调用
function afterAction() {
    updateBuffDurations();
    updateTimeSecretRealmUI();
}
// 侦查陷阱
function tsrDetectTrap() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    
    if (!room.hasTrap || room.trapDetected) return;
    
    const skill = tsr.traps.detectionSkills[tsr.traps.playerSkills.detection];
    const success = Math.random() < skill.successRate;
    
    // 消耗时间
    tsr.currentRun.timeLeft -= skill.cost;
    
    if (success) {
        room.trapDetected = true;
        addTsrLog(`侦查成功！发现了${room.trap.name}`, 'success');
    } else {
        addTsrLog(`侦查失败！没有发现陷阱`, 'warning');
    }
    
    updateCurrentRoomDisplay();
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
    }
}

// 解除陷阱
function tsrDisarmTrap() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    
    if (!room.hasTrap || !room.trapDetected || room.trapDisarmed) return;
    
    const skill = tsr.traps.disarmSkills[tsr.traps.playerSkills.disarm];
    const success = Math.random() < skill.successRate;
    
    // 消耗时间
    tsr.currentRun.timeLeft -= skill.cost;
    
    if (success) {
        room.trapDisarmed = true;
        addTsrLog(`解除成功！安全解除了${room.trap.name}`, 'success');
        
        // 解除陷阱奖励
        const reward = 200 + Math.floor(Math.random() * 30);
        tsr.currentRun.currencyEarned += reward;
        addTsrLog(`获得${reward}秘境币作为解除陷阱的奖励`);
    } else {
        // 解除失败，触发陷阱
        addTsrLog(`解除失败！触发了${room.trap.name}`, 'error');
        triggerTrap(room.trap);
    }
    
    updateCurrentRoomDisplay();
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
    }
}

// 触发陷阱效果
function triggerTrap(trap) {
    const tsr = player.timeSecretRealm;
    
    switch(trap.damageType) {
        case 'percentage':
            const percentageDamage = Math.floor(tsr.currentRun.playerHealth * trap.damage);
            applyDamage(percentageDamage);
            addTsrLog(`受到${percentageDamage}点伤害（${trap.damage * 100}%生命值）`, 'error');
            break;
            
        case 'fixed':
            applyDamage(trap.damage);
            addTsrLog(`受到${formatSci(trap.damage)}点固定伤害`, 'error');
            break;
            
        case 'debuff':
            // 添加减益效果
            const debuff = {
                name: trap.name + '减益',
                effect: trap.effect,
                value: trap.value,
                duration: trap.duration,
                isDebuff: true
            };
            addTempBuff(debuff);
            addTsrLog(`${trap.effect === 'attack' ? '攻击力' : '暴击率'}降低${trap.value * 100}%，持续${trap.duration}回合`, 'warning');
            break;
            
        case 'time':
            tsr.currentRun.timeLeft -= trap.damage;
            addTsrLog(`时间减少${trap.damage}秒`, 'warning');
            break;
            
        case 'random':
            const randomDamage = Math.floor(tsr.currentRun.playerHealth * (Math.random() * trap.damage));
            applyDamage(randomDamage);
            addTsrLog(`受到${randomDamage}点随机伤害`, 'error');
            break;
    }
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
    }
}
// 更新血条显示
function updateHealthBar() {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun || !tsr.currentRun.isActive) return;
    
    const maxHealth = calculateTsrPlayerHealth();
    const currentHealth = tsr.currentRun.playerHealth;
    const healthPercentage = (currentHealth / maxHealth) * 100;
    
    // 更新血条
    const healthBar = document.getElementById('tsrHealthBarFill');
    const healthText = document.getElementById('tsrHealthText');
    const healthWarning = document.getElementById('tsrHealthWarning');
    
    if (healthBar && healthText) {
        healthBar.style.width = `${healthPercentage}%`;
        healthText.textContent = `${healthPercentage.toFixed(1)}% (${formatSci(currentHealth)}/${formatSci(maxHealth)})`;
        
        // 警告显示
        if (healthPercentage <= 30) {
            healthWarning.style.display = 'inline';
            healthBar.style.background = 'linear-gradient(to right, #ff4500, #8b0000)';
        } else if (healthPercentage <= 50) {
            healthWarning.style.display = 'none';
            healthBar.style.background = 'linear-gradient(to right, #ffa500, #ff4500)';
        } else {
            healthWarning.style.display = 'none';
            healthBar.style.background = 'linear-gradient(to right, #32cd32, #ffa500)';
        }
    }
}

// 检查生命值是否低于失败阈值（30%）
function checkHealthFailure() {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun || !tsr.currentRun.isActive) return false;
    
    const maxHealth = calculateTsrPlayerHealth();
    const currentHealth = tsr.currentRun.playerHealth;
    const healthPercentage = (currentHealth / maxHealth) * 100;
    
    // 生命值低于30%时失败
    if (healthPercentage < 30) {
        endTimeSecretRealm('生命值过低');
        return true;
    }
    
    return false;
}
function applyDamage(damage) {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun) return;
    
    tsr.currentRun.playerHealth -= damage;
    
    // 更新血条
    updateHealthBar();
    
    // 检查是否失败
    if (checkHealthFailure()) {
        return;
    }
    
    // 检查是否死亡
    if (tsr.currentRun.playerHealth <= 0) {
        endTimeSecretRealm('战斗失败');
        return;
    }
}
// 探索房间
function tsrExploreRoom() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    const difficultyMultiplier = tsr.currentRun.difficultyMultiplier;
    
    if (!room || room.explored) return;
    
    // 检查生命值是否过低
    if (checkHealthFailure()) {
        return;
    }
    
    room.explored = true;
    tsr.currentRun.exploredRooms++;
    tsr.currentRun.lastAction = 'explore';
    tsr.currentRun.consecutiveFloors = 0; // 重置连续层数
    
    // 消耗时间（难度越高消耗越多）
    const timeCost = Math.floor(10 * difficultyMultiplier);
    tsr.currentRun.timeLeft -= timeCost;
    
    // 如果有未解除的陷阱，触发它
    if (room.hasTrap && !room.trapDisarmed) {
        addTsrLog(`触发了${room.trap.name}！`, 'error');
        triggerTrap(room.trap);
        
        if (tsr.currentRun.playerHealth <= 0 || tsr.currentRun.timeLeft <= 0) {
            return;
        }
    }
    
    // 处理房间事件
    switch(room.type) {
        case 'battle':
            handleBattleRoom();
            break;
        case 'event':
            handleEventRoom();
            break;
        case 'treasure':
            handleTreasureRoom();
            break;
        case 'rest':
            handleRestRoom();
            break;
        case 'shop':
            handleShopRoom();
            break;
    }
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
        return;
    }
    
    updateTimeSecretRealmUI();
}



// 处理战斗房间
function handleBattleRoom() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    const difficultyMultiplier = tsr.currentRun.difficultyMultiplier;
    
    // 模拟战斗，难度越高成功率越低
    const baseSuccessRate = 0.7;
    const successRate = baseSuccessRate / difficultyMultiplier;
    const battleSuccess = Math.random() < successRate;
    
    if (battleSuccess) {
        // 战斗胜利，获得奖励（应用难度奖励倍数）
        const reward = Math.floor(room.rewards.currency * tsr.currentRun.rewardMultiplier);
        tsr.currentRun.currencyEarned += reward;
        
        addTsrLog(`战斗胜利！获得${reward}秘境币`, 'success');
        
        // 有几率获得临时强化（难度越高几率越低但效果更强）
        if (Math.random() < (0.2 / difficultyMultiplier)) {
            const buff = getRandomTempBuff();
            // 难度越高强化效果越强
            if (buff.value) {
                buff.value *= difficultyMultiplier;
            }
            // 确保增益包含时间奖励
            if (!buff.timeBonus) {
                buff.timeBonus = getTimeBonusByEffect(buff.effect);
            }
            addTempBuff(buff);
        }
    } else {
        // 战斗失败，受到伤害（难度越高伤害越大）
        const damage = Math.floor(tsr.currentRun.playerHealth * (0.2 * difficultyMultiplier));
        applyDamage(damage);
        addTsrLog(`战斗失败！受到${damage}点伤害`, 'error');
        
        if (tsr.currentRun.playerHealth <= 0) return;
    }
    
    afterAction();
}
// 修复增益效果应用验证函数
function validateBuffEffects() {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun || !tsr.currentRun.tempBuffs) return;
    
    console.log('当前增益效果:');
    tsr.currentRun.tempBuffs.forEach((buff, index) => {
        console.log(`${index + 1}. ${buff.name}: ${buff.effect} = ${buff.value}`);
    });
    
    console.log('计算后的属性:');
    console.log('攻击力:', calculateTsrPlayerAttack());
    console.log('爆伤:', calculateTsrPlayerCritDamage());
    console.log('暴击率:', calculateTsrPlayerCritRate());
    console.log('生命值:', calculateTsrPlayerHealth());
}

// 处理事件房间
function handleEventRoom() {
    const tsr = player.timeSecretRealm;
    
    // 随机事件
    const events = [
        { 
            name: '神秘祝福', 
            effect: () => {
                const buff = getRandomTempBuff();
                // 确保增益包含时间奖励
                if (!buff.timeBonus) {
                    buff.timeBonus = getTimeBonusByEffect(buff.effect);
                }
                addTempBuff(buff);
                return `获得了临时强化: ${buff.name}`;
            }
        },
        { 
            name: '时间扭曲', 
            effect: () => {
                const timeChange = Math.random() > 0.5 ? 30 : -20;
                tsr.currentRun.timeLeft += timeChange;
                return `时间${timeChange > 0 ? '增加' : '减少'}了${Math.abs(timeChange)}秒`;
            }
        },
        { 
            name: '财富降临', 
            effect: () => {
                const currency = 100 + Math.floor(Math.random() * 100);
                tsr.currentRun.currencyEarned += currency;
                return `获得了${currency}秘境币`;
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    const result = event.effect();
    afterAction();
    addTsrLog(`事件: ${event.name} - ${result}`);
}

// 辅助函数：根据增益效果获取时间奖励
function getTimeBonusByEffect(effect) {
    switch(effect) {
        case 'attack': return 30;
        case 'health': return 60;
        case 'critRate': return 90;
        case 'critDamage': return 120;
        case 'speed': return 150;
        default: return 0;
    }
}
function handleTreasureRoom() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    
    tsr.currentRun.currencyEarned += room.rewards.currency;
    addTsrLog(`打开了宝箱！获得${room.rewards.currency}秘境币`);
    
    // 有几率获得稀有奖励
    if (Math.random() < 0.1) {
        const rareCurrency = room.rewards.currency * 3;
        tsr.currentRun.currencyEarned += rareCurrency;
        addTsrLog(`发现隐藏宝藏！额外获得${rareCurrency}秘境币`);
    }
}

// 处理休息房间
function handleRestRoom() {
    const tsr = player.timeSecretRealm;
    
    // 恢复生命值
    const maxHealth = calculateTsrPlayerHealth();
    const healAmount = Math.floor(maxHealth * 0.3);
    tsr.currentRun.playerHealth = Math.min(maxHealth, tsr.currentRun.playerHealth + healAmount);
    
    addTsrLog(`休息恢复！恢复了${healAmount}点生命值`, 'success');
    updateHealthBar();
}


// 处理商店房间
function handleShopRoom() {
    const tsr = player.timeSecretRealm;
    
    // 随机提供2-3个临时强化购买选项
    const availableBuffs = Object.values(tsr.tempBuffs);
    const numOffers = 2 + Math.floor(Math.random() * 2); // 2-3个选项
    const offers = [];
    
    for (let i = 0; i < numOffers; i++) {
        const randomIndex = Math.floor(Math.random() * availableBuffs.length);
        const buff = availableBuffs[randomIndex];
        const cost = 100 + Math.floor(Math.random() * 50); // 50-100秘境币
        
        offers.push({
            buff: buff,
            cost: cost
        });
    }
    
    // 显示购买选项
    addTsrLog(`神秘商店提供以下强化:`);
    offers.forEach((offer, index) => {
        addTsrLog(`${index + 1}. ${offer.buff.name} - ${offer.cost}秘境币`);
    });
    
    // 存储当前商店信息
    tsr.currentRun.currentShop = offers;
    
    // 显示购买按钮
    showShopOptions(offers);
}

// 显示商店购买选项
function showShopOptions(offers) {
    const container = document.getElementById('tsrCurrentRoom');
    let optionsHTML = '<div style="margin-top: 10px;">';
    
    offers.forEach((offer, index) => {
        optionsHTML += `
            <button onclick="buyTsrBuff(${index})" style="background: #9370db; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin: 2px; font-size: 12px;">
                ${offer.buff.name} (${offer.cost}币)
            </button>
        `;
    });
    
    optionsHTML += '</div>';
    container.innerHTML += optionsHTML;
}

// 购买临时强化
function buyTsrBuff(index) {
    const tsr = player.timeSecretRealm;
    const offer = tsr.currentRun.currentShop[index];
    
    if (!offer) return;
    
    if (tsr.currentRun.currencyEarned >= offer.cost) {
        tsr.currentRun.currencyEarned -= offer.cost;
        
        // 确保增益包含时间奖励
        if (!offer.buff.timeBonus) {
            offer.buff.timeBonus = getTimeBonusByEffect(offer.buff.effect);
        }
        
        addTempBuff(offer.buff);
        
        addTsrLog(`购买了${offer.buff.name}，消耗${offer.cost}秘境币`);
        updateTimeSecretRealmUI();
    } else {
        addTsrLog(`秘境币不足！需要${offer.cost}秘境币，只有${tsr.currentRun.currencyEarned}秘境币`);
    }
}

// 休息恢复
function tsrRest() {
    const tsr = player.timeSecretRealm;
    
    // 消耗时间
    tsr.currentRun.timeLeft -= 15;
    
    // 恢复生命值
    const maxHealth = calculateTsrPlayerHealth();
    const healAmount = Math.floor(maxHealth * 0.5);
    tsr.currentRun.playerHealth = Math.min(maxHealth, tsr.currentRun.playerHealth + healAmount);
    
    addTsrLog(`休息恢复！恢复了${healAmount}点生命值，消耗15秒时间`);
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
        return;
    }
    
    updateTimeSecretRealmUI();
}

// 前往下一层
function tsrNextFloor() {
    const tsr = player.timeSecretRealm;
    const difficulty = tsr.difficulty.levels[tsr.currentRun.difficulty];
    const clearFloor = difficulty.clearFloor;
    const difficultyMultiplier = tsr.currentRun.difficultyMultiplier;
    
    // 检查是否连续前往下一层（惩罚机制）
    if (tsr.currentRun.lastAction === 'nextFloor') {
        tsr.currentRun.consecutiveFloors++;
        
        // 连续层数越多，惩罚越大
        const penalty = Math.min(5, tsr.currentRun.consecutiveFloors);
        const timePenalty = 30 + (penalty * 15); // 额外时间惩罚
        const healthPenalty = Math.floor(tsr.currentRun.playerHealth * (penalty * 0.05)); // 生命值惩罚
        
        tsr.currentRun.timeLeft -= timePenalty;
        tsr.currentRun.playerHealth -= healthPenalty;
        
        addTsrLog(`连续探索惩罚！时间减少${timePenalty}秒，生命值减少${healthPenalty}点`, 'warning');
        
        // 检查是否失败
        if (checkHealthFailure() || tsr.currentRun.timeLeft <= 0) {
            return;
        }
    } else {
        tsr.currentRun.consecutiveFloors = 0;
    }
    
    tsr.currentRun.lastAction = 'nextFloor';
    
    // 消耗时间（难度越高消耗越多）
    const timeCost = Math.floor(30 * difficultyMultiplier);
    tsr.currentRun.timeLeft -= timeCost;
    
    // 增加层数
    tsr.currentRun.currentFloor++;
    tsr.currentRun.exploredRooms = 0;
    
    // 更新最佳层数
    if (tsr.currentRun.currentFloor > tsr.bestFloor) {
        tsr.bestFloor = tsr.currentRun.currentFloor;
    }
    
    // 生成新房间（难度越高房间越难）
    generateNewRoom();
    
    // 检查是否达到通关要求
    if (tsr.currentRun.currentFloor >= clearFloor) {
        addTsrLog(`🎉 恭喜！已达到${clearFloor}层通关要求！`, 'success');
        addTsrLog(`继续前进可获得更多奖励，或随时退出获得通关奖励`);
    } else if (tsr.currentRun.currentFloor >= clearFloor * 0.8) {
        addTsrLog(`📈 当前层数: ${tsr.currentRun.currentFloor}/${clearFloor}，接近通关！`, 'info');
    } else if (tsr.currentRun.currentFloor >= clearFloor * 0.5) {
        addTsrLog(`📈 当前层数: ${tsr.currentRun.currentFloor}/${clearFloor}，已完成一半进度`, 'info');
    }
    
    addTsrLog(`进入了第${tsr.currentRun.currentFloor}层！消耗${timeCost}秒时间`);
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
        return;
    }
    
    updateTimeSecretRealmUI();
}

// 退出秘境
function tsrExitRealm() {
    endTimeSecretRealm('主动退出');
}

// 结束时光秘境冒险
function endTimeSecretRealm(reason) {
    const tsr = player.timeSecretRealm;
    const difficulty = tsr.difficulty.levels[tsr.currentRun.difficulty];
    const clearFloor = difficulty.clearFloor;
    
    // 检查是否通关（达到该难度的通关层数要求）
    const isCleared = tsr.currentRun.currentFloor >= clearFloor;
    
    if (isCleared && reason !== '战斗失败' && reason !== '时间耗尽' && reason !== '生命值过低') {
        tsr.clearCount++;
        addTsrLog(`恭喜！成功通关${difficulty.name}难度（达到${clearFloor}层）`, 'success');
        
        // 检查难度解锁
        checkDifficultyUnlocks();
        
        // 通关额外奖励
        const clearBonus = Math.floor(tsr.currentRun.currencyEarned * 0.5); // 50%额外奖励
        tsr.currentRun.currencyEarned += clearBonus;
        addTsrLog(`通关奖励！额外获得${clearBonus}秘境币`, 'success');
    }
    
    // 计算最终奖励
    let finalReward = tsr.currentRun.currencyEarned * tsr.currentRun.rewardMultiplier;
    finalReward *= tsr.currentRun.currentFloor;
    tsr.currency += finalReward;
    
    // 更新最佳层数
    if (tsr.currentRun.currentFloor > tsr.bestFloor) {
        tsr.bestFloor = tsr.currentRun.currentFloor;
    }
    
    // 记录结束日志
    addTsrLog(`=== ${difficulty.name}难度冒险结束 ===`);
    addTsrLog(`结束原因: ${reason}`);
    addTsrLog(`最终层数: ${tsr.currentRun.currentFloor}/${clearFloor}`);
    addTsrLog(`通关要求: ${clearFloor}层`);
    addTsrLog(isCleared ? '状态: 通关成功 ✓' : '状态: 未通关 ✗');
    addTsrLog(`获得秘境币: ${finalReward}`);
    addTsrLog(`总秘境币: ${tsr.currency}`);
    
    // 重置当前冒险
    tsr.currentRun.isActive = false;
    
    // 显示难度选择界面
    document.getElementById('tsrDifficultySelection').style.display = 'block';
    document.getElementById('startTsrBtn').style.display = 'inline-block';
    document.getElementById('openTsrShopBtn').style.display = 'inline-block';
    
    // 隐藏冒险界面元素
    document.getElementById('tsrStatusDisplay').style.display = 'none';
    document.getElementById('tsrRoomDisplay').style.display = 'none';
    document.getElementById('tsrActionControls').style.display = 'none';
    document.getElementById('tsrBuffsDisplay').style.display = 'none';
    document.getElementById('tsrSkillsDisplay').style.display = 'none';
    document.getElementById('tsrHealthBar').style.display = 'none';
    
    // 更新界面
    updateTimeSecretRealmUI();
    saveGame();
}
function initTimeSecretRealm() {
    const tsr = player.timeSecretRealm;
     // 初始化永久加成数据
    if (!tsr.permanentBonuses) {
        tsr.permanentBonuses = {
            baseTime: 0,
            startingBuffs: 0
        };
    }
    
    // 初始化商店物品购买记录
    Object.values(tsr.shopItems).forEach(item => {
        if (!item.purchased) {
            item.purchased = 0;
        }
    });
    if (!tsr.difficulty) {
        tsr.difficulty = {
            levels: {
                easy: { 
            name: '简单', 
            multiplier: 0.8, 
            rewardMultiplier: 0.7, 
            description: '适合新手玩家', 
            unlockCondition: '无',
            clearFloor: 10  // 通关层数要求
        },
        normal: { 
            name: '普通', 
            multiplier: 1.0, 
            rewardMultiplier: 1.0, 
            description: '标准难度', 
            unlockCondition: '通关简单难度3次',
            clearFloor: 15
        },
        hard: { 
            name: '困难', 
            multiplier: 1.5, 
            rewardMultiplier: 1.5, 
            description: '更具挑战性', 
            unlockCondition: '通关普通难度5次',
            clearFloor: 20
        },
        nightmare: { 
            name: '噩梦', 
            multiplier: 2.0, 
            rewardMultiplier: 2.5, 
            description: '极限挑战', 
            unlockCondition: '通关困难难度10次',
            clearFloor: 25
        },
        hell: { 
            name: '地狱', 
            multiplier: 3.0, 
            rewardMultiplier: 4.0, 
            description: '终极考验', 
            unlockCondition: '通关噩梦难度20次',
            clearFloor: 30
        }
            },
            current: 'easy', // 默认选择简单难度
            unlocked: ['easy']
        };
    }
    
    // 检查解锁条件
    checkDifficultyUnlocks();
    updateDifficultyUI();
}

// 开始秘境计时器
function startTsrTimer() {
    const tsr = player.timeSecretRealm;
    
    // 清除现有计时器
    if (tsr.timer) {
        clearInterval(tsr.timer);
    }
    
    // 每秒更新一次时间
    tsr.timer = setInterval(() => {
        if (tsr.currentRun.isActive) {
            tsr.currentRun.timeLeft--;
            
            // 更新界面显示
            document.getElementById('tsrTimeLeft').textContent = tsr.currentRun.timeLeft + '秒';
            
            // 检查时间是否用完
            if (tsr.currentRun.timeLeft <= 0) {
                endTimeSecretRealm('时间耗尽');
            }
        }
    }, 1000);
}


// 在玩家属性计算中应用增益效果
function calculateTsrPlayerHealth() {
    const baseHealth = player.battle.playerHealth || 1e4;
    
    // 应用临时强化
    let multiplier = 1;
    const tsr = player.timeSecretRealm;
    if (tsr.currentRun && tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs.forEach(buff => {
            if (buff.effect === 'health') {
                multiplier += buff.value;
            }
        });
    }
    
    return Math.floor(baseHealth * multiplier);
}

function calculateTsrPlayerAttack() {
    const baseAttack = player.battle.playerAttack || 1e4;
    
    // 应用临时强化
    let multiplier = 1;
    const tsr = player.timeSecretRealm;
    if (tsr.currentRun && tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs.forEach(buff => {
            if (buff.effect === 'attack') {
                multiplier += buff.value;
            }
        });
    }
    
    return Math.floor(baseAttack * multiplier);
}

function calculateTsrPlayerCritRate() {
    const baseCritRate = player.battle.playerCritRate || 0.1;
    
    // 应用临时强化
    let bonus = 0;
    const tsr = player.timeSecretRealm;
    if (tsr.currentRun && tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs.forEach(buff => {
            if (buff.effect === 'critRate') {
                bonus += buff.value;
            }
        });
    }
    
    return Math.min(0.9, baseCritRate + bonus);
}

function calculateTsrPlayerCritDamage() {
    const baseCritDamage = player.battle.playerCritDamage || 1.5;
    
    // 应用临时强化
    let multiplier = 1;
    const tsr = player.timeSecretRealm;
    if (tsr.currentRun && tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs.forEach(buff => {
            if (buff.effect === 'critDamage') {
                multiplier += buff.value;
            }
        });
    }
    
    return baseCritDamage * multiplier;
}

function updatePlayerStatsDisplay() {
    const tsr = player.timeSecretRealm;
    
    // 计算正确的属性值
    const playerHealth = calculateTsrPlayerHealth();
    const playerAttack = calculateTsrPlayerAttack();
    const playerCritRate = calculateTsrPlayerCritRate();
    const playerCritDamage = calculateTsrPlayerCritDamage();
    
    // 更新界面显示
    document.getElementById('penglaiPlayerHealth').textContent = formatSci(playerHealth);
    document.getElementById('penglaiPlayerAttack').textContent = formatSci(playerAttack);
    document.getElementById('penglaiPlayerCritRate').textContent = (playerCritRate * 100).toFixed(2) + '%';
    document.getElementById('penglaiPlayerCritDamage').textContent = (playerCritDamage * 100).toFixed(1) + '%';
    
    // 更新当前运行数据（用于战斗计算）
    if (tsr.currentRun) {
        tsr.currentRun.playerHealth = playerHealth;
        tsr.currentRun.playerAttack = playerAttack;
    }
}
function calculateBattleDamage() {
    const tsr = player.timeSecretRealm;
    const baseAttack = tsr.currentRun.playerAttack;
    const critRate = calculateTsrPlayerCritRate();
    const critDamage = calculateTsrPlayerCritDamage();
    
    // 计算是否暴击
    const isCrit = Math.random() < critRate;
    let damage = baseAttack;
    
    if (isCrit) {
        damage *= critDamage;
        addTsrLog('暴击！', 'success');
    }
    
    return {
        damage: damage,
        isCrit: isCrit
    };
}
// 修复增益效果应用函数
function applyBuffEffects() {
    const tsr = player.timeSecretRealm;
    
    // 重置基础属性
    tsr.currentRun.playerHealth = calculateTsrPlayerHealth();
    tsr.currentRun.playerAttack = calculateTsrPlayerAttack();
    
    // 应用特殊效果（如幸运加成）
    tsr.currentRun.hasLuckBuff = tsr.currentRun.tempBuffs.some(buff => buff.effect === 'luck');
    tsr.currentRun.hasSpeedBuff = tsr.currentRun.tempBuffs.some(buff => buff.effect === 'speed');
}

// 修复增益显示函数，确保数值正确
function updateBuffsDisplay() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrCurrentBuffs');
    container.innerHTML = '';
    
    if (!tsr.currentRun.tempBuffs || tsr.currentRun.tempBuffs.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; grid-column: 1 / -1;">无增益效果</div>';
        return;
    }
    
    tsr.currentRun.tempBuffs.forEach((buff, index) => {
        const buffElement = document.createElement('div');
        buffElement.style.cssText = `
            background: ${buff.isDebuff ? 'rgba(255, 0, 0, 0.2)' : 'rgba(0, 255, 0, 0.2)'};
            padding: 10px;
            border-radius: 5px;
            border: 1px solid ${buff.isDebuff ? '#ff6b6b' : '#32cd32'};
            position: relative;
        `;
        
        let effectText = '';
        let valueText = '';
        let timeBonusText = '';
        
        // 根据增益类型生成描述
        switch(buff.effect) {
            case 'attack':
                effectText = '攻击力';
                valueText = `${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'health':
                effectText = '生命值';
                valueText = `${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'critRate':
                effectText = '暴击率';
                valueText = `${(buff.value * 100).toFixed(1)}%`;
                break;
            case 'critDamage':
                effectText = '爆伤';
                valueText = `${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'speed':
                effectText = '探索速度';
                valueText = `+${buff.value}秒`;
                break;
            case 'luck':
                effectText = '幸运';
                valueText = '双倍秘境币';
                break;
            default:
                effectText = '未知效果';
                valueText = '';
        }
        
        // 添加时间奖励显示
        if (buff.timeBonus && buff.timeBonus > 0) {
            timeBonusText = `<div style="font-size: 11px; color: #00bfff; margin-top: 3px;">⏱️ +${buff.timeBonus}秒</div>`;
        }
        
        buffElement.innerHTML = `
            <div style="font-weight: bold; color: ${buff.isDebuff ? '#ff6b6b' : '#32cd32'}; margin-bottom: 5px;">
                ${buff.name}
            </div>
            <div style="font-size: 12px; color: ${buff.isDebuff ? '#ff6b6b' : '#32cd32'}; margin-bottom: 3px;">
                ${effectText}: +${valueText}
            </div>
            ${timeBonusText}
            ${buff.duration ? `
                <div style="font-size: 11px; color: #d8bfd8; margin-top: 5px;">
                    剩余: ${buff.duration}回合
                </div>
            ` : ''}
            ${buff.isDebuff ? `
                <div style="position: absolute; top: 5px; right: 5px; color: #ff6b6b;">⚠️</div>
            ` : `
                <div style="position: absolute; top: 5px; right: 5px; color: #32cd32;">✨</div>
            `}
        `;
        
        container.appendChild(buffElement);
    });
}
// 在战斗日志中显示增益效果变化
function addBuffChangeLog(buff, isGained) {
    let effectDescription = '';
    let timeBonusText = '';
    
    // 生成效果描述
    switch(buff.effect) {
        case 'attack':
            effectDescription = `攻击力提升${(buff.value * 100).toFixed(0)}%`;
            break;
        case 'health':
            effectDescription = `生命值提升${(buff.value * 100).toFixed(0)}%`;
            break;
        case 'critRate':
            effectDescription = `暴击率提升${(buff.value * 100).toFixed(1)}%`;
            break;
        case 'critDamage':
            effectDescription = `爆伤提升${(buff.value * 100).toFixed(0)}%`;
            break;
        case 'speed':
            effectDescription = `探索速度提升`;
            break;
        case 'luck':
            effectDescription = '获得双倍秘境币';
            break;
        default:
            effectDescription = buff.name;
    }
    
    // 添加时间奖励描述
    if (buff.timeBonus && buff.timeBonus > 0) {
        timeBonusText = `，探索时间+${buff.timeBonus}秒`;
    }
    
    if (isGained) {
        addTsrLog(`获得增益: ${buff.name} (${effectDescription}${timeBonusText})`, 'success');
    } else {
        addTsrLog(`增益消失: ${buff.name}`, 'warning');
    }
}
// 修改增益添加逻辑，添加日志
function addTempBuff(buff) {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs = [];
    }
    
    // 检查是否已存在相同类型的增益
    const existingBuffIndex = tsr.currentRun.tempBuffs.findIndex(b => b.effect === buff.effect);
    
    if (existingBuffIndex !== -1) {
        // 如果已存在，替换为新的增益
        tsr.currentRun.tempBuffs[existingBuffIndex] = buff;
    } else {
        // 如果不存在，添加新增益
        tsr.currentRun.tempBuffs.push(buff);
    }
    
    // 应用时间奖励
    if (buff.timeBonus && buff.timeBonus > 0) {
        tsr.currentRun.timeLeft += buff.timeBonus;
        addTsrLog(`获得${buff.timeBonus}秒探索时间奖励！`, 'success');
    }
    
    addBuffChangeLog(buff, true);
    updateBuffsDisplay();
    
    // 重新计算玩家属性
    tsr.currentRun.playerHealth = calculateTsrPlayerHealth();
    tsr.currentRun.playerAttack = calculateTsrPlayerAttack();
    updateHealthBar();
    
    // 更新界面显示
    updateTimeSecretRealmUI();
}
// 修改增益移除逻辑，添加日志
function removeExpiredBuffs() {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun.tempBuffs) return;
    
    const expiredBuffs = [];
    
    tsr.currentRun.tempBuffs = tsr.currentRun.tempBuffs.filter(buff => {
        if (buff.duration && buff.duration > 0) {
            buff.duration--;
            if (buff.duration <= 0) {
                expiredBuffs.push(buff);
                return false;
            }
        }
        return true;
    });
    
    expiredBuffs.forEach(buff => {
        addBuffChangeLog(buff, false);
    });
    
    // 重新计算玩家属性
    if (expiredBuffs.length > 0) {
        tsr.currentRun.playerHealth = calculateTsrPlayerHealth();
        tsr.currentRun.playerAttack = calculateTsrPlayerAttack();
        updateBuffsDisplay();
        updateHealthBar();
    }
}
// 生成房间奖励
function generateRoomRewards(roomType, difficultyMultiplier) {
    const baseRewards = {
        battle: { currency: 20, buffChance: 0.2 },
        event: { currency: 10, buffChance: 0.5 },
        treasure: { currency: 50, buffChance: 0.1 },
        rest: { currency: 0, buffChance: 0 },
        shop: { currency: 0, buffChance: 0 }
    };
    
    const reward = { ...baseRewards[roomType] };
    
    // 应用难度奖励倍数
    reward.currency = Math.floor(reward.currency * difficultyMultiplier);
    reward.buffChance *= difficultyMultiplier;
    
    return reward;
}


// 获取随机临时强化
function getRandomTempBuff() {
    const tsr = player.timeSecretRealm;
    const buffs = Object.values(tsr.tempBuffs);
    const randomBuff = buffs[Math.floor(Math.random() * buffs.length)];
    
    // 返回完整的buff对象，包含时间奖励
    return {
        name: randomBuff.name,
        effect: randomBuff.effect,
        value: randomBuff.value,
        timeBonus: randomBuff.timeBonus || getTimeBonusByEffect(randomBuff.effect),
        duration: randomBuff.duration || 0,
        isDebuff: false
    };
}

// 添加秘境日志
function addTsrLog(message) {
    const logContainer = document.getElementById('tsrBattleLog');
    const logEntry = document.createElement('div');
    logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logEntry.style.margin = '2px 0';
    logEntry.style.padding = '2px 5px';
    
    // 根据消息类型添加颜色
    if (message.includes('获得') || message.includes('恢复') || message.includes('幸运')) {
        logEntry.style.color = '#00ff00';
    } else if (message.includes('消耗') || message.includes('时间')) {
        logEntry.style.color = '#ffa500';
    } else if (message.includes('失败') || message.includes('伤害') || message.includes('死亡')) {
        logEntry.style.color = '#ff6b6b';
    } else if (message.includes('进入') || message.includes('开始') || message.includes('层')) {
        logEntry.style.color = '#00bfff';
    } else if (message.includes('购买') || message.includes('商店')) {
        logEntry.style.color = '#9370db';
    }
    
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

// 打开秘境商店
function openTsrShop() {
    const overlay = document.getElementById('tsrShopOverlay');
    const ui = document.getElementById('tsrShopUI');
    
    overlay.style.display = 'block';
    ui.style.display = 'block';
    
    updateTsrShop();
}

// 关闭秘境商店
function closeTsrShop() {
    document.getElementById('tsrShopOverlay').style.display = 'none';
    document.getElementById('tsrShopUI').style.display = 'none';
}

// 更新秘境商店
function updateTsrShop() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrShopItems');
    
    // 更新货币显示
    document.getElementById('tsrShopCurrency').textContent = tsr.currency.toFixed(0);
    
    // 清空容器
    container.innerHTML = '';
    
    // 添加商店物品
    Object.entries(tsr.shopItems).forEach(([key, item]) => {
        const itemElement = document.createElement('div');
        
        // 检查是否已达到购买上限
        const isMaxPurchased = item.maxPurchase && item.purchased >= item.maxPurchase;
        const purchaseInfo = item.maxPurchase ? 
            `（${item.purchased || 0}/${item.maxPurchase}）` : '';
        
        itemElement.style.cssText = `
            background: ${isMaxPurchased ? 'rgba(128,128,128,0.3)' : 'rgba(0,0,0,0.3)'};
            padding: 15px;
            border-radius: 5px;
            border: 1px solid ${isMaxPurchased ? '#666' : '#ffd700'};
            text-align: left;
            opacity: ${isMaxPurchased ? 0.6 : 1};
        `;
        
        itemElement.innerHTML = `
            <div style="font-weight: bold; color: ${isMaxPurchased ? '#666' : '#ffd700'}; margin-bottom: 5px;">
                ${item.name}${purchaseInfo}
            </div>
            <div style="font-size: 14px; color: ${isMaxPurchased ? '#888' : '#d8bfd8'}; margin-bottom: 10px;">
                ${item.description}
            </div>
            <div style="color: #00bfff;">价格: ${item.cost}秘境币</div>
            <button onclick="buyTsrShopItem('${key}')" 
                style="background: ${isMaxPurchased ? '#666' : 'linear-gradient(to bottom, #ffd700, #daa520)'}; 
                       color: ${isMaxPurchased ? '#999' : '#004d73'}; 
                       border: none; padding: 5px 10px; border-radius: 3px; 
                       cursor: ${isMaxPurchased ? 'not-allowed' : 'pointer'}; 
                       margin-top: 10px; font-weight: bold;"
                ${isMaxPurchased ? 'disabled' : ''}>
                ${isMaxPurchased ? '已售罄' : '购买'}
            </button>
            ${isMaxPurchased ? `
                <div style="color: #ff6b6b; font-size: 12px; margin-top: 5px;">
                    ⚠️ 已达到购买上限
                </div>
            ` : ''}
        `;
        
        container.appendChild(itemElement);
    });
    
    // 显示永久加成信息
    updatePermanentBonusesDisplay();
}

// 显示永久加成信息
function updatePermanentBonusesDisplay() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrPermanentBonuses');
    
    if (!tsr.permanentBonuses) {
        container.innerHTML = '<div style="color: #888; text-align: center;">暂无永久加成</div>';
        return;
    }
    
    let bonusesHTML = '<div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">永久加成效果:</div>';
    
    if (tsr.permanentBonuses.baseTime) {
        bonusesHTML += `
            <div style="color: #00bfff; margin: 5px 0;">
                ⏱️ 时间沙漏: +${tsr.permanentBonuses.baseTime}秒基础探索时间
            </div>
        `;
    }
    
    if (tsr.permanentBonuses.startingBuffs) {
        bonusesHTML += `
            <div style="color: #32cd32; margin: 5px 0;">
                ✨ 起始祝福: 每次冒险开始获得${tsr.permanentBonuses.startingBuffs}个随机增益
            </div>
        `;
    }
    
    container.innerHTML = bonusesHTML;
}

// 购买商店物品
function buyTsrShopItem(itemKey) {
    const tsr = player.timeSecretRealm;
    const item = tsr.shopItems[itemKey];
    
    if (!item) return;
    
    // 检查限购
    if (item.maxPurchase && item.purchased >= item.maxPurchase) {
        logAction(`${item.name}已达到购买上限（${item.maxPurchase}个）`, 'error');
        return;
    }
    
    if (tsr.currency >= item.cost) {
        tsr.currency -= item.cost;
        
        // 增加已购买数量
        if (item.maxPurchase) {
            item.purchased = (item.purchased || 0) + 1;
        }
        
        // 应用物品效果
        switch(item.effect) {
            case 'time':
                // 时间沙漏：永久增加基础探索时间
                if (!tsr.permanentBonuses) {
                    tsr.permanentBonuses = {};
                }
                tsr.permanentBonuses.baseTime = (tsr.permanentBonuses.baseTime || 0) + 60;
                logAction(`永久增加60秒基础探索时间！当前总加成：${tsr.permanentBonuses.baseTime}秒`, 'success');
                break;
                
            case 'startingBuff':
                // 起始祝福：每次冒险开始时获得随机增益
                if (!tsr.permanentBonuses) {
                    tsr.permanentBonuses = {};
                }
                tsr.permanentBonuses.startingBuffs = (tsr.permanentBonuses.startingBuffs || 0) + 1;
                logAction(`永久获得起始祝福！每次冒险开始时随机获得${tsr.permanentBonuses.startingBuffs}个增益效果`, 'success');
                break;
                
            case 'attack':
                player.attributes.attackBonus += 0.50;
                logAction(`临时攻击力提升50%！当前总加成：${(player.attributes.attackBonus * 100).toFixed(2)}%`, 'success');
                break;
                
            case 'health':
                player.attributes.healthBonus += 0.50;
                logAction(`临时生命值提升50%！当前总加成：${(player.attributes.healthBonus * 100).toFixed(2)}%`, 'success');
                break;
                
            case 'detection_advanced':
                tsr.traps.playerSkills.detection = 'advanced';
                logAction('侦查技能提升至高级！成功率60%', 'success');
                break;
                
            case 'detection_expert':
                tsr.traps.playerSkills.detection = 'expert';
                logAction('侦查技能提升至专家级！成功率80%', 'success');
                break;
                
            case 'disarm_advanced':
                tsr.traps.playerSkills.disarm = 'advanced';
                logAction('解除技能提升至高级！成功率70%', 'success');
                break;
                
            case 'disarm_expert':
                tsr.traps.playerSkills.disarm = 'expert';
                logAction('解除技能提升至专家级！成功率85%', 'success');
                break;
                
            case 'detection_boost':
                // 下次冒险侦查加成
                tsr.currentRun.detectionBoost = true;
                logAction('获得陷阱感知药水！下次冒险侦查成功率+30%', 'success');
                break;
                
            case 'material':
                player.items.yuzhou4 += 1000;
                logAction('获得1000个神器碎片', 'success');
                break;
        }
        
        // 标记物品为已解锁
        if (!tsr.unlockedItems.includes(itemKey)) {
            tsr.unlockedItems.push(itemKey);
        }
        
        logAction(`购买了${item.name}，消耗${item.cost}秘境币`, 'success');
        updateTsrShop();
        updateTimeSecretRealmUI();
        updateSkillsDisplay();
        saveGame();
    } else {
        logAction(`秘境币不足！需要${item.cost}秘境币，只有${tsr.currency}秘境币`, 'error');
    }
}
  // 种子属性
        const seedProperties = {
            "土豆": { price: 0, minWeight: 0.1, maxWeight: 10, color: "#8B4513" },
            "金桔": { price: 1000, minWeight: 0.1, maxWeight: 3, color: "#8B4513" },
            "牵牛花": { price: 3000, minWeight: 0.1, maxWeight: 5, color: "#9B59B6" },
            "无花果": { price: 5000, minWeight: 0.1, maxWeight: 5, color: "#9B59B6" },
            "黄瓜": { price: 9000, minWeight: 0.1, maxWeight: 6, color: "#27AE60" },
            "西瓜": { price: 30000, minWeight: 0.1, maxWeight: 7, color: "#2ECC71" },
            "猕猴桃": { price: 60000, minWeight: 0.1, maxWeight: 8, color: "#2ECC71" },
            "百合花": { price: 80000, minWeight: 0.1, maxWeight: 10, color: "#2ECC71" },
            "枣树": { price: 100000, minWeight: 0.1, maxWeight: 15, color: "#2ECC71" },
            "蓝莓": { price: 120000, minWeight: 0.1, maxWeight: 8, color: "#2ECC71" },
            "苹果": { price: 150000, minWeight: 0.1, maxWeight: 8, color: "#E74C3C" },
            "丝瓜": { price: 200000, minWeight: 0.1, maxWeight: 9, color: "#E74C3C" },
            "香蕉": { price: 300000, minWeight: 0.1, maxWeight: 10, color: "#F1C40F" },
            "哈密瓜": { price: 400000, minWeight: 0.1, maxWeight: 11, color: "#F1C40F" },
            "冰淇淋豆": { price: 500000, minWeight: 0.1, maxWeight: 12, color: "#F1C40F" },
            "南瓜": { price: 600000, minWeight: 0.1, maxWeight: 12, color: "#D35400" },
            "红茶": { price: 700000, minWeight: 0.1, maxWeight: 12, color: "#D35400" },
            "橙子": { price: 800000, minWeight: 0.1, maxWeight: 13, color: "#D35400" },
            "玫瑰花": { price: 900000, minWeight: 0.1, maxWeight: 13, color: "#D35400" },
            "茄子": { price: 1000000, minWeight: 0.1, maxWeight: 14, color: "#D35400" },
            "草莓": { price: 1200000, minWeight: 0.1, maxWeight: 15, color: "#E74C3C" },
            "芒果": { price: 1500000, minWeight: 0.1, maxWeight: 16, color: "#E74C3C" },
            "樱桃": { price: 2100000, minWeight: 0.1, maxWeight: 18, color: "#E74C3C" }, 
            "柚子": { price: 2400000, minWeight: 0.1, maxWeight: 19, color: "#E74C3C" }, 
            "向日葵": { price: 3000000, minWeight: 0.1, maxWeight: 20, color: "#F1C40F" },
            "松树": { price: 4000000, minWeight: 0.1, maxWeight: 22, color: "#F1C40F" },
            "茶树": { price: 5000000, minWeight: 0.1, maxWeight: 24, color: "#F1C40F" },
            "大王菊": { price: 6000000, minWeight: 0.1, maxWeight: 25, color: "#9B59B6" },
            "红袍梅": { price: 7000000, minWeight: 0.1, maxWeight: 26, color: "#9B59B6" },
            "火龙果": { price: 8000000, minWeight: 0.1, maxWeight: 22, color: "#9B59B6" },
            "柳树": { price: 9000000, minWeight: 0.1, maxWeight: 35, color: "#9B59B6" },
            "闫闫果": { price: 10000000, minWeight: 0.1, maxWeight: 29, color: "#9B59B6" },
            "菠萝": { price: 12000000, minWeight: 0.1, maxWeight: 31, color: "#9B59B6" },
            "葡萄": { price: 15000000, minWeight: 0.1, maxWeight: 30, color: "#8E44AD" },  
            "蟠桃": { price: 20000000, minWeight: 0.1, maxWeight: 30, color: "#8E44AD" },                       
            "惊奇菇": { price: 25000000, minWeight: 0.1, maxWeight: 50, color: "#8E44AD" },
            "红毛丹": { price: 30000000, minWeight: 0.1, maxWeight: 55, color: "#8E44AD" },
            "泡泡果": { price: 40000000, minWeight: 0.1, maxWeight: 50, color: "#8E44AD" },
            "人参树": { price: 50000000, minWeight: 0.1, maxWeight: 80, color: "#8E44AD" },
            "神秘果": { price: 100000000, minWeight: 0.1, maxWeight: 100, color: "#8E44AD" }
        };

        // 种子刷新概率
        const refreshProbabilities = {
            "土豆": 100,
            "牵牛花": 100,
            "黄瓜": 100,
            "金桔": 100,
            "无花果": 100,
            "西瓜": 20,
            "苹果": 20,
            "香蕉": 20,
            "丝瓜": 20,
            "哈密瓜": 20,
            "猕猴桃": 20,
            "百合花": 20,
            "蓝莓": 20,
            "冰淇淋豆": 10,
            "枣树": 10,
            "茄子": 10,
            "南瓜": 10,
            "橙子": 10,
            "红茶": 10,
            "玫瑰花": 5,
            "草莓": 5,
            "樱桃": 5,
            "芒果": 5,
            "柚子": 3,
            "向日葵": 3,            
            "松树": 3,
            "茶树": 3,
            "大王菊": 1,
            "柳树": 1,
            "红袍梅": 1,
            "火龙果": 1,
            "菠萝": 1,            
            "闫闫果": 1,
            "葡萄": 1,
            "蟠桃": 0.1,
            "惊奇菇": 0.1,
            "红毛丹": 0.1,
            "泡泡果": 0.1,
            "人参树": 0.1,
           "神秘果": 0.01
        };

        // 道具属性
        const itemProperties = {
            "普通浇水器": { 
                price: 2000, 
                color: "#3498db",
                refreshProbability: 100,
                description: "加速成长10分钟，如果没有特殊突变或者基础突变，2%几率特殊突变和基础突变"
            },
            "高级浇水器": { 
                price: 20000, 
                color: "#9b59b6",
                refreshProbability: 20,
                description: "加速成长20分钟，如果没有特殊突变或者基础突变，5%几率特殊突变和基础突变"
            },
            "超级浇水器": { 
                price: 100000, 
                color: "#e74c3c",
                refreshProbability: 5,
                description: "加速成长60分钟，如果没有特殊突变或者基础突变，10%几率特殊突变和基础突变"
            },
            "天气附加器": { 
                price: 500000, 
                color: "#f1c40f",
                refreshProbability: 1,
                description: "直接获得一个没有获得的天气突变"
            },
         "流星棒": { 
        price: 200000, 
        color: "#ff6b6b",
        refreshProbability: 3,
        description: "已有天气词条时，如果词条中无亮晶晶词条，则直接获得亮晶晶词条"
    },
    "火盆": { 
        price: 20000, 
        color: "#ff6b35",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无灼热词条，则直接获得灼热词条"
    },
    "吹风机": { 
        price: 200000, 
        color: "#4d96ff",
        refreshProbability: 3,
        description: "已有天气词条时，如果词条中无龙卷风词条，则直接获得龙卷风词条"
    },
    "避雷针": { 
        price: 200000, 
        color: "#ffd93d",
        refreshProbability: 2,
        description: "已有天气词条时，如果词条中无落雷词条，则直接获得落雷词条"
    },
    "雪球机": { 
        price: 20000, 
        color: "#6bc5ff",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无覆雪词条，则直接获得覆雪词条"
    },
    "催化器": { 
        price: 50000, 
        color: "#6bcf7f",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无生机词条，则直接获得生机词条"
    },
    "臭气弹": { 
        price: 50000, 
        color: "#8b5a2b",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无臭气词条，则直接获得臭气词条"
    },
    "生化弹": { 
        price: 50000, 
        color: "#6b8b3d",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无腐烂词条，则直接获得腐烂词条"
    },
    "雾霾制造器": { 
        price: 50000, 
        color: "#a9a9a9",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无迷雾词条，则直接获得迷雾词条"
    }
        };
// 突变倍率
        const mutationMultipliers = {
            // 灰色词条
            "潮湿": 1, "颤栗": 1, "生机": 1, "覆雪": 1,"腐烂": 1,
            "迷雾": 1, "灼热": 1, "沙尘": 1, "结霜": 1,"臭气": 1,
            // 绿色词条
            "银": 3, "落雷": 3, "冰冻": 3, "陶化": 3,
            // 蓝色词条
            "金": 10, "荧光": 10, "彩虹": 10,"龙卷风": 10,
            // 紫色词条
            "星环": 15, "瓷化": 15, "亮晶晶": 15, "台风": 15,
            // 金色词条
            "水晶": 20, "红月": 20, "陨石": 20,
            // 彩色词条
            "流光": 25, "霓虹": 25, "渡劫": 25
        };

        // 特殊突变
        const specialMutations = {
            "土豆": "薯片",
            "黄瓜": "黄瓜蛇",
            "西瓜": "方形",
            "金桔": "桔王",
            "无花果": "芜湖",
            "苹果": "糖葫芦",
            "枣树": "大枣王",
            "香蕉": "橡胶猴",
            "丝瓜": "丝雨",
            "茄子": "巨无霸",
            "红茶": "冰红茶",
            "草莓": "连体",
            "哈密瓜": "哈批",
            "樱桃": "双胞胎",
            "猕猴桃": "齐天大圣",
            "冰淇淋豆": "冰淇淋",
            "向日葵": "海绵宝宝",
            "大王菊": "超人菊", 
            "红袍梅": "红袍尊者",
            "玫瑰花": "爱心",
            "柚子": "柚水",
            "蓝莓": "蓝颜知己",
            "百合花": "友情",
            "惊奇菇": "奥特曼",
            "葡萄": "菩提祖师",
            "松树": "三只松鼠",
            "茶树": "茶茶萝莉",
            "蟠桃": "仙桃",
           "红毛丹": "仙丹",
           "闫闫果": "小闫闫",
           "人参树": "人参果",
           "菠萝": "菠萝吹雪",
            "泡泡果": "泡神",
             "柳树": "柳神",
           "火龙果": "火龙真身",
           "神秘果": "未来之心",
            "南瓜": "万圣节"
        };

        // 天气列表
        const weatherList = [
            "潮湿", "颤栗", "生机", "覆雪", "迷雾","冰冻", "陶化", "瓷化","臭气",
            "灼热", "沙尘", "结霜", "落雷", "荧光","龙卷风","台风","腐烂",
            "彩虹", "星环", "亮晶晶", "霓虹", "红月", "渡劫", "陨石"
        ];

        // 天气突变颜色映射
        const weatherMutationColors = {
            "潮湿": "grey",      // 灰色
            "腐烂": "grey", 
            "臭气": "grey", 
            "颤栗": "grey",    // 灰色
            "生机": "grey",     // 灰色
            "覆雪": "grey",           // 灰色
            "迷雾": "grey",           // 灰色
            "灼热": "grey",         // 灰色
            "沙尘": "grey",         // 灰色
            "结霜": "grey",     // 灰色
            "落雷": "green",          // 绿色
            "冰冻": "green", 
            "陶化": "green", 
            "荧光": "blue",           // 蓝色
            "龙卷风": "blue",  
            "彩虹": "rainbow",        // 彩虹色
            "星环": "purple",         // 紫色
            "瓷化": "purple",  
            "亮晶晶": "purple",
            "台风": "purple",  
            "霓虹": "rainbow",        // 彩虹色
            "渡劫": "rainbow",
            "陨石": "gold", 
            "红月": "gold"           // 金色
                    };

        // 疯狂地主游戏控制函数
        function toggleLandlordGame() {
        if (player.battle.maxStage < 2) {
        alert("需要打怪模式达到第3层才能开启疯狂地主！");
        return;
    }
            const ui = document.getElementById('landlordUI');
            if (ui.style.display === 'block') {
                closeLandlordGame();
            } else {
                openLandlordGame();
            }
        }

        function openLandlordGame() {
            const ui = document.getElementById('landlordUI');
            ui.style.display = 'block';
            initLandlordGame();
        }

        function closeLandlordGame() {
            const ui = document.getElementById('landlordUI');
            ui.style.display = 'none';
            saveGame(); // 关闭时保存游戏
        }

        // 初始化疯狂地主游戏
        function initLandlordGame() {
            refreshLandlordStore();
            refreshLandlordItemStore();
            updateLandlordWeather();
            renderAllLandlordUI();
            startLandlordTimers();
            
            // 检查离线收益
            checkLandlordOfflineEarnings();
        }

        // 刷新种子商店
        function refreshLandlordStore() {
            const now = Date.now();
            const timeSinceRefresh = now - player.landlord.lastSeedRefreshTime;
            
            // 每10分钟刷新一次
            if (timeSinceRefresh >= 10 * 60 * 1000) {
                player.landlord.storeItems = {};
                
                for (const seed in refreshProbabilities) {
                    if (Math.random() * 100 < refreshProbabilities[seed]) {
                        player.landlord.storeItems[seed] = 1; // 库存1个
                    } else {
                        player.landlord.storeItems[seed] = 0; // 无库存
                    }
                }
                
                player.landlord.lastSeedRefreshTime = now;
                showLandlordNotification("种子商店已刷新！", "info");
            }
            
            renderLandlordStore();
        }

        // 刷新道具商店
        function refreshLandlordItemStore() {
            const now = Date.now();
            const timeSinceRefresh = now - player.landlord.lastItemRefreshTime;
            
            // 每10分钟刷新一次
            if (timeSinceRefresh >= 10 * 60 * 1000) {
                player.landlord.itemStoreItems = {};
                
                for (const item in itemProperties) {
                    const probability = itemProperties[item].refreshProbability;
                    if (Math.random() * 100 < probability) {
                        player.landlord.itemStoreItems[item] = 1; // 库存1个
                    } else {
                        player.landlord.itemStoreItems[item] = 0; // 无库存
                    }
                }
                
                player.landlord.lastItemRefreshTime = now;
                showLandlordNotification("道具商店已刷新！", "info");
            }
            
            renderLandlordItemStore();
        }

        // 购买种子
        function buyLandlordSeed(seedName) {
            const seed = seedProperties[seedName];
            
            if (!seed) {
                showLandlordNotification("种子不存在！", "error");
                return;
            }
            
            if (player.landlord.storeItems[seedName] <= 0) {
                showLandlordNotification("该种子已售罄！", "error");
                return;
            }
            
            if (player.landlord.coins < seed.price) {
                showLandlordNotification("地主币不足！", "error");
                return;
            }
            
            // 扣除货币
            player.landlord.coins -= seed.price;
            
            // 添加到种子仓库
            if (!player.landlord.seedStorage[seedName]) {
                player.landlord.seedStorage[seedName] = 0;
            }
            player.landlord.seedStorage[seedName]++;
            
            // 减少库存
            player.landlord.storeItems[seedName]--;
            
            // 更新显示
            updateLandlordCoinDisplay();
            renderLandlordStore();
            renderLandlordSeedStorage();
            
            showLandlordNotification(`成功购买${seedName}种子！`, "success");
            saveGame();
        }

        // 购买道具
        function buyLandlordItem(itemName) {
            const item = itemProperties[itemName];
            
            if (!item) {
                showLandlordNotification("道具不存在！", "error");
                return;
            }
            
            if (player.landlord.itemStoreItems[itemName] <= 0) {
                showLandlordNotification("该道具已售罄！", "error");
                return;
            }
            
            if (player.landlord.coins < item.price) {
                showLandlordNotification("地主币不足！", "error");
                return;
            }
            
            // 扣除货币
            player.landlord.coins -= item.price;
            
            // 添加到道具仓库
            if (!player.landlord.itemStorage[itemName]) {
                player.landlord.itemStorage[itemName] = 0;
            }
            player.landlord.itemStorage[itemName]++;
            
            // 减少库存
            player.landlord.itemStoreItems[itemName]--;
            
            // 更新显示
            updateLandlordCoinDisplay();
            renderLandlordItemStore();
            renderLandlordItemStorage();
            
            showLandlordNotification(`成功购买${itemName}！`, "success");
            saveGame();
        }

        // 选择种子种植
        function selectLandlordSeedForPlanting(fieldIndex) {
            player.landlord.selectedFieldIndex = fieldIndex;
            
            // 打开种子选择模态框
            const modal = document.getElementById('landlordSeedModal');
            const content = document.getElementById('landlordSeedModalContent');
            
            content.innerHTML = '';
            
            for (const seedName in player.landlord.seedStorage) {
                if (player.landlord.seedStorage[seedName] > 0) {
                    const seedDiv = document.createElement('div');
                    seedDiv.className = 'landlord-seed-item';
                    seedDiv.style.cursor = 'pointer';
                    seedDiv.style.marginBottom = '10px';
                    seedDiv.onclick = () => plantLandlordSeed(fieldIndex, seedName);
                    
                    const seedColor = seedProperties[seedName].color;
                    
                    seedDiv.innerHTML = `
                        <div class="landlord-seed-icon" style="background: ${seedColor};">${seedName.charAt(0)}</div>
                        <div>${seedName}</div>
                        <div>库存: ${player.landlord.seedStorage[seedName]}</div>
                    `;
                    
                    content.appendChild(seedDiv);
                }
            }
            
            if (content.children.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 20px;">种子仓库为空</div>';
            }
            
            modal.style.display = 'block';
        }

        // 关闭种子选择模态框
        function closeLandlordSeedModal() {
            document.getElementById('landlordSeedModal').style.display = 'none';
            player.landlord.selectedFieldIndex = null;
        }

        // 选择道具使用
        function selectLandlordItemForUsing(fieldIndex) {
            player.landlord.selectedFieldIndex = fieldIndex;
            
            // 打开道具选择模态框
            const modal = document.getElementById('landlordItemModal');
            const content = document.getElementById('landlordItemModalContent');
            
            content.innerHTML = '';
            
            for (const itemName in player.landlord.itemStorage) {
                if (player.landlord.itemStorage[itemName] > 0) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'landlord-item-item';
                    itemDiv.style.cursor = 'pointer';
                    itemDiv.style.marginBottom = '10px';
                    itemDiv.onclick = () => useLandlordItem(fieldIndex, itemName);
                    
                    const itemColor = itemProperties[itemName].color;
                    const itemDesc = itemProperties[itemName].description;
                    
                    itemDiv.innerHTML = `
                        <div class="landlord-item-icon" style="background: ${itemColor};">${itemName.charAt(0)}</div>
                        <div>${itemName}</div>
                        <div style="font-size: 0.8em; color: #7f8c8d; margin: 5px 0;">${itemDesc}</div>
                        <div>库存: ${player.landlord.itemStorage[itemName]}</div>
                    `;
                    
                    content.appendChild(itemDiv);
                }
            }
            
            if (content.children.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 20px;">道具仓库为空</div>';
            }
            
            modal.style.display = 'block';
        }

        // 关闭道具选择模态框
        function closeLandlordItemModal() {
            document.getElementById('landlordItemModal').style.display = 'none';
            player.landlord.selectedFieldIndex = null;
        }

        // 种植种子
        function plantLandlordSeed(fieldIndex, seedName) {
            if (!player.landlord.seedStorage[seedName] || player.landlord.seedStorage[seedName] <= 0) {
                showLandlordNotification("种子不足！", "error");
                closeLandlordSeedModal();
                return;
            }
            
            if (player.landlord.fields[fieldIndex] !== null) {
                showLandlordNotification("地块已被占用！", "error");
                closeLandlordSeedModal();
                return;
            }
            
            // 消耗种子
            player.landlord.seedStorage[seedName]--;
            
            // 创建新植物
            const plant = createNewLandlordPlant(seedName);
            
            // 放置到田地
            player.landlord.fields[fieldIndex] = plant;
            
            // 更新统计
            player.landlord.stats.totalPlants++;
            
            // 更新显示
            renderLandlordFields();
            renderLandlordSeedStorage();
            closeLandlordSeedModal();
            
            showLandlordNotification(`${seedName}已种植！`, "success");
            saveGame();
        }

        // 使用道具
        function useLandlordItem(fieldIndex, itemName) {
            const plant = player.landlord.fields[fieldIndex];
            
            if (!plant) {
                showLandlordNotification("地块为空，无法使用道具！", "error");
                closeLandlordItemModal();
                return;
            }
            
            if (!player.landlord.itemStorage[itemName] || player.landlord.itemStorage[itemName] <= 0) {
                showLandlordNotification("道具不足！", "error");
                closeLandlordItemModal();
                return;
            }
            
            // 消耗道具
            player.landlord.itemStorage[itemName]--;
            
            // 应用道具效果
            let effectMessage = applyLandlordItemEffect(plant, itemName);
            
            // 更新统计
            player.landlord.stats.itemsUsed++;
            
            // 更新显示
            renderLandlordFields();
            renderLandlordItemStorage();
            closeLandlordItemModal();
            
            showLandlordNotification(`使用${itemName}成功！${effectMessage}`, "success");
            saveGame();
        }

        // 应用道具效果
        function applyLandlordItemEffect(plant, itemName) {
            let effectMessage = "";
            
            switch(itemName) {
                case "普通浇水器":
                    // 加速成长5分钟
                    const acceleratedTime1 = Date.now() - 10 * 60 * 1000;
                    plant.plantedAt = Math.min(plant.plantedAt, acceleratedTime1);
                    effectMessage = "生长加速10分钟！";
                    
                    // 如果没有特殊突变或者基础突变，2%几率特殊突变和基础突变
                    if (plant.mutations.length === 0 && !plant.specialMutation) {
                        if (Math.random() * 100 < 2) {
                            applyLandlordBasicMutation(plant);
                            effectMessage += " 触发了基础突变！";
                        }
                    }
                    break;
                    
                case "高级浇水器":
                    // 加速成长15分钟
                    const acceleratedTime2 = Date.now() - 20 * 60 * 1000;
                    plant.plantedAt = Math.min(plant.plantedAt, acceleratedTime2);
                    effectMessage = "生长加速20分钟！";
                    
                    // 如果没有特殊突变或者基础突变，5%几率特殊突变和基础突变
                    if (plant.mutations.length === 0 && !plant.specialMutation) {
                        if (Math.random() * 100 < 5) {
                            applyLandlordBasicMutation(plant);
                            effectMessage += " 触发了基础突变！";
                        }
                    }
                    break;
                    
                case "超级浇水器":
                    // 加速成长30分钟
                    const acceleratedTime3 = Date.now() - 60 * 60 * 1000;
                    plant.plantedAt = Math.min(plant.plantedAt, acceleratedTime3);
                    effectMessage = "生长加速60分钟！";
                    
                    // 如果没有特殊突变或者基础突变，10%几率特殊突变和基础突变
                    if (plant.mutations.length === 0 && !plant.specialMutation) {
                        if (Math.random() * 100 < 10) {
                            applyLandlordBasicMutation(plant);
                            effectMessage += " 触发了基础突变！";
                        }
                    }
                    break;
                    
                case "天气附加器":
                    // 直接获得一个没有获得的天气突变
                    const availableWeathers = weatherList.filter(weather => 
                        !plant.weatherMutations.includes(weather)
                    );
                    
                    if (availableWeathers.length > 0) {
                        const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                        plant.weatherMutations.push(randomWeather);
                        player.landlord.stats.weatherMutations++;
                        effectMessage = `获得了${randomWeather}天气突变！`;
                    } else {
                        effectMessage = "已拥有所有天气突变！";
                    }
                    break;
            case "流星棒":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("亮晶晶")) {
                    plant.weatherMutations.push("亮晶晶");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了亮晶晶词条！";
                } else {
                    effectMessage = "已有亮晶晶词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "火盆":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("灼热")) {
                    plant.weatherMutations.push("灼热");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了灼热词条！";
                } else {
                    effectMessage = "已有灼热词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "吹风机":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("龙卷风")) {
                    plant.weatherMutations.push("龙卷风");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了龙卷风词条！";
                } else {
                    effectMessage = "已有龙卷风词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "避雷针":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("落雷")) {
                    plant.weatherMutations.push("落雷");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了落雷词条！";
                } else {
                    effectMessage = "已有落雷词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "雪球机":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("覆雪")) {
                    plant.weatherMutations.push("覆雪");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了覆雪词条！";
                } else {
                    effectMessage = "已有覆雪词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "催化器":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("生机")) {
                    plant.weatherMutations.push("生机");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了生机词条！";
                } else {
                    effectMessage = "已有生机词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "臭气弹":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("臭气")) {
                    plant.weatherMutations.push("臭气");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了臭气词条！";
                } else {
                    effectMessage = "已有臭气词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "生化弹":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("腐烂")) {
                    plant.weatherMutations.push("腐烂");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了腐烂词条！";
                } else {
                    effectMessage = "已有腐烂词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "雾霾制造器":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("迷雾")) {
                    plant.weatherMutations.push("迷雾");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了迷雾词条！";
                } else {
                    effectMessage = "已有迷雾词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            }
            
            return effectMessage;
        }

        // 创建新植物
        function createNewLandlordPlant(seedName) {
            // 计算重量
            const maxWeight = seedProperties[seedName].maxWeight;
            let weight = calculateLandlordWeight(maxWeight);
            
            // 计算生长时间（10分钟基础 + 每kg加1分钟）
            const growTime = 10 + Math.floor(weight);
            
            // 创建植物对象
            const plant = {
                type: seedName,
                weight: weight,
                plantedAt: Date.now(),
                growTime: growTime, // 分钟
                mutations: [], // 基础突变
                weatherMutations: [], // 天气突变
                specialMutation: false, // 特殊突变
                isMature: false
            };
            
            // 应用基础突变
            applyLandlordBasicMutation(plant);
            
            return plant;
        }

        // 计算重量
        function calculateLandlordWeight(maxWeight) {
            const random = Math.random() * 100;
            let weightPercentage;
            
            if (random < 80) {
                weightPercentage = 0.05 + Math.random() * 0.05; // 5%-10%
            } else if (random < 92) {
                weightPercentage = 0.1 + Math.random() * 0.2; // 10%-30%
            } else if (random < 96) {
                weightPercentage = 0.3 + Math.random() * 0.5; // 30%-80%
            } else if (random < 99) {
                weightPercentage = 0.5 + Math.random() * 0.5; // 50%-100%
            } else {
                weightPercentage = Math.random(); // 0-100%
            }
            
            // 确保重量在最小值和最大值之间
            const minWeight = 0.1;
            return Math.max(minWeight, Math.min(maxWeight, maxWeight * weightPercentage));
        }

        // 应用基础突变
        function applyLandlordBasicMutation(plant) {
            const random = Math.random() * 100;
            
            if (random < 80) {
                // 无突变
            } else if (random < 93) {
                plant.mutations.push("银");
                player.landlord.stats.basicMutations++;
            } else if (random < 97) {
                plant.mutations.push("金");
                player.landlord.stats.basicMutations++;
            } else if (random < 99) {
                plant.mutations.push("水晶");
                player.landlord.stats.basicMutations++;
            } else {
                plant.mutations.push("流光");
                player.landlord.stats.basicMutations++;
            }
            
            // 检查特殊突变 (5%几率)
            if (Math.random() * 100 < 5) {
                plant.specialMutation = true;
                player.landlord.stats.specialMutations++;
            }
        }

        // 收获植物
       function harvestLandlordPlant(fieldIndex) {
            const plant = player.landlord.fields[fieldIndex];
            
            if (!plant || !plant.isMature) {
                showLandlordNotification("植物尚未成熟！", "error");
                return;
            }
            
            // 计算价格
            const value = calculateLandlordPlantValue(plant);
            
            // 添加到果实仓库
            const fruit = {
                type: plant.type,
                weight: plant.weight,
                value: value,
                mutations: [...plant.mutations],
                weatherMutations: [...plant.weatherMutations],
                specialMutation: plant.specialMutation,
                harvestedAt: new Date().toLocaleString('zh-CN', { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                }),
                harvestedTimestamp: Date.now(),
                isLocked: false  // 添加锁定状态，默认为未锁定
            };
            
            // 检查仓库容量
            if (player.landlord.fruitStorage.length >= 200) {
                showLandlordNotification("果实仓库已满！", "error");
                return;
            }
            
            player.landlord.fruitStorage.push(fruit);
            
            // 重新生成一个新植物（同种类，但重量和突变重新随机）
            const newPlant = createNewLandlordPlant(plant.type);
            
            // 注意：收获后天气突变重置，不复制旧植物的天气突变
            
            // 替换地块上的植物
            player.landlord.fields[fieldIndex] = newPlant;
            
            // 更新统计
            player.landlord.stats.totalHarvests++;
            player.landlord.stats.totalCoinsEarned += value;
            
            // 更新最高倍率
            const multiplier = calculateLandlordMultiplier(plant);
            if (multiplier > player.landlord.stats.highestMultiplier) {
                player.landlord.stats.highestMultiplier = multiplier;
            }
            
            // 更新显示
            renderLandlordFields();
            renderLandlordFruitStorage();
            updateLandlordStats();
            
            showLandlordNotification(`收获${plant.type}，价值${formatNumber(value)}地主币！`, "success");
            saveGame();
        }

        // 铲除植物
        function removeLandlordPlant(fieldIndex) {
            if (!player.landlord.fields[fieldIndex]) {
                showLandlordNotification("地块为空！", "error");
                return;
            }
            
            player.landlord.fields[fieldIndex] = null;
            
            renderLandlordFields();
            showLandlordNotification("植物已移除！", "info");
            saveGame();
        }

        // 计算植物价值
        function calculateLandlordPlantValue(plant) {
            const seedPrice = seedProperties[plant.type].price;
            
            // 基础价格
            const basePrice = (1 + (seedPrice / 100)) * plant.weight;
            
            // 基础突变倍率
            let basicMultiplier = 1;
            plant.mutations.forEach(mutation => {
                basicMultiplier *= (mutationMultipliers[mutation] || 1);
            });
            
            // 天气突变倍率 (加法)
            let weatherMultiplier = 1;
            if (plant.weatherMutations.length > 0) {
                const weatherMultipliers = plant.weatherMutations.map(m => mutationMultipliers[m] || 1);
                weatherMultiplier = 1 + weatherMultipliers.reduce((a, b) => a + b) - weatherMultipliers.length;
            }
            
            // 特殊突变倍率
            const specialMultiplier = plant.specialMutation ? 5 : 1;
            
            // 最终价格
            let finalPrice = basePrice * basicMultiplier * weatherMultiplier * specialMultiplier;
            
            // 如果是特殊突变植物，应用额外的5倍倍率
            if (plant.specialMutation && specialMutations[plant.type]) {
                finalPrice *= 5;
            }
            
            return Math.floor(finalPrice);
        }

        // 计算总倍率
        function calculateLandlordMultiplier(plant) {
            let multiplier = 1;
            
            plant.mutations.forEach(mutation => {
                multiplier *= (mutationMultipliers[mutation] || 1);
            });
            
            if (plant.weatherMutations.length > 0) {
                const weatherMultipliers = plant.weatherMutations.map(m => mutationMultipliers[m] || 1);
                multiplier *= (1 + weatherMultipliers.reduce((a, b) => a + b) - weatherMultipliers.length);
            }
            
            if (plant.specialMutation) {
                multiplier *= 5;
            }
            
            return multiplier;
        }

        // 卖出果实
        function sellLandlordFruit(fruitIndex) {
            const fruit = player.landlord.fruitStorage[fruitIndex];
            
            if (!fruit) {
                showLandlordNotification("果实不存在！", "error");
                return;
            }
            
            // 检查是否锁定
            if (fruit.isLocked) {
                showLandlordNotification("该果实已锁定，无法卖出！", "error");
                return;
            }
            
            // 增加地主币
            player.landlord.coins += fruit.value;
            
            // 移除果实
            player.landlord.fruitStorage.splice(fruitIndex, 1);
            
            // 更新显示
            updateLandlordCoinDisplay();
            renderLandlordFruitStorage();
            
            showLandlordNotification(`卖出${fruit.type}，获得${formatNumber(fruit.value)}地主币！`, "success");
            saveGame();
        }
 // 添加锁定/解锁果实函数
        function toggleLockLandlordFruit(fruitIndex) {
            const fruit = player.landlord.fruitStorage[fruitIndex];
            
            if (!fruit) {
                showLandlordNotification("果实不存在！", "error");
                return;
            }
            
            // 切换锁定状态
            fruit.isLocked = !fruit.isLocked;
            
            // 更新显示
            renderLandlordFruitStorage();
            
            showLandlordNotification(`${fruit.type}已${fruit.isLocked ? '锁定' : '解锁'}！`, "info");
            saveGame();
        }

        // 解锁新地块
        function unlockLandlordField() {
            const currentFields = player.landlord.unlockedFields;
            let unlockCost = 0;
            
            if (currentFields === 5) {
                unlockCost = 100000; // 解锁6-10块地
            } else if (currentFields === 10) {
                unlockCost = 2000000; // 解锁11-15块地
            } else if (currentFields === 15) {
                unlockCost = 50000000; // 解锁16-20块地
            } else if (currentFields === 20) {
                unlockCost = 500000000; // 解锁21-25块地
             } else if (currentFields === 25) {
                unlockCost = 5000000000; // 解锁26-30块地
             } else if (currentFields === 30) {
                unlockCost = 50000000000; // 解锁31-35块地
             } else if (currentFields === 35) {
                unlockCost = 5000000000000; // 解锁36-40块地
            } else if (currentFields === 40) {
                unlockCost = 500000000000000; // 解锁41-45块地
            } else if (currentFields === 45) {
                unlockCost = 50000000000000000; // 解锁46-50块地
            } else {
                showLandlordNotification("已解锁所有地块！", "info");
                return;
            }
            
            if (player.landlord.coins < unlockCost) {
                showLandlordNotification(`需要${formatNumber(unlockCost)}地主币！`, "error");
                return;
            }
            
            // 扣除地主币
            player.landlord.coins -= unlockCost;
            
            // 解锁新地块
            player.landlord.unlockedFields += 5;
            
            // 扩展田地数组
            for (let i = 0; i < 5; i++) {
                player.landlord.fields.push(null);
            }
            
            // 更新显示
            updateLandlordCoinDisplay();
            renderLandlordFields();
            updateLandlordStats();
            
            showLandlordNotification(`成功解锁5块新田地！`, "success");
            saveGame();
        }

        // 更新天气
        function updateLandlordWeather() {
            const now = Date.now();
            const timeSinceChange = now - player.landlord.lastWeatherChange;
            
            // 每10分钟有几率改变天气
            if (timeSinceChange >= 10 * 60 * 1000) {
                // 40%几率改变天气
                if (Math.random() * 100 < 40) {
                    const newWeather = weatherList[Math.floor(Math.random() * weatherList.length)];
                    player.landlord.weather = newWeather;
                    player.landlord.lastWeatherChange = now;
                    
                    // 应用天气突变
                    applyLandlordWeatherMutation();
                    
                    showLandlordNotification(`天气变为：${newWeather}`, "info");
                } else {
                    player.landlord.weather = "晴朗";
                }
                
                updateLandlordStats();
            }
        }

        // 应用天气突变 (15%几率)
        function applyLandlordWeatherMutation() {
            if (player.landlord.weather === "晴朗") return;
            
            let weatherApplied = false;
            
            player.landlord.fields.forEach((plant, index) => {
                if (plant) { // 只要有植物，无论是否成熟
                    // 15%几率应用天气突变
                    if (Math.random() * 100 < 15) {
                        if (!plant.weatherMutations.includes(player.landlord.weather)) {
          plant.weatherMutations.push(player.landlord.weather);
                            player.landlord.stats.weatherMutations++;
                            weatherApplied = true;
                            
                            // 重新渲染这个地块
                            renderLandlordField(index);
                        }
                    }
                }
            });
            
            if (weatherApplied) {
                showLandlordNotification(`${player.landlord.weather}天气影响了田地！`, "info");
            }
        }

        // 检查植物生长状态
        function checkLandlordPlantGrowth() {
            const now = Date.now();
            let changed = false;
            
            player.landlord.fields.forEach((plant, index) => {
                if (plant && !plant.isMature) {
                    const plantedAt = plant.plantedAt;
                    const elapsedMinutes = (now - plantedAt) / (1000 * 60);
                    
                    if (elapsedMinutes >= plant.growTime) {
                        plant.isMature = true;
                        changed = true;
                        
                        // 渲染这个地块
                        renderLandlordField(index);
                    }
                }
            });
            
            if (changed) {
                saveGame();
            }
        }

        // 渲染种子商店
        function renderLandlordStore() {
            const storeContainer = document.getElementById('landlordStoreItems');
            if (!storeContainer) return;
            
            storeContainer.innerHTML = '';
            
            for (const seedName in seedProperties) {
                const seed = seedProperties[seedName];
                const stock = player.landlord.storeItems[seedName] || 0;
                const canAfford = player.landlord.coins >= seed.price;
                
                const seedDiv = document.createElement('div');
                seedDiv.className = 'landlord-seed-item';
                seedDiv.innerHTML = `
                    <div class="landlord-seed-icon" style="background: ${seed.color};">${seedName.charAt(0)}</div>
                    <div style="font-weight: bold;">${seedName}</div>
                    <div style="font-size: 0.9em; color: #7f8c8d; margin: 5px 0;">
                        重量: ${seed.minWeight}-${seed.maxWeight}kg
                    </div>
                    <div class="landlord-seed-price">${formatNumber(seed.price)} 地主币</div>
                    <div style="margin: 5px 0; font-size: 0.9em;">库存: ${stock}</div>
                    <button class="landlord-buy-button" ${stock <= 0 || !canAfford ? 'disabled' : ''} 
                            onclick="buyLandlordSeed('${seedName}')">
                        ${stock <= 0 ? '售罄' : (canAfford ? '购买' : '货币不足')}
                    </button>
                `;
                
                storeContainer.appendChild(seedDiv);
            }
            
            // 更新刷新计时器
            updateLandlordSeedRefreshTimer();
        }

        // 渲染道具商店
        function renderLandlordItemStore() {
            const storeContainer = document.getElementById('landlordItemStoreItems');
            if (!storeContainer) return;
            
            storeContainer.innerHTML = '';
            
            for (const itemName in itemProperties) {
                const item = itemProperties[itemName];
                const stock = player.landlord.itemStoreItems[itemName] || 0;
                const canAfford = player.landlord.coins >= item.price;
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'landlord-item-item';
                itemDiv.innerHTML = `
                    <div class="landlord-item-icon" style="background: ${item.color};">${itemName.charAt(0)}</div>
                    <div style="font-weight: bold;">${itemName}</div>
                    <div style="font-size: 0.8em; color: #7f8c8d; margin: 5px 0;">${item.description}</div>
                    <div class="landlord-item-price">${formatNumber(item.price)} 地主币</div>
                    <div style="margin: 5px 0; font-size: 0.9em;">库存: ${stock}</div>
                    <button class="landlord-buy-button" ${stock <= 0 || !canAfford ? 'disabled' : ''} 
                            onclick="buyLandlordItem('${itemName}')">
                        ${stock <= 0 ? '售罄' : (canAfford ? '购买' : '货币不足')}
                    </button>
                `;
                
                storeContainer.appendChild(itemDiv);
            }
            
            // 更新刷新计时器
            updateLandlordItemRefreshTimer();
        }

        // 渲染田地
        function renderLandlordFields() {
            const fieldsContainer = document.getElementById('landlordFieldsContainer');
            const unlockSection = document.getElementById('landlordUnlockSection');
            
            if (!fieldsContainer) return;
            
            fieldsContainer.innerHTML = '';
            
            for (let i = 0; i < player.landlord.unlockedFields; i++) {
                const plant = player.landlord.fields[i];
                const fieldDiv = document.createElement('div');
                fieldDiv.className = `landlord-field ${!plant ? 'empty' : ''}`;
                
                if (!plant) {
                    fieldDiv.innerHTML = `
                        <div class="landlord-field-status">空闲</div>
                        <div style="font-size: 3em; color: rgba(0,0,0,0.1); margin: 20px 0;">+</div>
                        <button class="landlord-plant-button" onclick="selectLandlordSeedForPlanting(${i})">种植</button>
                    `;
                } else {
                    const timeLeft = plant.isMature ? 0 : 
                        Math.max(0, Math.ceil(plant.growTime - (Date.now() - plant.plantedAt) / (1000 * 60)));
                    
                    const progress = plant.isMature ? 100 : 
                        Math.min(100, Math.floor(((Date.now() - plant.plantedAt) / (1000 * 60)) / plant.growTime * 100));
                    
                    // 突变标签
                    let mutationTags = '';
                    
                    // 基础突变标签
                    plant.mutations.forEach(mutation => {
                        const colorClass = getLandlordMutationColorClass(mutation);
                        mutationTags += `<span class="landlord-mutation-tag ${colorClass}">${mutation}</span>`;
                    });
                    
                    // 天气突变标签
                    plant.weatherMutations.forEach(mutation => {
                        const colorClass = getLandlordMutationColorClass(mutation);
                        mutationTags += `<span class="landlord-mutation-tag ${colorClass}">${mutation}</span>`;
                    });
                    
                    // 特殊突变标签
                    if (plant.specialMutation) {
                        const specialName = specialMutations[plant.type] || '特殊突变';
                        mutationTags += `<span class="landlord-mutation-tag landlord-mutation-rainbow">${specialName}</span>`;
                    }
                    
                    fieldDiv.innerHTML = `
                        <div class="landlord-field-status">${plant.type}</div>
                        <div class="landlord-plant-info">
                            <div>重量: ${plant.weight.toFixed(2)}kg</div>
                            <div>${plant.isMature ? '已成熟' : `成长中... ${timeLeft}分钟`}</div>
                            ${mutationTags ? `<div class="landlord-mutations-list">${mutationTags}</div>` : ''}
                        </div>
                        <div class="landlord-field-actions">
                            <div class="landlord-action-row">
                                ${plant.isMature ? 
                                    `<button class="landlord-harvest-button" onclick="harvestLandlordPlant(${i})">收获</button>` : 
                                    `<button class="landlord-action-button" style="background: #7f8c8d; color: white;" disabled>${progress}%</button>`
                                }
                                <button class="landlord-remove-button" onclick="removeLandlordPlant(${i})">铲除</button>
                            </div>
                            <div class="landlord-action-row">
                                <button class="landlord-item-button" onclick="selectLandlordItemForUsing(${i})">使用道具</button>
                            </div>
                        </div>
                    `;
                    
                    // 添加生长进度条
                    if (!plant.isMature) {
                        const progressBar = document.createElement('div');
                        progressBar.className = 'landlord-progress-bar';
                        progressBar.style.marginTop = '10px';
                        progressBar.innerHTML = `<div class="landlord-progress-fill" style="width: ${progress}%"></div>`;
                        fieldDiv.querySelector('.landlord-plant-info').appendChild(progressBar);
                    }
                }
                
                fieldsContainer.appendChild(fieldDiv);
            }
            
            // 解锁地块信息
            let unlockCost = 0;
            if (player.landlord.unlockedFields === 5) {
                unlockCost = 100000;
            } else if (player.landlord.unlockedFields === 10) {
                unlockCost = 2000000;
            } else if (player.landlord.unlockedFields === 15) {
                unlockCost = 50000000;
            } else if (player.landlord.unlockedFields === 20) {
                unlockCost = 500000000;
            } else if (player.landlord.unlockedFields === 25) {
                unlockCost = 5000000000;
            }else if (player.landlord.unlockedFields === 30) {
                unlockCost = 50000000000;
            }else if (player.landlord.unlockedFields === 35) {
                unlockCost = 5000000000000;
            }else if (player.landlord.unlockedFields === 40) {
                unlockCost = 500000000000000;
            }else if (player.landlord.unlockedFields === 45) {
                unlockCost = 50000000000000000;
            }
            
            if (unlockCost > 0) {
                unlockSection.innerHTML = `
                    <h3>解锁更多田地</h3>
                    <p>解锁${player.landlord.unlockedFields + 1}-${player.landlord.unlockedFields + 5}号田地</p>
                    <p>需要: ${formatNumber(unlockCost)} 地主币</p>
                    <button class="landlord-unlock-button" ${player.landlord.coins >= unlockCost ? '' : 'disabled'} 
                            onclick="unlockLandlordField()">
                        ${player.landlord.coins >= unlockCost ? '解锁' : '货币不足'}
                    </button>
                `;
            } else {
                unlockSection.innerHTML = '<p>所有田地已解锁！</p>';
            }
        }

        // 渲染种子仓库
        function renderLandlordSeedStorage() {
            const storageContainer = document.getElementById('landlordSeedStorage');
            if (!storageContainer) return;
            
            storageContainer.innerHTML = '';
            
            let hasSeeds = false;
            
            for (const seedName in player.landlord.seedStorage) {
                if (player.landlord.seedStorage[seedName] > 0) {
                    hasSeeds = true;
                    const seedDiv = document.createElement('div');
                    seedDiv.className = 'landlord-storage-item';
                    seedDiv.innerHTML = `
                        <div class="landlord-item-info">
                            <div style="font-weight: bold;">${seedName}</div>
                            <div>价格: ${formatNumber(seedProperties[seedName].price)}</div>
                        </div>
                        <div style="font-weight: bold; color: #3498db;">${player.landlord.seedStorage[seedName]}</div>
                    `;
                    storageContainer.appendChild(seedDiv);
                }
            }
            
            if (!hasSeeds) {
                storageContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">种子仓库为空</div>';
            }
        }

        // 渲染果实仓库
       function renderLandlordFruitStorage() {
            const storageContainer = document.getElementById('landlordFruitStorage');
            const totalAssets = document.getElementById('landlordTotalAssetsValue');
            
            if (!storageContainer) return;
            
            storageContainer.innerHTML = '';
            
            let totalValue = 0;
            let lockedValue = 0;
            let unlockedValue = 0;
            
            if (player.landlord.fruitStorage.length === 0) {
                storageContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">果实仓库为空</div>';
            } else {
                player.landlord.fruitStorage.forEach((fruit, index) => {
                    totalValue += fruit.value;
                    if (fruit.isLocked) {
                        lockedValue += fruit.value;
                    } else {
                        unlockedValue += fruit.value;
                    }
                    
                    const fruitDiv = document.createElement('div');
                    fruitDiv.className = `landlord-storage-item ${fruit.isLocked ? 'locked' : ''}`;
                    if (fruit.isLocked) {
                        fruitDiv.style.background = 'linear-gradient(135deg, #fff3cd, #ffeaa7)';
                        fruitDiv.style.border = '2px solid #f39c12';
                    }
                    
                    // 突变标签
                    let mutationTags = '';
                    
                    // 基础突变标签
                    fruit.mutations.forEach(mutation => {
                        const colorClass = getLandlordMutationColorClass(mutation);
                        mutationTags += `<span class="landlord-mutation-tag ${colorClass}" style="font-size: 0.7em; margin-right: 2px;">${mutation}</span>`;
                    });
                    
                    // 天气突变标签
                    fruit.weatherMutations.forEach(mutation => {
                        const colorClass = getLandlordMutationColorClass(mutation);
                        mutationTags += `<span class="landlord-mutation-tag ${colorClass}" style="font-size: 0.7em; margin-right: 2px;">${mutation}</span>`;
                    });
                    
                    // 特殊突变标签
                    if (fruit.specialMutation) {
                        const specialName = specialMutations[fruit.type] || '特殊';
                        mutationTags += `<span class="landlord-mutation-tag landlord-mutation-rainbow" style="font-size: 0.7em; margin-right: 2px;">${specialName}</span>`;
                    }
                    
                    fruitDiv.innerHTML = `
                        <div class="landlord-item-info" style="flex: 1;">
                            <div style="font-weight: bold; display: flex; justify-content: space-between; align-items: center;">
                                <span>${fruit.type} ${fruit.isLocked ? '🔒' : ''}</span>
                                <span>${fruit.weight.toFixed(2)}kg</span>
                            </div>
                            <div style="color: #27ae60; font-weight: bold; font-size: 1.1em;">
                                ${formatNumber(fruit.value)} 地主币
                                ${fruit.isLocked ? '<span style="color: #f39c12; font-size: 0.8em;"> (已锁定)</span>' : ''}
                            </div>
                            <div style="margin-top: 5px;">
                                ${mutationTags || '<span style="color: #95a5a6; font-size: 0.9em;">无突变</span>'}
                            </div>
                            <div style="color: #7f8c8d; font-size: 0.8em; margin-top: 5px;">
                                收获: ${fruit.harvestedAt}
                            </div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 5px;">
                            <button onclick="toggleLockLandlordFruit(${index})" 
                                    style="background: ${fruit.isLocked ? '#f39c12' : '#95a5a6'}; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">
                                ${fruit.isLocked ? '解锁' : '锁定'}
                            </button>
                            <button onclick="sellLandlordFruit(${index})" 
                                    ${fruit.isLocked ? 'disabled' : ''}
                                    style="background: ${fruit.isLocked ? '#bdc3c7' : '#2ecc71'}; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">
                                ${fruit.isLocked ? '已锁定' : '卖出'}
                            </button>
                        </div>
                    `;
                    
                    storageContainer.appendChild(fruitDiv);
                });
            }
            
            if (totalAssets) {
                let displayText = formatNumber(unlockedValue) + ' 地主币';
                if (lockedValue > 0) {
                    displayText += ` (锁定: ${formatNumber(lockedValue)})`;
                }
                totalAssets.textContent = displayText;
            }
        }

        // 渲染道具仓库
        function renderLandlordItemStorage() {
            const storageContainer = document.getElementById('landlordItemStorage');
            if (!storageContainer) return;
            
            storageContainer.innerHTML = '';
            
            let hasItems = false;
            
            for (const itemName in player.landlord.itemStorage) {
                if (player.landlord.itemStorage[itemName] > 0) {
                    hasItems = true;
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'landlord-storage-item';
                    
                    const itemColor = itemProperties[itemName].color;
                    
                    itemDiv.innerHTML = `
                        <div class="landlord-item-info">
                            <div style="font-weight: bold; display: flex; align-items: center; gap: 10px;">
                                <div style="width: 20px; height: 20px; border-radius: 50%; background: ${itemColor};"></div>
                                <span>${itemName}</span>
                            </div>
                            <div style="font-size: 0.9em; color: #7f8c8d;">${itemProperties[itemName].description}</div>
                        </div>
                        <div style="font-weight: bold; color: #9b59b6; font-size: 1.2em;">${player.landlord.itemStorage[itemName]}</div>
                    `;
                    storageContainer.appendChild(itemDiv);
                }
            }
            
            if (!hasItems) {
                storageContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">道具仓库为空</div>';
            }
        }

        // 更新统计
        function updateLandlordStats() {
            const stats = player.landlord.stats;
            
            document.getElementById('landlordTotalPlants').textContent = stats.totalPlants;
            document.getElementById('landlordTotalHarvests').textContent = stats.totalHarvests;
            document.getElementById('landlordTotalCoinsEarned').textContent = formatNumber(stats.totalCoinsEarned);
            document.getElementById('landlordCurrentWeather').textContent = player.landlord.weather;
            document.getElementById('landlordBasicMutations').textContent = stats.basicMutations;
            document.getElementById('landlordWeatherMutations').textContent = stats.weatherMutations;
            document.getElementById('landlordSpecialMutations').textContent = stats.specialMutations;
            document.getElementById('landlordHighestMultiplier').textContent = stats.highestMultiplier.toFixed(1) + 'x';
            document.getElementById('landlordUnlockedFields').textContent = player.landlord.unlockedFields;
            document.getElementById('landlordItemUsageCount').textContent = stats.itemsUsed;
            
             // 计算种子和果实数量
            let seedCount = 0;
            for (const seed in player.landlord.seedStorage) {
                seedCount += player.landlord.seedStorage[seed];
            }
            document.getElementById('landlordSeedStorageCount').textContent = seedCount;
            
            // 计算锁定果实数量
            let lockedFruitCount = 0;
            let totalFruitValue = 0;
            let lockedFruitValue = 0;
            
            player.landlord.fruitStorage.forEach(fruit => {
                totalFruitValue += fruit.value;
                if (fruit.isLocked) {
                    lockedFruitCount++;
                    lockedFruitValue += fruit.value;
                }
            });
            
            document.getElementById('landlordFruitStorageCount').textContent = 
                `${player.landlord.fruitStorage.length} (${lockedFruitCount}锁定)`;
            
            // 在仓库总资产中显示锁定信息
            const totalAssetsElement = document.getElementById('landlordTotalAssetsValue');
            if (totalAssetsElement) {
                let assetsText = formatNumber(totalFruitValue) + ' 地主币';
                if (lockedFruitCount > 0) {
                    assetsText += ` (锁定: ${formatNumber(lockedFruitValue)})`;
                }
                totalAssetsElement.textContent = assetsText;
            }
        }
        // 更新货币显示
        function updateLandlordCoinDisplay() {
            document.getElementById('landlordCoinBalance').textContent = formatNumber(player.landlord.coins);
        }

        // 更新种子商店刷新计时器
        function updateLandlordSeedRefreshTimer() {
            const now = Date.now();
            const timeSinceRefresh = now - player.landlord.lastSeedRefreshTime;
            const timeUntilRefresh = Math.max(0, 10 * 60 * 1000 - timeSinceRefresh);
            
            const minutes = Math.floor(timeUntilRefresh / (1000 * 60));
            const seconds = Math.floor((timeUntilRefresh % (1000 * 60)) / 1000);
            
            const timerElement = document.getElementById('landlordSeedRefreshTimer');
            if (timerElement) {
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // 更新道具商店刷新计时器
        function updateLandlordItemRefreshTimer() {
            const now = Date.now();
            const timeSinceRefresh = now - player.landlord.lastItemRefreshTime;
            const timeUntilRefresh = Math.max(0, 10 * 60 * 1000 - timeSinceRefresh);
            
            const minutes = Math.floor(timeUntilRefresh / (1000 * 60));
            const seconds = Math.floor((timeUntilRefresh % (1000 * 60)) / 1000);
            
            const timerElement = document.getElementById('landlordItemRefreshTimer');
            if (timerElement) {
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // 获取突变颜色类
        function getLandlordMutationColorClass(mutation) {
            // 基础突变颜色
            if (["银", "落雷", "冰冻", "陶化"].includes(mutation)) return "landlord-mutation-green";
            if (["金", "荧光", "彩虹"].includes(mutation)) return "landlord-mutation-blue";
            if (["星环", "瓷化", "亮晶晶"].includes(mutation)) return "landlord-mutation-purple";
            if (["水晶", "红月"].includes(mutation)) return "landlord-mutation-gold";
            if (["流光", "霓虹"].includes(mutation)) return "landlord-mutation-rainbow";
            
            // 天气突变颜色
            if (weatherMutationColors[mutation]) {
                return `landlord-mutation-${weatherMutationColors[mutation]}`;
            }
            
            return "landlord-mutation-grey";
        }

        // 检查离线收益
        function checkLandlordOfflineEarnings() {
            const now = Date.now();
            const lastPlayTime = player.landlord.lastSaveTime || now;
            const offlineMinutes = (now - lastPlayTime) / (1000 * 60);
            
            // 最大离线20小时
            const maxOfflineMinutes = 1200;
            const effectiveOfflineMinutes = Math.min(offlineMinutes, maxOfflineMinutes);
            
            if (effectiveOfflineMinutes >= 10) {
                // 计算商店刷新次数
                const refreshCount = Math.floor(effectiveOfflineMinutes / 10);
                
                // 生长进度计算
                player.landlord.fields.forEach((plant, index) => {
                    if (plant && !plant.isMature) {
                        const plantedAt = plant.plantedAt;
                        const elapsedMinutes = (now - plantedAt) / (1000 * 60);
                        
                        if (elapsedMinutes >= plant.growTime) {
                            plant.isMature = true;
                        }
                    }
                });
                
                // 天气变化计算
                const weatherChangeCount = Math.floor(effectiveOfflineMinutes / 10);
                for (let i = 0; i < weatherChangeCount; i++) {
                    if (Math.random() * 100 < 40) {
                        const newWeather = weatherList[Math.floor(Math.random() * weatherList.length)];
                        player.landlord.weather = newWeather;
                        
                        // 离线期间对植物应用天气突变
                        player.landlord.fields.forEach((plant, index) => {
                            if (plant && Math.random() * 100 < 15) { // 15%几率应用天气突变
                                if (!plant.weatherMutations.includes(player.landlord.weather)) {
                                    plant.weatherMutations.push(player.landlord.weather);
                                    player.landlord.stats.weatherMutations++;
                                }
                            }
                        });
                    }
                }
                
                // 商店刷新
                for (let i = 0; i < refreshCount; i++) {
                    // 刷新种子商店
                    for (const seed in refreshProbabilities) {
                        if (Math.random() * 100 < refreshProbabilities[seed]) {
                            player.landlord.storeItems[seed] = 1;
                        } else {
                            player.landlord.storeItems[seed] = 0;
                        }
                    }
                    
                    // 刷新道具商店
                    for (const item in itemProperties) {
                        const probability = itemProperties[item].refreshProbability;
                        if (Math.random() * 100 < probability) {
                            player.landlord.itemStoreItems[item] = 1;
                        } else {
                            player.landlord.itemStoreItems[item] = 0;
                        }
                    }
                }
                
                if (refreshCount > 0) {
                    showLandlordNotification(`离线期间商店刷新了${refreshCount}次，天气变化了${weatherChangeCount}次`, "info");
                }
            }
            
            // 保存当前时间
            player.landlord.lastSaveTime = now;
        }

        // 切换标签页
        function switchLandlordTab(tabName) {
            // 隐藏所有标签页
            document.querySelectorAll('.landlord-tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 移除所有活动按钮
            document.querySelectorAll('.landlord-tab').forEach(button => {
                button.classList.remove('active');
            });
            
            // 显示目标标签页
            document.getElementById('landlord' + tabName.charAt(0).toUpperCase() + tabName.slice(1) + 'Tab').classList.add('active');
            
            // 激活目标按钮
            event.target.classList.add('active');
            
            // 刷新内容
            if (tabName === 'store') {
                renderLandlordStore();
            } else if (tabName === 'itemStore') {
                renderLandlordItemStore();
            } else if (tabName === 'fields') {
                renderLandlordFields();
            } else if (tabName === 'storage') {
                renderLandlordSeedStorage();
                renderLandlordFruitStorage();
                renderLandlordItemStorage();
            } else if (tabName === 'stats') {
                updateLandlordStats();
            }
        }

        // 渲染单个地块
        function renderLandlordField(fieldIndex) {
            const fieldsContainer = document.getElementById('landlordFieldsContainer');
            if (!fieldsContainer) return;
            
            const fieldDiv = fieldsContainer.children[fieldIndex];
            if (!fieldDiv) return;
            
            const plant = player.landlord.fields[fieldIndex];
            
            if (!plant) {
                fieldDiv.className = 'landlord-field empty';
                fieldDiv.innerHTML = `
                    <div class="landlord-field-status">空闲</div>
                    <div style="font-size: 3em; color: rgba(0,0,0,0.1); margin: 20px 0;">+</div>
                    <button class="landlord-plant-button" onclick="selectLandlordSeedForPlanting(${fieldIndex})">种植</button>
                `;
            } else {
                const timeLeft = plant.isMature ? 0 : 
                    Math.max(0, Math.ceil(plant.growTime - (Date.now() - plant.plantedAt) / (1000 * 60)));
                
                const progress = plant.isMature ? 100 : 
                    Math.min(100, Math.floor(((Date.now() - plant.plantedAt) / (1000 * 60)) / plant.growTime * 100));
                
                // 突变标签
                let mutationTags = '';
                
                // 基础突变标签
                plant.mutations.forEach(mutation => {
                    const colorClass = getLandlordMutationColorClass(mutation);
                    mutationTags += `<span class="landlord-mutation-tag ${colorClass}">${mutation}</span>`;
                });
                
                // 天气突变标签
                plant.weatherMutations.forEach(mutation => {
                    const colorClass = getLandlordMutationColorClass(mutation);
                    mutationTags += `<span class="landlord-mutation-tag ${colorClass}">${mutation}</span>`;
                });
                
                // 特殊突变标签
                if (plant.specialMutation) {
                    const specialName = specialMutations[plant.type] || '特殊突变';
                    mutationTags += `<span class="landlord-mutation-tag landlord-mutation-rainbow">${specialName}</span>`;
                }
                
                fieldDiv.className = 'landlord-field';
                fieldDiv.innerHTML = `
                    <div class="landlord-field-status">${plant.type}</div>
                    <div class="landlord-plant-info">
                        <div>重量: ${plant.weight.toFixed(2)}kg</div>
                        <div>${plant.isMature ? '已成熟' : `成长中... ${timeLeft}分钟`}</div>
                        ${mutationTags ? `<div class="landlord-mutations-list">${mutationTags}</div>` : ''}
                    </div>
                    <div class="landlord-field-actions">
                        <div class="landlord-action-row">
                            ${plant.isMature ? 
                                `<button class="landlord-harvest-button" onclick="harvestLandlordPlant(${fieldIndex})">收获</button>` : 
                                `<button class="landlord-action-button" style="background: #7f8c8d; color: white;" disabled>${progress}%</button>`
                            }
                            <button class="landlord-remove-button" onclick="removeLandlordPlant(${fieldIndex})">铲除</button>
                        </div>
                        <div class="landlord-action-row">
                            <button class="landlord-item-button" onclick="selectLandlordItemForUsing(${fieldIndex})">使用道具</button>
                        </div>
                    </div>
                `;
                
                // 添加生长进度条
                if (!plant.isMature) {
                    const progressBar = document.createElement('div');
                    progressBar.className = 'landlord-progress-bar';
                    progressBar.style.marginTop = '10px';
                    progressBar.innerHTML = `<div class="landlord-progress-fill" style="width: ${progress}%"></div>`;
                    fieldDiv.querySelector('.landlord-plant-info').appendChild(progressBar);
                }
            }
        }

        // 启动定时器
        function startLandlordTimers() {
            // 每秒更新一次
            setInterval(() => {
                checkLandlordPlantGrowth();
                updateLandlordSeedRefreshTimer();
                updateLandlordItemRefreshTimer();
                updateLandlordWeather();
                
                // 每60秒自动保存一次
                if (Date.now() - (player.landlord.lastSaveTime || 0) > 60000) {
                    saveGame();
                }
            }, 1000);
        }

        // 渲染所有UI
        function renderAllLandlordUI() {
            updateLandlordCoinDisplay();
            renderLandlordStore();
            renderLandlordItemStore();
            renderLandlordFields();
            renderLandlordSeedStorage();
            renderLandlordFruitStorage();
            renderLandlordItemStorage();
            updateLandlordStats();
        }

        // 显示通知
        function showLandlordNotification(message, type) {
            const notificationArea = document.getElementById('landlordNotificationArea');
            if (!notificationArea) return;
            
            const notification = document.createElement('div');
            notification.className = `landlord-notification ${type}`;
            notification.textContent = message;
            notificationArea.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        // 格式化数字
        function formatNumber(num) {
            if (num >= 1e9) {
                return (num / 1e9).toFixed(2) + 'B';
            } else if (num >= 1e6) {
                return (num / 1e6).toFixed(2) + 'M';
            } else if (num >= 1e3) {
                return (num / 1e3).toFixed(2) + 'K';
            }
            return Math.floor(num).toLocaleString();
        }

        // 初始化游戏数据
        function initLandlordGameData() {
            if (!player.landlord) {
                player.landlord = {
                    coins: 0,
                    unlockedFields: 5,
                    fields: Array(50).fill(null),
                    seedStorage: {},
                    fruitStorage: [],
                    itemStorage: {},
                    storeItems: {},
                    itemStoreItems: {},
                    lastSeedRefreshTime: Date.now(),
                    lastItemRefreshTime: Date.now(),
                    weather: "晴朗",
                    lastWeatherChange: Date.now(),
                    stats: {
                        totalPlants: 0,
                        totalHarvests: 0,
                        totalCoinsEarned: 0,
                        basicMutations: 0,
                        weatherMutations: 0,
                        specialMutations: 0,
                        highestMultiplier: 1,
                        itemsUsed: 0
                    },
                    selectedFieldIndex: null,
                    lastSaveTime: Date.now()
                };
            }
            
            // 确保fields数组长度正确
            while (player.landlord.fields.length < player.landlord.unlockedFields) {
                player.landlord.fields.push(null);
            }
            
            // 确保所有必要的对象都存在
            if (!player.landlord.seedStorage) player.landlord.seedStorage = {};
            if (!player.landlord.fruitStorage) player.landlord.fruitStorage = [];
            if (!player.landlord.itemStorage) player.landlord.itemStorage = {};
            if (!player.landlord.storeItems) player.landlord.storeItems = {};
            if (!player.landlord.itemStoreItems) player.landlord.itemStoreItems = {};
            if (!player.landlord.stats) player.landlord.stats = {
                totalPlants: 0,
                totalHarvests: 0,
                totalCoinsEarned: 0,
                basicMutations: 0,
                weatherMutations: 0,
                specialMutations: 0,
                highestMultiplier: 1,
                itemsUsed: 0
            };
        }

        // 在游戏加载时初始化疯狂地主数据
        function loadLandlordGameData() {
            initLandlordGameData();
            
            // 检查离线收益
            checkLandlordOfflineEarnings();
        }

        // 在游戏保存时保存疯狂地主数据
        function saveLandlordGameData() {
            if (player.landlord) {
                player.landlord.lastSaveTime = Date.now();
            }
        }

        // 修改原有的loadGame函数，添加疯狂地主数据加载
        const originalLoadGame = loadGame;
        loadGame = function() {
            originalLoadGame();
            loadLandlordGameData();
        };

        // 修改原有的saveGame函数，添加疯狂地主数据保存
        const originalSaveGame = saveGame;
        saveGame = function() {
            saveLandlordGameData();
            originalSaveGame();
        };

        // 在页面加载时初始化疯狂地主游戏
        window.addEventListener('load', function() {
            // 初始化疯狂地主游戏数据
            initLandlordGameData();
            
            // 如果疯狂地主界面是打开的，初始化UI
            if (document.getElementById('landlordUI').style.display === 'block') {
                initLandlordGame();
            }
        });

        // 添加测试数据函数（可选）
        function addTestLandlordData() {
            if (!localStorage.getItem('goldGameSave')) {
                // 添加初始数据
                player.landlord.coins = 10000;
                player.landlord.seedStorage = {
                    "土豆": 5,
                    "牵牛花": 3,
                    "黄瓜": 2
                };
                player.landlord.itemStorage = {
                    "普通浇水器": 2
                };
                
                // 初始化商店
                refreshLandlordStore();
                refreshLandlordItemStore();
            }
        }

        // 在游戏初始化时调用测试数据函数
        addTestLandlordData();

        // 添加一些辅助函数
        function getLandlordMutationColor(mutation) {
            const colorMap = {
                "银": "#c0c0c0",
                "金": "#ffd700", 
                "水晶": "#a7d8de",
                "流光": "#ff6b6b",
                "潮湿": "#87ceeb",
                "颤栗": "#d8bfd8",
                "生机": "#90ee90",
                "覆雪": "#f0f8ff",
                "迷雾": "#d3d3d3",
                "灼热": "#ff4500",
                "沙尘": "#f4a460",
                "结霜": "#b0e0e6",
                "落雷": "#9370db",
                "荧光": "#adff2f",
                "彩虹": "linear-gradient(45deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6600ff)",
                "星环": "#8a2be2",
                "瓷化": "#f5f5dc",
                "亮晶晶": "#e6e6fa",
                "红月": "#dc143c",
                "霓虹": "linear-gradient(45deg, #ff00ff, #00ffff, #ffff00)"
            };
            
            return colorMap[mutation] || "#bdc3c7";
        }

        // 添加一个快速收获所有成熟作物的函数
       function harvestAllMatureLandlordPlants() {
            let harvestedCount = 0;
            let totalValue = 0;
            let lockedCount = 0;
            
            player.landlord.fields.forEach((plant, index) => {
                if (plant && plant.isMature) {
                    // 计算价值
                    const value = calculateLandlordPlantValue(plant);
                    totalValue += value;
                    
                    // 添加到果实仓库
                    const fruit = {
                        type: plant.type,
                        weight: plant.weight,
                        value: value,
                        mutations: [...plant.mutations],
                        weatherMutations: [...plant.weatherMutations],
                        specialMutation: plant.specialMutation,
                        harvestedAt: new Date().toLocaleString('zh-CN'),
                        harvestedTimestamp: Date.now(),
                        isLocked: false  // 新收获的果实默认不锁定
                    };
                    
                    if (player.landlord.fruitStorage.length < 200) {
                        player.landlord.fruitStorage.push(fruit);
                        
                        // 重新生成植物
                        player.landlord.fields[index] = createNewLandlordPlant(plant.type);
                        harvestedCount++;
                    } else {
                        lockedCount++; // 仓库已满，无法收获
                    }
                }
            });
            
            if (harvestedCount > 0) {
                // 更新统计
                player.landlord.stats.totalHarvests += harvestedCount;
                player.landlord.stats.totalCoinsEarned += totalValue;
                
                // 更新显示
                renderLandlordFields();
                renderLandlordFruitStorage();
                updateLandlordStats();
                
                let message = `一键收获了${harvestedCount}个作物，总价值${formatNumber(totalValue)}地主币！`;
                if (lockedCount > 0) {
                    message += ` (${lockedCount}个因仓库已满未收获)`;
                }
                
                showLandlordNotification(message, "success");
                saveGame();
            } else {
                if (lockedCount > 0) {
                    showLandlordNotification("果实仓库已满，无法收获任何作物！", "error");
                } else {
                    showLandlordNotification("没有成熟的作物可收获！", "info");
                }
            }
        }

        // 添加一键收获按钮到界面
        function addHarvestAllButton() {
            // 在田地页面添加一键收获按钮
            const fieldsTab = document.getElementById('landlordFieldsTab');
            if (fieldsTab && !fieldsTab.querySelector('.harvest-all-button')) {
                const harvestAllButton = document.createElement('button');
                harvestAllButton.className = 'landlord-unlock-button';
                harvestAllButton.style.marginBottom = '20px';
                harvestAllButton.textContent = '一键收获所有成熟作物';
                harvestAllButton.onclick = harvestAllMatureLandlordPlants;
                harvestAllButton.classList.add('harvest-all-button');
                
                fieldsTab.insertBefore(harvestAllButton, fieldsTab.firstChild);
            }
        }

        // 在渲染田地时调用添加按钮函数
        const originalRenderLandlordFields = renderLandlordFields;
        renderLandlordFields = function() {
            originalRenderLandlordFields();
            addHarvestAllButton();
        };

        // 卖出所有果实
        function sellAllLandlordFruits() {
            if (player.landlord.fruitStorage.length === 0) {
                showLandlordNotification("没有果实可卖出！", "error");
                return;
            }
            
            let totalValue = 0;
            let soldCount = 0;
            let lockedCount = 0;
            
            // 从后往前遍历，避免splice导致的索引问题
            for (let i = player.landlord.fruitStorage.length - 1; i >= 0; i--) {
                const fruit = player.landlord.fruitStorage[i];
                if (!fruit.isLocked) {
                    totalValue += fruit.value;
                    player.landlord.fruitStorage.splice(i, 1);
                    soldCount++;
                } else {
                    lockedCount++;
                }
            }
            
            if (soldCount > 0) {
                // 增加地主币
                player.landlord.coins += totalValue;
                
                // 更新显示
                updateLandlordCoinDisplay();
                renderLandlordFruitStorage();
                
                let message = `一键卖出${soldCount}个果实，获得${formatNumber(totalValue)}地主币！`;
                if (lockedCount > 0) {
                    message += ` (${lockedCount}个已锁定的果实未卖出)`;
                }
                
                showLandlordNotification(message, "success");
                saveGame();
            } else {
                if (lockedCount > 0) {
                    showLandlordNotification(`所有${lockedCount}个果实都已锁定，无法卖出！`, "info");
                } else {
                    showLandlordNotification("没有果实可卖出！", "error");
                }
            }
        }

        // 添加一键卖出按钮到界面
        function addSellAllButton() {
            const storageTab = document.getElementById('landlordStorageTab');
            if (storageTab && !storageTab.querySelector('.sell-all-button')) {
                const sellAllButton = document.createElement('button');
                sellAllButton.className = 'landlord-unlock-button';
                sellAllButton.style.marginBottom = '20px';
                sellAllButton.textContent = '一键卖出所有果实';
                sellAllButton.onclick = sellAllLandlordFruits;
                sellAllButton.classList.add('sell-all-button');
                
                const storageContainer = storageTab.querySelector('.landlord-storage-container');
                if (storageContainer) {
                    storageContainer.parentNode.insertBefore(sellAllButton, storageContainer);
                }
            }
        }

        // 在渲染仓库时调用添加按钮函数
        const originalRenderLandlordFruitStorage = renderLandlordFruitStorage;
        renderLandlordFruitStorage = function() {
            originalRenderLandlordFruitStorage();
            addSellAllButton();
        };

        console.log("疯狂地主游戏已成功加载！");
   // 无尽挖矿配置
        const miningGemsConfig = [
        { name: '红宝石', key: 'ruby', rarity: 0.4, minDepth: 0, color: '#ff6b6b' },
        { name: '蓝宝石', key: 'sapphire', rarity: 0.3, minDepth: 10000, color: '#48cae4' },
        { name: '翡翠', key: 'emerald', rarity: 0.2, minDepth: 100000, color: '#52b788' },
        { name: '紫水晶', key: 'amethyst', rarity: 0.08, minDepth: 1000000, color: '#7b2cbf' },
        { name: '钻石', key: 'diamond', rarity: 0.02, minDepth: 10000000, color: '#caf0f8' }
    ];

         // 切换分页函数
        function switchMiningTab(tabName) {
            // 更新标签样式
            document.querySelectorAll('.mining-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`.mining-tab[onclick="switchMiningTab('${tabName}')"]`).classList.add('active');
            
            // 更新页面显示
            document.querySelectorAll('.mining-gems-page, .mining-upgrades-page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(`mining${tabName.charAt(0).toUpperCase() + tabName.slice(1)}Page`).classList.add('active');
        }

        function toggleMiningUI() {
       if (player.reincarnationCount < 1500) {
        alert("需要达到1500转才能开启无尽挖矿！");
        return;
    }
            const ui = document.getElementById('miningUI');
            if (ui.style.display === 'block') {
                ui.style.display = 'none';
            } else {
                ui.style.display = 'block';
                updateMiningUI();
                calculateOfflineMining();
            }
        }

        function getMiningMaxStamina() {
            return player.mining.baseMaxStamina + ((player.mining.staminaUpgradeLevel - 1) * 10);
        }

         function updateMiningUI() {
        const maxStamina = getMiningMaxStamina();
        const staminaPercent = (player.mining.stamina / maxStamina) * 100;
        
        // 更新基础信息
        document.getElementById('miningDepth').textContent = player.mining.depth.toLocaleString() + ' 米';
        document.getElementById('miningPower').textContent = player.mining.power;
        document.getElementById('miningMaxStamina').textContent = maxStamina;
        
        // 更新体力条
        document.getElementById('miningStaminaBar').style.width = staminaPercent + '%';
        document.getElementById('miningStaminaText').textContent = 
            Math.floor(player.mining.stamina) + ' / ' + maxStamina;
        
        // 确保所有宝石属性都存在
        for (let i = 0; i < miningGemsConfig.length; i++) {
            const gem = miningGemsConfig[i];
            if (player.mining.gems[gem.key] === undefined) {
                player.mining.gems[gem.key] = 0;
            }
        }
        
        // 更新宝石数量显示
        document.getElementById('miningRuby').textContent = player.mining.gems.ruby || 0;
        document.getElementById('miningSapphire').textContent = player.mining.gems.sapphire || 0;
        document.getElementById('miningEmerald').textContent = player.mining.gems.emerald || 0;
        document.getElementById('miningAmethyst').textContent = player.mining.gems.amethyst || 0;
        document.getElementById('miningDiamond').textContent = player.mining.gems.diamond || 0;
        document.getElementById('miningOre').textContent = player.mining.ore;
        
        // 更新药水数量
        document.getElementById('miningPotionCount').textContent = player.mining.potions;
        
        // 更新升级信息
        document.getElementById('miningPowerLevel').textContent = player.mining.upgrades.power;
        document.getElementById('miningStaminaLevel').textContent = player.mining.staminaUpgradeLevel;
        document.getElementById('miningDetectorLevel').textContent = player.mining.upgrades.detector;
        
        // 更新按钮状态
        document.getElementById('upgradeMiningPowerBtn').textContent = `升级 (${1000 * player.mining.upgrades.power})`;
        document.getElementById('upgradeMiningStaminaBtn').textContent = `升级 (${10000 * player.mining.staminaUpgradeLevel})`;
        document.getElementById('upgradeMiningDetectorBtn').textContent = `升级 (${50000 * player.mining.upgrades.detector})`;
        
        document.getElementById('upgradeMiningPowerBtn').disabled = player.mining.upgrades.power >= 100;
        document.getElementById('upgradeMiningStaminaBtn').disabled = player.mining.staminaUpgradeLevel >= 10;
        document.getElementById('upgradeMiningDetectorBtn').disabled = player.mining.upgrades.detector >= 10;
        
        // 更新挖矿按钮
        const miningBtn = document.getElementById('miningToggleBtn');
        miningBtn.textContent = player.mining.isMining ? '停止自动挖矿' : '开始自动挖矿';
        miningBtn.style.background = player.mining.isMining ? 
            'linear-gradient(135deg, #ff4757 0%, #ff3742 100%)' : 
            'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
        
        // 更新通知显示
        updateMiningNotifications();
    }
        

        function addMiningNotification(message, type = 'info') {
            const now = new Date();
            const timestamp = now.toLocaleTimeString();
            
            player.mining.notifications.unshift({
                message: message,
                type: type,
                timestamp: timestamp
            });
            
            // 限制通知数量
            if (player.mining.notifications.length > 20) {
                player.mining.notifications.pop();
            }
            
            updateMiningNotifications();
        }

        function updateMiningNotifications() {
            const container = document.getElementById('miningNotifications');
            container.innerHTML = '';
            
            player.mining.notifications.forEach(notif => {
                const div = document.createElement('div');
                div.className = 'mining-notification';
                div.style.borderLeftColor = notif.type === 'gem' ? '#4CAF50' : 
                                          notif.type === 'warning' ? '#ff6b6b' : '#4CAF50';
                div.innerHTML = `[${notif.timestamp}] ${notif.message}`;
                container.appendChild(div);
            });
        }

        function clearMiningNotifications() {
            player.mining.notifications = [];
            updateMiningNotifications();
        }

        function toggleMining() {
            player.mining.isMining = !player.mining.isMining;
            
            if (player.mining.isMining) {
                addMiningNotification('开始自动挖矿！');
                // 确保挖矿循环运行
                if (!window.miningInterval) {
                    window.miningInterval = setInterval(mine, 1000);
                }
            } else {
                addMiningNotification('停止自动挖矿！');
            }
            
            updateMiningUI();
            saveGame();
        }function findGem(depth, detectorLevel, isOffline = false) {
        const gemChance = 0.02 + (detectorLevel * 0.005);
        console.log(`宝石发现概率: ${(gemChance * 100).toFixed(2)}%, 当前深度: ${depth}`);
        
        // 先检查是否发现宝石
        if (Math.random() < gemChance) {
            const gemRoll = Math.random();
            console.log(`宝石判定随机数: ${gemRoll.toFixed(4)}`);
            
            // 记录挖掘前的宝石数量
            const gemsBefore = {...player.mining.gems};
            console.log('挖掘前宝石数量:', gemsBefore);
            
            // 检查翡翠属性是否存在
            if (player.mining.gems.emerald === undefined) {
                console.warn('⚠️ 翡翠属性不存在，正在初始化...');
                player.mining.gems.emerald = 0;
            }
            
            // 收集符合条件的宝石
            const availableGems = [];
            let totalRarity = 0;
            
            for (let i = 0; i < miningGemsConfig.length; i++) {
                const gem = miningGemsConfig[i];
                if (depth >= gem.minDepth) {
                    availableGems.push(gem);
                    totalRarity += gem.rarity;
                    console.log(`✅ 符合条件: ${gem.name}, 要求深度: ${gem.minDepth}, 当前深度: ${depth}`);
                } else {
                    console.log(`❌ 不符合条件: ${gem.name}, 要求深度: ${gem.minDepth}, 当前深度: ${depth}`);
                }
            }
            
            console.log(`符合条件的宝石: ${availableGems.length}种, 总概率: ${totalRarity}`);
            
            if (availableGems.length === 0) {
                console.log('没有符合条件的宝石，给予红宝石');
                selectedGem = miningGemsConfig[0]; // 红宝石
            } else {
                // 使用累积概率选择宝石
                let cumulative = 0;
                let selectedGem = null;
                
                for (let i = 0; i < availableGems.length; i++) {
                    const gem = availableGems[i];
                    cumulative += gem.rarity / totalRarity; // 标准化概率
                    if (gemRoll <= cumulative) {
                        selectedGem = gem;
                        break;
                    }
                }
                
                // 如果循环结束还没有选择宝石（由于浮点精度问题），选择最后一个
                if (!selectedGem) {
                    selectedGem = availableGems[availableGems.length - 1];
                }
                
                if (selectedGem) {
                    console.log(`🎯 选中宝石: ${selectedGem.name}, 键名: ${selectedGem.key}`);
                    
                    // 确保宝石属性存在
                    if (player.mining.gems[selectedGem.key] === undefined) {
                        console.warn(`⚠️ 宝石属性 ${selectedGem.key} 不存在，正在初始化...`);
                        player.mining.gems[selectedGem.key] = 0;
                    }
                    
                    // 增加宝石数量
                    player.mining.gems[selectedGem.key] += 1;
                    
                    // 发送通知
                    const prefix = isOffline ? '离线' : '';
                    addMiningNotification(`${prefix}发现 ${selectedGem.name}！`, 'gem');
                    
                    // 验证宝石数量确实增加了
                    const gemsAfter = {...player.mining.gems};
                    console.log('挖掘后宝石数量:', gemsAfter);
                    
                    if (gemsAfter[selectedGem.key] === gemsBefore[selectedGem.key] + 1) {
                        console.log(`✅ 成功获得宝石: ${selectedGem.name}, 数量: ${gemsAfter[selectedGem.key]}`);
                    } else {
                        console.error(`❌ 宝石数量未增加! 之前: ${gemsBefore[selectedGem.key]}, 之后: ${gemsAfter[selectedGem.key]}`);
                    }
                    
                    return true;
                }
            }
        }
        
        console.log('本次挖掘未发现宝石');
        return false;
    }


       function mine() {
        if (!player.mining.isMining) return;
        
        // 检查体力
        if (player.mining.stamina < 1) {
            player.mining.isMining = false;
            addMiningNotification('体力不足，自动挖矿停止！请使用体力药水恢复体力。', 'warning');
            updateMiningUI();
            return;
        }
        
        // 消耗体力
        player.mining.stamina -= 1;
        
        // 增加深度
        const depthGain = player.mining.power;
        player.mining.depth += depthGain;
        
        // 获得矿石
        const oreGain = Math.floor(player.mining.power * (0.2 + Math.random() * 0.5));
        player.mining.ore += oreGain;
        
        // 宝石发现逻辑
        const gemFound = findGem(player.mining.depth, player.mining.upgrades.detector, false);
        
        // 每挖掘100次自动保存
        if (player.mining.depth % 100 === 0) {
            saveGame();
        }
        
        updateMiningUI();
    }

        function useMiningPotion() {
            if (player.mining.potions > 0 && player.mining.stamina < getMiningMaxStamina()) {
                player.mining.potions -= 1;
                player.mining.stamina = getMiningMaxStamina();
                addMiningNotification('使用体力药水，恢复全部体力！');
                updateMiningUI();
                saveGame();
            }
        }

        function buyMiningPotion() {
            const cost = 1;
            if (player.items.primaryGemq >= cost) {
                player.items.primaryGemq -= cost;
                player.mining.potions += 1;
                addMiningNotification(`花费${cost}宝藏金币购买1个体力药水`);
                updateMiningUI();
                saveGame();
            } else {
                addMiningNotification('宝藏金币不足，无法购买药水', 'warning');
            }
        }

        function upgradeMiningPower() {
            if (player.mining.upgrades.power >= 100) {
                addMiningNotification('镐头已达到最大等级(100级)！', 'warning');
                return;
            }
            
            const cost = 1000 * player.mining.upgrades.power;
            if (player.mining.ore >= cost) {
                player.mining.ore -= cost;
                player.mining.power += 1;
                player.mining.upgrades.power += 1;
                addMiningNotification(`升级镐头成功！当前等级: ${player.mining.upgrades.power}`);
                updateMiningUI();
                saveGame();
            } else {
                addMiningNotification(`矿石不足，需要${cost}矿石`, 'warning');
            }
        }

        function upgradeMiningStamina() {
            if (player.mining.staminaUpgradeLevel >= 10) {
                addMiningNotification('体力上限已达到最大等级(10级)！', 'warning');
                return;
            }
            
            const cost = 10000 * player.mining.staminaUpgradeLevel;
            if (player.mining.ore >= cost) {
                player.mining.ore -= cost;
                
                // 保存当前体力比例
                const oldMaxStamina = getMiningMaxStamina();
                const staminaRatio = player.mining.stamina / oldMaxStamina;
                
                // 升级
                player.mining.staminaUpgradeLevel += 1;
                const newMaxStamina = getMiningMaxStamina();
                
                // 按比例恢复体力
                player.mining.stamina = Math.floor(newMaxStamina * staminaRatio);
                
                addMiningNotification(`升级体力上限成功！当前等级: ${player.mining.staminaUpgradeLevel}`);
                updateMiningUI();
                saveGame();
            } else {
                addMiningNotification(`矿石不足，需要${cost}矿石`, 'warning');
            }
        }

        function upgradeMiningDetector() {
            if (player.mining.upgrades.detector >= 10) {
                addMiningNotification('宝石探测器已达到最大等级(10级)！', 'warning');
                return;
            }
            
            const cost = 50000 * player.mining.upgrades.detector;
            if (player.mining.ore >= cost) {
                player.mining.ore -= cost;
                player.mining.upgrades.detector += 1;
                addMiningNotification(`升级宝石探测器成功！当前等级: ${player.mining.upgrades.detector}`);
                updateMiningUI();
                saveGame();
            } else {
                addMiningNotification(`矿石不足，需要${cost}矿石`, 'warning');
            }
        }

     function calculateOfflineMining() {
        const now = Date.now();
        const elapsed = Math.min(now - player.mining.lastUpdate, 86400000); // 最多24小时
        
        if (elapsed > 1000 && player.mining.isMining) {
            const seconds = Math.floor(elapsed / 1000);
            const maxStamina = getMiningMaxStamina();
            
            // 计算离线期间可以挖掘的次数
            const possibleMines = Math.min(seconds, player.mining.stamina);
            
            if (possibleMines > 0) {
                let gemsFound = 0;
                
                console.log(`开始离线挖矿: ${possibleMines}次, 当前深度: ${player.mining.depth}`);
                
                // 模拟离线挖掘
                for (let i = 0; i < possibleMines; i++) {
                    // 消耗体力
                    player.mining.stamina -= 1;
                    
                    // 增加深度
                    player.mining.depth += player.mining.power;
                    
                    // 获得矿石
                    const oreGain = Math.floor(player.mining.power * (0.2 + Math.random() * 0.5));
                    player.mining.ore += oreGain;
                    
                    // 宝石发现逻辑
                    if (findGem(player.mining.depth, player.mining.upgrades.detector, true)) {
                        gemsFound++;
                    }
                }
                
                console.log(`离线挖矿完成: 发现${gemsFound}个宝石`);
                
                if (possibleMines > 0) {
                    addMiningNotification(`离线期间挖掘了 ${possibleMines} 次，发现 ${gemsFound} 个宝石！`);
                }
            }
        }
        
        player.mining.lastUpdate = now;
        updateMiningUI();
    }


        // 初始化无尽挖矿系统
       function initMiningSystem() {
            if (!window.miningInterval) {
                window.miningInterval = setInterval(() => {
                    if (player.mining.isMining) {
                        mine();
                    }
                }, 1000);
            }
            
            window.addEventListener('beforeunload', () => {
                if (window.miningInterval) {
                    clearInterval(window.miningInterval);
                }
            });
        }


        setTimeout(initMiningSystem, 1000);
function initMiningData() {
        if (!player.mining) {
            player.mining = {
                depth: 0,
                power: 1,
                isMining: false,
                ore: 100,
                stamina: 100,
                baseMaxStamina: 100,
                staminaUpgradeLevel: 1,
                potions: 3,
                gems: {
                    ruby: 0,
                    sapphire: 0,
                    emerald: 0,
                    amethyst: 0,
                    diamond: 0
                },
                upgrades: {
                    power: 1,
                    detector: 1
                },
                notifications: [],
                lastUpdate: Date.now()
            };
        }
        
        // 确保所有宝石属性都存在
        for (let i = 0; i < miningGemsConfig.length; i++) {
            const gem = miningGemsConfig[i];
            if (player.mining.gems[gem.key] === undefined) {
                console.log(`初始化宝石属性: ${gem.key}`);
                player.mining.gems[gem.key] = 0;
            }
        }
    }
function initInvestmentGame() {
    if (!player.investmentGame) {
        player.investmentGame = {
            // 股票数据
            stocks: [
                {code: "zj0001", name: "鱼鱼基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0002", name: "闫闫基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},           
                {code: "zj0003", name: "茶茶金股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0004", name: "麒麟企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0005", name: "云南白药", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0006", name: "黑三逢源", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0007", name: "乐途企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0008", name: "PDD企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0009", name: "空白控股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0010", name: "慢手企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0011", name: "斗音公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0012", name: "阿里妈妈", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0013", name: "淘宝宝", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0014", name: "千达有限", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0015", name: "通元房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0016", name: "预言鱼塘", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0017", name: "新股长虹", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0018", name: "萩萩萩萩音乐", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0019", name: "盛通快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0020", name: "十鼎洗浴", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0021", name: "九鼎红楼", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0022", name: "星巴克", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0023", name: "大吴疆土", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0024", name: "九转仙股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0025", name: "乌龟科技", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0026", name: "阿斯塔特", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0027", name: "万里药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0028", name: "万里证券", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0029", name: "顶峰相见", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0030", name: "顺封快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0031", name: "晋商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0032", name: "爆涨房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0033", name: "书法银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0034", name: "阳城银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0035", name: "程羽银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0036", name: "中铁银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0037", name: "工商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0038", name: "明港基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0039", name: "东坑企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0040", name: "黑龙银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0041", name: "韵达银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0042", name: "巴士企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0043", name: "京东公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0044", name: "科技企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0045", name: "羊同药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0046", name: "风雪药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0047", name: "霸王别姬", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0048", name: "一点点奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0049", name: "古茗奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0050", name: "蜜雪冰城", price: 10.00, change: 0, holdings: 0, costPrice: 0}
            ],
            // 用户数据
            userData: {
                availableFunds: 1000.00,
                totalAssets: 1000.00,
                holdingPercent: 0.00,
                todayProfit: 0.00,
                tradeCount: 16,
                initialFunds: 1000.00,
                lastUpdateTime: Date.now()
            },
            // 当前选中的股票
            currentStockIndex: 0,
            // 交易数据
            tradeData: {
                quantity: 0,
                type: "buy",
                feeRate: 0.0048
            },
            // 图表缓存
            chartHistoryCache: {},
            // 定时器
            priceUpdateTimer: null,
            chartUpdateTimer: null
        };
    }
}

// 切换模拟投资游戏界面
function toggleInvestmentGame() {
    if (player.battle.maxStage < 2) {
        alert("需要打怪模式达到第3层才能开启疯狂地主！");
        return;
    }
    const ui = document.getElementById('investmentGameUI');
    if (ui.style.display === 'none') {
        // 初始化游戏数据
        initInvestmentGame();
        // 模拟离线期间的价格变化
        simulateOfflinePriceChanges();
        // 生成游戏界面
        renderInvestmentGame();
        // 开始价格模拟
        startPriceSimulation();
        ui.style.display = 'block';
    } else {
        closeInvestmentGame();
    }
}
function simulateOfflinePriceChanges() {
    if (!player.investmentGame || !player.investmentGame.userData) {
        return;
    }
    
    const game = player.investmentGame;
    const now = Date.now();
    const lastUpdate = game.userData.lastUpdateTime || now;
    const timeDiff = now - lastUpdate;
    const minutesDiff = Math.floor(timeDiff / (1000 * 60));
    
    if (minutesDiff > 0) {
        console.log(`模拟离线 ${minutesDiff} 分钟的价格变化`);
        
        // 为每个股票生成独特的随机性参数
        game.stocks.forEach((stock, index) => {
            if (!stock.randomParams) {
                // 生成该股票的特征参数
                stock.randomParams = {
                    // 基础波动率 (0.5% - 3%)
                    baseVolatility: 0.005 + Math.random() * 0.025,
                    // 趋势强度 (-0.1% 到 0.1% 每分钟)
                    trendStrength: (Math.random() - 0.5) * 0.002,
                    // 随机事件概率 (0.1% 每分钟)
                    eventProbability: 0.001,
                    // 均值回归强度
                    meanReversion: 0.2 + Math.random() * 0.3,
                    // 噪声因子
                    noiseLevel: Math.random() * 0.8 + 0.2,
                    // 上次的大波动方向
                    lastBigMove: 0
                };
            }
        });
        
        // 每分钟模拟一次
        for (let i = 0; i < minutesDiff; i++) {
            // 每分钟可能会有市场整体事件
            const marketEventRoll = Math.random();
            let marketEffect = 0;
            
            if (marketEventRoll < 0.0005) { // 0.05% 概率有重大市场事件
                marketEffect = (Math.random() - 0.5) * 0.1; // ±10%
                console.log(`第 ${i} 分钟: 发生重大市场事件，影响: ${(marketEffect * 100).toFixed(2)}%`);
            } else if (marketEventRoll < 0.005) { // 0.5% 概率有小事件
                marketEffect = (Math.random() - 0.5) * 0.03; // ±3%
            }
            
            game.stocks.forEach((stock, index) => {
                const params = stock.randomParams;
                const basePrice = stock.basePrice || 10;
                
                // 1. 趋势成分
                const trendChange = params.trendStrength;
                
                // 2. 随机波动 (使用不同的随机数源增加随机性)
                const rand1 = Math.random();
                const rand2 = Math.random();
                const rand3 = Math.sin(i * 0.1 + index) * 0.5 + 0.5; // 周期性噪声
                
                // 使用多种随机数组合
                const combinedRand = (rand1 + rand2 + rand3) / 3;
                
                // 随机波动幅度 (正态分布近似)
                let volatility = params.baseVolatility;
                
                // 3. 随机事件
                if (Math.random() < params.eventProbability) {
                    const eventType = Math.random();
                    if (eventType < 0.3) { // 30% 利好消息
                        volatility *= 3;
                        console.log(`股票 ${stock.code} 有利好消息`);
                    } else if (eventType < 0.6) { // 30% 利空消息
                        volatility *= 3;
                        trendChange -= 0.01; // 临时趋势下降
                    }
                    // 40% 无特殊事件
                }
                
                // 4. 均值回归 (价格偏离太远时会回归)
                const deviationFromMean = (stock.price - basePrice) / basePrice;
                const reversionForce = -deviationFromMean * params.meanReversion * 0.01;
                
                // 5. 计算价格变化
                let priceChange = 0;
                
                // 使用不同的价格变化模型增加随机性
                const modelChoice = i % 5; // 每5分钟换一种模型
                
                switch (modelChoice) {
                    case 0: // 简单随机游走
                        priceChange = (combinedRand - 0.5) * 2 * volatility;
                        break;
                    case 1: // 有动量的随机游走
                        const momentum = stock.lastChange || 0;
                        priceChange = (combinedRand - 0.5) * 2 * volatility + momentum * 0.3;
                        break;
                    case 2: // 跳跃扩散
                        if (Math.random() < 0.01) { // 1% 概率跳跃
                            priceChange = (Math.random() - 0.5) * volatility * 5;
                        } else {
                            priceChange = (combinedRand - 0.5) * 2 * volatility;
                        }
                        break;
                    case 3: // 均值回归模型
                        priceChange = (combinedRand - 0.5) * 2 * volatility + reversionForce;
                        break;
                    default: // GARCH-like 波动聚类
                        const volatilityMultiplier = 0.5 + Math.abs(stock.lastChange || 0) * 10;
                        priceChange = (combinedRand - 0.5) * 2 * volatility * volatilityMultiplier;
                }
                
                // 添加趋势
                priceChange += trendChange;
                
                // 添加市场整体影响
                priceChange += marketEffect;
                
                // 添加微小噪声
                const microNoise = (Math.random() - 0.5) * volatility * 0.1;
                priceChange += microNoise;
                
                // 记录上一次变化用于动量计算
                stock.lastChange = priceChange;
                
                // 应用变化
                const oldPrice = stock.price;
                stock.price *= (1 + priceChange);
                
                // 确保价格合理性
                if (stock.price < 1) stock.price = 1 + Math.random() * 2; // 最低1元
                if (stock.price > 100) stock.price = 100 - Math.random() * 10; // 最高100元
                
                // 防止价格停滞
                if (Math.abs(stock.price - oldPrice) < 0.001) {
                    stock.price += (Math.random() - 0.5) * 0.01;
                }
            });
            
            // 偶尔让股票间产生相关性
            if (i % 10 === 0) { // 每10分钟一次
                const correlationEffect = (Math.random() - 0.5) * 0.02;
                const sector = Math.floor(Math.random() * 3); // 随机选择一个"板块"
                
                game.stocks.forEach((stock, index) => {
                    if (index % 3 === sector) { // 同板块股票一起波动
                        stock.price *= (1 + correlationEffect);
                    }
                });
            }
        }
        
        // 更新涨跌幅
        game.stocks.forEach(stock => {
            const basePrice = stock.basePrice || 10;
            stock.change = ((stock.price - basePrice) / basePrice * 100);
        });
        
        // 更新最后更新时间
        game.userData.lastUpdateTime = now;
        
        // 更新总资产
        updateInvestmentTotalAssets();
        
        // 记录一些统计信息
        const avgChange = game.stocks.reduce((sum, s) => sum + s.change, 0) / game.stocks.length;
        const maxChange = Math.max(...game.stocks.map(s => s.change));
        const minChange = Math.min(...game.stocks.map(s => s.change));
        
        logAction(`离线${minutesDiff}分钟: 平均涨跌幅${avgChange.toFixed(2)}%, 最大${maxChange.toFixed(2)}%, 最小${minChange.toFixed(2)}%`, 'info');
    }
}
function closeInvestmentGame() {
    const ui = document.getElementById('investmentGameUI');
    ui.style.display = 'none';
    
    // 清理定时器
    const game = player.investmentGame;
    if (game.priceUpdateTimer) {
        clearInterval(game.priceUpdateTimer);
        game.priceUpdateTimer = null;
    }
    if (game.chartUpdateTimer) {
        clearInterval(game.chartUpdateTimer);
        game.chartUpdateTimer = null;
    }
    
    // 保存游戏数据
    saveGame();
}

// 渲染模拟投资游戏界面
function renderInvestmentGame() {
    const content = document.getElementById('investmentGameContent');
    const game = player.investmentGame;
    
    content.innerHTML = `
        <style>
            .investment-game * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            }
            
            .investment-game {
                background-color: #f5f7fa;
                color: #333;
                line-height: 1.6;
                padding: 20px;
                max-width: 1200px;
                margin: 0 auto;
            }
            
            .investment-game .header {
                text-align: center;
                margin-bottom: 25px;
                padding-bottom: 15px;
                border-bottom: 2px solid #e0e6ef;
                position: relative;
            }
            
            .investment-game h1 {
                color: #2c3e50;
                font-size: 2.2rem;
                margin-bottom: 8px;
            }
            
            .investment-game .subtitle {
                color: #7f8c8d;
                font-size: 1rem;
            }
            
            .investment-game .tabs {
                display: flex;
                background: white;
                border-radius: 12px 12px 0 0;
                overflow: hidden;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
                margin-bottom: 0;
            }
            
            .investment-game .tab {
                flex: 1;
                padding: 18px 5px;
                text-align: center;
                cursor: pointer;
                background: #f8f9fa;
                border-bottom: 3px solid transparent;
                transition: all 0.3s ease;
                font-weight: 600;
                color: #6c757d;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 6px;
            }
            
            .investment-game .tab i {
                font-size: 1.2rem;
            }
            
            .investment-game .tab.active {
                background: white;
                color: #4361ee;
                border-bottom: 3px solid #4361ee;
            }
            
            .investment-game .tab-content {
                display: none;
                background: white;
                padding: 25px;
                border-radius: 0 0 12px 12px;
                box-shadow: 0 6px 15px rgba(0, 0, 0, 0.08);
                min-height: 550px;
            }
            
            .investment-game .tab-content.active {
                display: block;
            }
            
            .investment-game .stock-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 25px;
                padding-bottom: 15px;
                border-bottom: 1px solid #eaeaea;
            }
            
            .investment-game .stock-name {
                font-size: 1.8rem;
                font-weight: 700;
                color: #2c3e50;
            }
            
            .investment-game .stock-price {
                font-size: 2.5rem;
                font-weight: 800;
                color: #10b981;
            }
            
            .investment-game .stock-price.down {
                color: #ef4444;
            }
            
            .investment-game .holdings-info {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                margin-bottom: 25px;
                background: #f8fafc;
                padding: 20px;
                border-radius: 10px;
            }
            
            .investment-game .info-item {
                display: flex;
                justify-content: space-between;
                padding: 10px 0;
                border-bottom: 1px dashed #e2e8f0;
            }
            
            .investment-game .info-item:last-child {
                border-bottom: none;
            }
            
            .investment-game .info-label {
                color: #64748b;
                font-weight: 500;
            }
            
            .investment-game .info-value {
                font-weight: 600;
                color: #334155;
            }
            
            .investment-game .transaction-section {
                margin-top: 30px;
            }
            
            .investment-game .transaction-title {
                font-size: 1.3rem;
                margin-bottom: 20px;
                color: #2c3e50;
                padding-bottom: 10px;
                border-bottom: 2px solid #e0e6ef;
            }
            
            .investment-game .transaction-form {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 25px;
            }
            
            .investment-game .form-group {
                margin-bottom: 20px;
            }
            
            .investment-game .form-label {
                display: block;
                margin-bottom: 8px;
                font-weight: 600;
                color: #475569;
            }
            
            .investment-game .input-group {
                display: flex;
                border: 1px solid #cbd5e1;
                border-radius: 8px;
                overflow: hidden;
            }
            
            .investment-game .input-group input {
                flex: 1;
                border: none;
                padding: 12px 15px;
                font-size: 1rem;
                outline: none;
            }
            
            .investment-game .input-group .unit {
                background: #f1f5f9;
                padding: 12px 15px;
                color: #475569;
                font-weight: 500;
            }
            
            .investment-game .quantity-buttons {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 10px;
            }
            
            .investment-game .qty-btn {
                flex: 1;
                min-width: calc(20% - 8px);
                padding: 10px 5px;
                background: #f1f5f9;
                border: 1px solid #cbd5e1;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 500;
                transition: all 0.2s;
                text-align: center;
            }
            
            .investment-game .qty-btn:hover {
                background: #e2e8f0;
            }
            
            .investment-game .qty-btn.highlight {
                background: #3b82f6;
                color: white;
                border-color: #3b82f6;
            }
            
            .investment-game .transaction-type {
                display: flex;
                gap: 15px;
                margin-top: 10px;
            }
            
            .investment-game .type-option {
                flex: 1;
                text-align: center;
                padding: 12px;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.2s;
            }
            
            .investment-game .type-option.active {
                border-color: #3b82f6;
                background: #eff6ff;
                color: #3b82f6;
            }
            
            .investment-game .type-buy.active {
                border-color: #10b981;
                background: #d1fae5;
                color: #10b981;
            }
            
            .investment-game .type-sell.active {
                border-color: #ef4444;
                background: #fee2e2;
                color: #ef4444;
            }
            
            .investment-game .fee-info {
                background: #fef3c7;
                padding: 12px 15px;
                border-radius: 8px;
                margin: 20px 0;
                color: #92400e;
                font-size: 0.95rem;
            }
            
            .investment-game .chart-container {
                margin-top: 30px;
                border-top: 1px solid #eaeaea;
                padding-top: 25px;
            }
            
            .investment-game .chart-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }
            
            .investment-game .chart-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #2c3e50;
            }
            
            .investment-game .time-filters {
                display: flex;
                gap: 10px;
            }
            
            .investment-game .time-filter {
                padding: 8px 15px;
                background: #f1f5f9;
                border-radius: 20px;
                font-size: 0.9rem;
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .investment-game .time-filter.active {
                background: #3b82f6;
                color: white;
            }
            
            .investment-game .chart-placeholder {
                height: 250px;
                background: #f8fafc;
                border-radius: 10px;
                position: relative;
                overflow: hidden;
                border: 1px solid #e2e8f0;
            }
            
            .investment-game .submit-section {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-top: 25px;
                padding-top: 20px;
                border-top: 1px solid #eaeaea;
            }
            
            .investment-game .trade-count {
                color: #6b7280;
                font-size: 0.95rem;
            }
            
            .investment-game .trade-count span {
                color: #3b82f6;
                font-weight: 600;
            }
            
            .investment-game .btn-submit {
                padding: 14px 40px;
                background: #3b82f6;
                color: white;
                border: none;
                border-radius: 8px;
                font-weight: 600;
                font-size: 1.1rem;
                cursor: pointer;
                transition: all 0.3s;
            }
            
            .investment-game .btn-submit:hover {
                background: #2563eb;
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(37, 99, 235, 0.2);
            }
            
            .investment-game .assets-header {
                background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
                color: white;
                padding: 25px;
                border-radius: 12px;
                margin-bottom: 25px;
            }
            
            .investment-game .assets-stats {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
            }
            
            .investment-game .stat-item {
                background: rgba(255, 255, 255, 0.1);
                padding: 20px;
                border-radius: 10px;
                backdrop-filter: blur(10px);
            }
            
            .investment-game .stat-label {
                font-size: 0.9rem;
                opacity: 0.9;
                margin-bottom: 8px;
            }
            
            .investment-game .stat-value {
                font-size: 1.8rem;
                font-weight: 700;
            }
            
            .investment-game .holdings-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
                border-radius: 10px;
                overflow: hidden;
            }
            
            .investment-game .holdings-table th {
                background: #f8fafc;
                padding: 18px 15px;
                text-align: left;
                color: #475569;
                font-weight: 600;
                border-bottom: 2px solid #e2e8f0;
            }
            
            .investment-game .holdings-table td {
                padding: 18px 15px;
                border-bottom: 1px solid #f1f5f9;
            }
            
            .investment-game .holdings-table tr:hover {
                background: #f8fafc;
            }
            
            .investment-game .stock-code {
                font-weight: 600;
                color: #334155;
            }
            
            .investment-game .profit-up {
                color: #10b981;
                font-weight: 600;
            }
            
            .investment-game .profit-up:after {
                content: " ↑";
            }
            
            .investment-game .profit-down {
                color: #ef4444;
                font-weight: 600;
            }
            
            .investment-game .profit-down:after {
                content: " ↓";
            }
            
            .investment-game .holding-percent {
                color: #3b82f6;
                font-weight: 600;
            }
            
            .investment-game .stocks-table-container {
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
                border: 1px solid #e2e8f0;
            }
            
            .investment-game .stocks-table {
                width: 100%;
                border-collapse: collapse;
            }
            
            .investment-game .stocks-table th {
                background: #f1f5f9;
                padding: 18px 15px;
                text-align: left;
                color: #475569;
                font-weight: 600;
            }
            
            .investment-game .stocks-table td {
                padding: 18px 15px;
                border-bottom: 1px solid #f1f5f9;
            }
            
            .investment-game .stocks-table tr:last-child td {
                border-bottom: none;
            }
            
            .investment-game .stock-item {
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .investment-game .stock-item:hover {
                background: #f8fafc;
            }
            
            .investment-game .stock-item.selected {
                background: #eff6ff;
            }
            
            .investment-game .footer-nav {
                display: flex;
                justify-content: center;
                gap: 30px;
                margin-top: 40px;
                padding-top: 20px;
                border-top: 1px solid #eaeaea;
            }
            
            .investment-game .nav-btn {
                display: flex;
                flex-direction: column;
                align-items: center;
                color: #6b7280;
                text-decoration: none;
                transition: all 0.3s;
                padding: 10px 20px;
                border-radius: 10px;
            }
            
            .investment-game .nav-btn i {
                font-size: 1.5rem;
                margin-bottom: 8px;
            }
            
            .investment-game .nav-btn.active {
                color: #3b82f6;
                background: #eff6ff;
            }
         .investment-game .notification {
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                color: white;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
                display: none;
                z-index: 1000;
                animation: slideIn 0.3s ease;
            }
            
            .investment-game .notification.success {
                background: #10b981;
            }
            
            .investment-game .notification.error {
                background: #ef4444;
            }
            
            .investment-game .notification.info {
                background: #3b82f6;
            }
            
            @keyframes slideIn {
                from {transform: translateX(100%); opacity: 0;}
                to {transform: translateX(0); opacity: 1;}
            }
            
            .investment-game .no-holding {
                text-align: center;
                padding: 40px 20px;
                color: #6b7280;
            }
            
            .investment-game .no-holding i {
                font-size: 3rem;
                margin-bottom: 15px;
                color: #cbd5e1;
            }
            
            @media (max-width: 768px) {
                .investment-game .transaction-form {
                    grid-template-columns: 1fr;
                }
                
                .investment-game .holdings-info {
                    grid-template-columns: 1fr;
                }
                
                .investment-game .assets-stats {
                    grid-template-columns: 1fr;
                }
                
                .investment-game .quantity-buttons {
                    justify-content: center;
                }
                
                .investment-game .qty-btn {
                    min-width: calc(33% - 8px);
                }
            }
        </style>
        
        <div class="investment-game">
            <div class="header">
                <h1>模拟投资交易游戏</h1>
                <p class="subtitle">虚拟交易 | 离线模拟 | 刺激体验</p>
            </div>
            
            <!-- 标签页导航 -->
            <div class="tabs">
                <div class="tab active" data-tab="trade">
                    <i class="fas fa-chart-line"></i>
                    <span>股票交易</span>
                </div>
                <div class="tab" data-tab="assets">
                    <i class="fas fa-chart-pie"></i>
                    <span>资产详情</span>
                </div>
                <div class="tab" data-tab="stocks">
                    <i class="fas fa-list"></i>
                    <span>股票列表</span>
                </div>
            </div>
            
            <!-- 股票交易界面 -->
            <div id="trade" class="tab-content active">
                <div class="stock-header">
                    <div>
                        <div class="stock-name" id="current-stock-name">${game.stocks[game.currentStockIndex].name}</div>
                        <div class="stock-update" id="update-time">股价上次更新时间：${new Date().toLocaleString()}</div>
                    </div>
                    <div class="stock-price" id="current-price">${game.stocks[game.currentStockIndex].price.toFixed(3)}</div>
                </div>
                
                <div class="holdings-info">
                    <div>
                        <div class="info-item">
                            <span class="info-label">当前持有数量：</span>
                            <span class="info-value" id="hold-amount">${game.stocks[game.currentStockIndex].holdings.toLocaleString()}</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">成本价格：</span>
                            <span class="info-value" id="cost-price">${game.stocks[game.currentStockIndex].costPrice > 0 ? game.stocks[game.currentStockIndex].costPrice.toFixed(3) : "0.000"}</span>
                        </div>
                    </div>
                    <div>
                        <div class="info-item">
                            <span class="info-label">持仓市值：</span>
                            <span class="info-value" id="hold-value">${(game.stocks[game.currentStockIndex].holdings * game.stocks[game.currentStockIndex].price).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">持仓盈亏：</span>
                            <span class="info-value" id="hold-profit">${calculateStockProfit(game.stocks[game.currentStockIndex])}</span>
                        </div>
                    </div>
                </div>
                
                <div class="transaction-section">
                    <h3 class="transaction-title">股票交易</h3>
                    
                    <div class="transaction-form">
                        <div>
                            <div class="form-group">
                                <label class="form-label">交易数量：</label>
                                <div class="input-group">
                                    <input type="number" id="trade-quantity" value="0" min="0">
                                    <div class="unit">股</div>
                                </div>
                                
                                <div class="quantity-buttons">
                                    <div class="qty-btn" data-action="0">清零</div>
                                    <div class="qty-btn" data-action="1">+1</div>
                                    <div class="qty-btn" data-action="10">+10</div>
                                    <div class="qty-btn" data-action="100">+100</div>
                                    <div class="qty-btn" data-action="max">最大</div>
                                    <div class="qty-btn" data-action="quarter">1/4仓</div>
                                    <div class="qty-btn" data-action="half">半仓</div>
                                    <div class="qty-btn" data-action="third">1/3仓</div>
                                    <div class="qty-btn" data-action="-1">-1</div>
                                    <div class="qty-btn" data-action="-10">-10</div>
                                    <div class="qty-btn" data-action="-100">-100</div>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">交易类型：</label>
                                <div class="transaction-type">
                                    <div class="type-option type-buy active" data-type="buy">买入</div>
                                    <div class="type-option type-sell" data-type="sell">卖出</div>
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <div class="form-group">
                                <label class="form-label">交易金额：</label>
                                <div class="input-group">
                                    <input type="text" id="trade-amount" value="0.00" readonly>
                                    <div class="unit">元</div>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">交易手续费：</label>
                                <div class="input-group">
                                    <input type="text" id="trade-fee" value="0.00" readonly>
                                    <div class="unit">元</div>
                                </div>
                            </div>
                            
                            <div class="fee-info">
                                交易手续费为交易资金的0.48%!本次将扣除——
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">最大可交易数量：</label>
                                <div class="input-group">
                                    <input type="text" id="max-quantity" value="0" readonly>
                                    <div class="unit">股</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="chart-header">
                            <div class="chart-title">走势图</div>
                            <div class="time-filters">
                                <div class="time-filter active" data-points="500">点击刷新走势图</div>
                            </div>
                        </div>
                        
                        <div class="chart-placeholder" id="price-chart">
                            <!-- 图表将通过JS动态生成 -->
                        </div>
                    </div>
                    
                    <div class="submit-section">
                        <div class="trade-count">可用交易次数：<span id="trade-count">${game.userData.tradeCount}</span> 
                            <a href="#" id="add-trade-count" style="color: #3b82f6; text-decoration: none;">点我增加</a>
                        </div>
                        <button class="btn-submit" id="submit-trade">提交交易</button>
                    </div>
                </div>
            </div>
            
            <!-- 资产详情界面 -->
            <div id="assets" class="tab-content">
                <div class="assets-header">
                    <h2 style="margin-bottom: 20px;">资产详情</h2>
                    <div class="assets-stats">
                        <div class="stat-item">
                            <div class="stat-label">可用资金</div>
                            <div class="stat-value" id="available-funds">${game.userData.availableFunds.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">总资产</div>
                            <div class="stat-value" id="total-assets">${game.userData.totalAssets.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">总持仓价值</div>
                            <div class="stat-value" id="total-hold-value">${calculateTotalHoldingsValue().toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">总持仓占比</div>
                            <div class="stat-value" id="total-holding-percent">${game.userData.holdingPercent.toFixed(2)}%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">总盈亏比例</div>
                            <div class="stat-value" id="today-profit">${game.userData.todayProfit >= 0 ? '+' : ''}${game.userData.todayProfit.toFixed(2)}%</div>
                        </div>
                    </div>
                </div>
                
                <h3 style="margin-bottom: 15px; color: #2c3e50;">持仓详情</h3>
                
                <table class="holdings-table" id="holdings-table">
                    <thead>
                        <tr>
                            <th>股票代码</th>
                            <th>股票名称</th>
                            <th>持股数量</th>
                            <th>当前价格</th>
                            <th>成本价格</th>
                            <th>总价格</th>
                            <th>盈亏比例</th>
                            <th>持仓占比</th>
                        </tr>
                    </thead>
                    <tbody id="holdings-body">
                        ${generateHoldingsTable()}
                    </tbody>
                </table>
                
                <div id="no-holdings" class="no-holding" style="${hasHoldings() ? 'display: none;' : ''}">
                    <i class="fas fa-chart-line"></i>
                    <h3>暂无持仓</h3>
                    <p>您还没有持有任何股票，快去交易页面买入股票吧！</p>
                </div>
            </div>
            
            <!-- 股票列表界面 -->
            <div id="stocks" class="tab-content">
                <h2 style="font-size: 1.8rem; margin-bottom: 25px; color: #2c3e50; text-align: center;">股票列表</h2>
                
                <div class="stocks-table-container">
                    <table class="stocks-table">
                        <thead>
                            <tr>
                                <th>股票代码</th>
                                <th>股票名称</th>
                                <th>当前价格</th>
                                <th>涨跌幅</th>
                            </tr>
                        </thead>
                        <tbody id="stocks-list">
                            ${generateStocksList()}
                        </tbody>
                    </table>
                </div>
                
                <div class="footer-nav">
                    <a href="#" class="nav-btn" data-nav="trade">
                        <i class="fas fa-chart-line"></i>
                        <span>股票交易</span>
                    </a>
                    <a href="#" class="nav-btn" data-nav="assets">
                        <i class="fas fa-chart-pie"></i>
                        <span>资产详情</span>
                    </a>
                </div>
            </div>
            
            <!-- 交易成功提示 -->
            <div class="notification" id="investment-notification"></div>
        </div>
    `;
    
    // 初始化事件监听
    initInvestmentEventListeners();
    // 初始化价格图表
    initInvestmentChart();
    // 更新交易信息
    updateInvestmentTradeInfo();
}

// 计算单只股票的盈亏
function calculateStockProfit(stock) {
    if (stock.costPrice <= 0 || stock.holdings <= 0) {
        return "0.00 (0.00%)";
    }
    
    const profit = (stock.price - stock.costPrice) * stock.holdings;
    const profitPercent = ((stock.price - stock.costPrice) / stock.costPrice * 100);
    
    return `${profit >= 0 ? '+' : ''}${profit.toFixed(2)} (${profit >= 0 ? '+' : ''}${profitPercent.toFixed(2)}%)`;
}

// 计算总持仓价值
function calculateTotalHoldingsValue() {
    const game = player.investmentGame;
    return game.stocks.reduce((sum, stock) => {
        return sum + (stock.holdings * stock.price);
    }, 0);
}

// 生成持仓表格
function generateHoldingsTable() {
    const game = player.investmentGame;
    const holdings = game.stocks.filter(stock => stock.holdings > 0);
    
    if (holdings.length === 0) {
        return '';
    }
    
    return holdings.map(stock => {
        const holdValue = stock.holdings * stock.price;
        const profitPercent = stock.costPrice > 0 ? 
            ((stock.price - stock.costPrice) / stock.costPrice * 100) : 0;
        const holdingPercent = (holdValue / game.userData.totalAssets * 100);
        
        return `
            <tr>
                <td class="stock-code">${stock.code}</td>
                <td>${stock.name}</td>
                <td>${stock.holdings.toLocaleString()}</td>
                <td>${stock.price.toFixed(3)}</td>
                <td>${stock.costPrice > 0 ? stock.costPrice.toFixed(3) : "0.000"}</td>
                <td>${holdValue.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                <td class="${profitPercent >= 0 ? 'profit-up' : 'profit-down'}">${profitPercent >= 0 ? '+' : ''}${profitPercent.toFixed(2)}%</td>
                <td class="holding-percent">${holdingPercent.toFixed(2)}%</td>
            </tr>
        `;
    }).join('');
}

// 检查是否有持仓
function hasHoldings() {
    const game = player.investmentGame;
    return game.stocks.some(stock => stock.holdings > 0);
}

// 生成股票列表
function generateStocksList() {
    const game = player.investmentGame;
    return game.stocks.map(stock => {
        return `
            <tr class="stock-item" data-code="${stock.code}">
                <td class="stock-code">${stock.code}</td>
                <td>${stock.name}</td>
                <td>${stock.price.toFixed(3)}</td>
                <td class="${stock.change >= 0 ? 'profit-up' : 'profit-down'}">${stock.change >= 0 ? '+' : ''}${stock.change.toFixed(2)}%</td>
            </tr>
        `;
    }).join('');
}

// 初始化投资游戏事件监听
function initInvestmentEventListeners() {
    const game = player.investmentGame;
    
    // 标签页切换
    document.querySelectorAll('.investment-game .tab').forEach(tab => {
        tab.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');
            
            // 更新活跃标签
            document.querySelectorAll('.investment-game .tab').forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            // 更新活跃内容
            document.querySelectorAll('.investment-game .tab-content').forEach(content => {
                content.classList.remove('active');
                if (content.id === tabId) {
                    content.classList.add('active');
                }
            });
            
            // 更新底部导航
            document.querySelectorAll('.investment-game .nav-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-nav') === tabId) {
                    btn.classList.add('active');
                }
            });
        });
    });
    
    // 底部导航点击
    document.querySelectorAll('.investment-game .nav-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            const tabId = this.getAttribute('data-nav');
            const targetTab = document.querySelector(`.investment-game .tab[data-tab="${tabId}"]`);
            if (targetTab) {
                targetTab.click();
            }
        });
    });
    
    // 股票列表项点击
    document.querySelectorAll('.investment-game .stock-item').forEach(item => {
        item.addEventListener('click', function() {
            const stockCode = this.getAttribute('data-code');
            const stockIndex = game.stocks.findIndex(s => s.code === stockCode);
            if (stockIndex >= 0) {
                game.currentStockIndex = stockIndex;
                // 切换到交易标签页
                document.querySelector('.investment-game .tab[data-tab="trade"]').click();
                // 更新显示
                updateInvestmentStockDisplay();
                updateInvestmentTradeInfo();
                updateInvestmentHoldingsInfo();
                updateInvestmentChart();
                showInvestmentNotification(`已切换到股票: ${game.stocks[stockIndex].name}`, 'info');
            }
        });
    });
    
    // 交易数量按钮
    document.querySelectorAll('.investment-game .qty-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const action = this.getAttribute('data-action');
            updateInvestmentTradeQuantity(action);
        });
    });
    
    // 交易类型切换
    document.querySelectorAll('.investment-game .type-option').forEach(option => {
        option.addEventListener('click', function() {
            document.querySelectorAll('.investment-game .type-option').forEach(opt => {
                opt.classList.remove('active');
            });
            this.classList.add('active');
            game.tradeData.type = this.getAttribute('data-type');
            updateInvestmentTradeInfo();
        });
    });
    
    // 交易数量输入
    const quantityInput = document.getElementById('trade-quantity');
    quantityInput.addEventListener('input', updateInvestmentTradeInfo);
    quantityInput.addEventListener('change', updateInvestmentTradeInfo);
    
    // 增加交易次数按钮
    document.getElementById('add-trade-count').addEventListener('click', function(e) {
        e.preventDefault();
        game.userData.tradeCount += 5;
        document.getElementById('trade-count').textContent = game.userData.tradeCount;
        showInvestmentNotification('交易次数已增加5次！', 'success');
        saveGame();
    });
    
    // 提交交易按钮
    document.getElementById('submit-trade').addEventListener('click', submitInvestmentTrade);
    
    // 时间过滤器
    document.querySelectorAll('.investment-game .time-filter').forEach(filter => {
        filter.addEventListener('click', function() {
            document.querySelectorAll('.investment-game .time-filter').forEach(f => {
                f.classList.remove('active');
            });
            this.classList.add('active');
            updateInvestmentChartFromCache(500);
        });
    });
}

// 更新股票显示
function updateInvestmentStockDisplay() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    
    document.getElementById('current-stock-name').textContent = currentStock.name;
    document.getElementById('current-price').textContent = currentStock.price.toFixed(3);
    
    // 根据涨跌设置颜色
    const priceElement = document.getElementById('current-price');
    if (currentStock.change >= 0) {
        priceElement.className = 'stock-price';
    } else {
        priceElement.className = 'stock-price down';
    }
    
    // 更新时间显示
    document.getElementById('update-time').textContent = `股价上次更新时间：${new Date().toLocaleString()}`;
}

// 更新交易数量
function updateInvestmentTradeQuantity(action) {
    const quantityInput = document.getElementById('trade-quantity');
    let quantity = parseInt(quantityInput.value) || 0;
    const maxQuantity = calculateInvestmentMaxQuantity();
    
    switch(action) {
        case '0':
            quantity = 0;
            break;
        case 'max':
            quantity = maxQuantity;
            break;
        case 'quarter':
            quantity = Math.floor(maxQuantity / 4);
            break;
        case 'half':
            quantity = Math.floor(maxQuantity / 2);
            break;
        case 'third':
            quantity = Math.floor(maxQuantity / 3);
            break;
        default:
            quantity += parseInt(action);
            if (quantity < 0) quantity = 0;
            if (quantity > maxQuantity) quantity = maxQuantity;
            break;
    }
    
    quantityInput.value = quantity;
    updateInvestmentTradeInfo();
}

// 计算最大可交易数量
function calculateInvestmentMaxQuantity() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    
    if (game.tradeData.type === 'buy') {
        // 根据可用资金计算最大可买入数量
        const maxByFunds = Math.floor(game.userData.availableFunds / (currentStock.price * (1 + game.tradeData.feeRate)));
        return Math.min(maxByFunds, 1000000000000000); // 限制最大1000万亿股
    } else {
        // 卖出时最多可卖出持有数量
        return currentStock.holdings;
    }
}

// 更新交易信息
function updateInvestmentTradeInfo() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    const quantityInput = document.getElementById('trade-quantity');
    const amountInput = document.getElementById('trade-amount');
    const feeInput = document.getElementById('trade-fee');
    const maxQuantityInput = document.getElementById('max-quantity');
    
    // 更新交易数量
    let quantity = parseInt(quantityInput.value) || 0;
    const maxQuantity = calculateInvestmentMaxQuantity();
    
    if (quantity > maxQuantity) {
        quantity = maxQuantity;
        quantityInput.value = quantity;
    }
    
    // 计算交易金额和手续费
    const amount = quantity * currentStock.price;
    const fee = amount * game.tradeData.feeRate;
    
    // 更新显示
    amountInput.value = amount.toFixed(2);
    feeInput.value = fee.toFixed(2);
    maxQuantityInput.value = maxQuantity.toLocaleString();
    
    // 更新持仓信息
    updateInvestmentHoldingsInfo();
}

// 更新持仓信息
function updateInvestmentHoldingsInfo() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    const holdValue = currentStock.holdings * currentStock.price;
    const profit = (currentStock.price - currentStock.costPrice) * currentStock.holdings;
    const profitPercent = currentStock.costPrice > 0 ? 
        ((currentStock.price - currentStock.costPrice) / currentStock.costPrice * 100) : 0;
    
    document.getElementById('hold-amount').textContent = currentStock.holdings.toLocaleString();
    document.getElementById('cost-price').textContent = currentStock.costPrice > 0 ? 
        currentStock.costPrice.toFixed(3) : "0.000";
    document.getElementById('hold-value').textContent = holdValue.toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
    
    const profitText = currentStock.costPrice > 0 ? 
        `${profit >= 0 ? '+' : ''}${profit.toFixed(2)} (${profit >= 0 ? '+' : ''}${profitPercent.toFixed(2)}%)` : 
        "0.00 (0.00%)";
    
    const profitElement = document.getElementById('hold-profit');
    profitElement.textContent = profitText;
    
    if (profit > 0) {
        profitElement.className = 'info-value profit-up';
    } else if (profit < 0) {
        profitElement.className = 'info-value profit-down';
    } else {
        profitElement.className = 'info-value';
    }
}

// 初始化价格图表
function initInvestmentChart() {
    updateInvestmentChartFromCache(500);
}

// 从缓存更新图表
function updateInvestmentChartFromCache(points) {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    const chartContainer = document.getElementById('price-chart');
    
    // 生成图表数据
    const data = generateInvestmentChartData(currentStock.code, points);
    
    // 创建SVG图表
    chartContainer.innerHTML = `
        <svg width="100%" height="100%" viewBox="0 0 800 300" preserveAspectRatio="none">
            ${generateInvestmentChartSVG(data, currentStock)}
        </svg>
    `;
}

// 生成图表数据
function generateInvestmentChartData(stockCode, points) {
    const game = player.investmentGame;
    const cacheKey = `${stockCode}_${points}`;
    const stock = game.stocks.find(s => s.code === stockCode);
    
    if (!stock) return [];
    
    // 检查缓存
    if (game.chartHistoryCache[cacheKey]) {
        return game.chartHistoryCache[cacheKey];
    }
    
    // 生成模拟数据
    const data = [];
    let currentPrice = stock.price * (0.9 + Math.random() * 0.2); // 随机起始价格
    
    for (let i = 0; i < points; i++) {
        // 模拟价格波动
        const change = (Math.random() - 0.5) * 0.02 * currentPrice;
        currentPrice += change;
        
        // 确保价格合理
        currentPrice = Math.max(5, Math.min(30, currentPrice));
        
        data.push(currentPrice);
    }
    
    // 确保最后一个点是当前价格
    data[points - 1] = stock.price;
    
    // 缓存数据
    game.chartHistoryCache[cacheKey] = data;
    return data;
}

// 生成SVG图表
function generateInvestmentChartSVG(data, stock) {
    if (data.length === 0) return '';
    
    const width = 800;
    const height = 300;
    const minPrice = Math.min(...data);
    const maxPrice = Math.max(...data);
    const range = maxPrice - minPrice || 1;
    
    // 生成路径
    let pathData = '';
    data.forEach((price, index) => {
        const x = (index / (data.length - 1)) * width;
        const y = height - ((price - minPrice) / range) * height;
        
        if (index === 0) {
            pathData += `M ${x} ${y} `;
        } else {
            pathData += `L ${x} ${y} `;
        }
    });
    
    return `
        <!-- 网格线 -->
        <defs>
            <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
                <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#e2e8f0" stroke-width="1"/>
            </pattern>
        </defs>
        <rect width="100%" height="100%" fill="url(#grid)"/>
        
        <!-- 价格路径 -->
        <path d="${pathData}" fill="none" stroke="${stock.change >= 0 ? '#10b981' : '#ef4444'}" 
              stroke-width="2" stroke-linejoin="round"/>
        
        <!-- 当前价格点 -->
        <circle cx="${width}" cy="${height - ((data[data.length-1] - minPrice) / range) * height}" 
                r="4" fill="${stock.change >= 0 ? '#10b981' : '#ef4444'}" stroke="white" stroke-width="2"/>
        
        <!-- 价格标签 -->
        <text x="10" y="20" font-family="Arial" font-size="12" fill="#6b7280">${maxPrice.toFixed(2)}</text>
        <text x="10" y="${height - 10}" font-family="Arial" font-size="12" fill="#6b7280">${minPrice.toFixed(2)}</text>
        <text x="${width - 60}" y="20" font-family="Arial" font-size="12" fill="#3b82f6">当前: ${stock.price.toFixed(3)}</text>
    `;
}

// 提交交易
function submitInvestmentTrade() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    
    if (game.userData.tradeCount <= 0) {
        showInvestmentNotification('交易次数不足！', 'error');
        return;
    }
    
    const quantityInput = document.getElementById('trade-quantity');
    const quantity = parseInt(quantityInput.value) || 0;
    
    if (quantity <= 0) {
        showInvestmentNotification('请输入有效的交易数量', 'error');
        return;
    }
    
    const amount = quantity * currentStock.price;
    const fee = amount * game.tradeData.feeRate;
    const totalCost = amount + fee;
    
    if (game.tradeData.type === 'buy') {
        if (totalCost > game.userData.availableFunds) {
            showInvestmentNotification('可用资金不足，无法完成买入', 'error');
            return;
        }
        
        // 执行买入
        game.userData.availableFunds -= totalCost;
        
        // 更新持仓
        const newTotalShares = currentStock.holdings + quantity;
        const newCostPrice = currentStock.holdings > 0 ? 
            (currentStock.holdings * currentStock.costPrice + amount) / newTotalShares : 
            currentStock.price;
        
        currentStock.holdings = newTotalShares;
        currentStock.costPrice = newCostPrice;
        game.userData.tradeCount--;
        
        showInvestmentNotification(`成功买入 ${quantity.toLocaleString()} 股${currentStock.name}，花费 ¥${totalCost.toFixed(2)}`, 'success');
    } else {
        if (quantity > currentStock.holdings) {
            showInvestmentNotification('持有数量不足，无法卖出', 'error');
            return;
        }
        
        // 执行卖出
        const sellAmount = amount - fee;
        game.userData.availableFunds += sellAmount;
        currentStock.holdings -= quantity;
        game.userData.tradeCount--;
        
        // 如果清仓，重置成本价
        if (currentStock.holdings === 0) {
            currentStock.costPrice = 0;
        }
        
        showInvestmentNotification(`成功卖出 ${quantity.toLocaleString()} 股${currentStock.name}，获得 ¥${sellAmount.toFixed(2)}`, 'success');
    }
    
    // 更新总资产
    updateInvestmentTotalAssets();
    
    // 更新界面
    document.getElementById('trade-count').textContent = game.userData.tradeCount;
    document.getElementById('available-funds').textContent = game.userData.availableFunds.toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
    
    // 重置交易数量
    quantityInput.value = 0;
    
    // 更新所有信息
    updateInvestmentTradeInfo();
    updateInvestmentHoldingsInfo();
    updateInvestmentAssetsDisplay();
    
    // 保存游戏
    saveGame();
}

// 更新总资产
function updateInvestmentTotalAssets() {
    const game = player.investmentGame;
    const totalHoldingsValue = game.stocks.reduce((sum, stock) => {
        return sum + (stock.holdings * stock.price);
    }, 0);
    
    game.userData.totalAssets = game.userData.availableFunds + totalHoldingsValue;
    game.userData.holdingPercent = (totalHoldingsValue / game.userData.totalAssets * 100);
    game.userData.todayProfit = ((game.userData.totalAssets - game.userData.initialFunds) / game.userData.initialFunds * 100);
}

// 更新资产显示
function updateInvestmentAssetsDisplay() {
    const game = player.investmentGame;
    
    document.getElementById('total-assets').textContent = game.userData.totalAssets.toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
    
    document.getElementById('total-hold-value').textContent = calculateTotalHoldingsValue().toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
    
    document.getElementById('total-holding-percent').textContent = game.userData.holdingPercent.toFixed(2) + '%';
    document.getElementById('today-profit').textContent = `${game.userData.todayProfit >= 0 ? '+' : ''}${game.userData.todayProfit.toFixed(2)}%`;
    
    // 更新持仓表格
    document.getElementById('holdings-body').innerHTML = generateHoldingsTable();
    
    // 显示/隐藏无持仓提示
    document.getElementById('no-holdings').style.display = hasHoldings() ? 'none' : 'block';
}

// 显示投资游戏通知
function showInvestmentNotification(message, type) {
    const notification = document.getElementById('investment-notification');
    notification.textContent = message;
    notification.className = `notification ${type}`;
    notification.style.display = 'block';
    
    setTimeout(() => {
        notification.style.display = 'none';
    }, 3000);
}

// 开始价格模拟
function startPriceSimulation() {
    const game = player.investmentGame;
    
    // 初始化随机参数（与离线模拟一致）
    if (!game.stocks[0]?.randomParams) {
        game.stocks.forEach((stock, index) => {
            if (!stock.randomParams) {
                stock.randomParams = {
                    baseVolatility: 0.005 + Math.random() * 0.025,
                    trendStrength: (Math.random() - 0.5) * 0.002,
                    eventProbability: 0.001,
                    meanReversion: 0.2 + Math.random() * 0.3,
                    noiseLevel: Math.random() * 0.8 + 0.2,
                    lastChange: 0,
                    priceHistory: []
                };
            }
            if (!stock.basePrice) {
                stock.basePrice = stock.price || 10;
            }
        });
    }
    
    // 清除之前的定时器
    if (game.priceUpdateTimer) {
        clearInterval(game.priceUpdateTimer);
    }
    if (game.chartUpdateTimer) {
        clearInterval(game.chartUpdateTimer);
    }
    
    let lastMarketEventTime = 0;
    let currentMarketMood = 0; // 市场情绪，-1到1
    
    // 每分钟更新一次价格
    game.priceUpdateTimer = setInterval(() => {
        const updateTime = Date.now();
        const minutesSinceStart = Math.floor((updateTime - (game.startTime || updateTime)) / 60000);
        
        // 每5分钟可能更新市场情绪
        if (minutesSinceStart % 5 === 0) {
            if (Math.random() < 0.3) { // 30%概率情绪变化
                currentMarketMood += (Math.random() - 0.5) * 0.4;
                currentMarketMood = Math.max(-1, Math.min(1, currentMarketMood));
            }
        }
        
        // 检查市场事件
        let marketEffect = 0;
        const timeSinceLastEvent = updateTime - lastMarketEventTime;
        
        if (timeSinceLastEvent > 5 * 60 * 1000) { // 至少5分钟没有事件
            const eventRoll = Math.random();
            if (eventRoll < 0.0005) { // 0.05% 概率重大事件
                marketEffect = (Math.random() - 0.5) * 0.08; // ±8%
                lastMarketEventTime = updateTime;
                logAction(`市场发生重大事件！影响: ${(marketEffect * 100).toFixed(2)}%`, 'market');
            } else if (eventRoll < 0.005) { // 0.5% 概率普通事件
                marketEffect = (Math.random() - 0.5) * 0.02; // ±2%
                lastMarketEventTime = updateTime;
            }
        }
        
        // 为所有股票更新价格
        game.stocks.forEach((stock, index) => {
            const params = stock.randomParams;
            const basePrice = stock.basePrice;
            
            // 1. 基础趋势
            const trendChange = params.trendStrength;
            
            // 2. 生成随机因子
            const timeBasedRand = Math.sin(updateTime * 0.0001 + index) * 0.5 + 0.5;
            const pureRand = Math.random();
            const normalRand = (Math.random() + Math.random() + Math.random() - 1.5) * 2; // 近似正态分布
            
            // 3. 波动率（随时间变化）
            let currentVolatility = params.baseVolatility;
            
            // 波动率随时间小幅变化
            currentVolatility *= (0.9 + Math.sin(updateTime * 0.00005) * 0.2);
            
            // 4. 随机事件
            if (Math.random() < params.eventProbability) {
                const eventMagnitude = 1 + Math.random() * 3; // 1-4倍波动
                currentVolatility *= eventMagnitude;
            }
            
            // 5. 均值回归
            const deviationFromMean = (stock.price - basePrice) / basePrice;
            const reversionForce = -deviationFromMean * params.meanReversion * 0.005;
            
            // 6. 动量效应
            const momentumEffect = params.lastChange * 0.2;
            
            // 7. 计算价格变化
            const modelIndex = minutesSinceStart % 6;
            let priceChange = 0;
            
            switch (modelIndex) {
                case 0: // 正态随机
                    priceChange = normalRand * currentVolatility;
                    break;
                case 1: // 带动量
                    priceChange = normalRand * currentVolatility + momentumEffect;
                    break;
                case 2: // 均值回归加强
                    priceChange = normalRand * currentVolatility * 0.7 + reversionForce;
                    break;
                case 3: // 高波动
                    priceChange = normalRand * currentVolatility * 1.5;
                    break;
                case 4: // 低波动
                    priceChange = normalRand * currentVolatility * 0.5;
                    break;
                default: // 混合模型
                    priceChange = (normalRand + timeBasedRand - 0.5) * currentVolatility;
            }
            
            // 添加趋势和市场情绪
            priceChange += trendChange;
            priceChange += currentMarketMood * 0.002; // 市场情绪影响
            
            // 添加市场事件影响
            if (marketEffect !== 0) {
                const stockSensitivity = 0.5 + Math.random() * 0.5; // 不同股票对事件敏感度不同
                priceChange += marketEffect * stockSensitivity;
            }
            
            // 板块效应
            if (index % 3 === minutesSinceStart % 3) {
                priceChange += (Math.random() - 0.5) * 0.003; // 同板块有微小相关性
            }
            
            // 记录历史变化
            params.lastChange = priceChange;
            params.priceHistory.push(stock.price);
            if (params.priceHistory.length > 100) {
                params.priceHistory.shift();
            }
            
            // 应用价格变化
            const oldPrice = stock.price;
            stock.price *= (1 + priceChange);
            
            // 确保价格合理性
            if (stock.price < 1) {
                stock.price = 1 + Math.random() * 2;
            } else if (stock.price > 100) {
                stock.price = 100 - Math.random() * 10;
            }
            
            // 防止价格停滞
            if (Math.abs(stock.price - oldPrice) < 0.001) {
                const microChange = (Math.random() - 0.5) * 0.01;
                stock.price *= (1 + microChange);
            }
            
            // 更新涨跌幅
            stock.change = ((stock.price - basePrice) / basePrice * 100);
            
            // 记录最高/最低价
            if (!stock.highestPrice || stock.price > stock.highestPrice) {
                stock.highestPrice = stock.price;
            }
            if (!stock.lowestPrice || stock.price < stock.lowestPrice) {
                stock.lowestPrice = stock.price;
            }
        });
        
        // 更新最后更新时间
        game.userData.lastUpdateTime = updateTime;
        
        // 如果游戏界面打开，更新显示
        if (document.getElementById('investmentGameUI')?.style.display === 'block') {
            updateInvestmentStockDisplay();
            updateInvestmentTradeInfo();
            updateInvestmentHoldingsInfo();
            updateInvestmentAssetsDisplay();
            
            // 更新时间显示
            const timeElement = document.getElementById('update-time');
            if (timeElement) {
                timeElement.textContent = `股价更新时间：${new Date().toLocaleTimeString()}`;
            }
            
            // 可选：显示市场情绪
            if (document.getElementById('market-mood')) {
                const moodText = currentMarketMood > 0.3 ? '📈 看涨' : 
                                currentMarketMood < -0.3 ? '📉 看跌' : '➡️ 震荡';
                document.getElementById('market-mood').textContent = `市场情绪: ${moodText}`;
            }
        }
        
        // 每5分钟记录一次日志
        if (minutesSinceStart % 5 === 0) {
            const avgChange = game.stocks.reduce((sum, s) => sum + s.change, 0) / game.stocks.length;
            console.log(`实时模拟: 平均涨跌幅 ${avgChange.toFixed(2)}%, 市场情绪: ${currentMarketMood.toFixed(2)}`);
        }
        
    }, 60000); // 每分钟更新一次
    
    // 图表更新频率更快（每10秒）
    game.chartUpdateTimer = setInterval(() => {
        if (document.getElementById('investmentGameUI')?.style.display === 'block') {
            updateInvestmentStockDisplay();
        }
    }, 10000);
    
    logAction('股票价格实时模拟已启动', 'system');
}
// 初始化投资游戏
function initInvestmentGame() {
    if (!player.investmentGame) {
        player.investmentGame = {
            stocks: [
                {code: "zj0001", name: "鱼鱼基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0002", name: "闫闫基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},           
                {code: "zj0003", name: "茶茶金股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0004", name: "麒麟企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0005", name: "云南白药", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0006", name: "黑三逢源", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0007", name: "乐途企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0008", name: "PDD企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0009", name: "空白控股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0010", name: "慢手企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0011", name: "斗音公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0012", name: "阿里妈妈", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0013", name: "淘宝宝", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0014", name: "千达有限", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0015", name: "通元房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0016", name: "预言鱼塘", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0017", name: "新股长虹", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0018", name: "萩萩萩萩音乐", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0019", name: "盛通快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0020", name: "十鼎洗浴", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0021", name: "九鼎红楼", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0022", name: "星巴克", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0023", name: "大吴疆土", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0024", name: "九转仙股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0025", name: "乌龟科技", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0026", name: "阿斯塔特", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0027", name: "万里药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0028", name: "万里证券", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0029", name: "顶峰相见", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0030", name: "顺封快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0031", name: "晋商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0032", name: "爆涨房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0033", name: "书法银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0034", name: "阳城银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0035", name: "程羽银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0036", name: "中铁银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0037", name: "工商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0038", name: "明港基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0039", name: "东坑企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0040", name: "黑龙银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0041", name: "韵达银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0042", name: "巴士企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0043", name: "京东公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0044", name: "科技企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0045", name: "羊同药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0046", name: "风雪药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0047", name: "霸王别姬", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0048", name: "一点点奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0049", name: "古茗奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0050", name: "蜜雪冰城", price: 10.00, change: 0, holdings: 0, costPrice: 0}
            ],
            userData: {
                availableFunds: 1000.00,
                totalAssets: 1000.00,
                holdingPercent: 0.00,
                todayProfit: 0.00,
                tradeCount: 16,
                initialFunds: 1000.00,
                lastUpdateTime: Date.now()
            },
            currentStockIndex: 0,
            tradeData: {
                quantity: 0,
                type: "buy",
                feeRate: 0.0048
            },
            chartHistoryCache: {},
            priceUpdateTimer: null,
            chartUpdateTimer: null
        };
    }
}

// 在游戏加载时初始化投资游戏数据
function initInvestmentGameOnLoad() {
    if (!player.investmentGame) {
        initInvestmentGame();
    }
}

// 在页面加载时调用
window.addEventListener('load', function() {
    // 确保在游戏加载后初始化投资游戏
    if (player) {
        initInvestmentGameOnLoad();
    }
});

// 在游戏保存时包含投资游戏数据
function saveInvestmentGameData() {
    // 投资游戏数据已经包含在player对象中
    // 保存时会自动保存
}

// 在游戏加载时恢复投资游戏数据
function loadInvestmentGameData() {
    if (player.investmentGame) {
        // 恢复定时器
        if (document.getElementById('investmentGameUI').style.display === 'block') {
            startPriceSimulation();
        }
    }
}
  // 房屋配置
        const houseTypes = [
            { id: 1, name: "茅草屋", rarity: 1, baseCost: 10000, income: 10, description: "简陋的茅草屋，提供基本住所" },
            { id: 2, name: "木屋", rarity: 2, baseCost: 50000, income: 50, description: "简单的木屋，比茅草屋舒适" },
            { id: 3, name: "石屋", rarity: 3, baseCost: 100000, income: 100, description: "坚固的石屋，能抵御风雨" },
            { id: 4, name: "砖房", rarity: 4, baseCost: 500000, income: 500, description: "砖砌房屋，更加耐用" },
            { id: 5, name: "别墅", rarity: 5, baseCost: 1000000, income: 1000, description: "豪华别墅，舒适宜居" },
            { id: 6, name: "庄园", rarity: 6, baseCost: 5000000, income: 5000, description: "广阔庄园，带有花园" },
            { id: 7, name: "城堡", rarity: 7, baseCost: 10000000, income: 10000, description: "宏伟城堡，彰显地位" },
            { id: 8, name: "宫殿", rarity: 8, baseCost: 50000000, income: 50000, description: "皇家宫殿，极尽奢华" },
            { id: 9, name: "天空之城", rarity: 9, baseCost: 100000000, income: 100000, description: "悬浮在空中的神奇城市" },
            { id: 10, name: "海底宫殿", rarity: 10, baseCost: 500000000, income: 500000, description: "深海中的神秘宫殿" },
            { id: 11, name: "星际堡垒", rarity: 11, baseCost: 1000000000, income: 1000000, description: "跨越星际的军事堡垒" },
            { id: 12, name: "时间之屋", rarity: 12, baseCost: 5000000000, income: 5000000, description: "能操控时间的奇异房屋" },
            { id: 13, name: "维度别墅", rarity: 13, baseCost: 10000000000, income: 10000000, description: "存在于多个维度的别墅" },
            { id: 14, name: "创世神殿", rarity: 14, baseCost: 50000000000, income: 50000000, description: "创世神居住的神圣殿堂" },
            { id: 15, name: "永恒居所", rarity: 15, baseCost: 100000000000, income: 100000000, description: "超越时间与空间的永恒住所" }
        ];

        // 初始化房屋系统数据
        function initHouseData() {
            if (!player.houses) {
                player.houses = {
                    level: 1,
                    exp: 0,
                    maxHouses: 5,
                    ownedHouses: [],
                    rentedHouses: [],
                    lastUpdate: Date.now(),
                    totalIncome: 0
                };
            }
        }

        // 切换房屋系统界面
        function toggleHouseSystem() {
            if (player.reincarnationCount < 200) {
                alert("需要达到200转才能开启房屋系统！");
                return;
            }
            
            const ui = document.getElementById('houseSystemUI');
            const overlay = document.getElementById('houseSystemOverlay');
            
            if (ui.style.display === 'block') {
                ui.style.display = 'none';
                overlay.style.display = 'none';
            } else {
                initHouseData();
                ui.style.display = 'block';
                overlay.style.display = 'block';
                updateHouseUI();
            }
        }

        function closeHouseSystem() {
            document.getElementById('houseSystemUI').style.display = 'none';
            document.getElementById('houseSystemOverlay').style.display = 'none';
        }

        // 更新房屋界面
        function updateHouseUI() {
            // 更新基本信息
            document.getElementById('houseLevel').textContent = player.houses.level;
            document.getElementById('houseCount').textContent = player.houses.rentedHouses.length;
            document.getElementById('maxHouses').textContent = player.houses.maxHouses;
            document.getElementById('houseExp').textContent = player.houses.exp.toFixed(1);
            document.getElementById('houseExpNext').textContent = getNextHouseLevelExp();
            document.getElementById('totalHouseIncome').textContent = player.houses.totalIncome.toExponential(1);
            document.getElementById('totalHouseIncoma').textContent = player.investmentGame.userData.availableFunds.toFixed(0);
            // 更新房屋商店
            updateHouseStore();
            
            // 更新房屋列表
            updateHouseList();
            
            // 更新房屋槽位显示
            updateHouseSlots();
            
            // 更新分解界面
            updateDecomposeHouseUI();
        }

        // 获取下一级所需经验
        function getNextHouseLevelExp() {
            const expRequirements = [100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000, 50000000, 100000000, 500000000, 1000000000, 5000000000, 10000000000, 50000000000, 100000000000, 1000000000000000000];
            const currentLevel = Math.min(player.houses.level, expRequirements.length);
            return expRequirements[currentLevel - 1] || expRequirements[expRequirements.length - 1];
        }

        // 更新房屋商店
        function updateHouseStore() {
            const container = document.getElementById('houseStore');
            container.innerHTML = '';
            
            houseTypes.forEach(houseType => {
                const houseCard = document.createElement('div');
                houseCard.className = `house-card house-${getHouseRarityClass(houseType.rarity)}`;
                
                houseCard.innerHTML = `
                    <div style="font-weight: bold;">${houseType.name}</div>
                    <div style="font-size: 0.8em; margin: 5px 0;">${houseType.description}</div>
                    <div style="font-size: 0.8em;">稀有度: ${houseType.rarity}</div>
                    <div style="font-size: 0.8em; color: #FFD700;">收益: ${houseType.income}/小时</div>
                    <div style="font-size: 0.8em; color: #32CD32;">价格: ${houseType.baseCost.toLocaleString()} 资金</div>
                    <button onclick="buyHouse(${houseType.id})" style="margin-top: 10px; background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; width: 100%;">购买</button>
                `;
                
                container.appendChild(houseCard);
            });
        }

        // 根据稀有度获取CSS类名
        function getHouseRarityClass(rarity) {
            if (rarity <= 3) return 'common';
            if (rarity <= 6) return 'rare';
            if (rarity <= 9) return 'epic';
            if (rarity <= 12) return 'legendary';
            return 'mythic';
        }

        // 购买房屋
        function buyHouse(houseId) {
            const houseType = houseTypes.find(h => h.id === houseId);
            
            if (!houseType) {
                logAction("无效的房屋类型", "error");
                return;
            }
            
            if (player.investmentGame.userData.availableFunds < houseType.baseCost) {
                logAction(`资金不足！需要 ${houseType.baseCost.toLocaleString()} 资金`, "error");
                return;
            }
            
            // 扣除转生币
            player.investmentGame.userData.availableFunds -= houseType.baseCost;
            
            // 创建房屋实例
            const newHouse = {
                id: 'house_' + Date.now(),
                type: houseType.id,
                name: houseType.name,
                rarity: houseType.rarity,
                baseIncome: houseType.income,
                rentTime: 0,
                isRented: false
            };
            
            // 添加到拥有的房屋列表
            player.houses.ownedHouses.push(newHouse);
            
            logAction(`成功购买了 ${houseType.name}！`, "success");
            updateHouseUI();
            updateDisplay();
            saveGame();
        }

        // 更新房屋列表
        function updateHouseList() {
            const container = document.getElementById('houseList');
            container.innerHTML = '';
            
            if (player.houses.ownedHouses.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">尚未购买任何房屋</div>';
                return;
            }
            
            player.houses.ownedHouses.forEach((house, index) => {
                const houseCard = document.createElement('div');
                houseCard.className = `house-card house-${getHouseRarityClass(house.rarity)}`;
                houseCard.style.cursor = 'pointer';
                houseCard.dataset.index = index;
                
                houseCard.innerHTML = `
                    <div style="font-weight: bold;">${house.name}</div>
                    <div style="font-size: 0.8em; margin: 5px 0;">稀有度: ${house.rarity}</div>
                    <div style="font-size: 0.8em; color: #FFD700;">收益: ${house.baseIncome}/小时</div>
                    <div style="font-size: 0.8em; color: ${house.isRented ? '#4CAF50' : '#f44336'};">${house.isRented ? '已出租' : '未出租'}</div>
                `;
                
                // 点击房屋进行出租操作
                houseCard.onclick = function() {
                    rentHouse(index);
                };
                
                container.appendChild(houseCard);
            });
        }

        // 出租房屋
        function rentHouse(houseIndex) {
            // 检查是否有空闲房屋槽位
            if (player.houses.rentedHouses.length >= player.houses.maxHouses) {
                logAction("没有空闲房屋槽位了！", "error");
                return;
            }
            
            const house = player.houses.ownedHouses[houseIndex];
            
            // 将房屋移动到出租列表
            player.houses.rentedHouses.push({
                ...house,
                rentTime: Date.now(),
                isRented: true
            });
            
            // 从拥有列表中移除
            player.houses.ownedHouses.splice(houseIndex, 1);
            
            logAction(`已将 ${house.name} 出租`, "success");
            updateHouseUI();
            saveGame();
        }

        // 更新房屋槽位显示
        function updateHouseSlots() {
            const container = document.getElementById('houseSlotsContainer');
            container.innerHTML = '';
            
            // 创建房屋槽位卡片
            for (let i = 0; i < player.houses.maxHouses; i++) {
                const slotCard = document.createElement('div');
                slotCard.className = 'house-slot';
                slotCard.style.border = '1px solid #ddd';
                slotCard.style.padding = '10px';
                slotCard.style.borderRadius = '5px';
                slotCard.style.textAlign = 'center';
                
                if (i < player.houses.rentedHouses.length) {
                    const house = player.houses.rentedHouses[i];
                    slotCard.innerHTML = `
                        <div style="font-weight: bold;">${house.name}</div>
                        <div>收益: ${calculateHouseIncome(house)} 资金</div>
                        <div>经验: ${calculateHouseIncome(house) / 1000} 经验值</div>
                        <button onclick="stopRentingHouse(${i})" style="margin-top: 10px; background: #ff9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">停止出租</button>
                    `;
                } else {
                    slotCard.innerHTML = '<div>空闲房屋槽位</div>';
                }
                
                container.appendChild(slotCard);
            }
        }

        // 计算房屋收益
        function calculateHouseIncome(house) {
            // 收益 = 房屋基础收益 * 出租时间(小时)
            const hoursRented = (Date.now() - house.rentTime) / (1000 * 60 * 60);
            return Math.floor(house.baseIncome * hoursRented);
        }

        // 停止出租房屋
        function stopRentingHouse(slotIndex) {
            if (slotIndex >= player.houses.rentedHouses.length) return;
            
            // 获取房屋信息
            const house = player.houses.rentedHouses[slotIndex];
            
            // 将房屋移回拥有列表
            player.houses.ownedHouses.push({
                ...house,
                isRented: false
            });
            
            // 从出租列表移除
            player.houses.rentedHouses.splice(slotIndex, 1);
            
            // 计算并收取收益
            const income = calculateHouseIncome(house);
            player.investmentGame.userData.availableFunds += income;
            player.houses.totalIncome += income;
            player.houses.exp += income / 1000;
            
            logAction(`停止出租: ${house.name}, 获得收益 ${income} 资金`, 'success');
            updateHouseUI();
            updateDisplay();
            saveGame();
        }

        // 一键出租
        function rentAllHouses() {
            // 计算可出租数量
            const availableSlots = player.houses.maxHouses - player.houses.rentedHouses.length;
            const housesToRent = Math.min(availableSlots, player.houses.ownedHouses.length);
            
            if (housesToRent === 0) {
                logAction("没有可出租的房屋或没有空闲槽位", "info");
                return;
            }
            
            // 出租操作
            for (let i = 0; i < housesToRent; i++) {
                const house = player.houses.ownedHouses[0];
                player.houses.rentedHouses.push({
                    ...house,
                    rentTime: Date.now(),
                    isRented: true
                });
                player.houses.ownedHouses.shift();
            }
            
            logAction(`已自动出租 ${housesToRent} 间房屋`, "success");
            updateHouseUI();
            saveGame();
        }

        // 收取所有房屋收益
        function collectAllHouseIncome() {
            let totalIncome = 0;
            
            player.houses.rentedHouses.forEach(house => {
                const income = calculateHouseIncome(house);
                totalIncome += income;
                
                // 添加房屋经验
                player.houses.exp += income / 1000;
                
                // 重置出租时间
                house.rentTime = Date.now();
            });
            
            // 添加收益
            player.investmentGame.userData.availableFunds += totalIncome;
            player.houses.totalIncome += totalIncome;
            
            logAction(`收取了所有房屋收益: ${totalIncome} 资金`, "success");
            updateHouseUI();
            updateDisplay();
            saveGame();
        }

        // 房屋分解功能
        function updateDecomposeHouseUI() {
            const container = document.getElementById('decomposeHouseContainer');
            container.innerHTML = '';
            
            if (player.houses.ownedHouses.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">没有可分解的房屋</div>';
                return;
            }
            
            // 添加拥有的房屋
            player.houses.ownedHouses.forEach((house, index) => {
                const houseDiv = document.createElement('div');
                houseDiv.className = `decompose-house-item house-${getHouseRarityClass(house.rarity)}`;
                houseDiv.style.display = 'flex';
                houseDiv.style.alignItems = 'center';
                houseDiv.style.justifyContent = 'space-between';
                houseDiv.style.marginBottom = '10px';
                houseDiv.style.padding = '10px';
                houseDiv.style.background = '#444';
                houseDiv.style.borderRadius = '5px';
                
                const decomposeValue = house.rarity * 5000;
                
                houseDiv.innerHTML = `
                    <div style="display: flex; align-items: center; flex: 1;">
                        <input type="checkbox" id="houseCheckbox${index}" 
                               style="margin-right: 10px; width: 16px; height: 16px;">
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px;">
                                ${house.name}
                            </div>
                            <div style="font-size: 12px; color: #ccc;">
                                稀有度: ${house.rarity}
                            </div>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 12px; color: #FFD700;">
                            价值: ${decomposeValue.toLocaleString()}
                        </div>
                        <div style="font-size: 10px; color: #888;">
                            资金
                        </div>
                    </div>
                `;
                
                container.appendChild(houseDiv);
            });
        }

        // 按稀有度批量选择房屋
        function selectHousesByRarity(maxRarity) {
            player.houses.ownedHouses.forEach((house, index) => {
                const checkbox = document.getElementById(`houseCheckbox${index}`);
                if (checkbox) {
                    checkbox.checked = house.rarity <= maxRarity;
                }
            });
            logAction(`已选择稀有度${maxRarity}及以下的房屋`, "info");
        }

        // 全选房屋
        function selectAllHouses() {
            player.houses.ownedHouses.forEach((house, index) => {
                const checkbox = document.getElementById(`houseCheckbox${index}`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            logAction("已选择所有房屋", "info");
        }

        // 取消全选
        function deselectAllHouses() {
            player.houses.ownedHouses.forEach((house, index) => {
                const checkbox = document.getElementById(`houseCheckbox${index}`);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            logAction("已取消选择所有房屋", "info");
        }

        // 分解选中房屋
        function decomposeSelectedHouse() {
            const housesToDecompose = [];
            
            // 收集选中的房屋
            player.houses.ownedHouses.forEach((house, index) => {
                const checkbox = document.getElementById(`houseCheckbox${index}`);
                if (checkbox && checkbox.checked) {
                    housesToDecompose.push({
                        index,
                        house
                    });
                }
            });
            
            if (housesToDecompose.length === 0) {
                logAction("请选择要分解的房屋", "error");
                return;
            }
            
            // 计算总收益和显示信息
            let totalValue = 0;
            let houseList = "";
            
            housesToDecompose.forEach(item => {
                totalValue += item.house.rarity * 5000;
                houseList += `\n${item.house.name} (稀有度${item.house.rarity})`;
            });
            
            // 显示确认对话框
            showCustomConfirm(`确定要分解以下 ${housesToDecompose.length} 间房屋吗？${houseList}\n\n总计可获得: ${totalValue.toLocaleString()} 资金`,
                (confirmed) => {
                    if (confirmed) {
                        // 从高索引到低索引删除，避免索引变化问题
                        housesToDecompose.sort((a, b) => b.index - a.index);
                        housesToDecompose.forEach(item => {
                            player.houses.ownedHouses.splice(item.index, 1);
                        });
                        
                        // 添加收益
                        player.investmentGame.userData.availableFunds += totalValue;
                        
                        logAction(`分解了 ${housesToDecompose.length} 间房屋，获得 ${totalValue.toLocaleString()} 资金`, "success");
                        updateHouseUI();
                        updateDisplay();
                        saveGame();
                    }
                }
            );
        }

        // 升级房屋系统
        function upgradeHouseSystem() {
            const requiredExp = getNextHouseLevelExp();
            
            if (player.houses.exp < requiredExp) {
                logAction(`经验不足！需要 ${requiredExp} 经验`, "error");
                return;
            }
            
            // 扣除经验
            player.houses.exp -= requiredExp;
            
            // 升级
            player.houses.level++;
            player.houses.maxHouses++;
            
            logAction(`房屋系统升级到 ${player.houses.level} 级！最大房屋槽位增加到 ${player.houses.maxHouses}`, "success");
            updateHouseUI();
            saveGame();
        }

        // 计算离线房屋收益
        function calculateOfflineHouseIncome() {
            if (!player.houses || !player.houses.rentedHouses) return;
            
            const now = Date.now();
            const elapsed = now - player.houses.lastUpdate;
            
            player.houses.rentedHouses.forEach(house => {
                const income = house.baseIncome * (elapsed / (1000 * 60 * 60)); // 每小时收益
                player.houses.totalIncome += income;
                player.houses.exp += income / 1000;
            });
            
            player.houses.lastUpdate = now;
        }

        // 在游戏加载时初始化房屋数据
        function initHouseSystemOnLoad() {
            if (!player.houses) {
                player.houses = {
                    level: 1,
                    exp: 0,
                    maxHouses: 5,
                    ownedHouses: [],
                    rentedHouses: [],
                    lastUpdate: Date.now(),
                    totalIncome: 0
                };
            } else {
                // 计算离线收益
                calculateOfflineHouseIncome();
            }
        }
 function addHouseSystemToGameLoop() {
            // 在现有的游戏循环中添加房屋收益计算
            setInterval(() => {
                if (player.houses && player.houses.rentedHouses.length > 0) {
                    // 每秒计算一次收益（实际收益按小时计算，这里只是累加）
                    const incomePerSecond = player.houses.rentedHouses.reduce((sum, house) => 
                        sum + house.baseIncome / 3600, 0
                    );
                    
                    player.reincarnationCoin += incomePerSecond;
                    player.houses.totalIncome += incomePerSecond;
                    player.houses.exp += incomePerSecond / 1000;
                    
                    // 每10秒更新一次UI（避免过于频繁的更新）
                    if (Math.floor(Date.now() / 1000) % 10 === 0) {
                        updateHouseUI();
                    }
                }
            }, 1000);
        }

 // 世界BOSS系统数据
        const worldBossData = {
            summonCount: 1,
            lastSummonTime: Date.now(),
            isBossActive: false,
            bossEndTime: 0,
            bossHealth: 0,
            bossMaxHealth: 0,
            bossName: "",
            bossWorld: "",
            bossStars: 0,
            playerDamage: 0,
            isAutoAttacking: false,
            attackInterval: null,
            virtualPlayers: [],
            rankings: [],
            battleLog: [],
            lastSummonTime: Date.now(),
    nextRecoveryTime: 0, // 新增：下次恢复时间
        };

        // BOSS名字池
        const bossNames = [
            "灭世魔尊·阎罗",
            "永恒天帝·太初",
            "混沌主宰·虚无",
            "九幽冥王·黄泉",
            "万界神皇·凌霄",
            "太古龙帝·烛阴",
            "星空吞噬者·饕餮",
            "时间掌控者·岁月",
            "命运编织者·天机",
            "元素始祖·创世"
        ];

        // 世界名字池
        const worldNames = [
            "玄天大陆",
            "九幽冥界",
            "太虚神境",
            "洪荒古界",
            "星辰海域",
            "万界战场",
            "永恒神域",
            "混沌虚空",
            "天元世界",
            "轮回之境"
        ];

        // 虚拟玩家名字池
        const virtualPlayerNames = [
            "萧炎", "林动", "牧尘", "叶凡", "石昊",
            "楚风", "秦羽", "方源", "韩立", "孟浩",
            "苏铭", "王林", "白小纯", "李七夜", "陈平安",
            "宁缺", "许七安", "陆鸣", "周元", "江离",
            "罗峰", "洪易", "纪宁", "滕青山", "唐三",
            "霍雨浩", "唐舞麟", "蓝轩宇", "古月娜", "唐昊", "茶茶", "闫闫", "萧云凡", "叶玄霄", "林昊辰", "楚星河", "秦无痕", "苏九夜", "陆天行", "沈青岚", "顾长歌", "洛千尘", "云清瑶", "柳如烟", "白芷晴", "慕雨柔", "苏灵儿", "凌寒霜", "楚月璃", "花未央", "冷轻衣", "夜琉璃", "夏知微", "苏晚晴", "林浅夏", "乔曦", "李二狗", "张全蛋", "赵日天", "王富贵"
        ];

        // 初始化世界BOSS系统
            function initWorldBossSystem() {
    // 计算离线时间增加的召唤次数
    const currentTime = Date.now();
    const timePassed = currentTime - (worldBossData.lastSummonTime || currentTime);
    const hoursPassed = Math.floor(timePassed / (60 * 60 * 1000));
    
    if (hoursPassed > 0) {
        worldBossData.summonCount = Math.min(worldBossData.summonCount + hoursPassed, 10);
        worldBossData.lastSummonTime = currentTime;
        saveWorldBossData();
    }
    
    // 计算下次恢复时间
    calculateNextRecoveryTime();
    
    // 启动倒计时更新
    updateSummonCountdown();
    
    updateBossUI();
}

// 计算下次恢复时间
function calculateNextRecoveryTime() {
    if (worldBossData.summonCount >= 10) {
        worldBossData.nextRecoveryTime = 0;
        return;
    }
    
    // 距离下次恢复的时间 = 1小时 - (当前时间与上次恢复的时间差 % 1小时)
    const oneHour = 60 * 60 * 1000;
    const timeSinceLastRecovery = Date.now() - worldBossData.lastSummonTime;
    const timeToNextRecovery = oneHour - (timeSinceLastRecovery % oneHour);
    
    worldBossData.nextRecoveryTime = Date.now() + timeToNextRecovery;
}

// 更新召唤次数倒计时显示
function updateSummonCountdown() {
    const countdownElement = document.getElementById('summonCountdown');
    if (!countdownElement) return;
    
    if (worldBossData.summonCount >= 10) {
        countdownElement.textContent = "已达上限";
        setTimeout(updateSummonCountdown, 1000);
        return;
    }
    
    const now = Date.now();
    const timeLeft = Math.max(0, worldBossData.nextRecoveryTime - now);
    
    if (timeLeft === 0 && worldBossData.summonCount < 10) {
        // 强制更新上次召唤时间为当前时间
        worldBossData.lastSummonTime = now;
        worldBossData.summonCount++;
        calculateNextRecoveryTime(); // 重新计算下次恢复时间（1小时后）
        saveWorldBossData();
        document.getElementById('bossSummonCount').textContent = worldBossData.summonCount;
        console.log("恢复次数+1，下次恢复时间：", new Date(worldBossData.nextRecoveryTime).toLocaleTimeString());
    }
    
    // 格式化时间显示
    const hours = Math.floor(timeLeft / (60 * 60 * 1000));
    const minutes = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
    const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);
    countdownElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    setTimeout(updateSummonCountdown, 1000);
}


        // 保存世界BOSS数据
        function saveWorldBossData() {
    worldBossData.lastUpdate = Date.now();
    localStorage.setItem('worldBossSave', JSON.stringify(worldBossData));
}

        // 加载世界BOSS数据
        // 加载世界BOSS数据
function loadWorldBossData() {
    const save = JSON.parse(localStorage.getItem('worldBossSave'));
    if (save) {
        Object.assign(worldBossData, save);
        
        // 如果BOSS活动正在进行中，计算离线期间的伤害
        if (worldBossData.isBossActive) {
            const currentTime = Date.now();
            
            // 检查BOSS是否已超时
            if (currentTime > worldBossData.bossEndTime) {
                endBossFight(false);
            } else {
                // 计算离线时间（秒）
                const offlineSeconds = Math.floor((currentTime - worldBossData.lastUpdate) / 1000);
                
                if (offlineSeconds > 0) {
                    // 1. 计算虚拟玩家在离线期间造成的总伤害（已有逻辑）
                    const virtualDamagePerSecond = worldBossData.virtualPlayers.reduce((sum, player) => {
                        const avgDamage = player.attack * player.multiAttack * 
                                        (1 + (player.critRate * (player.critDamage - 1)));
                        return sum + avgDamage;
                    }, 0);
                    const totalVirtualDamage = Math.floor(virtualDamagePerSecond * offlineSeconds);
                    worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - totalVirtualDamage);
                    const damagePerPlayer = Math.floor(totalVirtualDamage / worldBossData.virtualPlayers.length);
                    worldBossData.virtualPlayers.forEach(player => {
                        player.damage += damagePerPlayer;
                    });
                    addBossBattleLog(`离线期间虚拟玩家共造成 ${formatNumber(totalVirtualDamage)} 点伤害`);
                    
                    // 2. 新增：计算真实玩家的离线自动攻击伤害
                    if (worldBossData.isAutoAttacking) { // 仅当开启自动攻击时计算
                        // 玩家每秒攻击11次（与startAutoAttack一致）
                        const attacksPerSecond = 11;
                        const totalAttacks = offlineSeconds * attacksPerSecond;
                        
                        // 计算单次攻击的平均伤害（参考calculatePlayerDamage逻辑）
                        const playerData = {
                            attack: player.bossBattleSnapshot?.playerAttack || player.battle.playerAttack,
    multiAttack: player.bossBattleSnapshot?.playerMultiAttack || player.battle.playerMultiAttack,
    critRate: player.bossBattleSnapshot?.playerCritRate || player.battle.playerCritRate,
    critDamage: player.bossBattleSnapshot?.playerCritDamage || player.battle.playerCritDamage
                        };
                        // 计算单次攻击的平均伤害（避免循环计算totalAttacks次，优化性能）
                        const singleAttackAvgDamage = playerData.attack * playerData.multiAttack * 
                                                    (1 + (playerData.critRate * (playerData.critDamage - 1)));
                        const totalPlayerDamage = Math.floor(singleAttackAvgDamage * totalAttacks);
                        
                        // 应用玩家离线伤害
                        worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - totalPlayerDamage);
                        worldBossData.playerDamage += totalPlayerDamage;
                        addBossBattleLog(`离线期间你通过自动攻击造成 ${formatNumber(totalPlayerDamage)} 点伤害`);
                    }
                    
                    // 检查BOSS是否被击败
                    if (worldBossData.bossHealth <= 0) {
                        endBossFight(true);
                        return;
                    }
                }
            }
        }
    }
    
    // 重新开始虚拟玩家攻击
    startVirtualPlayerAttacks();
    
    // 更新最后更新时间
    worldBossData.lastUpdate = Date.now();
    initWorldBossSystem();
}

        // 切换世界BOSS界面
        function toggleWorldBossUI() {
           // 检查转生次数是否达到50次
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启世界BOSS系统！");
        return;
    }
            const ui = document.getElementById('worldBossUI');
            const overlay = document.getElementById('bossOverlay');
            
            if (ui.style.display === 'block') {
                ui.style.display = 'none';
                overlay.style.display = 'none';
                
               
            } else {
                ui.style.display = 'block';
                overlay.style.display = 'block';
                updateBossUI();
            }
        }

        // 更新BOSS界面
        function updateBossUI() {
            document.getElementById('bossSummonCount').textContent = worldBossData.summonCount;
    if (worldBossData.isBossActive && player.bossBattleSnapshot) {
        document.getElementById('playerBossAttack').textContent = formatNumber(player.bossBattleSnapshot.playerAttack);
        document.getElementById('playerBossMultiAttack').textContent = player.bossBattleSnapshot.playerMultiAttack;
        document.getElementById('playerBossCritRate').textContent = (player.bossBattleSnapshot.playerCritRate * 100).toFixed(1) + '%';
        document.getElementById('playerBossCritDamage').textContent = ((player.bossBattleSnapshot.playerCritDamage - 1) * 100).toFixed(1) + '%';
    } else {
        // 显示实时属性
        document.getElementById('playerBossAttack').textContent = formatNumber(player.battle.playerAttack);
        document.getElementById('playerBossMultiAttack').textContent = player.battle.playerMultiAttack;
        document.getElementById('playerBossCritRate').textContent = (player.battle.playerCritRate * 100).toFixed(1) + '%';
        document.getElementById('playerBossCritDamage').textContent = ((player.battle.playerCritDamage - 1) * 100).toFixed(1) + '%';
    }
            document.getElementById('playerBossDamage').textContent = formatNumber(worldBossData.playerDamage);
       if (!worldBossData.isBossActive) {
        document.getElementById('playerBossRank').textContent = "未开始";
    } else {
        // 触发一次排行更新
        updateRankings();
    }
            // 新增：检查BOSS是否超时（无论是否在战斗中，强制判断时间）
    if (worldBossData.isBossActive && Date.now() >= worldBossData.bossEndTime) {
        endBossFight(false); // 强制结束战斗
        return; // 结束后无需继续更新UI
    }
          if (!worldBossData.isBossActive) {
        document.getElementById('playerBossRank').textContent = "未开始";
    } else {
        // 触发一次排行更新
        updateRankings();
    }
            // 更新BOSS状态
            if (worldBossData.isBossActive) {
                document.getElementById('bossName').textContent = worldBossData.bossName;
                document.getElementById('bossWorld').textContent = worldBossData.bossWorld;
                document.getElementById('bossStars').textContent = '★'.repeat(worldBossData.bossStars);
                
                const healthPercent = (worldBossData.bossHealth / worldBossData.bossMaxHealth) * 100;
                document.getElementById('bossHealthFill').style.width = healthPercent + '%';
                document.getElementById('bossHealthText').textContent = 
                    formatNumber(worldBossData.bossHealth) + '/' + formatNumber(worldBossData.bossMaxHealth);
                
                const timeLeft = Math.max(0, Math.floor((worldBossData.bossEndTime - Date.now()) / 1000));
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                document.getElementById('bossTimeLeft').textContent = 
                    `剩余: ${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
                
                document.getElementById('bossSummonButton').disabled = true;
                document.getElementById('bossAttackButton').disabled = false;
                
                // 更新排行榜
                updateRankings();
            } else {
                document.getElementById('bossName').textContent = '未召唤BOSS';
                document.getElementById('bossWorld').textContent = '';
                document.getElementById('bossStars').textContent = '';
                document.getElementById('bossHealthFill').style.width = '0%';
                document.getElementById('bossHealthText').textContent = '0/0';
                document.getElementById('bossTimeLeft').textContent = '剩余: 未开始';
                
                document.getElementById('bossSummonButton').disabled = worldBossData.summonCount <= 0;
                document.getElementById('bossAttackButton').disabled = true;
                
                if (worldBossData.summonCount <= 0) {
                    document.getElementById('bossSummonButton').textContent = '无次数';
                } else {
                    document.getElementById('bossSummonButton').textContent = '召唤';
                }
            }
            
            // 更新自动攻击按钮
            document.getElementById('bossAutoAttackButton').textContent = 
                `自动: ${worldBossData.isAutoAttacking ? '开' : '关'}`;
        }

        // 召唤BOSS
        function summonBoss() {
           // 检查转生次数是否达到50次
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能召唤世界BOSS！");
        return;
    }
            if (worldBossData.summonCount <= 0) return;
            
            worldBossData.summonCount--;
            worldBossData.isBossActive = true;
            worldBossData.bossEndTime = Date.now() + 60 * 60 * 1000; // 60分钟
            worldBossData.playerDamage = 0;
            worldBossData.battleLog = [];
            
            // 随机生成BOSS属性
            worldBossData.bossName = bossNames[Math.floor(Math.random() * bossNames.length)];
            worldBossData.bossWorld = worldNames[Math.floor(Math.random() * worldNames.length)];
            worldBossData.bossStars = Math.floor(Math.random() * 30) + 1; // 1-30星
            
            // BOSS生命值为玩家攻击力的100000万-1000000万倍
            const healthMultiplier = 10000000000000000000 + Math.random() * 99000000000000000000000000;
            worldBossData.bossMaxHealth = Math.floor(player.battle.playerAttack * healthMultiplier * player.battle.playerCritDamage);
            worldBossData.bossHealth = worldBossData.bossMaxHealth;
           // 保存玩家属性快照
    player.bossBattleSnapshot = {
        playerAttack: player.battle.playerAttack,
        playerMultiAttack: player.battle.playerMultiAttack,
        playerCritRate: player.battle.playerCritRate,
        playerCritDamage: player.battle.playerCritDamage
    };                   
            // 生成虚拟玩家
            generateVirtualPlayers();
            
            // 开始虚拟玩家攻击
            startVirtualPlayerAttacks();
            
            // 更新UI
            updateBossUI();
            
            // 保存数据
            saveWorldBossData();
            
            // 添加战斗日志
            addBossBattleLog(`召唤了 ${worldBossData.bossName} [${worldBossData.bossWorld}] (${worldBossData.bossStars}★)`);
            
            // 设置BOSS结束检查
            setTimeout(checkBossEnd, 1000);
        }

        // 生成虚拟玩家
        function generateVirtualPlayers() {
            worldBossData.virtualPlayers = [];
            
            for (let i = 0; i < 60; i++) {
                const name = virtualPlayerNames[i] || `玩家${i+1}`;
                const attackMultiplier = 0.2 + Math.random() * 30; 
                const attack = Math.floor(player.battle.playerAttack * attackMultiplier);
                const multiAttack = Math.max(1, 
                    Math.floor(player.battle.playerMultiAttack * (0.3 + Math.random() * 1.5))); 
                const critRate = 0.5 + Math.random() * 1.9; 
                const critDamage = player.battle.playerCritDamage * (0.3 + Math.random() * 1.5);
                
                worldBossData.virtualPlayers.push({
                    name: name,
                    attack: attack,
                    multiAttack: multiAttack,
                    critRate: critRate,
                    critDamage: critDamage,
                    damage: 0
                });
            } 
      }
      // 修改离线虚拟玩家伤害计算逻辑（替换原有的平均分配部分）
function calculateOfflineVirtualDamage() {
    const now = Date.now();
    const timePassed = now - worldBossData.lastVirtualAttackTime;
    const secondsPassed = Math.floor(timePassed / 1000);
    if (secondsPassed <= 0) return;

    // 为每个虚拟玩家单独计算离线伤害（基于其自身属性）
    worldBossData.virtualPlayers.forEach(player => {
        // 计算该玩家的每秒平均伤害（考虑连击和爆伤）
        const avgDps = player.attack * player.multiAttack * 
                      (3 + (player.critRate * (player.critDamage - 1)));
        // 计算离线总伤害
        const playerDamage = Math.floor(avgDps * secondsPassed);
        // 应用伤害
        worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - playerDamage);
        player.damage += playerDamage;
    });

    // 更新最后攻击时间
    worldBossData.lastVirtualAttackTime = now;

    // 记录总离线伤害
    const totalDamage = worldBossData.virtualPlayers.reduce((sum, p) => sum + p.damageAdded, 0);
    addBossBattleLog(`离线期间虚拟玩家共造成 ${formatNumber(totalDamage)} 点伤害`);

    // 检查BOSS是否被击败
    if (worldBossData.bossHealth <= 0) {
        endBossFight(true);
    }
            
            // 更新排行榜
            updateRankings();
            
            // 保存数据
            saveWorldBossData();
        }
// 开始虚拟玩家攻击
        function startVirtualPlayerAttacks() {
            // 清除之前的攻击间隔
            if (worldBossData.virtualAttackInterval) {
                clearInterval(worldBossData.virtualAttackInterval);
            }
            
            // 设置新的攻击间隔 (每秒攻击一次)
            worldBossData.virtualAttackInterval = setInterval(() => {
                if (!worldBossData.isBossActive) {
                    clearInterval(worldBossData.virtualAttackInterval);
                    return;
                }
                
                // 所有虚拟玩家攻击
                worldBossData.virtualPlayers.forEach(player => {
                    const result = calculatePlayerDamage(player);
                    worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - result.total);
                    player.damage += result.total;
                    
                    // 每10次攻击记录一次（显示爆伤）
                    if (Math.random() < 0.1) {
                        let logMessage = `${player.name} 造成 ${formatNumber(result.total)} 伤害 - `;
                        logMessage += `普通: ${formatNumber(result.normalDamage)}, `;
                        logMessage += `暴击x${result.critCount}: ${formatNumber(result.critDamage)}`;
                        addBossBattleLog(logMessage);
                    }
                });
                
                // 更新UI
                updateRankings();
                updateBossUI();
                
                // 检查BOSS是否被击败
                if (worldBossData.bossHealth <= 0) {
                    endBossFight(true);
                }
            }, 1000);
        }

        // 计算玩家伤害
        function calculatePlayerDamage(playerData) {
            let totalDamage = 0;
            let critCount = 0;
            let critDamageTotal = 0;
            let normalDamageTotal = 0;
            
            for (let i = 0; i < playerData.multiAttack; i++) {
                const isCrit = Math.random() < playerData.critRate;
                let damage = playerData.attack;
                
                if (isCrit) {
                    damage *= playerData.critDamage;
                    critCount++;
                    critDamageTotal += damage;
                } else {
                    normalDamageTotal += damage;
                }
                
                totalDamage += damage;
            }
            
            return {
                total: Math.floor(totalDamage),
                critCount: critCount,
                critDamage: Math.floor(critDamageTotal),
                normalDamage: Math.floor(normalDamageTotal)
            };
        }

        // 攻击BOSS（修改为显示爆伤信息）
        function attackBoss() {
            if (!worldBossData.isBossActive) return;
            
    // 使用保存的属性快照而不是实时属性
    const result = calculatePlayerDamage({
        attack: player.bossBattleSnapshot.playerAttack,
        multiAttack: player.bossBattleSnapshot.playerMultiAttack,
        critRate: player.bossBattleSnapshot.playerCritRate,
        critDamage: player.bossBattleSnapshot.playerCritDamage
    });
    
            
            worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - result.total);
            worldBossData.playerDamage += result.total;
            
            // 添加战斗日志（显示爆伤详情）
            let logMessage = `你造成了 ${formatNumber(result.total)} 点伤害 (${player.battle.playerMultiAttack}连击) - `;
            logMessage += `普通伤害: ${formatNumber(result.normalDamage)}, `;
            logMessage += `暴击x${result.critCount}: ${formatNumber(result.critDamage)}`;
            
            addBossBattleLog(logMessage);
            
            // 更新UI
            updateRankings();
            updateBossUI();

           // 新增：保存攻击后的BOSS数据
    saveWorldBossData();
            
            // 检查BOSS是否被击败
            if (worldBossData.bossHealth <= 0) {
                endBossFight(true);
            }
        }

        // 切换自动攻击
        function toggleAutoAttackBoss() {
            worldBossData.isAutoAttacking = !worldBossData.isAutoAttacking;
            
            if (worldBossData.isAutoAttacking) {
                // 启动自动攻击（即使界面关闭也会继续）
                startAutoAttack();
            } else {
                stopAutoAttack();
            }
            
            updateBossUI();
        }

        // 新增专用函数处理自动攻击
function startAutoAttack() {
    // 先停止现有的自动攻击
    stopAutoAttack();
    
    // 每秒攻击20次
    worldBossData.attackInterval = setInterval(() => {
        if (worldBossData.isBossActive && worldBossData.isAutoAttacking) {
            for (let i = 0; i < 20; i++) {
                // 使用属性快照攻击
                const result = calculatePlayerDamage({
                    attack: player.bossBattleSnapshot.playerAttack,
                    multiAttack: player.bossBattleSnapshot.playerMultiAttack,
                    critRate: player.bossBattleSnapshot.playerCritRate,
                    critDamage: player.bossBattleSnapshot.playerCritDamage
                });
                
                worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - result.total);
                worldBossData.playerDamage += result.total;
                
                // 检查BOSS是否被击败
                if (worldBossData.bossHealth <= 0) {
                    endBossFight(true);
                    break;
                }
            }
        }
    }, 1000);
}

        function stopAutoAttack() {
            clearInterval(worldBossData.attackInterval);
        }

        // 更新排行榜
function updateRankings() {
    // 合并真实玩家和虚拟玩家
    const allPlayers = [
        {
            name: "你",
            damage: worldBossData.playerDamage
        },
        ...worldBossData.virtualPlayers.map(p => ({
            name: p.name,
            damage: p.damage
        }))
    ];
    
    // 按伤害排序
    allPlayers.sort((a, b) => b.damage - a.damage);
    worldBossData.rankings = allPlayers;
    
    // 更新玩家排名
    const playerRank = allPlayers.findIndex(p => p.name === "你") + 1;
    document.getElementById('playerBossRank').textContent = playerRank ? 
        `${playerRank} / ${allPlayers.length}` : "未排名";
    
    // 更新UI
    const rankingsContainer = document.getElementById('bossRankings');
    rankingsContainer.innerHTML = '';
    
    allPlayers.slice(0, 10).forEach((player, index) => {
        const div = document.createElement('div');
        div.className = 'boss-ranking-item';
        div.innerHTML = `
            <span>${index + 1}. ${player.name}</span>
            <span>${formatNumber(player.damage)}</span>
        `;
        rankingsContainer.appendChild(div);
    });
    
    if (allPlayers.length === 0) {
        rankingsContainer.innerHTML = '<div>尚未开始战斗</div>';
    }
}

        // 添加战斗日志
        function addBossBattleLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            worldBossData.battleLog.unshift(logEntry);
            if (worldBossData.battleLog.length > 15) { // 减少日志数量
                worldBossData.battleLog.pop();
            }
            
            // 更新UI
            const logContainer = document.getElementById('bossBattleLog');
            logContainer.innerHTML = worldBossData.battleLog.map(log => 
                `<div class="boss-battle-log-entry">${log}</div>`
            ).join('');
        }

        // 检查BOSS是否结束
        function checkBossEnd() {
            if (!worldBossData.isBossActive) return;
            
            if (Date.now() >= worldBossData.bossEndTime) {
                endBossFight(false);
            } else {
                setTimeout(checkBossEnd, 1000);
                updateBossUI();
            }
        }

        // 结束BOSS战斗
        function endBossFight(isDefeated) {
            worldBossData.isBossActive = false;
            clearInterval(worldBossData.virtualAttackInterval);
            
            // 停止自动攻击
            if (worldBossData.isAutoAttacking) {
                worldBossData.isAutoAttacking = false;
                stopAutoAttack();
            }
             player.bossBattleSnapshot = null;
            // 发放奖励
            distributeRewards();
            
            // 添加战斗日志
            if (isDefeated) {
                addBossBattleLog(`BOSS ${worldBossData.bossName} 已被击败！`);
            } else {
                addBossBattleLog(`BOSS ${worldBossData.bossName} 时间结束！`);
            }
            
            // 保存数据
            saveWorldBossData();
            
            // 更新UI
            updateBossUI();
            
            // 记录开奖结果
            recordBossResult();
        }

        // 分发奖励
        function distributeRewards() {
            const playerRank = worldBossData.rankings.findIndex(p => p.name === "你") + 1;
            
            if (playerRank === 1) {
        // 第一名
        player.items.divineGem += 5;
        player.reincarnationCoin += 30000;
        addBossBattleLog("你获得了第1名奖励: 5个神级宝石 + 30000转生币");
        
        // 解锁成就
        if (!player.achievements.world_boss_1st) {
            player.achievements.world_boss_1st = true;
            player.gpsMultiplier += achievementRewards.world_boss_1st.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_1st.description}，GPS奖励 +${achievementRewards.world_boss_1st.gpsMultiplier * 100}%`, 'success');
        }
    } else if (playerRank >= 2 && playerRank <= 10) {
        // 第2-10名
        player.items.superiorGem += 5;
        player.reincarnationCoin += 10000;
        addBossBattleLog(`你获得了第${playerRank}名奖励: 5个极品宝石 + 10000转生币`);
        
        // 解锁成就
        if (!player.achievements.world_boss_top5) {
            player.achievements.world_boss_top5 = true;
            player.gpsMultiplier += achievementRewards.world_boss_top5.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_top5.description}，GPS奖励 +${achievementRewards.world_boss_top5.gpsMultiplier * 100}%`, 'success');
        }
    } else if (playerRank >= 11 && playerRank <= 30) {
        // 第11-30名
        player.items.advancedGem += 3;
        player.reincarnationCoin += 5000;
        addBossBattleLog(`你获得了第${playerRank}名奖励: 3个高级宝石 + 5000转生币`);
        
        // 解锁成就
        if (!player.achievements.world_boss_top10) {
            player.achievements.world_boss_top10 = true;
            player.gpsMultiplier += achievementRewards.world_boss_top10.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_top10.description}，GPS奖励 +${achievementRewards.world_boss_top10.gpsMultiplier * 100}%`, 'success');
        }
    } else {
        // 参与奖
        player.items.primaryGem += 1;
        player.reincarnationCoin += 100;
        addBossBattleLog("你获得了参与奖: 1个初级宝石 + 100转生币");
        
        // 解锁成就
        if (!player.achievements.world_boss_participant) {
            player.achievements.world_boss_participant = true;
            player.gpsMultiplier += achievementRewards.world_boss_participant.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_participant.description}，GPS奖励 +${achievementRewards.world_boss_participant.gpsMultiplier * 100}%`, 'success');
        }
    }
    
    // 更新显示
    updateDisplay();
    updateAchievementsDisplay();
}

        // 记录开奖结果
        function recordBossResult() {
            const top3 = worldBossData.rankings.slice(0, 3).map(p => p.name).join(", ");
            const result = `世界BOSS ${worldBossData.bossName} 结束，前三名: ${top3}`;
            
            player.lotteryResults.unshift({
                time: new Date().toLocaleString(),
                result: result
            });
            
            if (player.lotteryResults.length > 5) {
                player.lotteryResults.pop();
            }
            
            // 更新彩票结果显示
            updateLotteryResultsDisplay();
        }

       // 格式化数字显示
        function formatNumber(value) {
            if (value >= 1e8) {
                return value.toExponential(3);
            } else {
                return value.toLocaleString();
            }
        }

        // 在游戏加载时初始化世界BOSS系统
        loadWorldBossData();
        updateOfficialSystemDisplay();
        updatePlayerClassNameDisplay();
     updateCompanionDisplay();
       updateItemDisplay();
 updateMysterySystemDisplay();
updateItemDisplay();
updateTraditionalLotteryDisplay();
updateTotalBonuses();
</script>
<!--客服 开始-->
<script src="//g8hh.github.io/static/js/jquery.min.js"></script>
<link rel="stylesheet" href="//g8hh.github.io/static/css/kf.css" type="text/css" media="screen" charset="utf-8">
<script src="//g8hh.github.io/static/js/kf.js"></script>
<!-- 客服 结束 -->
<!--站长统计-->
    <div style="display: none">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?828597e93cee632465679b7ef35edfd5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>    </div>

</body>
</html>