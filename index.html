<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>金币冒险者 - 完整版</title>
    <style>
        /* 样式保持不变 */
        body { font-family: Arial, sans-serif; padding: 20pxf; background-color: #ffffff; }
        button { padding: 10px; margin: 5px; cursor: pointer; }
        #equipmentList, #itemList, #collectionList, #reincarnationList, #petList, #stockList, #lotteryList, #bankList, #dungeonEquipmentList, #soulRingList { margin-top: 20px; max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; }
        .log { color: #666; font-size: 0.9em; }
        .common { color: #666; border-left: 4px solid #666; padding: 2px 5px; }
        .rare { color: blue; border-left: 4px solid blue; }
        .epic { color: purple; border-left: 4px solid purple; }
        .legendary { color: orange; border-left: 4px solid orange; }
        .ancient { color: brown; border-left: 4px solid brown; }
        .divine { color: gold; border-left: 4px solid gold; }
        .arcane { color: deepskyblue; border-left: 4px solid deepskyblue; }
        .celestial { color: lightblue; border-left: 4px solid lightblue; }
        .infernal { color: darkred; border-left: 4px solid darkred; }
        .astral { color: violet; border-left: 4px solid violet; }
        .primeval { color: darkgreen; border-left: 4px solid darkgreen; }
        .transcendental { color: fuchsia; border-left: 4px solid fuchsia; }
        .quantum { color: aqua; border-left: 4px solid aqua; }
        .ultimate { color: orange; border-left: 4px solid orange; }
        .chaos { color: #FF4500; border-left: 4px solid #FF4500; }
       .eternal { color: #00CED1; border-left: 4px solid #00CED1; }
         .void { color: #8A2BE2; border-left: 4px solid #8A2BE2; }
        .genesis { color: #FFD700; border-left: 4px solid #FFD700; }
         .divineRealm { color: #FF69B4; border-left: 4px solid #FF69B4; }
         .apocalypse { color: #000000; border-left: 4px solid #000000; }
       .yeyu1 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu2 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu3 { color: #FF4530; border-left: 4px solid #FF4530; }
        .yeyu4 { color: #4B0082; border-left: 4px solid #4B0082; }
         .yeyu5 { color: #FFD770; border-left: 4px solid #FFD770; }
         .yeyu6 { color: #8B0000; border-left: 4px solid #8B0000; }
       .yeyu7 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu8 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu9 { color: #FF4530; border-left: 4px solid #FF4530; }
        .yeyu10 { color: #4B0082; border-left: 4px solid #4B0082; }
         .yeyu11 { color: #FFD770; border-left: 4px solid #FFD770; }
         .yeyu12 { color: #8B0000; border-left: 4px solid #8B0000; }
       .yeyu13 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu14 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu15 { color: #FF4530; border-left: 4px solid #FF4530; }
      .yeyu16 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu17 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu18 { color: #FF4530; border-left: 4px solid #FF4530; }
        .yeyu19 { color: #4B0082; border-left: 4px solid #4B0082; }
         .yeyu20 { color: #FFD770; border-left: 4px solid #FFD770; }
         .yeyu21 { color: #8B0000; border-left: 4px solid #8B0000; }
       .yeyu22 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu23 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu24 { color: #FF4530; border-left: 4px solid #FF4530; }
   .ultimate2 { color: #00CED1; border-left: 4px solid #00CED1; }
.ultimate3 { color: #8A2BE2; border-left: 4px solid #8A2BE2; } 
.ultimate4 { color: #FFD700; border-left: 4px solid #FFD700; } 
.ultimate5 { color: #FF69B4; border-left: 4px solid #FF69B4; }
.ultimate6 { color: #000000; border-left: 4px solid #000000; }
.ultimate7 { color: #00FF00; border-left: 4px solid #00FF00; } 
.ultimate8 { color: #FF0000; border-left: 4px solid #FF0000; } 
.ultimate9 { color: #0000FF; border-left: 4px solid #0000FF; }
.ultimate10 { color: #800080; border-left: 4px solid #800080; } 
.ultimate11 { color: #FFA500; border-left: 4px solid #FFA500; } 
.ultimate12 { color: #008080; border-left: 4px solid #008080; } 
.ultimate13 { color: #4B0082; border-left: 4px solid #4B0082; } 
.ultimate14 { color: #FF6347; border-left: 4px solid #FF6347; } 
.ultimate15 { color: #7CFC00; border-left: 4px solid #7CFC00; } 
.ultimate16 { color: #DC143C; border-left: 4px solid #DC143C; } 
.ultimate17 { color: #00FFFF; border-left: 4px solid #00FFFF; } 
.ultimate18 { color: #FF00FF; border-left: 4px solid #FF00FF; } 
.ultimate19 { color: #FFFF00; border-left: 4px solid #FFFF00; }
.ultimate20 { color: #8B0000; border-left: 4px solid #8B0000; } 
.ultimate21 { color: #800000; border-left: 4px solid #800000; } 
.ultimate22 { color: #FFDAB9; border-left: 4px solid #FFDAB9; }
.ultimate23 { color: #000080; border-left: 4px solid #000080; } 
.ultimate24 { color: #FF1493; border-left: 4px solid #FF1493; } 
.ultimate25 { color: #00BFFF; border-left: 4px solid #00BFFF; }
.ultimate26 { color: #FF4500; border-left: 4px solid #FF4500; } 
.ultimate27 { color: #00CED1; border-left: 4px solid #00CED1; }
.ultimate28 { color: #8A2BE2; border-left: 4px solid #8A2BE2; } 
.ultimate29 { color: #FFD700; border-left: 4px solid #FFD700; }
.ultimate30 { color: #FF69B4; border-left: 4px solid #FF69B4; }
.ultimate31 { color: #000000; border-left: 4px solid #000000; }
.ultimate32 { color: #00FF00; border-left: 4px solid #00FF00; }
.ultimate33 { color: #FF0000; border-left: 4px solid #FF0000; } 
.ultimate34 { color: #0000FF; border-left: 4px solid #0000FF; } 
.ultimate35 { color: #800080; border-left: 4px solid #800080; } 
.ultimate36 { color: #FFA500; border-left: 4px solid #FFA500; } 
.ultimate37 { color: #008080; border-left: 4px solid #008080; }
.ultimate38 { color: #4B0082; border-left: 4px solid #4B0082; } 
.ultimate39 { color: #FF6347; border-left: 4px solid #FF6347; } 
.ultimate40 { color: #7CFC00; border-left: 4px solid #7CFC00; } 
.ultimate41 { color: #DC143C; border-left: 4px solid #DC143C; } 
.ultimate42 { color: #00FFFF; border-left: 4px solid #00FFFF; } 
.ultimate43 { color: #FF00FF; border-left: 4px solid #FF00FF; }
.ultimate44 { color: #FFFF00; border-left: 4px solid #FFFF00; }
.ultimate45 { color: #8B0000; border-left: 4px solid #8B0000; } 
.ultimate46 { color: #800000; border-left: 4px solid #800000; } 
.ultimate47 { color: #FFDAB9; border-left: 4px solid #FFDAB9; }
.ultimate48 { color: #000080; border-left: 4px solid #000080; }
.ultimate49 { color: #FF1493; border-left: 4px solid #FF1493; }
.ultimate50 { color: #00BFFF; border-left: 4px solid #00BFFF; }
          .equipment { position: relative; padding: 5px; margin: 3px 0; }
        .tooltip { 
            display: none;
            position: absolute;
            left: 65%;
            top: 0;
            background: white;
            border: 5px solid #ddd;
            padding: 5px;
            min-width: 200px;
            z-index: 0;
            transform: scale(0.5);
            margin-top: -90px;
        }
        .equipment:hover .tooltip { display: block; }
        @keyframes shake {
            -50%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .error { animation: shake 0.3s; color: red; }
        #actionLog {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }
        .offline-reward {
            color: #2ecc71;
            font-weight: bold;
            animation: fadeOut 1.5s ease-out 2s forwards;
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .success { color: #27ae60; }
        .info { color: #2980b9; }
        .auto-buy-container {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .auto-buy-btn { background-color: #e0e0e0; }
        .achievement { margin: 5px 0; padding: 5px; border: 1px solid #ddd; border-radius: 5px; }
        .achievement.unlocked { background-color: #e0f7fa; }
        .tab { cursor: pointer; padding: 10px; border: 1px solid #ccc; display: inline-block; margin-right: 5px; }
        .tab.active { background-color: #ccc; }

        /* 新增样式：装备品质面板缩小 200% */
        #equipmentList {
    transform: scale(1);
    transform-origin: top left;
    width: 100%;
    /* 新增以下样式 */
    max-height: 29.6vh; /* 限制最大高度为屏幕高度的20%，可根据需求调整 */
    overflow-y: auto; /* 允许垂直滚动 */
    -webkit-overflow-scrolling: touch; /* 启用移动端平滑滚动特性 */
    overscroll-behavior-y: contain; /* 阻止滚动到底部时的全局回弹 */
}

        /* 新增样式：游戏日志分页 */
        .log-tab { cursor: pointer; padding: 10px; border: 1px solid #ccc; display: inline-block; margin-right: 5px; }
        .log-tab.active { background-color: #ccc; }
        #gameLogPage1, #gameLogPage2, #gameLogPage3, #gameLogPage4 { display: none; }
        #gameLogPage1.active, #gameLogPage2.active, #gameLogPage3.active, #gameLogPage4.active { display: block; }

        /* 自定义对话框样式 */
        #customDialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            z-index: 1000;
            text-align: center;
        }
        #dialogOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        #dialogConfirm, #dialogCancel {
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
        }

        /* 新增股票样式 */
        #stocksContainer { margin-top: 20px; }
        .stock-item { 
            padding: 10px; 
            border: 1px solid #ddd; 
            margin: 5px 0; 
            cursor: pointer; 
        }
        .stock-item.selected { background-color: #e3f2fd; }
        .stock-control { margin-top: 20px; }
        .stock-control input { 
            padding: 5px;
            width: 120px;
            margin-right: 10px;
        }

        /* 新增彩票样式 */
        #lotteryResults, #traditionalLotteryNumbers {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }

        /* 新增银行系统样式 */
        #bankList {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }

        /* 新增打怪模式样式 */
        #monsterUI {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f9f9f9;
            border: 1px solid #ccc;
            padding: 10px;
            width: 300px;
            z-index: 1000;
        }
        #monsterUI h3 { margin-top: 0; }
        #monsterUI .monster-info { margin-bottom: 10px; }
        #monsterUI .player-info { margin-bottom: 10px; }
        #monsterUI .battle-log { max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; }

        /* 新增魂环样式 */
        #soulRingsContainer .equipment {
            padding: 8px;
            margin: 5px;
            border: 1px solid gold;
            border-radius: 4px;
        }
         /* 功法秘笈样式 */
.technique {
    padding: 10px;
    margin: 5px;
    border: 1px solid #8B4513; /* 棕色边框 */
    border-radius: 4px;
    background-color: #FFF8DC; /* 浅黄色背景 */
} 
#worldBossUI {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px; /* 从800px缩小到600px */
            max-width: 90%;
            max-height: 80vh; /* 限制最大高度 */
            background: #1a1a1a;
            border: 2px solid #d4af37;
            box-shadow: 0 0 15px #d4af37;
            padding: 15px; /* 减少内边距 */
            z-index: 1001;
            display: none;
            color: #fff;
            border-radius: 8px; /* 稍微减小圆角 */
            overflow-y: auto; /* 添加滚动条 */
        }
        
        #worldBossUI h3 {
            color: #d4af37;
            text-align: center;
            margin-top: 0;
            font-size: 20px; /* 减小字号 */
            text-shadow: 0 0 5px #d4af37;
            margin-bottom: 10px; /* 减小下边距 */
        }
        
        .boss-section {
            margin-bottom: 15px; /* 减小间距 */
            padding: 10px; /* 减小内边距 */
            background: #2a2a2a;
            border-radius: 6px;
            border: 1px solid #444;
        }
        
        .boss-section-title {
            color: #d4af37;
            font-weight: bold;
            margin-bottom: 8px; /* 减小下边距 */
            font-size: 16px; /* 减小字号 */
        }
        
        .boss-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px; /* 减小下边距 */
            font-size: 14px; /* 减小字号 */
        }
        
        .boss-name {
            font-size: 18px; /* 从22px减小 */
            color: #d4af37;
            text-align: center;
            margin: 8px 0; /* 减小边距 */
            text-shadow: 0 0 5px #d4af37;
        }
        
        .boss-world {
            font-size: 14px; /* 从16px减小 */
            color: #aaa;
            text-align: center;
            margin-bottom: 10px; /* 减小下边距 */
            font-style: italic;
        }
        
        .boss-stars {
            text-align: center;
            font-size: 16px; /* 从20px减小 */
            color: gold;
            margin-bottom: 10px; /* 减小下边距 */
        }
        
        .boss-health-bar {
            height: 20px; /* 从30px减小 */
            background: #333;
            border-radius: 10px;
            margin-bottom: 10px; /* 减小下边距 */
            overflow: hidden;
            position: relative;
        }
        
        .boss-health-fill {
            height: 100%;
            background: linear-gradient(to right, #d4af37, #f1e5ac);
            width: 100%;
            transition: width 0.3s;
        }
        
        .boss-health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            line-height: 20px; /* 与health-bar高度匹配 */
            color: #000;
            font-weight: bold;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-time-left {
            text-align: center;
            font-size: 14px; /* 从18px减小 */
            margin-bottom: 10px; /* 减小下边距 */
            color: #d4af37;
        }
        
        .boss-button {
            background: linear-gradient(to bottom, #d4af37, #a67c00);
            border: none;
            color: #000;
            padding: 6px 12px; /* 减小内边距 */
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin: 3px; /* 减小外边距 */
            transition: all 0.3s;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-button:hover {
            background: linear-gradient(to bottom, #f1e5ac, #d4af37);
            box-shadow: 0 0 8px #d4af37; /* 减小阴影 */
        }
        
        .boss-button:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }
        
        .boss-rankings {
            max-height: 120px; /* 从200px减小 */
            overflow-y: auto;
            border: 1px solid #444;
            padding: 6px; /* 减小内边距 */
            border-radius: 4px;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0; /* 减小内边距 */
            border-bottom: 1px solid #444;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-battle-log {
            max-height: 100px; /* 从150px减小 */
            overflow-y: auto;
            border: 1px solid #444;
            padding: 6px; /* 减小内边距 */
            border-radius: 4px;
            font-size: 11px; /* 减小字号 */
        }
        
        .boss-battle-log-entry {
            margin-bottom: 3px; /* 减小下边距 */
            padding-bottom: 3px; /* 减小内边距 */
            border-bottom: 1px dotted #444;
        }
        
        .boss-rewards {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        
        .boss-reward-tier {
            background: #333;
            padding: 6px; /* 减小内边距 */
            border-radius: 4px;
            margin: 3px; /* 减小外边距 */
            text-align: center;
            width: 45%; /* 调整宽度使两列显示 */
            min-width: 120px;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-reward-tier h4 {
            color: #d4af37;
            margin-top: 0;
            font-size: 13px; /* 减小字号 */
        }
        
        .boss-close-button {
            position: absolute;
            top: 5px; /* 减小位置 */
            right: 5px;
            background: none;
            border: none;
            color: #d4af37;
            font-size: 16px; /* 从20px减小 */
            cursor: pointer;
            padding: 2px;
        }
        
        .boss-summon-count {
            position: absolute;
            top: 5px; /* 减小位置 */
            left: 5px;
            color: #d4af37;
            font-weight: bold;
            font-size: 12px; /* 减小字号 */
        }
  .player-name {
  margin: 10px 0;
  padding: 8px 15px;
  font-size: 18px;
  font-weight: bold;
  position: relative;
  display: inline-block;
  background: linear-gradient(90deg, #fff, #f8f9fa, #fff);
  background-size: 200% 100%;
  border-radius: 6px;
  overflow: hidden;
}

.player-name::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    rgba(52, 152, 219, 0) 0%,
    rgba(52, 152, 219, 0.1) 50%,
    rgba(52, 152, 219, 0) 100%);
  animation: shine 3s infinite;
}

#playerName {
  background: linear-gradient(90deg, #3498db, #9b59b6, #e74c3c);
  background-size: 200% 200%;
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  animation: gradientShift 5s ease infinite;
  padding: 0 5px;
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@keyframes shine {
  100% { left: 100%; }
}

.player-name:hover #playerName {
  animation: gradientShift 2s ease infinite, bounce 0.5s ease;
}

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
}

.titleBranch {
    margin: 20px 0;
    padding: 10px;
    border: 1px solid #ddd;
}

.titleRow {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
}

.titleItem {
    padding: 8px 12px;
    background: #f0f0f0;
    border-radius: 4px;
    cursor: pointer;
    width: calc(20% - 10px); /* 每排5个 */
    text-align: center;
    box-sizing: border-box;
}

.titleItem.unlocked {
    background: #4CAF50;
    color: white;
}

.titleItem.selected {
    border: 2px solid #ffd700;
    font-weight: bold;
}
/* 通天塔界面缩小样式 */
#towerUI {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 500px; /* 缩小宽度 */
    max-width: 90%; /* 响应式最大宽度 */
    max-height: 70vh; /* 限制最大高度为屏幕的70% */
    background: #f9f9f9;
    border: 1px solid #ccc;
    padding: 15px; /* 减少内边距 */
    z-index: 1001;
    display: none; /* 默认隐藏 */
    overflow-y: auto; /* 内容过多时显示滚动条 */
    border-radius: 6px;
}

#towerUI h3 {
    font-size: 18px; /* 缩小标题字体 */
    margin: 10px 0;
    text-align: center;
}

#towerUI .floor-info {
    font-size: 14px; /* 缩小信息字体 */
    margin: 8px 0;
    padding: 8px;
    background: #f0f0f0;
    border-radius: 4px;
}

#towerUI button {
    padding: 6px 12px; /* 缩小按钮 */
    font-size: 12px;
    margin: 4px;
}

#towerUI .tower-log {
    max-height: 150px; /* 缩小日志区域 */
    overflow-y: auto;
    font-size: 12px;
    padding: 8px;
    margin-top: 10px;
    border: 1px solid #ddd;
}
#customDialog {
    z-index: 2000 !important; /* 确保高于其他元素 */
}

#dialogOverlay {
    z-index: 1999 !important;
}
.farm-field:hover {
    background-color: #3a3a3a !important;
    transition: background-color 0.3s;
}

.seed-item:hover {
    background-color: #3a3a3a !important;
    border-color: #4CAF50 !important;
    transition: all 0.3s;
}



button:hover {
    background: #666;
}
/* 星域探索系统样式 */
#explorationSystemUI {
    font-family: 'Arial', sans-serif;
}

.attribute-card {
    background: #2a2a4a;
    border-radius: 8px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.3s;
}

.attribute-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(74, 134, 232, 0.3);
}

.attribute-icon {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    margin-bottom: 10px;
}

.attribute-info {
    text-align: center;
    margin-bottom: 10px;
}

.upgrade-btn {
    background: linear-gradient(to bottom, #4a86e8, #1c5bb8);
    color: white;
    border: none;
    padding: 5px 15px;
    border-radius: 15px;
    cursor: pointer;
    width: 100%;
    transition: all 0.3s;
}

.upgrade-btn:hover {
    background: linear-gradient(to bottom, #5a96f8, #2c6bc8);
    transform: scale(1.05);
}

.mission-card {
    background: #2a2a4a;
    border-radius: 8px;
    padding: 15px;
    transition: all 0.3s;
}

.mission-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(74, 134, 232, 0.3);
}

.mission-card[data-difficulty="easy"] {
    border-left: 4px solid #00cc66;
}

.mission-card[data-difficulty="medium"] {
    border-left: 4px solid #4a86e8;
}

.mission-card[data-difficulty="hard"] {
    border-left: 4px solid #ff9900;
}

.mission-card[data-difficulty="extreme"] {
    border-left: 4px solid #ff3333;
}

.mission-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.difficulty-tag {
    background: #4a86e8;
    color: white;
    padding: 3px 10px;
    border-radius: 15px;
    font-size: 12px;
}

.mission-info {
    margin-bottom: 15px;
    font-size: 14px;
}

.start-mission-btn {
    background: linear-gradient(to bottom, #4a86e8, #1c5bb8);
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    width: 100%;
    transition: all 0.3s;
}

.start-mission-btn:hover {
    background: linear-gradient(to bottom, #5a96f8, #2c6bc8);
    transform: scale(1.05);
}

.resource-card {
    background: #2a2a4a;
    border-radius: 8px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.3s;
}

.resource-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(74, 134, 232, 0.3);
}

.resource-icon {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    margin-bottom: 10px;
}

.resource-info {
    text-align: center;
}

.log-entry {
    padding: 8px;
    margin-bottom: 5px;
    background: #2a2a4a;
    border-radius: 5px;
    font-size: 14px;
}

.log-entry:nth-child(odd) {
    background: #33335a;
}
.upgrade-btn:disabled {
    background: #666 !important;
    cursor: not-allowed;
    opacity: 0.7;
}
 .exchange-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
    }
    
    .exchange-info {
        flex: 1;
    }
    
    .exchange-controls {
        display: flex;
        gap: 10px;
    }
 .gem-shop-item {
        background: #2a2a2a;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
    }
    
    .gem-icon {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        font-weight: bold;
        margin: 0 auto 10px;
    }
    
    .gem-icon.red { background: linear-gradient(to bottom, #ff4d4d, #cc0000); }
    .gem-icon.blue { background: linear-gradient(to bottom, #4da6ff, #0066cc); }
    .gem-icon.black { background: linear-gradient(to bottom, #666666, #000000); }
    .gem-icon.green { background: linear-gradient(to bottom, #66ff66, #00cc00); }
    .gem-icon.pink { background: linear-gradient(to bottom, #ff66cc, #cc0099); }
    .gem-icon.yellow { background: linear-gradient(to bottom, #ffff66, #cccc00); }
    
    .gem-item {
        background: #2a2a2a;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        position: relative;
    }
    
    .gem-level {
        position: absolute;
        top: 5px;
        right: 5px;
        background: #d4af37;
        color: black;
        border-radius: 50%;
        width: 25px;
        height: 25px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
    }
.progress-bar {
    width: 100%;
    height: 20px;
    background-color: #333;
    border-radius: 10px;
    overflow: hidden;
    margin-top: 5px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(to right, #9C27B0, #E91E63);
    border-radius: 10px;
    transition: width 0.5s ease;
}

.tablink.active {
    background: #9C27B0 !important;
    font-weight: bold;
}
/* 添加弹幕动画效果 */
@keyframes danmakuMove {
    from {
        transform: translateX(100%);
    }
    to {
        transform: translateX(-100%);
    }
}

.danmaku {
    animation: danmakuMove linear forwards;
   pointer-events: none;
}
/* 添加一些动画效果 */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

#giftBoxBtn {
    animation: pulse 2s infinite;
    transition: all 0.3s;
}

#giftBoxBtn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(255, 94, 98, 0.5);
}

#boxInner {
    cursor: pointer;
    transition: transform 1s;
}

#giftBoxModal div {
    color: #ffffff;
}
 
    .exchange-btn {
        background: linear-gradient(to bottom, #4CAF50, #2E7D32);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
    }
    
    .exchange-btn:hover {
        background: linear-gradient(to bottom, #66BB6A, #388E3C);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .exchange-btn:active {
        transform: translateY(0);
    }
    
    .exchange-item {
        transition: all 0.3s;
    }
    
    .exchange-item:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    .gem-icon {
        box-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
    }
.artifact-tab {
    cursor: pointer;
    padding: 8px 15px;
    background: #333;
    border: 1px solid #d4af37;
    border-radius: 5px;
    color: #d4af37;
    font-weight: bold;
}

.artifact-tab.active {
    background: #d4af37;
    color: black;
}

.set-group {
    margin-bottom: 15px;
    border: 1px solid #444;
    border-radius: 5px;
    overflow: hidden;
}

.set-header {
    background: linear-gradient(to right, #2c2c2c, #1a1a1a);
    padding: 12px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #444;
}

.set-header:hover {
    background: linear-gradient(to right, #3c3c3c, #2a2a2a);
}

.set-name {
    font-weight: bold;
    color: #d4af37;
    font-size: 1.1em;
}

.set-count {
    background: #d4af37;
    color: black;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.9em;
}

.set-content {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    padding: 10px;
    background: #222;
}

.set-collapsed .set-content {
    display: none;
}

.folder-arrow {
    transition: transform 0.3s;
}

.set-collapsed .folder-arrow {
    transform: rotate(-90deg);
}
 .lottery-countdown {
            font-size: 14px;
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0;
            padding: 5px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
    </style>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body onload="resetItemDisplay(); resetPetDisplay()">
<body>
<div style="position: fixed; top: 10px; right: 10px; z-index: 9999; display: flex; flex-direction: column; align-items: flex-end;">
    <!-- 公告切换按钮 -->
    <button id="announcementToggle" style="background: #3498db; color: white; border: none; padding: 5px 10px; cursor: pointer; border-radius: 3px 3px 0 0;">
        点击呼出新手必看↓
    </button>
    
    <!-- 公告内容区域（默认隐藏） -->
    <div id="gameLogPage5" style="display: none; background: white; border: 1px solid #ddd; padding: 10px; max-height: 400px; width: 300px; overflow-y: auto; border-radius: 0 0 3px 3px;">
        <div class="log">
            <h4>游戏公告介绍</h4>
            <p>QQ群：864788026  有问题可以进群问</p>
            <p>1. 转生系统：玩家可以通过转生重置游戏进度，并获得转生币，用于提升转生属性（转生要求必须普通装备10000+转生次数*20）。</p>
            <p>   转生币等级兑换比例：普通10000=1  稀有5000=1 史诗1000=1 传说300=1 远古200=1 神圣125=1 奥术100=1 天空33=1 地狱20=1 星界12.5=1  原初10=1 超凡3=1 量子2=1 究极1=1  混沌1=3 永恒1=5 虚无1=10 创世1=20 神域1=30 终焉1=40 星辰1=50 起源1=60 时光1=70 造物1=80 银河1=90 天界1=100 星云1=200 星河1=300 纪元1=400 鸿蒙1=500 星穹1=600 亘古1=700 万象1=800 太虚1=900 九垓1=1000  穿梭1=2000  恒古1=3000 虚空1=4000 蔚来1=5000 神罚1=6000  时空1=7000  未来1=8000  从前1=9000   星澜1=10000</p>
            <p>2. 宠物系统：玩家可以通过升级宠物来提升装备属性加成。</p>
            <p>3. 离线系统：现在离线也能奥秘经验和银行和股票，彩票更新，升级装备。</p>
            <p>4. 新增股票系统，显示实时股价和持有情况，每10分钟股价随机波动±1%~10%，离线时间自动计算股价波动，所有交易使用转生币结算，实时显示价格变化趋势</p>
            <p>5. 彩票系统：30分钟开奖1次。刮刮卡：直接生效，开奖结果看获取！</p>
            <p>6. 银行系统：存钱每6分钟0.02%收益！</p>
            <p>7. 副本装备系统：副本装备可以提升第一页装备的全属性，使用洗炼石（材料宝箱或者打怪掉）可以重铸副本装备的成长属性或者分解重新获取。成长数值上限：废品0.05%，倚天剑10%，青龙枪15%，白虎斧20%，朱雀弓25%，玄武盾30%，麒麟杖35%，凤凰剑40%，饕餮刀45%，穷奇戟50%，烛龙枪60%，白泽剑70%，混沌斧80%，太初刃90%   后续加深颜色多10%  比如：☆=100%★=110% ○=200% ●=210%  ◇=300%  ◆=310%  □=400%  ■=410%  △=500%  ▲=510%</p>
            <p>8. 魂环系统：魂环可以永久提升装备属性，通过打怪掉落升级。</p>
            <p>9. 打怪模式(必须先打)：1转开启，逃跑等于重置关卡消耗最大关卡*10转生币（取消扫荡增加自动扫荡4秒1次！！！）（优先打！第一次打点逃跑！！！）。</p>
            <p>10. 升级属性：第一次加载要转生一次，在点洗点就正常了（总数和实际不一样点一下洗点）。</p>
            <p>11. 功法秘籍：后期比较强，加成属性直接算到玩家属性乘于里面（如果突然没效果了开一个秘法宝箱就好了，正常不会有问题）</p>
            <p>11. 世界BOSS系统：50转开启，才能打比较难，有连击后期简单。</p>
            <p>12. VIP系统：每一级提升大属性，材料宝箱和打怪模式掉落。</p>
            <p>13. 职业系统：20转开启，有法师和战士不同搭配属性，对于关卡解锁属性，选择获得属性。</p>
            <p>14. 称号系统：10转开启，解锁每一个都可以永久获得属性，自由搭配选择称号(不影响属性效果）。</p>
            <p>14. 官职系统：10转开启，增加总和攻击，一共65级。</p>
            <p>15. 伴侣系统：30转开启，大幅度增加属性。天赋品阶初级→中级→高级→终极→圣级→神级→远古→太古→洪荒，进阶玩法：每进阶+1倍率加1倍，未锁定状态才能进阶，点进阶自动消耗道具里面的同品质伴侣灵魂，想保留的伴侣记得锁定，史诗以上才能合成洗练！洗练每次洗减5评分！！（伴侣钥匙和玫瑰花和洗髓丹：打怪或者材料宝箱掉落）。</p>
            <p>16. 通天塔：100转开启，只要通过每一层加1点玩家属性，每一层加0.1倍GPS,还有对应称号。</p>
            <p>17. 存档问题：换设备后存档导入一开始进去VIP和伴侣是空的，你直接退出在重新进就恢复了或者刷新页面（点了导出按钮，会自动复制，你黏贴就可以了）</p>
            <p>18. 奥秘系统：100转开启，每阶段只生效第一个效果。</p>
            <p>19. 基金系统：投入的越多波动的幅度越大10-50%，1分钟刷新一次 ，10分钟不能实时卖出，如果跌到总价值20%以下 就全部没收清零。</p>
            <p>20. 钓鱼系统：20转开启，分解鱼类可以获得VIP能力值，玫瑰花，洗髓丹，洗练石，农场种子。鱼饵掉率（打怪模式扫荡）（自动钓鱼开启没用，点一下开始钓鱼，自动分解是分解钓到的所有东西）</p>
             <p>21. 农场系统：50转开启，种子靠鱼类分解，可以获得VIP能力值（水滴等于VIP能力值），每级都有每秒GPS和点击加成</p>
            <p>22. 停车场系统：200转开启，靠种子收取时候有几率获得车（进群领取兑换码送 "法拉利" ），每级都有每秒GPS和点击加成</p>
            <p>23. 神器锻造系统：500转开启，探索获取材料，6个品质，集齐套装加格外属性。</p>
           <p>24. 星域探索：300转开启，获取新材料</p>
           <p>25. 宝石系统：800转开启，提供大量属性</p>
           <p>26. 修仙系统：500转开启，开启经验获得条件是：获得一次灵根和血脉。材料都是杂货铺购买</p>
           <p>27. 宝图系统：600转开启，随机奖励或者打BOSS。</p>
           <p>28. 夜店系统：600转开启，店铺每级加点击伤害，特殊事件消耗50-200星币，提升30-60分钟金币或者经验收益，获得的星币可以兑换藏宝图，或者打世界地图怪物消耗（后续会加其他材料兑换）。</p>
           <p>29. 玩家等级：50转开启，每级10倍属性，世界地图怪物打怪升级。每100级可以飞升一次</p>
           <p>30. 世界地图：50转开启，打怪掉玩家经验，每挑战一次消耗1星币，如果打的时候闪退界面，那就是打不过这关。（后续会加材料掉落）。</p>
          <p>31. 直播系统：500转开启，每级增加点击伤害，粉丝数增加GPS加成，流量是获得多倍经验</p>
        <p>31. 宗门系统：1000转开启，每级GPS收益，功法库提升功法秘笈加成。</p>
        </div>
    </div>
</div>
   <div style="position: fixed; top: 10px; right: 510px; z-index: 9999; display: flex; flex-direction: column; align-items: flex-end;">
    <!-- 公告切换按钮 -->
    <button id="announcementToggle1" style="background: #3498db; color: white; border: none; padding: 5px 10px; cursor: pointer; border-radius: 3px 3px 0 0;">
        点击呼出更新日志↓
    </button>
    
    <!-- 公告内容区域（默认隐藏） -->
    <div id="gameLogPage4" style="display: none; background: white; border: 1px solid #ddd; padding: 10px; max-height: 400px; width: 300px; overflow-y: auto; border-radius: 0 0 3px 3px;">
        <div class="log">
            <h4>更新日志</h4>
           <p>2025/10/08 : 玩家等级增加飞升，每100级可以飞升一次(飞升后等级变为1级）属性翻倍，世界地图100转修改50转开启。鱼类分解增加获得种子几率。</p>
           <p>2025/10/07 : 修复星域探险任务进行中点开宗门导致星域不更新任务时间奖励</p>
           <p>2025/10/04 : 修复传统彩票不显示开奖结果。另外增加奖励！传统彩票奖励不再是转生币改为星尘发票（开奖后想看结果可以随便购买下面普通2个彩票中的一个刷新开奖结果界面）</p>
           <p>2025/10/03 :修改伴侣进阶要求：对应的伴侣灵魂获得。分解伴侣可以获得对应的伴侣灵魂（宝图小概率获得天使恶魔精灵），伴侣界面增加伴侣商店。宝图购买次数增加10-50次，开启也增加次数。宝图提高品质奖励：增加宝图2合1合成。修改农田浇水，每次浇水消耗30VIP能力值，可以加速成熟3分钟。</p>
           <p>2025/10/02 :神器界面加入筛选，想看什么筛选什么，神器锻造次数增加10-100次，建议不要太多分解再点。</p>
           <p>2025/10/01 :增加星域探索材料兑换转存档的时候可以用，伴侣宝箱开启次数增加10-50次，自动购买宝箱里面增加功法秘籍价格上限自己设置价格(输入10000或者1E4这样都可以)自动购买超出会停止购买转生后会自动开启，增加农场在线自动种植和收货。</p>
           <p>2025/9/30 : 修复宗门BUG</p>
           <p>2025/9/20 : 增加宗门，提升功法秘笈大量加成，忠诚度影响获得任务收益，大于忠诚50加低于减。宗门令牌：宝藏金币兑换，香囊：宝图打怪掉落</p>
           <p>2025/9/16 : 增加TXT导入存档，增加藏宝图商店，宝藏金币：宝图怪物掉落</p>
            <p>2025/9/14 : 优化扫荡严重卡顿，修复杂货铺兑换异常只能兑换1个的BUG</p>
            <p>2025/9/12 : 直播：盲盒出的礼物不加玫瑰花，只加粉丝数量，更新加了新3个宝箱9装备20成就3宠物3称号。</p>
            <p>2025/9/11 : 修复农田和离线时间异常显示，  增加直播：500转开启，每级增加点击伤害，粉丝数增加GPS加成，流量是获得多倍经验（每次进游戏建议结束直播在重新开播，不这样可能没礼物）（第一次加载记得刷新一下页面，第一次直播经验显示异常，刷新后正常）</p>
            <p>2025/9/10 : 玩家等级：50转开启，每一级增加10倍效果。世界地图：100转开启：打怪经验可以给玩家升级每次生成怪物消耗1星币（后续会加掉落材料）（如果属性显示低打一下打怪模式）</p>
            <p>2025/9/9 : 夜店：600转开启，生产星币，获得的星币可以兑换藏宝图或者升级（后续会加入更多东西兑换）已修复</p>
            <p>2025/9/8 : 通天塔失败不会关闭自动攻击</p>
            <p>2025/9/7 : 减少宝图兑换数量，神器增加进阶，消耗进阶神石：宝图掉落。（如果打怪模式显示血负了，脱一件神器在穿上就可以了）</p>

        </div>
    </div>
</div>
    <h1>金币冒险者</h1>
 <div class="player-name">
    <span id="playerName">勇者</span> <span id="playerClassName" style="color: #00f;"></span><span id="currentTitle" style="margin-left: 10px; color: #ffd700;"></span>
    <div class="vip-container" style="text-align: center; margin: 10px 0;">
     <span id="ascentionCountq" style="margin-left: 10px; color: #4CAF50;">0</span>
    <span id="playerLevelDisplay" style="margin-left: 10px; color: #4CAF50;">Lv.1</span>
  <div class="vip-level-display" style="font-size: 18px; font-weight: bold; background: linear-gradient(to right, #ffd700, #ffA500); -webkit-background-clip: text; color: transparent;">
    VIP等级: <span id="vipLevel">1</span>
  </div>
  <div class="vip-progress" style="height: 10px; background-color: #eee; border-radius: 5px; margin: 5px 0;">
    <div id="vipProgressBar" style="height: 100%; background: linear-gradient(to right, #ffd700, #ffA500); width: 0%;"></div>
  </div>
  <div class="vip-next-level" style="font-size: 12px; color: #666;">
    距离下一级: <span id="vipProgressText">0/1</span>
  </div>
</div>
 <div class="vip-power-use">
    <button onclick="useAllVipPower()">使用全部VIP能力值 (当前: <span id="vipPowerCount">0</span>)</button>
</div>
</div>
    <div class="currency">金币: <span id="gold">0</span></div>
    <div class="currency">钻石: <span id="diamond">0</span></div>
    <div class="currency">钛晶石: <span id="titanium">0</span></div>
    <div class="currency">星耀石: <span id="starstone">0</span></div>
    <div class="currency">宇宙石: <span id="cosmicstone">0</span></div>
    <div class="currency">超能石: <span id="superstone">0</span></div>
    <div class="currency">异界石: <span id="otherworldstone">0</span></div>
    <div class="currency">星界石: <span id="xingjiestone">0</span></div>
    <div class="currency">混沌石: <span id="hundunstone">0</span></div>
    <div class="currency">灵髓石: <span id="lingtone">0</span></div>
    <div class="currency">幻空石: <span id="huangtone">0</span></div>
    <div class="currency">冥源石: <span id="mingtone">0</span></div>
    <div class="currency">虚空石: <span id="xutong">0</span></div>
    <div class="currency">时空石: <span id="shitone">0</span></div>
    <div class="currency">未来石: <span id="weitone">0</span></div>
    <div class="currency">转生币: <span id="reincarnationCoin">0</span></div>
    <div>每秒金币（GPS）: <span id="gps">1</span></div>
    <div>点击收益: <span id="clickValue">1</span></div>
    <div>转生次数: <span id="reincarnationCount">0</span></div>
    <div>最高关卡: <span id="maxStage">0</span></div>
    <div>通天塔层数: <span id="towerFloor">0</span></div>
    <div>当前官职: <span id="currentOfficialTitle">无</span></div>
    <div>当前奥秘: <span id="currentMysteryTitle">初级秘法师 1阶1级</span></div>
    <div>修仙境界: <span id="currentStageq">凡人</span></div>
     <div id="sectNameDisplay" style="color: #8B4513; font-weight: bold; margin-top: 5px;">
        <!-- 宗门名称将在这里显示 -->
    </div>

    <button onclick="clickGold()">点击获取金币</button>
    <button onclick="reincarnate()">转生</button>
    <button onclick="toggleAutoReincarnation()" style="margin-left: 10px;">自动转生: <span id="autoReincarnationStatus">关闭</span></button>
    <button onclick="toggleLevelSystem()">玩家等级</button>
    <button onclick="toggleShopUI()">打开宝箱商店</button>
    <button onclick="toggleGroceriesUI()" style="margin-left: 10px;">杂货铺</button> 
    <button onclick="toggleMonsterUI()">打怪模式(优先打!)</button> 
    <button onclick="toggleWorldMap()">世界地图</button>
    <button onclick="toggleTowerUI()">通天塔</button>
    <button onclick="toggleWorldBossUI()" style="background: linear-gradient(to bottom, #d4af37, #a67c00); color: #000; font-weight: bold; padding: 6px 12px; font-size: 12px;">世界BOSS</button>
    <button onclick="toggleFundSystem()">基金系统</button>
    <button onclick="showTitleDialog()">称号系统</button>
    <button onclick="toggleOfficialSystem()">官职系统</button>
    <button onclick="toggleClassSystem()">职业系统</button>
    <button onclick="openCompanionSystem()">伴侣系统</button>
    <button onclick="toggleMysterySystem()">奥秘系统</button>
    <button onclick="toggleFishingSystem()" style="margin-left: 10px;">钓鱼系统</button>
    <button onclick="toggleFarmSystem()" style="margin-left: 10px;">农场系统</button>
    <button onclick="toggleParkingSystem()">停车位系统</button>
    <button onclick="toggleExplorationSystem()" style="margin-left: 10px;">星域探索</button>
    <button onclick="toggleArtifactSystem()" style="margin-left: 10px;">神器锻造系统</button>
    <button onclick="toggleCultivationSystem()" style="margin-left: 10px;">修仙系统</button>
    <button onclick="toggleGemSystem()" style="margin-left: 10px;">宝石系统</button>
    <button onclick="toggleTreasureMapSystem()">藏宝图系统</button>
    <button onclick="toggleNightClubSystem()" style="margin-left: 10px;">夜店系统</button>
    <button onclick="toggleLiveStreamSystem()" class="tab-button">直播系统</button>
    <button onclick="toggleSectSystem()" class="system-btn">宗门系统</button>
    <button onclick="toggleSettingsUI()">设置</button>

<h3>自动购买设置</h3>
    <div class="auto-buy-container">
      <button onclick="toggleAutoBuyShop()">自动购买商店</button>
      <button onclick="toggleAutoConvertUI()">自动兑换货币</button>
        <button id="autoBuySpeedBoost" class="auto-buy-btn" onclick="toggleAutoBuySpeedBoost()">在线自动购买100倍数量：关闭</button>
        <button id="toggleOnlineBoost" onclick="toggleOnlineBoost()">在线金币加速100倍: 关闭</button>
    </div>

  

    <div class="tab active" onclick="switchTab('equipment')">装备</div>
    <div class="tab" onclick="switchTab('items')">道具</div>
    <div class="tab" onclick="switchTab('collections')">收藏物</div>
    <div class="tab" onclick="switchTab('reincarnation')">转生属性</div>
    <div class="tab" onclick="switchTab('pets')">宠物</div>
    <div class="tab" onclick="switchTab('stocks')">股票</div>
    <div class="tab" onclick="switchTab('lottery')">彩票</div>
    <div class="tab" onclick="switchTab('bank')">银行系统</div>
    <div class="tab" onclick="switchTab('dungeonEquipment')">副本装备</div>
    <div class="tab" onclick="switchTab('soulRings')">魂环</div> <!-- 新增魂环标签 -->
    <div class="tab" onclick="switchTab('playerAttributes')">玩家属性</div>
    <div class="tab" onclick="switchTab('techniques')">功法秘籍</div>

    <h3></h3>
    <div id="equipmentList"></div>
    <h3></h3>
    <div id="itemList" style="display: none;">
    <h3></h3>
    <button onclick="resetItemDisplay()">重置道具页面</button> <!-- 新增按钮 -->
    
    <div id="itemContainer"></div> <!-- 用于显示道具信息的容器 -->
</div>
    <div id="collectionList" style="display: none;">
    <button onclick="resetAllCollectionEffects()">重新计算收藏物效果</button>
    <div id="collectionInfoContainer" style="margin-top: 10px;"></div>
</div>
    <h3></h3>
    <div id="reincarnationList" style="display: none;"></div>
    <h3></h3>
    <div id="petList" style="display: none;">
    <h3></h3>
    <button onclick="resetPetDisplay()">重置宠物页面</button> <!-- 新增按钮 -->
    <div id="petContainer"></div> <!-- 用于显示宠物信息的容器 -->
</div>
    <div id="stockList" style="display: none;">
        <h3>股票市场（每10分钟波动一次）</h3>
        <div id="stocksContainer"></div>
        <div class="stock-control">
            <input type="number" id="stockAmount" placeholder="数量" min="1">
            <button onclick="buyStock()">买入选中股</button>
            <button onclick="sellStock()">卖出选中股</button>
            <button onclick="buyAllStock()">买入选中所有股</button>
            <button onclick="sellAllStock()">卖出选中所有股</button>
        </div>
    </div>
    <h3></h3>
    <div id="lotteryList" style="display: none;">
        <h3></h3>
        <div>
            <h4>传统数字彩票（购买刮刮卡刷新开奖结果）</h4>
            <p>每30分钟开奖，1-50数字中6个100万，中5个10万，中4个1万，中3个1000，中2个100，中1个10（中奖奖励星尘发票）。记得来一注！</p>
            <button onclick="buyTraditionalLottery()">购买传统数字彩票（10转生币）</button>
            <div id="traditionalLotteryNumbers"></div>
            <div id="traditionalLotteryCountdown" class="lottery-countdown">下次开奖: --:--:--</div>
        </div>
        <div>
            <h4>蛇年刮刮卡（购买后刷新开奖结果）</h4>
            <p>60%谢谢惠顾0转生币，35%鼓励奖获得10-100转生币，三等奖3.9%获得100-500，二等奖1%获得500-2000，一等奖0.1%获得2000-10000。</p>
            <button onclick="buySnakeScratchCard()">购买蛇年刮刮卡（50转生币）</button>
        </div>
        <div>
            <h4>发财刮刮卡（购买后刷新开奖结果）</h4>
            <p>60%谢谢惠顾0转生币，35%鼓励奖获得100-1000转生币，三等奖3.9%获得1000-5000，二等奖1%获得5000-20000，一等奖0.1%获得20000-100000。</p>
            <button onclick="buyFortuneScratchCard()">购买发财刮刮卡（500转生币）</button>
        </div>
    </div>

    <!-- 新增银行系统 -->
    <div id="bankList" style="display: none;">
        <h3>银行系统</h3>
        <div>
            <p>当前存款: <span id="bankDeposit">0</span> 转生币</p>
            <p>利息: <span id="bankInterest">0.2%</span> 每6分钟</p>
            <p>总金额: <span id="bankTotal">0</span> 转生币</p>
            <input type="number" id="bankAmount" placeholder="存款金额" min="1">
            <button onclick="depositToBank()">存款</button>
            <button onclick="withdrawFromBank()">取款</button>
            <button onclick="depositAllToBank()">存款所有</button>
            <button onclick="withdrawAllFromBank()">取款所有</button>
        </div>
    </div>

    <!-- 新增副本装备系统 -->
    <div id="dungeonEquipmentList" style="display: none;">
        <h3></h3>
        <div id="dungeonEquipmentContainer"></div>
    </div>

    <!-- 新增魂环系统 -->
    <div id="soulRingList" style="display: none;">
        <h3></h3>
        <div id="soulRingsContainer"></div>
    </div>

        <!-- 玩家属性页面 -->
<div id="playerAttributesList" style="display: none;">
    <h3>玩家属性</h3>
    <div>总属性点: <span id="totalAttributePoints">0</span></div>
    <div>剩余属性点: <span id="remainingAttributePoints">0</span></div>
    <div>
        <strong>生命加成</strong>: 每2点属性点增加2%生命 
        (当前加成: <span id="healthBonus">0%</span>, 已投入: <span id="healthPoints">0</span>)
        <button onclick="addAttributePoint('health', 1)">+1</button>
        <button onclick="addAttributePoint('health', 10)">+10</button>
        <button onclick="addAttributePoint('health', 100)">+100</button>
        <button onclick="addAttributePoint('health', 1000)">+1000</button>
        <button onclick="addAttributePoint('health', 'all')">+全部</button>
    </div>
    <div>
        <strong>攻击加成</strong>: 每2点属性点增加2%攻击 
        (当前加成: <span id="attackBonus">0%</span>, 已投入: <span id="attackPoints">0</span>)
        <button onclick="addAttributePoint('attack', 1)">+1</button>
        <button onclick="addAttributePoint('attack', 10)">+10</button>
        <button onclick="addAttributePoint('attack', 100)">+100</button>
        <button onclick="addAttributePoint('attack', 1000)">+1000</button>
        <button onclick="addAttributePoint('attack', 'all')">+全部</button>
    </div>
    <div>
        <strong>暴击率加成</strong>: 每2点属性点增加0.1%暴击率 
        (当前加成: <span id="critRateBonus">0%</span>, 已投入: <span id="critRatePoints">0</span>)
        <button onclick="addAttributePoint('critRate', 1)">+1</button>
        <button onclick="addAttributePoint('critRate', 10)">+10</button>
        <button onclick="addAttributePoint('critRate', 100)">+100</button>
        <button onclick="addAttributePoint('critRate', 1000)">+1000</button>
        <button onclick="addAttributePoint('critRate', 'all')">+全部</button>
    </div>
    <div>
        <strong>爆伤加成</strong>: 每2点属性点增加1%爆伤 
        (当前加成: <span id="critDamageBonus">0%</span>, 已投入: <span id="critDamagePoints">0</span>)
        <button onclick="addAttributePoint('critDamage', 1)">+1</button>
        <button onclick="addAttributePoint('critDamage', 10)">+10</button>
        <button onclick="addAttributePoint('critDamage', 100)">+100</button>
        <button onclick="addAttributePoint('critDamage', 1000)">+1000</button>
        <button onclick="addAttributePoint('critDamage', 'all')">+全部</button>
    </div>
    <div>
        <strong>连击</strong>: 每300点属性点增加1次攻击 
        (当前加成: <span id="multiAttackBonus">0</span>, 已投入: <span id="multiAttackPoints">0</span>)
        <button onclick="addAttributePoint('multiAttack', 1)">+1</button>
        <button onclick="addAttributePoint('multiAttack', 10)">+10</button>
        <button onclick="addAttributePoint('multiAttack', 100)">+100</button>
        <button onclick="addAttributePoint('multiAttack', 1000)">+1000</button>
        <button onclick="addAttributePoint('multiAttack', 'all')">+全部</button>
    </div>
    <button onclick="resetAttributes()">洗点 (消耗1转生币)</button>
</div>

      <!-- 功法秘籍页面 -->
<div id="techniquesList" style="display: none;" >
    <h3></h3>
    <button onclick="resetTechniquesData()">重置功法页面</button>
    <div id="techniquesContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px;"></div>
 </div>

        <!-- 新增：游戏日志分页 -->
    <h3>游戏日志</h3>
    <div class="log-tab active" onclick="switchLogTab(1)">游戏记录</div>
    <div class="log-tab" onclick="switchLogTab(2)">公告右上角</div>
    <div class="log-tab" onclick="switchLogTab(3)">开奖结果</div>    
    <div id="gameLogPage1" class="active">
        <div id="actionLog" class="log"></div>
    </div>
    <div id="gameLogPage2">
        <div class="log">  
    </div>
</div>
    <div id="gameLogPage3">
        <div id="lotteryResults" class="log"></div>
    </div>
    <div id="gameLogPage4">
        <div id="battleLog" class="log"></div>
    </div>

    <h3>成就系统</h3>
    <div id="achievements" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px;"></div>

    <!-- 自定义对话框 -->
    <div id="customDialog">
        <div id="dialogMessage"></div>
        <textarea id="dialogInput" style="width: 100%; height: 100px; margin-bottom: 10px;"></textarea>
        <button id="dialogConfirm">确定</button>
        <button id="dialogCancel">取消</button>
    </div>
    <div id="dialogOverlay"></div>

 <div id="gemUseDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ccc; z-index: 1001; text-align: center;">
    <div id="gemUseMessage"></div>
    <div style="margin: 15px 0;">
        <button id="gemUseConfirm" style="padding: 8px 15px; margin-right: 10px;">确认使用</button>
        <button id="gemUseCancel" style="padding: 8px 15px;">取消</button>
    </div>
</div>
<div id="gemUseOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
  <div id="renameDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ccc; z-index: 1001;">
    <div>输入新名字:</div>
    <input type="text" id="newNameInput" style="margin: 10px 0;" maxlength="10">
    <div>
        <button onclick="confirmRename()">确定</button>
        <button onclick="cancelRename()">取消</button>
    </div>
</div>
<div id="classSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>

<div id="classSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 2px solid #333; z-index: 1000; max-width: 90%; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; text-align: center;">职业系统</h3>
    
    <div style="margin-bottom: 15px;">
        当前职业: <span id="currentClassName">无</span>
    </div>
    
    <div id="classSelection" style="margin: 15px 0; display: flex; gap: 10px; justify-content: center;">
        <button onclick="selectClass('warrior')">战士</button>
        <button onclick="selectClass('mage')">法师</button>
        <button onclick="toggleClassSystem()">关闭页面</button>
    </div>
    
    <div id="classChangeCost" style="color: red; margin: 10px 0; text-align: center; font-size: 0.9em;">
        更换职业将消耗1000转生币，所有职业加成将重置
    </div>
    
    <div id="classBranches" style="display: none; margin: 15px 0; padding: 10px; border-top: 1px dashed #333;max-height: 380px; overflow-y: auto">
        <h4 style="margin-top: 0;">职业分支加点</h4>
        <div id="branchPointsContainer"></div>

    </div>
</div>
<div id="renameOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
 <div id="activationCodeDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1001;">
    <h3>激活码兑换</h3>
    <input type="text" id="activationCodeInput" placeholder="请输入激活码" style="width: 200px; margin: 10px 0;">
    <div>
        <button onclick="confirmActivationCode()">确认兑换</button>
        <button onclick="cancelActivationCode()">取消</button>
    </div>
</div>
<div id="activationCodeOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>

    <!-- 新增打怪模式UI -->
    <div id="monsterUI" style="display: none;">
    <button onclick="toggleMonsterUI()" style="position: absolute; top: 5px; right: 200px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 25px; height: 25px; cursor: pointer;">×</button>
        <h3>打怪模式</h3>
        <div class="player-info">
            <p>生命: <span id="playerHealth">0</span></p>
            <p>攻击: <span id="playerAttack">0</span></p>
            <p>暴击率: <span id="playerCritRate">0%</span></p>
            <p>爆伤: <span id="playerCritDamage">0%</span></p>
            <p>命中: <span id="playerAccuracy">0%</span></p>
            <p>闪避: <span id="playerDodge">0%</span></p>
        </div>
        <div class="monster-info">
            <p>当前关卡: <span id="currentStage">0</span></p>
            <p>怪物名称: <span id="monsterName">无</span></p>
            <p>怪物品阶: <span id="monsterRank">无</span></p>
            <p>怪物生命: <span id="monsterHealth">0</span></p>
            <p>怪物攻击: <span id="monsterAttack">0</span></p>
            <p>怪物词条: <span id="monsterModifiers">无</span></p>
        </div>
        <div class="battle-controls">
            <button onclick="attackMonster()">攻击</button>
            <button onclick="fleeFromBattle()">逃跑</button>
            <button onclick="toggleAutoSweep()">自动扫荡: <span id="autoSweepStatus">关</span></button>
            <input type="number" id="jumpStage" placeholder="第一次打点逃跑" min="1">
            <button onclick="jumpToStage()">必看</button>
        </div>
        <div class="battle-log">
            <h4>战斗记录</h4>
            <div id="battleLogContent"></div>
        </div>
    </div>

<!-- 称号系统弹窗 -->
<div id="titleDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1001; width: 80%; max-width: 800px; max-height: 80vh; overflow-y: auto;">
    <h3>称号系统</h3>
    <div id="titleBranches">
        <!-- 关卡分支 -->
        <div class="titleBranch">
            <h4>关卡称号</h4>
            <div class="titleRow" id="stageBranchContainer"></div>
        </div>
        <!-- 转生分支 -->
        <div class="titleBranch">
            <h4>转生称号</h4>
            <div class="titleRow" id="reincarnationBranchContainer"></div>
        </div>
        <!-- 驯兽师分支 -->
        <div class="titleBranch">
            <h4>驯兽师称号</h4>
            <div class="titleRow" id="tamerBranchContainer"></div>
        </div>
        <!-- 魂环分支 -->
        <div class="titleBranch">
            <h4>魂环称号</h4>
            <div class="titleRow" id="soulRingBranchContainer"></div>
        </div>
        <!-- 特殊分支 -->
        <div class="titleBranch">
            <h4>特殊称号</h4>
            <div class="titleRow" id="specialBranchContainer"></div>
        </div>
     <!-- 特殊分支 -->
        <div class="titleBranch">
            <h4>普通称号</h4>
            <div class="titleRow" id="towerBranyyContainer"></div>
        </div>
    <!-- 特殊分支 -->
        <div class="titleBranch">
            <h4>通天塔称号</h4>
            <div class="titleRow" id="towerBranchContainer"></div>
        </div>
    </div>
    <button onclick="closeTitleDialog()" style="margin-top: 20px;">关闭</button>
</div>
<div id="titleOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>


<!-- 官职系统界面 -->
<div id="officialSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="officialSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 2px solid #333; z-index: 1001; max-width: 90%; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; text-align: center;">官职系统</h3>
    
    <div style="margin-bottom: 15px;">
        当前官职: <span id="officialTitleDisplay">无</span> (等级 <span id="officialLevelDisplay">0</span>)
    </div>
    <div style="margin-bottom: 15px;">
        当前加成: 攻击总和提升 <span id="officialBonusDisplay">1</span> 倍
    </div>
    
    <div style="margin: 15px 0;">
        <h4>下一阶官职</h4>
        <div id="nextOfficialInfo">请升级官职</div>
    </div>
    
    <div style="margin: 15px 0;">
        <label for="officialUpgradeAmount">升级次数:</label>
        <input type="number" id="officialUpgradeAmount" value="1" min="1" style="width: 60px;">
        <button onclick="upgradeOfficialByAmount()">升级</button>
        <button onclick="upgradeOfficialMaxPossible()">一键升级</button>
    </div>
    
    <div style="margin-top: 20px; text-align: center;">
        <button onclick="toggleOfficialSystem()">关闭</button>
    </div>
</div>

<div id="companionSystem" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <!-- 标题栏（包含标题和关闭按钮） -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
        <h2 style="color: #4CAF50; margin: 0;">伴侣系统</h2>
        <button onclick="closeCompanionSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
      <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 伴侣等级与升级 -->
    <div style="margin: 15px 0; padding: 10px; background: #333; border-radius: 5px;">
        <h3>伴侣等级: Lv. <span id="companionLevel">1</span></h3>
        <p>升级消耗: <span id="upgradeCost">10</span> 玫瑰花</p>
        <button onclick="upgradeCompanion()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">升级</button>
      <button onclick="toggleExpeditionSystem()" style="margin-top: 15px; background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">探险</button>
     <button onclick="toggleCompanionShop()" style="margin-top: 15px; background: #7417B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">伴侣商店</button>

</div> 
 
     <div style="flex: 1; min-width: 400px; background: #2a2a2a; padding: 10px; border-radius: 5px;">
        <h3>伴侣属性加成</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 0.9em;">
            <div>品质加成倍数: <span id="qualityMultiplier">1x</span></div>
            <div>攻击总和加成: <span id="attackTotalBonus">1x</span></div>
            <div>生命总和加成: <span id="healthTotalBonus">1x</span></div>
            <div>暴击率总和加成: <span id="critRateTotalBonus">1x</span></div>
            <div>爆伤总和加成: <span id="critDamageTotalBonus">1x</span></div>
            <div>连击总和加成: <span id="comboTotalBonus">0</span></div>
            <div>全属性总和加成: <span id="allStatsTotalBonus">1x</span></div>
</div>
</div>
</div>
    <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 伴侣宝箱 -->
    <div style="flex: 1; padding: 10px; background: #333; border-radius: 5px;">
        <h3>伴侣宝箱</h3>
        <p>当前钥匙: <span id="companionKeyCount">0</span></p>
        <button onclick="drawCompanion()" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启宝箱 (消耗1钥匙)</button>
    <div style="margin-top: 15px;">
    <h4>批量开启</h4>
    <button onclick="drawCompanionMultiple(10)" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启10次</button>
    <button onclick="drawCompanionMultiple(20)" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启20次</button>
    <button onclick="drawCompanionMultiple(50)" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启50次</button>
</div>
     <div style="margin-top: 15px; padding: 10px; background: #333; border-radius: 5px; font-size: 12px;">
        <h4 style="margin-top: 0; font-size: 13px; color: #d4af37;">保底机制</h4>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
            <div>史诗(紫色): <span id="epicGuarantee">0</span>/100</div>
            <div>卓越(粉色): <span id="pinkGuarantee">0</span>/500</div>
            <div>完美(橙色): <span id="orangeGuarantee">0</span>/1000</div>
            <div>神赐(红色): <span id="redGuarantee">0</span>/5000</div>
        </div>
    </div>
    </div>
    
    <!-- 批量分解 -->
    <div style="flex: 1; padding: 10px; background: #333; border-radius: 5px;">
        <h3>批量分解</h3>
        <select id="decomposeRarity" style="padding: 5px; margin-right: 10px;">
            <option value="white">普通(白色)</option>
            <option value="blue">稀有(蓝色)</option>
            <option value="epic">史诗(紫色)</option>
            <option value="pink">卓越(粉色)</option>
            <option value="orange">完美(橙色)</option>
            <option value="red">神赐(红色)</option>
            <option value="angel">天使(彩色)</option>
            <option value="emyyyy">恶魔(深红色)</option>
           <option value="jlyyyy">精灵(绿色)</option>
        </select>
        <button onclick="batchDecompose()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">批量分解选中品阶(未锁定)</button>
<div style="flex: 1; padding: 10px; background: #333; border-radius: 5px; margin-top: 1px;">
    <h3>自动分解设置</h3>
    <select id="autoDecomposeBelowRarity" style="padding: 5px; margin-right: 10px;">
        <option value="white">普通(白色)及以下</option>
        <option value="blue">稀有(蓝色)及以下</option>
        <option value="epic">史诗(紫色)及以下</option>
        <option value="pink">卓越(粉色)及以下</option>
        <option value="orange">完美(橙色)及以下</option>
        <option value="red">神赐(红色)及以下</option>
        <option value="angel">天使(彩色)及以下</option>
        <option value="emyyyy">恶魔(深红色)及以下</option>
        <option value="jlyyyy">精灵(绿色)及以下</option>
    </select>
    <button id="toggleAutoDecompose" onclick="toggleAutoDecompose()" style="background: #ff9800; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">自动分解：关闭</button>
</div>
    </div>
</div>
    
    <!-- 伴侣列表 -->
    <div style="margin: 15px 0;">
        <h3>我的伴侣</h3>
        <div id="companionList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;max-height: 400px; overflow-y: auto;">
            <!-- 伴侣卡片会动态生成在这里 -->
        </div>
    </div>
  </div>  
 
<div id="towerUI" style="display: none; position: fixed; top: 20%; left: 20%; transform: translate(50%, -10%); width: 30%; max-width: 800px; background: #fff; border: 2px solid #333; border-radius: 10px; padding: 20px; z-index: 1000;">
    <!-- 右上角关闭按钮 -->
    <button onclick="toggleTowerUI()" style="position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
    <h3>通天塔</h3>
     <div>GPS加成: <span id="towerBonus">0%</span> (每层增加0.1倍)</div>
    <div class="player-info">
        <p>生命: <span id="towerPlayerHealth">0</span></p>
        <p>攻击: <span id="towerPlayerAttack">0</span></p>
        <p>暴击率: <span id="towerPlayerCritRate">0%</span></p>
        <p>爆伤: <span id="towerPlayerCritDamage">0%</span></p>
        <p>命中: <span id="towerPlayerAccuracy">0%</span></p>
        <p>闪避: <span id="towerPlayerDodge">0%</span></p>
    </div>
    <div class="monster-info">
        <p>当前层数: <span id="towerCurrentFloor">0</span></p>
        <p>怪物名称: <span id="towerMonsterName">无</span></p>
        <p>怪物品阶: <span id="towerMonsterRank">无</span></p>
        <p>怪物生命: <span id="towerMonsterHealth">0</span></p>
        <p>怪物攻击: <span id="towerMonsterAttack">0</span></p>
        <p>怪物词条: <span id="towerMonsterModifiers">无</span></p>
        <p>剩余复活次数: <span id="towerMonsterResurrections">20</span></p>
    </div>
    <div class="battle-controls">
        <button onclick="attackTowerMonster()">攻击</button>
        <button onclick="toggleTowerAutoAttack()">自动攻击: <span id="towerAutoAttackStatus">关</span></button>
    </div><h4>如果属性是初始没加成，打一次打怪模式恢复在重新点击通天塔</h4>
    <div class="battle-log" id="towerBattleLog"></div>
</div>
</div>
</div>


<!-- 奥秘系统界面 -->
<div id="mysterySystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="mysterySystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 2px solid #333; z-index: 1001; max-width: 90%; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; text-align: center;">奥秘系统</h3>
    
    <div style="margin-bottom: 15px;">
        当前奥秘: <span id="mysteryTitleDisplay">初级秘法师 1阶1级</span>
    </div>
    <div style="margin-bottom: 15px;">
        当前加成: GPS加成 <span id="mysteryBonusDisplay">1</span> 倍（每一阶生效）
    </div>
    <div style="margin-bottom: 15px;">
        当前经验: <span id="currentMysteryExp">0</span> / <span id="nextMysteryExp">1000</span>
    </div>
    <div style="margin-bottom: 15px;">
        每分钟经验获取: <span id="expPerMinute">0</span> (通天塔层数 × VIP等级)
    </div>
    
    <div style="margin: 15px 0;">
        <h4>下一等级</h4>
        <div id="nextMysteryInfo">初级秘法师 1阶2级 - 消耗: 1000经验</div>
    </div>
    
    <div style="margin: 15px 0;">
        <label for="mysteryUpgradeAmount">升级次数:</label>
        <input type="number" id="mysteryUpgradeAmount" value="1" min="1" style="width: 60px;">
        <button onclick="upgradeMysteryByAmount()">升级</button>
        <button onclick="upgradeMysteryMaxPossible()">一键升级</button>
    </div>
    
    <div style="margin-top: 20px; text-align: center;">
        <button onclick="toggleMysterySystem()">关闭</button>
    </div>
</div>
<!-- 基金系统界面 -->
<div id="fundSystem" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 800px; background: #fff; border: 2px solid #333; border-radius: 10px; padding: 20px; z-index: 1001;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2>基金系统</h2>
          <h3>投入的越多波动的幅度越大10-50%（按满仓算50%）。1分钟刷新一次 ，10分钟不能实时卖出，最后5分钟不能投入，如果跌到总价值20%以下 就全部没收清零。每次第一次购买净值会归为1，已购买后正常。</h3> <button onclick="resetFundData()" style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">重置基金</button>
        <button onclick="toggleFundSystem()" style="padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭</button>
     <button onclick="updateFundDisplay()" style="padding: 5px 10px; margin-right: 10px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">刷新</button>
    </div>
    
    <div style="max-height: 500px; overflow-y: auto; padding-right: 10px;">
        <div id="fundsContainer"></div>
    </div>
    
   <!-- 基金遮罩层 -->
<div id="fundOverlay" style="display: none;"></div>
</div><!-- 基金遮罩层 -->
<!-- 商店界面HTML (添加到body标签内任意位置) -->
<div id="shopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; border-radius: 10px; z-index: 1000; max-width: 500px; max-height: 80vh; overflow-y: auto;">
    <h2>商店</h2>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button onclick="buyChest(1)">普通宝箱（100金币）</button>
        <button onclick="buyChest(2)">高级宝箱（10钻石）</button>
        <button onclick="buyChest(3)">稀有宝箱（1钛晶石）</button>
        <button onclick="buyChest(4)">史诗宝箱（1星耀石）</button>
        <button onclick="buyChest(5)">传说宝箱（1宇宙石）</button>
        <button onclick="buyChest(6)">混沌宝箱（1超能石）</button>
        <button onclick="buyChest(7)">终焉宝箱（1异界石）</button>
        <button onclick="buyChest(8)">星辰宝箱（1星界石）</button>
        <button onclick="buyChest(9)">银河宝箱（1混沌石）</button>
        <button onclick="buyChest(10)">星云宝箱（1灵髓石）</button>
        <button onclick="buyChest(11)">鸿蒙宝箱（1幻空石）</button>
        <button onclick="buyChest(12)">太虚宝箱（1冥源石）</button>
        <button onclick="buyChest(13)">虚空宝箱（1虚空石）</button>
        <button onclick="buyChest(14)">时空宝箱（1时空石）</button>
        <button onclick="buyChest(15)">未来宝箱（1未来石）</button>
     <button onclick="buyMaterialChest()">材料宝箱（<span id="materialChestCost">1</span>钻石）</button>
    <button onclick="buyTechniqueChest()">功法秘籍宝箱（<span id="techniqueChestCost">1</span>转生币）</button>
    </div>
    <button onclick="toggleShopUI()" style="margin-top: 20px; padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭商店</button>
</div>
<!-- 半透明背景遮罩 (添加到body标签内) -->
<div id="shopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
<!-- 设置界面对话框 -->
<div id="settingsDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ccc; z-index: 1000; text-align: center;">
    <h3>游戏设置</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button onclick="showRenameDialog()">名字修改</button>
        <button onclick="showActivationCodeDialog()">激活码兑换</button>
        <button onclick="saveGame()">保存游戏</button>
        <button onclick="loadGame()">加载游戏</button>
        <button onclick="exportSave()">导出存档（自动复制）</button>        
        <button onclick="importSave()">导入存档</button>
        <button onclick="downloadSave()">下载TXT存档</button>
         <button onclick="importEncryptedSave()">导入TXT存档</button>
        <button onclick="resetGame()" style="background-color: #ff4444; color: white; border: none;">重置游戏</button>
    </div>
    <button onclick="toggleSettingsUI()">关闭设置</button>
</div>
<input type="file" id="fileInput" accept=".txt" style="display: none;">


<!-- 半透明遮罩层 -->
<div id="settingsOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
<!-- 新增合成面板HTML -->
<div id="combinePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; background: #333; border: 2px solid #9C27B0; border-radius: 10px; padding: 20px; z-index: 1001;">
    <button onclick="closeCombinePanel()" style="position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
    <h3 style="color: #fff; text-align: center;">伴侣合成</h3>
    
    <div style="display: flex; gap: 20px; margin: 20px 0;">
        <!-- 主伴侣选择 -->
        <div style="flex: 1;">
            <h4 style="color: #fff;">主伴侣</h4>
            <div id="mainCompanionSlot" style="background: #444; border-radius: 5px; padding: 10px; min-height: 150px;">
                <select id="mainCompanionSelect" style="width: 100%; padding: 5px; background: #555; color: white; border: 1px solid #666;">
                    <!-- 动态填充可选伴侣 -->
                </select>
                <div id="mainCompanionInfo" style="margin-top: 10px; color: #fff; font-size: 0.9em;">
                    <!-- 显示选中的主伴侣信息 -->
                </div>
            </div>
        </div>
        
        <!-- 合成图标 -->
        <div style="display: flex; align-items: center; justify-content: center;">
            <button onclick="combineCompanions()" style="background: #9C27B0; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 20px; cursor: pointer;">→</button>
        </div>
        
        <!-- 副伴侣选择 -->
        <div style="flex: 1;">
            <h4 style="color: #fff;">副伴侣</h4>
            <div id="secondaryCompanionSlot" style="background: #444; border-radius: 5px; padding: 10px; min-height: 150px;">
                <select id="secondaryCompanionSelect" style="width: 100%; padding: 5px; background: #555; color: white; border: 1px solid #666;">
                    <!-- 动态填充可选伴侣 -->
                </select>
                <div id="secondaryCompanionInfo" style="margin-top: 10px; color: #fff; font-size: 0.9em;">
                    <!-- 显示选中的副伴侣信息 -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 合成预览 -->
    <div style="background: #444; border-radius: 5px; padding: 10px; margin: 10px 0;">
        <h4 style="color: #fff; margin-top: 0;">合成预览</h4>
        <div id="combinePreview" style="color: #fff; font-size: 0.9em;">
            <p>选择主副伴侣查看合成预览</p>
            <p>新一代数: <span id="previewGeneration">--</span></p>
            <p>预计天赋数量: <span id="previewTalentCount">--</span></p>
            <p>预计品质: <span id="previewRarity" style="color: #ff00ff;">天使(彩色)丶</span> <span id="previewRarity" style="color: #E63946;">恶魔(深红色)丶</span> <span id="previewRarity" style="color: #7CFC00;">精灵(绿色)</span></p>
            <p>预计评分范围: <span id="previewScoreRange">--</span></p>
            <p>品质加成倍数: <span id="previewQualityMultiplier">--</span></p>
        </div>
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="combineCompanions()" style="background: #9C27B0; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">确认合成</button>
        <p style="color: #ff4444; font-size: 0.8em; margin-top: 10px;">注意: 合成将消耗主副两只伴侣，且结果随机！</p>
    </div>
</div>
<!-- 新增自动购买商店界面 -->
<div id="autoBuyShop" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1000; max-height: 80vh; overflow-y: auto; width: 500px;">
    <h3>自动购买设置</h3>
    <div class="auto-buy-container">
        <button id="autoChest1" class="auto-buy-btn" onclick="toggleAutoBuy(1)">普通宝箱自动购买：关闭</button>
        <button id="autoChest2" class="auto-buy-btn" onclick="toggleAutoBuy(2)">高级宝箱自动购买：关闭</button>
        <button id="autoChest3" class="auto-buy-btn" onclick="toggleAutoBuy(3)">稀有宝箱自动购买：关闭</button>
        <button id="autoChest4" class="auto-buy-btn" onclick="toggleAutoBuy(4)">史诗宝箱自动购买：关闭</button>
        <button id="autoChest5" class="auto-buy-btn" onclick="toggleAutoBuy(5)">传说宝箱自动购买：关闭</button>
        <button id="autoChest6" class="auto-buy-btn" onclick="toggleAutoBuy(6)">混沌宝箱自动购买：关闭</button>
        <button id="autoChest7" class="auto-buy-btn" onclick="toggleAutoBuy(7)">终焉宝箱自动购买：关闭</button>
        <button id="autoChest8" class="auto-buy-btn" onclick="toggleAutoBuy(8)">星辰宝箱自动购买：关闭</button>
        <button id="autoChest9" class="auto-buy-btn" onclick="toggleAutoBuy(9)">银河宝箱自动购买：关闭</button>
        <button id="autoChest10" class="auto-buy-btn" onclick="toggleAutoBuy(10)">星云宝箱自动购买：关闭</button>
        <button id="autoChest11" class="auto-buy-btn" onclick="toggleAutoBuy(11)">鸿蒙宝箱自动购买：关闭</button>
        <button id="autoChest12" class="auto-buy-btn" onclick="toggleAutoBuy(12)">太虚宝箱自动购买：关闭</button>
        <button id="autoChest13" class="auto-buy-btn" onclick="toggleAutoBuy(13)">虚空宝箱自动购买：关闭</button>
        <button id="autoChest14" class="auto-buy-btn" onclick="toggleAutoBuy(14)">时空宝箱自动购买：关闭</button>
        <button id="autoChest15" class="auto-buy-btn" onclick="toggleAutoBuy(15)">未来宝箱自动购买：关闭</button>
        <button id="autoMaterialChest" class="auto-buy-btn" onclick="toggleAutoBuyMaterialChest()">材料宝箱自动购买：关闭</button>
        <button id="autoTechniqueChest" class="auto-buy-btn" onclick="toggleAutoBuyTechniqueChest()">功法秘籍宝箱自动购买：关闭</button>
    </div>
    <button onclick="toggleAutoBuyShop()" style="margin-top: 15px;">关闭商店</button>
     <button onclick="toggleAutoBuySettings()">功法秘籍自动购买设置</button>
</div>
<!-- 自动兑换货币界面 -->
<div id="autoConvertUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #3498db; border-radius: 10px; z-index: 1000; max-width: 500px; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; color: #3498db; text-align: center;">自动兑换设置</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
        <button id="autoConvertGold" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('gold')">金币自动兑换：关闭</button>
        <button id="autoConvertDiamond" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('diamond')">钻石自动兑换：关闭</button>
        <button id="autoConvertTitanium" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('titanium')">钛晶石自动兑换：关闭</button>
        <button id="autoConvertStarstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('starstone')">星耀石自动兑换：关闭</button>
        <button id="autoConvertCosmicstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('cosmicstone')">宇宙石自动兑换：关闭</button>
        <button id="autoConvertSuperstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('superstone')">超能石自动兑换：关闭</button>
        <button id="autoConvertOtherworldstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('otherworldstone')">异界石自动兑换：关闭</button>
        <button id="autoConvertXingjiestone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('xingjiestone')">星界石自动兑换：关闭</button>
        <button id="autoConvertHundunstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('hundunstone')">混沌石自动兑换：关闭</button>
        <button id="autoConvertLingtone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('lingtone')">灵髓石自动兑换：关闭</button>
        <button id="autoConvertHuangtone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('huangtone')">幻空石自动兑换：关闭</button>
        <button id="autoConvertMingtone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('mingtone')">冥源石自动兑换：关闭</button>
        <button id="autoConvertXutong" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('xutong')">虚空石自动兑换：关闭</button>
        <button id="autoConvertShitone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('shitone')">时空石自动兑换：关闭</button>
    </div>
    <div style="text-align: center; margin-top: 15px;">
        <button onclick="toggleAutoConvertUI()" style="background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">关闭</button>
    </div>
</div>

<!-- 半透明遮罩层 -->
<div id="autoConvertOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
<!-- 新增洗练面板HTML -->
<div id="washPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: #333; border: 2px solid #2196F3; border-radius: 10px; padding: 20px; z-index: 1001;">
    <button onclick="closeWashPanel()" style="position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
    <h3 style="color: #fff; text-align: center;">伴侣洗练</h3>
    
    <div id="washCompanionInfo" style="background: #444; border-radius: 5px; padding: 10px; margin: 15px 0;">
        <!-- 伴侣信息将在这里动态填充 -->
    </div>
    
    <div style="margin: 15px 0; color: #fff;">
        <p>洗练消耗：1 洗髓丹</p>
        <p>当前洗髓丹数量：<span id="rebornDanCount">0</span></p>
    </div>
    
    <div id="washResult" style="background: #444; border-radius: 5px; padding: 10px; margin: 15px 0; min-height: 60px; color: #fff; display: none;">
        <!-- 洗练结果将在这里动态显示 -->
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="washCompanion()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">确认洗练</button>
        <p style="color: #ff4444; font-size: 0.8em; margin-top: 10px;">注意: 洗练将随机改变伴侣天赋，可能增加天赋数量！</p>
    </div>
</div>
<div id="fishingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="fishingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #f0f8ff; padding: 20px; border: 3px solid #4682b4; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <!-- 标题栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #4682b4; padding-bottom: 10px;">
        <h2 style="color: #1e3a8a; margin: 0;">钓鱼系统</h2>
        <button onclick="toggleFishingSystem()" style="background: #ff4444; color: white; border: none; border-radius: 5px; padding: 5px 10px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 钓鱼信息 -->
    <div style="margin-bottom: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div>
                <strong>钓鱼等级: </strong><span id="fishingLevel">1</span>
            </div>
            <div>
                <strong>当前经验: </strong><span id="currentFishingExp">0</span>/<span id="nextFishingExp">500</span>
            </div>
            <div>
                <strong>点击收益加成: </strong><span id="fishingBonus">1</span>
            </div>
        </div>
        <div style="margin-top: 10px;">
            <strong>鱼饵数量: </strong><span id="baitCount">0</span>
        </div>
    </div>
    
    <!-- 钓鱼区域 -->
    <div style="background: #87ceeb; height: 200px; border-radius: 8px; margin-bottom: 20px; position: relative; overflow: hidden;">
        <div id="fishingPond" style="width: 100%; height: 100%; position: relative;">
            <!-- 水面效果 -->
            <div style="position: absolute; bottom: 0; width: 100%; height: 120px; background: #1e90ff; opacity: 0.7; border-top: 2px dashed #4682b4;"></div>
            
            <!-- 鱼竿 -->
            <div id="fishingRod" style="position: absolute; bottom: 120px; left: 50px; width: 150px; height: 10px; background: #8b4513; transform-origin: left center; transform: rotate(-30deg); display: none;">
                <div style="position: absolute; right: 0; width: 20px; height: 20px; background: #ffd700; border-radius: 50%;"></div>
            </div>
            
            <!-- 浮标 -->
            <div id="fishingBobber" style="position: absolute; bottom: 130px; left: 180px; width: 15px; height: 15px; background: #ff4500; border-radius: 50%; display: none;"></div>
            
            <!-- 鱼咬钩动画区域 -->
            <div id="biteIndicator" style="position: absolute; bottom: 120px; left: 180px; color: white; font-weight: bold; display: none; text-shadow: 0 0 5px #000;">
                鱼咬钩了！快拉！
            </div>
            
            <!-- 状态文本 -->
            <div id="fishingStatus" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: #1e3a8a; font-weight: bold;">
                点击"开始钓鱼"按钮开始
            </div>
        </div>
    </div>
    
    <!-- 钓鱼控制按钮 -->
    <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
        <button id="startFishingBtn" onclick="startFishing()" style="background: #228b22; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">开始钓鱼</button>
        <button id="reelInBtn" onclick="reelInFish()" style="background: #d2691e; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; display: none;">拉钩上钓</button>
     <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
    <button id="autoFishingBtn" onclick="toggleAutoFishing()" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">
        自动钓鱼: 关闭
    </button>
    <button id="autoDecomposeFishBtn" onclick="toggleAutoDecomposeFish()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">
        自动分解: 关闭
    </button>
</div>
    </div>
    
    <!-- 鱼笼信息 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #1e3a8a; border-bottom: 1px solid #4682b4; padding-bottom: 5px;">鱼笼 (<span id="cageCount">0</span>/20)</h3>
        <div id="fishCage" style="background: white; padding: 10px; border-radius: 8px; max-height: 200px; overflow-y: auto; border: 1px solid #ddd; display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
            <!-- 鱼会动态显示在这里 -->
            <div style="grid-column: 1 / -1; text-align: center; color: #666;">鱼笼是空的，快去钓鱼吧！</div>
        </div>
    </div>
    
    <!-- 分解按钮 -->
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="decomposeSelectedFish()" style="background: #8b0000; color: white; border: none; padding: 10px 30px; border-radius: 5px; cursor: pointer; font-size: 16px;">分解选中的鱼获</button>
    </div>
</div>
<!-- 农场系统界面 -->
<div id="farmSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="farmSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
        <h2 style="color: #4CAF50; margin: 0;">农场系统</h2>
        <button onclick="closeFarmSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 农场信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between;">
            <div>
                <strong>农场等级:</strong> <span id="farmLevel">1</span>
                <strong>经验:</strong> <span id="farmExp">0</span>/<span id="farmExpNext">100</span>
            </div>
            <div>
                <strong>农田数量:</strong> <span id="farmFieldCount">2</span>/<span id="farmMaxFields">5</span>
            </div>
            <div>
                <strong>水滴:</strong> <span id="waterCount">10</span>
            </div>
        </div>
    </div>
    
    <!-- 农田区域 -->
    <div style="margin-bottom: 20px;">
        <h3>农田</h3>
        <div id="farmFields" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 10px;">
            <!-- 农田地块将动态生成 -->
        </div>
    </div>
    
    <!-- 种子仓库 -->
    <div style="margin-bottom: 20px;">
        <h3>种子仓库</h3>
        <div id="seedInventory" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 10px; max-height: 200px; overflow-y: auto;">
            <!-- 种子将动态生成 -->
        </div>
    </div>
    
    <!-- 操作按钮 -->
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="waterAllCrops()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">一键浇水</button>
        <button onclick="harvestAllCrops()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">一键收获</button>

    <button id="autoPlantBtn" onclick="toggleAutoPlant()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">自动种植: 关闭</button>
    <button id="autoHarvestBtn" onclick="toggleAutoHarvest()" style="background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">自动收获: 关闭</button>
    </div>
</div>
<!-- 停车位系统界面 -->
<div id="parkingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="parkingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <!-- 标题栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
        <h2 style="color: #4CAF50; margin: 0;">停车位系统</h2>
        <button onclick="closeParkingSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 停车位信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div>
                <strong>停车位等级:</strong> <span id="parkingLevel">1</span>
            </div>
            <div>
                <strong>停车位数量:</strong> <span id="parkingSpotCount">1</span>/<span id="maxParkingSpots">5</span>
            </div>
            <div>
                <strong>停车经验:</strong> <span id="parkingExp">0</span>/<span id="nextLevelExp">150</span>
            </div>
            <div>
                <strong>总收益:</strong> <span id="totalParkingIncome">0</span> 转生币
            </div>
        </div>
        <button onclick="upgradeParking()" style="margin-top: 10px; background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">升级停车位 (消耗经验)</button>
    </div>
    
    <!-- 车辆管理 -->
    <div style="margin-bottom: 20px;">
        <h3>我的车辆</h3>
        <div id="vehicleList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; padding: 10px; background: #333; border-radius: 5px;">
            <!-- 车辆卡片会动态生成在这里 -->
        </div>
    </div>
    
    <!-- 停车操作 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>停车操作</h3>
        <div id="parkingSpotsContainer" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin: 10px 0; max-height: 400px; overflow-y: auto; ">
            <!-- 停车位会动态生成在这里 -->
        </div>
        <div>
            <button onclick="parkAllVehicles()" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; margin-right: 10px;">一键停车</button>
            <button onclick="collectAllParkingIncome()" style="background: #FFC107; color: black; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">收取所有收益</button>
                       
        </div>
    </div>
    
    <!-- 车辆分解 -->
    <div style="background: #333; padding: 15px; border-radius: 8px;">
        <h3>车辆分解</h3>
        <p>选择车辆进行分解，获得转生币</p>
        <div id="decomposeVehicleContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;max-height: 400px; overflow-y: auto;">
            <!-- 分解界面会动态生成在这里 -->
        </div>
        <button onclick="decomposeSelectedVehicle()" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">分解选中车辆</button>
    </div>
</div>
<!-- 星域探索系统界面 -->
<div id="explorationSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="explorationSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #0a0a2a; color: white; padding: 20px; border: 3px solid #4a86e8; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4a86e8; padding-bottom: 10px;">
        <h2 style="color: #4a86e8; margin: 0;">星域探索系统</h2>
        <button onclick="toggleExplorationSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    <div style="text-align: center; margin-top: 15px;">
    <button onclick="toggleExchangeShop()" style="background: #FFD700; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">兑换商店</button>
</div>

    <!-- 舰队属性 -->
    <div style="margin-bottom: 20px; background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">舰队属性</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 15px;">
           <div class="attribute-card">
    <div class="attribute-icon" style="background: linear-gradient(to bottom, #ff9900, #ff6600);">⏱️</div>
    <div class="attribute-info">
        <strong>速度</strong>
        <div>等级: <span id="speedLevel">1</span></div>
        <div>探索时间: <span id="explorationTime">60</span>分钟</div>
    </div>
    <button class="upgrade-btn" data-attr="speed" onclick="upgradeAttribute('speed')">升级</button>
</div>

<div class="attribute-card">
    <div class="attribute-icon" style="background: linear-gradient(to bottom, #00cc66, #00994d);">📦</div>
    <div class="attribute-info">
        <strong>容量</strong>
        <div>等级: <span id="capacityLevel">1</span></div>
        <div>资源获取: <span id="resourceGain">100%</span></div>
    </div>
    <button class="upgrade-btn" data-attr="capacity" onclick="upgradeAttribute('capacity')">升级</button>
</div>

<div class="attribute-card">
    <div class="attribute-icon" style="background: linear-gradient(to bottom, #9966ff, #6600cc);">🛡️</div>
    <div class="attribute-info">
        <strong>耐久</strong>
        <div>等级: <span id="durabilityLevel">1</span></div>
        <div>稀有率: <span id="rareRate">5%</span></div>
        <div>损坏率: <span id="damageRate">10%</span></div>
    </div>
    <button class="upgrade-btn" data-attr="durability" onclick="upgradeAttribute('durability')">升级</button>
</div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="upgradeAllAttributes()" style="background: #4a86e8; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer;">一键升级全部属性</button>
        </div>
    </div>
    
    <!-- 探索任务 -->
    <div style="margin-bottom: 20px; background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">探索任务</h3>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <div class="mission-card" data-difficulty="easy">
                <div class="mission-header">
                    <h4>近地星域</h4>
                    <span class="difficulty-tag">简单</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">60分钟</span></div>
                    <div>资源: 星尘</div>
                    <div>资源: 暗物质</div>
                    <div>损坏风险: <span class="damage-risk">10%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('easy')">开始探索</button>
            </div>
            
            <div class="mission-card" data-difficulty="medium">
                <div class="mission-header">
                    <h4>深空星域</h4>
                    <span class="difficulty-tag">中等</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">120分钟</span></div>
                    <div>资源: 星尘</div>
                    <div>资源: 暗物质</div>
                    <div>资源: 宇宙晶体</div>
                    <div>损坏风险: <span class="damage-risk">20%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('medium')">开始探索</button>
            </div>
            
            <div class="mission-card" data-difficulty="hard">
                <div class="mission-header">
                    <h4>黑洞边缘</h4>
                    <span class="difficulty-tag">困难</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">180分钟</span></div>
                    <div>资源: 星尘</div>
                    <div>资源: 暗物质</div>
                    <div>资源: 宇宙晶体</div>
                    <div>损坏风险: <span class="damage-risk">30%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('hard')">开始探索</button>
            </div>
            
            <div class="mission-card" data-difficulty="extreme">
                <div class="mission-header">
                    <h4>宇宙边缘</h4>
                    <span class="difficulty-tag">极限</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">240分钟</span></div>
                    <div>资源: 宇宙晶体</div>
                    <div>资源: 神器碎片</div>
                    <div>损坏风险: <span class="damage-risk">40%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('extreme')">开始探索</button>
            </div>
        </div>
    </div>
    
    <!-- 资源仓库 -->
    <div style="margin-bottom: 20px; background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">资源仓库</h3>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #cccccc, #999999);">✨</div>
                <div class="resource-info">
                    <strong>星尘</strong>
                    <div id="stardustCount">0</div>
                </div>
            </div>
            
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #333366, #000033);">🌌</div>
                <div class="resource-info">
                    <strong>暗物质</strong>
                    <div id="darkMatterCount">0</div>
                </div>
            </div>
            
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #66ccff, #3399ff);">💎</div>
                <div class="resource-info">
                    <strong>宇宙晶体</strong>
                    <div id="cosmicCrystalCount">0</div>
                </div>
            </div>
            
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #ffcc00, #ff9900);">🔱</div>
                <div class="resource-info">
                    <strong>神器碎片</strong>
                    <div id="artifactFragmentCount">0</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 探索日志 -->
    <div style="background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">探索日志</h3>
        <div id="explorationLog" style="height: 200px; overflow-y: auto; background: #0a0a1a; padding: 10px; border-radius: 5px; margin-top: 10px;">
            <div class="log-entry">欢迎使用星域探索系统！</div>
            <div class="log-entry">选择任务并开始探索宇宙奥秘吧！</div>
        </div>
    </div>
</div>
<!-- 神器锻造系统 -->
<div id="artifactSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="artifactSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #d4af37; padding-bottom: 10px;">
        <h2 style="color: #d4af37; margin: 0;">神器锻造系统</h2>
        <button onclick="toggleArtifactSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    

    <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 锻造区域 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">锻造神器</h3>
        <p>消耗10神器碎片随机锻造一件神器</p>
        <button onclick="forgeArtifact()" style="background: #d4af37; color: black; border: none; padding: 8px 20px; border-radius: 5px; cursor: font-weight: bold; margin-top: 10px;">锻造1次</button>
                       <button onclick="forgeArtifact(10)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造10次</button>
                <button onclick="forgeArtifact(20)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造20次</button>
                <button onclick="forgeArtifact(50)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造50次</button>
                <button onclick="forgeArtifact(100)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造100次</button>
    </div>
     <div style="margin-top: 0px; background: #444; padding: 15px; border-radius: 8px; width: 28%;">
        <h4 style="color: #d4af37; margin-top: 0;">进阶系统</h4>
        <h6 style="color: #d4af37; margin-top: 0;">下方神器仓库选择一个点击详情</h6>
        <div id="artifactAdvanceInfo">
            <!-- 进阶信息将动态填充 -->
        </div>
        <button id="advanceArtifactBtn" onclick="advanceArtifact()" style="margin-top: 10px; background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px;">进阶神器</button>
    </div>

     <div style="margin-top: 0px; background: #444; padding: 15px; border-radius: 8px; width: 28%;">
        <h7 style="color: #d4af37; margin-top: 0;"></h7>
        <h8 style="color: #d4af37; margin-top: 0;"></h8>
        </div> 
   </div>


    <!-- 装备部位 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d4af37; margin-top: 0;">装备部位</h3>
        <div id="artifactSlots" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
            <!-- 6个装备部位将动态生成 -->
        </div>
    </div>
    
    <!-- 神器仓库 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d4af37; margin-top: 0; overflow-y: auto;">神器仓库</h3>
    <div style="display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 1px solid #d4af37; padding-bottom: 10px; max-height: 400px; overflow-y: auto;">
    <div class="artifact-tab active" onclick="switchArtifactTab('all')">全部神器</div>
    <div class="artifact-tab" onclick="switchArtifactTab('sets')">按套装查看</div>
        <div id="artifactInventory" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-height: 400px; overflow-y: auto; padding: 10px; background: #333; border-radius: 8px;">
            <!-- 神器将动态生成 -->

</div>

<!-- 添加套装查看容器 -->
<div id="artifactSetsView" style="display: none;max-height: 400px; overflow-y: auto; padding: 10px; background: #333; border-radius: 8px;">
    <div id="artifactSetsContainer"></div>
</div>
        </div>
    </div>
   
    <!-- 套装效果 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">套装效果</h3>
        <div id="setBonuses">
            <!-- 套装效果将动态显示 -->
        </div>
    </div>
</div>
<!-- 杂货铺界面 -->
<div id="groceriesOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="groceriesUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; border-radius: 10px; z-index: 1001; width: 500px;">
    <h2>杂货铺</h2>
    <p>当前星尘: <span id="currentStardust">0</span></p>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>鱼饵</strong>
            <div>100星尘 → 2鱼饵</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="baitAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('bait')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>伴侣钥匙</strong>
            <div>200星尘 → 1钥匙</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="keyAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('key')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>玫瑰花</strong>
            <div>100星尘 → 20玫瑰花</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="roseAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('rose')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>VIP能力值</strong>
            <div>100星尘 → 10VIP能力值</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="vipAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('vip')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>神级宝石</strong>
            <div>5000星尘 → 1神级宝石</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="gemAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('gem')">兑换</button>
        </div>
    </div>
    <div class="exchange-item">
    <div class="exchange-info">
        <strong>灵根检测器</strong>
        <div>500星尘 → 1个</div>
    </div>
    <div class="exchange-controls">
        <input type="number" id="rootAmount" min="1" value="1" style="width: 60px;">
        <button onclick="exchangeStardust('root')">兑换</button>
    </div>
</div>
    <div class="exchange-item">
    <div class="exchange-info">
        <strong>血脉检测剂</strong>
        <div>500星尘 → 1个</div>
    </div>
    <div class="exchange-controls">
        <input type="number" id="bloodAmount" min="1" value="1" style="width: 60px;">
        <button onclick="exchangeStardust('blood')">兑换</button>
    </div>
</div>
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>转生币</strong>
            <div>100星尘 → 1000000转生币</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="coinAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('coin')">兑换</button>
        </div>
    </div>
    
    <button onclick="toggleGroceriesUI()" style="margin-top: 20px; padding: 8px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭</button>
</div>
<!-- 宝石系统界面 -->
<div id="gemSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="gemSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #d4af37; margin: 0;">宝石系统</h2>
        <button onclick="toggleGemSystem()" style="background: #ff4444; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 宝石商店 -->
    <div style="margin-bottom: 30px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">宝石商店</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
            <div class="gem-shop-item">
                <div class="gem-icon red">红</div>
                <div>红宝石 (攻击)</div>
                <div>价格: 100暗物质</div>
                <button onclick="buyGem('red', 1)">购买</button>
            </div>
            <div class="gem-shop-item">
                <div class="gem-icon blue">蓝</div>
                <div>蓝宝石 (生命)</div>
                <div>价格: 100暗物质</div>
                <button onclick="buyGem('blue', 1)">购买</button>
            </div>
            <div class="gem-shop-item">
                <div class="gem-icon black">黑</div>
                <div>黑宝石 (爆伤)</div>
                <div>价格: 100暗物质</div>
                <button onclick="buyGem('black', 1)">购买</button>

            </div>
        </div>
    </div>
    
    <!-- 宝石仓库 -->
    <div style="margin-bottom: 30px;">
        <h3 style="color: #d4af37; margin-top: 0;">宝石仓库</h3>
        <div id="gemInventory" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
            <!-- 宝石将动态生成在这里 -->
        </div>
    </div>
</div>
<!-- 修仙系统UI -->
<div id="cultivationSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="cultivationSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #4CAF50; margin: 0;">修仙系统</h2>
        <button onclick="toggleCultivationSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 当前灵根信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4CAF50; margin-top: 0;">当前灵根</h3>
        <div id="currentRootInfo" style="text-align: center; padding: 0px;">
            尚未检测灵根
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="openRootBox()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">开启灵根宝箱</button>
        </div>
    </div>
    <div style="margin-top: 0px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4CAF50; margin-top: 0;">当前血脉</h3>
        <div id="currentBloodlineInfo" style="text-align: center; padding: 0px;">
            尚未检测血脉
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="openBloodlineBox()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">开启血脉宝箱</button>
        </div>
    </div>
    <!-- 修仙阶段 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4CAF50; margin-top: 0;">修仙阶段</h3>
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div>境界等级: <span id="stageLevel">0</span></div>
        </div>
        <div style="margin-bottom: 10px;">
            <div>当前经验: <span id="currentExp">0</span></div>
            <div>升级所需: <span id="nextExp">1000</span></div>
      <div style="margin-top: 10px; background: #444; padding: 10px; border-radius: 5px;">
        <p>经验计算公式: (灵根加成 × 血脉加成) × 转生次数</p>
        <p>当前每分钟经验: <span id="currentExpPerMinute">0</span></p>
    </div>
</div>
        </div>
        <div class="exp-bar">
            <div id="expProgress" class="exp-progress" style="width: 0%;"></div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="upgradeCultivation()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">升级</button>
        </div>
    </div>
    
    <!-- 阶段加成 -->
    <div style="background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4CAF50; margin-top: 0;">阶段加成</h3>
        <div id="stageBonusInfo">
            当前加成: 点击收益+GPS × <span id="gpsMultiplier">1</span>
        </div>
    </div>
</div>

<!-- 灵根宝箱UI -->
<div id="rootBoxOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="rootBoxUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 400px; text-align: center;">
    <h3 style="color: #FFD700; margin-top: 0;">灵根宝箱</h3>
    <p>消耗1个灵根检测器开启宝箱</p>
    <div id="rootResult" style="margin: 20px 0; font-size: 18px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
        点击开启获取灵根
    </div>
    <button onclick="drawRoot()" style="background: #FFD700; color: black; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin-right: 10px;">开启宝箱</button>
    <button onclick="closeRootBox()" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">关闭</button>
</div>
<!-- 血脉宝箱UI -->
<div id="bloodlineBoxOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="bloodlineBoxUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 400px; text-align: center;">
    <h3 style="color: #FFD700; margin-top: 0;">血脉宝箱</h3>
    <p>消耗1个血脉检测剂开启宝箱</p>
    <div id="bloodlineResult" style="margin: 20px 0; font-size: 18px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
        点击开启获取血脉
    </div>
    <button onclick="drawBloodline()" style="background: #FFD700; color: black; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin-right: 10px;">开启宝箱</button>
    <button onclick="closeBloodlineBox()" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">关闭</button>
</div>
<!-- 伴侣探险系统UI -->
<div id="expeditionSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="expeditionSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #9C27B0; margin: 0;">伴侣探险</h2>
        <button onclick="toggleExpeditionSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 探险任务列表 -->
    <div style="margin-bottom: 20px;">
        <h3>探险任务（自动选择最高评分）</h3>
        <div id="expeditionTasks" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 10px;">
            <!-- 任务将动态生成 -->
        </div>
    </div>
    
    <!-- 当前探险状态 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>当前探险（评分有加成倍数）</h3>
        <div id="currentExpedition" style="margin-top: 10px;">
            <p>没有进行中的探险</p>
        </div>
    </div>
    
    <!-- 探险历史记录 -->
    <div style="margin-bottom: 20px;">
        <h3>探险记录</h3>
        <div id="expeditionHistory" style="max-height: 200px; overflow-y: auto; background: #333; padding: 10px; border-radius: 5px;">
            <!-- 记录将动态生成 -->
        </div>
    </div>
</div>
<!-- 藏宝图系统界面 -->
<div id="treasureMapSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureMapSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #d4af37; margin: 0;">藏宝图系统</h2>
        <button onclick="toggleTreasureMapSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 藏宝图钥匙信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">藏宝图钥匙</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>当前数量: <span id="treasureKeyCount">0</span></div>
            <button onclick="buyTreasureKey()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换钥匙 (100星尘)</button>
            <button onclick="buyTreasureKey1()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换钥匙 (100星币)</button>
            <button onclick="buyTreasureKey2()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换10个钥匙 (1000星币)</button>
            <button onclick="buyTreasureKey3()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换50个钥匙 (5000星币)</button>
        </div>
    </div>
    
    <!-- 开启藏宝图宝箱 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">开启藏宝图宝箱</h3>
        <p>消耗1个藏宝图钥匙随机获得一张藏宝图</p>
        <button onclick="openTreasureChest()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: font-weight: bold; margin-top: 10px;">开启宝箱</button>
          <button onclick="openTreasureChestBatch(10)" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开启10次</button>
    <button onclick="openTreasureChestBatch(20)" style="background: #FF9800; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开启20次</button>
    <button onclick="openTreasureChestBatch(50)" style="background: #F44336; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开启50次</button>
        <button onclick="openTreasureShop()" style="background: #9C27B0; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">藏宝图商店</button>
    </div>
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
    <h3 style="color: #d4af37; margin-top: 0;">藏宝图合成</h3>
    <p>将2张同等级同品质的藏宝图合成为1张更高品质的藏宝图</p>
    
    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
        <select id="craftLevel" style="padding: 5px; flex: 1;">
            <option value="1">一级藏宝图</option>
            <option value="2">二级藏宝图</option>
            <option value="3">三级藏宝图</option>
            <option value="4">四级藏宝图</option>
            <option value="5">五级藏宝图</option>
        </select>
        
        <select id="craftQuality" style="padding: 5px; flex: 1;">
            <option value="1">普通</option>
            <option value="2">精良</option>
            <option value="3">稀有</option>
            <option value="4">史诗</option>
            <option value="5">传说</option>
            <!-- 神话品质无法继续合成 -->
        </select>
    </div>
    
    <div style="margin-bottom: 10px;">
        当前拥有: <span id="craftCount">0</span> 张
    </div>
    
    <button onclick="craftTreasureMap()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; width: 100%;">合成</button>
    <button onclick="craftAllTreasureMaps()" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; width: 100%; margin-top: 10px;">一键合成全部</button>
</div>
    <!-- 我的藏宝图 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d4af37; margin-top: 0;">我的藏宝图（开宝图前建议打一下打怪模式刷新属性）</h3>
        <div id="treasureMapList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 300px; overflow-y: auto; padding: 10px; background: #333; border-radius: 5px;">
            <!-- 藏宝图卡片会动态生成在这里 -->
        </div>
    </div>
</div>
<div id="treasureBattleOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureBattleUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 600px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #d4af37; margin: 0;">宝藏守卫者</h2>
       <div id="treasureBattleStatus" style="color: #4CAF50; font-weight: bold;">战斗中...</div>
    </div>
    
    <div class="player-info">
        <p>生命: <span id="treasurePlayerHealth">0</span></p>
        <p>攻击: <span id="treasurePlayerAttack">0</span></p>
        <p>暴击率: <span id="treasurePlayerCritRate">0%</span></p>
        <p>爆伤: <span id="treasurePlayerCritDamage">0%</span></p>
    </div>
    
    <div class="monster-info">
        <p>怪物名称: <span id="treasureMonsterName">宝藏守卫者</span></p>
        <p>怪物品阶: <span id="treasureMonsterRank">无</span></p>
        <p>怪物生命: <span id="treasureMonsterHealth">0</span></p>
        <p>怪物攻击: <span id="treasureMonsterAttack">0</span></p>
        <p>怪物词条: <span id="treasureMonsterModifiers">无</span></p>
    </div>
    
    <div class="battle-controls">
        <button onclick="attackTreasureMonster()">攻击</button>
    </div>
    
    <div class="battle-log" id="treasureBattleLog" style="margin-top: 20px; height: 100px; overflow-y: auto; background: #333; padding: 10px; border-radius: 5px;"></div>
</div>

<!-- 藏宝图奖励界面 -->
<div id="treasureRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 500px;">
    <h2 style="color: #4CAF50; text-align: center; margin-top: 0;">藏宝图奖励</h2>
    <div id="treasureRewardContent" style="text-align: center; margin: 20px 0;">
        <!-- 奖励内容将在这里显示 -->
    </div>
    <button onclick="closeTreasureReward()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; display: block; margin: 0 auto;">关闭</button>
</div>
<!-- 夜店之王系统界面 -->
<div id="nightClubOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="nightClubUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 850px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #9C27B0; padding-bottom: 10px;">
        <h2 style="color: #9C27B0; margin: 0;">夜店之王</h2>
        <button onclick="toggleNightClubSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 店铺信息 -->
    <div style="margin-bottom: 20px; background: #222; padding: 15px; border-radius: 8px; border: 1px solid #444;">
        <div style="display: flex; justify-content: space-between;">
            <div>
                <strong>店铺等级:</strong> <span id="nightClubLevel">1</span>
                <div style="margin-top: 5px;">
                    <div class="progress-bar">
                        <div id="nightClubExpBar" class="progress-fill" style="width: 0%;"></div>
                    </div>
                    <div style="font-size: 0.9em; margin-top: 5px;">
                        经验: <span id="nightClubExp">0</span>/<span id="nightClubExpNext">100</span>
                    </div>
                </div>
            </div>
            <div style="text-align: right;">
                <strong>星币:</strong> <span id="starCoinCount">0</span>
                <div style="margin-top: 5px;">
                    <strong>每分钟收益:</strong>
                    <div>经验: <span id="expPerMinuteq">0</span></div>
                    <div>星币: <span id="coinsPerMinute">0</span></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 标签页 -->
    <div class="nightclub-tabs" style="display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 1px solid #444;">
        <button class="tablink active" onclick="openNightClubTab('staff')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">店员</button>
        <button class="tablink" onclick="openNightClubTab('equipment')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">设备</button>
        <button class="tablink" onclick="openNightClubTab('special')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">特殊人群</button>
        <button class="tablink" onclick="openNightClubTab('events')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">事件</button>
    </div>
    
    <!-- 店员标签页 -->
    <div id="nightClubStaff" class="nightclub-tabcontent">
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <!-- 店员卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 设备标签页 -->
    <div id="nightClubEquipment" class="nightclub-tabcontent" style="display:none;">
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <!-- 设备卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 特殊人群标签页 -->
    <div id="nightClubSpecial" class="nightclub-tabcontent" style="display:none;">
        <div style="background: #222; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <h3 style="margin-top: 0; color: #9C27B0;">VIP客人</h3>
            <p>VIP客人会定期光顾你的夜店，带来大量经验和星币！</p>
            <div id="vipInfo" style="margin-top: 10px;">
                <!-- VIP信息将动态显示 -->
            </div>
        </div>
    </div>
    
    <!-- 事件标签页 -->
    <div id="nightClubEvents" class="nightclub-tabcontent" style="display:none;">
        <div style="background: #222; padding: 15px; border-radius: 8px;">
            <h3 style="margin-top: 0; color: #9C27B0;">当前事件（消耗50-200星币）</h3>
            <div id="currentEvent" style="margin-bottom: 15px;">
                <!-- 当前事件将动态显示 -->
            </div>
            <button onclick="triggerRandomEvent()" style="background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">触发随机事件</button>
        </div>
    </div>
</div>
<!-- 玩家等级系统界面 -->
<div id="levelSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="levelSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 500px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #4CAF50; margin: 0;">玩家等级系统</h2>
        <button onclick="toggleLevelSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px;">
        <div>当前等级: <span id="currentPlayerLevel">1</span></div>
        <div>当前经验: <span id="currentPlayerExp">0</span>/<span id="nextLevelExpq">10000</span></div>
        <div>点击收益加成: <span id="clickBonus">0.01%</span></div>
        <div>每秒金币加成: <span id="gpsBonus">0.01</span></div>
         <div>飞升次数: <span id="ascentionCount">0</span></div>
        <div>飞升加成倍数: <span id="ascentionMultiplier">1</span></div>
        <div>下次飞升要求: <span id="nextAscentionRequirement">500</span>级</div>
    </div>
    
    <div class="exp-bar" style="height: 20px; background: #333; border-radius: 10px; margin: 10px 0;">
        <div id="playerExpProgress" style="height: 100%; background: #4CAF50; border-radius: 10px; width: 0%;"></div>
    </div>
    
    <div style="margin: 15px 0;">
         <button onclick="ascendPlayer()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">飞升</button>
    </div>
</div>

<!-- 世界地图界面 -->
<div id="worldMapOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="worldMapUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">世界地图</h2> 
        <button onclick="toggleWorldMap()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
   
    <div id="zoneList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
        <!-- 区域列表会动态生成 -->
    </div>
</div>

<!-- 战斗界面 -->
<div id="battleOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="battleUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FF4500; border-radius: 10px; z-index: 1001; width: 600px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FF4500; margin: 0;">战斗</h2>
        <button onclick="closeBattle()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    <div style="color: #FFD700; margin: 0;">
    星币: <span id="battleRebornDanCount">0</span>
    <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
        <div class="player-stats">
            <h3>玩家属性</h3>
            <div>生命: <span id="battlePlayerHealth">0</span></div>
            <div>攻击: <span id="battlePlayerAttack">0</span></div>
            <div>暴击率: <span id="battlePlayerCritRate">0%</span></div>
            <div>爆伤: <span id="battlePlayerCritDamage">0%</span></div>
        </div>
        
        <div class="monster-info">
    <p>怪物名称: <span id="battleMonsterName">无</span></p>
    <p>怪物词条: <span id="battleMonsterModifier">无</span></p>
    <p>怪物生命: <span id="battleMonsterHealth">0</span>/<span id="battleMonsterMaxHealth">0</span></p>
    <p>怪物攻击: <span id="battleMonsterAttack">0</span></p>
    <p>复活次数: <span id="battleMonsterResurrections">0</span>/5</p>
</div>
    </div>
    
    <div class="battle-controls" style="text-align: center; margin: 20px 0;">
<button onclick="toggleWorldMapAutoBattle()" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-right: 10px;">
    自动战斗: <span id="worldMapAutoBattleStatus">关闭</span>
</button>
    </div>
    
    <div id="addbattleLog" style="height: 200px; overflow-y: auto; background: #333; padding: 10px; border-radius: 5px; margin-top: 10px;">
        <!-- 战斗日志会动态显示 -->
    </div></div></div>
<!-- 直播系统UI -->
<div id="liveStreamSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="liveStreamSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #0f0f23; color: white; padding: 20px; border: 3px solid #ff00ff; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #ff00ff; padding-bottom: 10px;">
        <h2 style="color: #ff00ff; margin: 0;">直播系统</h2>
        <button onclick="toggleLiveStreamSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 直播状态和等级信息 -->
    <div style="margin-bottom: 20px; background: #1a1a2a; padding: 15px; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between;">
            <div>
                <strong>直播等级:</strong> <span id="liveStreamLevel">1</span>
                <strong>经验:</strong> <span id="liveStreamExp">0</span>/<span id="liveStreamNextExp">100</span>
            </div>
            <div>
                <strong>在线观众:</strong> <span id="liveViewerCount">0</span>
            </div>
            <div>
                <strong>粉丝数:</strong> <span id="totalLiveEarnings">0</span> 
            </div>
        </div>
        <div class="exp-bar" style="margin-top: 10px;">
            <div id="liveExpProgress" class="exp-progress" style="width: 0%;"></div>
        </div>
    </div>
    
    <!-- 直播控制 -->
    <div style="margin-bottom: 20px; text-align: center;">
        <button id="startLiveBtn" onclick="startLiveStream()" style="background: #ff00ff; color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">开始直播</button>
        <button id="boostLiveBtn" onclick="boostLiveStream()" style="background: #2196F3; color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-left: 10px;">推广流量 (1000星币)</button>
        <button id="giftBoxBtn" onclick="openGiftBox()" style="background: linear-gradient(to right, #ff9966, #ff5e62); color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-left: 10px; box-shadow: 0 4px 8px rgba(255, 94, 98, 0.4);">盲盒宝箱</button>
    </div>
    
    <!-- 直播内容区域 -->
    <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
        <!-- 直播窗口 -->
        <div style="background: #000; border-radius: 8px; overflow: hidden; position: relative;">
           <!-- 在直播窗口添加弹幕容器 -->
<div id="liveStreamVideo" style="height: 300px; background: linear-gradient(to bottom, #1a1a2a, #0f0f23); position: relative; overflow: hidden;">
    <div id="liveStatus" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #aaa; text-align: center; z-index: 1;">
        直播未开始
    </div>
    <div id="danmakuContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none;"></div>
</div>

<!-- 在直播控制区域添加弹幕控制 -->
<div style="margin-top: 10px; display: flex; justify-content: space-between;">
    <div>
        <label>
            <input type="checkbox" id="danmakuToggle" checked> 显示弹幕
        </label>
        <label style="margin-left: 10px;">
            速度: <input type="range" id="danmakuSpeed" min="1" max="10" value="5">
        </label>
    </div>
    <div>
        <label>
            密度: <input type="range" id="danmakuDensity" min="1" max="10" value="3">
        </label>
    </div>
</div>
            <div style="padding: 10px; background: #1a1a2a;">
                <h3 style="margin: 0; color: #ff00ff;">我的直播间</h3>
                <div style="display: flex; align-items: center; margin-top: 5px;">
                    <span style="background: #f44336; color: white; padding: 2px 6px; border-radius: 3px; font-size: 12px; margin-right: 10px;">LIVE</span>
                    <span id="liveTopic">转生大陆冒险日记</span>
                </div>
            </div>
        </div>
        
        <!-- 观众列表 -->
        <div style="background: #1a1a2a; border-radius: 8px; padding: 15px;">
            <h3 style="color: #ff00ff; margin-top: 0;">在线观众</h3>
            <div id="viewerList" style="max-height: 320px; overflow-y: auto;">
                <div style="text-align: center; color: #666; padding: 20px 0;">暂无观众</div>
            </div>
        </div>
    </div>
    
    <!-- 弹幕区域 -->
    <div style="margin-top: 20px; background: #1a1a2a; border-radius: 8px; padding: 15px;">
        <h3 style="color: #ff00ff; margin-top: 0;">弹幕互动</h3>
        <div id="danmakuContainerq" style="height: 200px; overflow-y: auto; background: #0a0a1a; border-radius: 5px; padding: 10px; margin-bottom: 10px;">
            <div class="danmaku-message">欢迎来到直播间！发送消息与其他观众互动吧！</div>
        </div>
        <div style="display: flex;">
            <input type="text" id="danmakuInput" placeholder="发送弹幕..." style="flex: 1; padding: 8px; border: 1px solid #444; border-radius: 3px; background: #0a0a1a; color: white;">
            <button onclick="sendDanmaku()" style="background: #ff00ff; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer; margin-left: 10px;">发送</button>
        </div>
    </div>
    
    <!-- 打赏记录 -->
    <div style="margin-top: 20px; background: #1a1a2a; border-radius: 8px; padding: 15px;">
        <h3 style="color: #ff00ff; margin-top: 0;">打赏记录</h3>
        <div id="donationHistory" style="max-height: 150px; overflow-y: auto;">
            <div style="text-align: center; color: #666; padding: 20px 0;">暂无打赏记录</div>
        </div>
    </div>
</div>
<!-- 盲盒宝箱模态框 -->
<div id="giftBoxModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center;">
    <div style="background: #1a1a2a; border-radius: 15px; padding: 30px; width: 80%; max-width: 600px; text-align: center; border: 3px solid #ff9966; box-shadow: 0 0 30px rgba(255, 153, 102, 0.6);">
        <h2 style="color: #ff9966; margin-top: 0;">神秘盲盒宝箱</h2>
        <p style="color: #ccc;">花费 <span style="color: #2196F3; font-weight: bold;">500星币</span> 开启盲盒，有机会获得超值礼物！</p>
        
        <div id="giftBox" style="position: relative; width: 200px; height: 200px; margin: 20px auto; perspective: 1000px;">
            <div id="boxInner" style="position: relative; width: 100%; height: 100%; transform-style: preserve-3d; transition: transform 1s;">
                <div style="position: absolute; width: 100%; height: 100%; backface-visibility: hidden; background: linear-gradient(135deg, #ff9966, #ff5e62); border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 24px; color: white; font-weight: bold; box-shadow: 0 10px 20px rgba(0,0,0,0.3);">
                    <div style="text-align: center;">
                        <div style="font-size: 40px;">🎁</div>
                        <div>点击开启</div>
                    </div>
                </div>
                <div id="giftResult" style="position: absolute; width: 100%; height: 100%; backface-visibility: hidden; background: linear-gradient(135deg, #5c6bc0, #3949ab); border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 24px; color: white; font-weight: bold; transform: rotateY(180deg); flex-direction: column; padding: 20px; box-sizing: border-box;">
                    <div id="giftIcon" style="font-size: 50px; margin-bottom: 15px;">🎁</div>
                    <div id="giftName" style="font-size: 24px; margin-bottom: 10px;">未知礼物</div>
                    <div id="giftValue" style="font-size: 20px;">价值: 0 玫瑰花</div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 20px;">
            <button onclick="drawGift()" style="background: linear-gradient(to right, #ff9966, #ff5e62); color: white; border: none; padding: 10px 30px; border-radius: 30px; cursor: pointer; font-size: 18px; font-weight: bold; box-shadow: 0 4px 8px rgba(255, 94, 98, 0.4);">开启盲盒 (500✨)</button>
            <button onclick="closeGiftBox()" style="background: #555; color: white; border: none; padding: 10px 30px; border-radius: 30px; cursor: pointer; font-size: 18px; margin-left: 15px;">关闭</button>
        </div>
        
        <div style="margin-top: 30px; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px;">
            <h3 style="color: #ff9966; margin-top: 0;">奖品概率</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: left;">
                <div><span style="color: #4CAF50;">鲜花:</span> 70% (10,000)</div>
                <div><span style="color: #2196F3;">墨镜:</span> 19.889% (25,000)</div>
                <div><span style="color: #FFC107;">礼花筒:</span> 7% (50,000)</div>
                <div><span style="color: #E91E63;">比心兔兔:</span> 3% (100,000)</div>
                <div><span style="color: #9C27B0;">热气球:</span> 0.1% (520,000)</div>
                <div><span style="color: #FF5722;">跑车:</span> 0.01% (1,200,000)</div>
                <div><span style="color: #00BCD4;">嘉年华:</span> 0.001% (2,800,000)</div>
            </div>
        </div>
    </div>
</div>


















  <div id="worldBossUI">
        <button class="boss-close-button" onclick="toggleWorldBossUI()">×</button>
        <div class="boss-summon-count">
    召唤: <span id="bossSummonCount">1</span>/10
    <br>
    下次恢复: <span id="summonCountdown">00:00:00</span>
</div>
        <h3>世界BOSS系统</h3>
        
        <div class="boss-section">
            <div class="boss-section-title">BOSS状态</div>
            <div class="boss-name" id="bossName">未召唤BOSS</div>
            <div class="boss-world" id="bossWorld"></div>
            <div class="boss-stars" id="bossStars"></div>
            <div class="boss-health-bar" id="bossHealthBar">
                <div class="boss-health-fill" id="bossHealthFill"></div>
                <div class="boss-health-text" id="bossHealthText">0/0</div>
            </div>
            <div class="boss-time-left" id="bossTimeLeft">剩余: 未开始</div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">你的状态</div>
            <div class="boss-info">攻击: <span id="playerBossAttack">0</span></div>
            <div class="boss-info">连击: <span id="playerBossMultiAttack">0</span></div>
            <div class="boss-info">暴击: <span id="playerBossCritRate">0%</span></div>
            <div class="boss-info">爆伤: <span id="playerBossCritDamage">0%</span></div>
            <div class="boss-info">伤害: <span id="playerBossDamage">0</span></div>
            <div class="boss-info">当前排行: <span id="playerBossRank">未排名</span></div>
            <div style="text-align: center; margin-top: 8px;">
                <button class="boss-button" id="bossAttackButton" onclick="attackBoss()">攻击</button>
                <button class="boss-button" id="bossAutoAttackButton" onclick="toggleAutoAttackBoss()">自动</button>
                <button class="boss-button" id="bossSummonButton" onclick="summonBoss()">召唤</button>
            </div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">排行榜</div>
            <div class="boss-rankings" id="bossRankings">
                <div>尚未开始战斗</div>
            </div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">战斗记录</div>
            <div class="boss-battle-log" id="bossBattleLog"></div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">奖励</div>
            <div class="boss-rewards">
                <div class="boss-reward-tier">
                    <h4>第1名</h4>
                    <div>5神级宝石</div>
                    <div>30000转生币</div>
                </div>
                <div class="boss-reward-tier">
                    <h4>第2-10名</h4>
                    <div>5极品宝石</div>
                    <div>10000转生币</div>
                </div>
                <div class="boss-reward-tier">
                    <h4>第11-30名</h4>
                    <div>3高级宝石</div>
                    <div>5000转生币</div>
                </div>
                <div class="boss-reward-tier">
                    <h4>参与奖</h4>
                    <div>1初级宝石</div>
                    <div>100转生币</div>
                </div>
            </div>
        </div>
    </div>
    <div id="bossOverlay"></div>
<!-- 新增宝石商店模态框 -->
<div id="treasureShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #9C27B0; margin: 0;">藏宝图商店</h2>
        <button onclick="closeTreasureShop()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px; text-align: center; font-size: 18px;">
        当前宝藏金币: <span id="currentPrimaryGemqCount" style="color: #FFD700; font-weight: bold;">0</span>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
        <!-- 兑换选项1: 50玫瑰花 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #e91e63;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #e91e63;">玫瑰花束</h4>
                    <p style="margin: 0;">兑换50朵玫瑰花</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(1)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项2: VIP能力值 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">VIP能力值</h4>
                    <p style="margin: 0;">兑换10点VIP能力值</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(2)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项3: 鱼饵 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #4CAF50;">鱼饵</h4>
                    <p style="margin: 0;">兑换1个鱼饵</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(3)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项4: 伴侣钥匙 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #FF9800;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #FF9800;">伴侣钥匙</h4>
                    <p style="margin: 0;">兑换1把伴侣钥匙</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">2</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(4)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项5: 灵根检测器 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #9C27B0;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #9C27B0;">灵根检测器</h4>
                    <p style="margin: 0;">兑换1个灵根检测器</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">5</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(5)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项6: 血脉检测剂 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #673AB7;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #673AB7;">血脉检测剂</h4>
                    <p style="margin: 0;">兑换1个血脉检测剂</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">5</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(6)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项7: 进阶神石 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F44336;">进阶神石</h4>
                    <p style="margin: 0;">兑换1个进阶神石</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">20</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(7)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
  <!-- 兑换选项7: 宗门令牌 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F54336;">宗门令牌</h4>
                    <p style="margin: 0;">兑换1个宗门令牌</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">50</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(8)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- 宗门系统界面 -->
<div id="sectSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="sectSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #8B4513; border-radius: 10px; z-index: 1001; width: 850px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #8B4513; padding-bottom: 10px;">
        <h2 style="color: #8B4513; margin: 0;">宗门系统</h2>
        <button onclick="toggleSectSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 宗门信息区域 -->
    <div id="sectInfoContainer" style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <!-- 宗门信息将动态生成 -->
    </div>
    
    <!-- 标签页导航 -->
    <div class="sect-tabs" style="display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 1px solid #444;">
        <button class="sect-tablink active" onclick="openSectTab('members')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">成员管理</button>
        <button class="sect-tablink" onclick="openSectTab('missions')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">任务派遣</button>
        <button class="sect-tablink" onclick="openSectTab('techniques')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">功法库</button>
        <button class="sect-tablink" onclick="openSectTab('settings')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">宗门设置</button>
    </div>
    
    <!-- 成员管理标签页 -->
    <div id="sectMembers" class="sect-tabcontent">
        <div style="margin-bottom: 15px;">
            <button onclick="recruitMember()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">招募弟子</button>
            <span>消耗: <span id="recruitCost">100</span> 灵石</span>
        </div>
        <div id="memberList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; max-height: 300px; overflow-y: auto;">
            <!-- 成员卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 任务派遣标签页 -->
    <div id="sectMissions" class="sect-tabcontent" style="display:none;">
        <div id="missionList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
            <!-- 任务卡片将动态生成 -->
        </div>
        <div id="activeMissions" style="background: #333; padding: 15px; border-radius: 8px;">
            <h3 style="color: #8B4513; margin-top: 0;">进行中的任务</h3>
            <div id="activeMissionList">
                <!-- 进行中的任务将动态生成 -->
            </div>
        </div>
    </div>
    
    <!-- 功法库标签页 -->
    <div id="sectTechniques" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px;">
            <button onclick="upgradeAllTechniques()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">一键升级所有功法</button>
            <span>消耗: <span id="upgradeAllCost">1000</span> 灵石</span>
        </div>
        <div id="techniqueList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 300px; overflow-y: auto;">
            <!-- 功法卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 宗门设置标签页 -->
    <div id="sectSettings" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px;">
            <label for="sectNameInput">宗门名称:</label>
            <input type="text" id="sectNameInput" style="margin-left: 10px; padding: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 3px;">
            <button onclick="changeSectName()" style="background: #FF9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 10px;">修改名称</button>
        </div>
        <div style="margin-bottom: 15px;">
            <p>创建于: <span id="sectCreationDate">未创建</span></p>
            <p>宗门宗旨: <span id="sectMotto">自强不息，厚德载物</span></p>
        </div>
        <div>
            <button onclick="disbandSect()" style="background: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">解散宗门</button>
            <p style="color: #ff4444; font-size: 0.9em; margin-top: 5px;">警告: 解散宗门将失去所有成员和宗门等级！！！</p>
        </div>
    </div>
</div>
<!-- 兑换商店界面 -->
<div id="exchangeShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="exchangeShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 500px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">兑换商店</h2>
        <button onclick="toggleExchangeShop()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px;">
        <p>在这里可以将探索资源与对应的发票道具互相兑换（1:1比例）</p>
    </div>
    
    <!-- 星尘兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <h3 style="color: #cccccc; margin-top: 0;">星尘 ↔ 星尘发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前星尘: <span id="currentStardustExchange">0</span></span>
                <span style="margin-left: 15px;">星尘发票: <span id="currentStardustTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="stardustAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('stardust', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('stardust', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换星尘</button>
            </div>
        </div>
    </div>
    
    <!-- 暗物质兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <h3 style="color: #333366; margin-top: 0;">暗物质 ↔ 暗物质发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前暗物质: <span id="currentDarkMatterExchange">0</span></span>
                <span style="margin-left: 15px;">暗物质发票: <span id="currentDarkMatterTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="darkMatterAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('darkMatter', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('darkMatter', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换暗物质</button>
            </div>
        </div>
    </div>
    
    <!-- 宇宙晶体兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <h3 style="color: #66ccff; margin-top: 0;">宇宙晶体 ↔ 宇宙晶体发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前宇宙晶体: <span id="currentCosmicCrystalExchange">0</span></span>
                <span style="margin-left: 15px;">宇宙晶体发票: <span id="currentCosmicCrystalTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="cosmicCrystalAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('cosmicCrystal', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('cosmicCrystal', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换晶体</button>
            </div>
        </div>
    </div>
    
    <!-- 神器碎片兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #ffcc00; margin-top: 0;">神器碎片 ↔ 神器碎片发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前神器碎片: <span id="currentArtifactFragmentExchange">0</span></span>
                <span style="margin-left: 15px;">神器碎片发票: <span id="currentArtifactFragmentTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="artifactFragmentAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('artifactFragment', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('artifactFragment', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换碎片</button>
            </div>
        </div>
    </div>
</div>
<div id="autoBuySettings" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1000;">
    <h3>自动购买设置</h3>
    
    <div style="margin: 15px 0;">
        <label for="techniqueMaxCost">功法秘籍宝箱自动购买价格上限: </label>
        <input type="number" id="techniqueMaxCost" min="1" step="1">
        <button onclick="setTechniqueMaxCost()">设置</button>
    </div>
    
    <button onclick="toggleAutoBuySettings()" style="margin-top: 15px;">关闭</button>
</div>
<!-- 伴侣商店界面 -->
<div id="companionShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="companionShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #9C27B0; padding-bottom: 10px;">
        <h2 style="color: #9C27B0; margin: 0;">伴侣商店</h2>
        <button onclick="toggleCompanionShop()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 当前灵魂道具数量显示 -->
    <div style="margin-bottom: 20px; padding: 10px; background: #333; border-radius: 5px;">
        <h3 style="margin-top: 0;">当前灵魂道具数量</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
            <div>普通伴侣灵魂: <span id="soulCount1">0</span></div>
            <div>稀有伴侣灵魂: <span id="soulCount2">0</span></div>
            <div>史诗伴侣灵魂: <span id="soulCount3">0</span></div>
            <div>卓越伴侣灵魂: <span id="soulCount4">0</span></div>
            <div>完美伴侣灵魂: <span id="soulCount5">0</span></div>
            <div>神赐伴侣灵魂: <span id="soulCount6">0</span></div>
            <div>天使伴侣灵魂: <span id="soulCount7">0</span></div>
            <div>恶魔伴侣灵魂: <span id="soulCount8">0</span></div>
            <div>精灵伴侣灵魂: <span id="soulCount9">0</span></div>
        </div>
    </div>
    
    <!-- 兑换选项 -->
    <div>
        <h3>灵魂道具兑换</h3>
        
        <!-- 稀有伴侣灵魂兑换普通伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>稀有伴侣灵魂 → 普通伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">100个稀有伴侣灵魂兑换500个普通伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv2', 'banlv1', 100, 500)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换史诗伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 史诗伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">100个普通伴侣灵魂兑换1个史诗伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv3', 100, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换天使伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 天使伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">250个普通伴侣灵魂兑换1个天使伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv7', 250, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换恶魔伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 恶魔伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">220个普通伴侣灵魂兑换1个恶魔伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv8', 220, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换精灵伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 精灵伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">200个普通伴侣灵魂兑换1个精灵伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv9', 200, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换卓越伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 卓越伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">500个普通伴侣灵魂兑换1个卓越伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv4', 500, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换完美伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 完美伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">1000个普通伴侣灵魂兑换1个完美伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv5', 1000, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换神赐伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 神赐伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">5000个普通伴侣灵魂兑换1个神赐伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv6', 5000, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
    </div>
</div>
    <script>
        // 初始化玩家数据
    let player = {
    name: "勇者",
    gold: 0,
    diamond: 0,
    titanium: 0,
    starstone: 0,
    cosmicstone: 0,
    superstone: 0,
    otherworldstone: 0,
    xingjiestone: 0,
    hundunstone: 0,
    lingtone: 0,
    huangtone: 0,
    mingtone: 0,
    xutong: 0,
    shitone: 0,
    weitone: 0,
    reincarnationCoin: 0,
    reincarnationCount: 0,
    equipment: [],
    usedActivationCodes: [],
    class: null, // 当前职业: null, 'warrior', 'mage'
    classBranches: [], // 已选择的分支 [0, 2, 1] 表示第1排选第0个，第2排选第2个等
    classBonuses: { // 新增：存储职业分支选择的加成
    soulRingMultiplier: 1,    // 魂环总加成乘数（默认1倍）
    dungeonEquipMultiplier: 1 // 副本装备总加成乘数（默认1倍）
  },
  sect: {
            created: false,
            name: "",
            level: 0,
            exp: 0,
            spiritStones: 0,
            members: [],
            missions: [],
            techniques: {},
            creationTime: 0,
            maxMembers: 5
        },
   battle: {
    currentZone: null,
    currentMonster: null,
    monsterResurrections: 0,
},
  worldMapBattle: {
    autoBattle: false,
    autoBattleInterval: null
},
liveStream: {
            level: 1,
            exp: 0,
            totalEarnings: 1000,
            isLive: false,
            lastLiveStart: 0,
            totalLiveTime: 0,
            expMultiplier: 1,
            viewers: [],
            donationHistory: [],
           lastDanmaku: null
        },
level: {
    current: 1,
    exp: 0,
    nextLevelExp: 10000,
    clickBonus: 1,
    gpsBonus: 1,
    ascentionCount: 0, // 飞升次数
    ascentionMultiplier: 1 // 飞升加成倍数
},
cultivation: {
            stage: 0, // 当前阶段索引
            exp: 0,   // 当前经验值
            root: null, // 当前灵根
            bloodline: null,
           bonus: 1
        },
 artifacts: {
            fragments: 0,
            crystals: 0,
            inventory: [],
            equipped: {
                helmet: null,
                clothes: null,
                pants: null,
                shoes: null,
                necklace: null,
                weapon: null
            },
        advanceLevels: {}
        },
   mystery: {
        stage: 1,
        level: 1,
        exp: 0,
        bonus: 1, // 默认加成1倍
        lastUpdateTime: Date.now() // 添加这个字段
    },
    autoReincarnation: false, // 新增自动转生状态
    officialLevel: 0, // 官职等级，初始为0
    officialBonus: 1, // 初始加成1倍
    vip: {
        level: 1,
        power: 0 // 累计VIP能力值数量
    },
   companionExpedition: {
            currentExpedition: null,
            history: [],
            lastUpdate: Date.now()
        },
   bossBattleSnapshot: {
    playerAttack: 0,
    playerMultiAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
},
 backgroundBattle: {
    active: false,
    interval: null
},
treasure: {
        keys: 0, // 藏宝图钥匙数量
        maps: [], // 拥有的藏宝图
        currentBattle: null // 当前战斗信息
    },
 parking: {
    level: 1, // 停车位等级
    exp: 0, // 停车经验
    expToNextLevel: [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000, 10000000, 20000000, 50000000, 100000000, 200000000], // 每级所需经验
    parkingLots: [], // 停车位数组，每个元素是一个对象 { carId: 'car1', parkTime: 1234567890 }
    cars: [] // 拥有的车辆数组，每个元素是车辆ID
},
   companionChestGuarantee: {
    epic: 0,     // 史诗保底计数器
    pink: 0,     // 卓越保底计数器
    orange: 0,  // 完美保底计数器
    red: 0       // 神赐保底计数器
},
 fishing: {
    level: 1,
    currentExp: 0,
    fishCage: [],
    isFishing: false,
    isBiting: false,
    biteTimer: null,
    biteWindowTimer: null,
    biteTime: 0,
    bonus: 1,
    autoFishingEnabled: false,
    autoDecomposeFishEnabled: false

},

exploration: {
            speed: { level: 1, cost: 100 },
            capacity: { level: 1, cost: 100 },
            durability: { level: 1, cost: 100 },
            resources: {
                stardust: 0,
                darkMatter: 0,
                cosmicCrystal: 0,
                artifactFragment: 0
            },
            activeMission: null,
            missionEndTime: 0,
            logs: []
        },
tower: {
    currentFloor: 0,
    maxFloor: 0,
    isAutoAttacking: false,
    autoAttackInterval: null,
    battleLog: [],
    playerHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0,
    monster: null
},
gems: {
            red: {},   // {等级: 数量}
            blue: {},
            black: {},
            green: {},
            pink: {},
            yellow: {}
        },
        companions: [], // 伴侣列表
    equippedCompanionId: null, // 当前装备的伴侣ID
    companionLevel: 1, // 共享的伴侣等级
   autoDecompose: {
    enabled: false,
    belowRarity: 'white' // 默认分解普通及以下
},
    items: {
        primaryGem: 0,
        advancedGem: 0,
        superiorGem: 0,
        divineGem: 0,
        refineStone: 0,
        rose: 0, // 玫瑰花
        companionKey: 0, // 伴侣钥匙
        rebornDan: 0,
        baitCount: 0,
        rootDetector: 0,
        bloodlineDetector: 0,
        advanceStone: 0,
        primaryGemq: 0,
        zongmen: 0,
        roseq: 0,
        yuzhou1: 0,  
       yuzhou2: 0, 
      yuzhou3: 0, 
     yuzhou4: 0, 
    banlv1: 0, 
     banlv2: 0, 
    banlv3: 0, 
    banlv4: 0, 
    banlv5: 0, 
     banlv6: 0, 
    banlv7: 0,
   banlv8: 0,
   banlv9: 0
    },
  nightClub: {
    level: 1,
    exp: 0,
    starCoins: 0,
    staff: [
        { type: 'waiter', level: 1, expOutput: 0.5, coinsOutput: 0.2 },
        { type: 'guard', level: 1, expOutput: 0.3, coinsOutput: 0.1 },
        { type: 'dj', level: 1, expOutput: 1.0, coinsOutput: 0.5 },
        { type: 'chef', level: 1, expOutput: 0.4, coinsOutput: 0.3 },
        { type: 'hostess', level: 1, expOutput: 0.7, coinsOutput: 0.4 }
    ],
    equipment: [
        { type: 'sound', level: 1, bonus: 1.05 },
        { type: 'light', level: 1, bonus: 1.03 },
        { type: 'bar', level: 1, bonus: 1.02 },
        { type: 'dancefloor', level: 1, bonus: 1.04 }
    ],
    vip: {
        lastVisit: 0,
        nextVisit: 0
    },
    activeEvent: null,
    lastUpdate: Date.now()
},
    collections: {
        lightSpeedHand: 0,
        empHand: 0,
        godlyHand: 0,
        quickHand: 0,
        shadowHand: 0,
        quantumHand: 0,
        lightningHand: 0,
        divineHand: 0
    },
    pets: {
        thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
        chaosTaotie: { level: 0, cost: 1, multiplier: 0.50 },
        netherQiongqi: { level: 0, cost: 1, multiplier: 2.50 },
        abyssKun: { level: 0, cost: 1, multiplier: 12.50 },
        primordialZhuLong: { level: 0, cost: 1, multiplier: 62.50 },
        wanJunSuanNi: { level: 0, cost: 1, multiplier: 312.50 },
         yanYuBiAn: { level: 0, cost: 1, multiplier: 1562.50 },
        yuyu1: { level: 0, cost: 1, multiplier: 7812.50 },
         yuyu2: { level: 0, cost: 1, multiplier: 39062.50 },   
              yuyu3: { level: 0, cost: 1, multiplier: 195312.50 },
         yuyu4: { level: 0, cost: 1, multiplier: 976562.50 },
              yuyu5: { level: 0, cost: 1, multiplier: 5882812.50 },
              yuyu6: { level: 0, cost: 1, multiplier: 29414062.50 },
         yuyu7: { level: 0, cost: 1, multiplier: 147070312.50 },
              yuyu8: { level: 0, cost: 1, multiplier: 735351562.50 }   
    },
    dungeonEquipment: [],
     techniques: {}, 
            soulRings: [], 
            attributes: {
              totalPoints: 0,
               remainingPoints: 0,
                health: 0,
            attack: 0,
             critRate: 0,
              critDamage: 0,
             multiAttack: 0,
           block: 0
            },
      farm: {
    level: 1,
    exp: 0,
    expToNextLevel: 100,
    fields: [],
    maxFields: 2,
    seeds: {},
    water: 10,
    lastUpdate: Date.now(),
    autoPlant: false,    // 新增自动种植设置
    autoHarvest: false
},
            lastUpdate: Date.now(),
            achievements: {
    "first_equipment": false,
    "first_rare": false,
    "first_epic": false,
    "first_legendary": false,
    "first_ancient": false,
    "first_divine": false,
    "first_arcane": false,
    "first_celestial": false,
    "first_infernal": false,
    "first_astral": false,
    "first_primeval": false,
    "first_transcendental": false,
    "first_quantum": false,
    "first_ultimate": false,
    "first_chaos": false,
    "first_eternal": false,
    "first_void": false,
    "first_genesis": false,
    "first_divineRealm": false,
    "first_apocalypse": false,
    "first_yeyu1": false,
    "first_yeyu2": false,
    "first_yeyu3": false,
    "first_yeyu4": false,
    "first_yeyu5": false,
    "first_yeyu6": false,
    "first_yeyu7": false,
    "first_yeyu8": false,
    "first_yeyu9": false,
    "first_yeyu10": false,
    "first_yeyu11": false,
    "first_yeyu12": false,
    "first_yeyu13": false,
    "first_yeyu14": false,
    "first_yeyu15": false,
    "first_yeyu16": false,
    "first_yeyu17": false,
    "first_yeyu18": false,
    "first_yeyu19": false,
    "first_yeyu20": false,
    "first_yeyu21": false,
    "first_yeyu22": false,
    "first_yeyu23": false,
    "first_yeyu24": false,
    "common_chest_100": false,
    "common_chest_10000": false,
    "common_chest_1000000": false,
    "common_chest_10000000": false,
    "common_chest_100000000": false,
    "advanced_chest_100": false,
    "advanced_chest_10000": false,
    "advanced_chest_1000000": false,
    "advanced_chest_10000000": false,
    "advanced_chest_100000000": false,
    "rare_chest_100": false,
    "rare_chest_10000": false,
    "rare_chest_1000000": false,
    "rare_chest_10000000": false,
    "rare_chest_100000000": false,
    "epic_chest_100": false,
    "epic_chest_10000": false,
    "epic_chest_1000000": false,
    "epic_chest_10000000": false,
    "epic_chest_100000000": false,
    "legendary_chest_100": false,
    "legendary_chest_10000": false,
    "legendary_chest_1000000": false,
    "legendary_chest_10000000": false,
    "legendary_chest_100000000": false,
    "chaos_chest_100": false,
    "chaos_chest_10000": false,
    "chaos_chest_1000000": false,
    "chaos_chest_10000000": false,
    "chaos_chest_100000000": false,
    "apocalypse_chest_100": false,
    "apocalypse_chest_10000": false,
    "apocalypse_chest_1000000": false,
    "apocalypse_chest_10000000": false,
    "apocalypse_chest_100000000": false,
    "yeyu1_chest_100": false,
    "yeyu1_chest_10000": false,
    "yeyu1_chest_1000000": false,
    "yeyu1_chest_10000000": false,
    "yeyu1_chest_100000000": false,
    "yeyu2_chest_100": false,
    "yeyu2_chest_10000": false,
    "yeyu2_chest_1000000": false,
    "yeyu2_chest_10000000": false,
    "yeyu2_chest_100000000": false,
    "yeyu3_chest_100": false,
    "yeyu3_chest_10000": false,
    "yeyu3_chest_1000000": false,
    "yeyu3_chest_10000000": false,
    "yeyu3_chest_100000000": false,
    "yeyu4_chest_100": false,
    "yeyu4_chest_10000": false,
    "yeyu4_chest_1000000": false,
    "yeyu4_chest_10000000": false,
    "yeyu4_chest_100000000": false,
    "yeyu5_chest_100": false,
    "yeyu5_chest_10000": false,
    "yeyu5_chest_1000000": false,
    "yeyu5_chest_10000000": false,
    "yeyu5_chest_100000000": false,
    "yeyu6_chest_100": false,
    "yeyu6_chest_10000": false,
    "yeyu6_chest_1000000": false,
    "yeyu6_chest_10000000": false,
    "yeyu6_chest_100000000": false,
    "yeyu7_chest_100": false,
    "yeyu7_chest_10000": false,
    "yeyu7_chest_1000000": false,
    "yeyu7_chest_10000000": false,
    "yeyu7_chest_100000000": false,
    "yeyu8_chest_100": false,
    "yeyu8_chest_10000": false,
    "yeyu8_chest_1000000": false,
    "yeyu8_chest_10000000": false,
    "yeyu8_chest_100000000": false,
    "max_stage_10": false,
    "max_stage_30": false,
    "max_stage_60": false,
    "max_stage_90": false,
    "max_stage_120": false,
    "max_stage_200": false,
    "max_stage_300": false,
    "max_stage_400": false,
    "max_stage_500": false,
    "max_stage_600": false,
    "max_stage_700": false,
    "max_stage_800": false,
    "max_stage_900": false,
    "max_stage_1000": false,

    // 新增宠物成就状态
    "thunderKirin_10": false,
    "thunderKirin_50": false,
    "thunderKirin_100": false,
    "chaosTaotie_10": false,
    "chaosTaotie_50": false,
    "chaosTaotie_100": false,
    "netherQiongqi_10": false,
    "netherQiongqi_50": false,
    "netherQiongqi_100": false,
    "abyssKun_10": false,
    "abyssKun_50": false,
    "abyssKun_100": false,
    "primordialZhuLong_10": false,
    "primordialZhuLong_50": false,
    "primordialZhuLong_100": false,
    "wanJunSuanNi_10": false,
    "wanJunSuanNi_50": false,
    "wanJunSuanNi_100": false,
    "yanYuBiAn_10": false,
    "yanYuBiAn_50": false,
    "yanYuBiAn_100": false,
    "yuyu1_10": false,
    "yuyu1_50": false,
    "yuyu1_100": false,
    "yuyu2_10": false,
    "yuyu2_50": false,
    "yuyu2_100": false,
    "yuyu3_10": false,
    "yuyu3_50": false,
    "yuyu3_100": false,
    "yuyu4_10": false,
    "yuyu4_50": false,
    "yuyu4_100": false,
    "yuyu5_10": false,
    "yuyu5_50": false,
    "yuyu5_100": false,
    "yuyu6_10": false,
    "yuyu6_50": false,
    "yuyu6_100": false,
    "yuyu7_10": false,
    "yuyu7_50": false,
    "yuyu7_100": false,
    "yuyu8_10": false,
    "yuyu8_50": false,
    "yuyu8_100": false,

    // 新增魂环成就状态
    "year1_10": false,
    "year10_10": false,
    "year100_10": false,
    "year1000_10": false,
    "year10000_10": false,
    "year100000_10": false,
    "year1000000_10": false,
    "year10000000_10": false,
    "year100000000_10": false,
    "year1_100": false,
    "year10_100": false,
    "year100_100": false,
    "year1000_100": false,
    "year10000_100": false,
    "year100000_100": false,
    "year1000000_100": false,
    "year10000000_100": false,
    "year100000000_100": false,
    "year1_1000": false,
    "year10_1000": false,
    "year100_1000": false,
    "year1000_1000": false,
    "year10000_1000": false,
    "year100000_1000": false,
    "year1000000_1000": false,
    "year10000000_1000": false,
    "year100000000_1000": false,
    "year1_10000": false,
    "year10_10000": false,
    "year100_10000": false,
    "year1000_10000": false,
    "year10000_10000": false,
    "year100000_10000": false,
    "year1000000_10000": false,
    "year10000000_10000": false,
    "year100000000_10000": false,
    "year2_10": false,
    "year2_100": false,
    "year2_1000": false,
    "year2_10000": false,
    "year3_10": false,
    "year3_100": false,
    "year3_1000": false,
    "year3_10000": false,
    "year4_10": false,
    "year4_100": false,
    "year4_1000": false,
    "year4_10000": false,
    "year5_10": false,
    "year5_100": false,
    "year5_1000": false,
    "year5_10000": false,
    "year6_10": false,
    "year6_100": false,
    "year6_1000": false,
    "year6_10000": false,
    "year7_10": false,
    "year7_100": false,
    "year7_1000": false,
    "year7_10000": false,
    "year8_10": false,
    "year8_100": false,
    "year8_1000": false,
    "year8_10000": false,
    "year9_10": false,
    "year9_100": false,
    "year9_1000": false,
    "year9_10000": false,
    "year11_10": false,
    "year11_100": false,
    "year11_1000": false,
    "year11_10000": false,
    "year12_10": false,
    "year12_100": false,
    "year12_1000": false,
    "year12_10000": false,
    "year13_10": false,
    "year13_100": false,
    "year13_1000": false,
    "year13_10000": false,
    "year14_10": false,
    "year14_100": false,
    "year14_1000": false,
    "year14_10000": false,
    "year15_10": false,
    "year15_100": false,
    "year15_1000": false,
    "year15_10000": false,
    "year16_10": false,
    "year16_100": false,
    "year16_1000": false,
    "year16_10000": false,
    "year17_10": false,
    "year17_100": false,
    "year17_1000": false,
    "year17_10000": false,
    "year18_10": false,
    "year18_100": false,
    "year18_1000": false,
    "year18_10000": false,
    "year19_10": false,
    "year19_100": false,
    "year19_1000": false,
    "year19_10000": false,
    "year20_10": false,
    "year20_100": false,
    "year20_1000": false,
    "year20_10000": false,
    "year21_10": false,
    "year21_100": false,
    "year21_1000": false,
    "year21_10000": false,
    "year22_10": false,
    "year22_100": false,
    "year22_1000": false,
    "year22_10000": false,
    "year23_10": false,
    "year23_100": false,
    "year23_1000": false,
    "year23_10000": false,
    "year24_10": false,
    "year24_100": false,
    "year24_1000": false,
    "year24_10000": false,
    "year25_10": false,
    "year25_100": false,
    "year25_1000": false,
    "year25_10000": false,
    "year26_10": false,
    "year26_100": false,
    "year26_1000": false,
    "year26_10000": false,
    "year27_10": false,
    "year27_100": false,
    "year27_1000": false,
    "year27_10000": false,
    "year28_10": false,
    "year28_100": false,
    "year28_1000": false,
    "year28_10000": false,
    "year29_10": false,
    "year29_100": false,
    "year29_1000": false,
    "year29_10000": false,
    "year30_10": false,
    "year30_100": false,
    "year30_1000": false,
    "year30_10000": false,
    "year31_10": false,
    "year31_100": false,
    "year31_1000": false,
    "year31_10000": false,
    "year32_10": false,
    "year32_100": false,
    "year32_1000": false,
    "year32_10000": false,
    "year33_10": false,
    "year33_100": false,
    "year33_1000": false,
    "year33_10000": false,
    "year34_10": false,
    "year34_100": false,
    "year34_1000": false,
    "year34_10000": false,
    "year35_10": false,
    "year35_100": false,
    "year35_1000": false,
    "year35_10000": false,
    "year36_10": false,
    "year36_100": false,
    "year36_1000": false,
    "year36_10000": false,
    "year37_10": false,
    "year37_100": false,
    "year37_1000": false,
    "year37_10000": false,
    "world_boss_1st": false,
    "world_boss_top5": false,
    "world_boss_top10": false,
    "world_boss_participant": false,
    "reincarnation_10": false,
    "reincarnation_100": false,
    "reincarnation_1000": false,
    "reincarnation_10000": false
      },
            actionLogs: [], 
            goldLogs: [],
            autoBuy: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], 
            autoBuySpeedBoost: false,
            onlineBoostEnabled: false,
            autoBuyMaterialChest: false, 
            autoBuyTechniqueChest: false, 
            autoBuyTechniqueMaxCost: 1e9,
            gpsMultiplier: 1, 
            clickMultiplier: 1,
            autoConvert: false,
            autoConvertCurrency: { 
                gold: false,
                diamond: false,
                titanium: false,
                starstone: false
            },
            clickTimestamps: [], 
            chestCounts: { 
                common: 0,
                advanced: 0,
                rare: 0,
                epic: 0,
                legendary: 0
            },
            reincarnationStats: { 
                gpsBonus: { level: 0, cost: 1 },
                equipmentLevelBonus: { level: 0, cost: 1 },
                clickLimitBonus: { level: 0, cost: 1 }
            },
            materialChestCost: 1,
            techniqueChestCost: 1,
            stockData: { 
                stocks: [
                    { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                    { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                    { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                    { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                    { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
                ],
                lastStockUpdate: Date.now()
            },
     fundData: {
    funds: [
        { name: "稳健型基金", netValue: 1.00, maxInvestment: 100000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "平衡型基金", netValue: 1.00, maxInvestment: 1000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "成长型基金", netValue: 1.00, maxInvestment: 100000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "进取型基金", netValue: 1.00, maxInvestment: 1e15, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "激进型基金", netValue: 1.00, maxInvestment: 1e30, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "风险型基金", netValue: 1.00, maxInvestment: 1e50, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 }
    ],
    lastFundUpdate: Date.now()
},
            lotteryResults: [],
            traditionalLotteryNumbers: [],
         traditionalLotteryPurchased: false,
          traditionalLotteryBought: false,
         traditionalLotteryDrawTime: 0,
            lastLotteryDraw: Date.now(),
           titles: {
        unlocked: [], // 已解锁称号列表
        current: null // 当前选择的称号
    },
            bank: { 
                deposit: 0, 
                lastInterestUpdate: Date.now() 
            },
         parking: {
            level: 1,
            exp: 0,
            maxSpots: 1,
            vehicles: [],
            parkedVehicles: [],
            lastUpdate: Date.now(),
            totalIncome: 0
        },
            battle: {
                currentStage: 0,
        maxStage: 0,
        monster: null,
        playerHealth: 0,
        playerAttack: 0,
        playerCritRate: 0.1,
        playerCritDamage: 1.5,
        playerAccuracy: 0.9,
        playerDodge: 0.1,
        autoSweepEnabled: false  
    }
};
        // 成就奖励配置
        const achievementRewards = {
    "common": { gpsMultiplier: 0.15, description: "获得普通装备，GPS +15%" },
    "rare": { gpsMultiplier: 0.30, description: "获得稀有装备，GPS +30%" },
    "epic": { gpsMultiplier: 0.45, description: "获得史诗装备，GPS +45%" },
    "legendary": { gpsMultiplier: 0.60, description: "获得传说装备，GPS +60%" },
    "ancient": { gpsMultiplier: 0.75, description: "获得远古装备，GPS +75%" },
    "divine": { gpsMultiplier: 0.90, description: "获得神圣装备，GPS +90%" },
    "arcane": { gpsMultiplier: 1.05, description: "获得奥术装备，GPS +105%" },
    "celestial": { gpsMultiplier: 1.30, description: "获得天空装备，GPS +130%" },
    "infernal": { gpsMultiplier: 1.45, description: "获得地狱装备，GPS +145%" },
    "astral": { gpsMultiplier: 1.60, description: "获得星界装备，GPS +160%" },
    "primeval": { gpsMultiplier: 1.75, description: "获得原初装备，GPS +175%" },
    "transcendental": { gpsMultiplier: 1.90, description: "获得超凡装备，GPS +190%" },
    "quantum": { gpsMultiplier: 2.05, description: "获得量子装备，GPS +205%" },
    "ultimate": { gpsMultiplier: 2.20, description: "获得究极装备，GPS +220%" },
    "chaos": { gpsMultiplier: 2.35, description: "获得混沌装备，GPS +235%" },
    "eternal": { gpsMultiplier: 2.50, description: "获得永恒装备，GPS +250%" },
    "void": { gpsMultiplier: 2.70, description: "获得虚无装备，GPS +270%" },
    "genesis": { gpsMultiplier: 2.80, description: "获得创世装备，GPS +280%" },
    "divineRealm": { gpsMultiplier: 2.90, description: "获得神域装备，GPS +290%" },
    "apocalypse": { gpsMultiplier: 3.00, description: "获得终焉装备，GPS +300%" },
    "yeyu1": { gpsMultiplier: 3.10, description: "获得星辰装备，GPS +310%" },
    "yeyu2": { gpsMultiplier: 3.20, description: "获得起源装备，GPS +320%" },
    "yeyu3": { gpsMultiplier: 3.30, description: "获得时光装备，GPS +330%" },
    "yeyu4": { gpsMultiplier: 3.40, description: "获得造物装备，GPS +340%" },
    "yeyu5": { gpsMultiplier: 3.50, description: "获得银河装备，GPS +350%" },
    "yeyu6": { gpsMultiplier: 3.60, description: "获得天界装备，GPS +360%" },
    "yeyu7": { gpsMultiplier: 3.70, description: "获得星云装备，GPS +370%" },
    "yeyu8": { gpsMultiplier: 3.80, description: "获得星河装备，GPS +380%" },
    "yeyu9": { gpsMultiplier: 3.90, description: "获得纪元装备，GPS +390%" },
    "yeyu10": { gpsMultiplier: 4.00, description: "获得鸿蒙装备，GPS +400%" },
    "yeyu11": { gpsMultiplier: 4.10, description: "获得星穹装备，GPS +410%" },
    "yeyu12": { gpsMultiplier: 4.20, description: "获得亘古装备，GPS +420%" },
    "yeyu13": { gpsMultiplier: 4.30, description: "获得万象装备，GPS +430%" },
    "yeyu14": { gpsMultiplier: 4.40, description: "获得太虚装备，GPS +440%" },
    "yeyu15": { gpsMultiplier: 4.50, description: "获得九垓装备，GPS +450%" },
    "yeyu16": { gpsMultiplier: 4.60, description: "获得穿梭装备，GPS +460%" },
    "yeyu17": { gpsMultiplier: 4.70, description: "获得恒古装备，GPS +470%" },
    "yeyu18": { gpsMultiplier: 4.80, description: "获得虚空装备，GPS +480%" },    
     "yeyu19": { gpsMultiplier: 4.90, description: "获得蔚来装备，GPS +490%" },
    "yeyu20": { gpsMultiplier: 5.00, description: "获得神罚装备，GPS +500%" },
    "yeyu21": { gpsMultiplier: 5.10, description: "获得时空装备，GPS +510%" },    
    "yeyu22": { gpsMultiplier: 5.20, description: "获得未来装备，GPS +520%" },
    "yeyu23": { gpsMultiplier: 5.30, description: "获得从前装备，GPS +530%" },
    "yeyu24": { gpsMultiplier: 5.40, description: "获得星澜装备，GPS +540%" },    
    // 新增成就奖励
    "common_chest_100": { gpsMultiplier: 0.10, description: "购买普通宝箱总数达到100个，GPS +10%" },
    "common_chest_10000": { gpsMultiplier: 0.20, description: "购买普通宝箱总数达到1万个，GPS +20%" },
    "common_chest_1000000": { gpsMultiplier: 0.40, description: "购买普通宝箱总数达到100万个，GPS +40%" },
    "common_chest_10000000": { gpsMultiplier: 0.80, description: "购买普通宝箱总数达到1000万个，GPS +80%" },
    "common_chest_100000000": { gpsMultiplier: 1.00, description: "购买普通宝箱总数达到1亿个，GPS +100%" },
    "advanced_chest_100": { gpsMultiplier: 0.20, description: "购买高级宝箱总数达到100个，GPS +20%" },
    "advanced_chest_10000": { gpsMultiplier: 0.40, description: "购买高级宝箱总数达到1万个，GPS +40%" },
    "advanced_chest_1000000": { gpsMultiplier: 0.70, description: "购买高级宝箱总数达到100万个，GPS +70%" },
    "advanced_chest_10000000": { gpsMultiplier: 1.20, description: "购买高级宝箱总数达到1000万个，GPS +120%" },
    "advanced_chest_100000000": { gpsMultiplier: 1.70, description: "购买高级宝箱总数达到1亿个，GPS +170%" },
    "rare_chest_100": { gpsMultiplier: 0.30, description: "购买稀有宝箱总数达到100个，GPS +30%" },
    "rare_chest_10000": { gpsMultiplier: 0.60, description: "购买稀有宝箱总数达到1万个，GPS +60%" },
    "rare_chest_1000000": { gpsMultiplier: 1.00, description: "购买稀有宝箱总数达到100万个，GPS +100%" },
    "rare_chest_10000000": { gpsMultiplier: 1.60, description: "购买稀有宝箱总数达到1000万个，GPS +160%" },
    "rare_chest_100000000": { gpsMultiplier: 2.40, description: "购买稀有宝箱总数达到1亿个，GPS +240%" },
    "epic_chest_100": { gpsMultiplier: 0.40, description: "购买史诗宝箱总数达到100个，GPS +40%" },
    "epic_chest_10000": { gpsMultiplier: 0.80, description: "购买史诗宝箱总数达到1万个，GPS +80%" },
    "epic_chest_1000000": { gpsMultiplier: 1.30, description: "购买史诗宝箱总数达到100万个，GPS +130%" },
    "epic_chest_10000000": { gpsMultiplier: 2.00, description: "购买史诗宝箱总数达到1000万个，GPS +200%" },
    "epic_chest_100000000": { gpsMultiplier: 3.10, description: "购买史诗宝箱总数达到1亿个，GPS +310%" },
    "legendary_chest_100": { gpsMultiplier: 0.50, description: "购买传说宝箱总数达到100个，GPS +50%" },
    "legendary_chest_10000": { gpsMultiplier: 1.00, description: "购买传说宝箱总数达到1万个，GPS +100%" },
    "legendary_chest_1000000": { gpsMultiplier: 1.60, description: "购买传说宝箱总数达到100万个，GPS +160%" },
    "legendary_chest_10000000": { gpsMultiplier: 2.40, description: "购买传说宝箱总数达到1000万个，GPS +240%" },
    "legendary_chest_100000000": { gpsMultiplier: 3.80, description: "购买传说宝箱总数达到1亿个，GPS +380%" },
    "chaos_chest_100": { gpsMultiplier: 0.60, description: "购买混沌宝箱总数达到100个，GPS +60%" },
    "chaos_chest_10000": { gpsMultiplier: 1.20, description: "购买混沌宝箱总数达到1万个，GPS +120%" },
    "chaos_chest_1000000": { gpsMultiplier: 1.90, description: "购买混沌宝箱总数达到100万个，GPS +190%" },
    "chaos_chest_10000000": { gpsMultiplier: 2.80, description: "购买混沌宝箱总数达到1000万个，GPS +280%" },
    "chaos_chest_100000000": { gpsMultiplier: 4.50, description: "购买混沌宝箱总数达到1亿个，GPS +450%" },
    "apocalypse_chest_100": { gpsMultiplier: 0.70, description: "购买终焉宝箱总数达到100个，GPS +70%" },
    "apocalypse_chest_10000": { gpsMultiplier: 1.40, description: "购买终焉宝箱总数达到1万个，GPS +140%" },
    "apocalypse_chest_1000000": { gpsMultiplier: 2.20, description: "购买终焉宝箱总数达到100万个，GPS +220%" },
    "apocalypse_chest_10000000": { gpsMultiplier: 3.20, description: "购买终焉宝箱总数达到1000万个，GPS +320%" },
    "apocalypse_chest_100000000": { gpsMultiplier: 5.20, description: "购买终焉宝箱总数达到1亿个，GPS +520%" },
    "yeyu1_chest_100": { gpsMultiplier: 0.80, description: "购买星辰宝箱总数达到100个，GPS +80%" },
    "yeyu1_chest_10000": { gpsMultiplier: 1.50, description: "购买星辰宝箱总数达到1万个，GPS +150%" },
    "yeyu1_chest_1000000": { gpsMultiplier: 2.30, description: "购买星辰宝箱总数达到100万个，GPS +230%" },
    "yeyu1_chest_10000000": { gpsMultiplier: 3.30, description: "购买星辰宝箱总数达到1000万个，GPS +330%" },
    "yeyu1_chest_100000000": { gpsMultiplier: 5.30, description: "购买星辰宝箱总数达到1亿个，GPS +530%" },
    "yeyu2_chest_100": { gpsMultiplier: 0.90, description: "购买银河宝箱总数达到100个，GPS +90%" },
    "yeyu2_chest_10000": { gpsMultiplier: 1.60, description: "购买银河宝箱总数达到1万个，GPS +160%" },
    "yeyu2_chest_1000000": { gpsMultiplier: 2.40, description: "购买银河宝箱总数达到100万个，GPS +240%" },
    "yeyu2_chest_10000000": { gpsMultiplier: 3.40, description: "购买银河宝箱总数达到1000万个，GPS +340%" },
    "yeyu2_chest_100000000": { gpsMultiplier: 5.40, description: "购买银河宝箱总数达到1亿个，GPS +540%" },
        "yeyu3_chest_100": { gpsMultiplier: 1.00, description: "购买星云宝箱总数达到100个，GPS +100%" },
    "yeyu3_chest_10000": { gpsMultiplier: 1.70, description: "购买星云宝箱总数达到1万个，GPS +170%" },
    "yeyu3_chest_1000000": { gpsMultiplier: 2.50, description: "购买星云宝箱总数达到100万个，GPS +250%" },
    "yeyu3_chest_10000000": { gpsMultiplier: 3.50, description: "购买星云宝箱总数达到1000万个，GPS +350%" },
    "yeyu3_chest_100000000": { gpsMultiplier: 5.50, description: "购买星云宝箱总数达到1亿个，GPS +550%" },
        "yeyu4_chest_100": { gpsMultiplier: 1.10, description: "购买鸿蒙宝箱总数达到100个，GPS +110%" },
    "yeyu4_chest_10000": { gpsMultiplier: 1.80, description: "购买鸿蒙宝箱总数达到1万个，GPS +180%" },
    "yeyu4_chest_1000000": { gpsMultiplier: 2.60, description: "购买鸿蒙宝箱总数达到100万个，GPS +260%" },
    "yeyu4_chest_10000000": { gpsMultiplier: 3.60, description: "购买鸿蒙宝箱总数达到1000万个，GPS +360%" },
    "yeyu4_chest_100000000": { gpsMultiplier: 5.60, description: "购买鸿蒙宝箱总数达到1亿个，GPS +560%" },
        "yeyu5_chest_100": { gpsMultiplier: 1.20, description: "购买太虚宝箱总数达到100个，GPS +120%" },
    "yeyu5_chest_10000": { gpsMultiplier: 1.90, description: "购买太虚宝箱总数达到1万个，GPS +190%" },
    "yeyu5_chest_1000000": { gpsMultiplier: 2.70, description: "购买太虚宝箱总数达到100万个，GPS +270%" },
    "yeyu5_chest_10000000": { gpsMultiplier: 3.70, description: "购买太虚宝箱总数达到1000万个，GPS +370%" },
    "yeyu5_chest_100000000": { gpsMultiplier: 5.70, description: "购买太虚宝箱总数达到1亿个，GPS +570%" },
       "yeyu6_chest_100": { gpsMultiplier: 1.30, description: "购买星云宝箱总数达到100个，GPS +130%" },
    "yeyu6_chest_10000": { gpsMultiplier: 2.00, description: "购买星云宝箱总数达到1万个，GPS +200%" },
    "yeyu6_chest_1000000": { gpsMultiplier: 2.80, description: "购买星云宝箱总数达到100万个，GPS +280%" },
    "yeyu6_chest_10000000": { gpsMultiplier: 3.70, description: "购买星云宝箱总数达到1000万个，GPS +370%" },
    "yeyu6_chest_100000000": { gpsMultiplier: 5.70, description: "购买星云宝箱总数达到1亿个，GPS +570%" },
    "yeyu7_chest_100": { gpsMultiplier: 1.40, description: "购买鸿蒙宝箱总数达到100个，GPS +140%" },
    "yeyu7_chest_10000": { gpsMultiplier: 2.10, description: "购买鸿蒙宝箱总数达到1万个，GPS +210%" },
    "yeyu7_chest_1000000": { gpsMultiplier: 2.90, description: "购买鸿蒙宝箱总数达到100万个，GPS +290%" },
    "yeyu7_chest_10000000": { gpsMultiplier: 3.80, description: "购买鸿蒙宝箱总数达到1000万个，GPS +380%" },
    "yeyu7_chest_100000000": { gpsMultiplier: 5.80, description: "购买鸿蒙宝箱总数达到1亿个，GPS +580%" },
    "yeyu8_chest_100": { gpsMultiplier: 1.50, description: "购买太虚宝箱总数达到100个，GPS +120%" },
    "yeyu8_chest_10000": { gpsMultiplier: 2.20, description: "购买太虚宝箱总数达到1万个，GPS +220%" },
    "yeyu8_chest_1000000": { gpsMultiplier: 3.00, description: "购买太虚宝箱总数达到100万个，GPS +300%" },
    "yeyu8_chest_10000000": { gpsMultiplier: 3.90, description: "购买太虚宝箱总数达到1000万个，GPS +390%" },
    "yeyu8_chest_100000000": { gpsMultiplier: 5.90, description: "购买太虚宝箱总数达到1亿个，GPS +590%" },
    "max_stage_10": { gpsMultiplier: 0.20, description: "达到最大关卡10，GPS +20%" },
    "max_stage_30": { gpsMultiplier: 0.50, description: "达到最大关卡30，GPS +50%" },
    "max_stage_60": { gpsMultiplier: 0.80, description: "达到最大关卡60，GPS +80%" },
    "max_stage_90": { gpsMultiplier: 1.20, description: "达到最大关卡90，GPS +120%" },
    "max_stage_120": { gpsMultiplier: 1.50, description: "达到最大关卡120，GPS +150%" },
    "max_stage_200": { gpsMultiplier: 1.80, description: "达到最大关卡200，GPS +180%" },
    "max_stage_300": { gpsMultiplier: 2.10, description: "达到最大关卡300，GPS +210%" },
    "max_stage_400": { gpsMultiplier: 2.40, description: "达到最大关卡400，GPS +240%" },
    "max_stage_500": { gpsMultiplier: 2.70, description: "达到最大关卡500，GPS +270%" },
    "max_stage_600": { gpsMultiplier: 3.00, description: "达到最大关卡600，GPS +300%" },
    "max_stage_700": { gpsMultiplier: 3.30, description: "达到最大关卡700，GPS +330%" },
    "max_stage_800": { gpsMultiplier: 3.60, description: "达到最大关卡800，GPS +360%" },
    "max_stage_900": { gpsMultiplier: 3.90, description: "达到最大关卡900，GPS +390%" },
    "max_stage_1000": { gpsMultiplier: 4.10, description: "达到最大关卡1000，GPS +410%" },

    // 新增宠物成就
    "thunderKirin_10": { gpsMultiplier: 0.10, description: "苍雷麒麟达到10级，GPS +10%" },
    "thunderKirin_50": { gpsMultiplier: 0.30, description: "苍雷麒麟达到50级，GPS +30%" },
    "thunderKirin_100": { gpsMultiplier: 1.00, description: "苍雷麒麟达到100级，GPS +100%" },
    "chaosTaotie_10": { gpsMultiplier: 0.20, description: "混沌饕餮达到10级，GPS +20%" },
    "chaosTaotie_50": { gpsMultiplier: 0.40, description: "混沌饕餮达到50级，GPS +40%" },
    "chaosTaotie_100": { gpsMultiplier: 1.20, description: "混沌饕餮达到100级，GPS +120%" },
    "netherQiongqi_10": { gpsMultiplier: 0.20, description: "九幽穷奇达到10级，GPS +20%" },
    "netherQiongqi_50": { gpsMultiplier: 0.50, description: "九幽穷奇达到50级，GPS +50%" },
    "netherQiongqi_100": { gpsMultiplier: 1.50, description: "九幽穷奇达到100级，GPS +150%" },
    "abyssKun_10": { gpsMultiplier: 0.30, description: "霸渊巨鲲达到10级，GPS +30%" },
    "abyssKun_50": { gpsMultiplier: 0.70, description: "霸渊巨鲲达到50级，GPS +70%" },
    "abyssKun_100": { gpsMultiplier: 2.00, description: "霸渊巨鲲达到100级，GPS +200%" },
    "primordialZhuLong_10": { gpsMultiplier: 0.50, description: "太初烛龙达到10级，GPS +50%" },
    "primordialZhuLong_50": { gpsMultiplier: 1.00, description: "太初烛龙达到50级，GPS +100%" },
    "primordialZhuLong_100": { gpsMultiplier: 2.50, description: "太初烛龙达到100级，GPS +250%" },
    "wanJunSuanNi_10": { gpsMultiplier: 0.70, description: "万钧狻猊达到10级，GPS +70%" },
    "wanJunSuanNi_50": { gpsMultiplier: 1.50, description: "万钧狻猊达到50级，GPS +150%" },
    "wanJunSuanNi_100": { gpsMultiplier: 3.00, description: "万钧狻猊达到100级，GPS +300%" },
    "yanYuBiAn_10": { gpsMultiplier: 1.00, description: "炎狱狴犴达到10级，GPS +100%" },
    "yanYuBiAn_50": { gpsMultiplier: 2.00, description: "炎狱狴犴达到50级，GPS +200%" },
    "yanYuBiAn_100": { gpsMultiplier: 3.50, description: "炎狱狴犴达到100级，GPS +350%" },
     "yuyu1_10": { gpsMultiplier: 1.00, description: "赤霄夔龙达到10级，GPS +100%" },
    "yuyu1_50": { gpsMultiplier: 2.50, description: "赤霄夔龙达到50级，GPS +250%" },
    "yuyu1_100": { gpsMultiplier: 4.00, description: "赤霄夔龙达到100级，GPS +400%" },
    "yuyu2_10": { gpsMultiplier: 1.30, description: "震岳白泽达到10级，GPS +130%" },
    "yuyu2_50": { gpsMultiplier: 3.00, description: "震岳白泽达到50级，GPS +300%" },
    "yuyu2_100": { gpsMultiplier: 4.50, description: "震岳白泽达到100级，GPS +450%" },
    "yuyu3_10": { gpsMultiplier: 1.60, description: "焚天蛊雕达到10级，GPS +160%" },
    "yuyu3_50": { gpsMultiplier: 3.50, description: "焚天蛊雕达到50级，GPS +350%" },
    "yuyu3_100": { gpsMultiplier: 5.00, description: "焚天蛊雕达到100级，GPS +500%" },
    "yuyu4_10": { gpsMultiplier: 1.90, description: "血煞梼杌达到10级，GPS +190%" },
    "yuyu4_50": { gpsMultiplier: 4.00, description: "血煞梼杌达到50级，GPS +400%" },
    "yuyu4_100": { gpsMultiplier: 5.50, description: "血煞梼杌达到100级，GPS +550%" },
    "yuyu5_10": { gpsMultiplier: 2.20, description: "玄渊白犼达到10级，GPS +220%" },
    "yuyu5_50": { gpsMultiplier: 4.50, description: "玄渊白犼达到50级，GPS +450%" },
    "yuyu5_100": { gpsMultiplier: 6.00, description: "玄渊白犼达到100级，GPS +600%" },
    "yuyu6_10": { gpsMultiplier: 2.50, description: "灾祸蜚牛达到10级，GPS +250%" },
    "yuyu6_50": { gpsMultiplier: 5.00, description: "灾祸蜚牛达到50级，GPS +500%" },
    "yuyu6_100": { gpsMultiplier: 6.50, description: "灾祸蜚牛达到100级，GPS +650%" },
    "yuyu7_10": { gpsMultiplier: 2.80, description: "寂灭罗睺达到10级，GPS +280%" },
    "yuyu7_50": { gpsMultiplier: 5.50, description: "寂灭罗睺达到50级，GPS +550%" },
    "yuyu7_100": { gpsMultiplier: 7.00, description: "寂灭罗睺达到100级，GPS +700%" },
    "yuyu8_10": { gpsMultiplier: 3.10, description: "永劫蚩尤达到10级，GPS +310%" },
    "yuyu8_50": { gpsMultiplier: 6.50, description: "永劫蚩尤达到50级，GPS +650%" },
    "yuyu8_100": { gpsMultiplier: 7.50, description: "永劫蚩尤达到100级，GPS +750%" },

    // 新增魂环成就
    "year1_10": { gpsMultiplier: 0.20, description: "一年魂环达到10级，GPS +20%" },
    "year10_10": { gpsMultiplier: 0.30, description: "十年魂环达到10级，GPS +30%" },
    "year100_10": { gpsMultiplier: 0.40, description: "百年魂环达到10级，GPS +40%" },
    "year1000_10": { gpsMultiplier: 0.50, description: "千年魂环达到10级，GPS +50%" },
    "year10000_10": { gpsMultiplier: 0.60, description: "万年魂环达到10级，GPS +60%" },
    "year100000_10": { gpsMultiplier: 0.70, description: "十万年魂环达到10级，GPS +70%" },
    "year1000000_10": { gpsMultiplier: 0.80, description: "百万年魂环达到10级，GPS +80%" },
    "year10000000_10": { gpsMultiplier: 0.90, description: "千万年魂环达到10级，GPS +90%" },
    "year100000000_10": { gpsMultiplier: 1.00, description: "亿年魂环达到10级，GPS +100%" },
    "year1_100": { gpsMultiplier: 0.50, description: "一年魂环达到100级，GPS +50%" },
    "year10_100": { gpsMultiplier: 0.60, description: "十年魂环达到100级，GPS +60%" },
    "year100_100": { gpsMultiplier: 0.70, description: "百年魂环达到100级，GPS +70%" },
    "year1000_100": { gpsMultiplier: 0.80, description: "千年魂环达到100级，GPS +80%" },
    "year10000_100": { gpsMultiplier: 0.90, description: "万年魂环达到100级，GPS +90%" },
    "year100000_100": { gpsMultiplier: 1.00, description: "十万年魂环达到100级，GPS +100%" },
    "year1000000_100": { gpsMultiplier: 1.10, description: "百万年魂环达到100级，GPS +110%" },
    "year10000000_100": { gpsMultiplier: 1.20, description: "千万年魂环达到100级，GPS +120%" },
    "year100000000_100": { gpsMultiplier: 1.30, description: "亿年魂环达到100级，GPS +130%" },
    "year1_1000": { gpsMultiplier: 1.00, description: "一年魂环达到1000级，GPS +100%" },
    "year10_1000": { gpsMultiplier: 1.10, description: "十年魂环达到1000级，GPS +110%" },
    "year100_1000": { gpsMultiplier: 1.20, description: "百年魂环达到1000级，GPS +120%" },
    "year1000_1000": { gpsMultiplier: 1.30, description: "千年魂环达到1000级，GPS +130%" },
    "year10000_1000": { gpsMultiplier: 1.40, description: "万年魂环达到1000级，GPS +140%" },
    "year100000_1000": { gpsMultiplier: 1.50, description: "十万年魂环达到1000级，GPS +150%" },
    "year1000000_1000": { gpsMultiplier: 1.60, description: "百万年魂环达到1000级，GPS +160%" },
    "year10000000_1000": { gpsMultiplier: 1.70, description: "千万年魂环达到1000级，GPS +170%" },
    "year100000000_1000": { gpsMultiplier: 1.80, description: "亿年魂环达到1000级，GPS +180%" },
    "year1_10000": { gpsMultiplier: 2.00, description: "一年魂环达到10000级，GPS +200%" },
    "year10_10000": { gpsMultiplier: 2.10, description: "十年魂环达到10000级，GPS +210%" },
    "year100_10000": { gpsMultiplier: 2.20, description: "百年魂环达到10000级，GPS +220%" },
    "year1000_10000": { gpsMultiplier: 2.30, description: "千年魂环达到10000级，GPS +230%" },
    "year10000_10000": { gpsMultiplier: 2.40, description: "万年魂环达到10000级，GPS +240%" },
    "year100000_10000": { gpsMultiplier: 2.50, description: "十万年魂环达到10000级，GPS +250%" },
    "year1000000_10000": { gpsMultiplier: 2.60, description: "百万年魂环达到10000级，GPS +260%" },
    "year10000000_10000": { gpsMultiplier: 2.70, description: "千万年魂环达到10000级，GPS +270%" },
    "year100000000_10000": { gpsMultiplier: 2.80, description: "亿年魂环达到10000级，GPS +280%" },
    "year2_10": { gpsMultiplier: 1.10, description: "太古·混沌亿年魂环达到10级，GPS +110%" },
    "year2_100": { gpsMultiplier: 1.40, description: "太古·混沌亿年魂环达到100级，GPS +140%" },
    "year2_1000": { gpsMultiplier: 1.90, description: "太古·混沌亿年魂环达到1000级，GPS +190%" },
    "year2_10000": { gpsMultiplier: 3.80, description: "太古·混沌亿年魂环达到10000级，GPS +380%" },
    "year3_10": { gpsMultiplier: 1.20, description: "鸿蒙·始源亿年魂环达到10级，GPS +120%" },
    "year3_100": { gpsMultiplier: 1.50, description: "鸿蒙·始源亿年魂环达到100级，GPS +150%" },
    "year3_1000": { gpsMultiplier: 2.00, description: "鸿蒙·始源亿年魂环达到1000级，GPS +200%" },
    "year3_10000": { gpsMultiplier: 3.90, description: "鸿蒙·始源亿年魂环达到10000级，GPS +390%" },
    "year4_10": { gpsMultiplier: 1.30, description: "亘古·时空亿年魂环达到10级，GPS +130%" },
    "year4_100": { gpsMultiplier: 1.60, description: "亘古·时空亿年魂环达到100级，GPS +160%" },
    "year4_1000": { gpsMultiplier: 2.10, description: "亘古·时空亿年魂环达到1000级，GPS +210%" },
    "year4_10000": { gpsMultiplier: 4.00, description: "亘古·时空亿年魂环达到10000级，GPS +400%" },
    "year5_10": { gpsMultiplier: 1.40, description: "九幽·冥渊亿年魂环达到10级，GPS +140%" },
    "year5_100": { gpsMultiplier: 1.70, description: "九幽·冥渊亿年魂环达到100级，GPS +170%" },
    "year5_1000": { gpsMultiplier: 2.20, description: "九幽·冥渊亿年魂环达到1000级，GPS +220%" },
    "year5_10000": { gpsMultiplier: 4.10, description: "九幽·冥渊亿年魂环达到10000级，GPS +410%" },
    "year6_10": { gpsMultiplier: 1.50, description: "皓宇·星辰亿年魂环达到10级，GPS +150%" },
    "year6_100": { gpsMultiplier: 1.80, description: "皓宇·星辰亿年魂环达到100级，GPS +180%" },
    "year6_1000": { gpsMultiplier: 2.30, description: "皓宇·星辰亿年魂环达到1000级，GPS +230%" },
    "year6_10000": { gpsMultiplier: 4.20, description: "皓宇·星辰亿年魂环达到10000级，GPS +420%" },
    "year7_10": { gpsMultiplier: 1.60, description: "炎狱·焚天亿年魂环达到10级，GPS +160%" },
    "year7_100": { gpsMultiplier: 1.90, description: "炎狱·焚天亿年魂环达到100级，GPS +190%" },
    "year7_1000": { gpsMultiplier: 2.40, description: "炎狱·焚天亿年魂环达到1000级，GPS +240%" },
    "year7_10000": { gpsMultiplier: 4.30, description: "炎狱·焚天亿年魂环达到10000级，GPS +430%" },
    "year8_10": { gpsMultiplier: 1.70, description: "霜烬·极寒亿年魂环达到10级，GPS +170%" },
    "year8_100": { gpsMultiplier: 2.00, description: "霜烬·极寒亿年魂环达到100级，GPS +200%" },
    "year8_1000": { gpsMultiplier: 2.50, description: "霜烬·极寒亿年魂环达到1000级，GPS +250%" },
    "year8_10000": { gpsMultiplier: 4.40, description: "霜烬·极寒亿年魂环达到10000级，GPS +440%" },
    "year9_10": { gpsMultiplier: 1.80, description: "灵幻·万象亿年魂环达到10级，GPS +180%" },
    "year9_100": { gpsMultiplier: 2.10, description: "灵幻·万象亿年魂环达到100级，GPS +210%" },
    "year9_1000": { gpsMultiplier: 2.60, description: "灵幻·万象亿年魂环达到1000级，GPS +260%" },
    "year9_10000": { gpsMultiplier: 4.50, description: "灵幻·万象亿年魂环达到10000级，GPS +450%" },
    "year11_10": { gpsMultiplier: 1.90, description: "炽阳·耀世亿年魂环达到10级，GPS +190%" },
    "year11_100": { gpsMultiplier: 2.20, description: "炽阳·耀世亿年魂环达到100级，GPS +220%" },
    "year11_1000": { gpsMultiplier: 2.70, description: "炽阳·耀世亿年魂环达到1000级，GPS +270%" },
    "year11_10000": { gpsMultiplier: 4.60, description: "炽阳·耀世亿年魂环达到10000级，GPS +460%" },
    "year12_10": { gpsMultiplier: 2.00, description: "暗蚀·灭世亿年魂环达到10级，GPS +200%" },
    "year12_100": { gpsMultiplier: 2.30, description: "暗蚀·灭世亿年魂环达到100级，GPS +230%" },
    "year12_1000": { gpsMultiplier: 2.80, description: "暗蚀·灭世亿年魂环达到1000级，GPS +280%" },
    "year12_10000": { gpsMultiplier: 4.70, description: "暗蚀·灭世亿年魂环达到10000级，GPS +470%" },
    "year13_10": { gpsMultiplier: 2.10, description: "圣辉·救赎亿年魂环达到10级，GPS +210%" },
    "year13_100": { gpsMultiplier: 2.40, description: "圣辉·救赎亿年魂环达到100级，GPS +240%" },
    "year13_1000": { gpsMultiplier: 2.90, description: "圣辉·救赎亿年魂环达到1000级，GPS +290%" },
    "year13_10000": { gpsMultiplier: 4.80, description: "圣辉·救赎亿年魂环达到10000级，GPS +480%" },
    "year14_10": { gpsMultiplier: 2.30, description: "紫霄·雷罚亿年魂环达到10级，GPS +220%" },
    "year14_100": { gpsMultiplier: 2.50, description: "紫霄·雷罚亿年魂环达到100级，GPS +250%" },
    "year14_1000": { gpsMultiplier: 3.00, description: "紫霄·雷罚亿年魂环达到1000级，GPS +300%" },
    "year14_10000": { gpsMultiplier: 4.90, description: "紫霄·雷罚亿年魂环达到10000级，GPS +490%" },
    "year15_10": { gpsMultiplier: 2.30, description: "青木·生机亿年魂环达到10级，GPS +230%" },
    "year15_100": { gpsMultiplier: 2.60, description: "青木·生机亿年魂环达到100级，GPS +260%" },
    "year15_1000": { gpsMultiplier: 3.00, description: "青木·生机亿年魂环达到1000级，GPS +300%" },
    "year15_10000": { gpsMultiplier: 5.00, description: "青木·生机亿年魂环达到10000级，GPS +500%" },
    "year16_10": { gpsMultiplier: 2.40, description: "星澜·幻梦亿年魂环达到10级，GPS +240%" },
    "year16_100": { gpsMultiplier: 2.70, description: "星澜·幻梦亿年魂环达到100级，GPS +270%" },
    "year16_1000": { gpsMultiplier: 3.10, description: "星澜·幻梦亿年魂环达到1000级，GPS +310%" },
    "year16_10000": { gpsMultiplier: 5.10, description: "星澜·幻梦亿年魂环达到10000级，GPS +510%" },
    "year17_10": { gpsMultiplier: 2.50, description: "渊海·无尽亿年魂环达到10级，GPS +250%" },
    "year17_100": { gpsMultiplier: 2.80, description: "渊海·无尽亿年魂环达到100级，GPS +280%" },
    "year17_1000": { gpsMultiplier: 3.20, description: "渊海·无尽亿年魂环达到1000级，GPS +320%" },
    "year17_10000": { gpsMultiplier: 5.20, description: "渊海·无尽亿年魂环达到10000级，GPS +520%" },
    "year18_10": { gpsMultiplier: 2.60, description: "荒古·遗世亿年魂环达到10级，GPS +260%" },
    "year18_100": { gpsMultiplier: 2.90, description: "荒古·遗世亿年魂环达到100级，GPS +290%" },
    "year18_1000": { gpsMultiplier: 3.30, description: "荒古·遗世亿年魂环达到1000级，GPS +330%" },
    "year18_10000": { gpsMultiplier: 5.30, description: "荒古·遗世亿年魂环达到10000级，GPS +530%" },
    "year19_10": { gpsMultiplier: 2.70, description: "净世·光明亿年魂环达到10级，GPS +270%" },
    "year19_100": { gpsMultiplier: 3.00, description: "净世·光明亿年魂环达到100级，GPS +300%" },
    "year19_1000": { gpsMultiplier: 3.40, description: "净世·光明亿年魂环达到1000级，GPS +340%" },
    "year19_10000": { gpsMultiplier: 5.40, description: "净世·光明亿年魂环达到10000级，GPS +540%" },
    "year20_10": { gpsMultiplier: 2.80, description: "蚀灵·诅咒亿年魂环达到10级，GPS +280%" },
    "year20_100": { gpsMultiplier: 3.10, description: "蚀灵·诅咒亿年魂环达到100级，GPS +310%" },
    "year20_1000": { gpsMultiplier: 3.50, description: "蚀灵·诅咒亿年魂环达到1000级，GPS +350%" },
    "year20_10000": { gpsMultiplier: 5.50, description: "蚀灵·诅咒亿年魂环达到10000级，GPS +550%" },
    "year21_10": { gpsMultiplier: 2.90, description: "逆乱·时空亿年魂环达到10级，GPS +290%" },
    "year21_100": { gpsMultiplier: 3.20, description: "逆乱·时空亿年魂环达到100级，GPS +320%" },
    "year21_1000": { gpsMultiplier: 3.60, description: "逆乱·时空亿年魂环达到1000级，GPS +360%" },
    "year21_10000": { gpsMultiplier: 5.60, description: "逆乱·时空亿年魂环达到10000级，GPS +560%" },
    "year22_10": { gpsMultiplier: 3.00, description: "龙渊·霸者亿年魂环达到10级，GPS +300%" },
    "year22_100": { gpsMultiplier: 3.30, description: "龙渊·霸者亿年魂环达到100级，GPS +330%" },
    "year22_1000": { gpsMultiplier: 3.70, description: "龙渊·霸者亿年魂环达到1000级，GPS +370%" },
    "year22_10000": { gpsMultiplier: 5.70, description: "龙渊·霸者亿年魂环达到10000级，GPS +570%" },
    "year23_10": { gpsMultiplier: 3.10, description: "凤羽·炎舞亿年魂环达到10级，GPS +310%" },
    "year23_100": { gpsMultiplier: 3.40, description: "凤羽·炎舞亿年魂环达到100级，GPS +340%" },
    "year23_1000": { gpsMultiplier: 3.80, description: "凤羽·炎舞亿年魂环达到1000级，GPS +380%" },
    "year23_10000": { gpsMultiplier: 5.80, description: "凤羽·炎舞亿年魂环达到10000级，GPS +580%" },
    "year24_10": { gpsMultiplier: 3.20, description: "星辰·命数亿年魂环达到10级，GPS +320%" },
    "year24_100": { gpsMultiplier: 3.50, description: "星辰·命数亿年魂环达到100级，GPS +350%" },
    "year24_1000": { gpsMultiplier: 3.90, description: "星辰·命数亿年魂环达到1000级，GPS +390%" },
    "year24_10000": { gpsMultiplier: 5.90, description: "星辰·命数亿年魂环达到10000级，GPS +590%" },
    "year25_10": { gpsMultiplier: 3.30, description: "荒炎·破灭亿年魂环达到10级，GPS +330%" },
    "year25_100": { gpsMultiplier: 3.60, description: "荒炎·破灭亿年魂环达到100级，GPS +360%" },
    "year25_1000": { gpsMultiplier: 4.00, description: "荒炎·破灭亿年魂环达到1000级，GPS +400%" },
    "year25_10000": { gpsMultiplier: 6.00, description: "荒炎·破灭亿年魂环达到10000级，GPS +600%" },
    "year26_10": { gpsMultiplier: 3.40, description: "玄冰·永冻亿年魂环达到10级，GPS +340%" },
    "year26_100": { gpsMultiplier: 3.70, description: "玄冰·永冻亿年魂环达到100级，GPS +370%" },
    "year26_1000": { gpsMultiplier: 4.10, description: "玄冰·永冻亿年魂环达到1000级，GPS +410%" },
    "year26_10000": { gpsMultiplier: 6.10, description: "玄冰·永冻亿年魂环达到10000级，GPS +610%" },
    "year27_10": { gpsMultiplier: 3.50, description: "灵犀·心眼亿年魂环达到10级，GPS +350%" },
    "year27_100": { gpsMultiplier: 3.80, description: "灵犀·心眼亿年魂环达到100级，GPS +380%" },
    "year27_1000": { gpsMultiplier: 4.20, description: "灵犀·心眼亿年魂环达到1000级，GPS +420%" },
    "year27_10000": { gpsMultiplier: 6.20, description: "灵犀·心眼亿年魂环达到10000级，GPS +620%" },
    "year28_10": { gpsMultiplier: 3.60, description: "圣谕·裁决亿年魂环达到10级，GPS +360%" },
    "year28_100": { gpsMultiplier: 3.90, description: "圣谕·裁决亿年魂环达到100级，GPS +390%" },
    "year28_1000": { gpsMultiplier: 4.30, description: "圣谕·裁决亿年魂环达到1000级，GPS +430%" },
    "year28_10000": { gpsMultiplier: 6.30, description: "圣谕·裁决亿年魂环达到10000级，GPS +630%" },
    "year29_10": { gpsMultiplier: 3.70, description: "九幽·黄泉亿年魂环达到10级，GPS +370%" },
    "year29_100": { gpsMultiplier: 4.00, description: "九幽·黄泉亿年魂环达到100级，GPS +400%" },
    "year29_1000": { gpsMultiplier: 4.40, description: "九幽·黄泉亿年魂环达到1000级，GPS +440%" },
    "year29_10000": { gpsMultiplier: 6.40, description: "九幽·黄泉亿年魂环达到10000级，GPS +640%" },
    "year30_10": { gpsMultiplier: 3.80, description: "灵蕴·造化亿年魂环达到10级，GPS +380%" },
    "year30_100": { gpsMultiplier: 4.10, description: "灵蕴·造化亿年魂环达到100级，GPS +410%" },
    "year30_1000": { gpsMultiplier: 4.50, description: "灵蕴·造化亿年魂环达到1000级，GPS +450%" },
    "year30_10000": { gpsMultiplier: 6.50, description: "灵蕴·造化亿年魂环达到10000级，GPS +650%" },
    "year31_10": { gpsMultiplier: 3.90, description: "混沌·元始亿年魂环达到10级，GPS +390%" },
    "year31_100": { gpsMultiplier: 4.20, description: "混沌·元始亿年魂环达到100级，GPS +420%" },
    "year31_1000": { gpsMultiplier: 4.60, description: "混沌·元始亿年魂环达到1000级，GPS +460%" },
    "year31_10000": { gpsMultiplier: 6.60, description: "混沌·元始亿年魂环达到10000级，GPS +660%" },
    "year32_10": { gpsMultiplier: 4.00, description: "苍穹·御天亿年魂环达到10级，GPS +400%" },
    "year32_100": { gpsMultiplier: 4.30, description: "苍穹·御天亿年魂环达到100级，GPS +430%" },
    "year32_1000": { gpsMultiplier: 4.70, description: "苍穹·御天亿年魂环达到1000级，GPS +470%" },
    "year32_10000": { gpsMultiplier: 6.70, description: "苍穹·御天亿年魂环达到10000级，GPS +670%" },
    "year33_10": { gpsMultiplier: 4.10, description: "龙炎·焚天亿年魂环达到10级，GPS +410%" },
    "year33_100": { gpsMultiplier: 4.40, description: "龙炎·焚天亿年魂环达到100级，GPS +440%" },
    "year33_1000": { gpsMultiplier: 4.80, description: "龙炎·焚天亿年魂环达到1000级，GPS +480%" },
    "year33_10000": { gpsMultiplier: 6.80, description: "龙炎·焚天亿年魂环达到10000级，GPS +680%" },
    "year34_10": { gpsMultiplier: 4.20, description: "血狱·魔神亿年魂环达到10级，GPS +420%" },
    "year34_100": { gpsMultiplier: 4.50, description: "血狱·魔神亿年魂环达到100级，GPS +450%" },
    "year34_1000": { gpsMultiplier: 4.90, description: "血狱·魔神亿年魂环达到1000级，GPS +490%" },
    "year34_10000": { gpsMultiplier: 6.90, description: "血狱·魔神亿年魂环达到10000级，GPS +690%" },
    "year35_10": { gpsMultiplier: 4.30, description: "赤霄·苍穹亿年魂环达到10级，GPS +430%" },
    "year35_100": { gpsMultiplier: 4.60, description: "赤霄·苍穹亿年魂环达到100级，GPS +460%" },
    "year35_1000": { gpsMultiplier: 5.00, description: "赤霄·苍穹亿年魂环达到1000级，GPS +500%" },
    "year35_10000": { gpsMultiplier: 7.00, description: "赤霄·苍穹亿年魂环达到10000级，GPS +700%" },
    "year36_10": { gpsMultiplier: 4.40, description: "炎凤·涅槃亿年魂环达到10级，GPS +440%" },
    "year36_100": { gpsMultiplier: 4.70, description: "炎凤·涅槃亿年魂环达到100级，GPS +470%" },
    "year36_1000": { gpsMultiplier: 5.10, description: "炎凤·涅槃亿年魂环达到1000级，GPS +510%" },
    "year36_10000": { gpsMultiplier: 7.10, description: "炎凤·涅槃亿年魂环达到10000级，GPS +710%" },
    "year37_10": { gpsMultiplier: 4.50, description: "闫闫·黑丝亿年魂环达到10级，GPS +450%" },
    "year37_100": { gpsMultiplier: 4.80, description: "闫闫·黑丝亿年魂环达到100级，GPS +480%" },
    "year37_1000": { gpsMultiplier: 5.20, description: "闫闫·黑丝亿年魂环达到1000级，GPS +520%" },
    "year37_10000": { gpsMultiplier: 7.20, description: "闫闫·黑丝亿年魂环达到10000级，GPS +720%" },
    "world_boss_1st": { gpsMultiplier: 10.0, description: "在世界BOSS中获得第1名，GPS +1000%"  },
    "world_boss_top5": { gpsMultiplier: 5.0, description: "在世界BOSS中获得第2-10名，GPS +500%"  },
    "world_boss_top10": { gpsMultiplier: 3.0, description: "在世界BOSS中获得第11-30名，GPS +300%"  },
    "world_boss_participant": { gpsMultiplier: 1.00, description: "参与世界BOSS战斗，GPS +100%"  },
    // 新增转生成就奖励
    "reincarnation_10": { gpsMultiplier: 0.50, description: "转生10次，GPS +50%" },
    "reincarnation_100": { gpsMultiplier: 1.00, description: "转生100次，GPS +100%" },
    "reincarnation_1000": { gpsMultiplier: 5.00, description: "转生1000次，GPS +500%" },
    "reincarnation_10000": { gpsMultiplier: 10.00, description: "转生10000次，GPS +1000%" }
};
 
// 功法秘笈配置
const techniqueConfig = {
    "immortalAsuraBody": { name: "不灭修罗体", type: "health", effect: 0.0001, description: "每一级增加0.01%生命永久属性" },
    "eightDesolationsWarDemonBody": { name: "八荒战魔躯", type: "health", effect: 0.001, description: "每一级增加0.1%生命永久属性" },
    "nineRevolutionsProfoundBody": { name: "九转玄黄身", type: "health", effect: 0.005, description: "每一级增加0.5%生命永久属性" },
    "loneDestinyBone": { name: "天煞孤星骨", type: "health", effect: 0.01, description: "每一级增加1%生命永久属性" },
    "bloodPrisonMadGodArmor": { name: "血狱狂神铠", type: "health", effect: 0.05, description: "每一级增加5%生命永久属性" },
    "godSlayingBurningHeavenArt": { name: "弑神焚天诀", type: "attack", effect: 0.0001, description: "每一级增加0.01%攻击永久属性" },
    "burialHeavenBladePrisonManual": { name: "葬天刀狱谱", type: "attack", effect: 0.001, description: "每一级增加0.1%攻击永久属性" },
    "tenDirectionsAnnihilationSpearCodex": { name: "十方俱灭枪典", type: "attack", effect: 0.005, description: "每一级增加0.5%攻击永久属" },
    "thousandCalamitiesVoidArrowArt": { name: "千劫裂空箭术", type: "attack", effect: 0.01, description: "每一级增加1%攻击永久属性" },
    "ancientAnnihilationHalberdArt": { name: "万古寂灭戟法", type: "attack", effect: 0.05, description: "每一级增加5%攻击永久属性" },
    "nineCalamitiesWorldDestroyingPalm": { name: "九劫灭世掌", type: "critDamage", effect: 0.001, description: "每一级增加0.1%爆伤永久属性" },
    "chaosCreationForce": { name: "混沌开天劲", type: "critDamage", effect: 0.005, description: "每一级增加0.5%爆伤永久属性" },
    "dragonElephantShatteringVoidArt": { name: "龙象碎穹功", type: "critDamage", effect: 0.01, description: "每一级增加1%爆伤永久属性" },
    "greatSunFallingStarFist": { name: "大日陨星拳", type: "critDamage", effect: 0.05, description: "每一级增加5%爆伤永久属性" },
    "nineHeavensThunderboltTruth": { name: "九霄雷殛真解", type: "critRate", effect: 0.00001, description: "每一级增加0.001%暴击率永久属性" },
    "netherBloodSeaDiagram": { name: "幽冥血海图录", type: "critRate", effect: 0.0005, description: "每一级增加0.05%暴击率永久属性" },
    "riverStarsHangingSecretScroll": { name: "星河倒悬秘卷", type: "critRate", effect: 0.0001, description: "每一级增加0.01%暴击率永久属性" },
    "eightDesolationsFireDragonRecord": { name: "八荒火龙焚世录", type: "critRate", effect: 0.001, description: "每一级增加0.1%暴击率永久属性" },
    "iceSealThreeThousandRealmArt": { name: "冰封三千界心法", type: "critRate", effect: 0.005, description: "每一级增加0.5%暴击率永久属性" },
    "greatVoidReturnToVoidCodex": { name: "太虚归墟典", type: "multiAttack", effect: 2, description: "每一级攻击次数+2永久属性" },
    "samsaraCalamityAnnihilationSutra": { name: "轮回劫灭经", type: "multiAttack", effect: 25, description: "每一级攻击次数+25永久属性" },
    "yinYangReversalArt": { name: "阴阳逆命术", type: "multiAttack", effect: 50, description: "每一级攻击次数+50永久属性" },
    "zhouHeavenStarsFallingWay": { name: "周天星陨道", type: "multiAttack", effect: 100, description: "每一级攻击次数+100永久属性" },
    "ancientVoidRecord": { name: "万古空冥录", type: "multiAttack", effect: 500, description: "每一级攻击次数+500永久属性" }
};
const vipConfig = [
    { level: 1, requiredPower: 0, bonus: 1 }, 
    { level: 2, requiredPower: 5, bonus: 10 }, 
    { level: 3, requiredPower: 15, bonus: 100 }, 
    { level: 4, requiredPower: 32, bonus: 1000 }, 
    { level: 5, requiredPower: 64, bonus: 10000 },
    { level: 6, requiredPower: 128, bonus: 100000 },
    { level: 7, requiredPower: 648, bonus: 1000000 }, 
    { level: 8, requiredPower: 1280, bonus: 10000000 }, 
    { level: 9, requiredPower: 3280, bonus: 100000000 }, 
    { level: 10, requiredPower: 6480, bonus: 1000000000 }, 
    { level: 11, requiredPower: 10000, bonus: 10000000000 },
    { level: 12, requiredPower: 20000, bonus: 100000000000 },
    { level: 13, requiredPower: 30000, bonus: 1000000000000 },
    { level: 14, requiredPower: 40000, bonus: 10000000000000 },
    { level: 15, requiredPower: 50000, bonus: 100000000000000 },
    { level: 16, requiredPower: 60000, bonus: 1000000000000000 },
    { level: 17, requiredPower: 70000, bonus: 10000000000000000 },
    { level: 18, requiredPower: 80000, bonus: 100000000000000000 },
    { level: 19, requiredPower: 90000, bonus: 1000000000000000000 },
    { level: 20, requiredPower: 100000, bonus: 10000000000000000000 },
    { level: 21, requiredPower: 125000, bonus: 100000000000000000000 },
    { level: 22, requiredPower: 150000, bonus: 1000000000000000000000 },
    { level: 23, requiredPower: 200000, bonus: 10000000000000000000000 },
    { level: 24, requiredPower: 250000, bonus: 100000000000000000000000 },
    { level: 25, requiredPower: 300000, bonus: 1000000000000000000000000 },
    { level: 26, requiredPower: 400000, bonus: 10000000000000000000000000 },
    { level: 27, requiredPower: 500000, bonus: 100000000000000000000000000 },
    { level: 28, requiredPower: 600000, bonus: 1000000000000000000000000000 },
    { level: 29, requiredPower: 750000, bonus: 10000000000000000000000000000 },
    { level: 30, requiredPower: 1000000, bonus: 100000000000000000000000000000 }
];
        // 道具配置
        const itemEffects = {
    primaryGem: { name: '初级宝石', effect: 10.00, description: '增加装备属性+1000%' },
    advancedGem: { name: '高级宝石', effect: 50.00, description: '增加装备属性+5000%' },
    superiorGem: { name: '极品宝石', effect: 500.00, description: '增加装备属性+50000%' },
    divineGem: { name: '神级宝石', effect: 5000.00, description: '增加装备属性+500000%' },
    vipPower: { name: 'VIP能力值', effect: 1, description: '提升VIP等级的特殊道具' },
    refineStone: { name: '洗炼石', effect: 0, description: '用于重铸副本装备的成长属性' }, // 新增洗炼石
    rose: { name: '玫瑰花', effect: 1, description: '用于升级伴侣等级' },
    companionKey: { name: '伴侣钥匙', effect: 0, description: '用于开启伴侣宝箱' }, 
    rebornDan: { name: '洗髓丹', effect: 0, description: '用于洗练伴侣天赋' },
    baitCount: { name: '鱼饵', effect: 0, description: '用于钓鱼消耗品' },
    rootDetector: { name: '灵根检测器', effect: 0, description: '用于开启灵根宝箱' },
    bloodlineDetector: { name: '血脉检测剂', effect: 0, description: '用于开启血脉宝箱' },
    advanceStone: { name: '进阶神石', effect: 0, description: '用于进阶神器' },  
   primaryGemq: { name: '宝藏金币', effect: 0, description: '用于兑换藏宝图商店物品' },
   zongmen: { name: '宗门令牌', effect: 0, description: '创建宗门消耗的必须品' },  
   roseq: { name: '香囊', effect: 0, description: '赠送宗门成员增加忠诚度' }, 
  yuzhou1: { name: '星尘发票', effect: 0, description: '兑换星尘专用' }, 
   yuzhou2: { name: '暗物质发票', effect: 0, description: '兑换暗物质专用' }, 
   yuzhou3: { name: '宇宙晶体发票', effect: 0, description: '兑换宇宙晶体专用' }, 
   yuzhou4: { name: '神器碎片发票', effect: 0, description: '兑换神器碎片专用' },
  banlv1: { name: '普通伴侣灵魂', effect: 0, description: '普通伴侣进阶必需品' },
 banlv2: { name: '稀有伴侣灵魂', effect: 0, description: '稀有伴侣进阶必需品' },
 banlv3: { name: '史诗伴侣灵魂', effect: 0, description: '史诗伴侣进阶必需品' },
 banlv4: { name: '卓越伴侣灵魂', effect: 0, description: '卓越伴侣进阶必需品' },
banlv5: { name: '完美伴侣灵魂', effect: 0, description: '完美伴侣进阶必需品' },
banlv6: { name: '神赐伴侣灵魂', effect: 0, description: '神赐伴侣进阶必需品' },
banlv7: { name: '天使伴侣灵魂', effect: 0, description: '天使伴侣进阶必需品' },
banlv8: { name: '恶魔伴侣灵魂', effect: 0, description: '恶魔伴侣进阶必需品' },
banlv9: { name: '精灵伴侣灵魂', effect: 0, description: '精灵伴侣进阶必需品' }
};

        // 收藏物配置
        const collectionEffects = {
             lightSpeedHand: { name: '光速幻影手', effect: 0.01, description: '增加全部装备属性 +1%' },
    empHand: { name: '电磁脉冲快手', effect: 0.05, description: '增加全部装备属性 +5%' },
    godlyHand: { name: '神级手速怪', effect: 0.30, description: '增加全部装备属性 +30%' },
    quickHand: { name: '秒点快手侠', effect: 2.00, description: '增加全部装备属性 +200%' },
    shadowHand: { name: '无影闪击手', effect: 5.00, description: '增加全部装备属性 +500%' },
    quantumHand: { name: '量子跃迁快手', effect: 10.00, description: '增加全部装备属性 +1000%' },
    lightningHand: { name: '闪电连点器之手', effect: 100.00, description: '增加全部装备属性 +10000%' },
    divineHand: { name: '天神之手', effect: 5000.00, description: '增加全部装备属性 +500000%' }
};

        // 材料宝箱掉落概率配置
        const materialChestProbabilities = [
     { type: 'lightSpeedHand', prob: 0.71188 },
    { type: 'empHand', prob: 0.2305 },
    { type: 'godlyHand', prob: 0.0324 },
    { type: 'quickHand', prob: 0.01 },
    { type: 'shadowHand', prob: 0.005 },
    { type: 'quantumHand', prob: 0.0005 },
    { type: 'lightningHand', prob: 0.00005 },
    { type: 'divineHand', prob: 0.00001 },
    { type: 'primaryGem', prob: 0.005 },
    { type: 'advancedGem', prob: 0.0005 },
    { type: 'superiorGem', prob: 0.00005 },
    { type: 'divineGem', prob: 0.00001 },
    { type: 'vipPower', prob: 0.001 },
    { type: 'refineStone', prob: 0.001 }, 
    { type: 'companionKey', prob: 0.001 }, 
     { type: 'rebornDan', prob: 0.001 }, 
    
];
    const techniqueChestDrops = [
    // 第一档 22%~21.8%
    { id: "immortalAsuraBody", prob: 0.21 },          // 不灭修罗体 21%
    { id: "godSlayingBurningHeavenArt", prob: 0.21 }, // 弑神焚天诀 21%
    { id: "nineHeavensThunderboltTruth", prob: 0.23299 }, // 九霄雷殛真解 20.65%
    
    // 第二档 5%
    { id: "eightDesolationsWarDemonBody", prob: 0.05 },  // 八荒战魔躯 5%
    { id: "burialHeavenBladePrisonManual", prob: 0.05 }, // 葬天刀狱谱 5%
    { id: "nineCalamitiesWorldDestroyingPalm", prob: 0.05 }, // 九劫灭世掌 5%
    { id: "netherBloodSeaDiagram", prob: 0.05 },        // 幽冥血海图录 5%
    
    // 第三档 2%
    { id: "nineRevolutionsProfoundBody", prob: 0.02 },  // 九转玄黄身 2%
    { id: "tenDirectionsAnnihilationSpearCodex", prob: 0.02 }, // 十方俱灭枪典 2%
    { id: "chaosCreationForce", prob: 0.02 },           // 混沌开天劲 2%
    { id: "riverStarsHangingSecretScroll", prob: 0.02 }, // 星河倒悬秘卷 2%
    
    // 第四档 1%
    { id: "loneDestinyBone", prob: 0.01 },              // 天煞孤星骨 1%
    { id: "thousandCalamitiesVoidArrowArt", prob: 0.01 }, // 千劫裂空箭术 1%
    { id: "dragonElephantShatteringVoidArt", prob: 0.01 }, // 龙象碎穹功 1%
    { id: "eightDesolationsFireDragonRecord", prob: 0.01 }, // 八荒火龙焚世录 1%
    
    // 第五档 0.5%
    { id: "bloodPrisonMadGodArmor", prob: 0.0051 },      // 血狱狂神铠 0.5%
    { id: "ancientAnnihilationHalberdArt", prob: 0.0051 }, // 万古寂灭戟法 0.5%
    { id: "greatSunFallingStarFist", prob: 0.0051 },     // 大日陨星拳 0.5%
    { id: "iceSealThreeThousandRealmArt", prob: 0.0051 }, // 冰封三千界心法 0.5%
    
    // 第六档 0.5%~0.001%
    { id: "greatVoidReturnToVoidCodex", prob: 0.005 },  // 太虚归墟典 0.5%
    { id: "samsaraCalamityAnnihilationSutra", prob: 0.001 }, // 轮回劫灭经 0.1%
    { id: "yinYangReversalArt", prob: 0.0005 },         // 阴阳逆命术 0.05%
    { id: "zhouHeavenStarsFallingWay", prob: 0.0001 },  // 周天星陨道 0.01%
    { id: "ancientVoidRecord", prob: 0.00001 }          // 万古空冥录 0.001%
];
 // 奥秘系统配置
const mysteryConfig = [
    { stage: 1, name: "初级秘法师", levelCost: 100, totalBonus: 1 },
    { stage: 2, name: "奥法转运者", levelCost: 10000, totalBonus: 5 },
    { stage: 3, name: "奥术掌握者", levelCost: 100000, totalBonus: 10 },
    { stage: 4, name: "秘能大师", levelCost: 500000, totalBonus: 50 },
    { stage: 5, name: "奥术之灵", levelCost: 1000000, totalBonus: 100 },
    { stage: 6, name: "神圣秘灵师", levelCost: 5000000, totalBonus: 500 },
    { stage: 7, name: "神之奥术掌握者", levelCost: 10000000, totalBonus: 1000 },
    { stage: 8, name: "先知大师", levelCost: 50000000, totalBonus: 5000 },
    { stage: 9, name: "恒星秘法师", levelCost: 100000000, totalBonus: 10000 },
    { stage: 10, name: "暗能量宗师", levelCost: 200000000, totalBonus: 50000 },
    { stage: 11, name: "星光秘耀使者", levelCost: 300000000, totalBonus: 100000 },
    { stage: 12, name: "混沌秘能主宰", levelCost: 400000000, totalBonus: 500000 },
    { stage: 13, name: "维度漫游大师", levelCost: 500000000, totalBonus: 1000000 },
    { stage: 14, name: "终焉秘法先知", levelCost: 600000000, totalBonus: 5000000 },
    { stage: 15, name: "时律操纵者", levelCost: 800000000, totalBonus: 10000000 },
    { stage: 16, name: "创世星芒导师", levelCost: 1000000000, totalBonus: 50000000 },
    { stage: 17, name: "虚无之光缔造者", levelCost: 2000000000, totalBonus: 100000000 },
    { stage: 18, name: "神谕秘能神", levelCost: 4000000000, totalBonus: 500000000 },
    { stage: 19, name: "永恒奥术神", levelCost: 6000000000, totalBonus: 1000000000 },
    { stage: 20, name: "超维秘耀神", levelCost: 8000000000, totalBonus: 5000000000 },
    { stage: 21, name: "奥秘本身", levelCost: 10000000000, totalBonus: 10000000000 }
];
        // 装备配置
        const equipmentTypes = {
            common: { name: '普通', gps: 1, click: 0, prob: 0.6, growthRate: 0.025 },
            rare: { name: '稀有', gps: 3, click: 3, prob: 0.15, growthRate: 0.05 },
            epic: { name: '史诗', gps: 15, click: 45, prob: 0.1, growthRate: 0.10 },
            legendary: { name: '传说', gps: 40, click: 160, prob: 0.05, growthRate: 0.15 },
            ancient: { name: '远古', gps: 100, click: 300, prob: 0.03, growthRate: 0.20 },
            divine: { name: '神圣', gps: 500, click: 2000, prob: 0.02, growthRate: 0.30 },
            arcane: { name: '奥术', gps: 600, click: 5000, prob: 0.015, growthRate: 0.35 },
            celestial: { name: '天空', gps: 1000, click: 10000, prob: 0.01, growthRate: 0.40 },
            infernal: { name: '地狱', gps: 50000, click: 500000, prob: 0.005, growthRate: 0.50 },
            astral: { name: '星界', gps: 60000, click: 800000, prob: 0.003, growthRate: 0.60 },
            primeval: { name: '原初', gps: 100000, click: 2000000, prob: 0.002, growthRate: 0.70 },
            transcendental: { name: '超凡', gps: 5000000, click: 50000000, prob: 0.001, growthRate: 0.80 },
            quantum: { name: '量子', gps: 6000000, click: 80000000, prob: 0.0005, growthRate: 0.90 },
            ultimate: { name: '究极', gps: 10000000, click: 2000000000, prob: 0.0134, growthRate: 1.00 },
            chaos: { name: '混沌', gps: 50000000000, click: 500000000000, prob: 0.01, growthRate: 1.20 },
            eternal: { name: '永恒', gps: 60000000000, click: 80000000000000, prob: 0.01, growthRate: 1.50 },
           void: { name: '虚无', gps: 1000000000000, click: 2000000000000000, prob: 0.001, growthRate: 2.00 },
          genesis: { name: '创世', gps: 500000000000000, click: 60000000000000000, prob: 0.01, growthRate: 2.50 },
          divineRealm: { name: '神域', gps: 600000000000000, click: 80000000000000000, prob: 0.01, growthRate: 2.70 },
          apocalypse: { name: '终焉', gps: 1000000000000000, click: 200000000000000000, prob: 0.01, growthRate: 3.00 },
         yeyu1: { name: '星辰', gps: 50000000000000000000, click: 5000000000000000000000, prob: 0.0001, growthRate: 3.20 },
         yeyu2: { name: '起源', gps: 60000000000000000000, click: 60000000000000000000000, prob: 0.00005, growthRate: 3.50 },
         yeyu3: { name: '时光', gps: 100000000000000000000, click: 200000000000000000000000, prob: 0.00001, growthRate: 4.00 },
         yeyu4: { name: '造物', gps: 500000000000000000000000, click: 500000000000000000000000000, prob: 0.000005, growthRate: 4.20 },
         yeyu5: { name: '银河', gps: 600000000000000000000000, click: 600000000000000000000000000, prob: 0.000001, growthRate: 4.50 },
         yeyu6: { name: '天界', gps: 1000000000000000000000000, click: 1000000000000000000000000000, prob: 0.0000001, growthRate: 5.00 },
         yeyu7: { name: '星云', gps: 5000000000000000000000000000, click: 5000000000000000000000000000000, prob: 0.0000001, growthRate: 5.50 },
         yeyu8: { name: '星河', gps: 6000000000000000000000000000, click: 6000000000000000000000000000000, prob: 0.0000001, growthRate: 6.00 },
         yeyu9: { name: '纪元', gps: 10000000000000000000000000000, click: 10000000000000000000000000000000, prob: 0.0000001, growthRate: 6.50 }, 
         yeyu10: { name: '鸿蒙', gps: 500000000000000000000000000000000, click: 50000000000000000000000000000000000, prob: 0.0000001, growthRate: 7.00 },
         yeyu11: { name: '星穹', gps: 600000000000000000000000000000000, click: 60000000000000000000000000000000000, prob: 0.0000001, growthRate: 7.50 },
         yeyu12: { name: '亘古', gps: 1000000000000000000000000000000000, click: 100000000000000000000000000000000000, prob: 0.0000001, growthRate: 8.00 },
         yeyu13: { name: '万象', gps: 50000000000000000000000000000000000000, click: 500000000000000000000000000000000000, prob: 0.0000001, growthRate: 8.50 },
         yeyu14: { name: '太虚', gps: 60000000000000000000000000000000000000, click: 600000000000000000000000000000000000, prob: 0.0000001, growthRate: 9.00 },
         yeyu15: { name: '九垓', gps: 100000000000000000000000000000000000000, click: 1000000000000000000000000000000000000, prob: 0.0000001, growthRate: 9.50 },
          yeyu16: { name: '穿梭', gps: 10000000000000000000000000000000000000000, click: 100000000000000000000000000000000000000, prob: 0.0000001, growthRate: 10.00 },
         yeyu17: { name: '恒古', gps: 100000000000000000000000000000000000000000, click: 1000000000000000000000000000000000000000, prob: 0.0000001, growthRate: 10.50 },
         yeyu18: { name: '虚空', gps: 500000000000000000000000000000000000000000, click: 5000000000000000000000000000000000000000, prob: 0.0000001, growthRate: 11.00 },
         yeyu19: { name: '蔚来', gps: 100000000000000000000000000000000000000000000, click: 1000000000000000000000000000000000000000000, prob: 0.0000001, growthRate: 11.50 },
         yeyu20: { name: '神罚', gps: 1000000000000000000000000000000000000000000000, click: 10000000000000000000000000000000000000000000, prob: 0.0000001, growthRate: 12.00 },
         yeyu21: { name: '时空', gps: 5000000000000000000000000000000000000000000000, click: 50000000000000000000000000000000000000000000, prob: 0.0000001, growthRate: 12.50 },
         yeyu22: { name: '未来', gps: 1000000000000000000000000000000000000000000000000, click: 10000000000000000000000000000000000000000000000, prob: 0.0000001, growthRate: 13.00 },
         yeyu23: { name: '从前', gps: 10000000000000000000000000000000000000000000000000, click: 100000000000000000000000000000000000000000000000, prob: 0.0000001, growthRate: 13.50 },
         yeyu24: { name: '星澜', gps: 50000000000000000000000000000000000000000000000000, click: 50000000000000000000000000000000000000000000000000, prob: 0.0000001, growthRate: 14.00 }
        };

        // 副本装备配置
        const dungeonEquipmentTypes = {
            common: { name: '废品', growthRange: [0.00001, 0.0005] },
            rare: { name: '倚天剑', growthRange: [0.001, 0.10] },
            epic: { name: '青龙枪', growthRange: [0.001, 0.15] },
            legendary: { name: '白虎斧', growthRange: [0.001, 0.20] },
            ancient: { name: '朱雀弓', growthRange: [0.001, 0.25] },
            divine: { name: '玄武盾', growthRange: [0.001, 0.30] },
            arcane: { name: '麒麟杖', growthRange: [0.001, 0.35] },
            celestial: { name: '凤凰剑', growthRange: [0.001, 0.40] },
            infernal: { name: '饕餮刀', growthRange: [0.001, 0.45] },
            astral: { name: '穷奇戟', growthRange: [0.001, 0.50] },
            primeval: { name: '烛龙枪', growthRange: [0.001, 0.60] },
            transcendental: { name: '白泽剑', growthRange: [0.001, 0.70] },
            quantum: { name: '混沌斧', growthRange: [0.001, 0.80] },
            ultimate: { name: '太初刃', growthRange: [0.001, 0.90] },
            ultimate1: { name: '幻梦·洪荒刃☆', growthRange: [0.001, 1.00] },
            ultimate2: { name: '灵蕴神界剑★', growthRange: [0.001, 1.10] },
            ultimate3: { name: '蚀魂·地狱斧★★', growthRange: [0.001, 1.20] },
            ultimate4: { name: '蚀魂·暗夜枪★★★', growthRange: [0.001, 1.30] },
            ultimate5: { name: '遗梦·异界弓★★★★', growthRange: [0.001, 1.40] },
            ultimate6: { name: '幻月·现代盾★★★★★', growthRange: [0.001, 1.50] },
            ultimate7: { name: '寒星·风神杖★★★★★★', growthRange: [0.001, 1.60] },
            ultimate8: { name: '炎凤·雷霆戟★★★★★★★', growthRange: [0.001, 1.70] },
            ultimate9: { name: '雾霭·星辰刃★★★★★★★★', growthRange: [0.001, 1.80] },
            ultimate10: { name: '月尘·虚空斧★★★★★★★★', growthRange: [0.001, 1.90] },
            ultimate11: { name: '焚天·混沌枪○', growthRange: [0.001, 2.00] },
            ultimate12: { name: '焚天·永恒剑●', growthRange: [0.001, 2.10] },
            ultimate13: { name: '混沌·幽冥弓●●', growthRange: [0.001, 2.20] },
            ultimate14: { name: '星辰·天启盾●●●', growthRange: [0.001, 2.30] },
            ultimate15: { name: '太古·破晓杖●●●●', growthRange: [0.001, 2.40] },
            ultimate16: { name: '月尘·末日戟●●●●●', growthRange: [0.001, 2.50] },
            ultimate17: { name: '月尘·苍穹刃●●●●●●', growthRange: [0.001, 2.60] },
            ultimate18: { name: '流萤·幻影斧●●●●●●●', growthRange: [0.001, 2.70] },
            ultimate19: { name: '皓宇·天罚枪●●●●●●●●', growthRange: [0.001, 2.80] },
            ultimate20: { name: '灵幻·神罚剑●●●●●●●●●', growthRange: [0.001, 2.90] },
            ultimate21: { name: '炽阳·魔界弓◇', growthRange: [0.001, 3.00] },
            ultimate22: { name: '琥珀·圣光盾◆', growthRange: [0.001, 3.10] },
            ultimate23: { name: '紫霄·暗影杖◆◆', growthRange: [0.001, 3.20] },
            ultimate24: { name: '荒古·龙魂戟◆◆◆', growthRange: [0.001, 3.30] },
            ultimate25: { name: '破晓·天穹刃◆◆◆◆', growthRange: [0.001, 3.40] },
            ultimate26: { name: '星澜·炎狱斧◆◆◆◆◆', growthRange: [0.001, 3.50] },
            ultimate27: { name: '龙炎·神枪戟◆◆◆◆◆◆', growthRange: [0.001, 3.60] },
            ultimate28: { name: '鸿蒙·冥界剑◆◆◆◆◆◆◆', growthRange: [0.001, 3.70] },
            ultimate29: { name: '鸿蒙·天界弓◆◆◆◆◆◆◆◆', growthRange: [0.001, 3.80] },
            ultimate30: { name: '荒古·地狱盾◆◆◆◆◆◆◆◆◆', growthRange: [0.001, 3.90] },
            ultimate31: { name: '荒炎·太古杖□', growthRange: [0.001, 4.00] },
            ultimate32: { name: '荒炎·异界戟■', growthRange: [0.001, 4.10] },
            ultimate33: { name: '荒炎·现代刃■■', growthRange: [0.001, 4.20] },
            ultimate34: { name: '凤羽·风神斧■■■', growthRange: [0.001, 4.30] },
            ultimate35: { name: '荒炎·雷霆枪■■■■', growthRange: [0.001, 4.40] },
            ultimate36: { name: '荒炎·星辰剑■■■■■', growthRange: [0.001, 4.50] },
            ultimate37: { name: '虚空·玄冰弓■■■■■■', growthRange: [0.001, 4.60] },
            ultimate38: { name: '虚空·混沌盾■■■■■■■', growthRange: [0.001, 4.70] },
            ultimate39: { name: '虚空·永恒杖■■■■■■■■', growthRange: [0.001, 4.80] },
            ultimate40: { name: '虚空·幽冥戟■■■■■■■■■', growthRange: [0.001, 4.90] },
            ultimate41: { name: '天启·穿越刃△', growthRange: [0.001, 5.00] },
            ultimate42: { name: '天启·破晓斧▲', growthRange: [0.001, 5.10] },
            ultimate43: { name: '时空·末日枪▲▲', growthRange: [0.001, 5.20] },
            ultimate44: { name: '九幽·苍穹剑▲▲▲', growthRange: [0.001, 5.30] },
            ultimate45: { name: '幻影·雷电弓▲▲▲▲', growthRange: [0.001, 5.40] },
            ultimate46: { name: '天罚·雷霆盾▲▲▲▲▲', growthRange: [0.001, 5.50] },
            ultimate47: { name: '神罚·雷霆杖▲▲▲▲▲▲', growthRange: [0.001, 5.60] },
            ultimate48: { name: '魔界·邪战戟▲▲▲▲▲▲▲', growthRange: [0.001, 5.70] },
            ultimate49: { name: '圣光·灭世剑▲▲▲▲▲▲▲▲', growthRange: [0.001, 5.80] },
            ultimate50: { name: '宇宙·神王剑▲▲▲▲▲▲▲▲▲', growthRange: [0.001, 5.90] }      
        };

        // 宝箱概率配置
        const chestProbabilities = {
    1: [ { rarity: 'common', prob: 0.8 }, { rarity: 'rare', prob: 0.2 } ],
    2: [ { rarity: 'rare', prob: 0.8 }, { rarity: 'epic', prob: 0.14 }, { rarity: 'legendary', prob: 0.05 }, { rarity: 'ancient', prob: 0.01 } ],
    3: [ { rarity: 'ancient', prob: 0.8 }, { rarity: 'divine', prob: 0.14 }, { rarity: 'arcane', prob: 0.05 }, { rarity: 'celestial', prob: 0.01 } ],
    4: [ { rarity: 'celestial', prob: 0.8 }, { rarity: 'infernal', prob: 0.14 }, { rarity: 'astral', prob: 0.05 }, { rarity: 'primeval', prob: 0.01 } ],
    5: [ { rarity: 'primeval', prob: 0.8 }, { rarity: 'transcendental', prob: 0.14 }, { rarity: 'quantum', prob: 0.05 }, { rarity: 'ultimate', prob: 0.01 } ],
    6: [ { rarity: 'ultimate', prob: 0.8 }, { rarity: 'chaos', prob: 0.14 }, { rarity: 'eternal', prob: 0.05 }, { rarity: 'void', prob: 0.01 } ],
    7: [ { rarity: 'void', prob: 0.8 }, { rarity: 'genesis', prob: 0.14 }, { rarity: 'divineRealm', prob: 0.05 }, { rarity: 'apocalypse', prob: 0.01 } ],
    8: [ { rarity: 'apocalypse', prob: 0.8 }, { rarity: 'yeyu1', prob: 0.14 }, { rarity: 'yeyu2', prob: 0.05 }, { rarity: 'yeyu3', prob: 0.01 } ],
    9: [ { rarity: 'yeyu3', prob: 0.8 }, { rarity: 'yeyu4', prob: 0.14 }, { rarity: 'yeyu5', prob: 0.05 }, { rarity: 'yeyu6', prob: 0.01 } ],
    10: [ { rarity: 'yeyu6', prob: 0.8 }, { rarity: 'yeyu7', prob: 0.14 }, { rarity: 'yeyu8', prob: 0.05 }, { rarity: 'yeyu9', prob: 0.01 } ],
    11: [ { rarity: 'yeyu9', prob: 0.8 }, { rarity: 'yeyu10', prob: 0.14 }, { rarity: 'yeyu11', prob: 0.05 }, { rarity: 'yeyu12', prob: 0.01 } ],
    12: [ { rarity: 'yeyu12', prob: 0.8 }, { rarity: 'yeyu13', prob: 0.14 }, { rarity: 'yeyu14', prob: 0.05 }, { rarity: 'yeyu15', prob: 0.01 } ],
    13: [ { rarity: 'yeyu15', prob: 0.8 }, { rarity: 'yeyu16', prob: 0.14 }, { rarity: 'yeyu17', prob: 0.05 }, { rarity: 'yeyu18', prob: 0.01 } ],
    14: [ { rarity: 'yeyu18', prob: 0.8 }, { rarity: 'yeyu19', prob: 0.14 }, { rarity: 'yeyu20', prob: 0.05 }, { rarity: 'yeyu21', prob: 0.01 } ],
    15: [ { rarity: 'yeyu21', prob: 0.8 }, { rarity: 'yeyu22', prob: 0.14 }, { rarity: 'yeyu23', prob: 0.05 }, { rarity: 'yeyu24', prob: 0.01 } ]
};

        // 宠物配置
        const petConfig = {
            thunderKirin: { name: '苍雷麒麟', currency: 'gold', multiplier: 0.10 }, 
            chaosTaotie: { name: '混沌饕餮', currency: 'diamond', multiplier: 0.50 }, 
            netherQiongqi: { name: '九幽穷奇', currency: 'titanium', multiplier: 2.50 }, 
            abyssKun: { name: '霸渊巨鲲', currency: 'starstone', multiplier: 12.50 }, 
            primordialZhuLong: { name: '太初烛龙', currency: 'cosmicstone', multiplier: 62.50 }, 
        wanJunSuanNi: { name: '万钧狻猊', currency: 'superstone', multiplier: 312.50 }, 
          yanYuBiAn: { name: '炎狱狴犴', currency: 'otherworldstone', multiplier: 1562.50 }, 
          yuyu1: { name: '赤霄夔龙', currency: 'xingjiestone', multiplier: 7812.50 }, 
          yuyu2: { name: '震岳白泽', currency: 'hundunstone', multiplier: 39062.50 }, 
         yuyu3: { name: '焚天蛊雕', currency: 'lingtone', multiplier: 195312.50 }, 
         yuyu4: { name: '血煞梼杌', currency: 'huangtone', multiplier: 976562.50 }, 
        yuyu5: { name: '玄渊白犼', currency: 'mingtone', multiplier: 5882812.50 },
         yuyu6: { name: '灾祸蜚牛', currency: 'xutong', multiplier: 29414062.50 }, 
         yuyu7: { name: '寂灭罗睺', currency: 'shitone', multiplier: 147070312.50 }, 
        yuyu8: { name: '永劫蚩尤', currency: 'weitone', multiplier: 735351562.50 } 
     };

        // 魂环配置
        const soulRingTypes = {
            year1: { name: '一年魂环', baseMult: 0.02, costBase: 1000 },
            year10: { name: '十年魂环', baseMult: 0.05, costBase: 1000 },
            year100: { name: '百年魂环', baseMult: 0.08, costBase: 1000 },
            year1000: { name: '千年魂环', baseMult: 0.10, costBase: 1000 },
            year10000: { name: '万年魂环', baseMult: 0.12, costBase: 1000 },
            year100000: { name: '十万年魂环', baseMult: 0.15, costBase: 1000 },
            year1000000: { name: '百万年魂环', baseMult: 0.18, costBase: 1000 },
            year10000000: { name: '千万年魂环', baseMult: 0.20, costBase: 1000 },
            year100000000: { name: '亿年魂环', baseMult: 0.25, costBase: 1000 },
            year2: { name: '太古·混沌亿年魂环', baseMult: 0.30, costBase: 1000 },
            year3: { name: '鸿蒙·始源亿年魂环', baseMult: 0.35, costBase: 1000 },
            year4: { name: '亘古·时空亿年魂环', baseMult: 0.40, costBase: 1000 },
            year5: { name: '九幽·冥渊亿年魂环', baseMult: 0.45, costBase: 1000 },
            year6: { name: '皓宇·星辰亿年魂环', baseMult: 0.50, costBase: 1000 },
            year7: { name: '炎狱·焚天亿年魂环', baseMult: 0.55, costBase: 1000 },
            year8: { name: '霜烬·极寒亿年魂环', baseMult: 0.60, costBase: 1000 },
            year9: { name: '灵幻·万象亿年魂环', baseMult: 0.65, costBase: 1000 },
            year11: { name: '炽阳·耀世亿年魂环', baseMult: 0.70, costBase: 1000 },
            year12: { name: '暗蚀·灭世亿年魂环', baseMult: 0.75, costBase: 1000 },
            year13: { name: '圣辉·救赎亿年魂环', baseMult: 0.80, costBase: 1000 },
            year14: { name: '紫霄·雷罚亿年魂环', baseMult: 0.85, costBase: 1000 },
            year15: { name: '青木·生机亿年魂环', baseMult: 0.90, costBase: 1000 },
            year16: { name: '星澜·幻梦亿年魂环', baseMult: 0.95, costBase: 1000 },
            year17: { name: '渊海·无尽亿年魂环', baseMult: 1.00, costBase: 1000 },
            year18: { name: '荒古·遗世亿年魂环', baseMult: 1.10, costBase: 1000 },
            year19: { name: '净世·光明亿年魂环', baseMult: 1.20, costBase: 1000 },
            year20: { name: '蚀灵·诅咒亿年魂环', baseMult: 1.30, costBase: 1000 },
            year21: { name: '逆乱·时空亿年魂环', baseMult: 1.40, costBase: 1000 },
            year22: { name: '龙渊·霸者亿年魂环', baseMult: 1.50, costBase: 1000 },
            year23: { name: '凤羽·炎舞亿年魂环', baseMult: 1.60, costBase: 1000 },
            year24: { name: '星辰·命数亿年魂环', baseMult: 1.70, costBase: 1000 },
            year25: { name: '荒炎·破灭亿年魂环', baseMult: 1.80, costBase: 1000 },
            year26: { name: '玄冰·永冻亿年魂环', baseMult: 1.90, costBase: 1000 },
            year27: { name: '灵犀·心眼亿年魂环', baseMult: 2.00, costBase: 1000 },
            year28: { name: '圣谕·裁决亿年魂环', baseMult: 2.10, costBase: 1000 },
            year29: { name: '九幽·黄泉亿年魂环', baseMult: 2.20, costBase: 1000 },
            year30: { name: '灵蕴·造化亿年魂环', baseMult: 2.30, costBase: 1000 },
            year31: { name: '混沌·元始亿年魂环', baseMult: 2.40, costBase: 1000 },
            year32: { name: '苍穹·御天亿年魂环', baseMult: 2.50, costBase: 1000 },
            year33: { name: '龙炎·焚天亿年魂环', baseMult: 2.60, costBase: 1000 }, 
            year34: { name: '血狱·魔神亿年魂环', baseMult: 2.70, costBase: 1000 },  
            year35: { name: '赤霄·苍穹亿年魂环', baseMult: 2.80, costBase: 1000 },
            year36: { name: '炎凤·涅槃亿年魂环', baseMult: 2.90, costBase: 1000 },
            year37: { name: '闫闫·黑丝亿年魂环', baseMult: 3.00, costBase: 1000 }
        };
           const TECHNIQUE_DISPLAY_ORDER = [
    // 生命类（防御型）
    "immortalAsuraBody",       // 不灭修罗体
    "eightDesolationsWarDemonBody", // 八荒战魔躯
    "nineRevolutionsProfoundBody",  // 九转玄黄身
    "loneDestinyBone",         // 天煞孤星骨
    "bloodPrisonMadGodArmor",  // 血狱狂神铠
    
    // 攻击类（输出型）
    "godSlayingBurningHeavenArt",  // 弑神焚天诀
    "burialHeavenBladePrisonManual", // 葬天刀狱谱
    "tenDirectionsAnnihilationSpearCodex", // 十方俱灭枪典
    "thousandCalamitiesVoidArrowArt", // 千劫裂空箭术
    "ancientAnnihilationHalberdArt", // 万古寂灭戟法
    
    // 暴击类
    "nineHeavensThunderboltTruth", // 九霄雷殛真解
    "netherBloodSeaDiagram",    // 幽冥血海图录
    "riverStarsHangingSecretScroll", // 星河倒悬秘卷
    "eightDesolationsFireDragonRecord", // 八荒火龙焚世录
    "iceSealThreeThousandRealmArt", // 冰封三千界心法
    
    // 爆伤类
    "nineCalamitiesWorldDestroyingPalm", // 九劫灭世掌
    "chaosCreationForce",      // 混沌开天劲
    "dragonElephantShatteringVoidArt", // 龙象碎穹功
    "greatSunFallingStarFist", // 大日陨星拳
    
    // 特殊效果类（连击/多段攻击）
    "greatVoidReturnToVoidCodex", // 太虚归墟典
    "samsaraCalamityAnnihilationSutra", // 轮回劫灭经
    "yinYangReversalArt",      // 阴阳逆命术
    "zhouHeavenStarsFallingWay", // 周天星陨道
    "ancientVoidRecord"        // 万古空冥录
];
   const DUNGEON_EQUIPMENT_ORDER = [
    'common',     
    'rare',       
    'epic',       
    'legendary',  
    'ancient',    
    'divine',    
    'arcane',     
    'celestial',  
    'infernal',  
    'astral',     
    'primeval',  
    'transcendental', 
    'quantum',   
    'ultimate',
    'yeyu1',
    'yeyu2',     
    'yeyu3',  
    'yeyu4', 
    'yeyu5',
    'yeyu6',  
     'yeyu7',
    'yeyu8',     
    'yeyu9',  
    'yeyu10', 
    'yeyu11',
    'yeyu12',  
     'yeyu13',
    'yeyu14',     
    'yeyu15',  
   'yeyu16',
    'yeyu17',  
     'yeyu18',
    'yeyu19',     
    'yeyu20',  
    'yeyu21', 
    'yeyu22',
    'yeyu23',  
     'yeyu24', 
    'ultimate1',     
    'ultimate2',   
    'ultimate3',       
    'ultimate4',   
    'ultimate5', 
    'ultimate6',    
    'ultimate7',     
    'ultimate8',   
    'ultimate9',       
    'ultimate10',   
    'ultimate11', 
    'ultimate12',     
    'ultimate13',     
    'ultimate14',   
    'ultimate15',       
    'ultimate16',   
    'ultimate17', 
    'ultimate18',   
    'ultimate19',     
    'ultimate20',   
    'ultimate21',       
    'ultimate22',   
    'ultimate23', 
    'ultimate24',   
    'ultimate25',   
    'ultimate26',       
    'ultimate27',   
    'ultimate28', 
    'ultimate29',     
    'ultimate30',     
    'ultimate31',   
    'ultimate32',       
    'ultimate33',   
    'ultimate34', 
    'ultimate35',     
    'ultimate36',     
    'ultimate37',   
    'ultimate38',       
    'ultimate39',   
    'ultimate40', 
    'ultimate41',    
    'ultimate42',     
    'ultimate43',   
    'ultimate44',       
    'ultimate45',   
    'ultimate46', 
    'ultimate47', 
    'ultimate48',   
    'ultimate49', 
    'ultimate50'
];

// 切换自动转生状态
function toggleAutoReincarnation() {
    player.autoReincarnation = !player.autoReincarnation;
    document.getElementById('autoReincarnationStatus').textContent = player.autoReincarnation ? '开启' : '关闭';
    logAction(`自动转生已${player.autoReincarnation ? '开启' : '关闭'}`, 'info');
}

// 切换自动转生状态
function toggleAutoReincarnation() {
    player.autoReincarnation = !player.autoReincarnation;
    document.getElementById('autoReincarnationStatus').textContent = player.autoReincarnation ? '开启' : '关闭';
    logAction(`自动转生已${player.autoReincarnation ? '开启' : '关闭'}`, 'info');
}

// 检查自动转生条件
function checkAutoReincarnation() {
    if (!player.autoReincarnation) return;
    
    // 计算当前转生所需的总等级
    const requiredLevel = 10000 + player.reincarnationCount * 20;
    
    // 计算所有普通装备的总等级
    const totalCommonLevel = player.equipment
        .filter(eq => eq.rarity === 'common')
        .reduce((sum, eq) => sum + eq.level, 0);
    
    if (totalCommonLevel >= requiredLevel) {
        // 直接执行转生逻辑，不弹出确认对话框
        autoReincarnate();
    }
}

// 自动转生逻辑（不弹出确认对话框）
function autoReincarnate() {
    // 计算当前转生所需的总等级
    const requiredLevel = 10000 + player.reincarnationCount * 20;
    
    // 计算所有普通装备的总等级
    const totalCommonLevel = player.equipment
        .filter(eq => eq.rarity === 'common')
        .reduce((sum, eq) => sum + eq.level, 0);
    
    if (totalCommonLevel < requiredLevel) {
        logAction(`自动转生失败：普通装备总等级不足（需要${requiredLevel}级，当前${totalCommonLevel}级）`, "error");
        return;
    }

    let totalReincarnationCoin = 0;

    // 计算转生币奖励
    player.equipment.forEach(eq => {
        switch (eq.rarity) {
            case 'common':
                totalReincarnationCoin += eq.level * 0.0001;
                break;
            case 'rare':
                totalReincarnationCoin += eq.level * 0.0002;
                break;
            case 'epic':
                totalReincarnationCoin += eq.level * 0.001;
                break;
            case 'legendary':
                totalReincarnationCoin += eq.level * 0.003;
                break;
            case 'ancient':
                totalReincarnationCoin += eq.level * 0.005;
                break;
            case 'divine':
                totalReincarnationCoin += eq.level * 0.008;
                break;
            case 'arcane':
                totalReincarnationCoin += eq.level * 0.01;
                break;
            case 'celestial':
                totalReincarnationCoin += eq.level * 0.03;
                break;
            case 'infernal':
                totalReincarnationCoin += eq.level * 0.05;
                break;
            case 'astral':
                totalReincarnationCoin += eq.level * 0.08;
                break;
            case 'primeval':
                totalReincarnationCoin += eq.level * 0.1;
                break;
            case 'transcendental':
                totalReincarnationCoin += eq.level * 0.3;
                break;
            case 'quantum':
                totalReincarnationCoin += eq.level * 0.5;
                break;
            case 'ultimate':
                totalReincarnationCoin += eq.level * 1.0;
                break;
            case 'chaos':
                totalReincarnationCoin += eq.level * 3.0;
                break;
            case 'eternal':
                totalReincarnationCoin += eq.level * 5.0;
                break;
            case 'void':
                totalReincarnationCoin += eq.level * 10.0;
                break;
            case 'genesis':
                totalReincarnationCoin += eq.level * 20.0;
                break;
            case 'divineRealm':
                totalReincarnationCoin += eq.level * 30.0;
                break;
            case 'apocalypse':
                totalReincarnationCoin += eq.level * 40.0;
                break;
            case 'yeyu1':
                totalReincarnationCoin += eq.level * 50.0;
                break;
            case 'yeyu2':
                totalReincarnationCoin += eq.level * 60.0;
                break;
            case 'yeyu3':
                totalReincarnationCoin += eq.level * 70.0;
                break;
            case 'yeyu4':
                totalReincarnationCoin += eq.level * 80.0;
                break;
            case 'yeyu5':
                totalReincarnationCoin += eq.level * 90.0;
                break;
            case 'yeyu6':
                totalReincarnationCoin += eq.level * 100.0;
                break;
            case 'yeyu7':
                totalReincarnationCoin += eq.level * 200.0;
                break;
            case 'yeyu8':
                totalReincarnationCoin += eq.level * 300.0;
                break;
            case 'yeyu9':
                totalReincarnationCoin += eq.level * 400.0;
                break;
            case 'yeyu10':
                totalReincarnationCoin += eq.level * 500.0;
                break;
            case 'yeyu11':
                totalReincarnationCoin += eq.level * 600.0;
                break;
            case 'yeyu12':
                totalReincarnationCoin += eq.level * 700.0;
                break;
            case 'yeyu13':
                totalReincarnationCoin += eq.level * 800.0;
                break;
            case 'yeyu14':
                totalReincarnationCoin += eq.level * 900.0;
                break;
            case 'yeyu15':
                totalReincarnationCoin += eq.level * 1000.0;
                break;
            case 'yeyu16':
                totalReincarnationCoin += eq.level * 2000.0;
                break;
            case 'yeyu17':
                totalReincarnationCoin += eq.level * 3000.0;
                break;
            case 'yeyu18':
                totalReincarnationCoin += eq.level * 4000.0;
                break;
            case 'yeyu19':
                totalReincarnationCoin += eq.level * 5000.0;
                break;
            case 'yeyu20':
                totalReincarnationCoin += eq.level * 6000.0;
                break;
            case 'yeyu21':
                totalReincarnationCoin += eq.level * 7000.0;
                break;
            case 'yeyu22':
                totalReincarnationCoin += eq.level * 8000.0;
                break;
            case 'yeyu23':
                totalReincarnationCoin += eq.level * 9000.0;
                break;
            case 'yeyu24':
                totalReincarnationCoin += eq.level * 10000.0;
                break;
        }
    });

    // 重置装备等级
    player.equipment.forEach(eq => {
        eq.level = 1 + player.reincarnationStats.equipmentLevelBonus.level * 200; // 转生属性加成
        eq.gps = equipmentTypes[eq.rarity].gps * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
        eq.click = equipmentTypes[eq.rarity].click * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
    });

    // 清空货币
    player.gold = 0;
    player.diamond = 0;
    player.titanium = 0;
    player.starstone = 0;
    player.cosmicstone = 0;
    player.superstone = 0;
    player.otherworldstone = 0;
    player.xingjiestone = 0;
    player.hundunstone = 0;
    player.lingtone = 0;
    player.huangtone = 0;
    player.mingtone = 0;
    player.xutong = 0;
    player.shitone = 0;
    player.weitone = 0;   
 // 重置材料宝箱购买成本
            player.materialChestCost = 1;
            player.techniqueChestCost = 1;
    // 增加转生币
    player.reincarnationCoin += totalReincarnationCoin;
    player.reincarnationCount++;
 player.autoBuyTechniqueChest = true;
    // 修改属性点计算逻辑
    player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
    player.attributes.remainingPoints += 1; // 每次转生增加1点剩余属性点

    // 检查转生成就
    checkReincarnationAchievements();

    logAction(`自动转生成功！获得转生币: ${totalReincarnationCoin.toFixed(4)}`, 'success');
    updateDisplay();
    updateTechniqueBonuses(); // 转生后更新功法加成
    updatePlayerBattleStats(); // 更新战斗属性
}


        // 转生系统
        function reincarnate() {
   // 计算当前转生所需的总等级
    const requiredLevel = 10000 + player.reincarnationCount * 20;
    
    // 计算所有普通装备的总等级
    const totalCommonLevel = player.equipment
        .filter(eq => eq.rarity === 'common')
        .reduce((sum, eq) => sum + eq.level, 0);
    
    if (totalCommonLevel < requiredLevel) {
        logAction(`转生需要普通装备总等级达到${requiredLevel}级（当前${totalCommonLevel}级）！`, "error");
        return;
    }

    showCustomConfirm(`确定要转生吗？需要普通装备总等级≥${requiredLevel}级，所有装备等级将重置为1级，货币将被清空！`, (confirmed) => {
        if (confirmed) {
            let totalReincarnationCoin = 0;

            // 计算转生币奖励
            player.equipment.forEach(eq => {
                switch (eq.rarity) {
                    case 'common':
                        totalReincarnationCoin += eq.level * 0.0001;
                        break;
                    case 'rare':
                        totalReincarnationCoin += eq.level * 0.0002;
                        break;
                    case 'epic':
                        totalReincarnationCoin += eq.level * 0.001;
                        break;
                    case 'legendary':
                        totalReincarnationCoin += eq.level * 0.003;
                        break;
                    case 'ancient':
                        totalReincarnationCoin += eq.level * 0.005;
                        break;
                    case 'divine':
                        totalReincarnationCoin += eq.level * 0.008;
                        break;
                    case 'arcane':
                        totalReincarnationCoin += eq.level * 0.01;
                        break;
                    case 'celestial':
                        totalReincarnationCoin += eq.level * 0.03;
                        break;
                    case 'infernal':
                        totalReincarnationCoin += eq.level * 0.05;
                        break;
                    case 'astral':
                        totalReincarnationCoin += eq.level * 0.08;
                        break;
                    case 'primeval':
                        totalReincarnationCoin += eq.level * 0.1;
                        break;
                    case 'transcendental':
                        totalReincarnationCoin += eq.level * 0.3;
                        break;
                    case 'quantum':
                        totalReincarnationCoin += eq.level * 0.5;
                        break;
                    case 'ultimate':
                        totalReincarnationCoin += eq.level * 1.0;
                        break;
                    case 'chaos':
                        totalReincarnationCoin += eq.level * 3.0;
                        break;
                   case 'eternal':
                        totalReincarnationCoin += eq.level * 5.0;
                        break;
                   case 'void':
                        totalReincarnationCoin += eq.level * 10.0;
                        break;
                   case 'genesis':
                        totalReincarnationCoin += eq.level * 20.0;
                        break;
                   case 'divineRealm':
                        totalReincarnationCoin += eq.level * 30.0;
                        break;
                   case 'apocalypse':
                        totalReincarnationCoin += eq.level * 40.0;
                        break;
                    case 'yeyu1':
                        totalReincarnationCoin += eq.level * 50.0;
                        break;
                    case 'yeyu2':
                        totalReincarnationCoin += eq.level * 60.0;
                        break;
                     case 'yeyu3':
                        totalReincarnationCoin += eq.level * 70.0;
                        break;
                     case 'yeyu4':
                        totalReincarnationCoin += eq.level * 80.0;
                        break;
                     case 'yeyu5':
                        totalReincarnationCoin += eq.level * 90.0;
                        break;
                     case 'yeyu6':
                        totalReincarnationCoin += eq.level * 100.0;
                        break;
                    case 'yeyu7':
                        totalReincarnationCoin += eq.level * 200.0;
                        break;
                    case 'yeyu8':
                        totalReincarnationCoin += eq.level * 300.0;
                        break;
                     case 'yeyu9':
                        totalReincarnationCoin += eq.level * 400.0;
                        break;
                     case 'yeyu10':
                        totalReincarnationCoin += eq.level * 500.0;
                        break;
                     case 'yeyu11':
                        totalReincarnationCoin += eq.level * 600.0;
                        break;
                     case 'yeyu12':
                        totalReincarnationCoin += eq.level * 700.0;
                        break; 
                       case 'yeyu13':
                        totalReincarnationCoin += eq.level * 800.0;
                        break;
                    case 'yeyu14':
                        totalReincarnationCoin += eq.level * 900.0;
                        break;
                     case 'yeyu15':
                        totalReincarnationCoin += eq.level * 1000.0;
                        break;
                    case 'yeyu16':
                        totalReincarnationCoin += eq.level * 2000.0;
                        break;
                    case 'yeyu17':
                        totalReincarnationCoin += eq.level * 3000.0;
                        break;
                     case 'yeyu18':
                        totalReincarnationCoin += eq.level * 4000.0;
                        break;
                     case 'yeyu19':
                        totalReincarnationCoin += eq.level * 5000.0;
                        break;
                     case 'yeyu20':
                        totalReincarnationCoin += eq.level * 6000.0;
                        break;
                     case 'yeyu21':
                        totalReincarnationCoin += eq.level * 7000.0;
                        break; 
                       case 'yeyu22':
                        totalReincarnationCoin += eq.level * 8000.0;
                        break;
                    case 'yeyu23':
                        totalReincarnationCoin += eq.level * 9000.0;
                        break;
                     case 'yeyu24':
                        totalReincarnationCoin += eq.level * 10000.0;
                        break;
                }
            });

            // 重置装备等级
            player.equipment.forEach(eq => {
                eq.level = 1 + player.reincarnationStats.equipmentLevelBonus.level * 200; // 转生属性加成
                eq.gps = equipmentTypes[eq.rarity].gps * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
                eq.click = equipmentTypes[eq.rarity].click * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
            });

            // 清空货币
            player.gold = 0;
            player.diamond = 0;
            player.titanium = 0;
            player.starstone = 0;
            player.cosmicstone = 0;
            player.superstone = 0;
            player.otherworldstone = 0;
            player.xingjiestone = 0;
            player.hundunstone = 0;
            player.lingtone = 0;
            player.huangtone = 0;
            player.mingtone = 0;
            player.xutong = 0;
            player.shitone = 0;
            player.weitone = 0;

            // 重置材料宝箱购买成本
            player.materialChestCost = 1;
            player.techniqueChestCost = 1;

            // 增加转生币
            player.reincarnationCoin += totalReincarnationCoin;
            player.reincarnationCount++;
            player.autoBuyTechniqueChest = true;
            // 修改属性点计算逻辑
            player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
            player.attributes.remainingPoints += 1; // 每次转生增加1点剩余属性点

            // 检查转生成就
            checkReincarnationAchievements();
       
            logAction(`转生成功！获得转生币: ${totalReincarnationCoin.toFixed(4)}`, 'success');
            updateDisplay();
            updateTechniqueBonuses(); // 转生后更新功法加成
            updatePlayerBattleStats(); // 更新战斗属性
        }
    });
}
        // 检查转生成就
        function checkReincarnationAchievements() {
            const achievements = [
                { count: 10, key: 'reincarnation_10' },
                { count: 100, key: 'reincarnation_100' },
                { count: 1000, key: 'reincarnation_1000' },
                { count: 10000, key: 'reincarnation_10000' }
            ];

            achievements.forEach(({ count, key }) => {
                if (player.reincarnationCount >= count && !player.achievements[key]) {
                    player.achievements[key] = true;
                    const reward = achievementRewards[key];
                    if (reward) {
                        player.gpsMultiplier += reward.gpsMultiplier;
                        logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                        updateAchievementsDisplay();
                    }
                }
            });
        }
      function showActivationCodeDialog() {
    document.getElementById("activationCodeDialog").style.display = "block";
    document.getElementById("activationCodeOverlay").style.display = "block";
    document.getElementById("activationCodeInput").focus();
}

function cancelActivationCode() {
    document.getElementById("activationCodeDialog").style.display = "none";
    document.getElementById("activationCodeOverlay").style.display = "none";
}

function confirmActivationCode() {
    const code = document.getElementById("activationCodeInput").value.trim().toUpperCase();
    const usedCodes = player.usedActivationCodes || [];
    
    if (!code) {
        logAction("请输入激活码", "error");
        return;
    }
    
    if (usedCodes.includes(code)) {
        logAction("该激活码已使用过", "error");
        cancelActivationCode();
        return;
    }
    
    let rewardMsg = "";
    let success = false;
    
    switch(code) {
        case "VIP666":
            player.reincarnationCoin += 1000;
            rewardMsg = "获得1000转生币";
            success = true;
            break;
        case "VIP777":
            // 假设洗炼石字段为refineStone，若实际字段不同请修改
            player.items.refineStone = (player.items.refineStone || 0) + 10;
            rewardMsg = "获得10个洗炼石";
            success = true;
            break;
        case "VIP888":
            player.items.advancedGem = (player.items.advancedGem || 0) + 3;
            rewardMsg = "获得3个高级宝石";
            success = true;
            break;
        case "XINGBI":
            player.nightClub.starCoins = (player.nightClub.starCoins || 0) + 300;
            rewardMsg = "获得300星币";
            success = true;
            break;
        case "YUYU":
            player.cosmicstone += 2;
            rewardMsg = "获得2个宇宙石";
            success = true;
            break;
       case "BANLV":
            player.items.companionKey += 10; 
            player.items.rose += 520;
            rewardMsg = "获得10个伴侣钥匙和520朵玫瑰花";
            success = true;
            break;  
          case "BANLV1":
            player.items.companionKey += 30; 
            player.items.rose += 520;
            rewardMsg = "获得30个伴侣钥匙和520朵玫瑰花";
            success = true;
            break;     
          case "XISUIDAN":
            player.items.rebornDan = (player.items.rebornDan || 0) + 10;
            rewardMsg = "获得10个洗髓丹";
            success = true;
            break;
           case "XIUXIAN":
            player.items.rootDetector = (player.items.rootDetector || 0) + 5;
            rewardMsg = "获得5个灵根检测器";
            success = true;
            break;
            case "XIUXIAN1":
            player.items.bloodlineDetector = (player.items.bloodlineDetector || 0) + 5;
            rewardMsg = "获得5个血脉检测剂";
            success = true;
            break;
           case "WOYAOCHE":
            const models = ["Portofino", "Roma", "SF90"];
            const randomModel = models[Math.floor(Math.random() * models.length)];
            const newVehicle = {
                id: 'vehicle_' + Date.now(),
                brand: "法拉利",
                model: randomModel,
                rarity: 15, // 普通稀有度
                parkTime: 0,
                income: 0
            };
            
            player.parking.vehicles.push(newVehicle);
            rewardMsg = `获得一辆法拉利${randomModel}汽车`;
            success = true;
            break;
        case "YUER":
            player.items.baitCount = (player.items.baitCount || 0) + 20;
            rewardMsg = "获得20个鱼饵";
            success = true;
            break;
        case "VIP666666":
        player.items.vipPower = (player.items.vipPower || 0) + 10;
        rewardMsg = "获得10个VIP能力值";
        success = true;
        break;
       case "VIP666777":
            // 添加"公测玩家"称号
            if (!player.titles.unlocked.includes("公测玩家")) {
                player.titles.unlocked.push("公测玩家");
                rewardMsg = "获得称号：公测玩家";
                success = true;
                // 自动选择新称号
                player.titles.current = "公测玩家";
                updateDisplay();
            } else {
                logAction("您已拥有此称号", "info");
            }
            break;
        case "补偿宝石损失":
        player.items.divineGem = (player.items.divineGem || 0) + 1;
        rewardMsg = "获得1个神级宝石";
        success = true;
        break;
        default:
            logAction("无效的激活码", "error");
            return;
    }
    
    if (success) {
        // 记录已使用的激活码
        usedCodes.push(code);
        player.usedActivationCodes = usedCodes;
        
        logAction(`激活码兑换成功：${rewardMsg}`, "success");
        updateDisplay(); // 更新界面显示
        cancelActivationCode();
         saveGame();
      setTimeout(() => {
                location.reload(true);
            }, 1000);
    }
}
// 添加VIP等级计算函数
function calculateVipLevel() {
    let currentLevel = 1;
    const { power } = player.vip;
    
    for (let i = vipConfig.length - 1; i >= 0; i--) {
        if (power >= vipConfig[i].requiredPower) {
            currentLevel = vipConfig[i].level;
            break;
        }
    }
    
    return currentLevel;
}

// 获取当前VIP等级的加成
function getVipBonus() {
    const level = player.vip.level;
    const config = vipConfig.find(c => c.level === level) || vipConfig[0];
    return config.bonus;
}

// 更新VIP显示
function updateVipDisplay() {
    const { level, power } = player.vip;
    const currentConfig = vipConfig.find(c => c.level === level) || vipConfig[0];
    const nextConfig = vipConfig.find(c => c.level === level + 1);
    
    document.getElementById('vipLevel').textContent = level;
    
    let progressPercent = 0;
    let progressText = '';
    
    if (nextConfig) {
        const progress = power - currentConfig.requiredPower;
        const total = nextConfig.requiredPower - currentConfig.requiredPower;
        progressPercent = Math.min(100, (progress / total) * 100);
        progressText = `${progress}/${total}`;
    } else {
        progressPercent = 100;
        progressText = '已达最高级';
    }
    
    document.getElementById('vipProgressBar').style.width = `${progressPercent}%`;
    document.getElementById('vipProgressText').textContent = progressText;
    
    // 设置VIP等级渐变色
    const hue = (level - 1) * (360 / 20); // 从0到360度的色相渐变
    document.querySelector('.vip-level-display').style.background = `linear-gradient(to right, hsl(${hue}, 100%, 50%), hsl(${(hue + 60) % 360}, 100%, 50%))`;
    document.querySelector('.vip-level-display').style.webkitBackgroundClip = 'text';
}
function useAllVipPower() {
    if (player.items.vipPower && player.items.vipPower > 0) {
        const useCount = player.items.vipPower;
        player.items.vipPower = 0;
        player.vip.power += useCount;
        
        const newLevel = calculateVipLevel();
        if (newLevel > player.vip.level) {
            const oldLevel = player.vip.level;
            player.vip.level = newLevel;
            logAction(`VIP等级提升至${newLevel}级！全属性装备提升${vipConfig[newLevel - 1].bonus * 100}%`, 'success');
            
            // 刷新所有装备属性
            const newVipBonus = 1 + getVipBonus();
            player.equipment.forEach(eq => {
                eq.gps = safeNumber(eq.gps / (1 + getVipBonusByLevel(oldLevel)) * newVipBonus); 
                eq.click = safeNumber(eq.click / (1 + getVipBonusByLevel(oldLevel)) * newVipBonus);
            });
        }
        
        updateVipDisplay();
        updateDisplay();
        logAction(`使用了${useCount}个VIP能力值`, "info");
    } else {
        logAction("VIP能力值不足！", "error");
    }
}

// 辅助函数：根据等级获取旧的VIP加成（需要实现）
function getVipBonusByLevel(level) {
    const config = vipConfig.find(c => c.level === level) || vipConfig[0];
    return config.bonus;
}
// 计算总GPS时，实时应用当前VIP加成
function calculateTotalGPS() {
    let totalGps = 0;
    player.equipment.forEach(eq => {
        totalGps += eq.gps * (1 + getVipBonus()); // 实时获取最新VIP加成
    });
    // 其他加成（如成就、转生等）
    return totalGps;
}
// 添加设置界面切换函数
function toggleAutoBuySettings() {
    const settings = document.getElementById('autoBuySettings');
    if (settings.style.display === 'none') {
        settings.style.display = 'block';
        // 将当前设置的值填入输入框
        document.getElementById('techniqueMaxCost').value = player.autoBuyTechniqueMaxCost;
    } else {
        settings.style.display = 'none';
    }
}

// 添加设置价格上限函数
function setTechniqueMaxCost() {
    const input = document.getElementById('techniqueMaxCost');
    const value = parseFloat(input.value);
    
    if (!isNaN(value) && value > 0) {
        player.autoBuyTechniqueMaxCost = value;
        logAction(`已设置功法秘籍宝箱自动购买价格上限为: ${formatNumber(value)}`, 'success');
    } else {
        logAction("请输入有效的价格上限", "error");
    }
}

        // 加载存档
       function loadSave() {
    try {
        const save = JSON.parse(localStorage.getItem('goldGameSave'));
        if (save) {
            if (save.lastUpdate && save.lastUpdate > Date.now()) {
                throw new Error("检测到时间回退，强制重置游戏");
            }
            player = migrateSaveData(save);
            player.equipment = validateEquipmentList(save.equipment);
        
            if (save.battle && save.battle.autoSweepEnabled !== undefined) {
            player.battle.autoSweepEnabled = save.battle.autoSweepEnabled;
        }
         updateAutoConvertDisplay();
        if (!player.battle) {
        player.battle = {
            playerHealth: 100 + player.reincarnationCount * 10,
            playerAttack: getTotalClickValue(),
            playerCritRate: 0.1 + player.attributes.critRate * 0.0005,
            playerCritDamage: 1.5 + player.attributes.critDamage * 0.005,
            currentZone: null,
            currentMonster: null,
            monsterResurrections: 0,
            autoBattle: false,
            autoBattleInterval: null
        };
    }
        if (save.autoBuyTechniqueMaxCost !== undefined) {
    player.autoBuyTechniqueMaxCost = save.autoBuyTechniqueMaxCost;
}
        
          if (save.level) {
                player.level = {
                    current: save.level.current || 1,
                    exp: save.level.exp || 0,
                    nextLevelExp: save.level.nextLevelExp || 10000,
                    clickBonus: save.level.clickBonus || 0,
                    gpsBonus: save.level.gpsBonus || 0,
                    ascentionCount: save.level.ascentionCount || 0,
                    ascentionMultiplier: save.level.ascentionMultiplier || 1
                };
            }

             // 确保加载通天塔数据
          if (!player.fishing) {
        player.fishing = {
            level: 1,
            currentExp: 0,
            fishCage: [],
            isFishing: false,
            isBiting: false,
            biteTimer: null,
            biteWindowTimer: null,
            biteTime: 0,
            bonus: 1
        };
    }
         
            if (save.tower) {
                player.tower = save.tower;
            }
           updateTowerUI();
          calculateOfflineMysteryExp();
            // 重置并重新计算收藏物效果
            resetAllCollectionEffects();
         // 新增：加载存档后自动计算并更新VIP等级
            const actualVipLevel = calculateVipLevel();
            player.vip.level = actualVipLevel;
            updateVipDisplay(); // 立即更新VIP显示

            // 确保自动购买状态被正确加载
            player.autoBuy = save.autoBuy || [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            player.autoBuyMaterialChest = save.autoBuyMaterialChest || false;
           player.autoBuyTechniqueChest = save.autoBuyTechniqueChest || false;
            // 强制覆盖宠物的 multiplier，同时保留等级和其他数据
            Object.keys(player.pets).forEach(petKey => {
                if (petConfig[petKey]) {
                    player.pets[petKey].multiplier = petConfig[petKey].multiplier;
                }
            });
       
            // 初始化自动购买按钮状态
            player.autoBuy.forEach((enabled, index) => {
                const btn = document.getElementById(`autoChest${index + 1}`);
                if (btn) {
                    btn.textContent = `${['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'][index]}宝箱自动购买：${enabled ? '开启' : '关闭'}`;
                }
            });
   

            // 初始化材料宝箱自动购买按钮状态
            const materialChestBtn = document.getElementById('autoMaterialChest');
            if (materialChestBtn) {
                materialChestBtn.textContent = `材料宝箱自动购买：${player.autoBuyMaterialChest ? '开启' : '关闭'}`;
            }
 const techniqueChestBtn = document.getElementById('autoTechniqueChest');
    if (techniqueChestBtn) {
        techniqueChestBtn.textContent = `功法秘籍宝箱自动购买：${player.autoBuyTechniqueChest ? '开启' : '关闭'}`;
    }
         // 在初始化自动购买按钮状态的地方添加
const speedBoostBtn = document.getElementById('autoBuySpeedBoost');
if (speedBoostBtn) {
    speedBoostBtn.textContent = `在线自动购买100倍数量：${player.autoBuySpeedBoost ? '开启' : '关闭'}`;
}
      const onlineBoostBtn = document.getElementById('toggleOnlineBoost');
    if (onlineBoostBtn) {
        onlineBoostBtn.textContent = `在线金币加速100倍: ${player.onlineBoostEnabled ? '开启' : '关闭'}`;
    }
      
            // 确保日志不超过 20 条
            player.actionLogs = player.actionLogs.slice(0, 20);
            player.lotteryResults = player.lotteryResults.slice(0, 5);

         

            // 计算离线时间
            const currentTime = Date.now();
            const maxOfflineTime = 86400 * 1000; // 24 小时（以毫秒为单位）
            const offlineTime = Math.min(currentTime - (player.lastUpdate || currentTime), maxOfflineTime); // 限制离线时间
            const offlineSeconds = Math.floor(offlineTime / 1000); // 将毫秒转换为秒

            if (offlineTime > 1000) {
// 计算离线分钟数
        const offlineMinutes = Math.floor(offlineSeconds / 60);
        
        // 每分钟为每件装备增加500级
        player.equipment.forEach(eq => {
            eq.level += offlineMinutes * 500;
        });
                // 模拟离线期间的自动购买
                simulateOfflineAutoBuy(offlineSeconds);
     
               
                // 计算离线收益
                const offlineGPS = getTotalGPS();
                const earnedGold = offlineSeconds * offlineGPS;
                player.gold += earnedGold;
            
      

                // 格式化离线收益
                const formattedEarnedGold = earnedGold >= 1e8 ? earnedGold.toExponential(3) : earnedGold.toLocaleString();

                logAction(`离线收益: +${formattedEarnedGold}金币 (${formatTime(offlineTime)})`, 'offline-reward');
             
                // 模拟离线期间的彩票开奖
                if (player.traditionalLotteryNumbers.length > 0) {
                    const lotteryIntervals = Math.floor(offlineTime / 1800000); // 每 30 分钟开奖一次
                    for (let i = 0; i < lotteryIntervals; i++) {
                        checkTraditionalLotteryResult();
                    }
                }
               calculateOfflineCultivationExp(offlineMinutes);
                // 计算离线期间的银行利息
                calculateBankInterest();
            }
          initFarmData();
        updateSectNameDisplay();
         initExplorationSystem();
        initExpeditionData();
    initTreasureMapSystem();
   initNightClubSystem();
    // 计算离线探险奖励
    calculateOfflineExpeditionRewards();
        if (save.exploration) {
                Object.assign(explorationData, save.exploration);
            }
    if (save.traditionalLotteryBought && save.traditionalLotteryDrawTime) {
                        if (Date.now() >= save.traditionalLotteryDrawTime) {
                            // 立即开奖
                            checkTraditionalLotteryResult();
                        } else {
                            // 设置开奖时间
                            player.traditionalLotteryDrawTime = save.traditionalLotteryDrawTime;
                        }
                    }
        }
    } catch (e) {
        console.warn('存档加载失败，使用默认数据:', e);
    }
    player.lastUpdate = Date.now();
}

  



        // 模拟离线期间的自动购买
        function simulateOfflineAutoBuy(offlineSeconds) {
    const maxOfflineTime = 86400; // 24小时（秒）
    const actualOfflineTime = Math.min(offlineSeconds, maxOfflineTime);
    const minutes = Math.floor(actualOfflineTime / 86400); // 转换为分钟数
    const chestsPerMinute = 1; // 每分钟购买数量

    player.autoBuy.forEach((enabled, index) => {
        if (enabled) {
            const type = index + 1;
            const costConfig = [
                { currency: "gold", amount: 100 },
                { currency: "diamond", amount: 10 },
                { currency: "titanium", amount: 1 },
                { currency: "starstone", amount: 1 },
                { currency: "cosmicstone", amount: 1 },
                { currency: "superstone", amount: 1 },
                { currency: "otherworldstone", amount: 1 },
                { currency: "xingjiestone", amount: 1 },
                { currency: "hundunstone", amount: 1 },
                { currency: "lingtone", amount: 1 },
                { currency: "huangtone", amount: 1 },
                { currency: "mingtone", amount: 1 },
                { currency: "xutong", amount: 1 },
                { currency: "shitone", amount: 1 },
                { currency: "weitone", amount: 1 }                
            ][index];

            // 计算最大可购买数量：分钟数 × 每分钟500个
            const maxPossible = minutes * chestsPerMinute;
            // 计算实际能购买的数量（受限于货币数量）
            const affordable = Math.floor(player[costConfig.currency] / costConfig.amount);
            const actualBuy = Math.min(maxPossible, affordable);

            if (actualBuy > 0) {
                // 扣除总消耗
                player[costConfig.currency] -= actualBuy * costConfig.amount;
                
                // 更新宝箱计数
                const chestType = ['common', 'advanced', 'rare', 'epic', 'legendary', 'chaos', 'apocalypse','yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6', 'yeyu7', 'yeyu8'][index];
                player.chestCounts[chestType] += actualBuy;
                
                // 批量处理装备获取（这里简化处理，实际可根据需要调整概率计算）
                for (let i = 0; i < actualBuy; i++) {
                    const selectedRarity = selectRarity(type);
                    handleEquipment(selectedRarity);
                }
                
                // 检查成就（会自动处理区间判断）
                checkChestAchievements(chestType, player.chestCounts[chestType]);
            }
        }
    });




    // 材料宝箱类似处理
    if (player.autoBuyMaterialChest) {
        const maxPossible = minutes * chestsPerMinute;
        let remaining = maxPossible;
        let totalCost = 0;
        
        // 计算材料宝箱可购买数量（考虑成本递增）
        while (remaining > 0 && player.diamond >= player.materialChestCost + totalCost) {
            totalCost += player.materialChestCost;
            player.materialChestCost *= 2; // 成本翻倍
            remaining--;
        }
        
        if (maxPossible - remaining > 0) {
            player.diamond -= totalCost;
            // 批量处理材料宝箱奖励
            for (let i = 0; i < maxPossible - remaining; i++) {
                const selectedItem = selectMaterialChestItem();
                if (selectedItem.type in player.collections) {
                    player.collections[selectedItem.type]++;
                    applyCollectionEffect(selectedItem.type);
                } else if (selectedItem.type in player.items) {
                    player.items[selectedItem.type]++;
                }
            }
        }
    }

    autoConvertCurrency();
}
function handleVipPowerGain() {
    player.vip.power++;
    const newLevel = calculateVipLevel();
    
    if (newLevel > player.vip.level) {
        const oldLevel = player.vip.level;
        player.vip.level = newLevel;
        logAction(`VIP等级提升至${newLevel}级！全属性装备提升${vipConfig[newLevel - 1].bonus * 100}%`, 'success');
    }
    
    updateVipDisplay();
}
        // 数据迁移
        function migrateSaveData(oldSave) {
    return {
        ...player,
        ...oldSave,
        achievements: {
            ...player.achievements, // 使用默认成就数据
            ...(oldSave.achievements || {}) // 覆盖旧存档的成就数据
        },
        equipment: oldSave.equipment || [],
        items: oldSave.items || { primaryGem: 0, advancedGem: 0, superiorGem: 0, divineGem: 0, vipPower: 0, refineStone: 0, rose: 0, companionKey: 0, rebornDan: 0, baitCount: 0, rootDetector: 0, bloodlineDetector: 0, advanceStone: 0, primaryGemq: 0, zongmen: 0, roseq: 0, yuzhou1: 0, yuzhou2: 0, yuzhou3: 0, yuzhou4: 0, banlv1: 0, banlv2: 0, banlv3: 0, banlv4: 0, banlv5: 0, banlv6: 0, banlv7: 0, banlv8: 0, banlv9: 0 },
        collections: oldSave.collections || {
            lightSpeedHand: 0,
            empHand: 0,
            godlyHand: 0,
            quickHand: 0,
            shadowHand: 0,
            quantumHand: 0,
            lightningHand: 0,
            divineHand: 0
        },
        pets: oldSave.pets || {
            thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
            chaosTaotie: { level: 0, cost: 1, multiplier: 0.50 },
            netherQiongqi: { level: 0, cost: 1, multiplier: 2.50 },
            abyssKun: { level: 0, cost: 1, multiplier: 12.50 },
            primordialZhuLong: { level: 0, cost: 1, multiplier: 62.50 },
           wanJunSuanNi: { level: 0, cost: 1, multiplier: 312.50 },
           yanYuBiAn: { level: 0, cost: 1, multiplier: 1562.50 },
          yuyu1: { level: 0, cost: 1, multiplier: 7812.50 },
         yuyu2: { level: 0, cost: 1, multiplier: 39062.50 },
          yuyu3: { level: 0, cost: 1, multiplier: 195312.50 },
         yuyu4: { level: 0, cost: 1, multiplier: 976562.50 },
          yuyu5: { level: 0, cost: 1, multiplier: 5882812.50 },
          yuyu6: { level: 0, cost: 1, multiplier: 29414062.50 },
         yuyu7: { level: 0, cost: 1, multiplier: 147070312.50 },
          yuyu8: { level: 0, cost: 1, multiplier: 735351562.50 }
        },
        dungeonEquipment: oldSave.dungeonEquipment || [],
        soulRings: oldSave.soulRings || [],
        achievements: oldSave.achievements || player.achievements,
        autoBuy: oldSave.autoBuy || [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], // 新增宝箱自动购买状态
        autoBuyMaterialChest: oldSave.autoBuyMaterialChest || false,
        autoBuyTechniqueChest: oldSave.autoBuyTechniqueChest || false,
       autoBuyTechniqueMaxCost: oldSave.autoBuyTechniqueMaxCost ||1e9,
        gpsMultiplie: oldSave.gpsMultiplier ||1,
        clickMultiplier: oldSave.clickMultiplier || 1,
        autoConvert: oldSave.autoConvert || false,
        autoConvertCurrency: oldSave.autoConvertCurrency || { gold: false, diamond: false, titanium: false, starstone: false },
        clickTimestamps: oldSave.clickTimestamps || [],
        chestCounts: oldSave.chestCounts || { common: 0, advanced: 0, rare: 0, epic: 0, legendary: 0, chaos: 0, apocalypse: 0, yeyu1: 0, yeyu2: 0, yeyu3: 0, yeyu4: 0, yeyu5: 0, yeyu6: 0, yeyu7: 0, yeyu8: 0 }, // 新增宝箱计数
        reincarnationCoin: oldSave.reincarnationCoin || 0,
        reincarnationCount: oldSave.reincarnationCount || 0,
        reincarnationStats: oldSave.reincarnationStats || {
            gpsBonus: { level: 0, cost: 1 },
            equipmentLevelBonus: { level: 0, cost: 1 },
            clickLimitBonus: { level: 0, cost: 1 }
        },
        materialChestCost: oldSave.materialChestCost || 1,
        stockData: oldSave.stockData || {
            stocks: [
                { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
            ],
            lastStockUpdate: Date.now()
        },
        lotteryResults: oldSave.lotteryResults || [],
        traditionalLotteryNumbers: oldSave.traditionalLotteryNumbers || [],
        lastLotteryDraw: oldSave.lastLotteryDraw || Date.now(),
        bank: oldSave.bank || {
            deposit: 0,
            lastInterestUpdate: Date.now()
        }
    };
}

        // 装备验证
        function validateEquipmentList(equipmentList) {
            return (equipmentList || []).map(eq => ({
                name: eq.name || getEquipmentName(eq),
                rarity: validateRarity(eq.rarity),
                level: Math.max(1, parseInt(eq.level) || 1),
                gps: safeNumber(eq.gps, 0),
                click: safeNumber(eq.click, 0),
                growthRate: safeNumber(eq.growthRate, getDefaultGrowthRate(eq.rarity)),
                gemMultiplier: safeNumber(eq.gemMultiplier, 0),
                collectionMultiplier: safeNumber(eq.collectionMultiplier, 0)
            }));
        }

        // 安全数值处理
        function safeNumber(value, fallback = 0) {
            return typeof value === 'number' ? value : parseFloat(value) || fallback;
        }

        // 核心游戏逻辑
        function getTotalGPS() {
    const towerMultiplier = 1 + player.tower.currentFloor * 0.1;
    const gpsBonus = player.reincarnationStats.gpsBonus.level * 1.00; // 每级增加100% GPS
    const petMultiplier = Object.values(player.pets).reduce((sum, pet) => sum + pet.level * pet.multiplier, 1);

    // 改为使用带职业加成的总装备加成
    const dungeonBonus = getTotalDungeonEquipBonus();
    // 改为使用带职业加成的总魂环加成
    const soulRingBonus = getTotalSoulRingBonus();
 const mysteryBonus = player.mystery.bonus || 1;
const cultivationBonus = player.cultivation.bonus || 1;
const gpsEnhancements =  [1, 5, 10, 25, 50, 75, 100, 150, 250, 500, 750, 1000, 2500, 5000, 7500, 10000, 25000, 50000, 75000, 100000, 250000, 500000, 750000, 1000000, 2500000, 5000000, 7500000, 10000000, 25000000, 50000000, 75000000, 100000000, 250000000, 500000000, 750000000, 1000000000, 2500000000, 5000000000, 7500000000, 1];
const farmGPSEnhancement  = gpsEnhancements[player.farm.level - 1] || gpsEnhancements[gpsEnhancements.length - 1];

const gpsEnhancementss =  [1, 5, 10, 25, 50, 75, 100, 150, 250, 500, 750, 1000, 2500, 5000, 7500, 10000, 25000, 50000, 75000, 100000, 250000, 500000, 750000, 1000000, 2500000, 5000000, 7500000, 10000000, 25000000, 50000000, 75000000, 100000000, 250000000, 500000000, 750000000, 1000000000, 2500000000, 5000000000, 7500000000, 1];
const farmGPSEnhancements  = gpsEnhancementss[player.parking.level - 1] || gpsEnhancementss[gpsEnhancementss.length - 1];
    const gpsBonuss = player.level.gpsBonus * 1.00;   
   const gpsBonusss = player.liveStream.totalEarnings * 0.001;  

const gpsEnhancementsp =  [1, 2, 5, 10, 20, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 1];
const farmGPSEnhancementp  = gpsEnhancementsp[player.sect.level - 1] || gpsEnhancementsp[gpsEnhancementsp.length - 1];


    return (1 + player.equipment.reduce((sum, eq) => sum + eq.gps * (1+eq.gemMultiplier + eq.collectionMultiplier), 0)) 
        * player.gpsMultiplier 
        * (1 + gpsBonus) 
        * petMultiplier * (1 + dungeonBonus) * (1 + soulRingBonus) * towerMultiplier * mysteryBonus * farmGPSEnhancement * farmGPSEnhancements  * cultivationBonus * gpsBonuss * gpsBonusss * farmGPSEnhancementp;
}

function getTotalClickValue() {
    const petMultiplier = Object.values(player.pets).reduce((sum, pet) => sum + pet.level * pet.multiplier, 1);
    // 改为使用带职业加成的总装备加成
    const dungeonBonus = getTotalDungeonEquipBonus();
    // 改为使用带职业加成的总魂环加成
   const fishingBonus = player.fishing ? player.fishing.bonus : 1;
    const soulRingBonus = getTotalSoulRingBonus();
   const cultivationBonus = player.cultivation.bonus || 1;
    const farmClickMultipliers = [1, 5, 10, 25, 50, 75, 100, 150, 250, 500, 750, 1000, 2500, 5000, 7500, 10000, 25000, 50000, 75000, 100000, 250000, 500000, 750000, 1000000, 2500000, 5000000, 7500000, 10000000, 25000000, 50000000, 75000000, 100000000, 250000000, 500000000, 750000000, 1000000000, 2500000000, 5000000000, 7500000000, 1];
 const farmClickBonus = farmClickMultipliers[player.farm.level - 1] || farmClickMultipliers[farmClickMultipliers.length - 1];

const farmClickMultiplierss = [1, 5, 10, 25, 50, 75, 100, 150, 250, 500, 750, 1000, 2500, 5000, 7500, 10000, 25000, 50000, 75000, 100000, 250000, 500000, 750000, 1000000, 2500000, 5000000, 7500000, 10000000, 25000000, 50000000, 75000000, 100000000, 250000000, 500000000, 750000000, 1000000000, 2500000000, 5000000000, 7500000000, 1];
    const farmClickBonuss = farmClickMultiplierss[player.parking.level - 1] || farmClickMultiplierss[farmClickMultiplierss.length - 1];
const farmClickMultipliersss = [1, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 1];
    const farmClickBonusss = farmClickMultipliersss[player.nightClub.level - 1] || farmClickMultipliersss[farmClickMultipliersss.length - 1];     
           
    const gpsBonusss = player.level.clickBonus * 1.00; 

const farmClickMultiplierssa = [1, 10, 25, 50, 75, 100, 200, 400, 600, 800, 1000, 2000, 4000, 6000, 8000, 10000, 20000, 40000, 60000, 80000, 100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 2000000, 4000000, 6000000, 8000000, 10000000, 25000000, 50000000, 75000000, 100000000, 1];
    const farmClickBonussa = farmClickMultiplierssa[player.liveStream.level - 1] || farmClickMultiplierssa[farmClickMultiplierssa.length - 1];
           

    return (1 + player.equipment.reduce((sum, eq) => sum + eq.click * (1+eq.gemMultiplier + eq.collectionMultiplier), 0)) 
        * player.clickMultiplier 
        * petMultiplier 
        * (1 + dungeonBonus)  // 应用副本装备总加成（含职业乘数）
        * (1 + soulRingBonus) * fishingBonus * farmClickBonus * farmClickBonuss * cultivationBonus * farmClickBonusss * gpsBonusss * farmClickBonussa; 
}


     
        // 自动兑换货币
        function autoConvertCurrency() {
    const conversions = [
        { from: 'gold', to: 'diamond', rate: 1e5 },
        { from: 'diamond', to: 'titanium', rate: 1e8 },
        { from: 'titanium', to: 'starstone', rate: 1e8 },
        { from: 'starstone', to: 'cosmicstone', rate: 1e8 },
        { from: 'cosmicstone', to: 'superstone', rate: 1e9 },
        { from: 'superstone', to: 'otherworldstone', rate: 1e15 },
        { from: 'otherworldstone', to: 'xingjiestone', rate: 1e20 },
        { from: 'xingjiestone', to: 'hundunstone', rate: 1e25 },
        { from: 'hundunstone', to: 'lingtone', rate: 1e25 },
        { from: 'lingtone', to: 'huangtone', rate: 1e25 },
        { from: 'huangtone', to: 'mingtone', rate: 1e25 },
        { from: 'mingtone', to: 'xutong', rate: 1e25 },
        { from: 'xutong', to: 'shitone', rate: 1e25 },
        { from: 'shitone', to: 'weitone', rate: 1e25 }        
    ];

    conversions.forEach(({ from, to, rate }) => {
        if (player.autoConvertCurrency[from]) {
            const converted = Math.floor(player[from] / rate);
            player[to] += converted;
            player[from] %= rate;
        }
    });
}

        // 点击获取金币，限制每秒10次
        function clickGold() {
            const now = Date.now();
            // 移除超过1秒的点击记录
            player.clickTimestamps = player.clickTimestamps.filter(timestamp => now - timestamp < 1000);

            const clickLimit = 10 + player.reincarnationStats.clickLimitBonus.level; // 每级增加1次点击上限
            if (player.clickTimestamps.length >= clickLimit) {
                logAction("点击速度过快，请稍后再试！", "error");
                return;
            }

            player.clickTimestamps.push(now);

            const value = getTotalClickValue();
            player.gold += value;
            logAction(`点击获取金币: +${value}`, 'info');
            updateDisplay();
        }

        function buyChest(type) {
    const costConfig = [
        { currency: "gold", amount: 100 },
        { currency: "diamond", amount: 10 },
        { currency: "titanium", amount: 1 },
        { currency: "starstone", amount: 1 },
        { currency: "cosmicstone", amount: 1 },
        { currency: "superstone", amount: 1 }, 
        { currency: "otherworldstone", amount: 1 }, 
        { currency: "xingjiestone", amount: 1 },
        { currency: "hundunstone", amount: 1 },
        { currency: "lingtone", amount: 1 }, 
        { currency: "huangtone", amount: 1 },
        { currency: "mingtone", amount: 1 }, 
        { currency: "xutong", amount: 1 }, 
        { currency: "shitone", amount: 1 },
        { currency: "weitone", amount: 1 }       
    ][type - 1];

    if (player[costConfig.currency] >= costConfig.amount) {
        player[costConfig.currency] -= costConfig.amount;
        const selectedRarity = selectRarity(type);
        console.log(`购买宝箱类型: ${type}, 掉落装备品质: ${selectedRarity}`); // 调试信息
        handleEquipment(selectedRarity);

        // 更新宝箱购买计数
        const chestType = ['common', 'advanced', 'rare', 'epic', 'legendary', 'chaos', 'apocalypse', 'yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6', 'yeyu7', 'yeyu8'][type - 1];
        player.chestCounts[chestType]++;
        checkChestAchievements(chestType, player.chestCounts[chestType]);
    } else {
        logAction(`${costConfig.currency}不足！无法购买${['普通','高级','稀有','史诗','传说','混沌','终焉','星辰','银河','星云','鸿蒙','太虚', '虚空', '时空', '未来'][type-1]}宝箱`, 'error');
    }
    updateDisplay();
}

        // 检查宝箱成就
        function checkChestAchievements(chestType, count) {
    const achievements = [
        { count: 100, key: `${chestType}_chest_100` },
        { count: 10000, key: `${chestType}_chest_10000` },
        { count: 1000000, key: `${chestType}_chest_1000000` },
        { count: 10000000, key: `${chestType}_chest_10000000` },
        { count: 100000000, key: `${chestType}_chest_100000000` }
    ];

    achievements.forEach(({ count: targetCount, key }) => {
        if (count >= targetCount && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updateAchievementsDisplay();
            }
        }
    });
}

        function buyMaterialChest() {
    const cost = player.materialChestCost;
    if (player.diamond >= cost) {
        player.diamond -= cost;
        const selectedItem = selectMaterialChestItem();
        
        if (selectedItem.type in player.collections) {
            player.collections[selectedItem.type]++;
            onCollectionAdded(selectedItem.type); // 应用效果
            logAction(`获得收藏物：${collectionEffects[selectedItem.type].name}`, 'success');
            updateCollectionDisplay(); // 更新收藏物页面
        } else if (selectedItem.type in player.items) {
            player.items[selectedItem.type]++;
            logAction(`获得道具：${itemEffects[selectedItem.type].name}`, 'success');
            updateItemDisplay(); // 更新道具页面
        }
// 新增：处理VIP能力值道具
        else if (selectedItem.type === 'vipPower') {
            handleVipPowerGain(); // 调用VIP能力值处理函数
        }
        // 更新材料宝箱购买成本
             player.materialChestCost *= 2;
            updateDisplay();
      }   else {
        logAction("钻石不足！无法购买材料宝箱", "error");
    }
}
     function buyTechniqueChest() {
    const cost = player.techniqueChestCost;
    if (player.reincarnationCoin >= cost) {
        player.reincarnationCoin -= cost;
        player.techniqueChestCost *= 2;  // 下次消耗翻倍
        player.techniqueChestLevel++;
        
        // 根据概率随机选择功法
        const roll = Math.random();
        let cumulativeProb = 0;
        
        for (const drop of techniqueChestDrops) {
            cumulativeProb += drop.prob;
            if (roll <= cumulativeProb) {
                addTechnique(drop.id);
                break;
            }
        }
        
        logAction("打开了功法秘笈宝箱！", "success");
        updateDisplay();
    } else {
        logAction("转生币不足！", "error");

    }
}
   // 初始化或重置时调用
function resetAllCollectionEffects() {
    // 重置所有装备的收藏物加成
    player.equipment.forEach(eq => {
        eq.collectionMultiplier = 0;
    });
    
    // 重新应用所有收藏物效果
    applyAllCollectionEffects();
}

// 应用所有收藏物效果
function applyAllCollectionEffects() {
    // 先重置所有效果
    player.equipment.forEach(eq => {
        eq.collectionMultiplier = 0;
    });
    
    // 累加所有收藏物效果
    Object.entries(player.collections).forEach(([type, count]) => {
        if(count > 0) {
            const effect = collectionEffects[type].effect * count;
            player.equipment.forEach(eq => {
                eq.collectionMultiplier += effect;
            });
        }
    });
    
    updateCollectionDisplay();
}

// 获得新收藏物时调用
function onCollectionAdded(collectionType) {
    const effect = collectionEffects[collectionType].effect;
    player.equipment.forEach(eq => {
        eq.collectionMultiplier += effect;
    });
    updateCollectionDisplay();
}


        // 选择材料宝箱掉落物品
        function selectMaterialChestItem() {
            let totalProb = materialChestProbabilities.reduce((sum, p) => sum + p.prob, 0);
            let rand = Math.random() * totalProb;
            for (const { type, prob } of materialChestProbabilities) {
                if (rand < prob) return { type };
                rand -= prob;
            }
            return { type: 'lightSpeedHand' }; // 默认掉落
        }

        function selectRarity(type) {
    const probConfig = chestProbabilities[type];
    let totalProb = probConfig.reduce((sum, p) => sum + p.prob, 0);
    let rand = Math.random() * totalProb;
    for (const { rarity, prob } of probConfig) {
        if (rand < prob) return validateRarity(rarity);
        rand -= prob;
    }
    return 'common';
}

        function handleEquipment(rarity) {
    const existingIndex = player.equipment.findIndex(eq => eq.rarity === rarity);
    if (existingIndex >= 0) {
        upgradeExistingEquipment(existingIndex, rarity);
    } else {
        addNewEquipment(rarity);
    }
    checkAchievement(rarity);
}

        function upgradeExistingEquipment(index, rarity) {
            const eq = player.equipment[index];
            const config = equipmentTypes[rarity];
            eq.level++;
            const vipBonus = 1 + getVipBonus();
            eq.gps = safeNumber(config.gps * (1 + config.growthRate * eq.level) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%
            eq.click = safeNumber(config.click * (1 + config.growthRate * eq.level) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%

        }

        function addNewEquipment(rarity) {
            const config = equipmentTypes[rarity] || equipmentTypes.common;
            const newEq = {
                name: config.name,
                gps: config.gps * (1 + player.reincarnationStats.gpsBonus.level), // 每级装备属性乘以100%
                click: config.click * (1 + player.reincarnationStats.gpsBonus.level), // 每级装备属性乘以100%
                rarity: rarity,
                level: 1 + player.reincarnationStats.equipmentLevelBonus.level * 200, // 转生属性加成
                growthRate: config.growthRate,
                gemMultiplier: 0,
                collectionMultiplier: 0
            };
            player.equipment.push(newEq);
            logAction(`获得 ${newEq.name}装备`, rarity);
        }

        function upgradeEquipment(index) {
            const eq = player.equipment[index];
            const cost = Math.floor(100 * Math.pow(1.5, eq.level));
            if (player.gold >= cost) {
                player.gold -= cost;
                eq.level++;
                const vipBonus = 1 + getVipBonus();
                eq.gps = safeNumber(eq.gps * (1 + eq.growthRate) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%
                eq.click = safeNumber(eq.click * (1 + eq.growthRate) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%
                logAction(`主动升级 ${eq.name}装备 至 Lv.${eq.level}`, eq.rarity);
                updateDisplay();
              updateVipDisplay();
            } else {
                logAction("金币不足！", "error");
            }
        }

        // 自动购买逻辑
       function checkAutoBuy() {
    const speedMultiplier = player.autoBuySpeedBoost ? 100 : 1;
    player.autoBuy.forEach((enabled, index) => {
        if (enabled) {
            const type = index + 1;
            const costConfig = [
                { currency: "gold", amount: 100 },
                { currency: "diamond", amount: 10 },
                { currency: "titanium", amount: 1 },
                { currency: "starstone", amount: 1 },
                { currency: "cosmicstone", amount: 1 },
                { currency: "superstone", amount: 1 },
                { currency: "otherworldstone", amount: 1 },
                { currency: "xingjiestone", amount: 1 },
                { currency: "hundunstone", amount: 1 },
                { currency: "lingtone", amount: 1 },
                { currency: "huangtone", amount: 1 },
                { currency: "mingtone", amount: 1 },
                { currency: "xutong", amount: 1 },
                { currency: "shitone", amount: 1 },
                { currency: "weitone", amount: 1 }              
            ][index];
            
            if (player[costConfig.currency] >= costConfig.amount) {
                // 计算最大可购买数量（最多100个）
                const maxBuy = Math.min(speedMultiplier, 100);
                const affordable = Math.floor(player[costConfig.currency] / costConfig.amount);
                const actualBuy = Math.min(maxBuy, affordable);
                
                if (actualBuy > 0) {
                    // 批量扣除货币
                    player[costConfig.currency] -= actualBuy * costConfig.amount;
                    
                    // 统计装备升级总级数
                    let totalLevelsUp = 0;
                    const chestTypeName = ['普通','高级','稀有','史诗','传说','混沌','终焉','星辰','银河','星云','鸿蒙','太虚', '虚空', '时空', '未来'][index];
                    
                    // 批量处理装备获取并统计升级计数
                    for (let i = 0; i < actualBuy; i++) {
                        const selectedRarity = selectRarity(type);
                        // 临时修改handleEquipment，使其返回升级的级数
                        const levelsUp = handleEquipment(selectedRarity);
                        totalLevelsUp += levelsUp;
                    }
                    
                    // 更新宝箱计数
                    const chestType = ['common', 'advanced', 'rare', 'epic', 'legendary', 'chaos', 'apocalypse', 'yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6', 'yeyu7', 'yeyu8'][index];
                    player.chestCounts[chestType] += actualBuy;
                    checkChestAchievements(chestType, player.chestCounts[chestType]);
                    
                    // 统一记录日志
                    logAction(`自动购买${chestTypeName}宝箱 x${actualBuy},${name}`, 'success');
                    updateDisplay();
                }
            }
        }
    });
if (player.autoBuyTechniqueChest && player.reincarnationCoin >= player.techniqueChestCost) {
       // 检查价格是否超过上限
        if (player.techniqueChestCost <= player.autoBuyTechniqueMaxCost) {
            buyTechniqueChest();
        } else {
            // 可选: 记录日志或通知玩家
           player.autoBuyTechniqueChest = false;
            logAction("功法秘籍宝箱价格超过上限，停止自动购买", "info");
        }
    }

    

    // 新增：自动购买材料宝箱
    if (player.autoBuyMaterialChest && player.diamond >= player.materialChestCost) {
        buyMaterialChest();
    }
}

        // 切换自动购买状态
        function toggleAutoBuy(typeIndex) {
    const index = typeIndex - 1; // 将宝箱类型转换为数组索引
    player.autoBuy[index] = !player.autoBuy[index]; // 切换状态
    const btn = document.getElementById(`autoChest${typeIndex}`);
    btn.textContent = `${['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'][index]}宝箱自动购买：${player.autoBuy[index] ? '开启' : '关闭'}`;
    logAction(`${player.autoBuy[index] ? '开启' : '关闭'}自动购买${['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'][index]}宝箱`, 'info');
}

        // 切换自动购买材料宝箱状态
        function toggleAutoBuyMaterialChest() {
    player.autoBuyMaterialChest = !player.autoBuyMaterialChest;
    const btn = document.getElementById('autoMaterialChest');
    btn.textContent = `材料宝箱自动购买：${player.autoBuyMaterialChest ? '开启' : '关闭'}`;
    logAction(`${player.autoBuyMaterialChest ? '开启' : '关闭'}自动购买材料宝箱`, 'info');
}
  function toggleAutoBuyTechniqueChest() {
    player.autoBuyTechniqueChest = !player.autoBuyTechniqueChest;
    const btn = document.getElementById('autoTechniqueChest');
    btn.textContent = `功法秘籍宝箱自动购买：${player.autoBuyTechniqueChest ? '开启' : '关闭'}`;
    logAction(`${player.autoBuyTechniqueChest ? '开启' : '关闭'}功法秘籍宝箱自动购买`, 'info');
}
     function toggleOnlineBoost() {
    player.onlineBoostEnabled = !player.onlineBoostEnabled;
    const btn = document.getElementById('toggleOnlineBoost');
    btn.textContent = `在线金币加速100倍: ${player.onlineBoostEnabled ? '开启' : '关闭'}`;
    logAction(`${player.onlineBoostEnabled ? '开启' : '关闭'}在线金币100倍加速`, 'info');
}
     function toggleAutoBuySpeedBoost() {
    player.autoBuySpeedBoost = !player.autoBuySpeedBoost;
    const btn = document.getElementById('autoBuySpeedBoost');
    btn.textContent = `在线自动购买100倍数量：${player.autoBuySpeedBoost ? '开启' : '关闭'}`;
    logAction(`${player.autoBuySpeedBoost ? '开启' : '关闭'}在线自动购买100倍数量`, 'info');
}

     // 添加更新自动兑换货币显示的函数
function updateAutoConvertDisplay() {
    const currencies = ['gold', 'diamond', 'titanium', 'starstone', 'cosmicstone', 
                        'superstone', 'otherworldstone', 'xingjiestone', 'hundunstone', 
                        'lingtone', 'huangtone', 'mingtone', 'xutong', 'shitone', 'weitone'];
    
    currencies.forEach(currency => {
        const btn = document.getElementById(`autoConvert${currency.charAt(0).toUpperCase() + currency.slice(1)}`);
        if (btn) {
            btn.textContent = `${getCurrencyName(currency)}自动兑换：${player.autoConvertCurrency[currency] ? '开启' : '关闭'}`;
        }
    });
}

// 辅助函数：获取货币中文名称
function getCurrencyName(currency) {
    const names = {
        gold: '金币',
        diamond: '钻石',
        titanium: '钛晶石',
        starstone: '星耀石',
        cosmicstone: '宇宙石',
        superstone: '超能石',
        otherworldstone: '异界石',
        xingjiestone: '星界石',
        hundunstone: '混沌石',
        lingtone: '灵髓石',
        huangtone: '幻空石',
        mingtone: '冥源石',
        xutong: '虚空石',
        shitone: '时空石',
        weitone: '未来石'      
    };
    return names[currency] || currency;
}

// 修改切换函数，确保更新显示
function toggleAutoConvertCurrency(currency) {
    player.autoConvertCurrency[currency] = !player.autoConvertCurrency[currency];
    
    // 更新按钮显示
    const btn = document.getElementById(`autoConvert${currency.charAt(0).toUpperCase() + currency.slice(1)}`);
    if (btn) {
        btn.textContent = `${getCurrencyName(currency)}自动兑换：${player.autoConvertCurrency[currency] ? '开启' : '关闭'}`;
    }
    
    logAction(`${getCurrencyName(currency)}自动兑换${player.autoConvertCurrency[currency] ? '开启' : '关闭'}`, 'info');
}
        // 成就检查
        function checkAchievement(rarity) {
    if (!player.achievements[rarity]) {
        player.achievements[rarity] = true;
        const reward = achievementRewards[rarity];
        if (reward) {
            player.gpsMultiplier += reward.gpsMultiplier;
            logAction(`成就达成：获得${equipmentTypes[rarity].name}装备，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
            updateAchievementsDisplay();
        }
    }
}

        // 更新成就显示
       function updateAchievementsDisplay() {
    const achievementsContainer = document.getElementById('achievements');
    const unlockedAchievements = Object.entries(player.achievements)
        .filter(([key, unlocked]) => unlocked)
        .map(([key]) => key);

    // 定义排序优先级
    const achievementOrder = [
     'common', 'rare', 'epic', 'legendary',
     'ancient', 'divine', 'arcane', 'celestial',
     'infernal', 'astral', 'primeval', 'transcendental',
     'quantum', 'ultimate', 'chaos', 'eternal',
     'void', 'genesis', 'divineRealm', 'apocalypse', 'yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6','yeyu7', 'yeyu8', 'yeyu9', 'yeyu10', 'yeyu11', 'yeyu12','yeyu13', 'yeyu14', 'yeyu15', 'yeyu16', 'yeyu17', 'yeyu18','yeyu19', 'yeyu20', 'yeyu21', 'yeyu22', 'yeyu23', 'yeyu24', 
    'common_chest_100',
    'common_chest_10000',
    'common_chest_1000000',
    'common_chest_10000000',
    'common_chest_100000000',
    'advanced_chest_100',
    'advanced_chest_10000',
    'advanced_chest_1000000',
    'advanced_chest_10000000',
    'advanced_chest_100000000',
    'rare_chest_100',
    'rare_chest_10000',
    'rare_chest_1000000',
    'rare_chest_10000000',
    'rare_chest_100000000',
    'epic_chest_100',
    'epic_chest_10000',
    'epic_chest_1000000',
    'epic_chest_10000000',
    'epic_chest_100000000',
    'legendary_chest_100',
    'legendary_chest_10000',
    'legendary_chest_1000000',
    'legendary_chest_10000000',
    'legendary_chest_100000000',
    'chaos_chest_100',
    'chaos_chest_10000',
    'chaos_chest_1000000',
    'chaos_chest_10000000',
    'chaos_chest_100000000',
    'apocalypse_chest_100',
    'apocalypse_chest_10000',
    'apocalypse_chest_1000000',
    'apocalypse_chest_10000000',
    'apocalypse_chest_100000000',
    'yeyu1_chest_100',
    'yeyu1_chest_10000',
    'yeyu1_chest_1000000',
    'yeyu1_chest_10000000',
    'yeyu1_chest_100000000',
    'yeyu2_chest_100',
    'yeyu2_chest_10000',
    'yeyu2_chest_1000000',
    'yeyu2_chest_10000000',
    'yeyu2_chest_100000000',
    'yeyu3_chest_100',
    'yeyu3_chest_10000',
    'yeyu3_chest_1000000',
    'yeyu3_chest_10000000',
    'yeyu3_chest_100000000',
    'yeyu4_chest_100',
    'yeyu4_chest_10000',
    'yeyu4_chest_1000000',
    'yeyu4_chest_10000000',
    'yeyu4_chest_100000000',
    'yeyu5_chest_100',
    'yeyu5_chest_10000',
    'yeyu5_chest_1000000',
    'yeyu5_chest_10000000',
    'yeyu5_chest_100000000',
    'yeyu6_chest_100',
    'yeyu6_chest_10000',
    'yeyu6_chest_1000000',
    'yeyu6_chest_10000000',
    'yeyu6_chest_100000000',
    'yeyu7_chest_100',
    'yeyu7_chest_10000',
    'yeyu7_chest_1000000',
    'yeyu7_chest_10000000',
    'yeyu7_chest_100000000',
    'yeyu8_chest_100',
    'yeyu8_chest_10000',
    'yeyu8_chest_1000000',
    'yeyu8_chest_10000000',
    'yeyu8_chest_100000000',
  'max_stage_10', 'max_stage_30', 'max_stage_60', 'max_stage_90',
   'max_stage_120', 'max_stage_200', 'max_stage_300', 'max_stage_400',
   'max_stage_500', 'max_stage_600', 'max_stage_700', 'max_stage_800',
   'max_stage_900', 'max_stage_1000',
 'thunderKirin_10',
    'thunderKirin_50',
    'thunderKirin_100',
    'chaosTaotie_10',
    'chaosTaotie_50',
    'chaosTaotie_100',
    'netherQiongqi_10',
    'netherQiongqi_50',
    'netherQiongqi_100',
    'abyssKun_10',
    'abyssKun_50',
    'abyssKun_100',
    'primordialZhuLong_10',
    'primordialZhuLong_50',
    'primordialZhuLong_100',
    'wanJunSuanNi_10',
    'wanJunSuanNi_50',
    'wanJunSuanNi_100',
    'yanYuBiAn_10',
    'yanYuBiAn_50',
    'yanYuBiAn_100',
    'yuyu1_10',
    'yuyu1_50',
    'yuyu1_100',
    'yuyu2_10',
    'yuyu2_50',
    'yuyu2_100',
    'yuyu3_10',
    'yuyu3_50',
    'yuyu3_100',
    'yuyu4_10',
    'yuyu4_50',
    'yuyu4_100',
    'yuyu5_10',
    'yuyu5_50',
    'yuyu5_100',
    'yuyu6_10',
    'yuyu6_50',
    'yuyu6_100',
    'yuyu7_10',
    'yuyu7_50',
    'yuyu7_100',
    'yuyu8_10',
    'yuyu8_50',
    'yuyu8_100',
     'year1_10',
    'year10_10',
    'year100_10',
    'year1000_10',
    'year10000_10',
    'year100000_10',
    'year1000000_10',
    'year10000000_10',
    'year100000000_10',
    'year1_100',
    'year10_100',
    'year100_100',
    'year1000_100',
    'year10000_100',
    'year100000_100',
    'year1000000_100',
    'year10000000_100',
    'year100000000_100',
    'year1_1000',
    'year10_1000',
    'year100_1000',
    'year1000_1000',
    'year10000_1000',
    'year100000_1000',
    'year1000000_1000',
    'year10000000_1000',
    'year100000000_1000',
    'year1_10000',
    'year10_10000',
    'year100_10000',
    'year1000_10000',
    'year10000_10000',
    'year100000_10000',
    'year1000000_10000',
    'year10000000_10000',
    'year100000000_10000',
    'year2_10',
    'year2_100',
    'year2_1000',
    'year2_10000',
    'year3_10',
    'year3_100',
    'year3_1000',
    'year3_10000',
    'year4_10',
    'year4_100',
    'year4_1000',
    'year4_10000',
    'year5_10',
    'year5_100',
    'year5_1000',
    'year5_10000',
    'year6_10',
    'year6_100',
    'year6_1000',
    'year6_10000',
    'year7_10',
    'year7_100',
    'year7_1000',
    'year7_10000',
    'year8_10',
    'year8_100',
    'year8_1000',
    'year8_10000',
    'year9_10',
    'year9_100',
    'year9_1000',
    'year9_10000',
    'year11_10',
    'year11_100',
    'year11_1000',
    'year11_10000',
    'year12_10',
    'year12_100',
    'year12_1000',
    'year12_10000',
    'year13_10',
    'year13_100',
    'year13_1000',
    'year13_10000',
    'year14_10',
    'year14_100',
    'year14_1000',
    'year14_10000',
    'year15_10',
    'year15_100',
    'year15_1000',
    'year15_10000',
    'year16_10',
    'year16_100',
    'year16_1000',
    'year16_10000',
    'year17_10',
    'year17_100',
    'year17_1000',
    'year17_10000',
    'year18_10',
    'year18_100',
    'year18_1000',
    'year18_10000',
    'year19_10',
    'year19_100',
    'year19_1000',
    'year19_10000',
    'year20_10',
    'year20_100',
    'year20_1000',
    'year20_10000',
    'year21_10',
    'year21_100',
    'year21_1000',
    'year21_10000',
    'year22_10',
    'year22_100',
    'year22_1000',
    'year22_10000',
    'year23_10',
    'year23_100',
    'year23_1000',
    'year23_10000',
    'year24_10',
    'year24_100',
    'year24_1000',
    'year24_10000',
    'year25_10',
    'year25_100',
    'year25_1000',
    'year25_10000',
    'year26_10',
    'year26_100',
    'year26_1000',
    'year26_10000',
    'year27_10',
    'year27_100',
    'year27_1000',
    'year27_10000',
    'year28_10',
    'year28_100',
    'year28_1000',
    'year28_10000',
    'year29_10',
    'year29_100',
    'year29_1000',
    'year29_10000',
    'year30_10',
    'year30_100',
    'year30_1000',
    'year30_10000',
    'year31_10',
    'year31_100',
    'year31_1000',
    'year31_10000',
    'year32_10',
    'year32_100',
    'year32_1000',
    'year32_10000',
    'year33_10',
    'year33_100',
    'year33_1000',
    'year33_10000',
    'year34_10',
    'year34_100',
    'year34_1000',
    'year34_10000',
    'year35_10',
    'year35_100',
    'year35_1000',
    'year35_10000',
    'year36_10',
    'year36_100',
    'year36_1000',
    'year36_10000',
    'year37_10',
    'year37_100',
    'year37_1000',
    'year37_10000',
   'reincarnation_10', 'reincarnation_100', 
   'reincarnation_1000', 'reincarnation_10000', 'world_boss_1st', 'world_boss_top5', 'world_boss_top10', 'world_boss_participant'
    ];

    // 按定义顺序过滤并排序已解锁成就
    const sortedAchievements = achievementOrder
        .filter(key => unlockedAchievements.includes(key))
        .map(key => ({
            key,
            ...achievementRewards[key]
        }));

    achievementsContainer.innerHTML = Object.entries(player.achievements)
        .filter(([key, value]) => value && achievementRewards[key]) // 只显示已解锁的成就
        .map(([key, value]) => {
            const reward = achievementRewards[key];
            return `<div class="achievement unlocked">${reward.description}</div>`;
        })
        .join('');
}

        // 切换装备、道具和收藏物页面
        function switchTab(tab) {
            document.getElementById('equipmentList').style.display = tab === 'equipment' ? 'block' : 'none';
            document.getElementById('itemList').style.display = tab === 'items' ? 'block' : 'none';
            document.getElementById('collectionList').style.display = tab === 'collections' ? 'block' : 'none';
            document.getElementById('reincarnationList').style.display = tab === 'reincarnation' ? 'block' : 'none';
            document.getElementById('petList').style.display = tab === 'pets' ? 'block' : 'none';
            document.getElementById('stockList').style.display = tab === 'stocks' ? 'block' : 'none';
            document.getElementById('lotteryList').style.display = tab === 'lottery' ? 'block' : 'none';
            document.getElementById('bankList').style.display = tab === 'bank' ? 'block' : 'none';
            document.getElementById('dungeonEquipmentList').style.display = tab === 'dungeonEquipment' ? 'block' : 'none'; // 新增副本装备页面
            document.getElementById('soulRingList').style.display = tab === 'soulRings' ? 'block' : 'none'; // 新增魂环页面
            document.getElementById('playerAttributesList').style.display = tab === 'playerAttributes' ? 'block' : 'none';
            document.getElementById('techniquesList').style.display = tab === 'techniques' ? 'block' : 'none';
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tab}')"]`).classList.add('active');
            if (tab === 'items') updateItemDisplay();
            if (tab === 'collections') updateCollectionDisplay();
            if (tab === 'reincarnation') updateReincarnationDisplay();
            if (tab === 'pets') updatePetDisplay();
            if (tab === 'stocks') updateStockDisplay();
            if (tab === 'bank') updateBankDisplay();
            if (tab === 'dungeonEquipment') updateDungeonEquipmentDisplay(); // 新增：更新副本装备显示
            if (tab === 'soulRings') updateSoulRingDisplay(); // 新增：更新魂环显示
            if (tab === 'techniques') updateTechniquesDisplay();
            if (tab === 'playerAttributes') updatePlayerAttributesDisplay();
        }

        // 更新道具显示
        function updateItemDisplay() {
            const itemContainer = document.getElementById('itemList');
            itemContainer.innerHTML = Object.entries(player.items)
                .map(([key, value]) => {
                    const item = itemEffects[key];
                    return `<div>${item.name}: ${value} - ${item.description}</div>`;
                })
                .join('');
        }

       // 重置收藏物显示
function resetCollectionDisplay() {
resetCollectionEffects();
    logAction("已完全重置收藏物效果计算", "success");
}
    // 重新计算所有收藏物效果（确保加法叠加）
    Object.keys(player.collections).forEach(collectionType => {
        const effect = collectionEffects[collectionType].effect;
        const count = player.collections[collectionType];
        const totalEffect = count * effect;
        
        player.equipment.forEach(eq => {
            eq.collectionMultiplier = totalEffect;
        });
    });
    
    updateCollectionDisplay();
    logAction("已重置收藏物效果计算", "info");

// 更新后的收藏物显示函数
function updateCollectionDisplay() {
    const container = document.getElementById("collectionInfoContainer");
    
    // 计算全部收藏物总加成
    const totalEffect = player.equipment.length > 0 ? 
        player.equipment[0].collectionMultiplier * 100 : 0;
    
    // 顶部总加成显示（保持不变）
    container.innerHTML = `
        <div style="margin-bottom: 15px; font-weight: bold;">
            当前全部收藏物总加成: +${totalEffect.toFixed(5)}%
        </div>
    `;
    
    // 每个收藏物的详细显示（增加总效果）
    container.innerHTML += Object.entries(player.collections)
        .map(([key, value]) => {
            const collection = collectionEffects[key];
            const singleEffect = collection.effect * 100;
            const totalEffect = value * singleEffect;
            
            return `
                <div style="margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #eee;">
                    <strong>${collection.name}</strong>: 
                    <span>数量: ${value}</span> | 
                    <span>单个效果: +${singleEffect.toFixed(5)}%</span> |
                    <span>总效果: +${totalEffect.toFixed(5)}%</span>
                    <div style="color:#666; font-size:0.9em; margin-top: 3px;">${collection.description}</div>
                </div>
            `;
        })
        .join('');
}
        // 更新转生属性显示
        function updateReincarnationDisplay() {
    const reincarnationContainer = document.getElementById('reincarnationList');
    reincarnationContainer.innerHTML = `
        <div>
            <h3>转生属性</h3>
            <div>
                <strong>收益加成</strong>: 每级装备属性 +${player.reincarnationStats.gpsBonus.level * 100}% (等级: ${player.reincarnationStats.gpsBonus.level})
                <button onclick="upgradeReincarnationStat('gpsBonus')">升级 (消耗 ${player.reincarnationStats.gpsBonus.cost} 转生币)</button>
            </div>
            <div>
                <strong>装备等级</strong>: 全部装备初始等级 +${player.reincarnationStats.equipmentLevelBonus.level * 200} 级 (等级: ${player.reincarnationStats.equipmentLevelBonus.level})
                <button onclick="upgradeReincarnationStat('equipmentLevelBonus')">升级 (消耗 ${player.reincarnationStats.equipmentLevelBonus.cost} 转生币)</button>
            </div>
            <div>
                <strong>点击上限</strong>: 每秒点击上限 +${player.reincarnationStats.clickLimitBonus.level} 次 (等级: ${player.reincarnationStats.clickLimitBonus.level})
                <button onclick="upgradeReincarnationStat('clickLimitBonus')">升级 (消耗 ${player.reincarnationStats.clickLimitBonus.cost} 转生币)</button>
            </div>
        </div>
    `;
}
   function updateTechniquesDisplay() {
    const container = document.getElementById('techniquesContainer');
    
    // 按预定顺序筛选已获得的功法
    const sortedTechniques = TECHNIQUE_DISPLAY_ORDER
        .filter(id => player.techniques[id])
        .map(id => {
            const tech = techniqueConfig[id];
            return {
                id,
                name: tech.name,
                level: player.techniques[id],
                description: tech.description,
                effect: tech.effect,
                type: tech.type
            };
        });

    // 生成HTML
    container.innerHTML = sortedTechniques.map(tech => `
        <div class="technique ${tech.type}">
            <h4>${tech.name} [Lv.${tech.level}]</h4>
            <p>${tech.description}</p>
            <div class="tech-effect">
                当前效果: ${
                    tech.type === 'multiAttack' 
                        ? `攻击次数+${tech.level * tech.effect}`
                        : `${(tech.level * tech.effect * 100).toFixed(tech.type === 'critRate' ? 3 : 2)}%`
                }
            </div>
        </div>
    `).join('');
}

// 添加功法秘笈获取函数
function addTechnique(type) {
    if (player.techniques[type]) {
        player.techniques[type]++;
    } else {
        player.techniques[type] = 1;
    }
    logAction(`获得功法: ${techniqueConfig[type].name} Lv.${player.techniques[type]}`, 'success');
    updateTechniqueBonuses(); // 新增调用
    updateTechniquesDisplay();
}

function calculateTechniqueBonuses() {
    const bonuses = {
        health: 0,
        attack: 0,
        critRate: 0,
        critDamage: 0,
        multiAttack: 0
    };

    // 计算所有功法加成
    Object.entries(player.techniques).forEach(([techId, level]) => {
        const tech = techniqueConfig[techId];
        if (tech && tech.effect) {
            // 获取宗门功法等级加成
            const sectLevel = player.sect.techniques[techId] || 0;
            const sectMultiplier = 1 + (sectLevel * 2); // 每级增加2倍效果
            
            // 应用宗门加成
            bonuses[tech.type] += level * tech.effect * sectMultiplier;
        }
    });

    return bonuses;
}
        // 重置宠物页面
function resetPetDisplay() {
    // 保留宠物的等级和升级成本
    const petData = {};
    Object.keys(player.pets).forEach(petKey => {
        petData[petKey] = {
            level: player.pets[petKey].level, // 保留等级
            cost: player.pets[petKey].cost    // 保留升级成本
        };
    });

    // 重置宠物页面（重新生成宠物数据）
    player.pets = {
        thunderKirin: { level: petData.thunderKirin?.level || 0, cost: petData.thunderKirin?.cost || 1, multiplier: 0.10 },
        chaosTaotie: { level: petData.chaosTaotie?.level || 0, cost: petData.chaosTaotie?.cost || 1, multiplier: 0.50 },
        netherQiongqi: { level: petData.netherQiongqi?.level || 0, cost: petData.netherQiongqi?.cost || 1, multiplier: 2.50 },
        abyssKun: { level: petData.abyssKun?.level || 0, cost: petData.abyssKun?.cost || 1, multiplier: 12.50 },
        primordialZhuLong: { level: petData.primordialZhuLong?.level || 0, cost: petData.primordialZhuLong?.cost || 1, multiplier: 62.50 },
        wanJunSuanNi: { level: petData.wanJunSuanNi?.level || 0, cost: petData.wanJunSuanNi?.cost || 1, multiplier: 312.50 },
        yanYuBiAn: { level: petData.yanYuBiAn?.level || 0, cost: petData.yanYuBiAn?.cost || 1, multiplier: 1562.50 },
       yuyu1: { level: petData.yuyu1?.level || 0, cost: petData.yuyu1?.cost || 1, multiplier: 7812.50 },
        yuyu2: { level: petData.yuyu2?.level || 0, cost: petData.yuyu2?.cost || 1, multiplier: 39062.50 },
       yuyu3: { level: petData.yuyu3?.level || 0, cost: petData.yuyu3?.cost || 1, multiplier: 195312.50 },
        yuyu4: { level: petData.yuyu4?.level || 0, cost: petData.yuyu4?.cost || 1, multiplier: 976562.50 },
       yuyu5: { level: petData.yuyu5?.level || 0, cost: petData.yuyu5?.cost || 1, multiplier: 5882812.50 },
       yuyu6: { level: petData.yuyu6?.level || 0, cost: petData.yuyu6?.cost || 1, multiplier: 29414062.50 },
        yuyu7: { level: petData.yuyu7?.level || 0, cost: petData.yuyu7?.cost || 1, multiplier: 147070312.50 },
       yuyu8: { level: petData.yuyu8?.level || 0, cost: petData.yuyu8?.cost || 1, multiplier: 735351562.50 }
    };

    // 更新宠物页面显示
    updatePetDisplay();
    logAction('宠物页面已重置，等级和升级消耗保留', 'success');
}

// 更新宠物页面显示
function updatePetDisplay() {
    const petContainer = document.getElementById('petContainer');
    if (!petContainer) {
        console.error('宠物容器未找到！');
        return;
    }
    
    // 货币类型到中文名称的映射
    const currencyNames = {
        gold: '金币',
        diamond: '钻石',
        titanium: '钛晶石',
        starstone: '星耀石',
        cosmicstone: '宇宙石',
        superstone: '超能石',
        otherworldstone: '异界石',
        xingjiestone: '星界石',
        hundunstone: '混沌石',
        lingtone: '灵髓石',
        huangtone: '幻空石',
        mingtone: '冥源石',
        xutong: '虚空石',
        shitone: '时空石',
        weitone: '未来石'  
    };
    
    petContainer.innerHTML = Object.entries(player.pets)
        .map(([key, pet]) => {
            const config = petConfig[key];
            if (!config) {
                console.error(`宠物配置未找到：${key}`);
                return '';
            }
            const cost = pet.cost;
            const formattedCost = cost >= 1e8 ? cost.toExponential(3) : cost.toLocaleString();
            
            // 获取货币中文名称
            const currencyName = currencyNames[config.currency] || config.currency;
            
            return `
                <div>
                    <strong>${config.name}</strong>: 等级 ${pet.level} - 装备属性加成 ${(pet.level * pet.multiplier * 100).toFixed(2)}%
                    <button onclick="upgradePet('${key}')">升级 (消耗 ${formattedCost} ${currencyName})</button>
                </div>
            `;
        })
        .join('');
}
    // 如果需要真正的重置功能（保留等级但刷新效果），可以添加这个函数
function resetTechniquesData() {
    showCustomConfirm('确定要重置功法数据吗？这将保留等级但重置所有效果计算！', (confirmed) => {
        if (confirmed) {
            // 重新计算所有功法效果
            updateTechniqueBonuses();
            updateTechniquesDisplay();
            logAction('功法数据已重置，效果重新计算', 'success');
        }
    });
}






   // 重置道具页面
function resetItemDisplay() {
    // 保留道具的数量
    const itemCounts = { ...player.items }; // 复制当前道具数量

    // 重置道具页面（重新生成道具数据）
    player.items = {
        primaryGem: itemCounts.primaryGem || 0,
        advancedGem: itemCounts.advancedGem || 0,
        superiorGem: itemCounts.superiorGem || 0,
        divineGem: itemCounts.divineGem || 0,
        vipPower: itemCounts.vipPower || 0,
        refineStone: itemCounts.refineStone || 0,
        rose: itemCounts.rose || 0,
        companionKey: itemCounts.companionKey || 0,
         rebornDan: itemCounts.rebornDan || 0,
      baitCount: itemCounts.baitCount || 0,
   rootDetector: itemCounts.rootDetector || 0,
 bloodlineDetector: itemCounts.bloodlineDetector || 0,
 advanceStone: itemCounts.advanceStone || 0, 
 primaryGemq: itemCounts.primaryGemq || 0, 
  zongmen: itemCounts.zongmen || 0, 
roseq: itemCounts.roseq || 0,
 yuzhou1: itemCounts.yuzhou1 || 0, 
  yuzhou2: itemCounts.yuzhou2 || 0, 
  yuzhou3: itemCounts.yuzhou3 || 0, 
  yuzhou4: itemCounts.yuzhou4 || 0,
  banlv1: itemCounts.banlv1 || 0,
  banlv2: itemCounts.banlv2 || 0,
  banlv3: itemCounts.banlv3 || 0,
  banlv4: itemCounts.banlv4 || 0,
  banlv5: itemCounts.banlv5 || 0,
  banlv6: itemCounts.banlv6 || 0,
  banlv7: itemCounts.banlv7 || 0,
  banlv8: itemCounts.banlv8 || 0,
  banlv9: itemCounts.banlv9 || 0
    };

    // 更新道具页面显示
    updateItemDisplay();
    logAction('道具页面已重置，道具数量保留', 'success');
}

// 更新道具页面显示
function updateItemDisplay() {
    const itemContainer = document.getElementById('itemContainer');
    if (!itemContainer) {
        console.error('道具容器未找到！');
        return;
    }
    itemContainer.innerHTML = Object.entries(player.items)
        .map(([key, value]) => {
            const item = itemEffects[key];
            if (!item) {
                console.error(`道具配置未找到：${key}`);
                return '';
            }
            return `
                <div>
                    <strong>${item.name}</strong>: ${value} - ${item.description}
                </div>
            `;
        })
        .join('');
}
 window.onload = function() {
    loadSave();
      // 执行重置函数
    resetItemDisplay();
    resetPetDisplay();
    updateExplorationUI();
    // 恢复自动扫荡状态显示
    document.getElementById('autoSweepStatus').textContent = 
        player.battle.autoSweepEnabled ? '开' : '关';
    
    // 如果自动扫荡是开启状态，重新启动
    if (player.battle.autoSweepEnabled) {
        startAutoSweep();
    }
};
        // 更新股票显示
        function updateStockDisplay() {
    const container = document.getElementById('stocksContainer');
    container.innerHTML = player.stockData.stocks.map((stock, index) => `
        <div class="stock-item" data-index="${index}" onclick="this.parentNode.querySelectorAll('.stock-item').forEach(e=>e.classList.remove('selected'));this.classList.add('selected')">
            <strong>${stock.name}</strong><br>
            当前价: ${stock.currentPrice.toFixed(2)} | 涨跌幅: ${((stock.currentPrice / stock.lastPrice - 1) * 100).toFixed(2)}%<br>
            持有: ${stock.shares}股 | 均价: ${stock.avgCost.toFixed(2)}<br>
            市值: ${(stock.shares * stock.currentPrice).toFixed(2)} | 收益率: ${stock.avgCost ? ((stock.currentPrice / stock.avgCost - 1) * 100).toFixed(2) + '%' : '-'}
        </div>
    `).join('');
}
document.getElementById('announcementToggle').addEventListener('click', function() {
    const announcementPanel = document.getElementById('gameLogPage5');
    // 切换显示状态
    announcementPanel.style.display = announcementPanel.style.display === 'none' ? 'block' : 'none';
    // 切换按钮文本箭头方向
    this.textContent = announcementPanel.style.display === 'block' ? '点击关闭新手必看↑' : '点击呼出新手必看↓';
});
document.getElementById('announcementToggle1').addEventListener('click', function() {
    const announcementPanel = document.getElementById('gameLogPage4');
    // 切换显示状态
    announcementPanel.style.display = announcementPanel.style.display === 'none' ? 'block' : 'none';
    // 切换按钮文本箭头方向
    this.textContent = announcementPanel.style.display === 'block' ? '点击关闭更新日志↑' : '点击呼出更新日志↓';
});
        // 升级宠物
        function upgradePet(petKey) {
    const pet = player.pets[petKey];
    const config = petConfig[petKey];
    if (player[config.currency] >= pet.cost) {
        player[config.currency] -= pet.cost;
        pet.level++;
        pet.cost *= 2; // 每次升级成本翻倍

        // 检查宠物成就
        checkPetAchievements(petKey, pet.level);

        logAction(`升级 ${config.name} 成功！`, 'success');
        updatePetDisplay();
        updateDisplay();
    } else {
        logAction(`${config.currency}不足！`, "error");
    }
}

function checkPetAchievements(petKey, level) {
    const achievements = [
        { level: 10, key: `${petKey}_10` },
        { level: 50, key: `${petKey}_50` },
        { level: 100, key: `${petKey}_100` },
    ];

    achievements.forEach(({ level: targetLevel, key }) => {
        if (level >= targetLevel && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updateAchievementsDisplay();
            }
        }
    });
}

        // 升级转生属性
        function upgradeReincarnationStat(stat) {
            const statData = player.reincarnationStats[stat];
            if (player.reincarnationCoin >= statData.cost) {
                player.reincarnationCoin -= statData.cost;
                statData.level++;
                if (stat === 'equipmentLevelBonus') {
                    statData.cost *= 5; // 装备等级加成每次升级消耗增加5倍
                } else {
                    statData.cost *= 1.2; // 其他属性每次升级消耗增加20%
                }
                logAction(`升级 ${stat} 成功！`, 'success');
                updateReincarnationDisplay();
                updateDisplay();
            } else {
                logAction("转生币不足！", "error");
            }
        }

function resetGemEffects() {
    player.equipment.forEach(eq => {
        eq.gemMultiplier = 0;
    });
    logAction("已重置所有宝石效果", "info");
    updateDisplay();
}
        // 使用宝石升级装备
        function useGem(index, gemType) {
    const eq = player.equipment[index];
    const gem = itemEffects[gemType];
    
    if (player.items[gemType] > 0) {
        player.items[gemType]--;
        // 改为加法叠加
        eq.gemMultiplier += gem.effect;
        
        logAction(`使用${gem.name}升级 ${eq.name}装备 (当前加成: +${(eq.gemMultiplier * 100).toFixed(2)}%)`, 'success');
        updateDisplay();
    } else {
        logAction(`${gem.name}不足！`, "error");
    }
}
// 新增一键使用宝石函数
function useAllGems(index, gemType) {
    const eq = player.equipment[index];
    const gem = itemEffects[gemType];
    const count = player.items[gemType];
    
    if (count > 0) {
        // 计算总加成
        const totalEffect = gem.effect * count;
        // 减少宝石数量
        player.items[gemType] = 0;
        // 增加装备宝石加成
        eq.gemMultiplier += totalEffect;
        
        logAction(`一键使用${count}个${gem.name}升级 ${eq.name}装备 (当前总加成: +${(eq.gemMultiplier * 100).toFixed(2)}%)`, 'success');
        updateDisplay();
    } else {
        logAction(`${gem.name}不足！`, "error");
    }
}
        // 股票价格波动函数
        function updateStockPrices() {
            const now = Date.now();
            const elapsed = now - player.stockData.lastStockUpdate;
            const intervals = Math.floor(elapsed / (10 * 60 * 1000));

            player.stockData.stocks.forEach(stock => {
                for (let i = 0; i < intervals; i++) {
                    stock.lastPrice = stock.currentPrice;

                    // 计算当前价格与初始价格的比例
                    const priceRatio = stock.currentPrice / stock.basePrice;

                    // 根据比例动态调整涨跌概率
                    let riseProbability; // 涨的概率
                    if (priceRatio <= 0.7) {
                        riseProbability = 0.8; 
                    } else if (priceRatio <= 0.8) {
                        riseProbability = 0.7; 
                    } else if (priceRatio <= 0.9) {
                        riseProbability = 0.6; 
                    } else if (priceRatio >= 1.6) {
                        riseProbability = 0.35; 
                    } else if (priceRatio >= 1.8) {
                        riseProbability = 0.25; 
                    } else if (priceRatio >= 2.0) {
                        riseProbability = 0.1; 
                    } else {
                        riseProbability = 0.5;
                    }

                    // 根据涨跌概率决定价格波动
                    const willRise = Math.random() < riseProbability; // 是否上涨
                    const fluctuation = willRise ? Math.random() * 0.1 : -Math.random() * 0.1; // 涨跌幅度
                    stock.currentPrice *= 1 + fluctuation;

                    // 价格保护机制
                    const minPrice = stock.basePrice * 0.3;
                    if (stock.currentPrice < minPrice) stock.currentPrice = minPrice;
                }
            });
            player.stockData.lastStockUpdate = now - (elapsed % (10 * 60 * 1000));
        }

        // 股票购买逻辑
        function buyStock() {
            const amount = parseInt(document.getElementById('stockAmount').value) || 0;
            const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
            
            if(selectedIndex === undefined || amount < 1) {
                logAction("请先选择股票并输入有效数量", "error");
                return;
            }

            const stock = player.stockData.stocks[selectedIndex];
            const totalCost = stock.currentPrice * amount;
            
            if(player.reincarnationCoin >= totalCost) {
                player.reincarnationCoin -= totalCost;
                const totalShares = stock.shares + amount;
                stock.avgCost = (stock.avgCost * stock.shares + totalCost) / totalShares;
                stock.shares += amount;
                logAction(`成功购买${stock.name} ${amount}股`, "success");
            } else {
                logAction("转生币不足！", "error");
            }
            updateStockDisplay();
        }

        // 股票出售逻辑
        function sellStock() {
            const amount = parseInt(document.getElementById('stockAmount').value) || 0;
            const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
            
            if(selectedIndex === undefined || amount < 1) {
                logAction("请先选择股票并输入有效数量", "error");
                return;
            }

            const stock = player.stockData.stocks[selectedIndex];
            if(stock.shares < amount) {
                logAction("持有份额不足！", "error");
                return;
            }

            const totalValue = stock.currentPrice * amount;
            player.reincarnationCoin += totalValue;
            stock.shares -= amount;
            logAction(`成功出售${stock.name} ${amount}股`, "success");
            
            if(stock.shares === 0) stock.avgCost = 0;
            updateStockDisplay();
        }
      // 购买所有股票
function buyAllStock() {
    const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
    if (selectedIndex === undefined) {
        logAction("请先选择股票", "error");
        return;
    }

    const stock = player.stockData.stocks[selectedIndex];
    const maxShares = Math.floor(player.reincarnationCoin / stock.currentPrice);

    if (maxShares > 0) {
        const totalCost = stock.currentPrice * maxShares;
        player.reincarnationCoin -= totalCost;
        const totalShares = stock.shares + maxShares;
        stock.avgCost = (stock.avgCost * stock.shares + totalCost) / totalShares;
        stock.shares += maxShares;
        logAction(`成功购买${stock.name} ${maxShares}股`, "success");
    } else {
        logAction("转生币不足，无法购买任何股票", "error");
    }
    updateStockDisplay();
}

// 出售所有股票
function sellAllStock() {
    const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
    if (selectedIndex === undefined) {
        logAction("请先选择股票", "error");
        return;
    }

    const stock = player.stockData.stocks[selectedIndex];
    if (stock.shares <= 0) {
        logAction("没有持有该股票", "error");
        return;
    }

    const totalValue = stock.currentPrice * stock.shares;
    player.reincarnationCoin += totalValue;
    logAction(`成功出售${stock.name} ${stock.shares}股`, "success");
    stock.shares = 0;
    stock.avgCost = 0;
    updateStockDisplay();
}

        // 购买传统数字彩票
     function buyTraditionalLottery() {
    if (player.traditionalLotteryBought) {
        logAction("您已购买过传统数字彩票，需等待开奖后才能重新购买。", "error");
        return;
    }

    if (player.reincarnationCoin >= 10) {
        player.reincarnationCoin -= 10;
        const numbers = generateTraditionalLotteryNumbers();
        player.traditionalLotteryNumbers = numbers;
        player.traditionalLotteryBought = true; // 设置购买标记
         player.traditionalLotteryDrawTime = Date.now() + 30 * 60 * 1000;
        updateTraditionalLotteryDisplay();
        logAction(`购买了传统数字彩票，号码为：${numbers.join(', ')}`, 'info');
        
        setTimeout(() => {
            checkTraditionalLotteryResult();
            resetTraditionalLottery(); // 开奖后重置状态
        }, 1800000);
    } else {
        logAction("转生币不足！无法购买传统数字彩票", "error");
    }
}

// 新增重置函数
function resetTraditionalLottery() {
    player.traditionalLotteryNumbers = [];
    player.traditionalLotteryBought = false; // 重置购买标记
    player.traditionalLotteryPurchased = false; // 重置原有限购标记
   player.traditionalLotteryDrawTime = 0;
    updateTraditionalLotteryDisplay();
}


        // 生成传统数字彩票号码
        function generateTraditionalLotteryNumbers() {
            const numbers = [];
            while (numbers.length < 6) {
                const num = Math.floor(Math.random() * 50) + 1; // 生成1到50的随机数
                if (!numbers.includes(num)) { // 确保号码不重复
                    numbers.push(num);
                }
            }
            return numbers.sort((a, b) => a - b); // 返回排序后的号码
        }

        // 检查传统数字彩票结果
        function checkTraditionalLotteryResult() {
    const winningNumbers = generateTraditionalLotteryNumbers();
    const matchedNumbers = player.traditionalLotteryNumbers.filter(num => winningNumbers.includes(num)).length;
    let reward = 0;
    switch (matchedNumbers) {
        case 6:
            reward = 1000000;
            break;
        case 5:
            reward = 100000;
            break;
        case 4:
            reward = 10000;
            break;
        case 3:
            reward = 1000;
            break;
        case 2:
            reward = 100;
            break;
        case 1:
            reward = 10;
            break;
      }
    player.items.yuzhou1 += reward;

     // 添加开奖结果
    player.lotteryResults.unshift({
        type: '传统数字彩票',
        numbers: winningNumbers,
        matched: matchedNumbers,
        reward: reward,
       timestamp: new Date().toLocaleTimeString()
    });

    // 保持开奖结果不超过 20 条
    if (player.lotteryResults.length > 20) {
        player.lotteryResults.pop(); // 移除最旧的一条开奖结果
    }
    
    logAction(`传统数字彩票开奖结果：中奖号码为 ${winningNumbers.join(', ')}，你中了 ${matchedNumbers} 个号码，获得 ${reward} 星尘发票`, 'success');
  // 开奖后重置购买状态
     resetTraditionalLottery();
    player.traditionalLotteryPurchased = false;
    updateLotteryResultsDisplay();
    saveGame();

}

  

        // 购买蛇年刮刮卡
        function buySnakeScratchCard() {
            if (player.reincarnationCoin >= 50) {
                player.reincarnationCoin -= 50;
                const reward = getSnakeScratchCardReward();
                player.reincarnationCoin += reward;

              // 添加开奖结果
        player.lotteryResults.unshift({
            type: '蛇年刮刮卡',
            reward: reward,
            timestamp: new Date().toLocaleTimeString()
        });

        // 保持开奖结果不超过 20 条
        if (player.lotteryResults.length > 20) {
            player.lotteryResults.pop(); // 移除最旧的一条开奖结果
        }
                logAction(`购买了蛇年刮刮卡，获得 ${reward} 转生币`, 'info');
                updateLotteryResultsDisplay();
            } else {
                logAction("转生币不足！无法购买蛇年刮刮卡", "error");
            }
        }

        // 获取蛇年刮刮卡奖励
        function getSnakeScratchCardReward() {
            const rand = Math.random();
            if (rand < 0.6) return 0;
            if (rand < 0.95) return Math.floor(Math.random() * 91) + 10; // 10-100
            if (rand < 0.989) return Math.floor(Math.random() * 401) + 100; // 100-500
            if (rand < 0.999) return Math.floor(Math.random() * 1501) + 500; // 500-2000
            return Math.floor(Math.random() * 8001) + 2000; // 2000-10000
        }

        // 购买发财刮刮卡
        function buyFortuneScratchCard() {
            if (player.reincarnationCoin >= 500) {
                player.reincarnationCoin -= 500;
                const reward = getFortuneScratchCardReward();
                player.reincarnationCoin += reward;

                 // 添加开奖结果
        player.lotteryResults.unshift({
            type: '发财刮刮卡',
            reward: reward,
            timestamp: new Date().toLocaleTimeString()
        });

        // 保持开奖结果不超过 20 条
        if (player.lotteryResults.length > 20) {
            player.lotteryResults.pop(); // 移除最旧的一条开奖结果
        }
                logAction(`购买了发财刮刮卡，获得 ${reward} 转生币`, 'info');
                updateLotteryResultsDisplay();
            } else {
                logAction("转生币不足！无法购买发财刮刮卡", "error");
            }
        }

        // 获取发财刮刮卡奖励
        function getFortuneScratchCardReward() {
            const rand = Math.random();
            if (rand < 0.6) return 0;
            if (rand < 0.95) return Math.floor(Math.random() * 901) + 100; // 100-1000
            if (rand < 0.989) return Math.floor(Math.random() * 4001) + 1000; // 1000-5000
            if (rand < 0.999) return Math.floor(Math.random() * 15001) + 5000; // 5000-20000
            return Math.floor(Math.random() * 80001) + 20000; // 20000-100000
        }

        // 更新传统数字彩票显示
     function updateTraditionalLotteryDisplay() {
            const container = document.getElementById('traditionalLotteryNumbers');
            if (player.traditionalLotteryBought) {
                container.textContent = `您的号码：${player.traditionalLotteryNumbers.join(', ')} (已购买，等待开奖...)`;
                document.querySelector('.buy-traditional-lottery-btn').style.display = 'none';
            } else {
                container.textContent = "您还没有购买彩票";
                document.querySelector('.buy-traditional-lottery-btn').style.display = 'block';
            }
            // 更新倒计时显示
            updateLotteryCountdown();
        }
      // 更新彩票倒计时
        function updateLotteryCountdown() {
            const countdownElement = document.getElementById('traditionalLotteryCountdown');
            if (!countdownElement) return;

            if (player.traditionalLotteryBought && player.traditionalLotteryDrawTime > 0) {
                const now = Date.now();
                const timeLeft = player.traditionalLotteryDrawTime - now;
                
                if (timeLeft <= 0) {
                    countdownElement.textContent = '开奖中...';
                    // 时间到了，立即开奖
                    checkTraditionalLotteryResult();
                } else {
                    const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                    const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                    countdownElement.textContent = `下次开奖: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            } else {
                countdownElement.textContent = '下次开奖: --:--:--';
            }
        }
        // 更新开奖结果显示
        function updateLotteryResultsDisplay() {
    const container = document.getElementById('lotteryResults');
    container.innerHTML = player.lotteryResults
        .slice(0, 20)
        .map(result => {
            if (result.type === '传统数字彩票') {
                return `<div>${result.type} - 中奖号码: ${result.numbers.join(', ')}，你中了 ${result.matched} 个号码，获得 ${result.reward} 星尘发票</div>`;
            } else {
                return `<div>${result.type} - 获得 ${result.reward} 转生币</div>`;
            }
        })
        .join('');
}

        // 银行系统逻辑
        function depositToBank() {
            const amount = parseInt(document.getElementById('bankAmount').value) || 0;
            if (amount < 1) {
                logAction("请输入有效的存款金额", "error");
                return;
            }
            if (player.reincarnationCoin >= amount) {
                player.reincarnationCoin -= amount;
                player.bank.deposit += amount;
                logAction(`成功存款 ${amount} 转生币`, "success");
                updateBankDisplay();
            } else {
                logAction("转生币不足！", "error");
            }
        }

        function withdrawFromBank() {
            const amount = parseInt(document.getElementById('bankAmount').value) || 0;
            if (amount < 1) {
                logAction("请输入有效的取款金额", "error");
                return;
            }
            if (player.bank.deposit >= amount) {
                player.bank.deposit -= amount;
                player.reincarnationCoin += amount;
                logAction(`成功取款 ${amount} 转生币`, "success");
                updateBankDisplay();
            } else {
                logAction("存款不足！", "error");
            }
        }
     // 存款所有转生币
function depositAllToBank() {
    const amount = player.reincarnationCoin; // 获取当前所有转生币
    if (amount < 1) {
        logAction("没有可存款的转生币", "error");
        return;
    }

    player.reincarnationCoin -= amount;
    player.bank.deposit += amount;
    logAction(`成功存款所有 ${amount} 转生币`, "success");
    updateBankDisplay();
}

// 取款所有转生币
function withdrawAllFromBank() {
    const amount = player.bank.deposit; // 获取当前所有存款
    if (amount < 1) {
        logAction("没有可取款的转生币", "error");
        return;
    }

    player.bank.deposit -= amount;
    player.reincarnationCoin += amount;
    logAction(`成功取款所有 ${amount} 转生币`, "success");
    updateBankDisplay();
    }      
        function calculateBankInterest() {
            const now = Date.now();
            const elapsed = now - player.bank.lastInterestUpdate;
            const intervals = Math.floor(elapsed / (6 * 60 * 1000)); // 每6分钟计算一次利息

            if (intervals > 0) {
                const interestRate = 0.002; // 0.2% 利息
                const interest = player.bank.deposit * interestRate * intervals;
                player.bank.deposit += interest;
                player.bank.lastInterestUpdate = now - (elapsed % (6 * 60 * 1000));
                logAction(`银行利息: +${interest.toFixed(2)} 转生币`, "info");
            }
        }

       function formatSci(value) {
    if (value >= 1e8) {
        return value.toExponential(3);
    } else {
        return value.toLocaleString();
    }
}

// 更新银行显示函数
function updateBankDisplay() {
    document.getElementById("bankDeposit").textContent = formatSci(player.bank.deposit);
    document.getElementById("bankTotal").textContent = formatSci(player.bank.deposit);
}

        // 新增：副本装备系统
        function addDungeonEquipment(rarity) {
    const config = dungeonEquipmentTypes[rarity];
    const growthRate = Math.random() * (config.growthRange[1] - config.growthRange[0]) + config.growthRange[0];

    // 检查是否已经有相同的副本装备
    const existingEq = player.dungeonEquipment.find(eq => eq.rarity === rarity);
    if (existingEq) {
        existingEq.quantity = (existingEq.quantity || 1) + 1; // 增加数量
        if (existingEq.quantity >= 3) {
            existingEq.level++; // 升级装备等级
            existingEq.quantity = 0; // 重置数量
            
       
        }
    } else {
        // 如果没有相同的副本装备，则添加新的装备
        const newEq = {
            name: config.name,
            rarity: rarity,
            level: 1,
            growthRate: growthRate,
            quantity: 1 // 初始化数量
        };
        player.dungeonEquipment.push(newEq);
        logAction(`获得副本装备：${newEq.name}`, rarity);
    }

    updateDungeonEquipmentDisplay(); // 更新副本装备显示
}

        function upgradeDungeonEquipment(index) {
            const eq = player.dungeonEquipment[index];
            const cost = eq.level * 100;
            if (player.reincarnationCoin >= cost) {
                player.reincarnationCoin -= cost;
                eq.level++;
                logAction(`升级副本装备：${eq.name} 至 Lv.${eq.level}`, eq.rarity);
                updateDungeonEquipmentDisplay(); // 刷新副本装备页面
                updateDisplay();
            } else {
                logAction("转生币不足！", "error");
            }
        }

        function refineDungeonEquipment(index) {
            const eq = player.dungeonEquipment[index];
            if (player.items.refineStone > 0) {
                player.items.refineStone--;
                const config = dungeonEquipmentTypes[eq.rarity];
                eq.growthRate = Math.random() * (config.growthRange[1] - config.growthRange[0]) + config.growthRange[0];
                logAction(`洗炼副本装备：${eq.name}，新的成长属性为 ${(eq.growthRate * 100).toFixed(2)}%`, 'success');
                updateDungeonEquipmentDisplay(); // 刷新副本装备页面
                updateDisplay();
            } else {
                logAction("洗炼石不足！", "error");
            }
        }

       function updateDungeonEquipmentDisplay() {

    const container = document.getElementById('dungeonEquipmentContainer');
    const rarityOrder = [
        'common',     
    'rare',       
    'epic',       
    'legendary',  
    'ancient',    
    'divine',    
    'arcane',     
    'celestial',  
    'infernal',  
    'astral',     
    'primeval',  
    'transcendental', 
    'quantum',    
    'ultimate',  
    'ultimate1',     
    'ultimate2',   
    'ultimate3',       
    'ultimate4',   
    'ultimate5', 
    'ultimate6',    
    'ultimate7',     
    'ultimate8',   
    'ultimate9',       
    'ultimate10',   
    'ultimate11', 
    'ultimate12',     
    'ultimate13',     
    'ultimate14',   
    'ultimate15',       
    'ultimate16',   
    'ultimate17', 
    'ultimate18',   
    'ultimate19',     
    'ultimate20',   
    'ultimate21',       
    'ultimate22',   
    'ultimate23', 
    'ultimate24',   
    'ultimate25',   
    'ultimate26',       
    'ultimate27',   
    'ultimate28', 
    'ultimate29',     
    'ultimate30',     
    'ultimate31',   
    'ultimate32',       
    'ultimate33',   
    'ultimate34', 
    'ultimate35',     
    'ultimate36',     
    'ultimate37',   
    'ultimate38',       
    'ultimate39',   
    'ultimate40', 
    'ultimate41',    
    'ultimate42',     
    'ultimate43',   
    'ultimate44',       
    'ultimate45',   
    'ultimate46', 
    'ultimate47', 
    'ultimate48',   
    'ultimate49', 
    'ultimate50'
    ];
    
    // 按品质排序
    const sortedEquipment = player.dungeonEquipment.sort((a, b) => {
        // 先按品质排序
        const rarityDiff = rarityOrder.indexOf(a.rarity) - rarityOrder.indexOf(b.rarity);
        if (rarityDiff !== 0) return rarityDiff;
        
        // 同品质按成长属性降序
        return b.growthRate - a.growthRate;
    });
    const totalBonus = player.dungeonEquipment.reduce((sum, eq) => sum + eq.level * eq.growthRate, 0);
    container.innerHTML = `
        <div>总加成: +${(totalBonus * 100).toFixed(2)}%</div>
        ${player.dungeonEquipment.map((eq, index) => `
            <div class="equipment ${eq.rarity}">
                ${eq.name} Lv.${eq.level} (数量: ${eq.quantity}/3, 成长属性: +${(eq.growthRate * 100).toFixed(2)}%)
                <button onclick="refineDungeonEquipment(${index})">洗炼</button>
                <button onclick="dismantleDungeonEquipment(${index})">分解</button>
            </div>
        `).join('')}
    `;
}

        // 分解副本装备
        function dismantleDungeonEquipment(index) {
            const eq = player.dungeonEquipment[index];
            player.dungeonEquipment.splice(index, 1);
            logAction(`分解了副本装备：${eq.name}`, 'success');
            updateDungeonEquipmentDisplay();
        }

        // 新增：魂环系统
        function addSoulRing(type) {
            const existing = player.soulRings.find(r => r.type === type);
            if(existing) {
                existing.level++;
            } else {
                player.soulRings.push({
                    type: type,
                    level: 1,
                    multiplier: soulRingTypes[type].baseMult
                });
            }
        }

        function upgradeSoulRing(type) {
    const ring = player.soulRings.find(r => r.type === type);
    const cost = ring.level * soulRingTypes[type].costBase * 1000;

    if (player.reincarnationCoin >= cost) {
        player.reincarnationCoin -= cost;
        ring.level++;

        // 检查魂环成就
        checkSoulRingAchievements(type, ring.level);

        logAction(`${soulRingTypes[type].name} 升级到 Lv.${ring.level}`, 'success');
    } else {
        logAction("转生币不足！", "error");
    }
}

function checkSoulRingAchievements(type, level) {
    const achievements = [
        { level: 10, key: `${type}_10` },
        { level: 100, key: `${type}_100` },
        { level: 1000, key: `${type}_1000` },
        { level: 10000, key: `${type}_10000` },
    ];

    achievements.forEach(({ level: targetLevel, key }) => {
        if (level >= targetLevel && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updateAchievementsDisplay();
            }
        }
    });
}
        function updateSoulRingDisplay() {
            const container = document.getElementById('soulRingsContainer');
            container.innerHTML = player.soulRings.map(ring => `
                <div class="equipment">
                    ${soulRingTypes[ring.type].name} Lv.${ring.level}
                    (全属性+${(ring.level * ring.multiplier * 100).toFixed(1)}%)

                    </button>
                </div>
            `).join('');
        }
      function showRenameDialog() {
    document.getElementById("renameDialog").style.display = "block";
    document.getElementById("renameOverlay").style.display = "block";
    document.getElementById("newNameInput").value = player.name;
    document.getElementById("newNameInput").focus();
}

function cancelRename() {
    document.getElementById("renameDialog").style.display = "none";
    document.getElementById("renameOverlay").style.display = "none";
}

function confirmRename() {
    const newName = document.getElementById("newNameInput").value.trim();
    if (newName && newName.length <= 10) {
        player.name = newName;
        document.getElementById("playerName").textContent = newName;
        saveGame();  // 确保保存玩家数据
        cancelRename();
    } else {
        alert("请输入有效的名字（1-10个字符）");
    }
}

        // 界面更新
        function updateDisplay() {
        const soulRingRingBonus = getTotalSoulRingBonus();
  const dungeonEquipBonus = getTotalDungeonEquipBonus();
      document.getElementById("playerName").textContent = player.name;
       const currentTitleEl = document.getElementById("currentTitle");
    currentTitleEl.textContent = player.titles.current ? `[${player.titles.current}]` : "";
  
 
    // 数值显示
    const display = (value) => {
    if (value >= 1e8) {  // 当数值大于等于 100,000,000 时使用科学计数法
        return value.toExponential(3);
    } else {
        return value.toLocaleString();  // 否则使用常规的数值显示
    }
};
   
  
    // 更新显示
    document.getElementById("gold").textContent = display(player.gold);
    document.getElementById("diamond").textContent = display(player.diamond);
    document.getElementById("titanium").textContent = display(player.titanium);
    document.getElementById("starstone").textContent = display(player.starstone);
    document.getElementById("cosmicstone").textContent = display(player.cosmicstone);
    document.getElementById("superstone").textContent = display(player.superstone); 
    document.getElementById("otherworldstone").textContent = display(player.otherworldstone); 
    document.getElementById("xingjiestone").textContent = display(player.xingjiestone);
    document.getElementById("hundunstone").textContent = display(player.hundunstone);
    document.getElementById("lingtone").textContent = display(player.lingtone);
    document.getElementById("huangtone").textContent = display(player.huangtone);
    document.getElementById("mingtone").textContent = display(player.mingtone);
    document.getElementById("xutong").textContent = display(player.xutong);
    document.getElementById("shitone").textContent = display(player.shitone);
    document.getElementById("weitone").textContent = display(player.weitone);
    document.getElementById("reincarnationCoin").textContent = display(player.reincarnationCoin);
    document.getElementById("reincarnationCount").textContent = player.reincarnationCount;
    document.getElementById("maxStage").textContent = player.battle.maxStage;
    document.getElementById("gps").textContent = display(getTotalGPS());
    document.getElementById("clickValue").textContent = display(getTotalClickValue());
    document.getElementById("vipPowerCount").textContent = player.items.vipPower || 0;
   document.getElementById("mysteryBonusDisplay").textContent = player.mystery.bonus;
  document.getElementById('playerLevelDisplay').textContent = `Lv.${player.level.current}级`;
  document.getElementById('ascentionCountq').textContent = `飞升.${player.level.ascentionCount}次`;


    // 更新材料宝箱购买成本显示
    document.getElementById("materialChestCost").textContent = display(player.materialChestCost);

        // 更新宝箱成本显示
     document.getElementById("techniqueChestCost").textContent = display(player.techniqueChestCost);

    // 更新怪物生命和攻击显示
    if (player.battle.monster) {
        document.getElementById("monsterHealth").textContent = display(player.battle.monster.health);
        document.getElementById("monsterAttack").textContent = display(player.battle.monster.attack);
    }
   
    // 更新玩家攻击显示
    document.getElementById("playerAttack").textContent = display(player.battle.playerAttack);

            // 装备列表
            const fragment = document.createDocumentFragment();
   player.equipment.forEach((eq, index) => {
    const div = document.createElement("div");
    div.className = `equipment ${eq.rarity}`;
    div.innerHTML = `
        ${getEquipmentName(eq)} Lv.${eq.level}
        (GPS +${eq.gps.toExponential(3)} 点击 +${eq.click.toExponential(3)})
        <button onclick="useGem(${index}, 'primaryGem')">使用初级宝石</button>
        <button onclick="useAllGems(${index}, 'primaryGem')">一键使用初级宝石</button>
        <button onclick="useGem(${index}, 'advancedGem')">使用高级宝石</button>
        <button onclick="useAllGems(${index}, 'advancedGem')">一键使用高级宝石</button>
        <button onclick="useGem(${index}, 'superiorGem')">使用极品宝石</button>
        <button onclick="useAllGems(${index}, 'superiorGem')">一键使用极品宝石</button>
        <button onclick="useGem(${index}, 'divineGem')">使用神级宝石</button>
        <button onclick="useAllGems(${index}, 'divineGem')">一键使用神级宝石</button>
        <div class="tooltip">
                品质: ${eq.name}<br>
                等级: ${eq.level}<br>
                成长率: +${(eq.growthRate * 100).toFixed(1)}%/级<br>
                宝石加成: +${(eq.gemMultiplier * 100).toFixed(2)}%<br>
            </div>
        `;
        fragment.appendChild(div);
    });
    document.getElementById("equipmentList").innerHTML = "";
    document.getElementById("equipmentList").appendChild(fragment);

            // 日志
            document.getElementById("actionLog").innerHTML = player.actionLogs
                .map(log => `<div class="${log.type}">[${log.timestamp}] ${log.message}</div>`)
                .join("");

            // 成就
            updateAchievementsDisplay();
            localStorage.setItem("goldGameSave", JSON.stringify(player));
        }

        // 辅助函数
        function getEquipmentName(eq) {
            return eq.name || equipmentTypes[eq.rarity]?.name || '神秘装备';
        }

        function validateRarity(rarity) {
            return equipmentTypes[rarity] ? rarity : 'common';
        }

        function getDefaultGrowthRate(rarity) {
            return equipmentTypes[rarity]?.growthRate || 0.01;
        }
            function formatSci(number) {
    if (number >= 1e9) {
        return number.toExponential(3)
            .replace(/(\.\d+?)0+e/, '$1e')
            .replace(/\.?e\+?/, 'e');
    }
    return Math.floor(number).toLocaleString();
}


        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            return [hours && `${hours}小时`, minutes && `${minutes}分`, `${secs}秒`]
                .filter(Boolean).join(' ');
        }

        function logAction(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();

    // 辅助函数：将大数值转换为科学计数法
    const formatNumber = (value) => {
        if (value >= 1e8) { // 当数值大于等于 100,000,000 时使用科学计数法
            return value.toExponential(3);
        } else {
            return value.toLocaleString(); // 否则使用常规的数值显示
        }
    };

    // 格式化消息中的数值
    const formattedMessage = message.replace(/\d+(\.\d+)?/g, (match) => {
        const number = parseFloat(match);
        return formatNumber(number);
    });

    // 添加到统一日志数组
    player.actionLogs.unshift({ message: formattedMessage, type, timestamp });
    // 保持日志长度不超过 20 条
    if (player.actionLogs.length > 20) {
        player.actionLogs.pop(); // 移除最旧的一条日志
    }

    // 原有 DOM 更新逻辑保持不变...
    const logEntry = document.createElement('div');
    logEntry.className = type;
    logEntry.textContent = `[${timestamp}] ${message}`;

    const logContainer = document.getElementById('actionLog');
    logContainer.insertBefore(logEntry, logContainer.firstChild);

    if (logContainer.children.length > 20) {
        logContainer.removeChild(logContainer.lastChild);
    }
}



        // 保存游戏
        function saveGame() {
    player.lastUpdate = Date.now(); // 确保保存时更新最后更新时间
    player.actionLogs = player.actionLogs.slice(0, 5);
    player.lotteryResults = player.lotteryResults.slice(0, 5);
    player.mystery.lastUpdateTime = Date.now();
    player.tower.lastUpdate = Date.now();
    player.exploration = {
        speed: explorationData.speed,
        capacity: explorationData.capacity,
        durability: explorationData.durability,
        resources: explorationData.resources,
        activeMission: explorationData.activeMission,
        missionEndTime: explorationData.missionEndTime,
        logs: explorationData.logs
    };
    
    localStorage.setItem('goldGameSave', JSON.stringify(player));
    localStorage.setItem('traditionalLotteryPurchased', player.traditionalLotteryPurchased);
    logAction('游戏已保存', 'success');
}

        // 加载游戏
        function loadGame() {
    loadSave();
   updateSectNameDisplay();
    updateDisplay();
   calculateTotalGPS();
 player.traditionalLotteryPurchased = localStorage.getItem('traditionalLotteryPurchased') === 'true';
 if (player.parking) {
        calculateOfflineParkingIncome();
    }
    logAction('游戏已加载', 'success');
}
 const ENCRYPTION_KEY = "your-secure-key-here-123";
        // 导出存档
        function exportSave() {
        try {
            // 转换玩家数据为JSON字符串
            const saveData = JSON.stringify(player);
            // 使用AES加密
            const encryptedData = CryptoJS.AES.encrypt(
                saveData,
                ENCRYPTION_KEY
            ).toString();
            
            // 复制加密后的数据到剪贴板
            const textArea = document.createElement('textarea');
            textArea.value = encryptedData;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            logAction('加密存档已复制到剪贴板', 'success');
        } catch (error) {
            logAction('存档导出失败', 'error');
            console.error('导出错误:', error);
        }
    }
 // 导出存档到文件（新增功能）
function downloadSave() {
    try {
        // 获取当前存档数据
        const saveData = JSON.stringify(player);
        
        // 使用AES加密存档
        const encryptedData = CryptoJS.AES.encrypt(
            saveData,
            ENCRYPTION_KEY
        ).toString();
        
        // 创建Blob对象
        const blob = new Blob([encryptedData], { type: 'text/plain' });
        
        // 创建下载链接
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `gold_adventurer_save_${new Date().toISOString().slice(0, 10)}.txt`;
        
        // 触发下载
        document.body.appendChild(a);
        a.click();
        
        // 清理
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        logAction('存档已加密并下载', 'success');
    } catch (error) {
        logAction('存档下载失败: ' + error.message, 'error');
        console.error('存档下载错误:', error);
    }
}
function importEncryptedSave() {
    // 检查冷却时间
    const lastImportTime = localStorage.getItem('lastImportTime');
    if (lastImportTime) {
        const currentTime = Date.now();
        const timeDiff = currentTime - parseInt(lastImportTime);
        const cooldown = 6 * 60 * 60 * 1000; // 6小时冷却时间
        
        if (timeDiff < cooldown) {
            const remaining = Math.ceil((cooldown - timeDiff) / (60 * 1000));
            logAction(`导入功能冷却中，请等待 ${remaining} 分钟后再试`, "error");
            return;
        }
    }
    
    // 触发文件选择器
    document.getElementById('fileInput').click();
    
    // 添加文件选择事件监听
    document.getElementById('fileInput').addEventListener('change', handleFileSelect);
}

// 处理文件选择
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // 检查文件类型
    if (file.type !== "text/plain" && !file.name.endsWith('.txt')) {
        logAction("请选择.txt格式的存档文件", "error");
        return;
    }
    
    // 读取文件内容
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const encryptedData = e.target.result;
            decryptAndLoadSave(encryptedData);
        } catch (error) {
            logAction("存档导入失败：" + error.message, "error");
            console.error("存档导入错误:", error);
        }
    };
    reader.readAsText(file);
}

// 解密并加载存档
function decryptAndLoadSave(encryptedData) {
    try {
        // 解密数据
        const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
        const saveData = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
        
        // 应用存档数据
        player = migrateSaveData(saveData);
        updateDisplay();
        logAction('加密存档导入成功！', 'success');
        
        // 更新导入时间
        localStorage.setItem('lastImportTime', Date.now().toString());
       saveGame();
      setTimeout(() => {
                location.reload(true);
            }, 1000);
    } catch (error) {
        logAction('存档导入失败：无效的存档或密钥错误', 'error');
        console.error('导入错误:', error);
    }
}
// 存档迁移函数（确保兼容性）
function migrateSaveData(save) {
    // 这里添加必要的存档迁移逻辑
    // 确保旧版存档能兼容新版游戏
    
    return {
        ...player, // 使用默认值
        ...save    // 覆盖为导入的数据
    };
}

        // 导入存档
    function importSave() {
    // 检查冷却时间
    const lastImportTime = localStorage.getItem('lastImportTime');
    if (lastImportTime) {
        const currentTime = Date.now();
        const timeDiff = currentTime - parseInt(lastImportTime);
        const cooldown = 6 * 60 * 60 * 1000; // 6小时冷却时间
        
        if (timeDiff < cooldown) {
            const remaining = Math.ceil((cooldown - timeDiff) / (60 * 1000));
            logAction(`导入功能冷却中，请等待 ${remaining} 分钟后再试`, "error");
            return;
        }
    }
    
    showCustomPrompt('请输入加密存档代码：', async (encryptedData) => {
        if (!encryptedData) return;
        
        try {
            // 解密存档数据
            const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
            const saveData = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
            
            // 应用存档数据
            player = migrateSaveData(saveData);
            updateDisplay();
            logAction('存档已成功导入！', 'success');
            
            // 更新导入时间
            localStorage.setItem('lastImportTime', Date.now().toString());
      saveGame();
      setTimeout(() => {
                location.reload(true);
            }, 1000);
        } catch (error) {
            logAction('存档导入失败：无效的存档或密钥错误', 'error');
            console.error('导入错误:', error);
        }
    });
}

// 获取加密的时间戳
async function getEncryptedTime(key) {
    const encrypted = localStorage.getItem(key);
    if (!encrypted) return null;
    try {
        const decrypted = CryptoJS.AES.decrypt(encrypted, ENCRYPTION_KEY);
        return parseInt(decrypted.toString(CryptoJS.enc.Utf8));
    } catch {
        return null;
    }
}

// 设置加密的时间戳
async function setEncryptedTime(key, value) {
    const encrypted = CryptoJS.AES.encrypt(String(value), ENCRYPTION_KEY);
    localStorage.setItem(key, encrypted.toString());
}

// 格式化时间显示
function formatTime(milliseconds) {
    const hours = Math.floor(milliseconds / 3600000);
    const mins = Math.floor((milliseconds % 3600000) / 60000);
    return `${hours}小时${mins}分钟`;
}
          function resetItems() {
      showCustomConfirm('确定要重置道具数据吗？所有道具将被清除！', (confirmed) => {
          if (confirmed) {
            // 重置道具数据
            player.items = {
                primaryGem: 0,
                advancedGem: 0,
                superiorGem: 0,
                divineGem: 0,
                vipPower: 0,
                refineStone: 0
            };

            // 更新道具页面
            updateItemDisplay();
            logAction('道具数据已重置', 'success');
           }
        });
   }
        // 重置游戏
        function resetGame() {
            showCustomConfirm('确定要重置游戏吗？所有进度将丢失！', (confirmed) => {
                if (confirmed) {
                    localStorage.removeItem('goldGameSave');
                    player = {
                        gold: 0,
                        diamond: 0,
                        titanium: 0,
                        starstone: 0,
                        cosmicstone: 0,
                        superstone: 0,
                        otherworldstone: 0, 
                        xingjiestone: 0, 
                        hundunstone: 0,  
                        lingtone: 0,
                        huangtone: 0,
                        mingtone: 0,
                        xutong: 0,
                        shitone: 0,
                        weitone: 0,
                        reincarnationCoin: 0,
                        reincarnationCount: 0,
                        equipment: [],
                        vip: {
        level: 1,
        power: 0, // 累计VIP能力值数量
    },
                        items: {
                            primaryGem: 0,
                            advancedGem: 0,
                            superiorGem: 0,
                            divineGem: 0,
                            vipPower: 0,
                            refineStone: 0 // 新增洗炼石
                        },
                        collections: {
                            lightSpeedHand: 0,
                            empHand: 0,
                            godlyHand: 0,
                            quickHand: 0,
                            shadowHand: 0,
                            quantumHand: 0,
                            lightningHand: 0,
                            divineHand: 0
                        },
                        pets: {
                             thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
                             chaosTaotie: { level: 0, cost: 1, multiplier: 0.50 },
                             netherQiongqi: { level: 0, cost: 1, multiplier: 2.50 },
                             abyssKun: { level: 0, cost: 1, multiplier: 12.50 },
                             primordialZhuLong: { level: 0, cost: 1, multiplier: 62.50 },
                            wanJunSuanNi: { level: 0, cost: 1, multiplier: 312.50 },
                            yanYuBiAn: { level: 0, cost: 1, multiplier: 1562.50 },
                            yuyu1: { level: 0, cost: 1, multiplier: 7812.50 },
                              yuyu2: { level: 0, cost: 1, multiplier: 39062.50 },
                            yuyu3: { level: 0, cost: 1, multiplier: 195312.50 },
                              yuyu4: { level: 0, cost: 1, multiplier: 976562.50 },
                            yuyu5: { level: 0, cost: 1, multiplier: 5882812.50 },
                            yuyu6: { level: 0, cost: 1, multiplier: 29414062.50 },
                              yuyu7: { level: 0, cost: 1, multiplier: 147070312.50 },
                            yuyu8: { level: 0, cost: 1, multiplier: 735351562.50 }
                        },
                        dungeonEquipment: [], // 新增副本装备
                        soulRings: [], // 新增魂环系统
                        techniques: {},
                        attributes: {
                         totalPoints: 0,
                        remainingPoints: 0,
                        health: 0,
                        attack: 0,
                        critRate: 0,
                         critDamage: 0,
                       multiAttack: 0,
                         block: 0
                        },
                        lastUpdate: Date.now(),
                        achievements: {
        first_equipment: false,
        first_rare: false,
        first_epic: false,
        first_legendary: false,
        first_ancient: false,
        first_divine: false,
        first_arcane: false,
        first_celestial: false,
        first_infernal: false,
        first_astral: false,
        first_primeval: false,
        first_transcendental: false,
        first_quantum: false,
        first_ultimate: false,
        first_chaos: false,
        first_eternal: false,
        first_void: false,
        first_genesis: false,
        first_divineRealm: false,
        first_apocalypse: false,
        first_yeyu1: false,
        first_yeyu2: false,
        first_yeyu3: false,
        first_yeyu4: false,
        first_yeyu5: false,
        first_yeyu6: false,
        first_yeyu7: false,
        first_yeyu8: false,
        first_yeyu9: false,
        first_yeyu10: false,
        first_yeyu11: false,
        first_yeyu12: false,
        first_yeyu13: false,
        first_yeyu14: false,
        first_yeyu15: false,
        first_yeyu16: false,
        first_yeyu17: false,
        first_yeyu18: false,
        first_yeyu19: false,
        first_yeyu20: false,
        first_yeyu21: false,
        first_yeyu22: false,
        first_yeyu23: false,
        first_yeyu24: false,
        // 宝箱成就
        common_chest_100: false,
        common_chest_10000: false,
        common_chest_1000000: false,
        common_chest_10000000: false,
        common_chest_100000000: false,
        advanced_chest_100: false,
        advanced_chest_10000: false,
        advanced_chest_1000000: false,
        advanced_chest_10000000: false,
        advanced_chest_100000000: false,
        rare_chest_100: false,
        rare_chest_10000: false,
        rare_chest_1000000: false,
        rare_chest_10000000: false,
        rare_chest_100000000: false,
        epic_chest_100: false,
        epic_chest_10000: false,
        epic_chest_1000000: false,
        epic_chest_10000000: false,
        epic_chest_100000000: false,
        legendary_chest_100: false,
        legendary_chest_10000: false,
        legendary_chest_1000000: false,
        legendary_chest_10000000: false,
        legendary_chest_100000000: false,
        chaos_chest_100: false,
        chaos_chest_10000: false,
        chaos_chest_1000000: false,
        chaos_chest_10000000: false,
        chaos_chest_100000000: false,
        apocalypse_chest_100: false,
        apocalypse_chest_10000: false,
        apocalypse_chest_1000000: false,
        apocalypse_chest_10000000: false,
        apocalypse_chest_100000000: false,
        yeyu1_chest_100: false,
        yeyu1_chest_10000: false,
        yeyu1_chest_1000000: false,
        yeyu1_chest_10000000: false,
        yeyu1_chest_100000000: false,
        yeyu2_chest_100: false,
        yeyu2_chest_10000: false,
        yeyu2_chest_1000000: false,
        yeyu2_chest_10000000: false,
        yeyu2_chest_100000000: false,
        yeyu3_chest_100: false,
        yeyu3_chest_10000: false,
        yeyu3_chest_1000000: false,
        yeyu3_chest_10000000: false,
        yeyu3_chest_100000000: false,
        yeyu4_chest_100: false,
        yeyu4_chest_10000: false,
        yeyu4_chest_1000000: false,
        yeyu4_chest_10000000: false,
        yeyu4_chest_100000000: false,
        yeyu5_chest_100: false,
        yeyu5_chest_10000: false,
        yeyu5_chest_1000000: false,
        yeyu5_chest_10000000: false,
        yeyu5_chest_100000000: false,
        yeyu6_chest_100: false,
        yeyu6_chest_10000: false,
        yeyu6_chest_1000000: false,
        yeyu6_chest_10000000: false,
        yeyu6_chest_100000000: false,
        yeyu7_chest_100: false,
        yeyu7_chest_10000: false,
        yeyu7_chest_1000000: false,
        yeyu7_chest_10000000: false,
        yeyu7_chest_100000000: false,
        yeyu8_chest_100: false,
        yeyu8_chest_10000: false,
        yeyu8_chest_1000000: false,
        yeyu8_chest_10000000: false,
        yeyu8_chest_100000000: false,
        "max_stage_10": false,
    "max_stage_30": false,
    "max_stage_60": false,
    "max_stage_90": false,
    "max_stage_120": false,
    "max_stage_200": false,
    "max_stage_300": false,
    "max_stage_400": false,
    "max_stage_500": false,
    "max_stage_600": false,
    "max_stage_700": false,
    "max_stage_800": false,
    "max_stage_900": false,
    "max_stage_1000": false,

    // 新增宠物成就状态
    "thunderKirin_10": false,
    "thunderKirin_50": false,
    "thunderKirin_100": false,
    "chaosTaotie_10": false,
    "chaosTaotie_50": false,
    "chaosTaotie_100": false,
    "netherQiongqi_10": false,
    "netherQiongqi_50": false,
    "netherQiongqi_100": false,
    "abyssKun_10": false,
    "abyssKun_50": false,
    "abyssKun_100": false,
    "primordialZhuLong_10": false,
    "primordialZhuLong_50": false,
    "primordialZhuLong_100": false,
    "wanJunSuanNi_10": false,
    "wanJunSuanNi_50": false,
    "wanJunSuanNi_100": false,
    "yanYuBiAn_10": false,
    "yanYuBiAn_50": false,
    "yanYuBiAn_100": false,
    "yuyu1_10": false,
    "yuyu1_50": false,
    "yuyu1_100": false,
    "yuyu2_10": false,
    "yuyu2_50": false,
    "yuyu2_100": false,
    "yuyu3_10": false,
    "yuyu3_50": false,
    "yuyu3_100": false,
    "yuyu4_10": false,
    "yuyu4_50": false,
    "yuyu4_100": false,
    "yuyu5_10": false,
    "yuyu5_50": false,
    "yuyu5_100": false,
    "yuyu6_10": false,
    "yuyu6_50": false,
    "yuyu6_100": false,
    "yuyu7_10": false,
    "yuyu7_50": false,
    "yuyu7_100": false,
    "yuyu8_10": false,
    "yuyu8_50": false,
    "yuyu8_100": false,
    // 新增魂环成就状态
    "year1_10": false,
    "year10_10": false,
    "year100_10": false,
    "year1000_10": false,
    "year10000_10": false,
    "year100000_10": false,
    "year1000000_10": false,
    "year10000000_10": false,
    "year100000000_10": false,
    "year1_100": false,
    "year10_100": false,
    "year100_100": false,
    "year1000_100": false,
    "year10000_100": false,
    "year100000_100": false,
    "year1000000_100": false,
    "year10000000_100": false,
    "year100000000_100": false,
    "year1_1000": false,
    "year10_1000": false,
    "year100_1000": false,
    "year1000_1000": false,
    "year10000_1000": false,
    "year100000_1000": false,
    "year1000000_1000": false,
    "year10000000_1000": false,
    "year100000000_1000": false,
    "year1_10000": false,
    "year10_10000": false,
    "year100_10000": false,
    "year1000_10000": false,
    "year10000_10000": false,
    "year100000_10000": false,
    "year1000000_10000": false,
    "year10000000_10000": false,
    "year100000000_10000": false,
    "year2_10": false,
    "year2_100": false,
    "year2_1000": false,
    "year2_10000": false,
    "year3_10": false,
    "year3_100": false,
    "year3_1000": false,
    "year3_10000": false,
    "year4_10": false,
    "year4_100": false,
    "year4_1000": false,
    "year4_10000": false,
    "year5_10": false,
    "year5_100": false,
    "year5_1000": false,
    "year5_10000": false,
    "year6_10": false,
    "year6_100": false,
    "year6_1000": false,
    "year6_10000": false,
    "year7_10": false,
    "year7_100": false,
    "year7_1000": false,
    "year7_10000": false,
    "year8_10": false,
    "year8_100": false,
    "year8_1000": false,
    "year8_10000": false,
    "year9_10": false,
    "year9_100": false,
    "year9_1000": false,
    "year9_10000": false,
    "year11_10": false,
    "year11_100": false,
    "year11_1000": false,
    "year11_10000": false,
    "year12_10": false,
    "year12_100": false,
    "year12_1000": false,
    "year12_10000": false,
    "year13_10": false,
    "year13_100": false,
    "year13_1000": false,
    "year13_10000": false,
    "year14_10": false,
    "year14_100": false,
    "year14_1000": false,
    "year14_10000": false,
    "year15_10": false,
    "year15_100": false,
    "year15_1000": false,
    "year15_10000": false,
    "year16_10": false,
    "year16_100": false,
    "year16_1000": false,
    "year16_10000": false,
    "year17_10": false,
    "year17_100": false,
    "year17_1000": false,
    "year17_10000": false,
    "year18_10": false,
    "year18_100": false,
    "year18_1000": false,
    "year18_10000": false,
    "year19_10": false,
    "year19_100": false,
    "year19_1000": false,
    "year19_10000": false,
    "year20_10": false,
    "year20_100": false,
    "year20_1000": false,
    "year20_10000": false,
    "year21_10": false,
    "year21_100": false,
    "year21_1000": false,
    "year21_10000": false,
    "year22_10": false,
    "year22_100": false,
    "year22_1000": false,
    "year22_10000": false,
    "year23_10": false,
    "year23_100": false,
    "year23_1000": false,
    "year23_10000": false,
    "year24_10": false,
    "year24_100": false,
    "year24_1000": false,
    "year24_10000": false,
    "year25_10": false,
    "year25_100": false,
    "year25_1000": false,
    "year25_10000": false,
    "year26_10": false,
    "year26_100": false,
    "year26_1000": false,
    "year26_10000": false,
    "year27_10": false,
    "year27_100": false,
    "year27_1000": false,
    "year27_10000": false,
    "year28_10": false,
    "year28_100": false,
    "year28_1000": false,
    "year28_10000": false,
    "year29_10": false,
    "year29_100": false,
    "year29_1000": false,
    "year29_10000": false,
    "year30_10": false,
    "year30_100": false,
    "year30_1000": false,
    "year30_10000": false,
    "year31_10": false,
    "year31_100": false,
    "year31_1000": false,
    "year31_10000": false,
    "year32_10": false,
    "year32_100": false,
    "year32_1000": false,
    "year32_10000": false,
    "year33_10": false,
    "year33_100": false,
    "year33_1000": false,
    "year33_10000": false,
    "year34_10": false,
    "year34_100": false,
    "year34_1000": false,
    "year34_10000": false,
    "year35_10": false,
    "year35_100": false,
    "year35_1000": false,
    "year35_10000": false,
    "year36_10": false,
    "year36_100": false,
    "year36_1000": false,
    "year36_10000": false,
    "year37_10": false,
    "year37_100": false,
    "year37_1000": false,
    "year37_10000": false,
    "world_boss_1st": false,
    "world_boss_top5": false,
    "world_boss_top10": false,
    "world_boss_participant": false,
    
        // 转生成就
        reincarnation_10: false,
        reincarnation_100: false,
        reincarnation_1000: false,
        reincarnation_10000: false
                        },
                        actionLogs: [], // 新增：统一存储所有操作日志
                        goldLogs: [], // 保留原有金币日志（如果仍需单独使用）
                        autoBuy: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], // 对应 7 种宝箱的自动购买状态
                        autoBuyMaterialChest: false, // 新增：自动购买材料宝箱的状态
                      autoBuyTechniqueChest: false,
                     autoBuyTechniqueMaxCost: 1e9,
                        gpsMultiplier: 1,
                        clickMultiplier: 1,
                        autoConvert: false,
                        autoConvertCurrency: { gold: false, diamond: false, titanium: false, starstone: false }, // 新增：自动兑换货币状态
                        clickTimestamps: [],
                        chestCounts: { common: 0, advanced: 0, rare: 0, epic: 0, legendary: 0 },
                        reincarnationStats: {
                            gpsBonus: { level: 0, cost: 1 },
                            equipmentLevelBonus: { level: 0, cost: 1 },
                            clickLimitBonus: { level: 0, cost: 1 }
                        },
                        materialChestCost: 1,
                        stockData: { // 新增股票数据
                            stocks: [
                                { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                                { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                                { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                                { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                                { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
                            ],
                            lastStockUpdate: Date.now()
                        },
                        lotteryResults: [], // 新增：彩票开奖结果
                        traditionalLotteryNumbers: [], // 新增：传统数字彩票号码
                        lastLotteryDraw: Date.now(), // 新增：上次开奖时间
                        bank: { // 新增银行系统
                            deposit: 0, // 存款金额
                            lastInterestUpdate: Date.now() // 上次利息计算时间
                        }
                    };
                    updateDisplay();
                    logAction('游戏已重置', 'success');
                }
            });
        }

        // 自定义对话框逻辑
        function showCustomConfirm(message, callback) {
            const dialog = document.getElementById('customDialog');
            const overlay = document.getElementById('dialogOverlay');
            document.getElementById('dialogMessage').textContent = message;
            
            dialog.style.display = 'block';
            overlay.style.display = 'block';

            const confirmBtn = document.getElementById('dialogConfirm');
            const cancelBtn = document.getElementById('dialogCancel');

            const handler = (result) => {
                dialog.style.display = 'none';
                overlay.style.display = 'none';
                callback(result);
                confirmBtn.removeEventListener('click', confirmHandler);
                cancelBtn.removeEventListener('click', cancelHandler);
            };

            const confirmHandler = () => handler(true);
            const cancelHandler = () => handler(false);

            confirmBtn.addEventListener('click', confirmHandler);
            cancelBtn.addEventListener('click', cancelHandler);
        }

        function showCustomPrompt(message, callback) {
            const dialog = document.getElementById('customDialog');
            const overlay = document.getElementById('dialogOverlay');
            document.getElementById('dialogMessage').textContent = message;
            document.getElementById('dialogInput').style.display = 'block'; // 显示输入框
            document.getElementById('dialogInput').value = ''; // 清空输入框

            dialog.style.display = 'block';
            overlay.style.display = 'block';

            const confirmBtn = document.getElementById('dialogConfirm');
            const cancelBtn = document.getElementById('dialogCancel');

            const handler = (result) => {
                dialog.style.display = 'none';
                overlay.style.display = 'none';
                document.getElementById('dialogInput').style.display = 'none'; // 隐藏输入框
                callback(result);
                confirmBtn.removeEventListener('click', confirmHandler);
                cancelBtn.removeEventListener('click', cancelHandler);
            };

            const confirmHandler = () => handler(document.getElementById('dialogInput').value);
            const cancelHandler = () => handler(null);

            confirmBtn.addEventListener('click', confirmHandler);
            cancelBtn.addEventListener('click', cancelHandler);
        }

        // 游戏初始化
        loadSave();
        setInterval(() => {
    let gpsPerSecond = getTotalGPS();
    // 如果在线且开启了加速，应用100倍加成
    if (document.visibilityState === 'visible' && player.onlineBoostEnabled) {
        gpsPerSecond *= 100;
    }
    player.gold += gpsPerSecond; // 每秒增加GPS
    autoConvertCurrency(); 
  gainCultivationExp();
 setInterval(calculateNightClubIncome, 1000);
 updateLiveStreamUI();
  initAutoDecomposeUI();
    checkAutoBuy(); 
 checkAutoDecompose();
    updateStockPrices(); 
    calculateBankInterest(); 
  calculateOfflineExpeditionRewards();
   updateFundValues(); // 添加这一行 
 checkAutoReincarnation(); // 检查自动转生
 updateCompanionDisplay();
 updateLotteryCountdown();
 updateDisplay();
   if (player.battle.maxStage > 1050) {
        localStorage.removeItem('goldGameSave');
        player = {
                        gold: 0,
                        diamond: 0,
                        titanium: 0,
                        starstone: 0,
                        cosmicstone: 0,
                        superstone: 0,
                        otherworldstone: 0, 
                        xingjiestone: 0, 
                        hundunstone: 0,  
                        lingtone: 0,
                        huangtone: 0,
                        mingtone: 0,
                        xutong: 0,
                        shitone: 0,
                        weitone: 0,
                        reincarnationCoin: 0,
                        reincarnationCount: 0,
                        equipment: [],
                        vip: {
        level: 1,
        power: 0, // 累计VIP能力值数量
    },
                        items: {
                            primaryGem: 0,
                            advancedGem: 0,
                            superiorGem: 0,
                            divineGem: 0,
                            vipPower: 0,
                            refineStone: 0 // 新增洗炼石
                        },
                        collections: {
                            lightSpeedHand: 0,
                            empHand: 0,
                            godlyHand: 0,
                            quickHand: 0,
                            shadowHand: 0,
                            quantumHand: 0,
                            lightningHand: 0,
                            divineHand: 0
                        },
                        pets: {
                             thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
                             chaosTaotie: { level: 0, cost: 1, multiplier: 0.50 },
                             netherQiongqi: { level: 0, cost: 1, multiplier: 2.50 },
                             abyssKun: { level: 0, cost: 1, multiplier: 12.50 },
                             primordialZhuLong: { level: 0, cost: 1, multiplier: 62.50 },
                            wanJunSuanNi: { level: 0, cost: 1, multiplier: 312.50 },
                            yanYuBiAn: { level: 0, cost: 1, multiplier: 1562.50 },
                            yuyu1: { level: 0, cost: 1, multiplier: 7812.50 },
                              yuyu2: { level: 0, cost: 1, multiplier: 39062.50 },
                            yuyu3: { level: 0, cost: 1, multiplier: 195312.50 },
                              yuyu4: { level: 0, cost: 1, multiplier: 976562.50 },
                            yuyu5: { level: 0, cost: 1, multiplier: 5882812.50 },
                            yuyu6: { level: 0, cost: 1, multiplier: 29414062.50 },
                              yuyu7: { level: 0, cost: 1, multiplier: 147070312.50 },
                            yuyu8: { level: 0, cost: 1, multiplier: 735351562.50 }
                        },
                        dungeonEquipment: [], // 新增副本装备
                        soulRings: [], // 新增魂环系统
                        techniques: {},
                        attributes: {
                         totalPoints: 0,
                        remainingPoints: 0,
                        health: 0,
                        attack: 0,
                        critRate: 0,
                         critDamage: 0,
                       multiAttack: 0,
                         block: 0
                        },
                        lastUpdate: Date.now(),
                        achievements: {
        first_equipment: false,
        first_rare: false,
        first_epic: false,
        first_legendary: false,
        first_ancient: false,
        first_divine: false,
        first_arcane: false,
        first_celestial: false,
        first_infernal: false,
        first_astral: false,
        first_primeval: false,
        first_transcendental: false,
        first_quantum: false,
        first_ultimate: false,
        first_chaos: false,
        first_eternal: false,
        first_void: false,
        first_genesis: false,
        first_divineRealm: false,
        first_apocalypse: false,
        first_yeyu1: false,
        first_yeyu2: false,
        first_yeyu3: false,
        first_yeyu4: false,
        first_yeyu5: false,
        first_yeyu6: false,
        first_yeyu7: false,
        first_yeyu8: false,
        first_yeyu9: false,
        first_yeyu10: false,
        first_yeyu11: false,
        first_yeyu12: false,
        first_yeyu13: false,
        first_yeyu14: false,
        first_yeyu15: false,
        first_yeyu16: false,
        first_yeyu17: false,
        first_yeyu18: false,
        first_yeyu19: false,
        first_yeyu20: false,
        first_yeyu21: false,
        first_yeyu22: false,
        first_yeyu23: false,
        first_yeyu24: false,
        // 宝箱成就
        common_chest_100: false,
        common_chest_10000: false,
        common_chest_1000000: false,
        common_chest_10000000: false,
        common_chest_100000000: false,
        advanced_chest_100: false,
        advanced_chest_10000: false,
        advanced_chest_1000000: false,
        advanced_chest_10000000: false,
        advanced_chest_100000000: false,
        rare_chest_100: false,
        rare_chest_10000: false,
        rare_chest_1000000: false,
        rare_chest_10000000: false,
        rare_chest_100000000: false,
        epic_chest_100: false,
        epic_chest_10000: false,
        epic_chest_1000000: false,
        epic_chest_10000000: false,
        epic_chest_100000000: false,
        legendary_chest_100: false,
        legendary_chest_10000: false,
        legendary_chest_1000000: false,
        legendary_chest_10000000: false,
        legendary_chest_100000000: false,
        chaos_chest_100: false,
        chaos_chest_10000: false,
        chaos_chest_1000000: false,
        chaos_chest_10000000: false,
        chaos_chest_100000000: false,
        apocalypse_chest_100: false,
        apocalypse_chest_10000: false,
        apocalypse_chest_1000000: false,
        apocalypse_chest_10000000: false,
        apocalypse_chest_100000000: false,
        yeyu1_chest_100: false,
        yeyu1_chest_10000: false,
        yeyu1_chest_1000000: false,
        yeyu1_chest_10000000: false,
        yeyu1_chest_100000000: false,
        yeyu2_chest_100: false,
        yeyu2_chest_10000: false,
        yeyu2_chest_1000000: false,
        yeyu2_chest_10000000: false,
        yeyu2_chest_100000000: false,
        yeyu3_chest_100: false,
        yeyu3_chest_10000: false,
        yeyu3_chest_1000000: false,
        yeyu3_chest_10000000: false,
        yeyu3_chest_100000000: false,
        yeyu4_chest_100: false,
        yeyu4_chest_10000: false,
        yeyu4_chest_1000000: false,
        yeyu4_chest_10000000: false,
        yeyu4_chest_100000000: false,
        yeyu5_chest_100: false,
        yeyu5_chest_10000: false,
        yeyu5_chest_1000000: false,
        yeyu5_chest_10000000: false,
        yeyu5_chest_100000000: false,
        yeyu6_chest_100: false,
        yeyu6_chest_10000: false,
        yeyu6_chest_1000000: false,
        yeyu6_chest_10000000: false,
        yeyu6_chest_100000000: false,
        yeyu7_chest_100: false,
        yeyu7_chest_10000: false,
        yeyu7_chest_1000000: false,
        yeyu7_chest_10000000: false,
        yeyu7_chest_100000000: false,
        yeyu8_chest_100: false,
        yeyu8_chest_10000: false,
        yeyu8_chest_1000000: false,
        yeyu8_chest_10000000: false,
        yeyu8_chest_100000000: false,
        "max_stage_10": false,
    "max_stage_30": false,
    "max_stage_60": false,
    "max_stage_90": false,
    "max_stage_120": false,
    "max_stage_200": false,
    "max_stage_300": false,
    "max_stage_400": false,
    "max_stage_500": false,
    "max_stage_600": false,
    "max_stage_700": false,
    "max_stage_800": false,
    "max_stage_900": false,
    "max_stage_1000": false,

    // 新增宠物成就状态
    "thunderKirin_10": false,
    "thunderKirin_50": false,
    "thunderKirin_100": false,
    "chaosTaotie_10": false,
    "chaosTaotie_50": false,
    "chaosTaotie_100": false,
    "netherQiongqi_10": false,
    "netherQiongqi_50": false,
    "netherQiongqi_100": false,
    "abyssKun_10": false,
    "abyssKun_50": false,
    "abyssKun_100": false,
    "primordialZhuLong_10": false,
    "primordialZhuLong_50": false,
    "primordialZhuLong_100": false,
    "wanJunSuanNi_10": false,
    "wanJunSuanNi_50": false,
    "wanJunSuanNi_100": false,
    "yanYuBiAn_10": false,
    "yanYuBiAn_50": false,
    "yanYuBiAn_100": false,
    "yuyu1_10": false,
    "yuyu1_50": false,
    "yuyu1_100": false,
    "yuyu2_10": false,
    "yuyu2_50": false,
    "yuyu2_100": false,
    "yuyu3_10": false,
    "yuyu3_50": false,
    "yuyu3_100": false,
    "yuyu4_10": false,
    "yuyu4_50": false,
    "yuyu4_100": false,
    "yuyu5_10": false,
    "yuyu5_50": false,
    "yuyu5_100": false,
    "yuyu6_10": false,
    "yuyu6_50": false,
    "yuyu6_100": false,
    "yuyu7_10": false,
    "yuyu7_50": false,
    "yuyu7_100": false,
    "yuyu8_10": false,
    "yuyu8_50": false,
    "yuyu8_100": false,
    // 新增魂环成就状态
    "year1_10": false,
    "year10_10": false,
    "year100_10": false,
    "year1000_10": false,
    "year10000_10": false,
    "year100000_10": false,
    "year1000000_10": false,
    "year10000000_10": false,
    "year100000000_10": false,
    "year1_100": false,
    "year10_100": false,
    "year100_100": false,
    "year1000_100": false,
    "year10000_100": false,
    "year100000_100": false,
    "year1000000_100": false,
    "year10000000_100": false,
    "year100000000_100": false,
    "year1_1000": false,
    "year10_1000": false,
    "year100_1000": false,
    "year1000_1000": false,
    "year10000_1000": false,
    "year100000_1000": false,
    "year1000000_1000": false,
    "year10000000_1000": false,
    "year100000000_1000": false,
    "year1_10000": false,
    "year10_10000": false,
    "year100_10000": false,
    "year1000_10000": false,
    "year10000_10000": false,
    "year100000_10000": false,
    "year1000000_10000": false,
    "year10000000_10000": false,
    "year100000000_10000": false,
    "year2_10": false,
    "year2_100": false,
    "year2_1000": false,
    "year2_10000": false,
    "year3_10": false,
    "year3_100": false,
    "year3_1000": false,
    "year3_10000": false,
    "year4_10": false,
    "year4_100": false,
    "year4_1000": false,
    "year4_10000": false,
    "year5_10": false,
    "year5_100": false,
    "year5_1000": false,
    "year5_10000": false,
    "year6_10": false,
    "year6_100": false,
    "year6_1000": false,
    "year6_10000": false,
    "year7_10": false,
    "year7_100": false,
    "year7_1000": false,
    "year7_10000": false,
    "year8_10": false,
    "year8_100": false,
    "year8_1000": false,
    "year8_10000": false,
    "year9_10": false,
    "year9_100": false,
    "year9_1000": false,
    "year9_10000": false,
    "year11_10": false,
    "year11_100": false,
    "year11_1000": false,
    "year11_10000": false,
    "year12_10": false,
    "year12_100": false,
    "year12_1000": false,
    "year12_10000": false,
    "year13_10": false,
    "year13_100": false,
    "year13_1000": false,
    "year13_10000": false,
    "year14_10": false,
    "year14_100": false,
    "year14_1000": false,
    "year14_10000": false,
    "year15_10": false,
    "year15_100": false,
    "year15_1000": false,
    "year15_10000": false,
    "year16_10": false,
    "year16_100": false,
    "year16_1000": false,
    "year16_10000": false,
    "year17_10": false,
    "year17_100": false,
    "year17_1000": false,
    "year17_10000": false,
    "year18_10": false,
    "year18_100": false,
    "year18_1000": false,
    "year18_10000": false,
    "year19_10": false,
    "year19_100": false,
    "year19_1000": false,
    "year19_10000": false,
    "year20_10": false,
    "year20_100": false,
    "year20_1000": false,
    "year20_10000": false,
    "year21_10": false,
    "year21_100": false,
    "year21_1000": false,
    "year21_10000": false,
    "year22_10": false,
    "year22_100": false,
    "year22_1000": false,
    "year22_10000": false,
    "year23_10": false,
    "year23_100": false,
    "year23_1000": false,
    "year23_10000": false,
    "year24_10": false,
    "year24_100": false,
    "year24_1000": false,
    "year24_10000": false,
    "year25_10": false,
    "year25_100": false,
    "year25_1000": false,
    "year25_10000": false,
    "year26_10": false,
    "year26_100": false,
    "year26_1000": false,
    "year26_10000": false,
    "year27_10": false,
    "year27_100": false,
    "year27_1000": false,
    "year27_10000": false,
    "year28_10": false,
    "year28_100": false,
    "year28_1000": false,
    "year28_10000": false,
    "year29_10": false,
    "year29_100": false,
    "year29_1000": false,
    "year29_10000": false,
    "year30_10": false,
    "year30_100": false,
    "year30_1000": false,
    "year30_10000": false,
    "year31_10": false,
    "year31_100": false,
    "year31_1000": false,
    "year31_10000": false,
    "year32_10": false,
    "year32_100": false,
    "year32_1000": false,
    "year32_10000": false,
    "year33_10": false,
    "year33_100": false,
    "year33_1000": false,
    "year33_10000": false,
    "year34_10": false,
    "year34_100": false,
    "year34_1000": false,
    "year34_10000": false,
    "year35_10": false,
    "year35_100": false,
    "year35_1000": false,
    "year35_10000": false,
    "year36_10": false,
    "year36_100": false,
    "year36_1000": false,
    "year36_10000": false,
    "year37_10": false,
    "year37_100": false,
    "year37_1000": false,
    "year37_10000": false,
    "world_boss_1st": false,
    "world_boss_top5": false,
    "world_boss_top10": false,
    "world_boss_participant": false,
    
        // 转生成就
        reincarnation_10: false,
        reincarnation_100: false,
        reincarnation_1000: false,
        reincarnation_10000: false
                        },
                        actionLogs: [], // 新增：统一存储所有操作日志
                        goldLogs: [], // 保留原有金币日志（如果仍需单独使用）
                        autoBuy: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], // 对应 7 种宝箱的自动购买状态
                        autoBuyMaterialChest: false, // 新增：自动购买材料宝箱的状态
                      autoBuyTechniqueChest: false,
                      autoBuyTechniqueMaxCost: 1e9,
                        gpsMultiplier: 1,
                        clickMultiplier: 1,
                        autoConvert: false,
                        autoConvertCurrency: { gold: false, diamond: false, titanium: false, starstone: false }, // 新增：自动兑换货币状态
                        clickTimestamps: [],
                        chestCounts: { common: 0, advanced: 0, rare: 0, epic: 0, legendary: 0 },
                        reincarnationStats: {
                            gpsBonus: { level: 0, cost: 1 },
                            equipmentLevelBonus: { level: 0, cost: 1 },
                            clickLimitBonus: { level: 0, cost: 1 }
                        },
                        materialChestCost: 1,
                        stockData: { // 新增股票数据
                            stocks: [
                                { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                                { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                                { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                                { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                                { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
                            ],
                            lastStockUpdate: Date.now()
                        },
                        lotteryResults: [], // 新增：彩票开奖结果
                        traditionalLotteryNumbers: [], // 新增：传统数字彩票号码
                        lastLotteryDraw: Date.now(), // 新增：上次开奖时间
                        bank: { // 新增银行系统
                            deposit: 0, // 存款金额
                            lastInterestUpdate: Date.now() // 上次利息计算时间
                        }
        };
        updateDisplay();
        logAction('游戏已自动重置', 'success');
    }
}, 1000);
        updateDisplay();

        // 页面可见性监听
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                loadSave();
                updateDisplay();
            }
        });

        // 新增：切换游戏日志分页
        function switchLogTab(page) {
            document.getElementById('gameLogPage1').classList.remove('active');
            document.getElementById('gameLogPage2').classList.remove('active');
            document.getElementById('gameLogPage3').classList.remove('active');
            document.getElementById('gameLogPage4').classList.remove('active');
            document.getElementById(`gameLogPage${page}`).classList.add('active');
            document.querySelectorAll('.log-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.log-tab[onclick="switchLogTab(${page})"]`).classList.add('active');
        }
   function toggleAutoConvertUI() {
    const ui = document.getElementById('autoConvertUI');
    const overlay = document.getElementById('autoConvertOverlay');
    
    if (ui.style.display === 'none') {
        ui.style.display = 'block';
        overlay.style.display = 'block';
    } else {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    }
}
function toggleAutoBuyShop() {
    const shop = document.getElementById('autoBuyShop');
    shop.style.display = shop.style.display === 'none' ? 'block' : 'none';
}
function toggleShopUI() {
    const shopUI = document.getElementById('shopUI');
    const overlay = document.getElementById('shopOverlay');
    
    if (shopUI.style.display === 'none') {
        shopUI.style.display = 'block';
        overlay.style.display = 'block';
    } else {
        shopUI.style.display = 'none';
        overlay.style.display = 'none';
    }
}
function toggleSettingsUI() {
    const dialog = document.getElementById('settingsDialog');
    const overlay = document.getElementById('settingsOverlay');
    
    if (dialog.style.display === 'none') {
        dialog.style.display = 'block';
        overlay.style.display = 'block';
    } else {
        dialog.style.display = 'none';
        overlay.style.display = 'none';
    }
}

        // 新增：打怪模式逻辑
        function toggleMonsterUI() {
        // 检查转生次数是否达到1次
    if (player.reincarnationCount < 1) {
        alert("需要达到1转才能开启打怪模式！");
        return;
    }
    const monsterUI = document.getElementById('monsterUI');
    monsterUI.style.display = monsterUI.style.display === 'none' ? 'block' : 'none';
    if (monsterUI.style.display === 'block') {
        // 重新生成玩家属性，但不重新生成怪物
        player.battle.playerHealth = player.reincarnationCount;
        player.battle.playerAttack = getTotalClickValue();
      updateOfficialSystemDisplay();
        updateMonsterUI(); // 更新UI显示
      updatePlayerBattleStats();
      
    }
}

        function startBattle() {
    player.battle.playerHealth = 1 + player.reincarnationCount;
    player.battle.playerAttack = 1 + getTotalClickValue();
    player.battle.playerCritRate = 0.1 + player.attributes.critRate * 0.0005; // 初始暴击率 + 属性加成
    player.battle.playerCritDamage = 1.5 + player.attributes.critDamage * 0.005; // 初始爆伤 + 属性加成
    player.battle.currentStage = player.battle.currentStage || 0;
    player.battle.maxStage = Math.max(player.battle.maxStage, player.battle.currentStage);
   updateOfficialSystemDisplay();
    updateMonsterUI(); // 更新UI显示
}

        const monsterModifiers = {
    // 防御类词条
    "硬化": { damageReduction: 0.9 }, // 受到伤害减少10%
    "钢铁": { damageReduction: 0.99 }, // 受到伤害减少20%
    "金身": { damageReduction: 0.999 }, // 受到伤害减少50%
    "不败": { damageReduction: 0.9999 }, // 受到伤害减少70%
    "圣体": { damageReduction: 0.99999 }, // 受到伤害减少80%
    "不死": { damageReduction: 0.999999 }, // 受到伤害减少99%

    // 攻击类词条
    "强击": { attackMultiplier: 2.10 }, 
    "突击": { attackMultiplier: 3.20 }, 
    "嗜血": { attackMultiplier: 4.30 }, 
    "炼狱": { attackMultiplier: 5.40 }, 
    "修罗": { attackMultiplier: 6.50 }, 
    "死神": { attackMultiplier: 10.00 }, 

    // 闪避类词条
    "初级闪避": { dodgeChance: 0.5 },
    "中级闪避": { dodgeChance: 0.6 }, 
    "高级闪避": { dodgeChance: 0.7 }, 
    "终极闪避": { dodgeChance: 0.8 }, 
    "神级闪避": { dodgeChance: 0.9 }, 

    // 特殊效果类词条
    "抵消": { blockCount: 2 }, // 可以抵消玩家2次攻击
    "金光": { blockCount: 3 }, // 可以抵消玩家3次攻击
    "神盾": { blockCount: 5 }, // 可以抵消玩家5次攻击

    // 特殊攻击类词条
    "连击": { attackCount: 3 }, // 攻击5次
    "虚弱": { damageTakenMultiplier: 1.50 } // 受到玩家伤害增加50%
};
 
const monsterRankModifiers = {
    "普通": { pool: ["硬化", "强击", "初级闪避", "虚弱"], selectCount: 2 },
    "精英": { pool: ["连击", "硬化", "强击", "初级闪避"], selectCount: 2 },
    "普通BOSS": { pool: ["虚弱", "连击", "钢铁", "突击", "初级闪避"], selectCount: 3 },
    "特殊BOSS": { pool: ["连击",  "钢铁", "突击", "中级闪避"], selectCount: 3 },
    "领主BOSS": { pool: ["连击", "钢铁", "突击", "嗜血", "中级闪避", "抵消"], selectCount: 4 },
    "霸主级BOSS": { pool: ["金身", "连击", "嗜血", "突击", "中级闪避", "抵消"], selectCount: 4 },
    "王级BOSS": { pool: ["连击", "金身", "炼狱", "嗜血", "高级闪避", "抵消"], selectCount: 4 },
    "皇级BOSS": { pool: ["连击", "不败", "炼狱", "高级闪避", "抵消"], selectCount: 4 },
    "帝级BOSS": { pool: ["连击", "不败", "炼狱", "修罗", "高级闪避", "金光"], selectCount: 4 },
    "神级BOSS": { pool: ["连击", "圣体", "修罗", "终极闪避", "金光", "死神"], selectCount: 5 },
    "圣级BOSS": { pool: ["连击", "不死", "死神", "神级闪避", "神盾"], selectCount: 5 }
};
 const monsterNames = [
    "夜叉丸", "玄天青龙帝", "九幽冥凤尊", "太虚剑仙·凌霄", "紫微星君·太华",
    "黄泉引渡使", "焚天炎龙圣主", "噬魂夜叉皇", "青丘九尾天狐", "白骨夫人·夜魅",
    "天河银蛟龙王", "幽冥骑士·龙煞", "永恒梦魇·修普诺斯", "幽冥鬼判·玄煞", "金翅大鹏明王",
    "天启四骑士·天罚", "混沌主宰", "哥布林", "太虚剑灵", "月宫蟾仙",
    "九幽煞魔", "幽冥鬼王", "幽狱魔尊", "混元道傀", "八荒龙神",
    "炎阳帝君", "星垣神王", "黄金狮心王·理查德", "幽冥鬼判·玄煞", "金翅大鹏明王",
    "玉虚雷神将", "鸿蒙祖神", "玄天帝君", "风暴之眼", "暗月武士·凯恩",
    "黑丝女神·闫闫", "萝莉·茶茶", "修罗刀魔·无间", "机械降神·欧米茄", "光年守望者·天狼",
    "寒冰之魂", "血月狼王·芬里尔", "永恒黑暗·厄瑞玻斯", "虚数之龙·阿莱夫", "数据化身·尼奥"
];

function getRandomMonsterName() {
    return monsterNames[Math.floor(Math.random() * monsterNames.length)];
}

function generateMonster() {
    const stage = player.battle.currentStage;
    const monsterRanks = ['普通', '精英', '普通BOSS', '特殊BOSS', '领主BOSS', '霸主级BOSS', '王级BOSS', '皇级BOSS', '帝级BOSS', '神级BOSS', '圣级BOSS'];
    const rankProbabilities = [0.45, 0.20, 0.10, 0.06, 0.05, 0.04, 0.03, 0.03, 0.02, 0.015, 0.005];

    // 随机生成怪物品阶
    let rankIndex = 0;
    let rand = Math.random();
    for (let i = 0; i < rankProbabilities.length; i++) {
        rand -= rankProbabilities[i];
        if (rand < 0) {
            rankIndex = i;
            break;
        }
    }
    const rank = monsterRanks[rankIndex];

    // 根据品阶选择词条
    const modifierPool = monsterRankModifiers[rank].pool;
    const selectCount = monsterRankModifiers[rank].selectCount;
    const selectedModifiers = [];
    const usedModifiers = new Set(); // 用于记录已经使用的词条

    for (let i = 0; i < selectCount; i++) {
        let modifier;
        do {
            modifier = modifierPool[Math.floor(Math.random() * modifierPool.length)];
        } while (usedModifiers.has(modifier)); // 确保词条不重复
        usedModifiers.add(modifier); // 记录已使用的词条
        selectedModifiers.push(modifier);
    }

    // 计算怪物属性
    const healthMultiplier = Math.pow(2, stage);
    let attackMultiplier;
    if (stage <= 5) {
        attackMultiplier = Math.floor(Math.random() * 3) + 1;
    } else if (stage <= 15) {
        attackMultiplier = 35 + (stage - 10) * 10;
    } else if (stage <= 25) {
        attackMultiplier = 50 + (stage - 10) * 10;
    } else if (stage <= 40) {
        attackMultiplier = 100 + (stage - 10) * 10;
    } else if (stage <= 65) {
        attackMultiplier = 350 + (stage - 9) * 100;
    } else if (stage <= 90) {
        attackMultiplier = 3500 + (stage - 64) * 100;
    } else if (stage <= 120) {
        attackMultiplier = 35000 + (stage - 89) * 1000;
    } else if (stage <= 250) {
        attackMultiplier = 350000 + (stage - 119) * 100000;
    } else if (stage <= 350) {
        attackMultiplier = 3500000 + (stage - 249) * 1000000000;
    } else if (stage <= 450) {
        attackMultiplier = 450000000 + (stage - 349) * 1000000000000;
    } else if (stage <= 550) {
        attackMultiplier = 5500009000 + (stage - 449) * 1000000000000000000;
    } else if (stage <= 650) {
        attackMultiplier = 650000000900 + (stage - 549) * 1000000000000000000000000;
    } else if (stage <= 700) {
        attackMultiplier = 6500000000900 + (stage - 649) * 100000000000000000000000000000000;
     } else if (stage <= 750) {
        attackMultiplier = 6500000000000900 + (stage - 699) * 10000000000000000000000000000000000000;
     } else if (stage <= 790) {
        attackMultiplier = 6500000000000000900 + (stage - 549) * 1000000000000000000000000000000000000000000;
    } else if (stage <= 820) {
        attackMultiplier = 65000000000000000000900 + (stage - 549) * 10000000000000000000000000000000000000000000000;
    } else if (stage <= 840) {
        attackMultiplier = 6500000000000000000000000900 + (stage - 549) * 1000000000000000000000000000000000000000000000000000000;
    } else if (stage <= 860) {
        attackMultiplier = 10000000000000000000000000000000 + (stage - 649) * 100000000000000000000000000000000000000000000000000000000000000000000;
    } else if (stage <= 900) {
        attackMultiplier = 100000000000000000000000000000000000 + (stage - 749) * 100000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    } else {
        attackMultiplier = 1000000000000000000000000000000000000000 + (stage - 849) * 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    }

    // 应用词条效果
    let attack = attackMultiplier;
    let damageReduction = 0;
    let dodgeChance = 0;
    let blockCount = 0;
    let attackCount = 1;
    let damageTakenMultiplier = 1;

    selectedModifiers.forEach(modifier => {
        const effect = monsterModifiers[modifier];
        if (effect.attackMultiplier) attack *= effect.attackMultiplier;
        if (effect.damageReduction) damageReduction += effect.damageReduction;
        if (effect.dodgeChance) dodgeChance += effect.dodgeChance;
        if (effect.blockCount) blockCount += effect.blockCount;
        if (effect.attackCount) attackCount = effect.attackCount;
        if (effect.damageTakenMultiplier) damageTakenMultiplier *= effect.damageTakenMultiplier;
    });

    // 生成怪物
    player.battle.monster = {
        name: `${getRandomMonsterName()}             等级${attackMultiplier  * 2 + 7}`, // 随机生成怪物名字
        rank: rank,
        health: 10000 * healthMultiplier,
        attack: attack,
        modifiers: selectedModifiers,
        damageReduction: damageReduction,
        dodgeChance: dodgeChance,
        blockCount: blockCount,
        attackCount: attackCount,
        damageTakenMultiplier: damageTakenMultiplier
    };
}

       function updateMonsterUI() {
    document.getElementById('playerHealth').textContent = player.battle.playerHealth.toExponential(3);
    document.getElementById('playerAttack').textContent = player.battle.playerAttack.toExponential(3);
    document.getElementById('playerCritRate').textContent = `${((player.battle.playerCritRate + player.attributes.critRate * 0.0005) * 100).toFixed(1)}%`; // 更新暴击率显示
    document.getElementById('playerCritDamage').textContent = `${((player.battle.playerCritDamage + player.attributes.critDamage * 0.005) * 100).toFixed(1)}%`; // 更新爆伤显示
    document.getElementById('playerAccuracy').textContent = `${(player.battle.playerAccuracy * 100).toFixed(1)}%`;
    document.getElementById('playerDodge').textContent = `${(player.battle.playerDodge * 100).toFixed(1)}%`;

    document.getElementById('currentStage').textContent = player.battle.currentStage + 1;
    document.getElementById('monsterName').textContent = player.battle.monster.name;
    document.getElementById('monsterRank').textContent = player.battle.monster.rank;
    document.getElementById('monsterHealth').textContent = player.battle.monster.health.toExponential(3);
    document.getElementById('monsterAttack').textContent = player.battle.monster.attack.toExponential(3);

    // 显示怪物词条
    const modifiers = player.battle.monster.modifiers.join(', ');
    document.getElementById('monsterModifiers').textContent = ` ${modifiers}`;
     
}
       function attackMonster() {
    const monster = player.battle.monster;

    // 应用属性加成
    const playerAttack = player.battle.playerAttack;
    const playerCritRate = player.battle.playerCritRate;
    const playerCritDamage = player.battle.playerCritDamage;
    const playerMultiAttack = player.battle.playerMultiAttack;
    const playerBlock = Math.floor(player.attributes.block / 5000000); // 每5000000点抵消属性点抵消1次攻击

    // 新增：统计变量
    let totalDamage = 0;           // 总伤害
    let dodgeCount = 0;            // 闪避次数
    let critCount = 0;             // 暴击次数
    let normalDamage = 0;          // 普通伤害总和
    const totalAttacks = playerMultiAttack + 1; // 总连击次数

    // 连击次数
    for (let i = 0; i < totalAttacks; i++) {
        // 计算命中
        if (Math.random() < monster.dodgeChance) {
            dodgeCount++; // 记录闪避次数
            continue;
        }

        // 计算伤害
        let damage = playerAttack * monster.damageTakenMultiplier;
        damage *= (1 - monster.damageReduction); // 应用伤害减免

        // 抵消效果
        if (monster.blockCount > 0) {
            monster.blockCount--;
            logBattleAction(`你的攻击被抵消了！怪物剩余抵消次数：${monster.blockCount}`);
            continue;
        }

        // 暴击计算
        if (Math.random() < playerCritRate) {
            damage *= playerCritDamage; // 应用爆伤加成
            critCount++;
            totalDamage += damage;
        } else {
            normalDamage += damage;
            totalDamage += damage;
        }

        // 应用伤害
        monster.health -= damage;

        if (monster.health <= 0) {
            break; // 如果怪物被击败，跳出连击循环
        }
    }

    // 新增：输出综合攻击日志
    logBattleAction(`你造成了${totalDamage.toFixed(0)}点伤害 (${totalAttacks}连击) - 普通伤害: ${normalDamage.toFixed(0)}, 闪避x${dodgeCount} 暴击x${critCount}`);

    // 检查怪物是否被击败
    if (monster.health <= 0) {
        logBattleAction(`你击败了${monster.name}，通关第${player.battle.currentStage + 1}关！`);
        player.battle.currentStage++;
        player.battle.maxStage = Math.max(player.battle.maxStage, player.battle.currentStage);
        
        updatePlayerBattleStats();
        // 更新总属性点
        player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10;
        // 检查最大关卡成就
        checkMaxStageAchievements();
        // 新增：检查称号解锁
        checkTitleUnlocks();
        updateOfficialSystemDisplay();
        // 掉落副本装备
        dropDungeonEquipment(player.battle.currentStage);

        // 掉落魂环
        dropSoulRing(player.battle.currentStage);
       
        // 掉落道具
        dropItemsAfterBattle();
                 
        generateMonster();
    }

    updateMonsterUI();

    function checkMaxStageAchievements() {
    const maxStage = player.battle.maxStage;
    const achievements = [
        { stage: 10, key: 'max_stage_10' },
        { stage: 30, key: 'max_stage_30' },
        { stage: 60, key: 'max_stage_60' },
        { stage: 90, key: 'max_stage_90' },
        { stage: 120, key: 'max_stage_120' },
        { stage: 200, key: 'max_stage_200' },
        { stage: 300, key: 'max_stage_300' },
        { stage: 400, key: 'max_stage_400' },
        { stage: 500, key: 'max_stage_500' },
        { stage: 600, key: 'max_stage_600' },
        { stage: 700, key: 'max_stage_700' },
        { stage: 800, key: 'max_stage_800' },
        { stage: 900, key: 'max_stage_900' },
        { stage: 1000, key: 'max_stage_1000' },
    ];

    achievements.forEach(({ stage, key }) => {
        if (maxStage >= stage && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updatePlayerBattleStats();
            }
        }
    });
}
    // 怪物反击逻辑
    if (monster.health > 0) {
        for (let i = 0; i < monster.attackCount; i++) {
            if (Math.random() > player.battle.playerDodge) {
                if (playerBlock > 0) {
                    playerBlock--; // 消耗一次抵消次数
                    logBattleAction(`你抵消了怪物的攻击！剩余抵消次数：${playerBlock}`);
                } else {
                    player.battle.playerHealth -= monster.attack; // 如果没有抵消次数，玩家受到伤害
                    logBattleAction(`${monster.name}对你造成了${monster.attack.toFixed(0)}点伤害`);
                }
            } else {
                logBattleAction('你闪避了怪物的攻击！');
            }
        }
    // 检查玩家是否被击败
        if (player.battle.playerHealth <= 0) {
            logBattleAction('你被怪物击败了！');
            monster.health = 10000 * Math.pow(2, player.battle.currentStage); // 重置怪物生命
          updatePlayerBattleStats();
       updateOfficialSystemDisplay();
        }
    }

    updateMonsterUI();
}
   // 掉落道具函数
function dropItemsAfterBattle() {
    const stage = player.battle.currentStage;

    // 洗炼石掉落（30关以上0.1%概率）
    if (stage >= 30 && Math.random() < 0.0005) {
        player.items.refineStone++;
        logBattleAction('获得了洗炼石！');
    }
     if (stage >= 1 && Math.random() < 0.0001) {
        player.items.vipPower++;
        logBattleAction('获得了VIP能力值！');
    }
   if (stage >= 50 && Math.random() < 0.0005) {
        player.items.primaryGem++;
        logBattleAction('获得了初级宝石！');
    }
     if (stage >= 100 && Math.random() < 0.0005) {
        player.items.advancedGem++;
        logBattleAction('获得了高级宝石！');
    }
     if (stage >= 150 && Math.random() < 0.0005) {
        player.items.superiorGem++;
        logBattleAction('获得了极品宝石！');
    }

     if (stage >= 1 && Math.random() < 0.001) {
        player.items.rose++;
        logBattleAction('获得了玫瑰花！');
    }

     if (stage >= 200 && Math.random() < 0.0001) {
        player.items.rebornDan++;
        logBattleAction('获得了洗髓丹！');
    }

     if (stage >= 1 && Math.random() < 0.0003) {
        player.items.companionKey++;
        logBattleAction('获得了伴侣钥匙！');
    }
    // 其他道具掉落逻辑可以在这里添加
}

// 更新道具显示
function updateItemDisplay() {
    const container = document.getElementById('itemContainer');
    container.innerHTML = Object.entries(player.items)
        .map(([key, value]) => {
            const item = itemEffects[key];
            return `<div>${item.name}: ${value} - ${item.description}</div>`;
        })
        .join('');
}
        function dropDungeonEquipment(stage) {
            const dropRates = getDropRatesByStage(stage);
            const drops = [];
            for (let i = 0; i < 3; i++) {
                const rand = Math.random();
                let cumulativeProb = 0;
                for (const [rarity, prob] of Object.entries(dropRates)) {
                    cumulativeProb += prob;
                    if (rand < cumulativeProb) {
                        drops.push(rarity);
                        break;
                    }
                }
            }

            drops.forEach(rarity => {
                addDungeonEquipment(rarity);
                logBattleAction(`获得了副本装备：${dungeonEquipmentTypes[rarity].name}`);
          // 新增：检查称号解锁
            checkTitleUnlocks();
            });
        }

        function dropSoulRing(stage) {
    const soulRingDrops = [
        { minStage: 1, type: 'year1', chance: 0.02 },
        { minStage: 15, type: 'year10', chance: 0.02 },
        { minStage: 25, type: 'year100', chance: 0.02 },
        { minStage: 35, type: 'year1000', chance: 0.02 },
        { minStage: 45, type: 'year10000', chance: 0.01 },
        { minStage: 55, type: 'year10000', chance: 0.01 },
        { minStage: 65, type: 'year100000', chance: 0.01 },
        { minStage: 75, type: 'year1000000', chance: 0.01 },
        { minStage: 90, type: 'year10000000', chance: 0.01 },
        { minStage: 120, type: 'year100000000', chance: 0.01 },
        { minStage: 140, type: 'year2', chance: 0.01 },
        { minStage: 160, type: 'year3', chance: 0.01 },
        { minStage: 180, type: 'year4', chance: 0.01 },
        { minStage: 200, type: 'year5', chance: 0.01 },
        { minStage: 220, type: 'year6', chance: 0.01 },
        { minStage: 240, type: 'year7', chance: 0.01 },
        { minStage: 260, type: 'year8', chance: 0.01 },
        { minStage: 280, type: 'year9', chance: 0.01 },
        { minStage: 300, type: 'year11', chance: 0.01 },
        { minStage: 320, type: 'year12', chance: 0.01 },
        { minStage: 340, type: 'year13', chance: 0.01 },
        { minStage: 360, type: 'year14', chance: 0.01 },
        { minStage: 380, type: 'year15', chance: 0.01 },
        { minStage: 400, type: 'year16', chance: 0.01 },
        { minStage: 420, type: 'year17', chance: 0.01 },
        { minStage: 440, type: 'year18', chance: 0.01 },
        { minStage: 460, type: 'year19', chance: 0.01 },
        { minStage: 480, type: 'year20', chance: 0.01 },
        { minStage: 500, type: 'year21', chance: 0.01 },
        { minStage: 520, type: 'year22', chance: 0.01 },
        { minStage: 540, type: 'year23', chance: 0.01 },
        { minStage: 560, type: 'year24', chance: 0.01 },
        { minStage: 580, type: 'year25', chance: 0.01 },
        { minStage: 600, type: 'year26', chance: 0.01 },
        { minStage: 620, type: 'year27', chance: 0.01 },
        { minStage: 640, type: 'year28', chance: 0.01 },
        { minStage: 660, type: 'year29', chance: 0.01 },
        { minStage: 680, type: 'year30', chance: 0.01 },
        { minStage: 700, type: 'year31', chance: 0.01 },
        { minStage: 720, type: 'year32', chance: 0.01 },
        { minStage: 740, type: 'year33', chance: 0.01 },
        { minStage: 780, type: 'year34', chance: 0.01 },
        { minStage: 800, type: 'year35', chance: 0.01 },
        { minStage: 820, type: 'year36', chance: 0.01 },
        { minStage: 850, type: 'year37', chance: 0.01 }
    ];

    soulRingDrops.forEach(drop => {
        if (stage >= drop.minStage && Math.random() < drop.chance) {
            addSoulRing(drop.type);
            logBattleAction(`获得了${soulRingTypes[drop.type].name}`);
          // 新增：检查称号解锁
                checkTitleUnlocks();
            // 检查成就
            const ring = player.soulRings.find(r => r.type === drop.type);
            if (ring) {
                checkSoulRingAchievements(drop.type, ring.level);
            }
        }
    });
}

       function getDropRatesByStage(stage) {
            if (stage <= 5) {
                return { common: 0.8, rare: 0.2 };
            } else if (stage <= 15) {
                return { common: 0.8, rare: 0.14, epic: 0.05, legendary: 0.01  };
            } else if (stage <= 25) {
                return { common: 0.8, rare: 0.12, epic: 0.04, legendary: 0.03, ancient: 0.01 };
            } else if (stage <= 40) {
                return { common: 0.8, epic: 0.11, legendary: 0.03, ancient: 0.03, divine: 0.02, arcane: 0.01 };
            } else if (stage <= 65) {
                return { common: 0.7, legendary: 0.15, ancient: 0.06, divine: 0.04, arcane: 0.02, celestial: 0.02, infernal: 0.01 };
            } else if (stage <= 90) {
                return { common: 0.7, ancient: 0.14, divine: 0.06, arcane: 0.04, celestial: 0.02, infernal: 0.02, astral: 0.01, primeval: 0.01 };
            } else if (stage <= 120) {
                return { common: 0.7, divine: 0.13, arcane: 0.06, celestial: 0.04, infernal: 0.02, astral: 0.02, primeval: 0.01, transcendental: 0.01, quantum: 0.01 };
            } else if (stage <= 150) {
                return { common: 0.7, celestial: 0.13, infernal: 0.06, astral: 0.04, primeval: 0.02, transcendental: 0.02, quantum: 0.01, ultimate: 0.01, ultimate1: 0.01 };
            } else if (stage <= 175) {
                return { common: 0.7, infernal: 0.13, astral: 0.06, primeval: 0.04, transcendental: 0.02, quantum: 0.02, ultimate: 0.01, ultimate2: 0.01, ultimate3: 0.01 };
            } else if (stage <= 200) {
                return { common: 0.7, primeval: 0.13, transcendental: 0.06, quantum: 0.04, ultimate: 0.02, ultimate1: 0.02, ultimate2: 0.01, ultimate3: 0.01, ultimate4: 0.01 };
            } else if (stage <= 225) {
                return { common: 0.7, quantum: 0.13, ultimate: 0.06, ultimate1: 0.04, ultimate2: 0.02, ultimate3: 0.02, ultimate4: 0.01, ultimate5: 0.01, ultimate6: 0.01 };
            } else if (stage <= 250) {
                return { common: 0.7, ultimate1: 0.13, ultimate2: 0.06, ultimate3: 0.04, ultimate4: 0.02, ultimate5: 0.02, ultimate6: 0.01, ultimate7: 0.01, ultimate8: 0.01 };
            } else if (stage <= 275) {
                return { common: 0.7, ultimate3: 0.13, ultimate4: 0.06, ultimate5: 0.04, ultimate6: 0.02, ultimate7: 0.02, ultimate8: 0.01, ultimate9: 0.01, ultimate10: 0.01 };
            } else if (stage <= 300) {
                return { common: 0.7, ultimate5: 0.13, ultimate6: 0.06, ultimate7: 0.04, ultimate8: 0.02, ultimate9: 0.02, ultimate10: 0.01, ultimate11: 0.01, ultimate12: 0.01 };
            } else if (stage <= 325) {
                return { common: 0.7, ultimate7: 0.13, ultimate8: 0.06, ultimate9: 0.04, ultimate10: 0.02, ultimate11: 0.02, ultimate12: 0.01, ultimate13: 0.01, ultimate14: 0.01 };
            } else if (stage <= 350) {
                return { common: 0.7, ultimate9: 0.13, ultimate10: 0.06, ultimate11: 0.04, ultimate12: 0.02, ultimate13: 0.02, ultimate14: 0.01, ultimate15: 0.01, ultimate16: 0.01 };
            } else if (stage <= 375) {
                return { common: 0.7, ultimate11: 0.13, ultimate12: 0.06, ultimate13: 0.04, ultimate14: 0.02, ultimate15: 0.02, ultimate16: 0.01, ultimate17: 0.01, ultimate18: 0.011 };
            } else if (stage <= 400) {
                return { common: 0.7, ultimate13: 0.13, ultimate14: 0.06, ultimate15: 0.04, ultimate16: 0.02, ultimate17: 0.02, ultimate18: 0.01, ultimate19: 0.01, ultimate20: 0.01 };
            } else if (stage <= 425) {
                return { common: 0.7, ultimate15: 0.13, ultimate16: 0.06, ultimate17: 0.04, ultimate18: 0.02, ultimate19: 0.02, ultimate20: 0.01, ultimate21: 0.01, ultimate22: 0.01 };
            } else if (stage <= 450) {
                return { common: 0.7, ultimate17: 0.13, ultimate18: 0.06, ultimate19: 0.04, ultimate20: 0.02, ultimate21: 0.02, ultimate22: 0.01, ultimate23: 0.01, ultimate24: 0.01 };
            } else if (stage <= 475) {
                return { common: 0.7, ultimate19: 0.13, ultimate20: 0.06, ultimate21: 0.04, ultimate22: 0.02, ultimate23: 0.02, ultimate24: 0.01, ultimate25: 0.01, ultimate26: 0.01 };
            } else if (stage <= 500) {
                return { common: 0.7, ultimate21: 0.13, ultimate22: 0.06, ultimate23: 0.04, ultimate24: 0.02, ultimate25: 0.02, ultimate26: 0.01, ultimate27: 0.01, ultimate28: 0.01 };
            } else if (stage <= 530) {
                return { common: 0.7, ultimate23: 0.13, ultimate24: 0.06, ultimate25: 0.04, ultimate26: 0.02, ultimate27: 0.02, ultimate28: 0.01, ultimate29: 0.01, ultimate30: 0.01 };
            } else if  (stage <= 560) {
                return { common: 0.7, ultimate25: 0.13, ultimate26: 0.06, ultimate27: 0.04, ultimate28: 0.02, ultimate29: 0.02, ultimate30: 0.01, ultimate31: 0.01, ultimate32: 0.01 };
            } else if (stage <= 590) {
                return { common: 0.7, ultimate27: 0.13, ultimate28: 0.06, ultimate29: 0.04, ultimate30: 0.02, ultimate31: 0.02, ultimate32: 0.01, ultimate33: 0.01, ultimate34: 0.01 };
            } else if (stage <= 620) {
                return { common: 0.7, ultimate29: 0.13, ultimate30: 0.06, ultimate31: 0.04, ultimate32: 0.02, ultimate33: 0.02, ultimate34: 0.01, ultimate35: 0.01, ultimate36: 0.01 };
            } else if (stage <= 650) {
                return { common: 0.7, ultimate31: 0.13, ultimate32: 0.06, ultimate33: 0.04, ultimate34: 0.02, ultimate35: 0.02, ultimate36: 0.01, ultimate37: 0.01, ultimate38: 0.01 };
            } else if (stage <= 680) {
                return { common: 0.7, ultimate33: 0.13, ultimate34: 0.06, ultimate35: 0.04, ultimate36: 0.02, ultimate37: 0.02, ultimate38: 0.01, ultimate39: 0.01, ultimate40: 0.01 };
            } else if (stage <= 720) {
                return { common: 0.7, ultimate35: 0.13, ultimate36: 0.06, ultimate37: 0.04, ultimate38: 0.02, ultimate39: 0.02, ultimate40: 0.01, ultimate41: 0.01, ultimate42: 0.01 };
            } else if (stage <= 750) {
                return { common: 0.7, ultimate37: 0.13, ultimate38: 0.06, ultimate39: 0.04, ultimate40: 0.02, ultimate41: 0.02, ultimate42: 0.01, ultimate43: 0.01, ultimate44: 0.01 };
            } else if (stage <= 780) {
                return { common: 0.7, ultimate39: 0.13, ultimate40: 0.06, ultimate41: 0.04, ultimate42: 0.02, ultimate43: 0.02, ultimate44: 0.01, ultimate45: 0.01, ultimate46: 0.01 };
            } else if (stage <= 800) {
                return { common: 0.7, ultimate41: 0.13, ultimate42: 0.06, ultimate43: 0.04, ultimate44: 0.02, ultimate45: 0.02, ultimate46: 0.01, ultimate47: 0.01, ultimate48: 0.01 };
            } else {
                return { common: 0.7, ultimate43: 0.13, ultimate44: 0.06, ultimate45: 0.04, ultimate46: 0.02, ultimate47: 0.02, ultimate48: 0.01, ultimate49: 0.01, ultimate50: 0.01 };
            }
        }


        function fleeFromBattle() {
            const cost = player.battle.maxStage * 10;
            if (player.reincarnationCoin >= cost) {
                player.reincarnationCoin -= cost;
                player.battle.currentStage = 0;
                generateMonster();
               updateOfficialSystemDisplay();
                updateMonsterUI();
                logBattleAction(`你重置了关卡，消耗了${cost}转生币`);
            } else {
                logBattleAction('转生币不足，无法重置关卡！');
            }
        }
      
        function sweepStages() {
    const currentStage = player.battle.currentStage;
    const maxStage = player.battle.maxStage;
    const targetStage = Math.max(1, maxStage - 6); // 扫荡到最大关卡-5
    
    if (currentStage >= targetStage) {
        logBattleAction("没有可扫荡的关卡！");
        return;
    }
    
    // 计算消耗的转生币
    const cost = (targetStage - currentStage) * 2;
    
    if (player.reincarnationCoin < cost) {
        logBattleAction(`扫荡需要 ${cost} 转生币，当前不足！`);
        return;
    }
    
    // 确认对话框
    showCustomConfirm(`确定要扫荡从第${currentStage + 1}关到第${targetStage}关吗？消耗 ${cost} 转生币`, (confirmed) => {
        if (confirmed) {
            player.reincarnationCoin -= cost;
            
            // 记录扫荡前的状态
            const originalStage = player.battle.currentStage;
            let totalDrops = 0;
            let dungeonEquipmentDrops = 0;
            let soulRingDrops = 0;
            let itemDrops = 0;
            
            // 模拟扫荡过程
            for (let stage = currentStage; stage < targetStage; stage++) {
                player.battle.currentStage = stage;
                
                // 固定掉落3个副本装备
                for (let i = 0; i < 3; i++) {
                    const dungeonDrops = getDropRatesByStage(stage);
                    const rand = Math.random();
                    let cumulativeProb = 0;
                    
                    for (const [rarity, prob] of Object.entries(dungeonDrops)) {
                        cumulativeProb += prob;
                        if (rand < cumulativeProb) {
                            addDungeonEquipment(rarity);
                            dungeonEquipmentDrops++;
                            break;
                        }
                    }
                }
                
                // 魂环掉落（保持原逻辑）
                const soulRingResult = simulateSoulRingDrop(stage);
                if (soulRingResult) {
                    soulRingDrops++;
                }
                
                // 道具掉落（保持原逻辑）
                const itemResult = simulateItemDrop(stage);
                if (itemResult) {
                    itemDrops++;
                }
                
                // 更新显示（每10关更新一次）
                if (stage % 10 === 0) {
                    updateMonsterUI();
                }
            }
            
            // 扫荡完成后停留在目标关卡
            player.battle.currentStage = targetStage;
            generateMonster();
            
            logBattleAction(`扫荡完成！从第${originalStage + 1}关到第${targetStage}关`);
            logBattleAction(`获得副本装备: ${dungeonEquipmentDrops}件`);
            logBattleAction(`获得魂环: ${soulRingDrops}件`);
            logBattleAction(`获得道具: ${itemDrops}件`);
            updateMonsterUI();
           updateOfficialSystemDisplay();
        }
    });
}

// 单独提取魂环掉落逻辑
function simulateSoulRingDrop(stage) {
    const soulRingDrops = [
        { minStage: 1, type: 'year1', chance: 0.02 },
        { minStage: 15, type: 'year10', chance: 0.02 },
        { minStage: 25, type: 'year100', chance: 0.02 },
        { minStage: 35, type: 'year1000', chance: 0.02 },
        { minStage: 45, type: 'year10000', chance: 0.01 },
        { minStage: 55, type: 'year10000', chance: 0.01 },
        { minStage: 65, type: 'year100000', chance: 0.01 },
        { minStage: 75, type: 'year1000000', chance: 0.01 },
        { minStage: 90, type: 'year10000000', chance: 0.01 },
        { minStage: 120, type: 'year100000000', chance: 0.01 },
        { minStage: 140, type: 'year2', chance: 0.01 },
        { minStage: 160, type: 'year3', chance: 0.01 },
        { minStage: 180, type: 'year4', chance: 0.01 },
        { minStage: 200, type: 'year5', chance: 0.01 },
        { minStage: 220, type: 'year6', chance: 0.01 },
        { minStage: 240, type: 'year7', chance: 0.01 },
        { minStage: 260, type: 'year8', chance: 0.01 },
        { minStage: 280, type: 'year9', chance: 0.01 },
        { minStage: 300, type: 'year11', chance: 0.01 },
        { minStage: 320, type: 'year12', chance: 0.01 },
        { minStage: 340, type: 'year13', chance: 0.01 },
        { minStage: 360, type: 'year14', chance: 0.01 },
        { minStage: 380, type: 'year15', chance: 0.01 },
        { minStage: 400, type: 'year16', chance: 0.01 },
        { minStage: 420, type: 'year17', chance: 0.01 },
        { minStage: 440, type: 'year18', chance: 0.01 },
        { minStage: 460, type: 'year19', chance: 0.01 },
        { minStage: 480, type: 'year20', chance: 0.01 },
        { minStage: 500, type: 'year21', chance: 0.01 },
        { minStage: 520, type: 'year22', chance: 0.01 },
        { minStage: 540, type: 'year23', chance: 0.01 },
        { minStage: 560, type: 'year24', chance: 0.01 },
        { minStage: 580, type: 'year25', chance: 0.01 },
        { minStage: 600, type: 'year26', chance: 0.01 },
        { minStage: 620, type: 'year27', chance: 0.01 },
        { minStage: 640, type: 'year28', chance: 0.01 },
        { minStage: 660, type: 'year29', chance: 0.01 },
        { minStage: 680, type: 'year30', chance: 0.01 },
        { minStage: 700, type: 'year31', chance: 0.01 },
        { minStage: 720, type: 'year32', chance: 0.01 },
        { minStage: 740, type: 'year33', chance: 0.01 },
        { minStage: 780, type: 'year34', chance: 0.01 },
        { minStage: 800, type: 'year35', chance: 0.01 },
        { minStage: 820, type: 'year36', chance: 0.01 },
        { minStage: 850, type: 'year37', chance: 0.01 }
    ];
    
    for (const drop of soulRingDrops) {
        if (stage >= drop.minStage && Math.random() < drop.chance) {
            addSoulRing(drop.type);
            return true;
        }
    }
    return false;
}

// 单独提取道具掉落逻辑
function simulateItemDrop(stage) {
    let hasDropped = false;
    
    // 洗炼石掉落（30关以上0.05%概率）
    if (stage >= 30 && Math.random() < 0.0001) {
        player.items.refineStone++;
        hasDropped = true;
    }
    
    // VIP能力值掉落（全关卡0.1%概率）
    if (stage >= 1 && Math.random() < 0.0002) {
        player.items.vipPower++;
        hasDropped = true;
    }
    
    // 初级宝石掉落（50关以上0.04%概率）
    if (stage >= 50 && Math.random() < 0.0003) {
        player.items.primaryGem++;
        hasDropped = true;
    }
    
    // 高级宝石掉落（100关以上0.03%概率）
    if (stage >= 100 && Math.random() < 0.0002) {
        player.items.advancedGem++;
        hasDropped = true;
    }
    
    // 极品宝石掉落（150关以上0.01%概率）
    if (stage >= 150 && Math.random() < 0.0001) {
        player.items.superiorGem++;
        hasDropped = true;
    }
    
    // 玫瑰花掉落（150关以上0.05%概率）
    if (stage >= 1 && Math.random() < 0.001) {
        player.items.rose++;
        hasDropped = true;
    }
    // 洗髓丹匙掉落（150关以上0.001%概率）
    if (stage >= 200 && Math.random() < 0.0001) {
        player.items.rebornDan++;
        hasDropped = true;
    }
    // 洗髓丹匙掉落（150关以上0.001%概率）
    if (stage >= 100 && Math.random() < 0.0001) {
        player.items.baitCount++;
        hasDropped = true;
    }
    // 伴侣钥匙掉落（150关以上0.001%概率）
    if (stage >= 1 && Math.random() < 0.0001) {
        player.items.companionKey++;
        hasDropped = true;
    }
    
    return hasDropped;
}
        function jumpToStage() {
            const stage = parseInt(document.getElementById('jumpStage').value) || 0;
            if (stage > player.battle.currentStage && stage <= player.battle.maxStage && player.reincarnationCoin >= stage) {
                player.reincarnationCoin -= stage;
                player.battle.currentStage = stage;
                generateMonster();
                updateMonsterUI();
                logBattleAction(`你跳到了第${stage + 1}关`);
            } else {
                logBattleAction('无法跳到该关卡！');
            }
        }
     function formatNumber(value) {
    if (value >= 1e8) { // 当数值大于等于 100,000,000 时使用科学计数法
        return value.toExponential(3); // 保留两位小数
    } else {
        return value.toLocaleString(); // 否则使用常规的数值显示
    }
}
        function logBattleAction(message) {
    const formattedMessage = message.replace(/\d+(\.\d+)?/g, num => 
        formatSci(parseFloat(num))
    );
    
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `<div class="battle-log-entry">[${timestamp}] ${formattedMessage}</div>`;
    
    const logContainer = document.getElementById("battleLogContent");
    logContainer.insertAdjacentHTML("afterbegin", logEntry);
    
    // 保持最多20条日志
    if (logContainer.children.length > 20) {
        logContainer.removeChild(logContainer.lastChild);
    }
}
 let autoSweepInterval = null;
let isAutoSweeping = false;

// 添加自动扫荡控制函数
function toggleAutoSweep() {
    player.battle.autoSweepEnabled = !player.battle.autoSweepEnabled;
    
    // 更新UI显示
    document.getElementById('autoSweepStatus').textContent = 
        player.battle.autoSweepEnabled ? '开' : '关';
    
    // 如果开启自动扫荡，启动定时器
    if (player.battle.autoSweepEnabled) {
        startAutoSweep();
    } else {
        stopAutoSweep();
    }
    
    logAction(`自动扫荡已${player.battle.autoSweepEnabled ? '开启' : '关闭'}`, 'info');
    saveGame();
 
}

// 启动自动扫荡
function startAutoSweep() {
    // 清除现有定时器（如果有）
    stopAutoSweep();
    // 每4秒执行一次自动扫荡
    player.battle.autoSweepInterval = setInterval(autoSweepProcess, 4000);
}

// 停止自动扫荡
function stopAutoSweep() {
    if (player.battle.autoSweepInterval) {
        clearInterval(player.battle.autoSweepInterval);
        player.battle.autoSweepInterval = null;
    }
}

// 自动扫荡处理流程
function autoSweepProcess() {
    // 检查是否需要重置关卡
    if (player.battle.currentStage >= Math.max(1, player.battle.maxStage - 1)) {
        // 重置关卡到0
        player.battle.currentStage = 0;
        logBattleAction("已自动重置关卡到初始位置");
    }
    
    // 执行扫荡
    const currentStage = player.battle.currentStage;
    const maxStage = player.battle.maxStage;
    const targetStage = Math.max(1, maxStage - 1);
    
    if (currentStage >= targetStage) {
        logBattleAction("自动扫荡：没有可扫荡的关卡，将重置关卡");
        return;
    }
    
    const cost = (targetStage - currentStage) * 12;
    if (player.reincarnationCoin < cost) {
        logBattleAction(`自动扫荡：转生币不足（需要${cost}），已停止`);
        toggleAutoSweep(); // 停止自动扫荡
        return;
    }
    
    // 自动执行扫荡（无需确认）
    player.reincarnationCoin -= cost;
    
    const originalStage = player.battle.currentStage;
    let totalDrops = 0;
    let dungeonEquipmentDrops = 0;
    let soulRingDrops = 0;
    let itemDrops = 0;
    
     for (let stage = currentStage; stage < targetStage; stage++) {
        player.battle.currentStage = stage;
        
        // 固定掉落3个副本装备 - 使用静默方式添加
        for (let i = 0; i < 3; i++) {
            const dungeonDrops = getDropRatesByStage(stage);
            const rand = Math.random();
            let cumulativeProb = 0;
            
            for (const [rarity, prob] of Object.entries(dungeonDrops)) {
                cumulativeProb += prob;
                if (rand < cumulativeProb) {
                    addDungeonEquipmentSilent(rarity); // 使用静默版本
                    dungeonEquipmentDrops++;
                    break;
                }
            }
        }
        
        // 魂环掉落 - 使用静默方式
        const soulRingResult = simulateSoulRingDropSilent(stage);
        if (soulRingResult) {
            soulRingDrops++;
        }
        
      // 道具掉落 - 保持原样（如果需要也可以静默）
        const itemResult = simulateItemDrop(stage);
        if (itemResult) {
            itemDrops++;
        }
    }

    // 扫荡完成后停留在目标关卡
    player.battle.currentStage = targetStage;
    generateMonster();
    
    logBattleAction(`自动扫荡完成！从第${originalStage + 1}关到第${targetStage}关`);
    logBattleAction(`获得副本装备: ${dungeonEquipmentDrops}件，魂环: ${soulRingDrops}个，道具: ${itemDrops}个`);
      updateOfficialSystemDisplay();
        updateMonsterUI(); 
}
// 静默添加副本装备（不显示提示）
function addDungeonEquipmentSilent(rarity) {
    const config = dungeonEquipmentTypes[rarity];
    const growthRate = Math.random() * (config.growthRange[1] - config.growthRange[0]) + config.growthRange[0];

    const existingEq = player.dungeonEquipment.find(eq => eq.rarity === rarity);
    if (existingEq) {
        existingEq.quantity = (existingEq.quantity || 1) + 1;
        if (existingEq.quantity >= 3) {
            existingEq.level++;
            existingEq.quantity = 0;
        }
    } else {
        const newEq = {
            name: config.name,
            rarity: rarity,
            level: 1,
            growthRate: growthRate,
            quantity: 1
        };
        player.dungeonEquipment.push(newEq);
    }
}

// 静默添加魂环（不显示提示）
function simulateSoulRingDropSilent(stage) {
    const soulRingDrops = [
        { minStage: 1, type: 'year1', chance: 0.02 },
        { minStage: 15, type: 'year10', chance: 0.02 },
        { minStage: 25, type: 'year100', chance: 0.02 },
        { minStage: 35, type: 'year1000', chance: 0.02 },
        { minStage: 45, type: 'year10000', chance: 0.01 },
        { minStage: 55, type: 'year10000', chance: 0.01 },
        { minStage: 65, type: 'year100000', chance: 0.01 },
        { minStage: 75, type: 'year1000000', chance: 0.01 },
        { minStage: 90, type: 'year10000000', chance: 0.01 },
        { minStage: 120, type: 'year100000000', chance: 0.01 },
        { minStage: 140, type: 'year2', chance: 0.01 },
        { minStage: 160, type: 'year3', chance: 0.01 },
        { minStage: 180, type: 'year4', chance: 0.01 },
        { minStage: 200, type: 'year5', chance: 0.01 },
        { minStage: 220, type: 'year6', chance: 0.01 },
        { minStage: 240, type: 'year7', chance: 0.01 },
        { minStage: 260, type: 'year8', chance: 0.01 },
        { minStage: 280, type: 'year9', chance: 0.01 },
        { minStage: 300, type: 'year11', chance: 0.01 },
        { minStage: 320, type: 'year12', chance: 0.01 },
        { minStage: 340, type: 'year13', chance: 0.01 },
        { minStage: 360, type: 'year14', chance: 0.01 },
        { minStage: 380, type: 'year15', chance: 0.01 },
        { minStage: 400, type: 'year16', chance: 0.01 },
        { minStage: 420, type: 'year17', chance: 0.01 },
        { minStage: 440, type: 'year18', chance: 0.01 },
        { minStage: 460, type: 'year19', chance: 0.01 },
        { minStage: 480, type: 'year20', chance: 0.01 },
        { minStage: 500, type: 'year21', chance: 0.01 },
        { minStage: 520, type: 'year22', chance: 0.01 },
        { minStage: 540, type: 'year23', chance: 0.01 },
        { minStage: 560, type: 'year24', chance: 0.01 },
        { minStage: 580, type: 'year25', chance: 0.01 },
        { minStage: 600, type: 'year26', chance: 0.01 },
        { minStage: 620, type: 'year27', chance: 0.01 },
        { minStage: 640, type: 'year28', chance: 0.01 },
        { minStage: 660, type: 'year29', chance: 0.01 },
        { minStage: 680, type: 'year30', chance: 0.01 },
        { minStage: 700, type: 'year31', chance: 0.01 },
        { minStage: 720, type: 'year32', chance: 0.01 },
        { minStage: 740, type: 'year33', chance: 0.01 },
        { minStage: 780, type: 'year34', chance: 0.01 },
        { minStage: 800, type: 'year35', chance: 0.01 },
        { minStage: 820, type: 'year36', chance: 0.01 },
        { minStage: 850, type: 'year37', chance: 0.01 }
    ];
    
    for (const drop of soulRingDrops) {
        if (stage >= drop.minStage && Math.random() < drop.chance) {
            addSoulRingSilent(drop.type); // 使用静默版本
            return true;
        }
    }
    return false;
}

function addSoulRingSilent(type) {
    const existing = player.soulRings.find(r => r.type === type);
    if(existing) {
        existing.level++;
    } else {
        player.soulRings.push({
            type: type,
            level: 1,
            multiplier: soulRingTypes[type].baseMult
        });
    }
}
  function addAttributePoint(attribute, amount) {
    // 计算实际要加的点数
    let pointsToAdd = 0;
    if (amount === 'all') {
        pointsToAdd = player.attributes.remainingPoints; // 全部剩余属性点
    } else {
        pointsToAdd = Math.min(amount, player.attributes.remainingPoints); // 不能超过剩余属性点
    }

    if (pointsToAdd <= 0) {
        logAction("剩余属性点不足！", "error");
        return;
    }

    // 根据属性类型加点
    switch (attribute) {
        case 'health':
            player.attributes.health += pointsToAdd;
            break;
        case 'attack':
            player.attributes.attack += pointsToAdd;
            break;
        case 'critRate':
            player.attributes.critRate += pointsToAdd;
            break;
        case 'critDamage':
            player.attributes.critDamage += pointsToAdd;
            break;
        case 'multiAttack':
            player.attributes.multiAttack += pointsToAdd;
            break;
        case 'block':
            player.attributes.block += pointsToAdd;
            break;
        default:
            logAction("无效的属性类型！", "error");
            return;
    }

    // 扣除剩余属性点
    player.attributes.remainingPoints -= pointsToAdd;

    // 更新显示
    updatePlayerAttributesDisplay();
    logAction(`成功为${attribute}属性增加${pointsToAdd}点`, 'success');
}

function resetAttributes() {
    if (player.reincarnationCoin >= 1) {
        player.reincarnationCoin -= 1;
        // 重置所有属性点
        player.attributes.health = 0;
        player.attributes.attack = 0;
        player.attributes.critRate = 0;
        player.attributes.critDamage = 0;
        player.attributes.multiAttack = 0;
        player.attributes.block = 0;
        // 重置剩余属性点 = 总属性点
        player.attributes.remainingPoints = player.attributes.totalPoints;
        updatePlayerAttributesDisplay(); // 更新显示
        logAction("属性点已重置", "success");
    } else {
        logAction("转生币不足！", "error");
    }
}

 function handleBattleResult(isVictory) {
    // 保存当前的功法加成
    const techniqueBonuses = {
        health: player.attributes.healthBonus,
        attack: player.attributes.attackBonus,
        critRate: player.attributes.critRateBonus,
        critDamage: player.attributes.critDamageBonus,
        multiAttack: player.attributes.multiAttackBonus
    };
    
    if (isVictory) {
        // 胜利逻辑...
        player.battle.currentStage++;
        player.battle.maxStage = Math.max(player.battle.maxStage, player.battle.currentStage);
    } else {
        // 失败逻辑...
        player.battle.playerHealth = player.reincarnationCount;
    }
    
    // 恢复功法加成
    player.attributes.healthBonus = techniqueBonuses.health;
    player.attributes.attackBonus = techniqueBonuses.attack;
    player.attributes.critRateBonus = techniqueBonuses.critRate;
    player.attributes.critDamageBonus = techniqueBonuses.critDamage;
    player.attributes.multiAttackBonus = techniqueBonuses.multiAttack;
    
    // 更新玩家战斗属性
    updatePlayerBattleStats();
    
}
function updatePlayerAttributesDisplay() {
    // 计算总属性点
    const totalAttributePoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
    player.attributes.totalPoints = totalAttributePoints;

    // 更新总属性点和剩余属性点
    document.getElementById("totalAttributePoints").textContent = player.attributes.totalPoints;
    document.getElementById("remainingAttributePoints").textContent = player.attributes.remainingPoints;

    // 更新各属性加成显示和已投入点数
    document.getElementById("healthBonus").textContent = 
        (player.attributes.health * 1 + player.attributes.healthBonus * 100).toFixed(2) + "%";
    document.getElementById("healthPoints").textContent = player.attributes.health;
    
    document.getElementById("attackBonus").textContent = 
        (player.attributes.attack * 1 + player.attributes.attackBonus * 100).toFixed(2) + "%";
    document.getElementById("attackPoints").textContent = player.attributes.attack;
    
    document.getElementById("critRateBonus").textContent = 
        (player.attributes.critRate * 0.05 + player.attributes.critRateBonus * 100).toFixed(3) + "%";
    document.getElementById("critRatePoints").textContent = player.attributes.critRate;
    
    document.getElementById("critDamageBonus").textContent = 
        (player.attributes.critDamage * 0.50 + player.attributes.critDamageBonus * 100).toFixed(2) + "%";
    document.getElementById("critDamagePoints").textContent = player.attributes.critDamage;
    
    document.getElementById("multiAttackBonus").textContent = 
        Math.floor(player.attributes.multiAttack / 300) + player.attributes.multiAttackBonus;
    document.getElementById("multiAttackPoints").textContent = player.attributes.multiAttack;
}
function updateTechniqueBonuses() {
    // 重置所有加成
    player.attributes.healthBonus = 0;
    player.attributes.attackBonus = 0;
    player.attributes.critRateBonus = 0;
    player.attributes.critDamageBonus = 0;
    player.attributes.multiAttackBonus = 0;
    
    // 计算所有功法提供的加成
    Object.entries(player.techniques).forEach(([type, level]) => {
        const tech = techniqueConfig[type];
        if(tech) {
            switch(tech.type) {
                case 'health':
                    player.attributes.healthBonus += level * tech.effect;
                    break;
                case 'attack':
                    player.attributes.attackBonus += level * tech.effect;
                    break;
                case 'critRate':
                    player.attributes.critRateBonus += level * tech.effect;
                    break;
                case 'critDamage':
                    player.attributes.critDamageBonus += level * tech.effect;
                    break;
                case 'multiAttack':
                    player.attributes.multiAttackBonus += Math.floor(level * tech.effect);
                    break;
            }
        }
    });
    
    // 更新玩家战斗属性
    updatePlayerBattleStats();
     updateOfficialSystemDisplay();
    updatePlayerAttributesDisplay();
}
function updatePlayerBattleStats() {
    // 1. 获取各类加成
    const classBonuses = calculateClassBonuses();
    const titleBonuses = calculateTotalBonuses(); // 重命名变量避免混淆
    const officialBonus = getOfficialBonus();
    const companionBonuses = getCompanionBonuses(); // 获取伴侣天赋加成
   const artifactBonuses = calculateArtifactBonuses();
    // 保存职业加成到player对象
    player.classBonuses = classBonuses;
    const bonuses = calculateGemBonuses(); 
    const techBonuses = calculateTechniqueBonuses();

    // 2. 计算玩家生命（应用伴侣生命加成）
    player.battle.playerHealth = Math.floor(
        player.reincarnationCount * 
        (1 + player.attributes.healthBonus + player.attributes.health * 0.01) *
        classBonuses.healthMultiplier * titleBonuses.healthMultiplier *
        companionBonuses.healthMultiplier * (1 + artifactBonuses.health) * (1 + bonuses.health / 100) *  (1 + techBonuses.health)// 应用伴侣生命加成
    );

    // 3. 计算玩家攻击（应用伴侣攻击加成）
    player.battle.playerAttack = Math.floor(
        getTotalClickValue() * 
        (1 + player.attributes.attackBonus + player.attributes.attack * 0.01) *
        classBonuses.attackMultiplier * titleBonuses.attackMultiplier *
        officialBonus * companionBonuses.attackMultiplier * (1 + artifactBonuses.attack) * (1 + bonuses.attack / 100) *  (1 + techBonuses.attack) // 应用伴侣攻击加成
    );

    // 4. 计算暴击率（应用伴侣暴击率加成）
    const baseCritRate = 0.1 + player.attributes.critRateBonus + player.attributes.critRate * 0.00025 +
        classBonuses.critChance;
    player.battle.playerCritRate = Math.min(
        0.9,
        baseCritRate * companionBonuses.critRateMultiplier +  (1 + techBonuses.critRate) // 应用伴侣暴击率乘数
    );

    // 5. 计算爆伤（应用伴侣爆伤加成和全属性加成）
    player.battle.playerCritDamage = (1.5 + 
        player.attributes.critDamageBonus + 
        player.attributes.critDamage * 0.0025) *
        classBonuses.critMultiplier * titleBonuses.critMultiplier *
        companionBonuses.critDamageMultiplier * (1 + artifactBonuses.critDamage) * (1 + bonuses.critDamage / 100) *  (1 + techBonuses.critDamage) ; // 应用伴侣爆伤加成

    // 6. 计算连击次数（应用伴侣连击加成）
    player.battle.playerMultiAttack = Math.max(1,
        Math.floor(player.attributes.multiAttack / 300) + 
        player.attributes.multiAttackBonus +
        companionBonuses.combo // 应用伴侣连击加成
    );

    // 更新UI显示
    updateMonsterUI();
}
function checkTimeValidity() {
    const now = Date.now();
    const storedTime = localStorage.getItem('lastValidTime');
    
    if (!storedTime) {
        localStorage.setItem('lastValidTime', now);
        return true;
    }
    
    const timeDiff = now - storedTime;
    if (timeDiff < 0 || timeDiff > 30 * 60 * 1000) { // 允许30分钟内偏差
        return false;
    }
    
    localStorage.setItem('lastValidTime', now);
    return true;
}

// 计算离线经验
// 新增：计算离线奥秘经验
function calculateOfflineMysteryExp() {
    if (!player.mystery || !player.mystery.lastUpdateTime) return;
    
    const now = Date.now();
    const timeDiff = now - player.mystery.lastUpdateTime;
   // 时间回退检测
    if (timeDiff < 0) {
        console.warn("检测到时间回退，重置奥秘经验");
        player.mystery.exp = 0;
        player.mystery.lastUpdateTime = now;
        return;
    }
    const minutesPassed = Math.floor(timeDiff / (1000 * 60));
    
    if (minutesPassed > 0) {
        const towerFloor = player.tower.currentFloor || 0;
        const vipLevel = player.vip.level || 1;
        const expGained = minutesPassed * towerFloor * vipLevel;
        
        if (expGained > 0) {
            player.mystery.exp += expGained;
            logAction(`离线获得 ${expGained} 奥秘经验`, 'success');
        }
    }
    
    // 更新最后更新时间
    player.mystery.lastUpdateTime = now;
}

// 定时增加经验
setInterval(() => {
    if (player.mystery) {
        const towerFloor = parseInt(document.getElementById('towerFloor').textContent) || 0;
        const vipLevel = parseInt(document.getElementById('vipLevel').textContent) || 1;
        const expPerMinute = towerFloor * vipLevel;
        
        if (expPerMinute > 0) {
            // 每分钟增加一次，这里按秒计算
            player.mystery.exp += expPerMinute / 60;
            player.mystery.lastUpdateTime = new Date().getTime();
            updateMysterySystemDisplay();
        }
    }
}, 1000);

// 切换奥秘系统界面
function toggleMysterySystem() {
   if (player.reincarnationCount < 100) {
        alert("需要达到100转才能开启奥秘系统！");
        return;
    }
  calculateOfflineMysteryExp();
    const ui = document.getElementById('mysterySystemUI');
    const overlay = document.getElementById('mysterySystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateMysterySystemDisplay();
    }
}

// 更新奥秘系统显示
function updateMysterySystemDisplay() {
    const currentStage = player.mystery.stage;
    const currentLevel = player.mystery.level;
    const currentConfig = mysteryConfig.find(c => c.stage === currentStage);
    const nextLevel = currentLevel < 10 ? currentLevel + 1 : 1;
    const nextStage = currentLevel < 10 ? currentStage : currentStage + 1;
    const nextConfig = mysteryConfig.find(c => c.stage === nextStage);
    
    // 更新当前奥秘信息
    const title = `${currentConfig.name} ${currentStage}阶${currentLevel}级`;
    document.getElementById('mysteryTitleDisplay').textContent = title;
    document.getElementById('currentMysteryTitle').textContent = title;
    
    // 更新加成显示
    const maxStageReached = Math.min(currentStage, mysteryConfig.length);
    const maxConfig = mysteryConfig.find(c => c.stage === maxStageReached);
    document.getElementById('mysteryBonusDisplay').textContent = maxConfig ? maxConfig.totalBonus : 1;
    
    // 更新经验显示
    document.getElementById('currentMysteryExp').textContent = Math.floor(player.mystery.exp);
    document.getElementById('nextMysteryExp').textContent = currentConfig.levelCost;
    
    // 更新每分钟经验
    const towerFloor = parseInt(document.getElementById('towerFloor').textContent) || 0;
    const vipLevel = parseInt(document.getElementById('vipLevel').textContent) || 1;
    document.getElementById('expPerMinute').textContent = towerFloor * vipLevel;
    


    // 更新下一等级信息
    const nextMysteryInfo = document.getElementById('nextMysteryInfo');
    if (nextConfig && currentStage < mysteryConfig.length) {
        nextMysteryInfo.innerHTML = `${nextConfig.name} ${nextStage}阶${nextLevel}级 - 消耗: ${nextConfig.levelCost}经验`;
    } else {
        nextMysteryInfo.textContent = '已达到最高奥秘等级';
      document.getElementById('mysteryBonusDisplay').textContent = player.mystery.bonus;
 const offlineExpElement = document.createElement('div');
    offlineExpElement.textContent = `离线经验: ${player.mystery.exp}`;
    container.appendChild(offlineExpElement);
    }
}

// 升级一次奥秘
function upgradeMystery() {
    const currentStage = player.mystery.stage;
    const currentLevel = player.mystery.level;
    const currentConfig = mysteryConfig.find(c => c.stage === currentStage);
    
    // 检查是否已达最高等级
    if (currentStage >= mysteryConfig.length && currentLevel >= 10) {
        logAction("已达到最高奥秘等级！", "error");
        return false;
    }
    
    // 检查经验是否足够
    if (player.mystery.exp < currentConfig.levelCost) {
        logAction("奥秘经验不足，无法升级！", "error");
        return false;
    }
    
    // 消耗经验
    player.mystery.exp -= currentConfig.levelCost;
    
    // 升级处理
    if (currentLevel < 10) {
        player.mystery.level += 1;
    } else {
        player.mystery.level = 1;
        player.mystery.stage += 1;
    }
    updateDisplay();
    return true;
}

// 按指定次数升级奥秘
function upgradeMysteryByAmount() {
    calculateOfflineMysteryExp();
    const amount = parseInt(document.getElementById('mysteryUpgradeAmount').value) || 1;
    let upgraded = 0;
    
    for (let i = 0; i < amount; i++) {
        if (!upgradeMystery()) {
            break;
        }
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级奥秘！`, 'success');
        updateMysterySystemDisplay();
        updateDisplay();
    }
}
 // 升级后更新加成
    const config = mysteryConfig.find(c => c.stage === player.mystery.stage);
    if (config) {
        player.mystery.bonus = config.totalBonus;
    }
  updateDisplay();

// 一键升级奥秘到最大可能
function upgradeMysteryMaxPossible() {
    calculateOfflineMysteryExp();
    let upgraded = 0;
    
    while (upgradeMystery()) {
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级奥秘！`, 'success');
        updateMysterySystemDisplay();
        updateDisplay();
    }
}
function resetFundData() {
    showCustomConfirm('确定要重置所有基金数据吗？这将清空所有投资和收益！', (confirmed) => {
        if (confirmed) {
            player.fundData = {
                funds: [
                    { name: "稳健型基金", netValue: 1.00, maxInvestment: 100000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "平衡型基金", netValue: 1.00, maxInvestment: 1000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "成长型基金", netValue: 1.00, maxInvestment: 100000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "进取型基金", netValue: 1.00, maxInvestment: 1e15, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "激进型基金", netValue: 1.00, maxInvestment: 1e30, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "风险型基金", netValue: 1.00, maxInvestment: 1e50, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 }
                ],
                lastFundUpdate: Date.now()
            };
            
            logAction("基金数据已重置到初始状态", "success");
            updateFundDisplay();
        }
    });
}
// 切换基金系统显示状态
function toggleFundSystem() {
    const fundSystem = document.getElementById('fundSystem');
    const overlay = document.getElementById('fundOverlay');
    const isVisible = fundSystem.style.display !== 'none';
    
    fundSystem.style.display = isVisible ? 'none' : 'block';
    overlay.style.display = isVisible ? 'none' : 'block';
    
    if (!isVisible) {
        updateFundDisplay();
    }
}

// 更新基金显示
function updateFundDisplay() {
    const container = document.getElementById('fundsContainer');
    container.innerHTML = player.fundData.funds.map((fund, index) => {
        const currentValue = fund.investment * fund.netValue;
        const changeRate = ((fund.netValue - 1) * 100).toFixed(2);
        const isPositive = changeRate >= 0;
        const canRedeem = Date.now() >= fund.redemptionTime;
        const redemptionLeft = canRedeem ? 0 : Math.ceil((fund.redemptionTime - Date.now()) / 1000);
        
        return `
            <div style="border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 5px;">
                <h3>${fund.name}</h3>
                <p>当前净值: ${fund.netValue.toFixed(4)}</p>
                <p>收益率: <span style="color: ${fund.returnRate >= 0 ? 'green' : 'red'}">${fund.returnRate >= 0 ? '+' : ''}${fund.returnRate}%</span></p>
                <p>最大投资: ${formatNumber(fund.maxInvestment)} 转生币</p>
                <p>你的投资: ${formatNumber(fund.investment)} 转生币</p>
                <p>当前价值: ${formatNumber(currentValue)} 转生币</p>
                <p>涨幅度: <span style="color: ${isPositive ? 'green' : 'red'}">${isPositive ? '+' : ''}${changeRate}%</span></p>
                
                ${!canRedeem ? `<p>赎回倒计时: ${Math.floor(redemptionLeft / 60)}分${redemptionLeft % 60}秒</p>` : ''}
                
                <div style="margin-top: 10px;">
                    <input type="number" id="fundAmount${index}" placeholder="投资金额" min="1" style="width: 120px; margin-right: 10px;">
                    <button onclick="investFund(${index})" ${fund.investment >= fund.maxInvestment ? 'disabled' : ''}>投资</button>
                    <button onclick="investAllFund(${index})" ${fund.investment >= fund.maxInvestment ? 'disabled' : ''}>一键投资</button>
                    <button onclick="redeemAllFund(${index})" ${fund.investment <= 0 || !canRedeem ? 'disabled' : ''}>一键赎回</button>
                </div>
            </div>
        `;
    }).join('');
}
// 投资基金
function investFund(index) {
   const fund = player.fundData.funds[index];
// 检查是否在赎回前5分钟内
    const now = Date.now();
    const redemptionTime = fund.redemptionTime;
    if (redemptionTime && now > redemptionTime - 5 * 60 * 1000 && now < redemptionTime) {
        logAction("赎回前最后5分钟内禁止投资！", "error");
        return;
    }
    
    const amount = parseInt(document.getElementById(`fundAmount${index}`).value) || 0;
    
    if (amount <= 0) {
        logAction("请输入有效的投资金额", "error");
        return;
    }
    
    if (fund.investment + amount > fund.maxInvestment) {
        logAction(`投资金额超过基金上限${formatNumber(fund.maxInvestment)}`, "error");
        return;
    }
    
    if (player.reincarnationCoin < amount) {
        logAction("转生币不足！", "error");
        return;
    }
    // 检查赎回倒计时状态
    if (fund.redemptionTime <= 0) {
        // 如果没有赎回倒计时，重置净值为1
        fund.netValue = 1.00;
        logAction(`重置基金净值至1.00`, "info");
    }
    player.reincarnationCoin -= amount;
    fund.investment += amount;
    
    // 设置赎回时间为10分钟后
    if (fund.redemptionTime < Date.now()) {
        fund.redemptionTime = Date.now() + 10 * 60 * 1000;
    }
    
    logAction(`成功投资${fund.name} ${amount}转生币`, "success");
    updateFundDisplay();
}

// 赎回基金
function redeemFund(index) {
    const fund = player.fundData.funds[index];
    const amount = parseInt(document.getElementById(`fundAmount${index}`).value) || 0;
    
    if (amount <= 0) {
        logAction("请输入有效的赎回金额", "error");
        return;
    }
    
    if (fund.investment < amount) {
        logAction("投资金额不足！", "error");
        return;
    }
    
    const redeemValue = amount * fund.netValue;
    player.reincarnationCoin += redeemValue;
    fund.investment -= amount;
    
    logAction(`成功赎回${fund.name} ${amount}转生币，获得${redeemValue.toFixed(2)}转生币`, "success");
    
    if (fund.investment === 0) {
        fund.redemptionTime = 0;
    }
    
    updateFundDisplay();
}

// 一键投资
function investAllFund(index) {
    const fund = player.fundData.funds[index];
    const redeemedTime = Date.now() - fund.redemptionStart;
// 检查是否在赎回前5分钟内
    const now = Date.now();
    const redemptionTime = fund.redemptionTime;
    if (redemptionTime && now > redemptionTime - 5 * 60 * 1000 && now < redemptionTime) {
        logAction("赎回前最后5分钟内禁止投资！", "error");
        return;
    }
    const maxCanInvest = fund.maxInvestment - fund.investment;
    const amount = Math.min(player.reincarnationCoin, maxCanInvest);
    
    if (amount <= 0) {
        logAction("没有可投资的转生币或已达投资上限", "error");
        return;
    }
    // 检查赎回倒计时状态
    if (fund.redemptionTime <= 0) {
        // 如果没有赎回倒计时，重置净值为1
        fund.netValue = 1.00;
        logAction(`重置基金净值至1.00`, "info");
    }
    player.reincarnationCoin -= amount;
    fund.investment += amount;
    
    // 设置赎回时间为10分钟后
    if (fund.redemptionTime < Date.now()) {
        fund.redemptionTime = Date.now() + 10 * 60 * 1000;
    }
    
    logAction(`成功全额投资${fund.name} ${amount}转生币`, "success");
    updateFundDisplay();
}

// 一键赎回
function redeemAllFund(index) {
    const fund = player.fundData.funds[index];
    
    if (fund.investment <= 0) {
        logAction("没有可赎回的投资", "error");
        return;
    }
    
    if (Date.now() < fund.redemptionTime) {
        logAction("未到赎回时间", "error");
        return;
    }
    
    const redeemValue = fund.investment * fund.netValue;
    player.reincarnationCoin += redeemValue;
    
    logAction(`成功全额赎回${fund.name}，获得${redeemValue.toFixed(2)}转生币`, "success");
    
    fund.investment = 0;
    fund.redemptionTime = 0;
    
    updateFundDisplay();
}

// 更新基金净值
function updateFundValues() {
    const now = Date.now();
    const elapsed = now - player.fundData.lastFundUpdate;
    const intervals = Math.floor(elapsed / (60 * 1000)); // 每分钟更新一次
    
    if (intervals > 0) {
        player.fundData.funds.forEach(fund => {
           
            let riseProbability;
            if (fund.netValue < 1.0) {
                riseProbability = 0.45; 
            } else if (fund.netValue < 1.5) {
                riseProbability = 0.40; 
            } else if (fund.netValue < 2.0) {
                riseProbability = 0.35; 
            } else if (fund.netValue < 2.5) {
                riseProbability = 0.25; 
            } else {
                riseProbability = 0.10; 
            }

            // 计算投资比例（0-1）
            const investmentRatio = fund.maxInvestment > 0 ? Math.min(fund.investment / fund.maxInvestment, 1) : 0;
            
            // 根据投资比例计算波动幅度（10%-50%）
            const baseVolatility = 0.10 + (0.4 * investmentRatio);
            
           
            
            let newNetValue = fund.netValue;
            for (let i = 0; i < intervals; i++) {
                const willRise = Math.random() < riseProbability;
                const volatility = willRise ? 
                    Math.random() * baseVolatility : 
                    -Math.random() * baseVolatility;
                
                newNetValue *= (1 + volatility);
                
                // 检查是否跌到20%以下，若是则清零
                if (newNetValue <= 0.2) {
                    logAction(`${fund.name}已退市，投资已清零`, "error");
                    fund.investment = 0;
                    newNetValue = 1.00;
                    fund.redemptionTime = 0;
                    break;
                }
            }
            
            // 计算收益率（新增）
            const returnRate = ((newNetValue / fund.netValue - 1) * 100).toFixed(2);
            fund.returnRate = parseFloat(returnRate);
            
            // 更新净值
            fund.netValue = newNetValue;
        });
        
        player.fundData.lastFundUpdate = now - (elapsed % (60 * 1000));
        
        // 如果基金面板打开则更新显示
        if (document.getElementById('fundSystem').style.display !== 'none') {
            updateFundDisplay();
        }
    }
}


// 添加格式化大数字的辅助函数
function formatNumber(num) {
    if (num >= 1e30) return (num / 1e30).toFixed(2) + 'e30';
    if (num >= 1e15) return (num / 1e15).toFixed(2) + 'e15';
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
    return num.toFixed(2);
}

// 钓鱼系统配置
const fishQualities = [
    { name: "普通", color: "#000", exp: 1, rarity: 60 },
    { name: "稀有", color: "#008000", exp: 5, rarity: 25 },
    { name: "珍贵", color: "#0000CD", exp: 20, rarity: 10 },
    { name: "传说", color: "#8B4513", exp: 50, rarity: 4 },
    { name: "神话", color: "#FFD700", exp: 100, rarity: 1 }
];

const junkItems = [
    "破旧的鞋子", "生锈的铁片", "塑料瓶", "烂木头", "破布", "闫闫的黑丝", "比基尼", "杜蕾斯",
    "空罐头", "旧轮胎", "玻璃瓶", "渔网碎片", "朽木"
];

const fishNames = [
    "鲫鱼", "鲤鱼", "草鱼", "闫闫鱼", "黑鱼",
    "鲶鱼", "鳊鱼", "鳙鱼", "鲢鱼", "青鱼",
    "黄鱼", "鳕鳕鱼", "金枪鱼", "三文鱼", "鲨鱼",
    "鳗鱼", "带鱼", "比目鱼", "鲳鱼", "鲈鱼",
    "虹鳟鱼", "罗非鱼", "鲷鱼", "鲅鱼", "鲮鱼", "巨龙", "龙王", "金龙鱼",
    "泥鳅", "黄鳝", "河虾", "对虾", "龙虾", "鳄鱼", "石斑鱼", "秋刀鱼", "河豚",
    "螃蟹", "扇贝", "牡蛎", "蛤蜊", "叶鱼", "墨鱼", "黄花鱼", "中华鲟", "马口鱼",
    "章鱼", "墨鱼", "虾蛄", "海马", "海龙", "美人鱼",
    "河豚", "石斑鱼", "金鱼", "锦鲤", "斗鱼",
    "龙鱼", "天使鱼", "孔雀鱼", "罗汉鱼", "鹦鹉鱼"
];

const decompositionRewards = [
    "vip能力值", "洗髓丹", "洗练石", "玫瑰花"
];
const levelConfig = [
    { level: 1, requiredExp: 0, bonus: 1 },
    { level: 2, requiredExp: 100, bonus: 1 },
    { level: 3, requiredExp: 500, bonus: 1 },
    { level: 4, requiredExp: 1000, bonus: 1 },
    { level: 5, requiredExp: 2500, bonus: 1 },
    { level: 6, requiredExp: 5000, bonus: 1 },
    { level: 7, requiredExp: 10000, bonus: 1 },
    { level: 8, requiredExp: 25000, bonus: 1 },
    { level: 9, requiredExp: 50000, bonus: 1 },
    { level: 10, requiredExp: 100000, bonus: 1 },
    { level: 11, requiredExp: 500000, bonus: 1 },
    { level: 12, requiredExp: 1000000, bonus: 1 },
    { level: 13, requiredExp: 5000000, bonus: 1 },
    { level: 14, requiredExp: 10000000, bonus: 1 },
    { level: 15, requiredExp: 50000000, bonus: 1 }
];

// 钓鱼系统函数
function toggleFishingSystem() {
 if (player.reincarnationCount < 20) {
        alert("需要达到20转才能开启钓鱼系统！");
        return;
    }
    const ui = document.getElementById('fishingSystemUI');
    const overlay = document.getElementById('fishingSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateFishingUI();
    }
}
// 切换自动钓鱼状态
function toggleAutoFishing() {
    player.fishing.autoFishingEnabled = !player.fishing.autoFishingEnabled;
    const btn = document.getElementById('autoFishingBtn');
    btn.textContent = `自动钓鱼: ${player.fishing.autoFishingEnabled ? '开启' : '关闭'}`;
    btn.style.background = player.fishing.autoFishingEnabled ? '#4CAF50' : '#f44336';
    
    logAction(`自动钓鱼${player.fishing.autoFishingEnabled ? '开启' : '关闭'}`, 'info');
    
    // 如果开启自动钓鱼且当前没有在钓鱼，则开始钓鱼
    if (player.fishing.autoFishingEnabled && !player.fishing.isFishing) {
        startFishing();
    }
}

// 切换自动分解状态
function toggleAutoDecomposeFish() {
    player.fishing.autoDecomposeFishEnabled = !player.fishing.autoDecomposeFishEnabled;
    const btn = document.getElementById('autoDecomposeFishBtn');
    btn.textContent = `自动分解: ${player.fishing.autoDecomposeFishEnabled ? '开启' : '关闭'}`;
    btn.style.background = player.fishing.autoDecomposeFishEnabled ? '#2196F3' : '#f44336';
    
    logAction(`自动分解${player.fishing.autoDecomposeFishEnabled ? '开启' : '关闭'}`, 'info');
}

function updateFishingUI() {
    if (!player.fishing) return;
    
   document.getElementById('fishingLevel').textContent = player.fishing.level;
    document.getElementById('currentFishingExp').textContent = player.fishing.currentExp;
    
    // 使用玩家道具中的鱼饵数量
    document.getElementById('baitCount').textContent = player.items.baitCount || 0;
    
    document.getElementById('cageCount').textContent = player.fishing.fishCage.length;
    
    // 计算下一级所需经验
    const nextLevel = Math.min(player.fishing.level, levelConfig.length - 1);
     document.getElementById('nextFishingExp').textContent = levelConfig[player.fishing.level].requiredExp;
    
    document.getElementById('fishingBonus').textContent = player.fishing.bonus.toFixed(2) + '倍';
    
    updateFishCageDisplay();
}

function startFishing() {
    // 检查是否有鱼饵（使用玩家道具中的鱼饵）
    if (!player.items.baitCount || player.items.baitCount <= 0) {
        document.getElementById('fishingStatus').textContent = "没有鱼饵了，无法钓鱼！";
     // 自动钓鱼模式下，鱼饵不足时关闭自动钓鱼
        if (player.fishing.autoFishingEnabled) {
            player.fishing.autoFishingEnabled = false;
            document.getElementById('autoFishingBtn').textContent = "自动钓鱼: 关闭";
            document.getElementById('autoFishingBtn').style.background = '#f44336';
        }

        return;
    }
    
    // 检查鱼笼是否已满
    if (player.fishing.fishCage.length >= 20) {
        document.getElementById('fishingStatus').textContent = "鱼笼已满，请先分解一些鱼获！";
        return;
    }
    
    // 消耗一个鱼饵（从玩家道具中扣除）
    player.items.baitCount--;
    updateFishingUI();
    
    // 更新状态
    player.fishing.isFishing = true;
    document.getElementById('startFishingBtn').style.display = 'none';
    document.getElementById('fishingStatus').textContent = "正在下竿...等待鱼上钩...";
    document.getElementById('fishingRod').style.display = 'block';
    document.getElementById('fishingBobber').style.display = 'block';
    
    // 随机3-10秒后鱼咬钩
    const biteDelay = 3000 + Math.random() * 7000; // 3-10秒
    player.fishing.biteTime = Date.now() + biteDelay;
    
    // 鱼咬钩定时器
    player.fishing.biteTimer = setTimeout(() => {
        fishBite();
    }, biteDelay);
}

function fishBite() {
    player.fishing.isBiting = true;
    document.getElementById('fishingStatus').textContent = "注意！有鱼对鱼饵感兴趣...";
    document.getElementById('fishingBobber').style.animation = 'bobberMove 0.5s infinite alternate';
    document.getElementById('biteIndicator').style.display = 'block';
    
    // 显示拉钩按钮
    document.getElementById('reelInBtn').style.display = 'block';
    
    // 如果开启了自动钓鱼，自动拉钩
    if (player.fishing.autoFishingEnabled) {
        // 随机延迟0.5-1.5秒后自动拉钩，模拟玩家反应时间
        const reelDelay = 500 + Math.random() * 1000;
        setTimeout(() => {
            reelInFish();
        }, reelDelay);
    }
    
    // 咬钩窗口期为2秒
    if (player.fishing.biteWindowTimer) {
        clearTimeout(player.fishing.biteWindowTimer);
    }
    
    player.fishing.biteWindowTimer = setTimeout(() => {
        // 窗口期结束，未及时拉杆
        if (player.fishing.isBiting) {
            document.getElementById('fishingStatus').textContent = "鱼跑掉了！";
            resetFishing();
            
            // 自动钓鱼模式下，自动开始下一次钓鱼
            if (player.fishing.autoFishingEnabled) {
                startFishing();
            }
        }
    }, 2000);
}

function reelInFish() {
    // 检查是否在咬钩状态
    if (!player.fishing.isBiting) return;
    
    // 清除定时器
    clearTimeout(player.fishing.biteWindowTimer);
    
    // 计算是否成功钓到鱼（基于时机）
    const currentTime = Date.now();
    const timeSinceBite = currentTime - player.fishing.biteTime;
    let success = timeSinceBite >= 0 && timeSinceBite <= 2000;
    
    if (success) {
        // 70%概率钓到鱼，30%概率钓到破烂
        if (Math.random() < 0.7) {
            catchFish();
        } else {
            catchJunk();
        }
    } else {
        document.getElementById('fishingStatus').textContent = "时机不对，鱼跑掉了！";
    }
    
    resetFishing();
  // 自动钓鱼模式下，自动开始下一次钓鱼
    if (player.fishing.autoFishingEnabled) {
        startFishing();
    }
}

function catchFish() {
    // 随机选择鱼的品质
    let quality = determineQuality();
    
    // 随机选择鱼的名称
    let name = fishNames[Math.floor(Math.random() * fishNames.length)];
    
    // 随机长度和重量
    let length = (2 + Math.random() * 98).toFixed(1); // 2-100厘米
    let weight = (0.1 + Math.random() * 9.9).toFixed(1); // 0.1-10公斤
    
    // 创建鱼对象
    let fish = {
        type: 'fish',
        name: name,
        quality: quality,
        length: length,
        weight: weight,
        selected: false
    };
    // 如果开启了自动分解，立即分解这条鱼
    if (player.fishing.autoDecomposeFishEnabled) {
        decomposeSingleFish(fish);
        document.getElementById('fishingStatus').textContent = `钓到${fish.quality.name}的${fish.name}并自动分解！`;
    } else {
        // 否则放入鱼笼
        player.fishing.fishCage.push(fish);
        document.getElementById('fishingStatus').textContent = `成功钓到${fish.quality.name}的${fish.name}！`;
    }
    
  // 添加经验
    addExperience(quality.exp);
    
}

function catchJunk() {
    // 随机选择破烂
    let junkName = junkItems[Math.floor(Math.random() * junkItems.length)];
    
    // 创建破烂对象
    let junk = {
        type: 'junk',
        name: junkName,
        selected: false
    };
    
   // 如果开启了自动分解，立即分解这个破烂
    if (player.fishing.autoDecomposeFishEnabled) {
        decomposeSingleJunk(junk);
        document.getElementById('fishingStatus').textContent = `钓到${junk.name}并自动分解！`;
    } else {
        // 否则放入鱼笼
        player.fishing.fishCage.push(junk);
        document.getElementById('fishingStatus').textContent = `钓到了${junk.name}！`;
    }
}

function resetFishing() {
    player.fishing.isFishing = false;
    player.fishing.isBiting = false;
    
    clearTimeout(player.fishing.biteTimer);
    clearTimeout(player.fishing.biteWindowTimer);
    
    document.getElementById('fishingRod').style.display = 'none';
    document.getElementById('fishingBobber').style.display = 'none';
    document.getElementById('biteIndicator').style.display = 'none';
    document.getElementById('fishingBobber').style.animation = '';
    document.getElementById('reelInBtn').style.display = 'none';
    document.getElementById('startFishingBtn').style.display = 'block';
    
    updateFishingUI();
}
function decomposeSingleFish(fish) {
    const qualityFactor = fishQualities.findIndex(q => q.name === fish.quality.name) + 2;
    const lengthFactor = parseFloat(fish.length) / 100;
    const weightFactor = parseFloat(fish.weight) / 10;
    
    // 计算基础数量
    let baseQuantity = Math.floor(1 + qualityFactor * (lengthFactor + weightFactor));
    // 应用收益加成
    baseQuantity = Math.floor(baseQuantity * getCurrentBonus());
    
    // 随机选择一种奖励
    const rewardType = decompositionRewards[Math.floor(Math.random() * decompositionRewards.length)];
    
    // 添加到玩家物品
    switch(rewardType) {
        case 'vip能力值':
            player.items.vipPower = (player.items.vipPower || 0) + baseQuantity;
            break;
        case '洗髓丹':
            player.items.rebornDan = (player.items.rebornDan || 0) + baseQuantity;
            break;
        case '洗练石':
            player.items.refineStone = (player.items.refineStone || 0) + baseQuantity;
            break;
        case '玫瑰花':
            player.items.rose = (player.items.rose || 0) + baseQuantity;
            break;
    }
    
    // 添加种子掉落
    if (Math.random() < 0.15) { // 15%概率获得种子
        dropSeedAfterDecompose();
    }
    
    // 更新显示
    updateFishingUI();
    updateItemDisplay();
   checkTitleUnlocks();
}

// 新增：分解单个破烂
function decomposeSingleJunk(junk) {
    // 破烂分解固定获得1朵玫瑰花
    player.items.rose = (player.items.rose || 0) + 1;
    
    // 更新显示
    updateFishingUI();
    updateItemDisplay();
  checkTitleUnlocks();
}
function addExperience(amount) {
    // 应用收益加成
    const bonus = getCurrentBonus();
    const actualAmount = amount * bonus;
    
    player.fishing.currentExp += actualAmount;
    checkLevelUp();
}

function checkLevelUp() {
    // 从当前等级开始检查是否可以升级
    let currentLevelIndex = levelConfig.findIndex(conf => conf.level === player.fishing.level);
    
    // 检查是否可以升级到下一级
    while (currentLevelIndex + 1 < levelConfig.length && 
           player.fishing.currentExp >= levelConfig[currentLevelIndex + 1].requiredExp) {
        player.fishing.level++;
        currentLevelIndex++;
        document.getElementById('fishingStatus').textContent += `恭喜！钓鱼等级提升到${player.fishing.level}级！`;
    }
    const fishingBonuses = [1, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000, 50000000];
     player.fishing.bonus = fishingBonuses[player.fishing.level - 1] || 50000000;   // 每级增加0.1倍（10%）
    updateFishingUI();
}

function updateFishCageDisplay() {
    const cageContainer = document.getElementById('fishCage');
    cageContainer.innerHTML = '';
    
    if (!player.fishing.fishCage || player.fishing.fishCage.length === 0) {
        cageContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #666;">鱼笼是空的，快去钓鱼吧！</div>';
        return;
    }
    
    player.fishing.fishCage.forEach((item, index) => {
        let itemElement = document.createElement('div');
        itemElement.style.padding = '5px';
        itemElement.style.borderRadius = '4px';
        itemElement.style.cursor = 'pointer';
        itemElement.style.transition = 'all 0.2s';
        
        // 设置选中状态样式
        if (item.selected) {
            itemElement.style.backgroundColor = '#e6f7ff';
            itemElement.style.border = '1px solid #91d5ff';
        } else {
            itemElement.style.backgroundColor = '#f9f9f9';
            itemElement.style.border = '1px solid transparent';
        }
        
        // 设置内容
        if (item.type === 'fish') {
            itemElement.innerHTML = `
                <span style="color: ${item.quality.color}; font-weight: bold;">${item.quality.name}</span>
                ${item.name} (${item.length}cm, ${item.weight}kg)
            `;
        } else {
            itemElement.textContent = item.name;
        }
        
        // 添加点击选中事件
        itemElement.addEventListener('click', () => {
            item.selected = !item.selected;
            updateFishCageDisplay();
        });
        
        cageContainer.appendChild(itemElement);
    });
}

function decomposeSelectedFish() {
    if (!player.fishing.fishCage || player.fishing.fishCage.length === 0) {
        alert('鱼笼是空的！');
        return;
    }
    
    const selectedItems = player.fishing.fishCage.filter(item => item.selected);
    
    if (selectedItems.length === 0) {
        alert('请先选择要分解的鱼获！');
        return;
    }
    
    let rewards = [];
    
    // 处理每种选中的物品
    selectedItems.forEach(item => {
        // 添加种子掉落
    if (Math.random() < 0.15) { // 15%概率获得种子
        dropSeedAfterDecompose();
    }
       
        if (item.type === 'junk') {
            // 破烂分解固定获得1朵玫瑰花
            player.items.rose = (player.items.rose || 0) + 1; // 添加到玩家物品
            rewards.push({type: '玫瑰花', quantity: 1});
        } else if (item.type === 'fish') {
            // 鱼分解根据品质、长度和重量获得奖励
            const qualityFactor = fishQualities.findIndex(q => q.name === item.quality.name) + 2;
            const lengthFactor = parseFloat(item.length) / 100;
            const weightFactor = parseFloat(item.weight) / 10;
            
            // 计算基础数量
            let baseQuantity = Math.floor(1 + qualityFactor * (lengthFactor + weightFactor));
            // 应用收益加成
            baseQuantity = Math.floor(baseQuantity * getCurrentBonus());
            
            // 随机选择一种奖励
            const rewardType = decompositionRewards[Math.floor(Math.random() * decompositionRewards.length)];
            
            // 添加到玩家物品
            switch(rewardType) {
                case 'vip能力值':
                    player.items.vipPower = (player.items.vipPower || 0) + baseQuantity;
                    break;
                case '洗髓丹':
                    player.items.rebornDan = (player.items.rebornDan || 0) + baseQuantity;
                    break;
                case '洗练石':
                    player.items.refineStone = (player.items.refineStone || 0) + baseQuantity;
                    break;
                case '玫瑰花':
                    player.items.rose = (player.items.rose || 0) + baseQuantity;
                    break;
            }
            
            rewards.push({type: rewardType, quantity: baseQuantity});
        }
        
        // 从鱼笼中移除
        const index = player.fishing.fishCage.indexOf(item);
        if (index > -1) {
            player.fishing.fishCage.splice(index, 1);
        }
    });
    
    // 显示奖励
    let rewardMessage = '分解获得：\n';
    rewards.forEach(reward => {
        rewardMessage += `- ${reward.type} x ${reward.quantity}\n`;
    });
    alert(rewardMessage);
    
    // 更新显示
    updateFishingUI();
    updateItemDisplay(); // 更新物品显示
}

function determineQuality() {
    let rand = Math.random() * 100;
    let cumulative = 0;


    for (let quality of fishQualities) {
        cumulative += quality.rarity;

        if (rand <= cumulative) {
            return quality;
        }
    }
    
    return fishQualities[0]; // 默认普通品质
}

function getCurrentBonus() {
    if (!player.fishing.level) return 1;
    const currentLevelConfig = levelConfig.find(conf => conf.level === player.fishing.level);
    return currentLevelConfig ? currentLevelConfig.bonus : 1;
}

// 添加CSS动画
const style = document.createElement('style');
style.textContent = `
    @keyframes bobberMove {
        from { transform: translateY(0); }
        to { transform: translateY(-10px); }
    }
`;
document.head.appendChild(style);

// 种子配置
const seedConfig = [
    { id: "seed1", name: "小麦种子", growthTime: 300, exp: 3, value: 2, rarity: 30 },
    { id: "seed2", name: "水稻种子", growthTime: 600, exp: 5, value: 4, rarity: 25 },
    { id: "seed3", name: "玉米种子", growthTime: 900, exp: 10, value: 10, rarity: 20 },
    { id: "seed4", name: "土豆种子", growthTime: 1200, exp: 15, value: 15, rarity: 18 },
    { id: "seed5", name: "胡萝卜种子", growthTime: 1500, exp: 20, value: 20, rarity: 15 },
    { id: "seed6", name: "番茄种子", growthTime: 1800, exp: 30, value: 25, rarity: 12 },
    { id: "seed7", name: "草莓种子", growthTime: 2100, exp: 40, value: 35, rarity: 10 },
    { id: "seed8", name: "蓝莓种子", growthTime: 2400, exp: 50, value: 40, rarity: 8 },
    { id: "seed9", name: "葡萄种子", growthTime: 2700, exp: 60, value: 50, rarity: 6 },
    { id: "seed10", name: "西瓜种子", growthTime: 3000, exp: 70, value: 60, rarity: 5 },
    { id: "seed11", name: "南瓜种子", growthTime: 3300, exp: 80, value: 70, rarity: 4 },
    { id: "seed12", name: "向日葵种子", growthTime: 3600, exp: 100, value: 80, rarity: 3 },
    { id: "seed13", name: "咖啡豆种子", growthTime: 7200, exp: 200, value: 160, rarity: 2 },
    { id: "seed14", name: "茶树种子", growthTime: 10800, exp: 500, value: 250, rarity: 1 },
    { id: "seed15", name: "金苹果种子", growthTime: 21600, exp: 1200, value: 500, rarity: 0.5 }
];

// 切换农场系统界面
function toggleFarmSystem() {
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启农场系统！");
        return;
    }
    const ui = document.getElementById('farmSystemUI');
    const overlay = document.getElementById('farmSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        
        // 关闭界面时清除自动化检查
        if (window.farmAutoCheckInterval) {
            clearInterval(window.farmAutoCheckInterval);
            window.farmAutoCheckInterval = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateFarmDisplay();
        
        // 开启界面时启动自动化检查（每10秒检查一次）
        if (!window.farmAutoCheckInterval) {
            window.farmAutoCheckInterval = setInterval(() => {
                if (player.farm.autoHarvest) autoHarvest();
                if (player.farm.autoPlant) autoPlant();
            }, 1000); // 1秒检查一次
        }
    }
}

function closeFarmSystem() {
    document.getElementById('farmSystemUI').style.display = 'none';
    document.getElementById('farmSystemOverlay').style.display = 'none';
}

// 更新农场显示
function updateFarmDisplay() {
    // 更新基本信息
    document.getElementById('farmLevel').textContent = player.farm.level;
    document.getElementById('farmExp').textContent = player.farm.exp;
    document.getElementById('farmExpNext').textContent = player.farm.expToNextLevel;
    document.getElementById('farmFieldCount').textContent = player.farm.fields.filter(f => f.planted).length;
    document.getElementById('farmMaxFields').textContent = player.farm.maxFields;
    document.getElementById('waterCount').textContent = player.items.vipPower;
     document.getElementById('autoPlantBtn').textContent = `自动种植: ${player.farm.autoPlant ? '开启' : '关闭'}`;
    document.getElementById('autoPlantBtn').style.background = player.farm.autoPlant ? '#4CAF50' : '#FF9800';
    document.getElementById('autoHarvestBtn').textContent = `自动收获: ${player.farm.autoHarvest ? '开启' : '关闭'}`;
    document.getElementById('autoHarvestBtn').style.background = player.farm.autoHarvest ? '#4CAF50' : '#9C27B0';
    // 更新农田显示
    const fieldsContainer = document.getElementById('farmFields');
    fieldsContainer.innerHTML = '';
    
    for (let i = 0; i < player.farm.maxFields; i++) {
        const field = player.farm.fields[i] || { planted: false };
        const fieldDiv = document.createElement('div');
        fieldDiv.className = 'farm-field';
        fieldDiv.style.border = '1px solid #555';
        fieldDiv.style.borderRadius = '5px';
        fieldDiv.style.padding = '10px';
        fieldDiv.style.textAlign = 'center';
        fieldDiv.style.cursor = 'pointer';
        fieldDiv.style.position = 'relative';
        fieldDiv.style.height = '100px';
        
        if (i >= player.farm.maxFields) {
            fieldDiv.style.backgroundColor = '#333';
            fieldDiv.innerHTML = '<div style="color: #777;">未解锁</div>';
            fieldsContainer.appendChild(fieldDiv);
            continue;
        }
        
        if (!field.planted) {
            fieldDiv.innerHTML = '<div>空闲农田</div><button onclick="openSeedSelection(' + i + ')" style="margin-top: 10px;">种植</button>';
            fieldDiv.style.backgroundColor = '#2a2a2a';
        } else {
            const seed = seedConfig.find(s => s.id === field.seedId);
            const now = Date.now();
            const elapsed = now - field.plantTime;
            const progress = Math.min(100, (elapsed / (seed.growthTime * 1000)) * 100);
            
            // 显示作物状态
            let statusText = '';
            if (progress < 100) {
                statusText = '生长中: ' + Math.floor(progress) + '%';
                
                // 检查是否需要浇水
                if (field.wateredAt && (now - field.wateredAt) > 1800000000) { // 半小时需要浇水
                    statusText = '<span style="color: #ff5555;">需要浇水!</span>';
                }
            } else {
                statusText = '<span style="color: #55ff55;">可收获!</span>';
            }
            
            fieldDiv.innerHTML = `
                <div><strong>${seed.name}</strong></div>
                <div>${statusText}</div>
                <div style="height: 10px; background: #555; margin-top: 10px; border-radius: 5px;">
                    <div style="height: 100%; background: #4CAF50; width: ${progress}%; border-radius: 5px;"></div>
                </div>
            `;
            
            // 添加操作按钮
            const buttonContainer = document.createElement('div');
            buttonContainer.style.marginTop = '0px';
            
            if (progress < 100) {
                const waterBtn = document.createElement('button');
                waterBtn.textContent = '浇水';
                waterBtn.onclick = () => waterCrop(i);
                waterBtn.style.marginRight = '5px';
                buttonContainer.appendChild(waterBtn);
            } else {
                const harvestBtn = document.createElement('button');
                harvestBtn.textContent = '收获';
                harvestBtn.onclick = () => harvestCrop(i);
                harvestBtn.style.backgroundColor = '#4CAF50';
                buttonContainer.appendChild(harvestBtn);
            }
            
            fieldDiv.appendChild(buttonContainer);
            
            if (progress < 100) {
                fieldDiv.style.backgroundColor = '#2a2a2a';
            } else {
                fieldDiv.style.backgroundColor = '#334433';
            }
        }
        
        fieldsContainer.appendChild(fieldDiv);
    }
    
    // 更新种子仓库
    const seedContainer = document.getElementById('seedInventory');
    seedContainer.innerHTML = '';
    
    seedConfig.forEach(seed => {
        const count = player.farm.seeds[seed.id] || 0;
        if (count > 0) {
            const seedDiv = document.createElement('div');
            seedDiv.className = 'seed-item';
            seedDiv.style.border = '1px solid #555';
            seedDiv.style.borderRadius = '5px';
            seedDiv.style.padding = '10px';
            seedDiv.style.textAlign = 'center';
            seedDiv.style.backgroundColor = '#2a2a2a';
            
            seedDiv.innerHTML = `
                <div><strong>${seed.name}</strong></div>
                <div>数量: ${count}</div>
                <div>时间: ${formatTimeq(seed.growthTime)}</div>
            `;
            
            seedContainer.appendChild(seedDiv);
        }
    });
}

// 打开种子选择界面
function openSeedSelection(fieldIndex) {
    const seedContainer = document.getElementById('seedInventory');
    seedContainer.innerHTML = '';
    
    seedConfig.forEach(seed => {
        const count = player.farm.seeds[seed.id] || 0;
        if (count > 0) {
            const seedDiv = document.createElement('div');
            seedDiv.className = 'seed-item';
            seedDiv.style.border = '1px solid #555';
            seedDiv.style.borderRadius = '5px';
            seedDiv.style.padding = '10px';
            seedDiv.style.textAlign = 'center';
            seedDiv.style.backgroundColor = '#2a2a2a';
            seedDiv.style.cursor = 'pointer';
            
            seedDiv.innerHTML = `
                <div><strong>${seed.name}</strong></div>
                <div>数量: ${count}</div>
                <div>时间: ${formatTimeq(seed.growthTime)}</div>
            `;
            
            seedDiv.onclick = () => plantSeed(fieldIndex, seed.id);
            
            seedContainer.appendChild(seedDiv);
        }
    });
    
    // 添加取消按钮
    const cancelDiv = document.createElement('div');
    cancelDiv.className = 'seed-item';
    cancelDiv.style.border = '1px solid #555';
    cancelDiv.style.borderRadius = '5px';
    cancelDiv.style.padding = '10px';
    cancelDiv.style.textAlign = 'center';
    cancelDiv.style.backgroundColor = '#442222';
    cancelDiv.style.cursor = 'pointer';
    cancelDiv.innerHTML = '<div><strong>取消</strong></div>';
    cancelDiv.onclick = updateFarmDisplay;
    seedContainer.appendChild(cancelDiv);
}

// 种植种子
function plantSeed(fieldIndex, seedId) {
    if (player.farm.seeds[seedId] <= 0) return;
    
    // 初始化农田数组
    while (player.farm.fields.length <= fieldIndex) {
        player.farm.fields.push({ planted: false });
    }
    
    player.farm.fields[fieldIndex] = {
        planted: true,
        seedId: seedId,
        plantTime: Date.now(),
        wateredAt: Date.now()
    };
    
    player.farm.seeds[seedId]--;
    
    updateFarmDisplay();
    logAction(`在农田${fieldIndex + 1}种植了种子`, 'success');
}

// 浇水
function waterCrop(fieldIndex) {
    if (player.items.vipPower <= 30) {
        logAction("水滴不足！", "error");
        return;
    }
    
    const field = player.farm.fields[fieldIndex];
    if (!field || !field.planted) return;
    
    // 减少3分钟成熟时间（180000毫秒）
    field.plantTime -= 180000;
    
    field.wateredAt = Date.now();
    player.items.vipPower-=30;
    
    updateFarmDisplay();
    logAction(`为农田${fieldIndex + 1}浇水，成熟时间减少3分钟`, 'info');
}

// 收获作物
function harvestCrop(fieldIndex) {
    const field = player.farm.fields[fieldIndex];
    if (!field || !field.planted) return;
    
    const seed = seedConfig.find(s => s.id === field.seedId);
    const now = Date.now();
    const elapsed = now - field.plantTime;
    
    if (elapsed < seed.growthTime * 1000) {
        logAction("作物还未成熟！", "error");
        return;
    }
    
    // 获得经验和转生币
    player.farm.exp += seed.exp;
    player.items.vipPower += seed.value;
    
    // 检查升级
    checkFarmLevelUp();
    
    // 重置农田
    player.farm.fields[fieldIndex] = { planted: false };
    onFarmHarvest();
    updateFarmDisplay();
    updateDisplay(); // 更新主界面显示
   checkTitleUnlocks();
    logAction(`收获${seed.name}，获得${seed.exp}农场经验和${seed.value}VIP能力值`, 'success');
}

// 一键浇水
function waterAllCrops() {
    if (player.items.vipPower <= 0) {
        logAction("水滴不足！", "error");
        return;
    }
    
    let watered = 0;
    player.farm.fields.forEach((field, index) => {
        if (field.planted) {
            const now = Date.now();
            if (field.wateredAt && (now - field.wateredAt) > 1800000) {
                if (player.items.vipPower > 0) {
                    field.wateredAt = now;
                    playe.items.vipPower--;
                    watered++;
                }
            }
        }
    });
    
    if (watered > 0) {
        updateFarmDisplay();
        logAction(`一键浇水完成，浇灌了${watered}块农田`, 'success');
    } else {
        logAction("没有需要浇水的农田", "info");
    }
}

// 一键收获
function harvestAllCrops() {
    let harvested = 0;
    let totalExp = 0;
    let totalCoins = 0;
    
    player.farm.fields.forEach((field, index) => {
        if (field.planted) {
            const seed = seedConfig.find(s => s.id === field.seedId);
            const now = Date.now();
            const elapsed = now - field.plantTime;
            
            if (elapsed >= seed.growthTime * 1000) {
                // 收获作物
                player.farm.exp += seed.exp;
                player.items.vipPower += seed.value;
                totalExp += seed.exp;
                totalCoins += seed.value;
                
                // 重置农田
                player.farm.fields[index] = { planted: false };
               onFarmHarvest();
                harvested++;
            }
        }
    });
    
    if (harvested > 0) {
        // 检查升级
        checkFarmLevelUp();
        updateFarmDisplay();
        updateDisplay(); // 更新主界面显示
        logAction(`一键收获完成，收获${harvested}块农田，获得${totalExp}农场经验和${totalCoins}VIP能力值`, 'success');
    } else {
        logAction("没有可收获的农田", "info");
    }
}

// 检查农场升级
function checkFarmLevelUp() {
    while (player.farm.exp >= player.farm.expToNextLevel) {
        player.farm.exp -= player.farm.expToNextLevel;
        player.farm.level++;
        
        // 每级增加最大农田数量
        if (player.farm.level % 3 === 0) {
            player.farm.maxFields++;
        }
        
        // 更新下一级所需经验
        player.farm.expToNextLevel = Math.floor(player.farm.expToNextLevel * 1.5);
        
        logAction(`农场升级到${player.farm.level}级！解锁新农田`, 'success');
    }
}
function dropSeedAfterDecompose() {
    const totalRarity = seedConfig.reduce((sum, seed) => sum + seed.rarity, 0);
    const rand = Math.random() * totalRarity;
    
    let cumulative = 0;
    for (const seed of seedConfig) {
        cumulative += seed.rarity;
        if (rand <= cumulative) {
            // 添加种子到仓库
            player.farm.seeds[seed.id] = (player.farm.seeds[seed.id] || 0) + 1;
            logAction(`分解获得${seed.name}`, 'success');
            break;
        }
    }
}
// 时间格式化辅助函数
function formatTimeq(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    return `${hours > 0 ? hours + '小时' : ''}${minutes > 0 ? minutes + '分' : ''}${secs}秒`;
}
// 离线时更新农场
function updateFarmOffline() {
    const now = Date.now();
    const elapsed = (now - player.farm.lastUpdate) / 1000; // 转换为秒
    
    player.farm.fields.forEach(field => {
        if (field.planted) {
            const seed = seedConfig.find(s => s.id === field.seedId);
            // 更新生长进度（但不自动收获）
            // 实际收获需要玩家手动操作
        }
    });
    
    player.farm.lastUpdate = now;
}
function initFarmData() {
    if (!player.farm) {
        player.farm = {
            level: 1,
            exp: 0,
            expToNextLevel: 150,
            fields: Array(2).fill().map(() => ({ planted: false })),
            maxFields: 2,
            seeds: {},
            water: 10,
            lastUpdate: Date.now(),
          autoPlant: false,    // 新增自动种植设置
            autoHarvest: false 
        };
    }
    
    // 确保农田数组大小正确
    while (player.farm.fields.length < player.farm.maxFields) {
        player.farm.fields.push({ planted: false });
    }
}
// 切换自动种植功能
function toggleAutoPlant() {
    player.farm.autoPlant = !player.farm.autoPlant;
    const btn = document.getElementById('autoPlantBtn');
    btn.textContent = `自动种植: ${player.farm.autoPlant ? '开启' : '关闭'}`;
    btn.style.background = player.farm.autoPlant ? '#4CAF50' : '#FF9800';
    
    logAction(`自动种植${player.farm.autoPlant ? '开启' : '关闭'}`, 'info');
    
    // 如果开启自动种植，立即执行一次
    if (player.farm.autoPlant) {
        autoPlant();
    }
}

// 切换自动收获功能
function toggleAutoHarvest() {
    player.farm.autoHarvest = !player.farm.autoHarvest;
    const btn = document.getElementById('autoHarvestBtn');
    btn.textContent = `自动收获: ${player.farm.autoHarvest ? '开启' : '关闭'}`;
    btn.style.background = player.farm.autoHarvest ? '#4CAF50' : '#9C27B0';
    
    logAction(`自动收获${player.farm.autoHarvest ? '开启' : '关闭'}`, 'info');
    
    // 如果开启自动收获，立即执行一次
    if (player.farm.autoHarvest) {
        autoHarvest();
    }
}

// 自动种植逻辑
function autoPlant() {
    if (!player.farm.autoPlant) return;
    
    let planted = false;
    
    // 检查是否有空闲农田
    for (let i = 0; i < player.farm.fields.length; i++) {
        const field = player.farm.fields[i];
        
        // 如果农田空闲且有种子可用
        if (!field.planted && Object.keys(player.farm.seeds).length > 0) {
            // 选择第一个有库存的种子
            for (const seedId in player.farm.seeds) {
                if (player.farm.seeds[seedId] > 0) {
                    plantSeed(i, seedId);
                    planted = true;
                    break;
                }
            }
        }
    }
    
    if (planted) {
        logAction("自动种植执行完成", 'success');
    }
}

// 自动收获逻辑
function autoHarvest() {
    if (!player.farm.autoHarvest) return;
    
    let harvested = false;
    
    // 检查所有农田
    for (let i = 0; i < player.farm.fields.length; i++) {
        const field = player.farm.fields[i];
        
        if (field.planted) {
            const seed = seedConfig.find(s => s.id === field.seedId);
            const now = Date.now();
            const elapsed = now - field.plantTime;
            
            // 如果作物已成熟
            if (elapsed >= seed.growthTime * 1000) {
                harvestCrop(i);
                harvested = true;
            }
        }
    }
    
    if (harvested) {
        logAction("自动收获执行完成", 'success');
    }
}

const liveStreamSystem = {
    level: 1,
    exp: 0,
    expToNextLevel: [1000, 5000, 7500, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000, 65000, 70000, 75000, 80000, 85000, 90000, 95000, 100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 2500000, 5000000, 7500000, 10000000, 25000000, 50000000, 75000000, 100000000, 10000000000],
    isLive: false,
    viewers: [],
    viewerCount: 0,
    maxViewers: 10,
    totalEarnings: 1000,
    expMultiplier: 1,
    lastUpdate: Date.now(),
   danmakuGeneratorActive: false,
    aiMessages: [
        "主播今天玩什么？",
        "加油！支持主播！",
        "这个游戏看起来好有趣",
        "刚刚的打斗太精彩了！",
        "主播技术真好",
        "求教学怎么快速转生",
        "关注了，下次还来",
        "礼物已送上，继续加油",
        "今天运气不错啊",
        "这个装备怎么获得的？",
        "6666666",
        "我喜欢你主播",
        "太强了",
         "主播嫁给我",
        "哈哈哈，这个操作笑死我了",
        "主播多大了？",
        "什么时候下次直播？",
        "求背景音乐名字",
        "画质好清晰啊",
        "卡了吗？怎么不动了",
        "第一次来看，感觉不错！",
        "求问主播用的什么鼠标？",
        "支持支持！打赏走一波",
        "这个角色怎么加点？",
        "新来的，关注了",
        "背景音乐好好听！",
        "刚刚那下没看清，能回放吗？",
        "主播吃饭了吗",
        "这游戏需要氪金吗？",
        "太厉害了吧，学到了",
        "卡了卡了，主播那边还好吗？",
        "下次能玩无限升级吗？",
        "礼物收到了吗？主播",
        "666，必须录屏了",
        "今天直播到几点呀？",
        "新手能玩这个游戏吗？",
        "主播加油，别慌！",
        "求组队一起玩！",
        "这个地图怎么解锁？",
        "哈哈哈，主播被坑了",
        "关注了，主播多更新",
        "主播今天状态不错啊",
        "网络有点卡，刷新试试",
        "这个技能怎么放的？",
        "刚刚那波失误有点可惜",
        "求主播带飞！",
        "这个游戏什么时候上线的？",
        "主播累不累？歇会儿吧",
        "新来的，求问这是什么游戏？",
        "太精彩了，全程没快进",
        "主播用的什么显卡？画质这么好",
        "下次直播能提前说一声吗？",
        "什么时候下次直播？",
        "刚刚那下反应好快！",
        "卡退了，重新进来了",
        "求问这个游戏怎么下载？",
        "主播技术比我朋友好多了",
        "哈哈哈，主播的表情太逗了",
        "这个游戏有手游吗？",
        "主播快回复一下我的问题呀",
        "网络怎么回事，老是卡顿",
        "主播明天几点直播？",
        "求教学怎么躲这个技能",
        "这个游戏画质真不错",
        "支持主播，会一直关注",
        "主播用的什么耳机？",
        "这个角色哪个职业最强？",
        "新来的，求主播带一下",
        "这个游戏需要什么配置？",
        "背景音乐是什么歌？好熟悉",
        "卡了，主播能等一下吗？",
        "主播今天直播内容好丰富",
        "求问怎么快速升级？",
        "礼物已刷，主播看得到吗？",
        "主播技术真的没话说，太强了",
        "新来的，觉得主播很有趣",
        "主播什么时候换游戏玩？",
        "关注了，下次开播提醒我",
        "支持主播，打赏不能少",
        "网络恢复了吗？刚才好卡",
        "求问这个游戏有攻略吗？",
        "这个游戏多人玩吗？",
        "关注了，主播要常开播哦",
        "主播今天心情不错呀",
        "新来的，求问主播常玩什么游戏？",
        "主播技术比我想象中好太多",
        "礼物送上，祝主播越来越好",
        "卡了卡了，大家都卡吗？",
        "主播明天还播这个游戏吗？",
        "支持主播，会推荐朋友来看",
        "关注了，主播多玩点新游戏",
        "主播今天直播时长多久呀？",
        "礼物已送，主播辛苦了",
        "主播什么时候开粉丝群？",
        "求问怎么获得金币快？",
        "刚刚的打斗太精彩了！",
        "支持主播，每天都来看",
        "关注了，主播记得回关哦",
        "关注了，下次还来",
        "网络终于不卡了",
        "今天运气不错啊",
        "这个装备怎么获得的？",
        "主播技术真的很专业",
        "这个游戏有等级上限吗？",
        "哈哈哈，这个操作笑死我了",
        "支持主播，打赏走起",
        "新来的，觉得直播很精彩",
        "背景音乐是谁唱的",
        "关注了，主播多搞点福利活动",
        "主播今天吃的什么呀？",
        "新来的，关注了不后悔",
        "主播技术越来越好的",
        "这个游戏看起来好有趣",
        "刚刚的打斗太精彩了！",
        "主播技术真好",
        "求教学怎么快速转生",
        "关注了，下次还来",
        "礼物已送上，继续加油",
        "今天运气不错啊",
        "美女",
        "支持主播，永远是粉丝",
        "这个游戏怎么创建角色？",
        "这个游戏有公会系统吗？",
        "关注了，下次开播不见不散",
        "求教学怎么放风筝",
         "老公吃饭了吗",
        "老婆吃饭了吗",
        "牛逼",
        "好厉害",
       "CPDD",
        "画质好清晰啊",
        "主播我喜欢你！",
        "你好菜啊",
        "加油！支持主播！",
        "这个游戏看起来好有趣",
        "刚刚的打斗太精彩了！",
        "网络又卡了，服了",
        "支持主播，会一直陪伴",
        "关注了，下次还来",
        "礼物已送上，继续加油",
        "这个游戏画面风格我喜欢",
        "这个游戏怎么举报外挂？",
        "主播下次能早点直播吗？",
        "这个游戏有师徒系统吗？",
        "哈哈哈，这个操作笑死我了",
        "主播有女朋友吗？",
        "什么时候下次直播？",
        "求背景音乐名字",
        "画质好清晰啊",
        "卡了吗？怎么不动了",
        "礼物送上，主播越来越火",
        "加油！支持主播！",
        "这个装备怎么镶嵌宝石？",
        "新来的，关注了，主播多播哦",  
        "晚安，先睡了",
        "明天还直播吗？"
    ],
    aiNames: [
        "闫闫", "花花", "茶茶", "鱼鱼", "通元","叶子", "沉鱼", "探探", "凡", "尝试", "胖大仙", "水芙蓉", "亲情相爱一家人", "伍思凯", "吖晴儿", 
        "苏菲", "王荣", "瑶瑶", "悸声", "反骨仔", "冰糖红茶", "蝴蝶效应,", "悦悦", "老倪", "慕白", "轩辕", "阿孝", "yuan", "王北的北,", "我已经在拉扯了", "林贝", "慕白", "阿迪", "微软是你", "王汝刚", "刘禹锡", "艾夫华", "渥太华", "阿杰", "阿道夫", "豆腐花茜茜", "阿法和阿伟","峰", "好人", "奥格威", "阿睿", "星嗄","阿华田", "子女不能", "开膛手杰华", "埃弗阿福", "黑丝姐姐", "黑菲","爱喝牛奶", "骚粉", "王如玉", "血红女爵", "水果",
        "萩", "我不高兴", "山麒麟", "管者", "阿斯巴甜","圣光", "征服他哥", "字画大师", "诗人睡睡", "孙国辉",
        "君子不气", "空白", "香香", "浪荡丶", "啦喇菈辣","十分", "神烦狗", "张枫五", "偶见", "孙国伟","时迁", "Plan B", "冥王", "阿顺帆",
        "Tung", "迷雾", "源", "泯潮猫", "寻良","冰箭", "赵哥", "张德荣", "三国英", "清茶", 
        "有意思", "非酋本酋", "肝双", "氪金佬", "舍尔", "赵哥帅", "张宝华", "祝福鱼", "珍贵仁",
         "Cardiac", "战无极", "凹凸曼", "白饭鱼", "独钓寒江雪",
        "锅巴", "花海", "怀安", "金刚骷髅娃", "锦瑟笙箫落",
        "旧", "举着戒指对你笑i", "磊哥", "凛", "六号线",
        "Numb", "柠檬妖精", "PoRo", "随风", "墨清",
        "桃子姐姐", "温存i", "我叫MMT", "我呀我", "小末影", "风影", "笑气气", "炫月", "燁燁",
        "一梦千年", "佳音如期", "功不唐捐", "卡子哥", "晨曦",
        "帅到分手", "午夜飞升", "星君", "预言", "成",
        "红尘", "幻月", "幻雪", "山与海", "虾仁哥哥",
        "风之奇影", "爱上风", "Dddddddd", "珊迪", "木子升", "建议击毙", "潮起潮落", "风云祭", "100分",
        "谷丶然", "无敌的话", "勿忘", "Rayn", "哈哈哈哈哈",
        "钵钵鸡", "笑气气", "花海", "Æternø", "天赋与努力",
        "晨落", "徒手", "柠檬", "余晖", "隐",
        "D", "三都", "大白菜帮子", "佳南",  "休闲玩家"
    ],
    donationMessages: [
        "送上小心心！",
        "给你点鼓励！",
        "支持主播！",
        "继续加油！",
        "小小礼物不成敬意",
        "今天的表现太棒了！",
        "值得鼓励！",
        "希望主播越来越好",
        "这是你应得的！",
        "打赏一波，主播辛苦了！",
        "希望越来越好，礼物支持",
        "一点心意，买杯奶茶喝~！",
        "看得尽兴，打赏表示",
        "关注很久了，今天送个礼物",
        "今天的直播超赞，打赏！",
        "主播加油，礼物来了哦",
        "小小礼物，不成敬意，继续加油",
        "每天必看，今天打赏一下",
        "这波太秀了，送礼物！",
        "希望你一直播下去，礼物支持",
        "主播辛苦了，送个小礼物",
        "支持你到底，打赏一波",
        "感谢带来欢乐，礼物请查收",
        "主播越来越好了，送个礼物",
        "今天看得过瘾，必须打赏",
        "喜欢你的直播，送点心意",
        "感谢分享，礼物送上！",
        "这波操作值个礼物！",
        "主播真棒，必须鼓励！",
        "感谢你的直播陪伴"
    ]
};
const danmakuSystem = {
    active: true,
    speed: 5, // 1-10
    density: 3, // 1-10
    container: null,
    colors: {
        system: '#ff00ff',
        viewer: '#ffffff',
        player: '#4CAF50',
        donation: '#FFD700'
    },
    tracks: [], // 弹幕轨道
    trackHeight: 30, // 每条轨道的高度
    maxTracks: 10, // 最大轨道数
    fontSizes: [14, 16, 18, 20],
    styles: ['normal', 'bold', 'italic']
};
// 初始化弹幕系统
function initDanmakuSystem() {
    danmakuSystem.container = document.getElementById('danmakuContainer');
    
    // 初始化轨道
    const containerHeight = danmakuSystem.container.clientHeight;
    danmakuSystem.maxTracks = Math.floor(containerHeight / danmakuSystem.trackHeight);
    danmakuSystem.tracks = [];
    
    for (let i = 0; i < danmakuSystem.maxTracks; i++) {
        danmakuSystem.tracks.push({
            occupied: false,
            lastUsed: 0
        });
    }
    
    // 设置弹幕控制事件
    document.getElementById('danmakuToggle').addEventListener('change', function() {
        danmakuSystem.active = this.checked;
        if (!this.checked) {
            clearDanmaku();
        }
    });
    
    document.getElementById('danmakuSpeed').addEventListener('input', function() {
        danmakuSystem.speed = parseInt(this.value);
    });
    
    document.getElementById('danmakuDensity').addEventListener('input', function() {
        danmakuSystem.density = parseInt(this.value);
    });
}

// 清除弹幕函数（修复）
function clearDanmaku() {
    if (!danmakuSystem.container) return;
    
    // 获取所有弹幕元素
    const danmakuElements = danmakuSystem.container.querySelectorAll('.danmaku');
    
    // 遍历所有弹幕元素
    danmakuElements.forEach(danmaku => {
        // 获取所有正在运行的动画
        const animations = danmaku.getAnimations();
        
        // 取消所有动画
        animations.forEach(animation => {
            animation.cancel();
        });
        
        // 移除元素
        danmaku.remove();
    });
    
    // 重置所有轨道状态
    if (danmakuSystem.tracks) {
        for (let i = 0; i < danmakuSystem.tracks.length; i++) {
            danmakuSystem.tracks[i].occupied = false;
            danmakuSystem.tracks[i].lastUsed = Date.now();
        }
    }
}

// 添加弹幕到直播画面
function addDanmakuToScreen(sender, message, type) {
    if (!danmakuSystem.active || !player.liveStream.isLive || !danmakuSystem.container) return;
    
    // 找到可用的轨道
    const availableTrack = findAvailableTrack();
    if (availableTrack === -1) return;
    
    // 创建弹幕元素
    const danmaku = document.createElement('div');
    danmaku.className = 'danmaku';
    danmaku.style.position = 'absolute';
    danmaku.style.top = `${availableTrack * danmakuSystem.trackHeight}px`;
    danmaku.style.right = '0';
    danmaku.style.color = danmakuSystem.colors[type] || '#ffffff';
    danmaku.style.fontSize = `${danmakuSystem.fontSizes[Math.floor(Math.random() * danmakuSystem.fontSizes.length)]}px`;
    danmaku.style.fontWeight = Math.random() > 0.7 ? 'bold' : 'normal';
    danmaku.style.fontStyle = Math.random() > 0.8 ? 'italic' : 'normal';
    danmaku.style.textShadow = '1px 1px 2px rgba(0,0,0,0.7)';
    danmaku.style.whiteSpace = 'nowrap';
    danmaku.style.zIndex = '2';
    danmaku.style.opacity = '0.9';
    danmaku.style.transform = 'translateX(100%)';
    danmaku.innerHTML = `<span style="color: #aaa;">${sender}:</span> ${message}`;
    
    // 添加到容器
    danmakuSystem.container.appendChild(danmaku);
    
    // 标记轨道占用
    danmakuSystem.tracks[availableTrack].occupied = true;
    
    // 计算动画时间
    const containerWidth = danmakuSystem.container.clientWidth;
    const danmakuWidth = danmaku.offsetWidth;
    const distance = containerWidth + danmakuWidth;
    const duration = distance / (danmakuSystem.speed * 50);
    
    // 应用动画
    const animation = danmaku.animate(
        [
            { transform: 'translateX(100%)' },
            { transform: `translateX(-${danmakuWidth}px)` }
        ],
        {
            duration: duration * 1000,
            easing: 'linear'
        }
    );
    
    animation.onfinish = () => {
        // 动画完成后移除元素并释放轨道
        if (danmaku.parentNode === danmakuSystem.container) {
            danmaku.remove();
        }
        if (availableTrack < danmakuSystem.tracks.length) {
            danmakuSystem.tracks[availableTrack].occupied = false;
            danmakuSystem.tracks[availableTrack].lastUsed = Date.now();
        }
    };
}

// 查找可用轨道
function findAvailableTrack() {
    if (!danmakuSystem.tracks || danmakuSystem.tracks.length === 0) return -1;
    
    // 按最后使用时间排序
    const sortedTracks = [...danmakuSystem.tracks]
        .map((track, index) => ({ ...track, index }))
        .sort((a, b) => a.lastUsed - b.lastUsed);
    
    for (let i = 0; i < sortedTracks.length; i++) {
        if (!sortedTracks[i].occupied) {
            return sortedTracks[i].index;
        }
    }
    
    // 如果没有空闲轨道，尝试使用最久未使用的轨道
    const oldestTrack = sortedTracks[0];
    if (Date.now() - oldestTrack.lastUsed > 5000) {
        return oldestTrack.index;
    }
    
    return -1;
}


// 初始化直播系统
function initLiveStreamSystem() {
    if (!player.liveStream) {
        player.liveStream = {
            level: 1,
            exp: 0,
            totalEarnings: 1000,
            isLive: false,
            lastLiveStart: 0,
            totalLiveTime: 0,
            expMultiplier: 1,
            viewers: [],
            donationHistory: [],
            lastDanmaku: null
        };
    }
}

// 切换直播系统界面
function toggleLiveStreamSystem() {
    if (player.reincarnationCount < 500) {
        alert("需要达到500转才能开启直播系统！");
        return;
    }
    const overlay = document.getElementById('liveStreamSystemOverlay');
    const ui = document.getElementById('liveStreamSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initLiveStreamSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateLiveStreamUI();
    }
}

// 更新直播系统UI
function updateLiveStreamUI() {
    document.getElementById('liveStreamLevel').textContent = player.liveStream.level;
    document.getElementById('liveStreamExp').textContent = Math.floor(player.liveStream.exp);
    document.getElementById('liveStreamNextExp').textContent = liveStreamSystem.expToNextLevel[player.liveStream.level - 1] || 10000000000;
    document.getElementById('totalLiveEarnings').textContent = (player.liveStream.totalEarnings/10).toFixed(0);
    document.getElementById('liveViewerCount').textContent = player.liveStream.viewers.length;
    
    // 更新经验条
    const expPercent = Math.min(100, (player.liveStream.exp / (liveStreamSystem.expToNextLevel[player.liveStream.level - 1] || 10000000000)) * 100);
    document.getElementById('liveExpProgress').style.width = `${expPercent}%`;
    
    // 更新观众列表
    const viewerList = document.getElementById('viewerList');
    viewerList.innerHTML = '';
    
    if (player.liveStream.viewers.length === 0) {
        viewerList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px 0;">暂无观众</div>';
    } else {
        player.liveStream.viewers.forEach(viewer => {
            const viewerElement = document.createElement('div');
            viewerElement.style.marginBottom = '5px';
            viewerElement.style.padding = '5px';
            viewerElement.style.background = '#0a0a1a';
            viewerElement.style.borderRadius = '3px';
            viewerElement.innerHTML = `👤 ${viewer.name}`;
            viewerList.appendChild(viewerElement);
        });
    }
    
    // 更新打赏记录
    const donationHistory = document.getElementById('donationHistory');
    donationHistory.innerHTML = '';
    
    if (player.liveStream.donationHistory.length === 0) {
        donationHistory.innerHTML = '<div style="text-align: center; color: #666; padding: 20px 0;">暂无打赏记录</div>';
    } else {
        // 只显示最近10条记录
        const recentDonations = player.liveStream.donationHistory.slice(-10);
        recentDonations.forEach(donation => {
            const donationElement = document.createElement('div');
            donationElement.style.marginBottom = '5px';
            donationElement.style.padding = '5px';
            donationElement.style.background = '#0a0a1a';
            donationElement.style.borderRadius = '3px';
            donationElement.innerHTML = `🎁 ${donation.viewer} 打赏了 ${donation.amount} 朵玫瑰花 - ${donation.message}`;
            donationHistory.appendChild(donationElement);
        });
    }
    
    // 更新直播状态
    const liveStatus = document.getElementById('liveStatus');
    const startLiveBtn = document.getElementById('startLiveBtn');
    
    if (player.liveStream.isLive) {
        liveStatus.innerHTML = `<div style="font-size: 24px; color: #ff00ff;">直播中</div><div>已直播: ${formatTimew(Date.now() - player.liveStream.lastLiveStart)}</div>`;
        startLiveBtn.textContent = '结束直播';
        startLiveBtn.style.background = '#f44336';
    } else {
        liveStatus.textContent = '直播未开始';
        startLiveBtn.textContent = '开始直播';
        startLiveBtn.style.background = '#ff00ff';
    }
}
function generateAIDanmaku() {
    if (!player.liveStream.isLive || !danmakuSystem.active) {
        liveStreamSystem.danmakuGeneratorActive = false;
        return;
    }
    
const minInterval = 10000 - (danmakuSystem.density * 800);
    const maxInterval = 20000 - (danmakuSystem.density * 1500);
    const interval = Math.random() * (maxInterval - minInterval) + minInterval;
    
    liveStreamSystem.danmakuGeneratorTimer = setTimeout(() => {
        if (player.liveStream.isLive && player.liveStream.viewers.length > 0) {
            const viewerIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
            const viewer = player.liveStream.viewers[viewerIndex];
            const message = liveStreamSystem.aiMessages[Math.floor(Math.random() * liveStreamSystem.aiMessages.length)];
            addDanmakuMessageq(viewer.name, message, "viewer");
            
            // 有小概率打赏
            if (Math.random() < 0.05) {
                generateDonation(viewer);
            }
        }
        
        // 递归调用前检查直播状态
        if (player.liveStream.isLive) {
            generateAIDanmaku();
        } else {
            liveStreamSystem.danmakuGeneratorActive = false;
        }
    }, interval);
}

// 开始直播
function startLiveStream() {
    if (player.liveStream.isLive) {
        stopLiveStream();
        return;
    }
     // 清除可能存在的弹幕生成器
    if (liveStreamSystem.danmakuGeneratorActive) {
        clearDanmakuGenerator();
    }
    player.liveStream.isLive = true;
    player.liveStream.lastLiveStart = Date.now();
    player.liveStream.viewers = [];
     liveStreamSystem.maxViewers = 10 + Math.floor(player.liveStream.level * 5);
    // 添加初始观众
    addViewers(liveStreamSystem.maxViewers*0.86);
     
    // 开始观众和互动定时器
    player.liveStream.viewerInterval = setInterval(updateViewers, 10000); // 每10秒更新观众
    player.liveStream.interactionInterval = setInterval(generateInteractions, 10000); // 每10秒生成互动
   initDanmakuSystem();
 // 启动弹幕生成器（确保只启动一次）
    if (!liveStreamSystem.danmakuGeneratorActive) {
        generateAIDanmaku();
        liveStreamSystem.danmakuGeneratorActive = true;
    }
    updateLiveStreamUI();
    addDanmakuMessageq("系统", "直播开始了！欢迎大家来到直播间！", "system");
    logAction("开始直播", "success");
}

// 停止直播
function stopLiveStream() {
    if (!player.liveStream.isLive) return;
    
    player.liveStream.isLive = false;
    const liveTime = Date.now() - player.liveStream.lastLiveStart;
    player.liveStream.totalLiveTime += liveTime;
    
    // 计算经验
    const expGain = Math.floor(liveTime / 1000) * player.liveStream.expMultiplier;
    player.liveStream.exp += expGain;
     liveStreamSystem.maxViewers = 10 + Math.floor(player.liveStream.level * 5);
    // 检查升级
    checkLiveLevelUp();
    
    // 清除定时器
    clearInterval(player.liveStream.viewerInterval);
    clearInterval(player.liveStream.interactionInterval);
    clearDanmakuGenerator();
    // 清空观众
    player.liveStream.viewers = [];
    clearDanmaku();
    
    updateLiveStreamUI();
    addDanmakuMessageq("系统", "直播已结束，感谢观看！", "system");
    
    logAction(`结束直播，获得 ${expGain} 直播经验`, "success");
    
}
function clearDanmakuGenerator() {
    if (liveStreamSystem.danmakuGeneratorTimer) {
        clearTimeout(liveStreamSystem.danmakuGeneratorTimer);
        liveStreamSystem.danmakuGeneratorTimer = null;
    }
    liveStreamSystem.danmakuGeneratorActive = false;
}


// 推广流量
function boostLiveStream() {
    if (player.nightClub.starCoins < 1000) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 1000;
    player.liveStream.expMultiplier = 2;
    
    // 设置1小时的加速效果
    player.liveStream.boostEndTime = Date.now() + 1 * 60 * 60 * 1000;
    
    // 添加更多观众
    addViewers(liveStreamSystem.maxViewers*0.4);
    
    updateLiveStreamUI();
    addDanmakuMessageq("系统", "主播使用了流量推广，直播间人气上升！", "system");
    
    logAction("使用流量推广，直播经验获取速度提升2倍，持续1小时", "success");
}

// 添加观众
function addViewers(count) {
    if (!player.liveStream.isLive) return;
    
    for (let i = 0; i < count; i++) {
        if (player.liveStream.viewers.length >= liveStreamSystem.maxViewers) break;
        
        const viewerName = liveStreamSystem.aiNames[Math.floor(Math.random() * liveStreamSystem.aiNames.length)];
        player.liveStream.viewers.push({
            id: Date.now() + Math.random(),
            name: viewerName,
            joinTime: Date.now(),
            activity: Math.random() // 活跃度
        });
    }
    
    updateLiveStreamUI();
}

// 更新观众
function updateViewers() {
    if (!player.liveStream.isLive) return;
    
    // 随机有观众离开
    if (player.liveStream.viewers.length > 0 && Math.random() < 0.4) {
        const leaveIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
        const leaveViewer = player.liveStream.viewers[leaveIndex];
        player.liveStream.viewers.splice(leaveIndex, 1);
        
        addDanmakuMessageq("系统", `${leaveViewer.name} 离开了直播间`, "system");
    }
    
    // 随机有新观众加入
    if (player.liveStream.viewers.length < liveStreamSystem.maxViewers && Math.random() < 0.6) {
        addViewers(1);
        const newViewer = player.liveStream.viewers[player.liveStream.viewers.length - 1];
        addDanmakuMessageq("系统", `${newViewer.name} 进入了直播间`, "system");
    }
    
    updateLiveStreamUI();
}

// 生成互动消息
function generateInteractions() {
    if (!player.liveStream.isLive || player.liveStream.viewers.length === 0) return;
    
    // 随机生成1-8条互动消息
    const messageCount = Math.floor(Math.random() * 7) + 1;
    
    for (let i = 0; i < messageCount; i++) {
        const viewerIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
        const viewer = player.liveStream.viewers[viewerIndex];
        
        const message = liveStreamSystem.aiMessages[Math.floor(Math.random() * liveStreamSystem.aiMessages.length)];
        addDanmakuMessageq(viewer.name, message, "viewer");
        
        // 有小概率打赏
        if (Math.random() < 0.05) {
            generateDonation(viewer);
        }
    }
}

// 生成打赏
function generateDonation(viewer) {
    // 打赏金额基于直播等级
    const baseAmount = player.liveStream.level * 1;
    const amount = Math.floor(baseAmount * (1 + Math.random() * 50));
    
    player.items.rose += amount;
    player.liveStream.totalEarnings += amount;
    
    const message = liveStreamSystem.donationMessages[Math.floor(Math.random() * liveStreamSystem.donationMessages.length)];
    
    // 记录打赏
    player.liveStream.donationHistory.push({
        viewer: viewer.name,
        amount: amount,
        message: message,
        time: Date.now()
    });
    
    addDanmakuMessageq("系统", `🎉 ${viewer.name} 打赏了 ${amount} 朵玫瑰花！${message}`, "donation");
    updateLiveStreamUI();
    updateDisplay();
}

// 发送弹幕
function sendDanmaku() {
    const input = document.getElementById('danmakuInput');
    const message = input.value.trim();
    
    if (message === '') return;
    
    addDanmakuMessageq(player.name, message, "player");
    input.value = '';
    
    // 玩家发送消息后，AI观众有概率回应
    if (player.liveStream.viewers.length > 0 && Math.random() < 0.5) {
        setTimeout(() => {
            const viewerIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
            const viewer = player.liveStream.viewers[viewerIndex];
            
            let response;
            if (message.includes('?')) {
                response = "这个问题问得好！";
            } else if (message.includes('谢谢') || message.includes('感谢')) {
                response = "不客气~";
            } else {
                response = "同意主播！" ;
            }
            
            addDanmakuMessageq(viewer.name, response, "viewer");
        }, 1000 + Math.random() * 2000);
    }
}

// 添加弹幕消息
function addDanmakuMessageq(sender, message, type) {
    const container = document.getElementById('danmakuContainerq');
    const messageElement = document.createElement('div');
    messageElement.className = 'danmaku-message';
    
    // 根据消息类型设置样式
    switch(type) {
        case "system":
            messageElement.style.color = '#ff00ff';
            break;
        case "donation":
            messageElement.style.color = '#FFD700';
            messageElement.style.fontWeight = 'bold';
            break;
        case "player":
            messageElement.style.color = '#4CAF50';
            break;
        default:
            messageElement.style.color = '#ccc';
    }
    
    messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
    container.appendChild(messageElement);
      if (player.liveStream.isLive) {
        addDanmakuToScreen(sender, message, type);}
    // 自动滚动到底部
    container.scrollTop = container.scrollHeight;
   
    // 限制消息数量
    if (container.children.length > 30) {
        container.removeChild(container.children[0]);
    }
}

// 检查直播等级提升
function checkLiveLevelUp() {
    const nextLevelExp = liveStreamSystem.expToNextLevel[player.liveStream.level - 1] || 10000000000;
    
    if (player.liveStream.exp >= nextLevelExp) {
        player.liveStream.level++;
        player.liveStream.exp -= nextLevelExp;
        
        // 增加最大观众数
         liveStreamSystem.maxViewers = 10 + Math.floor(player.liveStream.level * 5);
        
        addDanmakuMessageq("系统", `恭喜！直播等级提升到 ${player.liveStream.level} 级！`, "system");
        logAction(`直播等级提升到 ${player.liveStream.level} 级！`, "success");
        
        // 递归检查是否还能升级
        checkLiveLevelUp();
    }
    
    updateLiveStreamUI();
}

// 格式化时间
function formatTimew(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    return `${hours.toString().padStart(2, '0')}:${(minutes % 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
}

// 在游戏主循环中更新直播经验
function updateLiveStreamExperience() {
    if (player.liveStream && player.liveStream.isLive) {
        const now = Date.now();
        const elapsed = now - player.liveStream.lastUpdate;
        player.liveStream.lastUpdate = now;
        
        // 检查加速是否结束
        if (player.liveStream.boostEndTime && now > player.liveStream.boostEndTime) {
            player.liveStream.expMultiplier = 1;
            player.liveStream.boostEndTime = null;
            addDanmakuMessageq("系统", "流量推广效果已结束", "system");
        }
        
        // 每秒获得1点经验乘以倍率
        const expGain = (elapsed / 1000) * player.liveStream.expMultiplier;
        player.liveStream.exp += expGain;
        
        // 检查升级
        checkLiveLevelUp();
        
        // 更新UI
        updateLiveStreamUI();
    }
}

// 礼物数据
const giftBoxSystem = {
    gifts: [
        { name: "鲜花", value: 10000, probability: 70, icon: "💐", color: "#4CAF50" },
        { name: "墨镜", value: 25000, probability: 19.889, icon: "🕶️", color: "#2196F3" },
        { name: "礼花筒", value: 50000, probability: 7, icon: "🎆", color: "#FFC107" },
        { name: "比心兔兔", value: 100000, probability: 3, icon: "🐰💖", color: "#E91E63" },
        { name: "热气球", value: 520000, probability: 0.1, icon: "🎈", color: "#9C27B0" },
        { name: "跑车", value: 1200000, probability: 0.01, icon: "🏎️", color: "#FF5722" },
        { name: "嘉年华", value: 2800000, probability: 0.001, icon: "🎪", color: "#00BCD4" }
    ],
    drawCost: 50
};

// 打开盲盒宝箱界面
function openGiftBox() {
    document.getElementById('giftBoxModal').style.display = 'flex';
    resetGiftBox();
}

// 关闭盲盒宝箱界面
function closeGiftBox() {
    document.getElementById('giftBoxModal').style.display = 'none';
}

// 重置盲盒显示
function resetGiftBox() {
    const boxInner = document.getElementById('boxInner');
    boxInner.style.transform = 'rotateY(0deg)';
    
    document.getElementById('giftIcon').textContent = '🎁';
    document.getElementById('giftName').textContent = '未知礼物';
    document.getElementById('giftValue').textContent = '价值: 0 玫瑰花';
}

// 抽取礼物
function drawGift() {
    if (player.nightClub.starCoins < 500) {
        logAction("星币不足！", "error");
        return;
    }
    
    // 扣除星币
    player.nightClub.starCoins -= 500;
   
    
    // 计算总概率
    const totalProbability = giftBoxSystem.gifts.reduce((sum, gift) => sum + gift.probability, 0);
    
    // 生成随机数
    const random = Math.random() * totalProbability;
    
    // 确定获得的礼物
    let cumulative = 0;
    let selectedGift = null;
    
    for (const gift of giftBoxSystem.gifts) {
        cumulative += gift.probability;
        if (random <= cumulative) {
            selectedGift = gift;
            break;
        }
    }
    
    // 如果没有选中礼物（理论上不会发生），默认给鲜花
    if (!selectedGift) {
        selectedGift = giftBoxSystem.gifts[0];
    }
    
    // 更新直播总收益
    player.liveStream.totalEarnings += selectedGift.value;
    
    // 记录打赏
    player.liveStream.donationHistory.push({
        viewer: "主播自己",
        amount: selectedGift.value,
        message: `获得${selectedGift.name}`,
        time: Date.now()
    });
    
    // 显示礼物结果
    showGiftResult(selectedGift);
    
    // 添加弹幕消息
    addDanmakuMessageq("系统", `恭喜主播从盲盒中，抽到了${selectedGift.name}`, "system");
    
    // 更新UI
    updateLiveStreamUI();
    updateDisplay();
    
    logAction(`开启盲盒获得${selectedGift.name}，价值${selectedGift.value}朵玫瑰花`, "success");
}

// 显示礼物结果
function showGiftResult(gift) {
    const boxInner = document.getElementById('boxInner');
    const giftIcon = document.getElementById('giftIcon');
    const giftName = document.getElementById('giftName');
    const giftValue = document.getElementById('giftValue');
    
    // 更新礼物信息
    giftIcon.textContent = gift.icon;
    giftName.textContent = gift.name;
    giftName.style.color = gift.color;
    giftValue.textContent = `价值: ${gift.value.toLocaleString()} 玫瑰花`;
    
    // 添加动画效果
    boxInner.style.transform = 'rotateY(180deg)';
    
    // 添加粒子效果
    createParticles();
}

// 创建粒子效果
function createParticles() {
    const giftBox = document.getElementById('giftBox');
    const colors = ['#ff9966', '#ff5e62', '#ffcc00', '#4CAF50', '#2196F3'];
    
    for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = '8px';
        particle.style.height = '8px';
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        particle.style.borderRadius = '50%';
        particle.style.zIndex = '10';
        
        // 随机位置
        const posX = Math.random() * 200;
        const posY = Math.random() * 200;
        particle.style.left = `${posX}px`;
        particle.style.top = `${posY}px`;
        
        giftBox.appendChild(particle);
        
        // 动画效果
        const angle = Math.random() * Math.PI * 2;
        const distance = 100 + Math.random() * 100;
        const duration = 1000 + Math.random() * 500;
        
        particle.animate(
            [
                { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`, opacity: 0 }
            ],
            {
                duration: duration,
                easing: 'ease-out'
            }
        ).onfinish = () => {
            particle.remove();
        };
    }
}



const worldZones = [
    {
        id: 'beginner',
        name: '新手村',
        minLevel: 1,
        maxLevel: 49,
        expRange: [1, 10],
        monsterNames: ['小妖', '小怪', '小兽', '小魔', '小精', '小灵', '小魂', '小魄'],
        modifiers: [
            { name: '普通', health: 1.0, attack: 2.0 },
            { name: '强壮', health: 1.5, attack: 3.2 },
            { name: '野蛮', health: 2.2, attack: 2.5 },
            { name: '弱小', health: 0.5, attack: 0.2 },
            { name: '强大', health: 5.2, attack: 5.5 },
            { name: '影子', health: 3.5, attack: 2.2 },
            { name: '敏捷', health: 2.2, attack: 10.5 },
            { name: '狂暴', health: 1.3, attack: 11.8 }
        ]
    },
    {
        id: 'forest',
        name: '落木林',
        minLevel: 50,
        maxLevel: 99,
        expRange: [10, 25],
        monsterNames: ['树妖', '木精', '叶魔', '根魂', '枝魄', '森灵', '林怪', '藤妖'],
        modifiers: [
            { name: '剧毒', health: 3.2, attack: 1.8 },
            { name: '缠绕', health: 5.8, attack: 31.2 },
            { name: '吸血', health: 7.5, attack: 5.5 },
            { name: '邪恶', health: 23.8, attack: 3.2 },
            { name: '幽魂', health: 6.5, attack: 7.5 },
            { name: '火焰', health: 7.8, attack: 8.2 },
            { name: '冰霜', health: 9.5, attack: 13.5 },   
            { name: '雷霆', health: 10.8, attack: 23.2 },
            { name: '闪电', health: 5.5, attack: 5.5 },
            { name: '再生', health: 7.0, attack: 1.0 }
            
        ]
    },
    {
        id: 'plains',
        name: '青风平原',
        minLevel: 100,
        maxLevel: 149,
        expRange: [25, 50],
        monsterNames: ['风灵', '草妖', '石魔', '土魂', '沙魄', '云精', '雾怪', '雨灵'],
        modifiers: [
            { name: '疾风', health: 21.0, attack: 12.0 },
            { name: '厚土', health: 12.0, attack: 13.0 },
            { name: '飞沙', health: 11.5, attack: 15.8 },
            { name: '风暴', health: 21.0, attack: 18.0 },
            { name: '流沙', health: 12.0, attack: 11.0 },
            { name: '魅影', health: 21.5, attack: 21.8 },
            { name: '龙卷风', health: 21.0, attack: 32.0 },
            { name: '法师', health: 12.0, attack: 41.0 },
            { name: '刺客', health: 12.5, attack: 51.8 },
            { name: '迷雾', health: 15.8, attack: 21.5 }

        ]
    },
    {
        id: 'swamp',
        name: '迷雾沼泽',
        minLevel: 150,
        maxLevel: 199,
        expRange: [50, 100],
        monsterNames: ['沼魔', '泥妖', '水精', '雾魂', '毒魄', '瘴灵', '腐怪', '湿妖'],
        modifiers: [
            { name: '剧毒', health: 10.5, attack: 20.0 },
            { name: '腐蚀', health: 20.0, attack: 10.8 },
            { name: '减速', health: 104.8, attack: 10.5 },
            { name: '灼烧', health: 10.5, attack: 70.0 },
            { name: '冰冻', health: 20.0, attack: 80.8 },
            { name: '野蛮', health: 100.8, attack: 380.5 },
            { name: '毒粉', health: 10.5, attack: 250.0 },
            { name: '妖化', health: 20.0, attack: 140.8 },
            { name: '电王', health: 140.8, attack: 130.5 },
            { name: '致盲', health: 100.5, attack: 200.2 }
        ]
    },
    {
        id: 'nest',
        name: '剧毒巢穴',
        minLevel: 200,
        maxLevel: 249,
        expRange: [100, 250],
        monsterNames: ['毒蛛', '蝎魔', '蛇妖', '蜈蚣精', '蟾蜍怪', '蜂后', '蚁王', '蝇魔'],
        modifiers: [
            { name: '致命毒液', health: 10.8, attack: 52.5 },
            { name: '麻痹毒素', health: 280.0, attack: 172.0 },
            { name: '神经毒素', health: 180.5, attack: 113.0 },
            { name: '灵魂毒液', health: 30.8, attack: 412.5 },
            { name: '肉体毒素', health: 280.0, attack: 221.0 },
            { name: '轻微毒素', health: 20.5, attack: 433.0 },
            { name: '智障毒液', health: 10.8, attack: 302.5 },
            { name: '雷雨毒素', health: 23.0, attack: 602.0 },
            { name: '闪电毒素', health: 101.5, attack: 333.0 },
            { name: '腐蚀酸液', health: 87.5, attack: 702.2 }
        ]
    },
    {
        id: 'wetland',
        name: '浅滩湿地',
        minLevel: 250,
        maxLevel: 299,
        expRange: [250, 500],
        monsterNames: ['水妖', '泽魔', '滩魂', '湿魄', '藻精', '贝怪', '蟹灵', '虾妖'],
        modifiers: [
            { name: '水之护盾', health: 32.0, attack: 12.5 },
            { name: '潮汐之力', health: 11.8, attack: 52.8 },
            { name: '深海恐惧', health: 21.5, attack: 23.5 },
            { name: '水之战舰', health: 341.0, attack: 123.5 },
            { name: '潮汐冰箭', health: 11.8, attack: 312.8 },
            { name: '深海咆哮', health: 21.5, attack: 232.5 },
            { name: '水王', health: 53.0, attack: 791.5 },
            { name: '水皇', health: 551.8, attack: 552.8 },
            { name: '水尊', health: 288.5, attack: 882.5 },
            { name: '漩涡牵引', health: 26.0, attack: 356.0 }
        ]
    },
    {
        id: 'canyon',
        name: '黑风峡谷',
        minLevel: 300,
        maxLevel: 349,
        expRange: [500, 1000],
        monsterNames: ['岩魔', '石怪', '山精', '谷魂', '崖魄', '壁妖', '穴灵', '洞魔'],
        modifiers: [
            { name: '岩甲', health: 40.0, attack: 100.8 },
            { name: '落石', health: 20.5, attack: 300.0 },
            { name: '地震', health: 30.5, attack: 200.8 },
            { name: '石小妖', health: 2.0, attack: 10.8 },
            { name: '石头怪', health: 20.5, attack: 30.0 },
            { name: '石帝', health: 30.5, attack: 310.8 },
            { name: '石妖', health: 100.0, attack: 120.8 },
            { name: '石王', health: 20.5, attack: 300.0 },
            { name: '石皇', health: 200.5, attack: 200.8 },
            { name: '山崩', health: 200.0, attack: 300.5 }
        ]
    },
    {
        id: 'swamp2',
        name: '迷雾沼泽深处',
        minLevel: 350,
        maxLevel: 399,
        expRange: [1000, 2500],
        monsterNames: ['沼王', '泥后', '水帝', '雾皇', '毒尊', '瘴圣', '腐神', '湿魔'],
        modifiers: [
            { name: '剧毒领域', health: 100.0, attack: 400.0 },
            { name: '腐蚀领域', health: 20.0, attack: 300.5 },
            { name: '迷雾领域', health: 30.5, attack: 200.5 },
            { name: '氧化领域', health: 30.0, attack: 400.0 },
            { name: '腐闪领域', health: 40.0, attack: 300.5 },
            { name: '蜂石领域', health: 30.5, attack: 800.5 },
            { name: '恶徒领域', health: 30.0, attack: 400.0 },
            { name: '螣神领域', health: 40.0, attack: 100.5 },
            { name: '山峰领域', health: 30.5, attack: 300.5 },
            { name: '死亡领域', health: 100.0, attack: 500.0 }
        ]
    },
    {
        id: 'abyss',
        name: '暗影深渊',
        minLevel: 400,
        maxLevel: 449,
        expRange: [2500, 5000],
        monsterNames: ['影魔', '暗妖', '渊魂', '冥魄', '夜精', '幽怪', '鬼灵', '魅魔'],
        modifiers: [
            { name: '暗影突袭', health: 30.5, attack: 700.0 },
            { name: '深渊凝视', health: 150.0, attack: 310.0 },
            { name: '虚空吞噬', health: 140.5, attack: 450.8 },
            { name: '时间回溯', health: 230.5, attack: 500.0 },
            { name: '精神屏障', health: 50.0, attack: 300.0 },
            { name: '晶体穿刺', health: 210.5, attack: 100.8 },
            { name: '空间封锁', health: 100.5, attack: 200.0 },
            { name: '声波共振', health: 50.0, attack: 200.0 },
            { name: '精神链接', health: 30.5, attack: 400.8 },
            { name: '永夜降临', health: 200.0, attack: 600.0 }
        ]
    },
    {
        id: 'rift',
        name: '混沌之隙',
        minLevel: 450,
        maxLevel: 499,
        expRange: [5000, 10000],
        monsterNames: ['混沌兽', '无序魔', '混乱妖', '虚空精', '扭曲魂', '裂痕魄', '次元怪', '位面灵'],
        modifiers: [
            { name: '混沌护盾', health: 80.0, attack: 500.0 },
            { name: '空间撕裂', health: 50.5, attack: 800.0 },
            { name: '时间扭曲', health: 70.0, attack: 700.0 },
            { name: '时间停滞', health: 200.0, attack: 500.0 },
            { name: '空间暗影', health: 100.5, attack: 100.0 },
            { name: '时间风暴', health: 70.0, attack: 200.0 },
            { name: '维度停滞', health: 20.0, attack: 500.0 },
            { name: '暗影风暴', health: 200.5, attack: 200.0 },
            { name: '混沌风暴', health: 70.0, attack: 700.0 },
            { name: '位面崩塌', health: 100.0, attack: 100.0 }
        ]
    },
    {
        id: 'battlefield',
        name: '血狱战场',
        minLevel: 500,
        maxLevel: 549,
        expRange: [10000, 15000],
        monsterNames: ['血魔', '狱妖', '战魂', '争魄', '杀精', '戮怪', '伐灵', '征魔'],
        modifiers: [
            { name: '嗜血', health: 400.0, attack: 1000.0 },
            { name: '狂战', health: 80.0, attack: 800.0 },
            { name: '不屈', health: 10.0, attack: 500.0 },
            { name: '血族', health: 300.0, attack: 1000.0 },
            { name: '狂战族', health: 50.0, attack: 300.0 },
            { name: '不屈族', health: 150.0, attack: 200.0 },
            { name: '嗜血族', health: 600.0, attack: 1000.0 },
            { name: '狂战血脉', health: 500.0, attack: 180.0 },
            { name: '不屈血脉', health: 150.0, attack: 150.0 },
            { name: '死战', health: 530.0, attack: 1500.0 }
        ]
    },
    {
        id: 'lair',
        name: '恶魔巢穴',
        minLevel: 550,
        maxLevel: 599,
        expRange: [15000, 25000],
        monsterNames: ['恶魔领主', '深渊魔王', '地狱公爵', '炼狱侯爵', '邪能伯爵', '堕落子爵', '腐化男爵', '扭曲骑士'],
        modifiers: [
            { name: '恶魔之怒', health: 100.0, attack: 350.0 },
            { name: '深渊之力', health: 20.0, attack: 820.0 },
            { name: '炼狱之力', health: 120.0, attack: 1800.0 },
            { name: '恶魔之力', health: 130.0, attack: 150.0 },
            { name: '夜魔之力', health: 30.0, attack: 120.0 },
            { name: '地狱之力', health: 120.0, attack: 1800.0 },
            { name: '魔神之力', health: 10.0, attack: 1500.0 },
            { name: '深渊核心', health: 110.0, attack: 1200.0 },
            { name: '地火核心', health: 120.0, attack: 180.0 },
            { name: '邪能腐蚀', health: 480.0, attack: 3800.0 }
        ]
    },
    {
        id: 'throne',
        name: '冰封王座',
        minLevel: 600,
        maxLevel: 649,
        expRange: [25000, 50000],
        monsterNames: ['冰霜巨龙', '寒冰巫妖', '极地巨人', '雪域女王', '冰川领主', '冻土之王', '永冬守卫', '霜寒使者'],
        modifiers: [
            { name: '绝对零度', health: 20.0, attack: 120.0 },
            { name: '冰封领域', health: 100.0, attack: 700.0 },
            { name: '霜冻新星', health: 20.0, attack: 130.0 },
            { name: '零度之力', health: 20.0, attack: 480.0 },
            { name: '封神领域', health: 320.0, attack: 1000.0 },
            { name: '霜冻之力', health: 10.0, attack: 80.0 },
            { name: '霜寒死神', health: 200.0, attack: 320.0 },
            { name: '冰封之力', health: 30.0, attack: 220.0 },
            { name: '灵魂深王', health: 250.0, attack: 1320.0 },
            { name: '寒冰牢笼', health: 550.0, attack: 4500.0 }
        ]
    },
    {
        id: 'wasteland',
        name: '血月荒原',
        minLevel: 650,
        maxLevel: 699,
        expRange: [50000, 100000],
        monsterNames: ['血月狼王', '赤红巨蝎', '绯色狮鹫', '猩红飞龙', '朱红泰坦', '深红梦魇', '鲜红收割者', '暗红破坏神'],
        modifiers: [
            { name: '血月之力', health: 400.0, attack: 500.0 },
            { name: '猩红狂暴', health: 90.0, attack: 720.0 },
            { name: '赤红领域', health: 300.0, attack: 440.0 },
            { name: '血月暗魔', health: 400.0, attack: 200.0 },
            { name: '猩红之力', health: 70.0, attack: 3100.0 },
            { name: '血族领域', health: 61.0, attack: 1400.0 },
            { name: '血月战刃', health: 30.0, attack: 2500.0 },
            { name: '收割者领域', health: 40.0, attack: 500.0 },
            { name: '梦魇领域', health: 69.0, attack: 4100.0 },
            { name: '深红诅咒', health: 390.0, attack: 6000.0 }
        ]
    },
    {
        id: 'ruins',
        name: '时空废墟',
        minLevel: 700,
        maxLevel: 749,
        expRange: [100000, 500000],
        monsterNames: ['时空守护者', '裂隙观察者', '维度旅行者', '位面穿梭者', '虚空漫步者', '次元监察者', '宇宙编织者', '现实扭曲者'],
        modifiers: [
            { name: '时间加速', health: 20.0, attack: 800.0 },
            { name: '空间折叠', health: 280.0, attack: 700.0 },
            { name: '维度撕裂', health: 190.0, attack: 400.0 },
            { name: '量子隐身', health: 70.0, attack: 8100.0 },
            { name: '时间碎片', health: 380.0, attack: 2300.0 },
            { name: '维度错位', health: 90.0, attack: 1800.0 },
            { name: '中子星脉冲', health: 70.0, attack: 2000.0 },
            { name: '时间分流', health: 80.0, attack: 3000.0 },
            { name: '超声波攻击', health: 400.0, attack: 5000.0 },
            { name: '现实重构', health: 600.0, attack: 10000.0 }
        ]
    },
    {
        id: 'land',
        name: '星陨之地',
        minLevel: 750,
        maxLevel: 799,
        expRange: [500000, 1000000],
        monsterNames: ['星陨巨兽', '陨石领主', '彗星使者', '流星猎人', '行星吞噬者', '恒星毁灭者', '星系守护者', '宇宙创造者'],
        modifiers: [
            { name: '星辰坠落', health: 150.0, attack: 580.0 },
            { name: '黑洞吞噬', health: 20.0, attack: 2500.0 },
            { name: '超新星爆发', health: 180.0, attack: 5300.0 },
            { name: '星辰碰撞', health: 150.0, attack: 7010.0 },
            { name: '流星吞噬', health: 200.0, attack: 1500.0 },
            { name: '毁灭爆发', health: 18.0, attack: 3000.0 },
            { name: '星辰爆炸', health: 150.0, attack: 8000.0 },
            { name: '银河吞噬', health: 200.0, attack: 4500.0 },
            { name: '超新爆风', health: 180.0, attack: 22000.0 },
            { name: '宇宙大爆炸', health: 700.0, attack: 30000.0 }
        ]
    },
    {
        id: 'temple',
        name: '永恒圣殿',
        minLevel: 800,
        maxLevel: 849,
        expRange: [1000000, 5000000],
        monsterNames: ['圣殿守卫', '永恒骑士', '不朽祭司', '神圣主教', '天界大天使', '神域审判者', '至高仲裁者', '创世神使'],
        modifiers: [
            { name: '神圣庇护', health: 50.0, attack: 1000.0 },
            { name: '永恒之光', health: 140.0, attack: 3010.0 },
            { name: '神之裁决', health: 310.0, attack: 15100.0 },
            { name: '神圣打击', health: 520.0, attack: 30120.0 },
            { name: '神圣之光', health: 240.0, attack: 6020.0 },
            { name: '神之神剑', health: 600.0, attack: 5100.0 },
            { name: '神圣护盾', health: 450.0, attack: 44000.0 },
            { name: '神王护体', health: 240.0, attack: 36000.0 },
            { name: '神尊破灭', health: 160.0, attack: 25200.0 },
            { name: '创世之力', health: 1000.0, attack: 80000.0 }
        ]
    },
    {
        id: 'realm',
        name: '万象界域',
        minLevel: 850,
        maxLevel: 899,
        expRange: [5000000, 10000000],
        monsterNames: ['万象之主', '元素皇帝', '法则掌控者', '秩序守护神', '混沌化身', '虚空君主', '位面主宰', '多元宇宙观察者'],
        modifiers: [
            { name: '元素风暴', health: 130.0, attack: 4200.0 },
            { name: '法则扭曲', health: 750.0, attack: 8000.0 },
            { name: '秩序崩坏', health: 420.0, attack: 6500.0 },
            { name: '元素至尊', health: 300.0, attack: 9200.0 },
            { name: '法则至尊', health: 280.0, attack: 10000.0 },
            { name: '秩序至尊', health: 240.0, attack: 25000.0 },
            { name: '万象至尊', health: 400.0, attack: 32000.0 },
            { name: '混沌至尊', health: 430.0, attack: 40000.0 },
            { name: '位面至尊', health: 320.0, attack: 75000.0 },
            { name: '混沌初开', health: 1000.0, attack: 100000.0 }
        ]
    },
    {
        id: 'realm2',
        name: '鸿蒙秘境',
        minLevel: 900,
        maxLevel: 949,
        expRange: [10000000, 50000000],
        monsterNames: ['鸿蒙巨兽', '太初古神', '元始天尊', '造化之主', '命运编织者', '因果律者', '真理守护者', '终极观察者'],
        modifiers: [
            { name: '鸿蒙初开', health: 500.0, attack: 110000.0 },
            { name: '太初之力', health: 700.0, attack: 240000.0 },
            { name: '造化神功', health: 200.0, attack: 110000.0 },
            { name: '鸿蒙尊者', health: 100.0, attack: 205000.0 },
            { name: '太初尊者', health: 700.0, attack: 302000.0 },
            { name: '未来尊者', health: 80.0, attack: 400100.0 },
            { name: '命运尊者', health: 200.0, attack: 600000.0 },
            { name: '太古尊者', health: 70.0, attack: 300000.0 },
            { name: '九亥古神', health: 200.0, attack: 700000.0 },
            { name: '终极真理', health: 1000.0, attack: 1000000.0 }
        ]
    },
    {
        id: 'domain',
        name: '终焉神域',
        minLevel: 950,
        maxLevel: 1000,
        expRange: [50000000, 100000000],
        monsterNames: ['终焉之主', '灭世魔神', '创世之神', '永恒终结者', '无限吞噬者', '绝对虚无', '最终答案', '一切之终'],
        modifiers: [
            { name: '终焉降临', health: 20.0, attack: 500000.0 },
            { name: '灭世之力', health: 80.0, attack: 1200000.0 },
            { name: '创世之力', health: 20.0, attack: 800000.0 },
            { name: '终焉之力', health: 240.0, attack: 2700000.0 },
            { name: '永恒之力', health: 310.0, attack: 1200000.0 },
            { name: '无限之力', health: 120.0, attack: 600000.0 },
            { name: '绝对之力', health: 300.0, attack: 2400000.0 },
            { name: '灭世之力', health: 700.0, attack: 420000.0 },
            { name: '灰烬之力', health: 550.0, attack: 2010000.0 },
            { name: '绝对虚无', health: 1000.0, attack: 5000000.0 }
        ]
    }
];
// 切换世界地图界面
function toggleWorldMap() {
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启世界地图！");
        return;
    }
    const overlay = document.getElementById('worldMapOverlay');
    const ui = document.getElementById('worldMapUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateWorldMapUI();
    }
}

// 更新世界地图界面
function updateWorldMapUI() {
    const container = document.getElementById('zoneList');
    container.innerHTML = '';
    
    worldZones.forEach(zone => {
        const zoneElement = document.createElement('div');
        zoneElement.style.background = '#333';
        zoneElement.style.padding = '15px';
        zoneElement.style.borderRadius = '8px';
        zoneElement.style.textAlign = 'center';
        zoneElement.style.cursor = 'pointer';
        
        zoneElement.innerHTML = `
            <h3>${zone.name}</h3>
            <div>等级: ${zone.minLevel}-${zone.maxLevel}</div>
            <div>经验: ${zone.expRange[0]}-${zone.expRange[1]}*VIP</div>
        `;
        
        zoneElement.onclick = () => startBattleInZone(zone);
        container.appendChild(zoneElement);
    });
}

// 在指定区域开始战斗
function startBattleInZone(zone) {
  
    if (player.nightClub.starCoins < 1) {
        logAction("星币不足，无法生成怪物！", "error");
        toggleWorldMap(); // 关闭世界地图界面
        return;
    }
    
    
    player.nightClub.starCoins--;
    logAction("消耗1个星币生成怪物", "info");
    player.battle.currentZone = zone;
    
    // 生成怪物（复制打怪模式中的怪物属性）
    generateMonsterForZone(zone);
    
    // 初始化战斗状态
    player.battle.monsterResurrections = 0;
    
    // 显示战斗界面
    document.getElementById('worldMapUI').style.display = 'none';
    document.getElementById('worldMapOverlay').style.display = 'none';
    
    document.getElementById('battleUI').style.display = 'block';
    document.getElementById('battleOverlay').style.display = 'block';
    
    updateBattleUI();
}

// 为区域生成怪物
function generateMonsterForZone(zone) {
    // 随机选择怪物名字
    const name = zone.monsterNames[Math.floor(Math.random() * zone.monsterNames.length)];
    
    // 随机选择词条
    const modifier = zone.modifiers[Math.floor(Math.random() * zone.modifiers.length)];
    
    // 计算基础属性
    const stage = Math.floor((zone.minLevel + zone.maxLevel) / 2);
    const healthMultiplier = Math.pow(2, stage);
    const attackMultiplier = calculateAttackMultiplier(stage);
    
    // 应用词条加成
    const health = 10000 * healthMultiplier * modifier.health;
    const attack = attackMultiplier * modifier.attack;
    
    player.battle.currentMonster = {
        name: `${name}`,
        rank: modifier.name,
        health: health,
        maxHealth: health,
        attack: attack,
        resurrections: 0,
        modifier: modifier
    };
}

// 计算攻击乘数
function calculateAttackMultiplier(stage) {
    if (stage <= 5) return Math.floor(Math.random() * 3) + 1;
    if (stage <= 25) return 100 + (stage - 4) * 10;
    if (stage <= 50) return 1000 + (stage - 24) * 100;
    if (stage <= 100) return 5000 + (stage - 49) * 500;
    if (stage <= 150) return 50000 + (stage - 99) * 1000;
    if (stage <= 200) return 10000 + (stage - 149) * 10000;
    if (stage <= 250) return 500000 + (stage - 199) * 100000;
    if (stage <= 300) return 5000000 + (stage - 249) * 1000000;
    if (stage <= 350) return 10000000 + (stage - 299) * 100000000;
    if (stage <= 400) return 100000000 + (stage - 349) * 1000000000;
    if (stage <= 450) return 1000000000 + (stage - 399) * 100000000000;
    if (stage <= 500) return 10000000000 + (stage - 349) * 100000000000000;
    if (stage <= 550) return 100000000000 + (stage - 499) * 10000000000000000;
    if (stage <= 600) return 1000000000000 + (stage - 549) * 1000000000000000000;
    if (stage <= 650) return 10000000000000 + (stage - 599) * 1000000000000000000000;
    if (stage <= 700) return 100000000000000 + (stage - 649) * 1000000000000000000000000;
    if (stage <= 750) return 1000009000000000 + (stage - 699) * 10000000000000000000000000000;
    if (stage <= 800) return 10000000000000900 + (stage - 749) * 1000000000000000000000000000000000;
    if (stage <= 850) return 100000000000000900 + (stage - 799) * 10000000000000000000000000000000000000000;
    if (stage <= 900) return 10000000000000000900 + (stage - 849) * 10000000000000000000000000000000000000000000000;
    if (stage <= 950) return 6500000000000000000900 + (stage - 899) * 1000000000000000000000000000000000000000000000000000000;    
    return 650000000000000000000000000000000900 + (stage - 949) * 100000000000000000000000000000000000000000000000000000000000000;
}

// 更新战斗界面
function updateBattleUI() {
    // 玩家属性
    document.getElementById('battlePlayerHealth').textContent = player.battle.playerHealth.toExponential(3);
    document.getElementById('battlePlayerAttack').textContent = player.battle.playerAttack.toExponential(3);
    document.getElementById('battlePlayerCritRate').textContent = (player.battle.playerCritRate * 100).toFixed(2) + '%';
    document.getElementById('battlePlayerCritDamage').textContent = (player.battle.playerCritDamage * 100).toExponential(3) + '%';
    document.getElementById('battleRebornDanCount').textContent = (player.nightClub.starCoins || 0).toFixed(1);

    
    // 怪物属性
    const monster = player.battle.currentMonster;
    document.getElementById('battleMonsterName').textContent = monster.name;
    document.getElementById('battleMonsterHealth').textContent = formatNumber(monster.health);
    document.getElementById('battleMonsterMaxHealth').textContent = formatNumber(monster.maxHealth);
    document.getElementById('battleMonsterAttack').textContent = formatNumber(monster.attack);
    document.getElementById('battleMonsterModifier').textContent = ` ${monster.rank}`;
   document.getElementById('battleMonsterResurrections').textContent = player.battle.monsterResurrections;
}

// 切换自动战斗
function toggleWorldMapAutoBattle() {
    player.worldMapBattle.autoBattle = !player.worldMapBattle.autoBattle;
    document.getElementById('worldMapAutoBattleStatus').textContent = 
        player.worldMapBattle.autoBattle ? '开启' : '关闭';
    
    if (player.worldMapBattle.autoBattle) {
        // 开始自动战斗
        player.worldMapBattle.autoBattleInterval = setInterval(worldMapAttackMonster, 500);
        
        // 如果关闭界面，启动后台战斗
        player.backgroundBattle.active = true;
    } else {
        // 停止自动战斗
        clearInterval(player.worldMapBattle.autoBattleInterval);
        player.backgroundBattle.active = false;
    }
}

// 攻击怪物
function worldMapAttackMonster() {
    const playerAttack = player.battle.playerAttack;
    const monster = player.battle.currentMonster;
    
    // 计算伤害（考虑暴击）
    let isCrit = Math.random() < player.battle.playerCritRate;
    let damage = isCrit ? playerAttack * player.battle.playerCritDamage : playerAttack;
    
    // 应用伤害
    monster.health -= damage;
    
    // 记录战斗日志
    addBattleLog(`你对${monster.name}造成了${damage.toExponential(2)}点${isCrit ? '暴击 ' : ''}伤害`);
    
    // 检查怪物是否死亡
    if (monster.health <= 0) {
        handleMonsterDefeated();
    } else {
        // 怪物反击
        monsterCounterAttack();
    }
    
    updateBattleUI();
}

// 怪物反击
function monsterCounterAttack() {
    const monster = player.battle.currentMonster;
    const damage = monster.attack;
    
    // 应用伤害
    player.battle.playerHealth -= damage;
    
    // 记录战斗日志
    addBattleLog(`${monster.name}对你造成了${damage.toExponential(2)}点伤害`);
    
    // 检查玩家是否死亡
    if (player.battle.playerHealth <= 0) {
        addBattleLog('你被怪物击败了！');
        closeBattle();
     updatePlayerBattleStats();
    }
    
    updateBattleUI();
}

// 处理怪物被击败
function handleMonsterDefeated() {
    const monster = player.battle.currentMonster;
    const zone = player.battle.currentZone;
    
    // 增加复活次数
    player.battle.monsterResurrections++;
    
    if (player.battle.monsterResurrections < 5) {
        // 怪物复活（属性增强）
        monster.health = monster.maxHealth * Math.pow(2, player.battle.monsterResurrections);
        monster.attack *= 1.5;
        
        addBattleLog(`${monster.name}复活了！(第${player.battle.monsterResurrections}次)`);
     monsterCounterAttack();
    } else {
        // 怪物真正死亡
        addBattleLog(`你击败了${monster.name}！`);
        
        // 计算经验奖励
        const expMin = zone.expRange[0];
        const expMax = zone.expRange[1];
        const exp = Math.floor(Math.random() * (expMax - expMin + 1)) + expMin;
        const finalExp = exp * player.vip.level;
        
        // 添加经验
        addPlayerExp(finalExp);
        addBattleLog(`获得${finalExp.toLocaleString()}经验！`);
  
        if (player.nightClub.starCoins < 1) {
            addBattleLog("星币不足，无法生成新怪物！");
            closeBattle();
            return;
        }
        
        
        player.nightClub.starCoins--;
        addBattleLog("消耗1个星币生成新怪物");
        updateItemDisplay();
  
        
        // 生成新怪物
        generateMonsterForZone(zone);
        player.battle.monsterResurrections = 0;
      updatePlayerBattleStats();
    }
    
    updateBattleUI();
          updateLevelUI();
    updateDisplay();
}

// 添加战斗日志
function addBattleLog(message) {
    const logContainer = document.getElementById('addbattleLog');
    const logElement = document.createElement('div');
    logElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    
    // 添加到日志容器
    logContainer.appendChild(logElement);
    
    // 限制最多10条日志
    if (logContainer.children.length > 10) {
        logContainer.removeChild(logContainer.firstChild);
    }
    
    // 滚动到底部
    logContainer.scrollTop = logContainer.scrollHeight;
}

// 关闭战斗
function closeBattle() {
    // 停止自动战斗
    if (player.worldMapBattle.autoBattle) {
        clearInterval(player.worldMapBattle.autoBattleInterval);
        player.worldMapBattle.autoBattle = false;
        document.getElementById('worldMapAutoBattleStatus').textContent = '关闭';
    }
    
    // 关闭界面
    document.getElementById('battleUI').style.display = 'none';
    document.getElementById('battleOverlay').style.display = 'none';
    
    // 如果自动战斗开启，启动后台战斗
    if (player.backgroundBattle.active) {
        startBackgroundBattle();
    }
}
function startBackgroundBattle() {
    // 清除之前的后台战斗
    if (player.backgroundBattle.interval) {
        clearInterval(player.backgroundBattle.interval);
    }
    
    // 每秒钟执行一次后台战斗
    player.backgroundBattle.interval = setInterval(() => {
        if (player.nightClub.starCoins < 1) {
            stopBackgroundBattle();
            logAction("星币不足，后台自动战斗已停止", "warning");
            return;
        }
        
        // 执行一次攻击
        backgroundWorldMapAttackMonster();
    }, 500);
}
function backgroundWorldMapAttackMonster() {
    const playerAttack = player.battle.playerAttack;
    const monster = player.battle.currentMonster;
    
    // 计算伤害（考虑暴击）
    let isCrit = Math.random() < player.battle.playerCritRate;
    let damage = isCrit ? playerAttack * player.battle.playerCritDamage : playerAttack;
    
    // 应用伤害
    monster.health -= damage;
    
    // 检查怪物是否死亡
    if (monster.health <= 0) {
        backgroundHandleMonsterDefeated();
    } else {
        // 怪物反击
        backgroundMonsterCounterAttack();
    }
}

// 后台怪物反击
function backgroundMonsterCounterAttack() {
    const monster = player.battle.currentMonster;
    const damage = monster.attack;
    
    // 应用伤害
    player.battle.playerHealth -= damage;
    
    // 检查玩家是否死亡
    if (player.battle.playerHealth <= 0) {
        stopBackgroundBattle();
        logAction("你在后台战斗中被怪物击败！", "error");
     updatePlayerBattleStats();
    }
}

// 后台处理怪物被击败
function backgroundHandleMonsterDefeated() {
    const monster = player.battle.currentMonster;
    const zone = player.battle.currentZone;
    
    // 增加复活次数
    player.battle.monsterResurrections++;
    
    if (player.battle.monsterResurrections < 5) {
        // 怪物复活（属性增强）
        monster.health = monster.maxHealth * Math.pow(2, player.battle.monsterResurrections);
        monster.attack *= 1.5;
   backgroundMonsterCounterAttack();
    } else {
        // 怪物真正死亡
        // 计算经验奖励
        const expMin = zone.expRange[0];
        const expMax = zone.expRange[1];
        const exp = Math.floor(Math.random() * (expMax - expMin + 1)) + expMin;
        const finalExp = exp * player.vip.level;
        
        // 添加经验
        addPlayerExp(finalExp);
        
        if (player.nightClub.starCoins < 1) {
            stopBackgroundBattle();
            logAction("星币不足，后台自动战斗已停止", "warning");
            return;
        }
        
       
        player.nightClub.starCoins--;
        
        // 生成新怪物
        generateMonsterForZone(zone);
        player.battle.monsterResurrections = 0;
      updatePlayerBattleStats();
    }
}

// 停止后台战斗
function stopBackgroundBattle() {
    if (player.backgroundBattle.interval) {
        clearInterval(player.backgroundBattle.interval);
        player.backgroundBattle.interval = null;
    }
    player.backgroundBattle.active = false;
}
function openBattleUI() {
    document.getElementById('battleUI').style.display = 'block';
    document.getElementById('battleOverlay').style.display = 'block';
    
    // 更新界面显示
    updateBattleUI();
    
    // 显示后台战斗日志
    player.battleLog.forEach(log => {
        const logElement = document.createElement('div');
        logElement.textContent = log;
        document.getElementById('addbattleLog').appendChild(logElement);
    });
    
    // 滚动到底部
    document.getElementById('addbattleLog').scrollTop = document.getElementById('addbattleLog').scrollHeight;
}
// 车辆品牌配置
const vehicleBrands = [
    { id: 1, name: "大众", models: ["Polo", "Golf", "Passat"], rarity: 1 },
    { id: 2, name: "丰田", models: ["卡罗拉", "凯美瑞", "RAV4"], rarity: 2 },
    { id: 3, name: "本田", models: ["思域", "雅阁", "CR-V"], rarity: 3 },
    { id: 4, name: "福特", models: ["福克斯", "蒙迪欧", "探险者"], rarity: 4 },
    { id: 5, name: "日产", models: ["轩逸", "天籁", "奇骏"], rarity: 5 },
    { id: 6, name: "现代", models: ["伊兰特", "索纳塔", "途胜"], rarity: 6 },
    { id: 7, name: "宝马", models: ["3系", "5系", "X5"], rarity: 7 },
    { id: 8, name: "奔驰", models: ["C级", "E级", "GLC"], rarity: 8 },
    { id: 9, name: "奥迪", models: ["A4", "A6", "Q5"], rarity: 9 },
    { id: 10, name: "雷克萨斯", models: ["ES", "RX", "NX"], rarity: 10 },
    { id: 11, name: "沃尔沃", models: ["S60", "S90", "XC60"], rarity: 11 },
    { id: 12, name: "凯迪拉克", models: ["CT5", "XT5", "Escalade"], rarity: 12 },
    { id: 13, name: "保时捷", models: ["911", "Cayenne", "Panamera"], rarity: 13 },
    { id: 14, name: "玛莎拉蒂", models: ["Ghibli", "Levante", "Quattroporte"], rarity: 14 },
    { id: 15, name: "法拉利", models: ["Portofino", "Roma", "SF90"], rarity: 15 },
    { id: 16, name: "兰博基尼", models: ["Huracan", "Aventador", "Urus"], rarity: 16 },
    { id: 17, name: "宾利", models: ["飞驰", "添越", "欧陆"], rarity: 17 },
    { id: 18, name: "劳斯莱斯", models: ["古斯特", "幻影", "库里南"], rarity: 18 },
    { id: 19, name: "迈凯伦", models: ["GT", "720S", "Artura"], rarity: 19 },
    { id: 20, name: "阿斯顿马丁", models: ["DB11", "Vantage", "DBS"], rarity: 20 },
    { id: 21, name: "布加迪", models: ["Chiron", "Divo", "Centodieci"], rarity: 21 },
    { id: 22, name: "柯尼塞格", models: ["Jesko", "Gemera", "Regera"], rarity: 22 },
    { id: 23, name: "帕加尼", models: ["Huayra", "Zonda", "Utopia"], rarity: 23 },
    { id: 24, name: "世爵", models: ["C8", "D12", "B6"], rarity: 24 },
    { id: 25, name: "威兹曼", models: ["GT", "Roadster", "MF5"], rarity: 25 },
    { id: 26, name: "西尔贝", models: ["Tuatara", "Aero", "Ultimate"], rarity: 26 },
    { id: 27, name: "轩尼诗", models: ["Venom F5", "Venom GT", "Exorcist"], rarity: 27 },
    { id: 28, name: "里马克", models: ["C_Two", "Concept_One", "Nevera"], rarity: 28 },
    { id: 29, name: "阿波罗", models: ["IE", "Intensa", "Project Evo"], rarity: 29 },
    { id: 30, name: "Zenvo", models: ["TSR-S", "ST1", "TS1"], rarity: 30 },
    { id: 31, name: "锐马克", models: ["Nevera", "C_Two", "Concept Two"], rarity: 31 },
    { id: 32, name: "宾尼法利纳", models: ["Battista", "PF0", "PF1"], rarity: 32 },
    { id: 33, name: "克钦格", models: ["21C", "22C", "23C"], rarity: 33 },
    { id: 34, name: "SCG", models: ["007 LMH", "008 Stradale", "009 Hypercar"], rarity: 34 },
    { id: 35, name: "唐克沃特", models: ["D8 GTO", "D8 GT", "D8 Spider"], rarity: 35 },
    { id: 36, name: "凡克", models: ["Shield", "P60", "S1"], rarity: 36 },
    { id: 37, name: "梅尔库斯", models: ["RS2000", "RS3000", "RS4000"], rarity: 37 },
    { id: 38, name: "德托马索", models: ["P72", "Valerio", "Mangusta"], rarity: 38 },
    { id: 39, name: "向量", models: ["WX-8", "WX-12", "V12 Supercharged"], rarity: 39 },
    { id: 40, name: "帕诺兹", models: ["Evviva", "Abruzzi", "Roadster"], rarity: 40 },
    { id: 41, name: "阿尔派", models: ["A110 Stradale", "A110 GT", "A110 S"], rarity: 41 },
    { id: 42, name: "路特斯", models: ["Evija", "Emira", "Elise"], rarity: 42 },
    { id: 43, name: "赫尔姆", models: ["Fury", "GT", "Spider"], rarity: 43 },
    { id: 44, name: "泰格鲁斯·腾风", models: ["GT96 T Revival", "AT96 T", "GT96 T Electric"], rarity: 44 },
    { id: 45, name: "Vencer", models: ["Shield", "P60", "S1"], rarity: 45 },
    { id: 46, name: "比扎里尼", models: ["5000 GT", "Strada", "P538"], rarity: 46 },
    { id: 47, name: "BAC Mono", models: ["Mono", "Mono R", "Mono X"], rarity: 47 },
    { id: 48, name: "Panoz", models: ["Evviva", "Abruzzi", "Roadster"], rarity: 48 },
    { id: 49, name: "Fisker", models: ["Pearl", "Ronin", "Force E"], rarity: 49 },
    { id: 50, name: "Koenigsegg", models: ["Jesko Absolut", "Gemera", "Regera"], rarity: 50 }
];

// 初始化玩家停车位数据
function initParkingData() {
    if (!player.parking) {
        player.parking = {
            level: 1,
            exp: 0,
            maxSpots: 1,
            vehicles: [],
            parkedVehicles: [],
            lastUpdate: Date.now(),
            totalIncome: 0
        };
    }
}

// 切换停车位系统界面
function toggleParkingSystem() {
   if (player.reincarnationCount < 200) {
        alert("需要达到200转才能开启停车场系统！");
        return;
    }
    const ui = document.getElementById('parkingSystemUI');
    const overlay = document.getElementById('parkingSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initParkingData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateParkingUI();
    }
}

function closeParkingSystem() {
    document.getElementById('parkingSystemUI').style.display = 'none';
    document.getElementById('parkingSystemOverlay').style.display = 'none';
}

// 更新停车位界面
function updateParkingUI() {
    // 更新基本信息
    document.getElementById('parkingLevel').textContent = player.parking.level;
    document.getElementById('parkingSpotCount').textContent = player.parking.parkedVehicles.length;
    document.getElementById('maxParkingSpots').textContent = player.parking.maxSpots;
    document.getElementById('parkingExp').textContent = player.parking.exp.toFixed(1);
    document.getElementById('nextLevelExp').textContent = getNextLevelExpq();
    document.getElementById('totalParkingIncome').textContent = player.parking.totalIncome.toExponential(1);
    
    // 更新车辆列表
    updateVehicleList();
    
    // 更新停车位显示
    updateParkingSpots();
    
    // 更新分解界面
    updateDecomposeUI();
}

// 获取下一级所需经验
function getNextLevelExpq() {
    const expRequirements = [100, 200, 300, 400, 600, 800, 1000, 1300, 1700, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 15000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000, 125000, 150000, 200000, 400000, 600000, 800000, 1000000, 2500000, 5000000, 10000000, 100000000];
    const currentLevel = Math.min(player.parking.level, expRequirements.length);
    return expRequirements[currentLevel - 1];
}

// 更新车辆列表
function updateVehicleList() {
    const container = document.getElementById('vehicleList');
    container.innerHTML = '';
    
    player.parking.vehicles.forEach((vehicle, index) => {
        const vehicleCard = document.createElement('div');
        vehicleCard.className = 'vehicle-card';
        vehicleCard.style.background = '#444';
        vehicleCard.style.padding = '10px';
        vehicleCard.style.borderRadius = '5px';
        vehicleCard.style.textAlign = 'center';
        vehicleCard.style.cursor = 'pointer';
        vehicleCard.dataset.index = index;
        
        // 根据稀有度设置边框颜色
        const rarityColor = getRarityColor(vehicle.rarity);
        vehicleCard.style.border = `2px solid ${rarityColor}`;
        
        vehicleCard.innerHTML = `
            <div style="font-weight: bold; color: ${rarityColor}">${vehicle.brand}</div>
            <div>${vehicle.model}</div>
            <div style="font-size: 0.8em; margin-top: 5px;">稀有度: ${vehicle.rarity}</div>
        `;
        
        // 点击车辆进行停车操作
        vehicleCard.onclick = function() {
            parkVehicle(index);
        };
        
        container.appendChild(vehicleCard);
    });
}

// 根据稀有度获取颜色
function getRarityColor(rarity) {
    if (rarity <= 5) return '#1E90FF'; // 普通 - 蓝色
    if (rarity <= 10) return '#32CD32'; // 稀有 - 绿色
    if (rarity <= 15) return '#FFD700'; // 史诗 - 金色
    if (rarity <= 20) return '#9370DB'; // 传说 - 紫色
    if (rarity <= 25) return '#013220'; // 传说 - 紫色
    if (rarity <= 30) return '#C0C0C0'; // 传说 - 紫色
    if (rarity <= 35) return '#FF1493'; // 传说 - 紫色
    if (rarity <= 45) return '#FF4500'; // 神话 - 橙色
    return '#FF0000'; // 至尊 - 粉色
}

// 更新停车位显示
function updateParkingSpots() {
    const container = document.getElementById('parkingSpotsContainer');
    container.innerHTML = '';
    
    // 创建停车位卡片
    for (let i = 0; i < player.parking.maxSpots; i++) {
        const spotCard = document.createElement('div');
        spotCard.className = 'parking-spot';
        spotCard.style.border = '1px solid #ddd';
        spotCard.style.padding = '10px';
        spotCard.style.borderRadius = '5px';
        spotCard.style.textAlign = 'center';
        
        if (i < player.parking.parkedVehicles.length) {
            const vehicle = player.parking.parkedVehicles[i];
         const rarityColor = getRarityColor(vehicle.rarity);
            spotCard.innerHTML = `
               <div style="font-weight: bold; color: ${rarityColor}">${vehicle.brand}</div>
                <div>${vehicle.model}</div>
                <div>收益: ${calculateParkingIncome(vehicle)} 转生币</div>
                <div>经验: ${calculateParkingIncome(vehicle) / 10000} 经验值</div>
                <button onclick="unparkVehicle(${i})" style="margin-top: 10px; background: #ff9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">卸下</button>
            `;
        } else {
            spotCard.innerHTML = '<div>空闲车位</div>';
        }
        
        container.appendChild(spotCard);
    }
}
function unparkVehicle(spotIndex) {
    if (spotIndex >= player.parking.parkedVehicles.length) return;
    
    // 获取车辆信息
    const vehicle = player.parking.parkedVehicles[spotIndex];
    
    // 将车辆移回车辆列表
    player.parking.vehicles.push(vehicle);
    
    // 从停车位移除
    player.parking.parkedVehicles.splice(spotIndex, 1);
    
    // 计算并收取收益
    const income = calculateParkingIncome(vehicle);
    player.reincarnationCoin += income;
    player.parking.totalIncome += income;
    player.parking.exp += income / 10000;
    logAction(`卸下车辆: ${vehicle.brand} ${vehicle.model}, 获得收益 ${income} 转生币`, 'success');
    updateParkingUI();
    
    // 更新显示
    updateParkingDisplay();
    updateDisplay();
    checkTitleUnlocks();
    saveGame();
}

// 计算停车收益
function calculateParkingIncome(vehicle) {
    // 收益 = 车辆稀有度 * 停车时间(小时)
    const hoursParked = (Date.now() - vehicle.parkTime) / (100 * 60 * 60);
    return Math.floor(vehicle.rarity * hoursParked) * 1000;
}

// 停车操作
function parkVehicle(vehicleIndex) {
    // 检查是否有空闲车位
    if (player.parking.parkedVehicles.length >= player.parking.maxSpots) {
        logAction("没有空闲车位了！", "error");
        return;
    }
    
    const vehicle = player.parking.vehicles[vehicleIndex];
    
    // 将车辆移动到停车位
    player.parking.parkedVehicles.push({
        ...vehicle,
        parkTime: Date.now()
    });
    
    // 从车辆列表中移除
    player.parking.vehicles.splice(vehicleIndex, 1);
    
    logAction(`已将 ${vehicle.brand} ${vehicle.model} 停入车位`, "success");
    updateParkingUI();
    saveGame();
}

// 一键停车
function parkAllVehicles() {
    // 计算可停车数量
    const availableSpots = player.parking.maxSpots - player.parking.parkedVehicles.length;
    const vehiclesToPark = Math.min(availableSpots, player.parking.vehicles.length);
    
    if (vehiclesToPark === 0) {
        logAction("没有可停车的车辆或没有空闲车位", "info");
        return;
    }
    
    // 停车操作
    for (let i = 0; i < vehiclesToPark; i++) {
        const vehicle = player.parking.vehicles[0];
        player.parking.parkedVehicles.push({
            ...vehicle,
            parkTime: Date.now()
        });
        player.parking.vehicles.shift();
    }
    
    logAction(`已自动停放 ${vehiclesToPark} 辆车辆`, "success");
    updateParkingUI();
    saveGame();
}

// 收取单个车位收益
function collectParkingIncome(spotIndex) {
    const vehicle = player.parking.parkedVehicles[spotIndex];
    const income = calculateParkingIncome(vehicle);
    
    // 添加收益
    player.reincarnationCoin += income;
    player.parking.totalIncome += income;
    
    // 添加停车经验
    player.parking.exp += income / 10000;
    
    // 重置停车时间
    vehicle.parkTime = Date.now();
    
    logAction(`收取了 ${vehicle.brand} ${vehicle.model} 的停车收益: ${income} 转生币`, "success");
    updateParkingUI();
    updateDisplay();
    saveGame();
}

// 收取所有收益
function collectAllParkingIncome() {
    let totalIncome = 0;
    
    player.parking.parkedVehicles.forEach(vehicle => {
        const income = calculateParkingIncome(vehicle);
        totalIncome += income;
        
        // 添加停车经验
        player.parking.exp += income / 10000;
        
        // 重置停车时间
        vehicle.parkTime = Date.now();
    });
    
    // 添加收益
    player.reincarnationCoin += totalIncome;
    player.parking.totalIncome += totalIncome;
    
    logAction(`收取了所有停车收益: ${totalIncome} 转生币`, "success");
    updateParkingUI();
    updateDisplay();
   checkTitleUnlocks();
    saveGame();
}

// 更新分解界面
function updateDecomposeUI() {
    const container = document.getElementById('decomposeVehicleContainer');
    container.innerHTML = '';
    
    // 添加车库中的车辆
    player.parking.vehicles.forEach((vehicle, index) => {
        const vehicleDiv = document.createElement('div');
        vehicleDiv.style.display = 'flex';
        vehicleDiv.style.alignItems = 'center';
        vehicleDiv.style.marginBottom = '10px';
        vehicleDiv.style.padding = '5px';
        vehicleDiv.style.background = '#444';
        vehicleDiv.style.borderRadius = '3px';
        
        const rarityColor = getRarityColor(vehicle.rarity);
        
        vehicleDiv.innerHTML = `
            <input type="checkbox" id="vehicleCheckbox${index}" style="margin-right: 10px;">
            <div style="flex: 1;">
                <div style="font-weight: bold; color: ${rarityColor}">${vehicle.brand} ${vehicle.model}</div>
                <div style="font-size: 0.8em;">稀有度: ${vehicle.rarity}</div>
            </div>
            <div style="margin-left: 10px;">
                分解价值: <span style="color: #FFD700;">${vehicle.rarity * 10000}</span>
            </div>
        `;
        
        container.appendChild(vehicleDiv);
    });
}

// 分解选中车辆
function decomposeSelectedVehicle() {
    const vehiclesToDecompose = [];
    
    // 收集选中的车辆
    player.parking.vehicles.forEach((vehicle, index) => {
        const checkbox = document.getElementById(`vehicleCheckbox${index}`);
        if (checkbox && checkbox.checked) {
            vehiclesToDecompose.push({
                index,
                vehicle
            });
        }
    });
    
    if (vehiclesToDecompose.length === 0) {
        logAction("请选择要分解的车辆", "error");
        return;
    }
    
    // 计算总收益
    let totalValue = 0;
    vehiclesToDecompose.forEach(item => {
        totalValue += item.vehicle.rarity * 10000;
    });
    
    // 从高索引到低索引删除，避免索引变化问题
    vehiclesToDecompose.sort((a, b) => b.index - a.index);
    vehiclesToDecompose.forEach(item => {
        player.parking.vehicles.splice(item.index, 1);
    });
    
    // 添加收益
    player.reincarnationCoin += totalValue;
    
    logAction(`分解了 ${vehiclesToDecompose.length} 辆车辆，获得 ${totalValue} 转生币`, "success");
    updateParkingUI();
    updateDisplay();
    saveGame();
}

// 升级停车位
function upgradeParking() {
    const requiredExp = getNextLevelExpq();
    
    if (player.parking.exp < requiredExp) {
        logAction(`经验不足！需要 ${requiredExp} 经验`, "error");
        return;
    }
    
    // 扣除经验
    player.parking.exp -= requiredExp;
    
    // 升级
    player.parking.level++;
    player.parking.maxSpots++;
    
    logAction(`停车位升级到 ${player.parking.level} 级！最大车位增加到 ${player.parking.maxSpots}`, "success");
    updateParkingUI();
    saveGame();
}
// 在农场收获时获得车辆
function onFarmHarvest() {
 if (Math.random() < 0.2) {
        // 根据品阶设置掉落概率
        const rand = Math.random();
        let rarityRange;
        
        if (rand < 0.70) {
            rarityRange = [1, 7];
        } else if (rand < 0.88) {
            rarityRange = [8, 14];
        } else if (rand < 0.96) {
           rarityRange = [15, 22];
            } else if (rand < 0.99) {
           rarityRange = [23, 30];
        } else if (rand < 0.998) {
            rarityRange = [31, 38];
        } else if (rand < 0.9999) {
            rarityRange = [39, 44];
        } else {
            rarityRange = [45, 50];
        }
        
        // 在指定品阶范围内筛选符合条件的车辆
        const eligibleBrands = vehicleBrands.filter(brand => 
            brand.rarity >= rarityRange[0] && brand.rarity <= rarityRange[1]
        );
        
        if (eligibleBrands.length > 0) {
            // 随机选择一个品牌
            const brand = eligibleBrands[Math.floor(Math.random() * eligibleBrands.length)];
            
            // 随机选择型号
            const model = brand.models[Math.floor(Math.random() * brand.models.length)];
            
            // 创建车辆对象
            const newVehicle = {
                id: 'vehicle_' + Date.now(),
                brand: brand.name,
                model: model,
                rarity: brand.rarity,
                parkTime: 0,
                income: 0
            };
            
            // 添加到车辆列表
            player.parking.vehicles.push(newVehicle);
            
            // 记录日志
            logAction(`收获时获得了一辆${brand.name} ${model}（品阶${brand.rarity}）！`, "success");
        }
    }
}
function calculateOfflineParkingIncome() {
    const now = Date.now();
    const elapsed = now - player.parking.lastUpdate;
    
    player.parking.parkedVehicles.forEach(vehicle => {
        const income = vehicle.rarity * (elapsed / (100 * 60 * 60)); // 每小时收益
        player.parking.totalIncome += income;
        player.parking.exp += income / 10000;
    });
    
    player.parking.lastUpdate = now;
}
// 星域探索系统数据
const explorationData = {
    speed: { level: 1, cost: 100 },
    capacity: { level: 1, cost: 100 },
    durability: { level: 1, cost: 100 },
    resources: {
        stardust: 0,
        darkMatter: 0,
        cosmicCrystal: 0,
        artifactFragment: 0
    },
    activeMission: null,
    missionEndTime: 0,
    logs: []
};

// 任务配置
const missions = {
    easy: {
        name: "近地星域",
        time: 120, // 分钟
        rewards: {
            stardust: { min: 1, max: 15 },
            darkMatter: { min: 1, max: 15 }
        },
        damageRisk: 50
    },
    medium: {
        name: "深空星域",
        time: 180,
        rewards: { 
            stardust: { min: 1, max: 25 },
            darkMatter: { min: 1, max: 30 },
             cosmicCrystal: { min: 1, max: 20 }
        },
        damageRisk: 60
    },
    hard: {
        name: "黑洞边缘",
        time: 240,
        rewards: {
            stardust: { min: 1, max: 50 },
            darkMatter: { min: 1, max: 50 },
            cosmicCrystal: { min: 1, max: 50 }
        },
        damageRisk: 70
    },
    extreme: {
        name: "宇宙边缘",
        time: 360,
        rewards: {
            cosmicCrystal: { min: 1, max: 50 },
            artifactFragment: { min: 1, max: 50 }
        },
        damageRisk: 80
    }
};

// 切换探索系统界面
function toggleExplorationSystem() {
    if (player.reincarnationCount < 300) {
        alert("需要达到300转才能开启星域探索！");
        return;
    }
    const ui = document.getElementById('explorationSystemUI');
    const overlay = document.getElementById('explorationSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateExplorationUI();
    }
}

// 更新探索系统界面
function updateExplorationUI() {
    // 更新资源仓库显示
    document.getElementById('speedLevel').textContent = explorationData.speed.level;
    document.getElementById('capacityLevel').textContent = explorationData.capacity.level;
    document.getElementById('durabilityLevel').textContent = explorationData.durability.level;
    
    // 计算属性效果
    const speedEffect = 60 - (explorationData.speed.level - 1) * 5;
    const capacityEffect = 100 + (explorationData.capacity.level - 1) * 20;
    const durabilityEffect = 5 + (explorationData.durability.level - 1) * 2;
    const damageReduction = 10 - (explorationData.durability.level - 1) * 1;
    
    document.getElementById('explorationTime').textContent = Math.max(10, speedEffect);
    document.getElementById('resourceGain').textContent = capacityEffect + '%';
    document.getElementById('rareRate').textContent = durabilityEffect + '%';
    document.getElementById('damageRate').textContent = Math.max(1, damageReduction) + '%';
    
    // 更新资源显示
    document.getElementById('stardustCount').textContent = explorationData.resources.stardust || 0;
    document.getElementById('darkMatterCount').textContent = explorationData.resources.darkMatter || 0;
    document.getElementById('cosmicCrystalCount').textContent = explorationData.resources.cosmicCrystal || 0;
    document.getElementById('artifactFragmentCount').textContent = explorationData.resources.artifactFragment || 0;
    
    // 更新任务按钮状态
    const missionButtons = document.querySelectorAll('.start-mission-btn');
    missionButtons.forEach(button => {
        if (explorationData.activeMission) {
            button.disabled = true;
            button.textContent = "任务进行中";
        } else {
            button.disabled = false;
            button.textContent = "开始探索";
        }
    });
    
    // 更新任务时间显示（应用速度加成）- 修复部分
    const missionCards = document.querySelectorAll('.mission-card');
    missionCards.forEach(card => {
        const difficulty = card.getAttribute('data-difficulty');
         // 添加安全检查
        if (!missions[difficulty]) {
            console.error("未找到任务配置:", difficulty);
            return; // 跳过这个卡片
        }
   
        
        const mission = missions[difficulty];
        const baseTime = mission.time;
        const actualTime = Math.max(10, baseTime - (explorationData.speed.level - 1) * 5);
        card.querySelector('.mission-time').textContent = actualTime + "分钟";
        
        // 应用耐久加成后的损坏率
        const baseRisk = mission.damageRisk;
        const actualRisk = Math.max(1, baseRisk - (explorationData.durability.level - 1));
        card.querySelector('.damage-risk').textContent = actualRisk + "%";
    });
    
    // 更新属性升级按钮的显示
    const attributes = ['speed', 'capacity', 'durability'];
    attributes.forEach(attr => {
        const btn = document.querySelector(`.upgrade-btn[data-attr="${attr}"]`);
        if (btn) {
            const cost = explorationData[attr].cost;
            btn.textContent = `升级 (${formatNumber(cost)}转生币)`;
            btn.disabled = player.reincarnationCoin < cost;
        }
    });

    // 更新日志
    updateExplorationLog();
    
    // 如果有进行中的任务，显示倒计时
    if (explorationData.activeMission) {
        const remaining = Math.max(0, explorationData.missionEndTime - Date.now());
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        
        addLog(`任务进行中: ${missions[explorationData.activeMission]?.name || '未知任务'} - 剩余: ${minutes}分${seconds}秒`);
        
        if (remaining <= 0) {
            completeMission();
        }
    }
}

// 升级属性
function upgradeAttribute(attribute) {
    const cost = explorationData[attribute].cost;
    
    if (player.reincarnationCoin >= cost) {
        player.reincarnationCoin -= cost;
        explorationData[attribute].level++;
        explorationData[attribute].cost = Math.floor(cost * 10);
        
        addLog(`${attribute === 'speed' ? '速度' : attribute === 'capacity' ? '容量' : '耐久'}升级到 ${explorationData[attribute].level}级`);
        updateExplorationUI();
        logAction(`星域探索: ${attribute}升级成功`, 'success');
    } else {
        logAction(`转生币不足！需要${formatNumber(cost)}转生币`, "error");
    }
}

// 一键升级全部属性
function upgradeAllAttributes() {
    const attributes = ['speed', 'capacity', 'durability'];
    let upgraded = false;
    
    attributes.forEach(attr => {
        while (player.reincarnationCoin >= explorationData[attr].cost) {
            const cost = explorationData[attr].cost;
            player.reincarnationCoin -= cost;
            explorationData[attr].level++;
            explorationData[attr].cost = Math.floor(cost * 10);
            upgraded = true;
        }
    });
    
    if (upgraded) {
        addLog("一键升级全部属性成功");
        updateExplorationUI();
        logAction("星域探索: 一键升级成功", 'success');
    } else {
        // 显示具体缺少的转生币数量
        const costs = attributes.map(attr => explorationData[attr].cost);
        const minCost = Math.min(...costs);
        logAction(`转生币不足，至少需要${formatNumber(minCost)}转生币才能升级任一属性`, "error");
    }
}

// 开始任务
function startMission(difficulty) {
    if (explorationData.activeMission) {
        logAction("已有任务进行中", "error");
        return;
    }
    
    // 计算实际任务时间（应用速度加成）
    const baseTime = missions[difficulty].time;
    const actualTime = Math.max(10, baseTime - (explorationData.speed.level - 1) * 5) * 60000;
    
    explorationData.activeMission = difficulty;
    explorationData.missionEndTime = Date.now() + actualTime;
    
    addLog(`开始探索: ${missions[difficulty].name} - 预计完成时间: ${new Date(explorationData.missionEndTime).toLocaleTimeString()}`);
    updateExplorationUI();
    
    // 设置任务完成检查
    setTimeout(completeMission, actualTime);
    
    // 立即保存游戏
    saveGame();
}

// 完成任务
function completeMission() {
    if (!explorationData.activeMission) return;
    
    const mission = missions[explorationData.activeMission];
    const difficulty = explorationData.activeMission;
    
    // 计算实际损坏率（应用耐久加成）
    const baseRisk = mission.damageRisk;
    const actualRisk = Math.max(1, baseRisk - (explorationData.durability.level - 1));
    
    // 检查是否发生损坏
    let damaged = false;
    if (Math.random() * 100 < actualRisk) {
        damaged = true;
        addLog(`任务完成，但舰队受到损坏！`);
    } else {
        addLog(`任务成功完成: ${mission.name}`);
    }
    
    // 计算资源获取（应用容量加成）
    const capacityMultiplier = 1 + (explorationData.capacity.level - 1) * 0.2;
    
    // 发放资源
    let rewards = "";
    for (const resource in mission.rewards) {
        const min = mission.rewards[resource].min;
        const max = mission.rewards[resource].max;
        let amount = Math.floor((Math.random() * (max - min + 1) + min) * capacityMultiplier);
    
        if (damaged) {
            amount = Math.floor(amount * 0.2); // 损坏时资源减半
        }
        
        explorationData.resources[resource] += amount;
        rewards += `${getResourceName(resource)}: ${amount} `;
    }
    
    addLog(`获得资源: ${rewards}`);
    
    // 重置任务状态
    explorationData.activeMission = null;
    explorationData.missionEndTime = 0;
    
    updateExplorationUI();
    saveGame();
}

// 获取资源名称
function getResourceName(resource) {
    switch(resource) {
        case 'stardust': return '星尘';
        case 'darkMatter': return '暗物质';
        case 'cosmicCrystal': return '宇宙晶体';
        case 'artifactFragment': return '神器碎片';
        default: return resource;
    }
}

// 添加日志
function addLog(message) {
    const timestamp = new Date().toLocaleTimeString();
    explorationData.logs.unshift(`[${timestamp}] ${message}`);
    
    if (explorationData.logs.length > 20) {
        explorationData.logs.pop();
    }
    
    updateExplorationLog();
}

// 更新日志显示
function updateExplorationLog() {
    const logContainer = document.getElementById('explorationLog');
    logContainer.innerHTML = explorationData.logs.map(log => 
        `<div class="log-entry">${log}</div>`
    ).join('');
}

function initExplorationSystem() {
    // 确保所有属性都有默认值
    explorationData.speed = explorationData.speed || { level: 1, cost: 100 };
    explorationData.capacity = explorationData.capacity || { level: 1, cost: 100 };
    explorationData.durability = explorationData.durability || { level: 1, cost: 100 };
    explorationData.resources = explorationData.resources || {
        stardust: 0,
        darkMatter: 0,
        cosmicCrystal: 0,
        artifactFragment: 0
    };
    explorationData.activeMission = explorationData.activeMission || null;
    explorationData.missionEndTime = explorationData.missionEndTime || 0;
    explorationData.logs = explorationData.logs || [];
    
    // 检查是否有进行中的任务
    if (explorationData.activeMission && explorationData.missionEndTime > Date.now()) {
        const remaining = explorationData.missionEndTime - Date.now();
        setTimeout(completeMission, remaining);
        addLog(`恢复进行中的探索任务: ${missions[explorationData.activeMission].name} - 剩余时间: ${Math.floor(remaining/60000)}分钟`);
    } else if (explorationData.activeMission && explorationData.missionEndTime <= Date.now()) {
        // 任务已经结束但未完成
        completeMission();
    }
}
// 切换兑换商店显示
function toggleExchangeShop() {
    const overlay = document.getElementById('exchangeShopOverlay');
    const ui = document.getElementById('exchangeShopUI');
    
    if (ui.style.display === 'none') {
        // 打开商店时更新显示
        updateExchangeDisplay();
        overlay.style.display = 'block';
        ui.style.display = 'block';
    } else {
        overlay.style.display = 'none';
        ui.style.display = 'none';
    }
}

// 更新兑换商店显示
function updateExchangeDisplay() {
    // 更新资源数量
    document.getElementById('currentStardustExchange').textContent = player.exploration.resources.stardust;
    document.getElementById('currentDarkMatterExchange').textContent = player.exploration.resources.darkMatter;
    document.getElementById('currentCosmicCrystalExchange').textContent = player.exploration.resources.cosmicCrystal;
    document.getElementById('currentArtifactFragmentExchange').textContent = player.exploration.resources.artifactFragment;
    
    // 更新发票数量
    document.getElementById('currentStardustTicket').textContent = player.items.yuzhou1 || 0;
    document.getElementById('currentDarkMatterTicket').textContent = player.items.yuzhou2 || 0;
    document.getElementById('currentCosmicCrystalTicket').textContent = player.items.yuzhou3 || 0;
    document.getElementById('currentArtifactFragmentTicket').textContent = player.items.yuzhou4 || 0;
}

// 资源兑换函数
function exchangeResource(resourceType, direction) {
    // 确定兑换数量和输入框
    let amountInput, amount;
    let ticketType;
    
    switch(resourceType) {
        case 'stardust':
            amountInput = document.getElementById('stardustAmount');
            ticketType = 'yuzhou1';
            break;
        case 'darkMatter':
            amountInput = document.getElementById('darkMatterAmount');
            ticketType = 'yuzhou2';
            break;
        case 'cosmicCrystal':
            amountInput = document.getElementById('cosmicCrystalAmount');
            ticketType = 'yuzhou3';
            break;
        case 'artifactFragment':
            amountInput = document.getElementById('artifactFragmentAmount');
            ticketType = 'yuzhou4';
            break;
    }
    
    amount = parseInt(amountInput.value);
    if (isNaN(amount) || amount < 1) {
        logAction("请输入有效的兑换数量", "error");
        return;
    }
    
    if (direction === 'toTicket') {
        // 资源兑换发票
        if (player.exploration.resources[resourceType] < amount) {
            logAction(`${getResourceName(resourceType)}不足`, "error");
            return;
        }
        
        player.exploration.resources[resourceType] -= amount;
        player.items[ticketType] = (player.items[ticketType] || 0) + amount;
        
        logAction(`成功将${amount}个${getResourceName(resourceType)}兑换为${amount}张${getTicketName(ticketType)}`, "success");
    } else {
        // 发票兑换资源
        if ((player.items[ticketType] || 0) < amount) {
            logAction(`${getTicketName(ticketType)}不足`, "error");
            return;
        }
        
        player.items[ticketType] -= amount;
        player.exploration.resources[resourceType] += amount;
        
        logAction(`成功将${amount}张${getTicketName(ticketType)}兑换为${amount}个${getResourceName(resourceType)}`, "success");
    }
    
    // 更新显示
    updateExchangeDisplay();
    saveGame();
}

// 获取资源名称
function getResourceName(type) {
    const names = {
        'stardust': '星尘',
        'darkMatter': '暗物质',
        'cosmicCrystal': '宇宙晶体',
        'artifactFragment': '神器碎片'
    };
    return names[type] || type;
}

// 获取发票名称
function getTicketName(type) {
    const names = {
        'yuzhou1': '星尘发票',
        'yuzhou2': '暗物质发票',
        'yuzhou3': '宇宙晶体发票',
        'yuzhou4': '神器碎片发票'
    };
    return names[type] || type;
}
// 神器部位配置
const artifactParts = [
    { id: "helmet", name: "头盔" },
    { id: "clothes", name: "衣服" },
    { id: "pants", name: "裤子" },
    { id: "shoes", name: "鞋子" },
    { id: "necklace", name: "项链" },
    { id: "weapon", name: "武器" }
];

// 神器品质配置
const artifactQualities = [
    { id: "common", name: "普通", color: "#FFFFFF", minBonus: 0.1, maxBonus: 1 },
    { id: "uncommon", name: "精良", color: "#1E90FF", minBonus: 0.5, maxBonus: 5 },
    { id: "rare", name: "稀有", color: "#9B30FF", minBonus: 1, maxBonus: 10 },
    { id: "epic", name: "史诗", color: "#FF4500", minBonus: 2, maxBonus: 20 },
    { id: "legendary", name: "传说", color: "#FFD700", minBonus: 5, maxBonus: 50 },
    { id: "mythic", name: "神话", color: "#FF1493", minBonus: 10, maxBonus: 100 }
];

// 神器套装配置
const artifactSets = [
    {
        name: "青龙套装",
        bonuses: {
            2: { health: 30, description: "生命加成+3000%" },
            4: { attack: 200, description: "攻击加成+20000%" },
            6: { critDamage: 1500, description: "爆伤加成+150000%" }
        }
    },
 {
        name: "新手套装",
        bonuses: {
            2: { health: 2, description: "生命加成+200%" },
            4: { attack: 20, description: "攻击加成+2000%" },
            6: { critDamage: 150, description: "爆伤加成+15000%" }
        }
    },
 {
        name: "废品套装",
        bonuses: {
            2: { health: 1, description: "生命加成+100%" },
            4: { attack: 1, description: "攻击加成+100%" },
            6: { critDamage: 1, description: "爆伤加成+100%" }
        }
},
 {
        name: "闫闫套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { health: 10, description: "生命加成+1000%" },
            6: { health: 10, description: "生命加成+1000%" }
        }
},
 {
        name: "茶茶套装",
        bonuses: {
            2: { attack: 20, description: "攻击加成+2000%" },
            4: { attack: 20, description: "攻击加成+2000%" },
            6: { attack: 20, description: "攻击加成+2000%" }
        }
    },
 {
        name: "幼儿园套装",
        bonuses: {
            2: { health: 2, description: "生命加成+200%" },
            4: { attack: 2, description: "攻击加成+200%" },
            6: { critDamage: 2, description: "爆伤加成+200%" }
        }
    },
 {
        name: "梦想套装",
        bonuses: {
            2: { health: 1, description: "生命加成+100%" },
            4: { attack: 10, description: "攻击加成+1000%" },
            6: { critDamage: 100, description: "爆伤加成+10000%" }
        }
    },
 {
        name: "堕入套装",
        bonuses: {
            2: { attack: 3, description: "攻击加成+300%" },
            4: { attack: 5, description: "攻击加成+500%" },
            6: { critDamage: 80, description: "爆伤加成+8000%" }
        }
    },
 {
        name: "邪恶套装",
        bonuses: {
            2: { critDamage: 2, description: "爆伤加成+200%" },
            4: { critDamage: 10, description: "爆伤加成+1000%" },
            6: { critDamage: 170, description: "爆伤加成+17000%" }
        }
    },
 {
        name: "猎人套装",
        bonuses: {
            2: { health: 2, description: "生命加成+200%" },
            4: { attack: 30, description: "攻击加成+3000%" },
            6: { critDamage: 150, description: "爆伤加成+15000%" }
        }
    },
 {
        name: "死神套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { attack: 500, description: "攻击加成+50000%" },
            6: { attack: 4000, description: "攻击加成+400000%" }
        }
    },
 {
        name: "冥王套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { attack: 300, description: "攻击加成+30000%" },
            6: { critDamage: 3000, description: "爆伤加成+300000%" }
        }
    },
 {
        name: "至尊套装",
        bonuses: {
            2: { attack: 30, description: "攻击加成+3000%" },
            4: { health: 500, description: "生命加成+50000%" },
            6: { critDamage: 1700, description: "爆伤加成+170000%" }
        }
    },
 {
        name: "雷霆套装",
        bonuses: {
            2: { attack: 100, description: "攻击加成+10000%" },
            4: { attack: 550, description: "攻击加成+55000%" },
            6: { critDamage: 1300, description: "爆伤加成+130000%" }
        }
    },
 {
        name: "堕落套装",
        bonuses: {
            2: { health: 5, description: "生命加成+500%" },
            4: { attack: 10, description: "攻击加成+1000%" },
            6: { critDamage: 53, description: "爆伤加成+5300%" }
        }
    },
 {
        name: "神话套装",
        bonuses: {
            2: { health: 22, description: "生命加成+2200%" },
            4: { critDamage: 400, description: "攻击加成+40000%" },
            6: { critDamage: 2000, description: "爆伤加成+200000%" }
        }
    },
 {
        name: "圣光套装",
        bonuses: {
            2: { health: 15, description: "生命加成+1500%" },
            4: { attack: 100, description: "攻击加成+10000%" },
            6: { critDamage: 1300, description: "爆伤加成+130000%" }
        }
    },
 {
        name: "混沌套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { attack: 300, description: "攻击加成+30000%" },
            6: { health: 1500, description: "生命加成+150000%" }
        }
    },
    {
        name: "白虎套装",
        bonuses: {
            2: { attack: 15, description: "攻击加成+1500%" },
            4: { attack: 400, description: "攻击加成+40000%" },
            6: { attack: 1850, description: "攻击加成+185000%" }
        }
    },
    {
        name: "朱雀套装",
        bonuses: {
            2: { critDamage: 20, description: "爆伤加成+2000%" },
            4: { critDamage: 250, description: "爆伤加成+25000%" },
            6: { attack: 1650, description: "攻击加成+165000%" }
        }
    },
    {
        name: "玄武套装",
        bonuses: {
            2: { health: 50, description: "生命加成+5000%" },
            4: { health: 500, description: "生命加成+50000%" },
            6: { health: 1800, description: "生命加成+180000%" }
        }
    },
    {
        name: "麒麟套装",
        bonuses: {
            2: { attack: 50, description: "攻击加成+5000%" },
            4: { attack: 550, description: "攻击加成+55000%" },
            6: { health: 1000, description: "生命加成+100000%" }
        }
    }
];

// 神器名字库
const artifactNames = {
    helmet: ["玄铁战盔", "流光宝冠", "暗影头盔", "烈焰头环", "凤羽冠", "圣光战盔", "疾风头盔", "雷霆战盔", "雷霆战盔", "守护者头盔", "幽魂头罩", "精灵之冠", "矮人战盔", "毒藤头环", "寒冰面甲", "荣耀战盔", "耻辱面甲", "刹那冠冕", "雨龙盔", "龟甲盔", "云龙盔", "饕餮头盔", "虬龙头盔", "青鸾头盔", "火凤头盔", "蛟龙头盔", "龙鳞头盔", "苍龙头盔", "虚无头盔"],
    clothes: ["龙鳞甲", "玄冰法袍", "暗影披风", "圣光铠甲", "大地之袍", "疾风劲装", "藤蔓风衣", "王者披风", "毁灭者战衣", "混沌战甲", "黎明法衣", "黄昏披风", "幽魂长衫", "泰坦铠甲", "矮人战甲", "恶魔披风", "磐石铠甲", "熔岩铠甲", "寒冰法袍", "静谧长衫", "狂怒战甲", "意志披风", "龙纹战甲", "流光战衣", "深渊战甲", "永恒战甲", "信仰战甲", "狂怒长衫", "闫闫内衣"],
    pants: ["星空护腿", "玄铁战裤", "暗影皮裤", "冰晶长裤", "圣光战裤", "幽冥长裤", "疾风短裤", "大地之裤", "藤蔓短裤", "混沌护腿", "雷霆战裤", "藤蔓护腿", "幻影护腿", "守护者护腿", "黎明护腿", "幽魂护腿", "恶魔护腿", "天使护腿", "毒藤护腿", "磐石护腿", "狂怒护腿", "勇气护腿", "雷神护腿", "火神护腿", "暗夜护腿", "星光护腿", "死神护腿", "闫闫黑丝"],
    shoes: ["流光战靴", "烈焰履", "黑麒麟战靴", "神玄武战靴", "邪白虎战靴", "圣朱雀羽靴", "灭世青龙战靴", "赫光圣靴", "疾风战靴", "混沌战靴", "死神战靴", "雷神战靴", "至尊战靴", "剑圣战靴", "剑神战靴", "灭神战靴", "永恒战靴", "火迷战靴", "镭射战靴", "冥王战靴", "仙人神靴", "风暴战靴", "荣耀圣靴", "暗夜神靴", "圣飒战靴", "强韧战靴", "傲世神靴"],
    necklace: ["星空项链", "烈焰项链", "王者项链", "玄德项链", "迪虎项链", "黎明项链", "幽魂项链", "黄昏圣链", "泰坦项链", "恶魔项链", "熔岩吊坠", "寒冰吊坠", "风暴吊坠", "狂怒吊坠", "力量吊坠", "勇气项链", "至尊项链", "荣耀项链", "凤羽项链", "流光项链", "顺神项链", "风日项链", "邪神吊坠", "睡神项链", "水神项链", "敖包吊坠", "死亡项链"],
    weapon: ["万古绝尘剑", "撼天动地斧", "焚天怒焰刀", "惊鸿掠影剑", "血狱幽冥枪", "破界陨星锤", "冰封千里杖", "地狱修罗刀", "九霄龙吟剑", "噬魂夺魄刃", "乾坤逆转戟", "裂地崩山斧", "焚天炽羽弓", "玄冰锁魂镰", "紫电灭魔剑", "血饮狂刀", "雷霆碎岳锤", "万劫不灭矛", "破空穿云箭", "寒霜冻世剑", "炎狱修罗枪", "星河碎影剑", "混沌开天斧", "白虎裂山刃", "炼狱修罗爪", "破天裂穹剑", "轩辕剑", "湛泸剑", "赤霄剑", "泰阿剑", "承影剑", "干将", "莫邪", "鱼肠剑", "无影剑艾雷诺", "破碎之命运", "光炎剑", "泰拉石手枪", "永恒之枪", "潘多拉魔盒", "三叉戟", "方天画戟", "草薙剑", "圣剑格拉墨", "命运之矛", "埃癸斯之盾", "杜蕾斯", "闫闫爱心锤", "茶茶小奶瓶"]
};
const advanceCosts = [5, 10, 20, 40, 80, 160, 320]; // 进阶1-7级所需神石
const advancePrefixes = [
    "", 
    "高·", 
    "超·", 
    "圣·", 
    "仙·", 
    "神·", 
    "荒·", 
    "帝·"
];
// 初始化神器系统
function initArtifactSystem() {
    if (!player.artifacts) {
        player.artifacts = {
            fragments: 0,
            crystals: 0,
            inventory: [],
            equipped: {
                helmet: null,
                clothes: null,
                pants: null,
                shoes: null,
                necklace: null,
                weapon: null
            },
            advanceLevels: {} // 神器ID -> 进阶等级 (0-7)
        };
    }
    if (!player.artifacts.batchSelection) {
    player.artifacts.batchSelection = {
        selectedIds: [],
        filters: {
            quality: 'all',
            set: 'all',
            part: 'all'
        }
    };
}
    // 修复旧装备初始化问题
    if (!player.artifacts.advanceLevels) {
        player.artifacts.advanceLevels = {};
    }
    
    // 确保所有神器都有进阶等级
    player.artifacts.inventory.forEach(artifact => {
        if (!player.artifacts.advanceLevels[artifact.id]) {
            player.artifacts.advanceLevels[artifact.id] = 0;
        }
    });
    
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact && !player.artifacts.advanceLevels[artifact.id]) {
            player.artifacts.advanceLevels[artifact.id] = 0;
        }
    });
 player.artifacts.inventory.forEach(artifact => {
        if (!artifact.baseName) {
            artifact.baseName = artifact.name;
        }
    });
    
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact && !artifact.baseName) {
            artifact.baseName = artifact.name;
        }
    });
}
// 切换神器查看标签
function switchArtifactTab(tab) {
    const allTab = document.querySelector('.artifact-tab[onclick="switchArtifactTab(\'all\')"]');
    const setsTab = document.querySelector('.artifact-tab[onclick="switchArtifactTab(\'sets\')"]');
    
    if (tab === 'all') {
        document.getElementById('artifactInventory').style.display = 'grid';
        document.getElementById('artifactSetsView').style.display = 'none';
        allTab.classList.add('active');
        setsTab.classList.remove('active');
    } else {
        document.getElementById('artifactInventory').style.display = 'none';
        document.getElementById('artifactSetsView').style.display = 'block';
        allTab.classList.remove('active');
        setsTab.classList.add('active');
        updateArtifactSetsView();
    }
}

// 更新套装视图
function updateArtifactSetsView() {
    const container = document.getElementById('artifactSetsContainer');
    container.innerHTML = '';
    
    // 按套装分组
    const sets = {};
    player.artifacts.inventory.forEach(artifact => {
        const setName = artifact.set || '无套装';
        if (!sets[setName]) {
            sets[setName] = [];
        }
        sets[setName].push(artifact);
    });
    
    // 创建套装组
    Object.keys(sets).sort().forEach(setName => {
        const artifacts = sets[setName];
        const setGroup = document.createElement('div');
        setGroup.className = 'set-group set-collapsed';
        setGroup.id = `set-group-${setName.replace(/\s+/g, '-')}`;
        
        setGroup.innerHTML = `
            <div class="set-header" onclick="toggleSetGroup('${setName.replace(/\s+/g, '-')}')">
                <div class="set-name">${setName}</div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="set-count">${artifacts.length}件</span>
                    <span class="folder-arrow">▼</span>
                </div>
            </div>
            <div class="set-content">
                ${artifacts.map(artifact => createArtifactCardHTML(artifact)).join('')}
            </div>
        `;
        
        container.appendChild(setGroup);
    });
}

// 切换套装组展开/收起
function toggleSetGroup(setName) {
    const group = document.getElementById(`set-group-${setName}`);
    group.classList.toggle('set-collapsed');
}

// 创建神器卡片HTML（复用原有函数或创建新函数）
function createArtifactCardHTML(artifact) {
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const part = artifactParts.find(p => p.id === artifact.part);
    
    return `
        <div class="artifact-card" style="border: 2px solid ${quality.color};">
            <div style="color: ${quality.color}; font-weight: bold;">${artifact.name}</div>
            <div>${part.name}</div>
            <div style="font-size: 0.8em;">
                <div>等级: ${artifact.upgradeLevel}</div>
                <div>生命: +${(artifact.bonuses.health * 100).toFixed(1)}%</div>
                <div>攻击: +${(artifact.bonuses.attack * 100).toFixed(1)}%</div>
                <div>爆伤: +${(artifact.bonuses.critDamage * 100).toFixed(1)}%</div>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="equipArtifact('${artifact.id}')" style="background: #4CAF50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em; margin-right: 5px;">装备</button>
                <button onclick="showArtifactDetails('${artifact.id}')" style="background: #2196F3; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">详情</button>
               <button onclick="decomposeArtifactItem('${artifact.id}')" style="background: #f44336; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">分解</button>

            </div>
        </div>
    `;
}
// 切换神器系统界面
function toggleArtifactSystem() {
    if (player.reincarnationCount < 500) {
        alert("需要达到500转才能开启神器系统！");
        return;
    }
    const overlay = document.getElementById('artifactSystemOverlay');
    const ui = document.getElementById('artifactSystemUI');


    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initArtifactSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateArtifactUI();
    }
}

// 更新神器系统界面
   function updateArtifactUI() {
   

    
    // 更新装备部位
    updateArtifactSlots();
    
    // 更新神器仓库
    updateArtifactInventory();
    updateFilteredCount(); 
    // 更新套装效果
    updateSetBonuses();
}

// 更新装备部位显示
function updateArtifactSlots() {
    const slotsContainer = document.getElementById('artifactSlots');
    slotsContainer.innerHTML = '';
    
    artifactParts.forEach(part => {
        const slot = document.createElement('div');
        slot.className = 'artifact-slot';
        slot.style.border = '1px solid #d4af37';
        slot.style.padding = '10px';
        slot.style.borderRadius = '5px';
        slot.style.textAlign = 'center';
        slot.style.backgroundColor = '#222';
        
        const equippedArtifact = player.artifacts.equipped[part.id];
        
        if (equippedArtifact) {
            const quality = artifactQualities.find(q => q.id === equippedArtifact.quality);
            const set = artifactSets.find(s => s.name === equippedArtifact.set);
            
            slot.innerHTML = `
                <div style="color: ${quality.color}; font-weight: bold;">${equippedArtifact.name}</div>
                <div>${part.name}</div>
                <div style="font-size: 0.8em; margin-top: 5px;">
                    <div>等级: ${equippedArtifact.upgradeLevel}</div>
                    <div>套装: <span style="color: #d4af37;">${equippedArtifact.set}</span></div>
                    <div>生命: +${(equippedArtifact.bonuses.health * 100).toFixed(1)}%</div>
                    <div>攻击: +${(equippedArtifact.bonuses.attack * 100).toFixed(1)}%</div>
                    <div>爆伤: +${(equippedArtifact.bonuses.critDamage * 100).toFixed(1)}%</div>
                </div>
                <button onclick="unequipArtifact('${part.id}')" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">卸下</button>
            `;
        } else {
            slot.innerHTML = `
                <div>${part.name}</div>
                <div style="color: #888; font-size: 0.9em; margin-top: 5px;">未装备</div>
            `;
        }
        
        slotsContainer.appendChild(slot);
    });
}

// 更新神器仓库显示
function updateArtifactInventory() {

    const inventoryContainer = document.getElementById('artifactInventory');
    const filterContainer = document.getElementById('artifactFilterUI');
    
    // 先创建筛选界面
    if (!filterContainer) {
        createFilterUI();
    }
    
    // 获取筛选后的神器列表
    const filteredArtifacts = getFilteredArtifacts();
    
    inventoryContainer.innerHTML = '';
    
    if (filteredArtifacts.length === 0) {
        inventoryContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">没有符合条件的神器</div>';
        return;
    }
    
    // 显示批量操作按钮
    inventoryContainer.innerHTML = `
        <div style="grid-column: 1 / -1; margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <strong style="color: #d4af37;">批量操作</strong>
            <button onclick="selectAllArtifacts()" style="margin: 0 5px; padding: 5px 10px;">全选</button>
            <button onclick="deselectAllArtifacts()" style="margin: 0 5px; padding: 5px 10px;">取消全选</button>
            <button onclick="batchDecomposeArtifacts()" style="margin: 0 5px; padding: 5px 10px; background: #f44336; color: white;">批量分解选中神器 (${player.artifacts.batchSelection.selectedIds.length})</button>
            <span style="margin-left: 10px; color: #4CAF50;">选中: ${player.artifacts.batchSelection.selectedIds.length}/${filteredArtifacts.length}</span>
        </div>
    `;
    
    // 显示神器卡片
    filteredArtifacts.forEach(artifact => {
        const quality = artifactQualities.find(q => q.id === artifact.quality);
        const part = artifactParts.find(p => p.id === artifact.part);
        const isSelected = player.artifacts.batchSelection.selectedIds.includes(artifact.id);
        
        const artifactCard = document.createElement('div');
        artifactCard.className = 'artifact-card';
        artifactCard.style.border = `2px solid ${isSelected ? '#4CAF50' : quality.color}`;
        artifactCard.style.padding = '10px';
        artifactCard.style.borderRadius = '5px';
        artifactCard.style.cursor = 'pointer';
        artifactCard.style.backgroundColor = isSelected ? '#2a2a2a' : '#1a1a1a';
        artifactCard.onclick = (e) => {
            if (!e.target.closest('button')) {
                toggleArtifactSelection(artifact.id);
            }
        };
        
        artifactCard.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <input type="checkbox" ${isSelected ? 'checked' : ''} 
                       onchange="toggleArtifactSelection('${artifact.id}')"
                       style="margin-right: 10px; transform: scale(1.2);">
                <div style="color: ${quality.color}; font-weight: bold; flex-grow: 1;">${artifact.name}</div>
            </div>
            <div>${part.name} | ${quality.name}</div>
            <div style="font-size: 0.8em; margin-top: 5px;">
                <div>等级: ${artifact.upgradeLevel}</div>
                <div>套装: <span style="color: #d4af37;">${artifact.set}</span></div>
                <div>生命: +${(artifact.bonuses.health * 100).toFixed(1)}%</div>
                <div>攻击: +${(artifact.bonuses.attack * 100).toFixed(1)}%</div>
                <div>爆伤: +${(artifact.bonuses.critDamage * 100).toFixed(1)}%</div>
            </div>
            <div style="margin-top: 10px; display: flex; gap: 5px; flex-wrap: wrap;">
                <button onclick="event.stopPropagation(); showArtifactDetails('${artifact.id}')" 
                        style="background: #2196F3; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">详情</button>
                <button onclick="event.stopPropagation(); equipArtifact('${artifact.id}')" 
                        style="background: #4CAF50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">装备</button>
                <button onclick="event.stopPropagation(); upgradeArtifact('${artifact.id}')" 
                        style="background: #FF9800; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">升级</button>
                <button onclick="event.stopPropagation(); decomposeArtifactItem('${artifact.id}')" 
                        style="background: #f44336; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">分解</button>
            </div>
        `;
        
        inventoryContainer.appendChild(artifactCard);
    });
}

 function createFilterUI() {
    const artifactSystemUI = document.getElementById('artifactSystemUI');
    
    // 在神器仓库标题前插入筛选界面
    const filterHTML = `
        <div id="artifactFilterUI" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 8px;">
            <h4 style="color: #d4af37; margin-top: 0;">筛选条件</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                <div>
                    <label>品质筛选:</label>
                    <select id="qualityFilter" onchange="updateArtifactFilter('quality', this.value)" style="width: 100%; padding: 5px;">
                        <option value="all">全部品质</option>
                        ${artifactQualities.map(q => `<option value="${q.id}">${q.name}</option>`).join('')}
                    </select>
                </div>
                <div>
                    <label>套装筛选:</label>
                    <select id="setFilter" onchange="updateArtifactFilter('set', this.value)" style="width: 100%; padding: 5px;">
                        <option value="all">全部套装</option>
                        ${[...new Set(artifactSets.map(s => s.name))].map(set => `<option value="${set}">${set}</option>`).join('')}
                    </select>
                </div>
                <div>
                    <label>部位筛选:</label>
                    <select id="partFilter" onchange="updateArtifactFilter('part', this.value)" style="width: 100%; padding: 5px;">
                        <option value="all">全部部位</option>
                        ${artifactParts.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                    </select>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="clearArtifactFilters()" style="background: #666; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 10px;">清除筛选</button>
                <span style="color: #888;">当前显示: <span id="filteredCount">0</span> 个神器</span>
            </div>
        </div>
    `;
    
    const inventoryTitle = artifactSystemUI.querySelector('h7');
    inventoryTitle.insertAdjacentHTML('afterend', filterHTML);
}

// 获取筛选后的神器列表
function getFilteredArtifacts() {
    const filters = player.artifacts.batchSelection.filters;
    
    return player.artifacts.inventory.filter(artifact => {
        // 品质筛选
        if (filters.quality !== 'all' && artifact.quality !== filters.quality) {
            return false;
        }
        
        // 套装筛选
        if (filters.set !== 'all' && artifact.set !== filters.set) {
            return false;
        }
        
        // 部位筛选
        if (filters.part !== 'all' && artifact.part !== filters.part) {
            return false;
        }
        
        return true;
    });
}

// 更新筛选条件
function updateArtifactFilter(type, value) {
    player.artifacts.batchSelection.filters[type] = value;
    
    // 清空选择（因为列表改变了）
    player.artifacts.batchSelection.selectedIds = [];
    
    updateArtifactInventory();
    updateFilteredCount();
}

// 清除所有筛选条件
function clearArtifactFilters() {
    player.artifacts.batchSelection.filters = {
        quality: 'all',
        set: 'all',
        part: 'all'
    };
    
    // 重置下拉菜单
    document.getElementById('qualityFilter').value = 'all';
    document.getElementById('setFilter').value = 'all';
    document.getElementById('partFilter').value = 'all';
    
    player.artifacts.batchSelection.selectedIds = [];
    updateArtifactInventory();
    updateFilteredCount();
}

// 更新筛选计数显示
function updateFilteredCount() {
    const filteredArtifacts = getFilteredArtifacts();
    document.getElementById('filteredCount').textContent = filteredArtifacts.length;
}

// 切换神器选择状态
function toggleArtifactSelection(artifactId) {
    const index = player.artifacts.batchSelection.selectedIds.indexOf(artifactId);
    
    if (index > -1) {
        // 如果已选中，则取消选择
        player.artifacts.batchSelection.selectedIds.splice(index, 1);
    } else {
        // 如果未选中，则选择
        player.artifacts.batchSelection.selectedIds.push(artifactId);
    }
    
    updateArtifactInventory();
}

// 全选当前筛选结果
function selectAllArtifacts() {
    const filteredArtifacts = getFilteredArtifacts();
    player.artifacts.batchSelection.selectedIds = filteredArtifacts.map(artifact => artifact.id);
    updateArtifactInventory();
}

// 取消全选
function deselectAllArtifacts() {
    player.artifacts.batchSelection.selectedIds = [];
    updateArtifactInventory();
}

// 批量分解选中的神器
function batchDecomposeArtifacts() {
    const selectedIds = player.artifacts.batchSelection.selectedIds;
    
    if (selectedIds.length === 0) {
        logAction("请先选择要分解的神器", "error");
        return;
    }
    
    showCustomConfirm(`确定要批量分解 ${selectedIds.length} 个神器吗？此操作不可撤销！`, (confirmed) => {
        if (confirmed) {
            let totalFragments = 0;
            let totalCrystals = 0;
            let decomposedCount = 0;
            
            // 分解选中的神器
            selectedIds.forEach(artifactId => {
                const artifactIndex = player.artifacts.inventory.findIndex(a => a.id === artifactId);
                if (artifactIndex > -1) {
                    const artifact = player.artifacts.inventory[artifactIndex];
                    const rewards = calculateDecompositionReward(artifact);
                    
                    totalFragments += rewards.fragments;
                    totalCrystals += rewards.crystals;
                    decomposedCount++;
                    
                    // 从仓库中移除
                    player.artifacts.inventory.splice(artifactIndex, 1);
                }
            });
            
            // 添加资源
            player.exploration.resources.artifactFragment += totalFragments;
            player.exploration.resources.cosmicCrystal += totalCrystals;
            
            // 清空选择
            player.artifacts.batchSelection.selectedIds = [];
            
            // 更新显示
            updateArtifactUI();
            updateExplorationUI();
            
            // 显示分解结果
            showBatchDecompositionResult(decomposedCount, totalFragments, totalCrystals);
        }
    });
}

// 显示批量分解结果
function showBatchDecompositionResult(count, fragments, crystals) {
    const resultOverlay = document.createElement('div');
    resultOverlay.id = 'batchDecompositionResultOverlay';
    resultOverlay.style.position = 'fixed';
    resultOverlay.style.top = '0';
    resultOverlay.style.left = '0';
    resultOverlay.style.width = '100%';
    resultOverlay.style.height = '100%';
    resultOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    resultOverlay.style.zIndex = '2000';
    resultOverlay.style.display = 'flex';
    resultOverlay.style.justifyContent = 'center';
    resultOverlay.style.alignItems = 'center';
    
    const resultCard = document.createElement('div');
    resultCard.style.backgroundColor = '#1a1a1a';
    resultCard.style.padding = '30px';
    resultCard.style.borderRadius = '10px';
    resultCard.style.border = '3px solid #4CAF50';
    resultCard.style.width = '450px';
    resultCard.style.maxWidth = '90%';
    resultCard.style.textAlign = 'center';
    
    resultCard.innerHTML = `
        <h2 style="color: #4CAF50; margin-top: 0;">批量分解完成</h2>
        <div style="margin-bottom: 20px;">
            <div style="font-size: 1.2em; margin-bottom: 10px;">成功分解了 <span style="color: #4CAF50;">${count}</span> 个神器</div>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #d4af37;">获得资源</div>
            <div style="display: flex; justify-content: space-around; margin-top: 15px;">
                <div>
                    <div style="font-size: 1.2em; color: #FF9800;">${fragments}</div>
                    <div>神器碎片</div>
                </div>
                <div>
                    <div style="font-size: 1.2em; color: #2196F3;">${crystals}</div>
                    <div>宇宙晶体</div>
                </div>
            </div>
        </div>
        <button onclick="document.body.removeChild(document.getElementById('batchDecompositionResultOverlay'))" 
                style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 1.1em;">
            确认
        </button>
    `;
    
    resultOverlay.appendChild(resultCard);
    document.body.appendChild(resultOverlay);
    
    logAction(`批量分解了 ${count} 个神器，获得 ${fragments} 碎片和 ${crystals} 晶体`, "success");
}
// 更新套装效果显示
function updateSetBonuses() {
    const setContainer = document.getElementById('setBonuses');
    setContainer.innerHTML = '';
    
    // 计算当前装备的套装数量
    const setCounts = {};
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            if (!setCounts[artifact.set]) {
                setCounts[artifact.set] = 0;
            }
            setCounts[artifact.set]++;
        }
    });
    
    // 显示激活的套装效果
    Object.entries(setCounts).forEach(([setName, count]) => {
        const set = artifactSets.find(s => s.name === setName);
        if (!set) return;
        
        const setDiv = document.createElement('div');
        setDiv.style.marginBottom = '15px';
        setDiv.style.padding = '15px';
        setDiv.style.border = '1px solid #d4af37';
        setDiv.style.borderRadius = '5px';
        setDiv.style.backgroundColor = '#1a1a1a';
        
        let bonusesHtml = `<div style="font-weight: bold; color: #d4af37; font-size: 1.1em; margin-bottom: 10px;">${setName} (${count}/6)</div>`;
        
        // 显示已激活的效果
        Object.entries(set.bonuses).forEach(([pieceCount, bonus]) => {
            const pieceNum = parseInt(pieceCount);
            const isActive = count >= pieceNum;
            
            bonusesHtml += `
                <div style="margin-top: 8px; ${isActive ? 'color: #4CAF50;' : 'color: #888;'}">
                    ${isActive ? '✓ ' : ''}${pieceCount}件: ${bonus.description}
                </div>
            `;
        });
        
        setDiv.innerHTML = bonusesHtml;
        setContainer.appendChild(setDiv);
    });
    
    if (Object.keys(setCounts).length === 0) {
        setContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">未装备任何套装神器</div>';
    }
}
function showArtifactDetails(artifactId) {
   // 先移除可能已存在的详情弹窗
    const existingOverlay = document.getElementById('artifactDetailOverlay');
    if (existingOverlay) {
        document.body.removeChild(existingOverlay);
    }
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const part = artifactParts.find(p => p.id === artifact.part);
    
    // 创建详情弹窗
    const detailOverlay = document.createElement('div');
    detailOverlay.id = 'artifactDetailOverlay';
    detailOverlay.style.position = 'fixed';
    detailOverlay.style.top = '0';
    detailOverlay.style.left = '0';
    detailOverlay.style.width = '100%';
    detailOverlay.style.height = '100%';
    detailOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    detailOverlay.style.zIndex = '2000';
    detailOverlay.style.display = 'flex';
    detailOverlay.style.justifyContent = 'center';
    detailOverlay.style.alignItems = 'center';
    
    const detailCard = document.createElement('div');
    detailCard.style.backgroundColor = '#1a1a1a';
    detailCard.style.padding = '20px';
    detailCard.style.borderRadius = '10px';
    detailCard.style.border = `3px solid ${quality.color}`;
    detailCard.style.width = '400px';
    detailCard.style.maxWidth = '90%';
    
    detailCard.innerHTML = `
        <div style="text-align: right;">
            <button onclick="document.body.removeChild(document.getElementById('artifactDetailOverlay'))" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="color: ${quality.color}; font-size: 1.2em; font-weight: bold;">${artifact.name}</div>
            <div> ${part.name}</div>
            <div style="margin-top: 10px; font-size: 1.1em; color: #d4af37;">${artifact.set}套装</div>
        </div>
        <div style="margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>品质:</span>
                <span style="color: ${quality.color};">${quality.name}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>升级等级:</span>
                <span>${artifact.upgradeLevel}</span>
            </div>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #d4af37;">属性加成</div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>生命加成:</span>
                <span>+${(artifact.bonuses.health * 100).toFixed(1)}%</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>攻击加成:</span>
                <span>+${(artifact.bonuses.attack * 100).toFixed(1)}%</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>爆伤加成:</span>
                <span>+${(artifact.bonuses.critDamage * 100).toFixed(1)}%</span>
            </div>
        </div>
        <div style="display: flex; justify-content: center; gap: 10px;">
            <button onclick="equipArtifact('${artifact.id}')" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">装备</button>
            <button onclick="upgradeArtifact('${artifact.id}')" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">升级</button>
        </div>
    `;
     // 获取进阶等级
     const baseName = artifact.baseName || artifact.name;
    const advanceLevel = player.artifacts.advanceLevels[artifactId] || 0;
    
    // 更新进阶信息显示
    const advanceInfo = document.getElementById('artifactAdvanceInfo');
    const advanceBtn = document.getElementById('advanceArtifactBtn');
    advanceBtn.onclick = function() {
        advanceArtifact(artifactId);
    };
    
    if (advanceLevel < 7) {
        const cost = advanceCosts[advanceLevel];
        advanceInfo.innerHTML = `
            <div>当前进阶: ${advanceLevel}级 (${advancePrefixes[advanceLevel]}${baseName})</div>
            <div>下一进阶: ${advanceLevel + 1}级 (${advancePrefixes[advanceLevel + 1]}${baseName})</div>
            <div>消耗: ${cost} 进阶神石</div>
            <div>属性提升: ${Math.pow(2, advanceLevel + 1).toFixed(1)}倍</div>
        `;
        
        // 检查是否有足够进阶神石
        if (player.items.advanceStone >= cost) {
            advanceBtn.disabled = false;
            advanceBtn.textContent = "进阶神器";
        } else {
            advanceBtn.disabled = true;
            advanceBtn.textContent = "进阶神石不足";
        }
    } else {
        advanceInfo.innerHTML = `
            <div>当前进阶: 7级 (${advancePrefixes[7]}${baseName})</div>
            <div>已达最高进阶等级</div>
            <div>属性加成: ${Math.pow(2, 7).toFixed(1)}倍</div>
        `;
        advanceBtn.disabled = true;
        advanceBtn.textContent = "已达最高进阶";
    }

    detailOverlay.appendChild(detailCard);
    document.body.appendChild(detailOverlay);
}
function advanceArtifact(artifactId) {
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    const advanceLevel = player.artifacts.advanceLevels[artifactId] || 0;
    if (advanceLevel >= 7) return;
    
    const cost = advanceCosts[advanceLevel];
    if (player.items.advanceStone < cost) {
        logAction("进阶神石不足！", "error");
        return;
    }
    
    // 扣除进阶神石
    player.items.advanceStone -= cost;
    
    // 提升进阶等级
    player.artifacts.advanceLevels[artifactId] = advanceLevel + 1;
    
    // 更新名字前缀
    artifact.name = advancePrefixes[advanceLevel + 1] + artifact.baseName;
    
    logAction(`成功将${artifact.baseName}进阶到${advanceLevel + 1}级！`, "success");
    
    // 更新显示
    updateArtifactUI();
    showArtifactDetails(artifactId); // 重新加载详情页面
}

function decomposeArtifactItem(artifactId) {
    const artifactIndex = player.artifacts.inventory.findIndex(a => a.id === artifactId);
    if (artifactIndex === -1) return;
    
    const artifact = player.artifacts.inventory[artifactIndex];
    
    // 计算分解收益
    const decompositionRewards = calculateDecompositionReward(artifact);
    
    // 添加资源
    player.exploration.resources.artifactFragment += decompositionRewards.fragments;
    player.exploration.resources.cosmicCrystal += decompositionRewards.crystals;
    
    // 从仓库中移除神器
    player.artifacts.inventory.splice(artifactIndex, 1);
    
    // 更新UI
    updateArtifactUI();
    updateExplorationUI();
    updateArtifactSetsView();
    // 显示分解结果
    showDecompositionResult(artifact, decompositionRewards);
}

// 计算分解收益
function calculateDecompositionReward(artifact) {
    // 基础收益基于品质
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const baseRewards = {
        common: { fragments: 1, crystals: 1 },
        uncommon: { fragments: 3, crystals: 2 },
        rare: { fragments: 5, crystals: 5 },
        epic: { fragments: 8, crystals: 8 },
        legendary: { fragments: 20, crystals: 10 },
        mythic: { fragments: 50, crystals: 20 }
    };
    
    // 获取基础收益
    const base = baseRewards[artifact.quality] || baseRewards.common;
    
    // 升级加成：每级增加20%收益
    const upgradeMultiplier = 1 + (artifact.upgradeLevel * 0.2);
    
    // 套装加成：套装神器额外增加50%收益
    const setMultiplier = artifact.set ? 1.5 : 1;
    
    // 计算最终收益
    const fragments = Math.floor(base.fragments * upgradeMultiplier * setMultiplier);
    const crystals = Math.floor(base.crystals * upgradeMultiplier * setMultiplier);
    
    return { fragments, crystals };
}

// 显示分解结果
function showDecompositionResult(artifact, rewards) {
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const part = artifactParts.find(p => p.id === artifact.part);
    
    // 创建结果弹窗
    const resultOverlay = document.createElement('div');
    resultOverlay.id = 'decompositionResultOverlay';
    resultOverlay.style.position = 'fixed';
    resultOverlay.style.top = '0';
    resultOverlay.style.left = '0';
    resultOverlay.style.width = '100%';
    resultOverlay.style.height = '100%';
    resultOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    resultOverlay.style.zIndex = '2000';
    resultOverlay.style.display = 'flex';
    resultOverlay.style.justifyContent = 'center';
    resultOverlay.style.alignItems = 'center';
    
    const resultCard = document.createElement('div');
    resultCard.style.backgroundColor = '#1a1a1a';
    resultCard.style.padding = '30px';
    resultCard.style.borderRadius = '10px';
    resultCard.style.border = `3px solid ${quality.color}`;
    resultCard.style.width = '450px';
    resultCard.style.maxWidth = '90%';
    resultCard.style.textAlign = 'center';
    
    resultCard.innerHTML = `
        <h2 style="color: ${quality.color}; margin-top: 0;">分解成功</h2>
        <div style="margin-bottom: 20px;">
            <div style="font-size: 1.1em; margin-bottom: 10px;">${artifact.name} (${part.name})</div>
            <div style="color: #d4af37; margin-bottom: 10px;">${artifact.set}套装</div>
            <div>品质: <span style="color: ${quality.color};">${quality.name}</span></div>
            <div>升级等级: ${artifact.upgradeLevel}</div>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #d4af37;">获得资源</div>
            <div style="display: flex; justify-content: space-around; margin-top: 15px;">
                <div>
                    <div style="font-size: 1.2em; color: #FF9800;">${rewards.fragments}</div>
                    <div>神器碎片</div>
                </div>
                <div>
                    <div style="font-size: 1.2em; color: #2196F3;">${rewards.crystals}</div>
                    <div>宇宙晶体</div>
                </div>
            </div>
        </div>
        <button onclick="document.body.removeChild(document.getElementById('decompositionResultOverlay'))" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 1.1em;">确认</button>
    `;
    
    resultOverlay.appendChild(resultCard);
    document.body.appendChild(resultOverlay);
}


// 锻造神器
function forgeArtifact(batchCount = 1) {
    const costPerForge = 10;
    const totalCost = costPerForge * batchCount;
    
    if (player.exploration.resources.artifactFragment < totalCost) {
        logAction(`神器碎片不足！需要 ${totalCost}，当前只有 ${player.exploration.resources.artifactFragment}`, "error");
        return;
    }
    
    player.exploration.resources.artifactFragment -= totalCost;
    
    // 记录获得的各品质神器数量
    const qualityCounts = {};
    artifactQualities.forEach(q => {
        qualityCounts[q.id] = 0;
    });
    
    // 批量锻造
    for (let i = 0; i < batchCount; i++) {
        // 随机选择部位
        const part = artifactParts[Math.floor(Math.random() * artifactParts.length)];
    // 随机选择品质（概率不同）
    const qualityRoll = Math.random();
    let quality;
    if (qualityRoll < 0.7) quality = artifactQualities[0]; 
    else if (qualityRoll < 0.95) quality = artifactQualities[1]; 
    else if (qualityRoll < 0.995) quality = artifactQualities[2]; 
    else if (qualityRoll < 0.9995) quality = artifactQualities[3]; 
    else if (qualityRoll < 0.99999) quality = artifactQualities[4]; 
    else quality = artifactQualities[5]; 
      // 记录品质数量
        qualityCounts[quality.id]++;
    // 随机选择名字
    const name = artifactNames[part.id][Math.floor(Math.random() * artifactNames[part.id].length)];
    
    // 随机选择套装
    const set = artifactSets[Math.floor(Math.random() * artifactSets.length)];
    
    // 生成随机属性（在品质范围内）
    const bonuses = {
        health: (Math.random() * (quality.maxBonus - quality.minBonus) + quality.minBonus).toFixed(3),
        attack: (Math.random() * (quality.maxBonus - quality.minBonus) + quality.minBonus).toFixed(3),
        critDamage: (Math.random() * (quality.maxBonus - quality.minBonus) + quality.minBonus).toFixed(3)
    };
    
    // 创建神器
    const artifact = {
        id: 'artifact_' + Date.now() + Math.random(),
        name: name,
        baseName: name,
        part: part.id,
        quality: quality.id,
        set: set.name,
        bonuses: bonuses,
        upgradeLevel: 0,
        advanceLevel: 0
    };
    
     player.artifacts.inventory.push(artifact);
        
        // 单次锻造时显示消息
        if (batchCount === 1) {
            logAction(`成功锻造 ${quality.name}品质${part.name}：${name}`, 'success');
        }
    }
    
    // 批量锻造时显示汇总消息
    if (batchCount > 1) {
        let summaryMessage = `批量锻造 ${batchCount} 次，消耗 ${totalCost} 神器碎片，获得：`;
        
        // 添加各品质数量
        artifactQualities.forEach(q => {
            if (qualityCounts[q.id] > 0) {
                summaryMessage += `${q.name}x${qualityCounts[q.id]} `;
            }
        });
        
        logAction(summaryMessage, 'success');
    }
    
    // 更新UI
    updateArtifactUI();
   updateArtifactSetsView();
}

// 装备神器
function equipArtifact(artifactId) {
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    // 检查该部位是否已装备
    if (player.artifacts.equipped[artifact.part]) {
        // 卸下当前装备
        player.artifacts.inventory.push(player.artifacts.equipped[artifact.part]);
    }
    
    // 装备新神器
    player.artifacts.equipped[artifact.part] = artifact;
    
    // 从仓库移除
    player.artifacts.inventory = player.artifacts.inventory.filter(a => a.id !== artifactId);
    
    logAction(`装备了神器：${artifact.name}`, 'success');
   updateExplorationUI();
  updateArtifactUI();
    updatePlayerBattleStats(); // 更新玩家战斗属性
}

// 卸下神器
function unequipArtifact(part) {
    const artifact = player.artifacts.equipped[part];
    if (!artifact) return;
    
    player.artifacts.inventory.push(artifact);
    player.artifacts.equipped[part] = null;
    
    logAction(`卸下了神器：${artifact.name}`, 'success');
    updateArtifactUI();
    updatePlayerBattleStats(); // 更新玩家战斗属性
}

// 升级神器
function upgradeArtifact(artifactId) {
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    const upgradeCost = 10 * (artifact.upgradeLevel + 1);
    if (player.exploration.resources.cosmicCrystal < upgradeCost) {
        logAction(`宇宙晶体不足！需要${upgradeCost}`, "error");
        return;
    }
    
    player.exploration.resources.cosmicCrystal -= upgradeCost;
    artifact.upgradeLevel++;
    
    // 提升属性（最多提升50%）
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const maxBonus = quality.maxBonus * 100000000; // 最大提升100%
    
    Object.keys(artifact.bonuses).forEach(key => {
        const currentBonus = parseFloat(artifact.bonuses[key]);
        const upgradeAmount = Math.min(
            maxBonus - currentBonus,
            quality.maxBonus * 0.1 // 每次升级提升10%的品质上限
        );
        
        if (upgradeAmount > 0) {
            artifact.bonuses[key] = (currentBonus + upgradeAmount).toFixed(3);
        }
    });
     // 在升级成功后，检查是否有打开的详情弹窗，如果有则刷新它
    const detailOverlay = document.getElementById('artifactDetailOverlay');
    if (detailOverlay) {
        // 先关闭现有弹窗
        document.body.removeChild(detailOverlay);
        // 重新打开详情弹窗显示最新数据
        showArtifactDetails(artifactId);
    }
    logAction(`成功升级 ${artifact.name} 到 Lv.${artifact.upgradeLevel}`, 'success');
updateArtifactUI();
  updateArtifactSetsView();
}

// 计算神器总加成
function calculateArtifactBonuses() {
    const bonuses = {
        health: 0,
        attack: 0,
        critDamage: 0
    };
    
    // 累加所有装备神器的加成
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            const advanceLevel = player.artifacts.advanceLevels[artifact.id] || 0;
            const advanceMultiplier = Math.pow(2, advanceLevel);
            bonuses.health += parseFloat(artifact.bonuses.health) * advanceMultiplier;
            bonuses.attack += parseFloat(artifact.bonuses.attack) * advanceMultiplier;
            bonuses.critDamage += parseFloat(artifact.bonuses.critDamage) * advanceMultiplier;
        }
    });
    
    // 应用套装效果
    const setCounts = {};
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            if (!setCounts[artifact.set]) {
                setCounts[artifact.set] = 0;
            }
            setCounts[artifact.set]++;
        }
    });
    
    Object.entries(setCounts).forEach(([setName, count]) => {
        const set = artifactSets.find(s => s.name === setName);
        if (!set) return;
        
        Object.entries(set.bonuses).forEach(([pieceCount, bonus]) => {
            if (count >= parseInt(pieceCount)) {
                bonuses.health += bonus.health || 0;
                bonuses.attack += bonus.attack || 0;
                bonuses.critDamage += bonus.critDamage || 0;
            }
        });
    });
    
    return bonuses;
}
function initSectData() {
    if (!player.sect) {
        player.sect = {
            created: false,
            name: "",
            level: 0,
            exp: 0,
            spiritStones: 0,
            members: [],
            missions: [],
            techniques: {},
            creationTime: 0,
            maxMembers: 5
        };
    }
}

// 切换宗门系统界面
function toggleSectSystem() {
    if (player.reincarnationCount < 1000) {
        alert("需要达到1000转才能开启宗门系统！");
        return;
    }
    
    const ui = document.getElementById('sectSystemUI');
    const overlay = document.getElementById('sectSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initSectData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateSectUI();
    }
}

// 创建宗门
function createSect() {
    if (player.sect.created) {
        logAction("你已经创建过宗门了！", "error");
        return;
    }
    
    if (player.items.zongmen < 1) {
        logAction("宗门令牌不足，无法创建宗门！", "error");
        return;
    }
    
    // 消耗宗门令牌
    player.items.zongmen--;
    
    // 初始化宗门数据
    player.sect = {
        created: true,
        name: "无名宗门",
        level: 1,
        exp: 0,
        spiritStones: 1000,
        members: [],
        missions: [],
        techniques: {},
        creationTime: Date.now(),
        maxMembers: 5
    };
    
    // 自动添加掌门（玩家自己）
    player.sect.members.push({
        id: "leader",
        name: player.name,
        aptitude: "SS",
        loyalty: 100,
        status: "idle",
        joinTime: Date.now()
    });
    
    logAction("成功创建宗门！", "success");
    updateSectUI();
   updateSectNameDisplay();
}

// 更新宗门界面
function updateSectUI() {
    if (!player.sect.created) {
        document.getElementById('sectInfoContainer').innerHTML = `
            <div style="text-align: center; padding: 20px;">
                <h3 style="color: #8B4513;">尚未创建宗门</h3>
                <p>创建宗门需要消耗1个宗门令牌</p>
                <button onclick="createSect()" style="background: #8B4513; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">创建宗门</button>
            </div>
        `;
        return;
    }
    
    // 更新宗门信息
    document.getElementById('sectInfoContainer').innerHTML = `
        <div style="display: flex; justify-content: space-between;">
            <div>
                <h3 style="color: #8B4513; margin: 0;">${player.sect.name}</h3>
                <div>等级: ${player.sect.level} | 声望: ${player.sect.exp}/${getNextLevelExp()}</div>
                <div>成员: ${player.sect.members.length}/${player.sect.maxMembers}</div>
            </div>
            <div style="text-align: right;">
                <div>灵石: <span style="color: #FFD700;">${player.sect.spiritStones.toFixed(0)}</span></div>
                <div>功法数量: ${Object.keys(player.sect.techniques).length}</div>
            </div>
        </div>
    `;
     // 更新招募消耗显示
    document.getElementById('recruitCost').textContent = calculateRecruitCost().toFixed(0);
    // 更新成员列表
    updateMemberList();
    
    // 更新任务列表
    updateMissionList();
    
    // 更新功法列表
    updateTechniqueList();
    
    // 更新设置页面
    document.getElementById('sectNameInput').value = player.sect.name;
    document.getElementById('sectCreationDate').textContent = new Date(player.sect.creationTime).toLocaleDateString();
}

// 更新成员列表
function updateMemberList() {
    const container = document.getElementById('memberList');
    container.innerHTML = '';
    
    player.sect.members.forEach(member => {
        const memberCard = document.createElement('div');
        memberCard.className = 'member-card';
        memberCard.style.background = '#444';
        memberCard.style.padding = '10px';
        memberCard.style.borderRadius = '5px';
        
        // 根据资质设置颜色
        let aptitudeColor = '#ccc';
        if (member.aptitude === 'SSS') aptitudeColor = '#FFD700';
        else if (member.aptitude === 'SS') aptitudeColor = '#FF6B6B';
        else if (member.aptitude === 'S') aptitudeColor = '#4ECDC4';
        else if (member.aptitude === 'A') aptitudeColor = '#FF9FF3';
        else if (member.aptitude === 'B') aptitudeColor = '#FECA57';
        else if (member.aptitude === 'C') aptitudeColor = '#54A0FF';
        
        // 检查成员是否在任务中
        const isOnMission = member.status === 'onMission';
        
        memberCard.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
                <div style="font-weight: bold;">${member.name}</div>
                <div style="color: ${aptitudeColor};">${member.aptitude}</div>
            </div>
            <div>忠诚度: ${member.loyalty}</div>
            <div>状态: ${isOnMission ? '<span style="color: #FF9800;">任务中</span>' : '空闲'}</div>
            ${member.id !== 'leader' && !isOnMission ? `
            <button onclick="expelMember('${member.id}')" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">驱逐</button>
            <button onclick="giftMember('${member.id}')" style="background: #4CAF50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 12px; flex: 1;">赠礼</button>
            ` : ''}
        `;
        
        container.appendChild(memberCard);
    });
}
function updateSectNameDisplay() {
    const sectNameDisplay = document.getElementById('sectNameDisplay');
    
    if (player.sect && player.sect.created) {
        sectNameDisplay.textContent = `宗门: ${player.sect.name}`;
        sectNameDisplay.style.display = 'block';
    } else {
        sectNameDisplay.style.display = 'none';
    }
}
function giftMember(memberId) {
    const member = player.sect.members.find(m => m.id === memberId);
    if (!member) return;
    
    // 检查玫瑰花数量
    if (player.items.roseq < 1) {
        logAction("香囊不足！", "error");
        return;
    }
    
    // 检查忠诚度是否已达上限
    if (member.loyalty >= 100) {
        logAction(`${member.name}的忠诚度已达上限！`, "info");
        return;
    }
    
    // 消耗香囊
    player.items.roseq--;
    
    // 增加忠诚度
    member.loyalty += 5;
    if (member.loyalty > 100) member.loyalty = 100;
    
    logAction(`赠送给${member.name}一个香囊，忠诚度提升5点！`, "success");
    updateSectUI();
    updateDisplay();
}
// 招募弟子
function recruitMember() {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    if (player.sect.members.length >= player.sect.maxMembers) {
        logAction("宗门成员已满！", "error");
        return;
    }
    
    const cost = calculateRecruitCost();
    if (player.sect.spiritStones < cost) {
        logAction(`灵石不足！需要 ${cost} 灵石`, "error");
        return;
    }
    
    // 消耗灵石
    player.sect.spiritStones -= cost;
    
    // 随机生成弟子属性
    const aptitudes = ['C', 'B', 'A', 'S', 'SS', 'SSS'];
    const weights = [0.60, 0.25, 0.10, 0.039, 0.01, 0.001]; 
    
    let rand = Math.random();
    let aptitude = 'C';
    for (let i = 0; i < weights.length; i++) {
        rand -= weights[i];
        if (rand <= 0) {
            aptitude = aptitudes[i];
            break;
        }
    }
    
    // 生成随机名字
    const familyNames = ['赵', '钱', '孙', '李', '周', '吴', '郑', '王', '冯', '陈', '褚', '卫'];
    const givenNames = ['明', '华', '强', '伟', '芳', '娜', '秀英', '勇', '军', '杰', '磊', '超', '鹏', '婷'];
    const name = familyNames[Math.floor(Math.random() * familyNames.length)] + 
                 givenNames[Math.floor(Math.random() * givenNames.length)];
    
    // 添加新成员
    const newMember = {
        id: 'member_' + Date.now(),
        name: name,
        aptitude: aptitude,
        loyalty: 70 + Math.floor(Math.random() * 20), // 70-89的忠诚度
        status: 'idle',
        joinTime: Date.now()
    };
    
    player.sect.members.push(newMember);
    
    logAction(`成功招募弟子: ${name} (${aptitude}资质)`, "success");
    document.getElementById('recruitCost').textContent = calculateRecruitCost().toFixed(0);
    updateSectUI();
}

// 计算招募成本
function calculateRecruitCost() {
    return 100 * Math.pow(1.1, player.sect.members.length);
}

// 驱逐弟子
function expelMember(memberId) {
    const memberIndex = player.sect.members.findIndex(m => m.id === memberId);
    if (memberIndex === -1) return;
    
    const member = player.sect.members[memberIndex];
    
    // 移除成员
    player.sect.members.splice(memberIndex, 1);
    
    // 降低其他成员忠诚度（1-5点）
    player.sect.members.forEach(m => {
        if (m.id !== 'leader') {
            m.loyalty -= 1 + Math.floor(Math.random() * 4);
            if (m.loyalty < 0) m.loyalty = 0;
        }
    });
    
    logAction(`已驱逐弟子: ${member.name}`, "info");
    updateSectUI();
}

// 切换宗门标签页
function openSectTab(tabName) {
    // 隐藏所有标签内容
    document.querySelectorAll('.sect-tabcontent').forEach(tab => {
        tab.style.display = 'none';
    });
    
    // 移除所有标签的active类
    document.querySelectorAll('.sect-tablink').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // 显示选中的标签内容并添加active类
    document.getElementById('sect' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).style.display = 'block';
    event.currentTarget.classList.add('active');
}

// 初始化宗门任务
function initSectMissions() {
    return [
        {
            id: "gather_stones",
            name: "采集灵石",
            description: "派遣弟子前往灵脉采集灵石",
            requiredAptitude: "C",
            duration: 3600000, // 1小时
            reward: { stones: 130, exp: 50 },
            difficulty: 1
        },
        {
            id: "hunt_demon",
            name: "剿灭妖兽",
            description: "清除宗门附近的低阶妖兽",
            requiredAptitude: "B",
            duration: 7200000, // 2小时
            reward: { stones: 300, exp: 100 },
            difficulty: 2
        },
        {
            id: "explore_ruins",
            name: "探索遗迹",
            description: "探索古代修士遗留的洞府遗迹",
            requiredAptitude: "A",
            duration: 10800000, // 3小时
            reward: { stones: 600, exp: 200, itemChance: 0.3 },
            difficulty: 3
        },
        {
            id: "guard_caravan",
            name: "护送商队",
            description: "护送商队通过危险区域",
            requiredAptitude: "S",
            duration: 14400000, // 4小时
            reward: { stones: 1200, exp: 400, itemChance: 0.5 },
            difficulty: 4
        },
        {
            id: "compete_tournament",
            name: "参加论道大会",
            description: "代表宗门参加修仙界论道大会",
            requiredAptitude: "SS",
            duration: 21600000, // 6小时
            reward: { stones: 2500, exp: 800, itemChance: 0.7 },
            difficulty: 5
        },
        {
            id: "slay_ancient_demon",
            name: "讨伐上古魔头",
            description: "讨伐苏醒的上古魔头，维护修仙界和平",
            requiredAptitude: "SSS",
            duration: 43200000, // 12小时
            reward: { stones: 6500, exp: 2000, itemChance: 0.9 },
            difficulty: 6
        }
    ];
}

// 更新任务列表
function updateMissionList() {
    const missionContainer = document.getElementById('missionList');
    const activeMissionContainer = document.getElementById('activeMissionList');
    
    missionContainer.innerHTML = '';
    activeMissionContainer.innerHTML = '';
    
    // 获取任务列表
    const missions = initSectMissions();
    
    // 显示可用任务
    missions.forEach(mission => {
        const missionCard = document.createElement('div');
        missionCard.className = 'mission-card';
        missionCard.style.background = '#444';
        missionCard.style.padding = '10px';
        missionCard.style.borderRadius = '5px';
        
        missionCard.innerHTML = `
            <h4 style="margin: 0 0 10px 0; color: #8B4513;">${mission.name}</h4>
            <p style="margin: 0 0 10px 0; font-size: 0.9em;">${mission.description}</p>
            <div style="font-size: 0.9em; margin-bottom: 10px;">
                <div>要求资质: ${mission.requiredAptitude}</div>
                <div>耗时: ${formatTimes(mission.duration)}</div>
                <div>奖励: ${mission.reward.stones}灵石, ${mission.reward.exp}声望</div>
            </div>
            <button onclick="startMissionq('${mission.id}')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; width: 100%;">派遣弟子</button>
        `;
        
        missionContainer.appendChild(missionCard);
    });
    
    // 显示进行中的任务
    if (player.sect.missions.length === 0) {
        activeMissionContainer.innerHTML = '<p>当前没有进行中的任务</p>';
    } else {
        player.sect.missions.forEach(mission => {
            const missionItem = document.createElement('div');
            missionItem.style.marginBottom = '10px';
            missionItem.style.padding = '10px';
            missionItem.style.background = '#555';
            missionItem.style.borderRadius = '5px';
            
            const remaining = mission.startTime + mission.duration - Date.now();
            const progress = remaining > 0 ? 100 - (remaining / mission.duration * 100) : 100;
            
            missionItem.innerHTML = `
                <div style="display: flex; justify-content: space-between;">
                    <div>${mission.name}</div>
                    <div>${formatTimes(remaining > 0 ? remaining : 0)}</div>
                </div>
                <div style="height: 5px; background: #444; border-radius: 3px; margin-top: 5px;">
                    <div style="height: 100%; background: #8B4513; border-radius: 3px; width: ${progress}%;"></div>
                </div>
            `;
            
            activeMissionContainer.appendChild(missionItem);
        });
    }
}

// 开始任务
function startMissionq(missionId) {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    // 获取任务详情
    const missions = initSectMissions();
    const mission = missions.find(m => m.id === missionId);
    if (!mission) return;
    
    // 查找符合条件的空闲弟子
    const aptitudesOrder = { 'C': 1, 'B': 2, 'A': 3, 'S': 4, 'SS': 5, 'SSS': 6 };
    const requiredLevel = aptitudesOrder[mission.requiredAptitude];
    
    const availableMembers = player.sect.members.filter(member => 
        member.status === 'idle' && aptitudesOrder[member.aptitude] >= requiredLevel
    );
    
    if (availableMembers.length === 0) {
        logAction("没有符合条件的空闲弟子！", "error");
        return;
    }
    
    // 选择忠诚度最高的弟子
    availableMembers.sort((a, b) => b.loyalty - a.loyalty);
    const member = availableMembers[0];
    
    // 更新弟子状态
    member.status = 'onMission';
    
    // 添加任务
    player.sect.missions.push({
        id: missionId,
        name: mission.name,
        memberId: member.id,
        startTime: Date.now(),
        duration: mission.duration,
        reward: mission.reward
    });
 // 计算预计加成
    const loyaltyBonus = calculateLoyaltyBonus(member.loyalty);
    const bonusPercent = (loyaltyBonus * 100 - 100).toFixed(1);
    
    logAction(`派遣 ${member.name} 执行任务: ${mission.name} (预计忠诚度${loyaltyBonus >= 1 ? '+' : ''}${bonusPercent}%奖励)`, "success");
    updateSectUI();
    
    // 设置任务完成计时器
    setTimeout(() => completeMissionq(missionId), mission.duration);
}

function completeMissionq(missionId) {
    const missionIndex = player.sect.missions.findIndex(m => m.id === missionId);
    if (missionIndex === -1) return;
    
    const mission = player.sect.missions[missionIndex];
    const member = player.sect.members.find(m => m.id === mission.memberId);
    
    if (member) {
        // 恢复弟子状态
        member.status = 'idle';
        
      // 计算忠诚度加成/减成
        const loyaltyBonus = calculateLoyaltyBonus(member.loyalty);
        
        // 发放奖励（应用忠诚度加成）
        const stonesReward = Math.floor(mission.reward.stones * loyaltyBonus);
        const expReward = Math.floor(mission.reward.exp * loyaltyBonus);
        
        player.sect.spiritStones += stonesReward;
        player.sect.exp += expReward;
        
       if (mission.reward.itemChance && Math.random() < mission.reward.itemChance) {
            // 随机获得一种物品
            const items = ['primaryGem', 'advancedGem', 'rebornDan', 'cultivationPill'];
            const randomItem = items[Math.floor(Math.random() * items.length)];
            player.items[randomItem] = (player.items[randomItem] || 0) + 1;
            
            logAction(`${member.name}完成任务带回${getItemName(randomItem)}！(忠诚度加成: ${(loyaltyBonus * 100 - 100).toFixed(1)}%)`, "success");
        } else {
            logAction(`${member.name}完成任务，获得${stonesReward}灵石和${expReward}声望！(忠诚度加成: ${(loyaltyBonus * 100 - 100).toFixed(1)}%)`, "success");
        }
        // 根据忠诚度变化调整忠诚度
        // 高奖励会增加忠诚度，低奖励会减少忠诚度
        const loyaltyChange = Math.floor((loyaltyBonus - 1) * 5);
        member.loyalty += loyaltyChange;
        
        // 确保忠诚度在合理范围内
        if (member.loyalty < 0) member.loyalty = 0;
        if (member.loyalty > 100) member.loyalty = 100;
        
        if (loyaltyChange > 0) {
            logAction(`${member.name}的忠诚度提升了${loyaltyChange}点！`, "info");
        } else if (loyaltyChange < 0) {
            logAction(`${member.name}的忠诚度降低了${Math.abs(loyaltyChange)}点！`, "warning");
        }
        // 检查升级
        checkSectLevelUp();
        
        // 移除任务
        player.sect.missions.splice(missionIndex, 1);
        
        // 更新UI - 这会重新渲染成员列表，显示驱逐按钮
        updateSectUI();
    }
}
function calculateLoyaltyBonus(loyalty) {
    if (loyalty >= 50) {
        // 高于50忠诚度，每点增加1%奖励
        return 1 + (loyalty - 50) * 0.01;
    } else {
        // 低于50忠诚度，每点减少1%奖励
        return 1 - (50 - loyalty) * 0.01;
    }
}
// 检查宗门升级
function checkSectLevelUp() {
    const nextLevelExp = getNextLevelExp();
    if (player.sect.exp >= nextLevelExp) {
        player.sect.level++;
        player.sect.exp -= nextLevelExp;
        
        // 升级奖励
        player.sect.maxMembers += 2;
        player.sect.spiritStones += 500 * player.sect.level;
        
        logAction(`宗门升级至${player.sect.level}级！成员上限增加至${player.sect.maxMembers}`, "success");
    }
}

// 获取下一级所需经验
function getNextLevelExp() {
    return 1000 * Math.pow(1.5, player.sect.level - 1);
}

// 更新功法列表
function updateTechniqueList() {
    const container = document.getElementById('techniqueList');
    container.innerHTML = '';
    
    // 获取玩家所有功法
    const techniques = Object.keys(player.techniques).filter(t => t !== 'none');
    
    if (techniques.length === 0) {
        container.innerHTML = '<p>尚未习得任何功法</p>';
        return;
    }
    
    techniques.forEach(techId => {
        const techLevel = player.techniques[techId] || 1;
        const sectTechLevel = player.sect.techniques[techId] || 1;
        
        // 获取功法配置
        const techConfig = techniqueConfig[techId];
        const techName = techConfig ? techConfig.name : techId;
        
        // 计算当前加成效果
        const baseEffect = techConfig ? techConfig.effect : 0;
        const sectMultiplier = 1 + (sectTechLevel * 2); // 每级增加2倍效果
        const totalEffect = techLevel * baseEffect * sectMultiplier;
        
        // 格式化效果显示
        let effectDisplay = '';
        if (techConfig && techConfig.type) {
            switch (techConfig.type) {
                case 'health':
                    effectDisplay = `生命加成: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'attack':
                    effectDisplay = `攻击加成: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'critRate':
                    effectDisplay = `暴击率: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'critDamage':
                    effectDisplay = `爆伤加成: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'multiAttack':
                    effectDisplay = `连击次数: +${totalEffect.toFixed(1)}`;
                    break;
                default:
                    effectDisplay = `效果: +${(totalEffect * 100).toFixed(1)}%`;
            }
        }
        
        const techCard = document.createElement('div');
        techCard.className = 'tech-card';
        techCard.style.background = '#444';
        techCard.style.padding = '10px';
        techCard.style.borderRadius = '5px';
        
        techCard.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h4 style="margin: 0; color: #8B4513;">${techName}</h4>
                <div style="font-size: 0.9em;">宗门等级: ${sectTechLevel}</div>
            </div>
            <div style="margin: 10px 0; font-size: 0.9em;">
                <div>个人等级: ${techLevel}</div>
                <div>${effectDisplay}</div>
                <div>升级消耗: ${calculateUpgradeCost(techId).toFixed(0)}灵石</div>
            </div>
            <button onclick="upgradeTechnique('${techId}')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; width: 100%;">升级功法</button>
        `;
        
        container.appendChild(techCard);
    });
    

    
    // 更新一键升级成本
    document.getElementById('upgradeAllCost').textContent = calculateUpgradeAllCost().toFixed(0);
}

// 升级功法
function upgradeTechnique(techName) {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    const cost = calculateUpgradeCost(techName);
    if (player.sect.spiritStones < cost) {
        logAction(`灵石不足！需要 ${cost} 灵石`, "error");
        return;
    }
    
    // 消耗灵石
    player.sect.spiritStones -= cost;
    
    // 升级功法
    if (!player.sect.techniques[techName]) {
        player.sect.techniques[techName] = 1;
    } else {
        player.sect.techniques[techName]++;
    }
     
       

    logAction(`成功升级功法: ${techName} (当前宗门等级: ${player.sect.techniques[techName]})`, "success");
   updatePlayerBattleStats();
    updateSectUI();
}

// 计算功法升级成本
function calculateUpgradeCost(techName) {
    const currentLevel = player.sect.techniques[techName] || 0;
    return 100 * Math.pow(1.2, currentLevel);
}

// 一键升级所有功法
function upgradeAllTechniques() {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    const totalCost = calculateUpgradeAllCost();
    if (player.sect.spiritStones < totalCost) {
        logAction(`灵石不足！需要 ${totalCost} 灵石`, "error");
        return;
    }
    
    // 消耗灵石
    player.sect.spiritStones -= totalCost;
    
    // 升级所有功法
    Object.keys(player.techniques).forEach(techName => {
        if (techName !== 'none') {
            if (!player.sect.techniques[techName]) {
                player.sect.techniques[techName] = 1;
            } else {
                player.sect.techniques[techName]++;
            }
        }
    });
    
    logAction("成功一键升级所有功法！", "success");
   updatePlayerBattleStats();
    updateSectUI();
}

// 计算一键升级总成本
function calculateUpgradeAllCost() {
    let totalCost = 0;
    Object.keys(player.techniques).forEach(techName => {
        if (techName !== 'none') {
            totalCost += calculateUpgradeCost(techName);
        }
    });
    return totalCost;
}

// 修改宗门名称
function changeSectName() {
    const newName = document.getElementById('sectNameInput').value.trim();
    
    if (!newName) {
        logAction("宗门名称不能为空！", "error");
        return;
    }
    
    if (newName.length > 20) {
        logAction("宗门名称过长（最多20字符）！", "error");
        return;
    }
    
    player.sect.name = newName;
    logAction(`宗门名称已修改为: ${newName}`, "success");
    updateSectUI();
  updateSectNameDisplay();
}

// 解散宗门
function disbandSect() {
    if (!confirm("确定要解散宗门吗？将会失去所有宗门成员和等级！")) {
        return;
    }
    
    // 返还部分资源
    const refund = Math.floor(player.sect.spiritStones * 0.5);
    player.spiritStones += refund;
    
    // 重置宗门数据
    player.sect = {
        created: false,
        name: "",
        level: 0,
        exp: 0,
        spiritStones: 0,
        members: [],
        missions: [],
        techniques: {},
        creationTime: 0,
        maxMembers: 5
    };
    
    logAction(`宗门已解散，返还${refund}灵石`, "info");
    updateSectUI();
   updateSectNameDisplay();
}

// 辅助函数：格式化时间
function formatTimes(ms) {
    if (ms <= 0) return "已完成";
    
    const hours = Math.floor(ms / 3600000);
    const minutes = Math.floor((ms % 3600000) / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    
    return `${hours}小时 ${minutes}分钟 ${seconds}秒`;
}

// 辅助函数：获取物品名称
function getItemName(itemKey) {
    const names = {
        'superiorGem': '极品宝石',
        'baitCount': '鱼饵',
        'rebornDan': '洗髓丹',
        'companionKey': '伴侣钥匙'
    };
    return names[itemKey] || itemKey;
}

// 每秒检查任务完成情况
setInterval(() => {
    if (player.sect && player.sect.created) {
        player.sect.missions.forEach(mission => {
            if (Date.now() - mission.startTime >= mission.duration) {
                completeMissionq(mission.id);
            }
        });
    }
}, 1000);
// 夜店系统数据结构
const nightClubConfig = {
    staffTypes: [
        { id: 'waiter', name: '服务员', baseExp: 0.5, baseCoins: 0.2, expPerLevel: 0.1, coinsPerLevel: 0.05, baseCost: 10 },
        { id: 'guard', name: '保安', baseExp: 0.3, baseCoins: 0.1, expPerLevel: 0.05, coinsPerLevel: 0.03, baseCost: 8 },
        { id: 'dj', name: 'DJ师', baseExp: 1.0, baseCoins: 0.5, expPerLevel: 0.2, coinsPerLevel: 0.1, baseCost: 20 },
        { id: 'chef', name: '厨师', baseExp: 0.4, baseCoins: 0.3, expPerLevel: 0.08, coinsPerLevel: 0.07, baseCost: 15 },
        { id: 'hostess', name: '小妹', baseExp: 0.7, baseCoins: 0.4, expPerLevel: 0.15, coinsPerLevel: 0.08, baseCost: 18 }
    ],
    equipmentTypes: [
        { id: 'sound', name: '音响系统', baseBonus: 1.05, bonusPerLevel: 0.05, baseCost: 50 },
        { id: 'light', name: '灯光系统', baseBonus: 1.03, bonusPerLevel: 0.03, baseCost: 40 },
        { id: 'bar', name: '吧台', baseBonus: 1.02, bonusPerLevel: 0.02, baseCost: 30 },
        { id: 'dancefloor', name: '舞池', baseBonus: 1.04, bonusPerLevel: 0.04, baseCost: 45 }
    ],
    vipConfig: {
        baseInterval: 30, // 分钟
        baseExp: 50,
        baseCoins: 25,
        levelMultiplier: 1.1
    },
    events: [
        { 
            name: "周末狂欢夜", 
            description: "激情音乐、炫酷灯光，打造周末不眠之夜！吸引大量年轻顾客涌入，现场气氛火爆。收益：经验获取速度3倍！", 
            effect: { expMultiplier: 3.0, duration: 60 },
            cost: 100 
        },
        { 
            name: "啤酒狂欢节", 
            description: "精选全球特色啤酒买一送一，搭配德式香肠拼盘，带来纯正欧陆风情体验。收益：金币收益提升50%！", 
            effect: { coinsMultiplier: 1.5, duration: 45 },
            cost: 75 
        },
     { 
            name: "闫闫魅惑之夜", 
            description: "国际超模闫闫领衔内衣大秀，水晶舞台搭配梦幻泡泡机，打造视觉盛宴。收益：金币收益暴涨400%！", 
            effect: { coinsMultiplier: 5.0, duration: 30 },
            cost: 100 
        },
      { 
            name: "茶茶烈焰舞台", 
            description: "亚洲舞后茶茶带来全新编舞，钢管舞与灯光艺术完美融合，限定特调鸡尾酒同步上市。收益：金币收益提升150%！", 
            effect: { coinsMultiplier: 2.5, duration: 30 },
            cost: 50 
        },
    { 
            name: "午夜折扣狂欢", 
            description: "零点后所有酒水买二送一，深夜食堂特色小食买一送一，打造深夜聚会圣地。收益：金币收益提升80%！", 
            effect: { coinsMultiplier: 1.8, duration: 40 },
            cost: 70 
        },
    { 
            name: "电音风暴派对", 
            description: "国际知名DJ现场打碟，激光矩阵与干冰特效，配备专业舞池震动装置。收益：经验获取7.5倍！", 
            effect: { expMultiplier: 7.5, duration: 30 },
            cost: 100 
        },
   { 
            name: "威士忌品鉴会", 
            description: "精选单一麦芽威士忌五折畅饮，配雪茄套餐，专业品酒师现场讲解。收益：金币收益提升120%！", 
            effect: { coinsMultiplier: 2.2, duration: 35 },
            cost: 50 
        },
      { 
            name: "泳池派对季", 
            description: "屋顶泳池派对限时开放，比基尼时装秀、水上飞人表演，特调热带鸡尾酒无限供应。收益：金币收益提升200%！", 
            effect: { coinsMultiplier: 3.0, duration: 40 },
            cost: 100 
        },
      { 
            name: "精英商务酒会", 
            description: "高端雪茄吧限时开放，陈年干邑买一送一，配备私人管家服务。收益：金币收益提升180%！", 
            effect: { coinsMultiplier: 2.8, duration: 35 },
            cost: 50 
        },
      { 
            name: "校园青春派对", 
            description: "学生证专属优惠，廉价啤酒畅饮套餐，街机游戏区免费开放。收益：经验获取3.2倍！", 
            effect: { expMultiplier: 3.2, duration: 55 },
            cost: 50 
        },
     { 
            name: "极光梦幻之夜", 
            description: "全息极光投影覆盖整个场馆，搭配空灵电子音乐，打造迷幻视觉盛宴。收益：经验获取7.2倍+金币收益2.8倍！", 
            effect: { expMultiplier: 7.2, coinsMultiplier: 2.8, duration: 35 },
            cost: 150 
        },
     { 
            name: "拳王争霸观赛", 
            description: "大型投影直播拳击赛事，拳击台造型卡座，能量饮料无限供应。收益：经验获取3.3倍！", 
            effect: { expMultiplier: 3.3, duration: 45 },
            cost: 60 
        },
     { 
            name: "黑色礼服之夜", 
            description: "正式着装限定派对， 茶茶在喷泉里洗澡，交响乐团现场演奏。收益：金币收益提升220%！", 
            effect: { coinsMultiplier: 3.2, duration: 40 },
            cost: 100 
        },
     { 
            name: "热带雨林探险", 
            description: "真实植物墙与人工瀑布，丛林动物音效，特色热带鸡尾酒。收益：经验获取5.7倍+金币收益1.9倍！", 
            effect: { expMultiplier: 5.7, coinsMultiplier: 1.9, duration: 55 },
            cost: 100 
        },
      { 
            name: "魔术大师秀", 
            description: "国际魔术冠军近距离表演，神秘道具展示，魔术主题特饮。收益：金币收益提升190%！", 
            effect: { coinsMultiplier: 2.9, duration: 35 },
            cost: 100 
        },
      { 
            name: "啤酒花园节", 
            description: "露天花园派对，30种精酿啤酒品尝，德式烤肠与pretzel。收益：经验获取5.0倍！", 
            effect: { expMultiplier: 5.0, duration: 60 },
            cost: 50 
        },
      { 
            name: "1920黄金时代", 
            description: "盖茨比风格派对，女郎表演，古董车展示。收益：金币收益提升240%！", 
            effect: { coinsMultiplier: 3.4, duration: 30 },
            cost: 60 
        },
       { 
            name: "高空露台电影", 
            description: "屋顶露天电影院，经典电影放映，懒人沙发与毛毯服务。收益：经验获取2.5倍！", 
            effect: { expMultiplier: 2.5, duration: 60 },
            cost: 40 
        },
       { 
            name: "龙舌兰日出", 
            description: "墨西哥主题派对，龙舌兰shot免费续杯，墨西哥卷饼自助。收益：金币收益提升170%！", 
            effect: { coinsMultiplier: 2.7, duration: 45 },
            cost: 100 
        },
      { 
            name: "科幻赛博朋克夜", 
            description: "赛博朋克未来风装饰，VR游戏体验，发光鸡尾酒。收益：经验获取6.8倍+金币收益2.5倍！", 
            effect: { expMultiplier: 6.8, coinsMultiplier: 2.5, duration: 40 },
            cost: 150 
        },
      { 
            name: "葡萄酒庄之旅", 
            description: "纳帕谷葡萄酒品尝，奶酪拼盘无限续，品酒师讲座。收益：金币收益提升210%！", 
            effect: { coinsMultiplier: 3.1, duration: 40 },
            cost: 50 
        },
      { 
            name: "卡拉OK冠军赛", 
            description: "专业级KTV设备，歌唱比赛有奖竞猜，气泡酒免费续杯。收益：经验获取3.9倍！", 
            effect: { expMultiplier: 3.9, duration: 60 },
            cost: 60 
        },
      { 
            name: "白色派对庆典", 
            description: "全白着装主题派对，泡沫机与雪花特效，冰雕vodka吧台。收益：金币收益提升190%！", 
            effect: { coinsMultiplier: 2.9, duration: 45 },
            cost: 100 
        },
      { 
            name: "密室逃脱之夜", 
            description: "真人密室游戏联动，线索收集换优惠，神秘特调隐藏菜单。收益：经验获取4.3倍！", 
            effect: { expMultiplier: 4.3, duration: 60 },
            cost: 70 
        },
       { 
            name: "生蚝生鲜吧", 
            description: "空运新鲜生蚝半价，专业开蚝师表演，白葡萄酒搭配。收益：金币收益提升130%！", 
            effect: { coinsMultiplier: 2.3, duration: 30 },
            cost: 60 
        },
      { 
            name: "哈利波特魔法夜", 
            description: "分院帽体验，黄油啤酒特供，魔杖决斗大赛。收益：经验获取6.0倍！", 
            effect: { expMultiplier: 6.0, duration: 30 },
            cost: 200 
        },
        { 
            name: "夏日冲浪派对", 
            description: "人工波浪机体验，比基尼时装秀，热带水果鸡尾酒。收益：金币收益提升180%！", 
            effect: { coinsMultiplier: 2.8, duration: 30 },
            cost: 70 
        },
     { 
            name: "爵士灵魂之夜", 
            description: "蓝调爵士乐队演出，复古唱片点播，经典马提尼。收益：经验获取4.8倍+金币收益2.1倍！", 
            effect: { expMultiplier: 4.8, coinsMultiplier: 2.1, duration: 50 },
            cost: 200 
        },
     { 
            name: "万圣惊魂夜", 
            description: "恐怖主题装饰，化妆比赛，限量血袋鸡尾酒。收益：金币收益提升140%！", 
            effect: { coinsMultiplier: 2.4, duration: 50 },
            cost: 80 
        },
       { 
            name: "威士忌收藏家", 
            description: "稀有威士忌品尝，雪茄套餐买一送一，专家讲解。收益：金币收益提升250%！", 
            effect: { coinsMultiplier: 3.5, duration: 30 },
            cost: 120 
        },
      { 
            name: "电子竞技联赛", 
            description: "大型赛事直播，电竞椅专属区，游戏主题特饮。收益：经验获取4.4倍！", 
            effect: { expMultiplier: 4.4, duration: 50 },
            cost: 150 
        },
     { 
            name: "极限运动嘉年华", 
            description: "室内滑板表演区，攀岩墙挑战，能量饮料赞助与运动明星见面会。收益：经验获取5.9倍+金币收益2.4倍！", 
            effect: { expMultiplier: 5.9, coinsMultiplier: 2.4, duration: 45 },
            cost: 200 
        },
     { 
            name: "白色情人节", 
            description: "浪漫装饰，情侣套餐买一送一，玫瑰花瓣雨。收益：金币收益提升230%！", 
            effect: { coinsMultiplier: 3.3, duration: 30 },
            cost: 70 
        },
       { 
            name: "睡衣派对", 
            description: "舒适睡衣主题，床头鸡尾酒，枕头大战区。收益：经验获取3.3倍！", 
            effect: { expMultiplier: 3.3, duration: 40 },
            cost: 50 
        },
        { 
            name: "黑金会员专属", 
            description: "会员专属通道，稀有威士忌品尝，手工雪茄免费派送。收益：金币收益提升260%！", 
            effect: { coinsMultiplier: 3.6, duration: 30 },
            cost: 100 
        },
       { 
            name: "夏威夷草裙舞", 
            description: "草裙舞表演教学，鲜花项链迎宾，热带水果鸡尾酒。收益：金币收益提升70%！", 
            effect: { coinsMultiplier: 1.7, duration: 30 },
            cost: 60 
        },
        { 
            name: "午夜拉面食堂", 
            description: "日式拉面宵夜，清酒买一送一，午夜限定菜单。收益：金币收益提升110%！", 
            effect: { coinsMultiplier: 2.1, duration: 30 },
            cost: 70 
        },
      { 
            name: "终极单身派对", 
            description: "速配游戏活动，爱情灵药特调，约会基金抽奖。收益：金币收益提升350%！", 
            effect: { coinsMultiplier: 4.5, duration: 30 },
            cost: 100 
        },
       { 
            name: "复古迪斯科之夜", 
            description: "70年代复古装扮派对，disco球与霓虹灯装饰，经典老歌串烧狂欢。收益：经验1.8倍+金币1.6倍！", 
            effect: { expMultiplier: 1.8, coinsMultiplier: 1.6, duration: 45 },
            cost: 150 
        },
        { 
            name: "巨星闪耀夜", 
            description: "特邀顶流明星驻场表演，红毯入场仪式+签名合影环节，钻石香槟塔无限供应。收益：经验获取4倍+金币收益2倍！", 
            effect: { expMultiplier: 4.0, coinsMultiplier: 2.0, duration: 30 },
            cost: 200 
        }
    ],
    levelExpRequirements: [200, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000, 50000000, 100000000]
};

// 初始化夜店系统
function initNightClubSystem() {
    if (!player.nightClub) {
        player.nightClub = {
            level: 1,
            exp: 0,
            starCoins: 0,
            staff: nightClubConfig.staffTypes.map(type => ({
                type: type.id,
                level: 1,
                expOutput: type.baseExp,
                coinsOutput: type.baseCoins
            })),
            equipment: nightClubConfig.equipmentTypes.map(type => ({
                type: type.id,
                level: 1,
                bonus: type.baseBonus
            })),
            vip: {
                lastVisit: 0,
                nextVisit: 0
            },
            activeEvent: null,
            lastUpdate: Date.now()
        };
    }
}

// 切换夜店系统界面
function toggleNightClubSystem() {
      if (player.reincarnationCount < 600) {
        alert("需要达到600转才能开启夜店系统！");
        return;
    }
    const overlay = document.getElementById('nightClubOverlay');
    const ui = document.getElementById('nightClubUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initNightClubSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        openNightClubTab('staff');
        updateNightClubUI();
    }
}

// 切换标签页
function openNightClubTab(tabName) {
    // 隐藏所有标签内容
    const tabcontents = document.getElementsByClassName('nightclub-tabcontent');
    for (let i = 0; i < tabcontents.length; i++) {
        tabcontents[i].style.display = 'none';
    }
    
    // 移除所有标签的活动状态
    const tablinks = document.getElementsByClassName('tablink');
    for (let i = 0; i < tablinks.length; i++) {
        tablinks[i].classList.remove('active');
    }
    
    // 显示当前标签内容并添加活动类
    document.getElementById('nightClub' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).style.display = 'block';
    event.currentTarget.classList.add('active');
    
    // 更新标签内容
    if (tabName === 'staff') {
        updateStaffTab();
    } else if (tabName === 'equipment') {
        updateEquipmentTab();
    } else if (tabName === 'special') {
        updateSpecialTab();
    } else if (tabName === 'events') {
        updateEventsTab();
    }
}

// 更新夜店系统UI
function updateNightClubUI() {
    // 更新店铺信息
    document.getElementById('nightClubLevel').textContent = player.nightClub.level;
    document.getElementById('nightClubExp').textContent = player.nightClub.exp.toFixed(1);
    
    const nextLevelExp = nightClubConfig.levelExpRequirements[player.nightClub.level - 1] || 
                         nightClubConfig.levelExpRequirements[nightClubConfig.levelExpRequirements.length - 1];
    document.getElementById('nightClubExpNext').textContent = nextLevelExp;
    
    const expPercent = Math.min(100, (player.nightClub.exp / nextLevelExp) * 100);
    document.getElementById('nightClubExpBar').style.width = expPercent + '%';
    
    document.getElementById('starCoinCount').textContent = player.nightClub.starCoins.toFixed(1);
    

    // 计算每分钟收益
    let totalExpPerMin = 0;
    let totalCoinsPerMin = 0;
    
    // 店员收益
    player.nightClub.staff.forEach(staff => {
        totalExpPerMin += staff.expOutput;
        totalCoinsPerMin += staff.coinsOutput;
    });
    
    // 设备加成
    let bonusMultiplier = 1;
    player.nightClub.equipment.forEach(eq => {
        bonusMultiplier *= eq.bonus;
    });
    
    // 活动加成
    if (player.nightClub.activeEvent) {
        if (player.nightClub.activeEvent.effect.expMultiplier) {
            totalExpPerMin *= player.nightClub.activeEvent.effect.expMultiplier;
        }
        if (player.nightClub.activeEvent.effect.coinsMultiplier) {
            totalCoinsPerMin *= player.nightClub.activeEvent.effect.coinsMultiplier;
        }
    }
    
    totalExpPerMin *= bonusMultiplier;
    totalCoinsPerMin *= bonusMultiplier;
    
    document.getElementById('expPerMinuteq').textContent = totalExpPerMin.toFixed(2);
    document.getElementById('coinsPerMinute').textContent = totalCoinsPerMin.toFixed(2);
}

// 更新店员标签页
function updateStaffTab() {
    const container = document.getElementById('nightClubStaff');
    container.innerHTML = '';
    
    player.nightClub.staff.forEach(staff => {
        const config = nightClubConfig.staffTypes.find(t => t.id === staff.type);
        const cost = calculateStaffUpgradeCost(staff.type);
        
        container.innerHTML += `
            <div class="staff-card" style="background: #222; border-radius: 8px; padding: 15px; border: 1px solid #444;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 style="margin: 0; color: #9C27B0;">${config.name}</h3>
                    <span>Lv.${staff.level}</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <div>经验产出: ${staff.expOutput.toFixed(3)}/分钟</div>
                    <div>星币产出: ${staff.coinsOutput.toFixed(3)}/分钟</div>
                </div>
                <button onclick="upgradeStaff('${staff.type}')" 
                        style="width: 100%; background: ${player.nightClub.starCoins >= cost ? '#4CAF50' : '#f44336'}; 
                               color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;"
                        ${player.nightClub.starCoins < cost ? 'disabled' : ''}>
                    升级 (${cost}星币)
                </button>
            </div>
        `;
    });
}

// 计算店员升级成本
function calculateStaffUpgradeCost(staffType) {
    const staff = player.nightClub.staff.find(s => s.type === staffType);
    const config = nightClubConfig.staffTypes.find(t => t.id === staffType);
    return Math.floor(config.baseCost * Math.pow(1.5, staff.level - 1));
}

// 升级店员
function upgradeStaff(staffType) {
    const staff = player.nightClub.staff.find(s => s.type === staffType);
    const config = nightClubConfig.staffTypes.find(t => t.id === staffType);
    const cost = calculateStaffUpgradeCost(staffType);
    
    if (player.nightClub.starCoins < cost) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= cost;
    staff.level++;
    staff.expOutput = config.baseExp + (config.expPerLevel * (staff.level - 1));
    staff.coinsOutput = config.baseCoins + (config.coinsPerLevel * (staff.level - 1));
    
    logAction(`${config.name}升级到Lv.${staff.level}！`, "success");
    updateNightClubUI();
    updateStaffTab();
}

// 更新设备标签页
function updateEquipmentTab() {
    const container = document.getElementById('nightClubEquipment');
    container.innerHTML = '';
    
    player.nightClub.equipment.forEach(eq => {
        const config = nightClubConfig.equipmentTypes.find(t => t.id === eq.type);
        const cost = calculateEquipmentUpgradeCost(eq.type);
        
        container.innerHTML += `
            <div class="equipment-card" style="background: #222; border-radius: 8px; padding: 15px; border: 1px solid #444;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 style="margin: 0; color: #9C27B0;">${config.name}</h3>
                    <span>Lv.${eq.level}</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <div>全局加成: ${(eq.bonus * 100 - 100).toFixed(1)}%</div>
                </div>
                <button onclick="upgradeEquipment('${eq.type}')" 
                        style="width: 100%; background: ${player.nightClub.starCoins >= cost ? '#4CAF50' : '#f44336'}; 
                               color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;"
                        ${player.nightClub.starCoins < cost ? 'disabled' : ''}>
                    升级 (${cost}星币)
                </button>
            </div>
        `;
    });
}

// 计算设备升级成本
function calculateEquipmentUpgradeCost(eqType) {
    const eq = player.nightClub.equipment.find(e => e.type === eqType);
    const config = nightClubConfig.equipmentTypes.find(t => t.id === eqType);
    return Math.floor(config.baseCost * Math.pow(1.8, eq.level - 1));
}

// 升级设备
function upgradeEquipment(eqType) {
    const eq = player.nightClub.equipment.find(e => e.type === eqType);
    const config = nightClubConfig.equipmentTypes.find(t => t.id === eqType);
    const cost = calculateEquipmentUpgradeCost(eqType);
    
    if (player.nightClub.starCoins < cost) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= cost;
    eq.level++;
    eq.bonus = config.baseBonus + (config.bonusPerLevel * (eq.level - 1));
    
    logAction(`${config.name}升级到Lv.${eq.level}！`, "success");
    updateNightClubUI();
    updateEquipmentTab();
}

// 更新特殊人群标签页
function updateSpecialTab() {
    const container = document.getElementById('nightClubSpecial');
    const vipInfo = document.getElementById('vipInfo');
    
    // 计算VIP下次到访时间
    const now = Date.now();
    const timeSinceLastVisit = (now - player.nightClub.vip.lastVisit) / (1000 * 60); // 分钟
    const timeUntilNextVisit = Math.max(0, player.nightClub.vip.nextVisit - now);
    
    vipInfo.innerHTML = `
        <div style="margin-bottom: 10px;">
            <strong>下次VIP到访:</strong> 
            ${timeUntilNextVisit > 0 ? 
                `<span id="vipTimer">${formatTime(timeUntilNextVisit)}</span>` : 
                "VIP随时可能光临！"}
        </div>
    `;
    
    // 如果VIP即将到来，启动计时器
    if (timeUntilNextVisit > 0) {
        startVipTimer();
    }
}

// 格式化时间
function formatTime(ms) {
    const minutes = Math.floor(ms / (1000 * 60));
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    return `${minutes}分${seconds}秒`;
}

// 启动VIP计时器
function startVipTimer() {
    if (window.vipTimer) clearInterval(window.vipTimer);
    
    window.vipTimer = setInterval(() => {
        const now = Date.now();
        const timeUntilNextVisit = Math.max(0, player.nightClub.vip.nextVisit - now);
        
        if (timeUntilNextVisit <= 0) {
            clearInterval(window.vipTimer);
            document.getElementById('vipTimer').textContent = "VIP已到达！";
            triggerVipVisit();
        } else {
            document.getElementById('vipTimer').textContent = formatTime(timeUntilNextVisit);
        }
    }, 1000);
}

// 触发VIP访问
function triggerVipVisit() {
    const baseExp = nightClubConfig.vipConfig.baseExp;
    const baseCoins = nightClubConfig.vipConfig.baseCoins;
    const multiplier = Math.pow(nightClubConfig.vipConfig.levelMultiplier, player.nightClub.level - 1);
    
    const expGain = Math.floor(baseExp * multiplier);
    const coinsGain = Math.floor(baseCoins * multiplier);
    
    player.nightClub.exp += expGain;
    player.nightClub.starCoins += coinsGain;
    
    // 设置下次访问时间
    const now = Date.now();
    player.nightClub.vip.lastVisit = now;
    player.nightClub.vip.nextVisit = now + (nightClubConfig.vipConfig.baseInterval * 60 * 1000);
    
    logAction(`VIP光临！获得${expGain}经验和${coinsGain}星币！`, "success");
    updateNightClubUI();
    updateSpecialTab();
    checkNightClubLevelUp();
}

// 更新事件标签页
function updateEventsTab() {
    const container = document.getElementById('nightClubEvents');
    const currentEventDiv = document.getElementById('currentEvent');
    
    if (player.nightClub.activeEvent) {
        const timeLeft = Math.max(0, player.nightClub.activeEvent.endTime - Date.now());
        currentEventDiv.innerHTML = `
            <div style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <h4 style="margin-top: 0; color: #FFD700;">${player.nightClub.activeEvent.name}</h4>
                <p>${player.nightClub.activeEvent.description}</p>
                <div>剩余时间: ${formatTime(timeLeft)}</div>
            </div>
        `;
    } else {
        currentEventDiv.innerHTML = "<p>当前没有活跃事件</p>";
    }
}

// 触发随机事件
function triggerRandomEvent() {
    if (player.nightClub.activeEvent) {
        logAction("当前已有活跃事件！", "error");
        return;
    }
    
    const randomEvent = nightClubConfig.events[Math.floor(Math.random() * nightClubConfig.events.length)];
    
    if (player.nightClub.starCoins < randomEvent.cost) {
        logAction(`星币不足！需要${randomEvent.cost}星币`, "error");
        return;
    }
    
    player.nightClub.starCoins -= randomEvent.cost;
    player.nightClub.activeEvent = {
        name: randomEvent.name,
        description: randomEvent.description,
        effect: randomEvent.effect,
        startTime: Date.now(),
        endTime: Date.now() + (randomEvent.effect.duration * 60 * 1000)
    };
    
    logAction(`已启动事件: ${randomEvent.name}！`, "success");
    updateNightClubUI();
    updateEventsTab();
}

// 检查店铺升级
function checkNightClubLevelUp() {
    const nextLevelExp = nightClubConfig.levelExpRequirements[player.nightClub.level - 1];
    
    if (player.nightClub.exp >= nextLevelExp && player.nightClub.level < nightClubConfig.levelExpRequirements.length) {
        player.nightClub.level++;
        player.nightClub.exp -= nextLevelExp;
        logAction(`店铺升级到Lv.${player.nightClub.level}！`, "success");
        updateNightClubUI();
    }
}

// 每分钟计算夜店收益
function calculateNightClubIncome() {
    if (!player.nightClub) return;
    
    const now = Date.now();
    const elapsedMinutes = (now - player.nightClub.lastUpdate) / (1000 * 60);
    
    if (elapsedMinutes < 1) return;
    
    let totalExp = 0;
    let totalCoins = 0;
    
    // 计算店员收益
    player.nightClub.staff.forEach(staff => {
        totalExp += staff.expOutput * elapsedMinutes;
        totalCoins += staff.coinsOutput * elapsedMinutes;
    });
    
    // 应用设备加成
    let bonusMultiplier = 1;
    player.nightClub.equipment.forEach(eq => {
        bonusMultiplier *= eq.bonus;
    });
    
    // 应用活动加成
    if (player.nightClub.activeEvent) {
        if (player.nightClub.activeEvent.effect.expMultiplier) {
            totalExp *= player.nightClub.activeEvent.effect.expMultiplier;
        }
        if (player.nightClub.activeEvent.effect.coinsMultiplier) {
            totalCoins *= player.nightClub.activeEvent.effect.coinsMultiplier;
        }
        
        // 检查事件是否结束
        if (now > player.nightClub.activeEvent.endTime) {
            logAction(`事件"${player.nightClub.activeEvent.name}"已结束`, "info");
            player.nightClub.activeEvent = null;
        }
    }
    
    totalExp *= bonusMultiplier;
    totalCoins *= bonusMultiplier;
    
    player.nightClub.exp += totalExp;
    player.nightClub.starCoins += totalCoins;
    player.nightClub.lastUpdate = now;
    
    // 检查VIP访问
    if (now > player.nightClub.vip.nextVisit) {
        triggerVipVisit();
    }
    
    // 检查店铺升级
    checkNightClubLevelUp();
    
    // 更新UI（如果界面打开）
    if (document.getElementById('nightClubUI').style.display === 'block') {
        updateNightClubUI();
    }
}

// 杂货铺功能
function toggleGroceriesUI() {
if (player.reincarnationCount < 400) {
        alert("需要达到400转才能开启杂货铺！");
        return;
    }
    const ui = document.getElementById('groceriesUI');
    const overlay = document.getElementById('groceriesOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateGroceriesUI();
    }
}

function updateGroceriesUI() {
    // 更新星尘数量显示
    document.getElementById('currentStardust').textContent = player.exploration.resources.stardust;
}

function exchangeStardust(type) {
    const exchangeRates = {
        bait: { cost: 100, item: 'baitCount', amount: parseInt(document.getElementById('baitAmount').value), coinRate: 2 },
        key: { cost: 200, item: 'companionKey', amount: parseInt(document.getElementById('keyAmount').value) },
        rose: { cost: 100, item: 'rose', amount: parseInt(document.getElementById('roseAmount').value), coinRate: 20 },
        vip: { cost: 100, item: 'vipPower', amount: parseInt(document.getElementById('vipAmount').value), coinRate: 10 },
        gem: { cost: 5000, item: 'divineGem', amount: parseInt(document.getElementById('gemAmount').value) },
        root: { cost: 500, item: 'rootDetector', amount: parseInt(document.getElementById('rootAmount').value) },
        blood: { cost: 500, item: 'bloodlineDetector', amount: parseInt(document.getElementById('bloodAmount').value) },
        coin: { cost: 100, item: 'reincarnationCoin', amount: parseInt(document.getElementById('coinAmount').value), coinRate: 1000000 }
    };
    
    const config = exchangeRates[type];
    if (!config) return;
    
    // 输入验证
    if (isNaN(config.amount) || config.amount <= 0) {
        logAction("请输入有效的兑换数量！", "error");
        return;
    }
    
    const totalCost = config.cost * config.amount;
    const stardust = player.exploration.resources.stardust;
    
    if (stardust < totalCost) {
        logAction("星尘不足！", "error");
        return;
    }
    
    player.exploration.resources.stardust -= totalCost;
    
    // 修复点：所有带coinRate的物品都应用倍数
    const multiplier = config.coinRate || 1;
    const actualAmount = config.amount * multiplier;
    
    if (type === 'coin') {
        player[config.item] += actualAmount;
    } else {
        player.items[config.item] = (player.items[config.item] || 0) + actualAmount;
    }
    
    logAction(`成功兑换: ${actualAmount}${getItemName(type)}`, "success");
    updateGroceriesUI();
    updateDisplay();
    saveGame();
}

function getItemName(type) {
    const names = {
        bait: "鱼饵",
        key: "伴侣钥匙",
        rose: "玫瑰花",
        vip: "VIP能力值",
        gem: "神级宝石",
       root: "灵根检测器",
       blood: "血脉检测剂",
        coin: "转生币"
    };
    return names[type] || "物品";
}
// 切换等级系统界面
function toggleLevelSystem() {
   if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启玩家等级！");
        return;
    }
    const overlay = document.getElementById('levelSystemOverlay');
    const ui = document.getElementById('levelSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateLevelUI();
        updateDisplay();
    }
}
function ascendPlayer() {
    // 计算下次飞升所需等级
    const nextAscentionLevel = (player.level.ascentionCount + 1) * 100;
    
    // 检查是否满足飞升条件
    if (player.level.current < nextAscentionLevel) {
        logAction(`飞升需要等级${nextAscentionLevel}！当前等级${player.level.current}。`, "error");
        return;
    }
    
    // 执行飞升
    player.level.ascentionCount++;
    player.level.ascentionMultiplier *= 2; // 属性加成翻倍
    player.level.current = 1; // 等级重置为1
    player.level.exp = 0;
    player.level.nextLevelExp = 10000;
    
    // 更新加成
    player.level.clickBonus = 10 * player.level.ascentionMultiplier;
    player.level.gpsBonus = 10 * player.level.ascentionMultiplier;
    
    logAction(`飞升成功！当前飞升次数：${player.level.ascentionCount}，加成倍数：${player.level.ascentionMultiplier}`, "success");
    updateLevelUI();
    updateDisplay();
}
// 更新等级界面
function updateLevelUI() {
    document.getElementById('currentPlayerLevel').textContent = player.level.current;
    document.getElementById('currentPlayerExp').textContent = player.level.exp;
    document.getElementById('nextLevelExpq').textContent = player.level.nextLevelExp;
    document.getElementById('clickBonus').textContent = player.level.clickBonus.toFixed(0) + '倍';
    document.getElementById('gpsBonus').textContent =  player.level.gpsBonus.toFixed(0) + '倍';
     document.getElementById("ascentionCount").textContent = player.level.ascentionCount;
    document.getElementById("ascentionMultiplier").textContent = player.level.ascentionMultiplier + "倍";
    document.getElementById("nextAscentionRequirement").textContent = (player.level.ascentionCount + 1) * 100;
    const progress = (player.level.exp / player.level.nextLevelExp) * 100;
    document.getElementById('playerExpProgress').style.width = progress + '%';
}

// 升级玩家等级
function upgradePlayerLevel(amount) {
    for (let i = 0; i < amount; i++) {
        if (player.level.exp >= player.level.nextLevelExp) {
            player.level.exp -= player.level.nextLevelExp;
            player.level.current++;
            
            // 计算下一级所需经验
            player.level.nextLevelExp = 10000 * player.level.current;
            
            // 计算加成，考虑飞升倍数
            player.level.clickBonus = player.level.current * 10 * player.level.ascentionMultiplier;
            player.level.gpsBonus = player.level.current * 10 * player.level.ascentionMultiplier;
            
            logAction(`玩家等级提升至 ${player.level.current}级！`, 'success');
            
            // 检查飞升条件
            const nextAscentionLevel = (player.level.ascentionCount + 1) * 100;
            if (player.level.current === nextAscentionLevel) {
                logAction(`已达到第${player.level.ascentionCount + 1}次飞升条件，可进行飞升！`, 'info');
            }
        } else {
            logAction("经验不足，无法升级！", "error");
            break;
        }
    }
    updateLevelUI();
    updateDisplay();
}

// 添加经验
function addPlayerExp(amount) {
    player.level.exp += amount;
    
    // 检查是否可以升级
    while (player.level.exp >= player.level.nextLevelExp) {
        upgradePlayerLevel(1);
    }
    
    updateLevelUI();
}

// 宝石系统初始化
function initGemSystem() {
    if (!player.gems) {
        player.gems = {
            red: {1: 0},   // 初始化为0个1级红宝石
            blue: {1: 0},   // 初始化为0个1级蓝宝石
            black: {1: 0}  // 初始化为0个1级黑宝石

        };
    }
}

// 切换宝石系统界面
function toggleGemSystem() {
   if (player.reincarnationCount < 800) {
        alert("需要达到800转才能开启宝石系统！");
        return;
    }
    const overlay = document.getElementById('gemSystemOverlay');
    const ui = document.getElementById('gemSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initGemSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateGemUI();
    }
}

// 更新宝石界面
function updateGemUI() {
    updateGemInventory();
    updateGemBonuses();
}

// 更新宝石仓库显示
function updateGemInventory() {
    const container = document.getElementById('gemInventory');
    container.innerHTML = '';
    
    // 红宝石
    addGemTypeToUI('red', '红宝石 (攻击加成)', container);
    // 蓝宝石
    addGemTypeToUI('blue', '蓝宝石 (生命加成)', container);
    // 黑宝石
    addGemTypeToUI('black', '黑宝石 (爆伤加成)', container);

}

// 添加宝石类型到UI
function addGemTypeToUI(type, name, container) {
    const gemTypeDiv = document.createElement('div');
    gemTypeDiv.className = 'gem-type-section';
    gemTypeDiv.innerHTML = `<h4>${name}</h4>`;
    
    const gemsContainer = document.createElement('div');
    gemsContainer.style.display = 'grid';
    gemsContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
    gemsContainer.style.gap = '10px';
    gemsContainer.style.marginTop = '10px';
    
    // 显示该类型的所有宝石
    let hasGems = false;
    for (const level in player.gems[type]) {
        const count = player.gems[type][level];
        if (count > 0) {
            hasGems = true;
            const gemDiv = document.createElement('div');
            gemDiv.className = 'gem-item';
            gemDiv.innerHTML = `
                <div class="gem-icon ${type}">${type.charAt(0).toUpperCase()}</div>
                <div class="gem-level">${level}</div>
                <div>数量: ${count}</div>
                <button onclick="upgradeGem('${type}', ${level})" ${count < 3 ? 'disabled' : ''}>合成</button>
            `;
            gemsContainer.appendChild(gemDiv);
        }
    }
    
    // 如果没有宝石，显示提示
    if (!hasGems) {
        gemsContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888;">暂无宝石</div>';
    }
    
    gemTypeDiv.appendChild(gemsContainer);
    container.appendChild(gemTypeDiv);
}

// 更新宝石加成显示
function updateGemBonuses() {
    const bonuses = calculateGemBonuses();
    
    document.getElementById('attackBonus').textContent = `${bonuses.attack.toFixed(1)}%`;
    document.getElementById('healthBonus').textContent = `${bonuses.health.toFixed(1)}%`;
    document.getElementById('critDamageBonus').textContent = `${bonuses.critDamage.toFixed(1)}%`;

}


// 计算宝石总加成
function calculateGemBonuses() {
    return {
        attack: calculateGemBonus('red'),
        health: calculateGemBonus('blue'),
        critDamage: calculateGemBonus('black')


    };
}
// 计算单个宝石类型的加成
function calculateGemBonus(type) {
    let totalBonus = 0;
    
    for (const level in player.gems[type]) {
        const count = player.gems[type][level];
        const levelInt = parseInt(level);
        
        // 不同宝石类型有不同的加成计算方式
        switch (type) {
            case 'red': // 攻击加成: 100% * 2^(等级-1)
                totalBonus += count * 100 * (Math.pow(3, levelInt) - 1) / 2;
                break;
            case 'blue': // 生命加成: 5% * 2^(等级-1)
                totalBonus += count * 5 * (Math.pow(3, levelInt) - 1) / 2;
                break;
            case 'black': // 爆伤加成: 100% * 2^(等级-1)
                totalBonus += count * 100 * (Math.pow(3, levelInt) - 1) / 2;
                break;

        }
    }
    
    return totalBonus;
}

// 购买宝石
function buyGem(type, level) {
    if (player.exploration.resources.darkMatter >= 100) {
        player.exploration.resources.darkMatter -= 100;
        
        // 确保宝石类型存在
        if (!player.gems[type]) {
            player.gems[type] = {};
        }
        
        // 确保宝石等级存在
        if (!player.gems[type][level]) {
            player.gems[type][level] = 0;
        }
        
        player.gems[type][level]++;
        logAction(`购买了1个${getGemName(type)}宝石`, 'success');
        updateGemUI();
        updateDisplay();
    } else {
        logAction("暗物质不足！", "error");
    }
}

// 添加宝石
function addGem(type, level) {
    if (!player.gems[type][level]) {
        player.gems[type][level] = 0;
    }
    player.gems[type][level]++;
}

// 获取宝石名称
function getGemName(type) {
    const names = {
        red: "红",
        blue: "蓝",
        black: "黑"

    };
    return names[type] || "未知";
}

// 宝石合成
function upgradeGem(type, level) {
    const currentLevel = parseInt(level);
    const nextLevel = currentLevel + 1;
    
    // 检查是否有足够的宝石合成
    if (player.gems[type][currentLevel] >= 3) {
        player.gems[type][currentLevel] -= 3;
        
        // 如果数量为0，删除该等级
        if (player.gems[type][currentLevel] === 0) {
            delete player.gems[type][currentLevel];
        }
        
        // 添加高一级宝石
        if (!player.gems[type][nextLevel]) {
            player.gems[type][nextLevel] = 0;
        }
        player.gems[type][nextLevel]++;
        
        logAction(`成功合成${getGemName(type)}宝石 Lv.${nextLevel}`, 'success');
        updateGemUI();
    } else {
        logAction("宝石数量不足，无法合成！", "error");
    }
}
// 打开藏宝图商店
    function openTreasureShop() {
        document.getElementById('treasureShopOverlay').style.display = 'block';
        document.getElementById('treasureShopUI').style.display = 'block';
        updateGemDisplay();
    }
    
    // 关闭藏宝图商店
    function closeTreasureShop() {
        document.getElementById('treasureShopOverlay').style.display = 'none';
        document.getElementById('treasureShopUI').style.display = 'none';
    }
    
    // 更新宝石数量显示
    function updateGemDisplay() {
        document.getElementById('currentPrimaryGemqCount').textContent = player.items.primaryGemq || 0;
    }
    
    // 兑换物品函数
    function exchangeItem(type) {
        let cost, item, amount;
        
        switch(type) {
            case 1: // 玫瑰花
                cost = 1;
                item = 'rose';
                amount = 50;
                break;
            case 2: // VIP能力值
                cost = 1;
                item = 'vipPower';
                amount = 10;
                break;
            case 3: // 鱼饵
                cost = 1;
                item = 'baitCount';
                amount = 1;
                break;
            case 4: // 伴侣钥匙
                cost = 2;
                item = 'companionKey';
                amount = 1;
                break;
            case 5: // 灵根检测器
                cost = 5;
                item = 'rootDetector';
                amount = 1;
                break;
            case 6: // 血脉检测剂
                cost = 5;
                item = 'bloodlineDetector';
                amount = 1;
                break;
            case 7: // 进阶神石
                cost = 20;
                item = 'advanceStone';
                amount = 1;
                break;
           case 8: // 宗门令牌
                cost = 50;
                item = 'zongmen';
                amount = 1;
                break;
            default:
                return;
        }
        
        // 检查金币数量
        if (player.items.primaryGemq >= cost) {
            // 扣除金币
            player.items.primaryGemq -= cost;
            
            // 添加物品
            if (!player.items[item]) player.items[item] = 0;
            player.items[item] += amount;
            
            // 更新显示
            updateGemDisplay();
            updateDisplay();
            
            // 显示成功消息
            let itemName = '';
            switch(item) {
                case 'rose': itemName = '玫瑰花'; break;
                case 'vipPower': itemName = 'VIP能力值'; break;
                case 'baitCount': itemName = '鱼饵'; break;
                case 'companionKey': itemName = '伴侣钥匙'; break;
                case 'rootDetector': itemName = '灵根检测器'; break;
                case 'bloodlineDetector': itemName = '血脉检测剂'; break;
                case 'advanceStone': itemName = '进阶神石'; break;
               case 'zongmen': itemName = '宗门令牌'; break;
            }
            
            logAction(`宝藏金币成功兑换: ${amount}${itemName}`, 'success');
        } else {
            logAction('宝藏金币不足！', 'error');
        }
    }




// 藏宝图等级配置
const treasureMapLevels = [
    { level: 1, name: "一级藏宝图", monsterMinStage: 50, monsterMaxStage: 200, expReward: 10000, rewards: [
        { type: "baitCount", amount: 1 },
        { type: "companionKey", amount: 1 },
        { type: "vipPower", amount: 2 },
        { type: "rose", amount: 20 },
        { type: "primaryGem", amount: 1 },
        { type: "advancedGem", amount: 1 },
        { type: "yuzhou1", amount: 3 },
        { type: "yuzhou2", amount: 3 },
         { type: "banlv1", amount: 1 },
        { type: "banlv2", amount: 1 }
    ]},
    { level: 2, name: "二级藏宝图", monsterMinStage: 200, monsterMaxStage: 400, expReward: 50000, rewards: [
        { type: "baitCount", amount: 2 },
        { type: "companionKey", amount: 2 },
        { type: "vipPower", amount: 5 },
        { type: "rose", amount: 50 },
        { type: "advancedGem", amount: 2 },
        { type: "primaryGem", amount: 2 },
        { type: "rebornDan", amount: 3 },
        { type: "advanceStone", amount: 1 },
        { type: "yuzhou1", amount: 5 },
        { type: "yuzhou2", amount: 5 },
        { type: "banlv1", amount: 2 },
        { type: "banlv2", amount: 2 }
    ]},
    { level: 3, name: "三级藏宝图", monsterMinStage: 400, monsterMaxStage: 600, expReward: 100000, rewards: [
        { type: "baitCount", amount: 5 },
        { type: "companionKey", amount: 3 },
        { type: "vipPower", amount: 10 },
        { type: "rose", amount: 100 },
        { type: "advancedGem", amount: 3 },
        { type: "superiorGem", amount: 3 },
        { type: "rebornDan", amount: 5 },
        { type: "rootDetector", amount: 1 },
        { type: "bloodlineDetector", amount: 1 },
        { type: "advanceStone", amount: 1 },
              { type: "yuzhou1", amount: 10 },
        { type: "yuzhou2", amount: 5 },
        { type: "yuzhou3", amount: 5 },
         { type: "yuzhou4", amount: 5 },
        { type: "banlv1", amount: 5 },
        { type: "banlv2", amount: 5 },  
        { type: "banlv7", amount: 1 },
       { type: "banlv8", amount: 1 },      
      { type: "banlv9", amount: 1 }       
    ]},
    { level: 4, name: "四级藏宝图", monsterMinStage: 600, monsterMaxStage: 800, expReward: 500000, rewards: [
        { type: "baitCount", amount: 5 },
        { type: "companionKey", amount: 5 },
        { type: "vipPower", amount: 20 },
        { type: "rose", amount: 200 },
        { type: "superiorGem", amount: 3 },
        { type: "divineGem", amount: 3 },
        { type: "rebornDan", amount: 10 },
        { type: "rootDetector", amount: 3 },
        { type: "bloodlineDetector", amount: 3 },
        { type: "advanceStone", amount: 2 },
        { type: "yuzhou1", amount: 10 },
        { type: "yuzhou2", amount: 10 },
        { type: "yuzhou3", amount: 10 },
        { type: "yuzhou4", amount: 10 },
        { type: "banlv1", amount: 10 },
        { type: "banlv2", amount: 10 }, 
        { type: "banlv7", amount: 10 },
       { type: "banlv8", amount: 2 },      
      { type: "banlv9", amount: 2 }  
    ]},
    { level: 5, name: "五级藏宝图", monsterMinStage: 800, monsterMaxStage: 1000, expReward: 1000000, rewards: [
        { type: "baitCount", amount: 10 },
        { type: "companionKey", amount: 10 },
        { type: "vipPower", amount: 50 },
        { type: "rose", amount: 500 },
        { type: "superiorGem", amount: 5 },
        { type: "divineGem", amount: 5 },
        { type: "rebornDan", amount: 20 },
        { type: "rootDetector", amount: 5 },
        { type: "bloodlineDetector", amount: 5 },
       { type: "advanceStone", amount: 3 },
       { type: "yuzhou1", amount: 30 },
       { type: "yuzhou2", amount: 30 },
       { type: "yuzhou3", amount: 30 },
       { type: "yuzhou4", amount: 30 },
       { type: "banlv1", amount: 20 },
       { type: "banlv2", amount: 20 },  
         { type: "banlv7", amount: 3 },
       { type: "banlv8", amount: 3 },      
      { type: "banlv9", amount: 3 }  
    ]}
];

// 藏宝图品质配置
const treasureMapQualities = [
    { quality: 1, name: "普通", multiplier: 1.0 },
    { quality: 2, name: "精良", multiplier: 2.0 },
    { quality: 3, name: "稀有", multiplier: 3.0 },
    { quality: 4, name: "史诗", multiplier: 5.0 },
    { quality: 5, name: "传说", multiplier: 10.0 },
    { quality: 6, name: "神话", multiplier: 20.0 }
];

// 切换藏宝图系统显示
function toggleTreasureMapSystem() {
    if (player.reincarnationCount < 600) {
        alert("需要达到600转才能开启宝图系统！");
        return;
    }
    const ui = document.getElementById('treasureMapSystemUI');
    const overlay = document.getElementById('treasureMapSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateTreasureMapDisplay();
        // 初始化合成界面
    updateCraftingDisplay();
    
    // 添加选择框变化监听
    document.getElementById('craftLevel').addEventListener('change', updateCraftingDisplay);
    document.getElementById('craftQuality').addEventListener('change', updateCraftingDisplay);
    }
}

// 更新藏宝图系统显示
function updateTreasureMapDisplay() {
     // 更新钥匙数量
    document.getElementById('treasureKeyCount').textContent = player.treasure.keys;
    const container = document.getElementById('treasureMapList');
    container.innerHTML = '';
    
    if (player.treasure.maps.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888;">暂无藏宝图</div>';
        return;
    }
    
    // 按等级和品质排序
    player.treasure.maps.sort((a, b) => {
        if (a.level !== b.level) return b.level - a.level;
        return b.quality - a.quality;
    });
    
    player.treasure.maps.forEach((map, index) => {
        const levelConfig = treasureMapLevels.find(l => l.level === map.level);
        const qualityConfig = treasureMapQualities.find(q => q.quality === map.quality);
        
        const card = document.createElement('div');
        card.style.background = '#444';
        card.style.padding = '10px';
        card.style.borderRadius = '5px';
        card.style.border = `2px solid ${map.quality >= 4 ? '#d4af37' : '#4CAF50'}`;
        
        card.innerHTML = `
            <div style="font-weight: bold; color: ${map.quality >= 4 ? '#d4af37' : '#4CAF50'};">${levelConfig.name}</div>
            <div>品质: ${qualityConfig.name} (x${qualityConfig.multiplier})</div>
            <div>获得时间: ${new Date(map.obtainedAt).toLocaleDateString()}</div>
            <button onclick="useTreasureMap(${index})" style="margin-top: 10px; width: 100%; background: #2196F3; color: white; border: none; padding: 5px; border-radius: 3px; cursor: pointer;">使用</button>
        `;
        
        container.appendChild(card);
    });
    
    // 更新合成界面
    updateCraftingDisplay();
}

// 兑换藏宝图钥匙
function buyTreasureKey() {
    if (player.exploration.resources.stardust < 100) {
        logAction("星尘不足！", "error");
        return;
    }
    
    player.exploration.resources.stardust -= 100;
    player.treasure.keys++;
    updateTreasureMapDisplay();
    logAction("成功兑换1个藏宝图钥匙", "success");
}
function buyTreasureKey1() {
    if (player.nightClub.starCoins < 100) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 100;
    player.treasure.keys++;
    updateTreasureMapDisplay();
    logAction("成功兑换1个藏宝图钥匙", "success");
}
function buyTreasureKey2() {
    if (player.nightClub.starCoins < 1000) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 1000;
    player.treasure.keys+=10;
    updateTreasureMapDisplay();
    logAction("成功兑换10个藏宝图钥匙", "success");
}
function buyTreasureKey3() {
    if (player.nightClub.starCoins < 5000) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 5000;
    player.treasure.keys+=50;
    updateTreasureMapDisplay();
    logAction("成功兑换50个藏宝图钥匙", "success");
}
function openTreasureChestBatch(count) {
    if (player.treasure.keys < count) {
        logAction(`藏宝图钥匙不足！需要${count}个钥匙`, "error");
        return;
    }
    
    player.treasure.keys -= count;
    
    // 统计获得的藏宝图
    const results = {
        total: 0,
        byLevel: {},
        byQuality: {}
    };
    
    for (let i = 0; i < count; i++) {
        // 随机生成藏宝图等级
        const levelRand = Math.random();
        let level;
        if (levelRand < 0.7) level = 1;
        else if (levelRand < 0.92) level = 2;
        else if (levelRand < 0.98) level = 3;
        else if (levelRand < 0.995) level = 4;
        else level = 5;
        
        // 随机生成藏宝图品质
        const qualityRand = Math.random();
        let quality;
        if (qualityRand < 0.7) quality = 1;
        else if (qualityRand < 0.95) quality = 2;
        else if (qualityRand < 0.99889) quality = 3;
        else if (qualityRand < 0.99989) quality = 4;
        else if (qualityRand < 0.99999) quality = 5;
        else quality = 6;
        
        // 创建藏宝图
        const newMap = {
            level: level,
            quality: quality,
            obtainedAt: Date.now()
        };
        
        player.treasure.maps.push(newMap);
        
        // 统计结果
        results.total++;
        results.byLevel[level] = (results.byLevel[level] || 0) + 1;
        results.byQuality[quality] = (results.byQuality[quality] || 0) + 1;
    }
    
    // 更新显示
    updateTreasureMapDisplay();
    
    // 生成汇总消息
    let message = `批量开启了${count}个宝箱，获得${results.total}张藏宝图：`;
    
    // 按等级统计
    message += " 等级分布:";
    for (let lvl = 1; lvl <= 5; lvl++) {
        if (results.byLevel[lvl]) {
            const levelName = treasureMapLevels.find(l => l.level === lvl).name;
            message += ` ${levelName}×${results.byLevel[lvl]}`;
        }
    }
    
    // 按品质统计
    message += " 品质分布:";
    for (let q = 1; q <= 6; q++) {
        if (results.byQuality[q]) {
            const qualityName = treasureMapQualities.find(qual => qual.quality === q).name;
            message += ` ${qualityName}×${results.byQuality[q]}`;
        }
    }
    
    logAction(message, 'success');
}




// 开启藏宝图宝箱
function openTreasureChest() {
    if (player.treasure.keys < 1) {
        logAction("藏宝图钥匙不足！", "error");
        return;
    }
    
    player.treasure.keys--;
    
    // 随机生成藏宝图等级
    const levelRand = Math.random();
    let level;
    if (levelRand < 0.7) level = 1;
    else if (levelRand < 0.92) level = 2;
    else if (levelRand < 0.98) level = 3;
    else if (levelRand < 0.995) level = 4;
    else level = 5;
    
    // 随机生成藏宝图品质
    const qualityRand = Math.random();
    let quality;
    if (qualityRand < 0.7) quality = 1;
    else if (qualityRand < 0.95) quality = 2;
    else if (qualityRand < 0.99889) quality = 3;
    else if (qualityRand < 0.99989) quality = 4;
    else if (qualityRand < 0.99999) quality = 5;
    else quality = 6;
    
    // 创建藏宝图
    const newMap = {
        level: level,
        quality: quality,
        obtainedAt: Date.now()
    };
    
    player.treasure.maps.push(newMap);
    updateTreasureMapDisplay();
    
    const levelName = treasureMapLevels.find(l => l.level === level).name;
    const qualityName = treasureMapQualities.find(q => q.quality === quality).name;
    logAction(`获得${levelName}（${qualityName}品质）`, "success");
}
function updateCraftingDisplay() {
    const levelSelect = document.getElementById('craftLevel');
    const qualitySelect = document.getElementById('craftQuality');
    const countDisplay = document.getElementById('craftCount');
    
    if (!levelSelect || !qualitySelect || !countDisplay) return;
    
    // 获取当前选择的等级和品质
    const selectedLevel = parseInt(levelSelect.value);
    const selectedQuality = parseInt(qualitySelect.value);
    
    // 计算当前拥有的符合条件的藏宝图数量
    const count = player.treasure.maps.filter(map => 
        map.level === selectedLevel && map.quality === selectedQuality
    ).length;
    
    countDisplay.textContent = count;
    
    // 更新品质选择框，隐藏无法合成的选项（神话品质）
    while (qualitySelect.options.length > 0) {
        qualitySelect.remove(0);
    }
    
    const maxQuality = 5; // 最高可合成到传说品质
    for (let q = 1; q <= maxQuality; q++) {
        const option = document.createElement('option');
        option.value = q;
        option.textContent = treasureMapQualities.find(qual => qual.quality === q).name;
        qualitySelect.appendChild(option);
    }
    
    // 恢复之前的选择
    qualitySelect.value = Math.min(selectedQuality, maxQuality);
}

// 合成藏宝图
function craftTreasureMap() {
    const level = parseInt(document.getElementById('craftLevel').value);
    const quality = parseInt(document.getElementById('craftQuality').value);
    
    // 检查是否可以合成（神话品质无法继续合成）
    if (quality >= 6) {
        logAction("神话品质无法继续合成！", "error");
        return;
    }
    
    // 获取符合条件的藏宝图
    const matchingMaps = player.treasure.maps.filter(map => 
        map.level === level && map.quality === quality
    );
    
    // 检查数量是否足够
    if (matchingMaps.length < 2) {
        logAction(`需要2张${treasureMapLevels.find(l => l.level === level).name}（${treasureMapQualities.find(q => q.quality === quality).name}品质）才能合成！`, "error");
        return;
    }
    
    // 移除2张原材料
    for (let i = 0; i < 2; i++) {
        const index = player.treasure.maps.findIndex(map => 
            map.level === level && map.quality === quality
        );
        if (index !== -1) {
            player.treasure.maps.splice(index, 1);
        }
    }
    
    // 添加1张更高品质的同等级藏宝图
    const newMap = {
        level: level,
        quality: quality + 1,
        obtainedAt: Date.now()
    };
    
    player.treasure.maps.push(newMap);
    
    // 更新显示
    updateTreasureMapDisplay();
    updateCraftingDisplay();
    
    const levelName = treasureMapLevels.find(l => l.level === level).name;
    const oldQualityName = treasureMapQualities.find(q => q.quality === quality).name;
    const newQualityName = treasureMapQualities.find(q => q.quality === quality + 1).name;
    
    logAction(`成功将2张${levelName}（${oldQualityName}品质）合成为1张${levelName}（${newQualityName}品质）`, "success");
}

// 一键合成全部可合成的藏宝图
function craftAllTreasureMaps() {
    let craftedCount = 0;
    
    // 遍历所有等级和品质（除了神话品质）
    for (let level = 1; level <= 5; level++) {
        for (let quality = 1; quality <= 5; quality++) { // 最高合成到传说品质
            let craftedInThisCategory = 0;
            
            // 获取符合条件的藏宝图
            const matchingMaps = player.treasure.maps.filter(map => 
                map.level === level && map.quality === quality
            );
            
            // 计算可合成的次数
            const craftTimes = Math.floor(matchingMaps.length / 2);
            
            if (craftTimes > 0) {
                // 移除原材料
                for (let i = 0; i < craftTimes * 2; i++) {
                    const index = player.treasure.maps.findIndex(map => 
                        map.level === level && map.quality === quality
                    );
                    if (index !== -1) {
                        player.treasure.maps.splice(index, 1);
                    }
                }
                
                // 添加合成后的藏宝图
                for (let i = 0; i < craftTimes; i++) {
                    const newMap = {
                        level: level,
                        quality: quality + 1,
                        obtainedAt: Date.now()
                    };
                    player.treasure.maps.push(newMap);
                    craftedCount++;
                }
                
                craftedInThisCategory += craftTimes;
            }
            
            if (craftedInThisCategory > 0) {
                const levelName = treasureMapLevels.find(l => l.level === level).name;
                const oldQualityName = treasureMapQualities.find(q => q.quality === quality).name;
                const newQualityName = treasureMapQualities.find(q => q.quality === quality + 1).name;
                
                logAction(`一键合成了${craftedInThisCategory}组${levelName}（${oldQualityName}品质）→ ${levelName}（${newQualityName}品质）`, "info");
            }
        }
    }
    
    if (craftedCount > 0) {
        logAction(`一键合成完成，共合成${craftedCount}张藏宝图`, "success");
    } else {
        logAction("没有可合成的藏宝图", "info");
    }
    
    // 更新显示
    updateTreasureMapDisplay();
    updateCraftingDisplay();
}




// 使用藏宝图
function useTreasureMap(index) {
    if (index < 0 || index >= player.treasure.maps.length) return;
    
    const map = player.treasure.maps[index];
    const levelConfig = treasureMapLevels.find(l => l.level === map.level);
    const qualityConfig = treasureMapQualities.find(q => q.quality === map.quality);
    
    // 移除藏宝图
    player.treasure.maps.splice(index, 1);
    updateTreasureMapDisplay();
    
    // 随机决定事件类型
    const eventRand = Math.random();
    
    if (eventRand < 0.6) {
        // 60% 遇到怪物
        startTreasureBattle(map);
    } else if (eventRand < 0.8) {
        // 20% 直接获得奖励
        giveTreasureRewards(map, false);
    } else {
        // 20% 没有奖励
        showTreasureReward("没有获得任何奖励");
    }
}

function generateTreasureMonster(minStage, maxStage) {
    // 随机选择关卡
    const stage = Math.floor(Math.random() * (maxStage - minStage + 1)) + minStage;
    
    // 复制打怪模式的属性生成逻辑
    const monsterRanks = ['普通', '精英', '普通BOSS', '特殊BOSS', '领主BOSS', '霸主级BOSS', '王级BOSS', '皇级BOSS', '帝级BOSS', '神级BOSS', '圣级BOSS'];
    const rankProbabilities = [0.45, 0.20, 0.10, 0.06, 0.05, 0.04, 0.03, 0.03, 0.02, 0.015, 0.005];
    
    // 随机生成怪物品阶
    let rankIndex = 0;
    let rand = Math.random();
    for (let i = 0; i < rankProbabilities.length; i++) {
        rand -= rankProbabilities[i];
        if (rand < 0) {
            rankIndex = i;
            break;
        }
    }
    const rank = monsterRanks[rankIndex];
    
    // 根据品阶选择词条
    const modifierPool = monsterRankModifiers[rank].pool;
    const selectCount = monsterRankModifiers[rank].selectCount;
    const selectedModifiers = [];
    const usedModifiers = new Set();
    
    for (let i = 0; i < selectCount; i++) {
        let modifier;
        do {
            modifier = modifierPool[Math.floor(Math.random() * modifierPool.length)];
        } while (usedModifiers.has(modifier));
        usedModifiers.add(modifier);
        selectedModifiers.push(modifier);
    }
    
    // 计算怪物属性
    const healthMultiplier = Math.pow(2, stage);
    let attackMultiplier;
  
    if (stage <= 5) {
        attackMultiplier = Math.floor(Math.random() * 3) + 1;
    } else if (stage <= 15) {
        attackMultiplier = 35 + (stage - 10) * 10;
    } else if (stage <= 25) {
        attackMultiplier = 50 + (stage - 10) * 10;
    } else if (stage <= 40) {
        attackMultiplier = 100 + (stage - 10) * 1000;
    } else if (stage <= 65) {
        attackMultiplier = 1000 + (stage - 9) * 10000;
    } else if (stage <= 90) {
        attackMultiplier = 3500 + (stage - 64) * 1000000;
    } else if (stage <= 120) {
        attackMultiplier = 35000 + (stage - 89) * 100000000;
    } else if (stage <= 250) {
        attackMultiplier = 350000 + (stage - 119) * 1000000000000;
    } else if (stage <= 350) {
        attackMultiplier = 3500000 + (stage - 249) * 10000000000000000;
    } else if (stage <= 450) {
        attackMultiplier = 450000000 + (stage - 349) * 100000000000000000000;
    } else if (stage <= 550) {
        attackMultiplier = 5500009000 + (stage - 449) * 10000000000000000000000000;
    } else if (stage <= 650) {
        attackMultiplier = 650000000900 + (stage - 549) * 1000000000000000000000000000000;
    } else if (stage <= 700) {
        attackMultiplier = 6500000000900 + (stage - 649) * 10000000000000000000000000000000000000;
    } else if (stage <= 750) {
        attackMultiplier = 6500000000000900 + (stage - 699) * 100000000000000000000000000000000000000000;
    } else if (stage <= 790) {
        attackMultiplier = 6500000000000000900 + (stage - 549) * 100000000000000000000000000000000000000000000000;
    } else if (stage <= 820) {
        attackMultiplier = 65000000000000000000900 + (stage - 549) * 100000000000000000000000000000000000000000000000000000;
    } else if (stage <= 840) {
        attackMultiplier = 6500000000000000000000000900 + (stage - 549) * 100000000000000000000000000000000000000000000000000000000000000;
    } else if (stage <= 860) {
        attackMultiplier = 10000000000000000000000000000000 + (stage - 649) * 100000000000000000000000000000000000000000000000000000000000000000000000000;
    } else if (stage <= 900) {
        attackMultiplier = 100000000000000000000000000000000000 + (stage - 749) * 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    } else {
        attackMultiplier = 1000000000000000000000000000000000000000 + (stage - 849) * 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    }
    
    // 应用词条效果
    let attack = attackMultiplier;
    let damageReduction = 0;
    let dodgeChance = 0;
    let blockCount = 0;
    let attackCount = 1;
    let damageTakenMultiplier = 1;
    
    selectedModifiers.forEach(modifier => {
        const effect = monsterModifiers[modifier];
        if (effect.attackMultiplier) attack *= effect.attackMultiplier;
        if (effect.damageReduction) damageReduction += effect.damageReduction;
        if (effect.dodgeChance) dodgeChance += effect.dodgeChance;
        if (effect.blockCount) blockCount += effect.blockCount;
        if (effect.attackCount) attackCount = effect.attackCount;
        if (effect.damageTakenMultiplier) damageTakenMultiplier *= effect.damageTakenMultiplier;
    });
    
    // 生成怪物
    return {
        name: "宝藏守卫者",
        rank: rank,
        health: 10000 * healthMultiplier,
        attack: attack,
        modifiers: selectedModifiers,
        damageReduction: damageReduction,
        dodgeChance: dodgeChance,
        blockCount: blockCount,
        attackCount: attackCount,
        damageTakenMultiplier: damageTakenMultiplier
    };
}

// 在宝藏守卫者战斗中使用独立的属性生成
function startTreasureBattle(map) {
    const levelConfig = treasureMapLevels.find(l => l.level === map.level);
    
    // 使用独立的属性生成函数
    const monster = generateTreasureMonster(levelConfig.monsterMinStage, levelConfig.monsterMaxStage);
    
    // 保存战斗信息
    player.treasure.currentBattle = {
        map: map,
        monster: monster,
        playerHealth: player.battle.playerHealth,
        playerAttack: player.battle.playerAttack,
        playerCritRate: player.battle.playerCritRate,
        playerCritDamage: player.battle.playerCritDamage,
        battleEnded: false
    };
    
    // 更新战斗界面
    document.getElementById('treasurePlayerHealth').textContent = player.battle.playerHealth.toExponential(3);
    document.getElementById('treasurePlayerAttack').textContent = player.battle.playerAttack.toExponential(3);
    document.getElementById('treasurePlayerCritRate').textContent = (player.battle.playerCritRate * 100).toFixed(1) + "%";
    document.getElementById('treasurePlayerCritDamage').textContent = (player.battle.playerCritDamage * 100).toFixed(1) + "%";
    
    document.getElementById('treasureMonsterName').textContent = monster.name;
    document.getElementById('treasureMonsterRank').textContent = monster.rank;
    document.getElementById('treasureMonsterHealth').textContent = monster.health.toExponential(3);
    document.getElementById('treasureMonsterAttack').textContent = monster.attack.toExponential(3);
    document.getElementById('treasureMonsterModifiers').textContent = monster.modifiers.join(', ') || '无';
    
    document.getElementById('treasureBattleLog').innerHTML = "";
    
    // 显示战斗界面
    document.getElementById('treasureBattleOverlay').style.display = 'block';
    document.getElementById('treasureBattleUI').style.display = 'block';
}

// 攻击宝藏守卫者
function attackTreasureMonster() {
    if (!player.treasure.currentBattle) return;
    
    const battle = player.treasure.currentBattle;
   if (!battle || battle.battleEnded) return; // 检查战斗是否结束
    const logContainer = document.getElementById('treasureBattleLog');
    
    // 玩家攻击
    let playerDamage = battle.playerAttack;
    
    // 暴击判断
    if (Math.random() < battle.playerCritRate) {
        playerDamage *= battle.playerCritDamage;
        logContainer.innerHTML += `<div>你发动暴击，造成${Math.floor(playerDamage)}点伤害！</div>`;
    } else {
        logContainer.innerHTML += `<div>你造成${Math.floor(playerDamage)}点伤害</div>`;
    }
    
    battle.monster.health -= playerDamage;
    document.getElementById('treasureMonsterHealth').textContent = Math.max(0, battle.monster.health);
    
    // 检查怪物是否被击败
    if (battle.monster.health <= 0) {
        logContainer.innerHTML += `<div style="color: #4CAF50;">你击败了宝藏守卫者！</div>`;
        battle.battleEnded = true; // 标记战斗结束
        
        // 禁用攻击按钮
        const attackBtn = document.querySelector('#treasureBattleUI button');
        if (attackBtn) {
            attackBtn.disabled = true;
            attackBtn.style.background = '#999';
        }
        setTimeout(() => {
            giveTreasureRewards(battle.map, true);
            closeTreasureBattle();
           updateTreasureBattleStatus();
        }, 1000);
        return;
    }
    
    // 怪物反击
    let monsterDamage = battle.monster.attack;
    battle.playerHealth -= monsterDamage;
    document.getElementById('treasurePlayerHealth').textContent = Math.max(0, battle.playerHealth);
    logContainer.innerHTML += `<div>宝藏守卫者对你造成${Math.floor(monsterDamage)}点伤害</div>`;
    
    // 滚动到底部
    logContainer.scrollTop = logContainer.scrollHeight;
    
    // 检查玩家是否被击败
    if (battle.playerHealth <= 0) {
        logContainer.innerHTML += `<div style="color: #f44336;">你被宝藏守卫者击败了！</div>`;
          battle.battleEnded = true; // 标记战斗结束
        
        // 禁用攻击按钮
        const attackBtn = document.querySelector('#treasureBattleUI button');
        if (attackBtn) {
            attackBtn.disabled = true;
            attackBtn.style.background = '#999';
        }
        setTimeout(() => {
            showTreasureReward("战斗失败，没有获得任何奖励");
            closeTreasureBattle();     
        }, 1000);
    }
}

// 关闭宝藏战斗界面
function closeTreasureBattle() {
    document.getElementById('treasureBattleOverlay').style.display = 'none';
    document.getElementById('treasureBattleUI').style.display = 'none';
    player.treasure.currentBattle = null;
  const attackBtn = document.querySelector('#treasureBattleUI button');
        if (attackBtn) {
            attackBtn.disabled = false;
            attackBtn.style.background = '#999';
        }
}

// 给予藏宝图奖励
function giveTreasureRewards(map, isBattleWin) {
    const levelConfig = treasureMapLevels.find(l => l.level === map.level);
    const qualityConfig = treasureMapQualities.find(q => q.quality === map.quality);
    
    let rewardText = "";
    
    if (isBattleWin) {
        // 战斗胜利奖励：修仙经验
        const exp = levelConfig.expReward * qualityConfig.multiplier;
        player.cultivation.exp += exp;
      
        rewardText = `战斗胜利！获得${exp}点修仙经验`;
    if (Math.random() < 0.1) {
            player.items.roseq = (player.items.roseq || 0) + 1;
            rewardText += "<br>获得香囊x1！";
        }
    if (Math.random() < 0.1) {
            player.items.primaryGemq = (player.items.primaryGemq || 0) + 1;
            rewardText += "<br>获得宝藏金币x1！";
        }
    } else {
        // 直接获得奖励：随机选择2个奖励
        const rewards = [];
        const rewardCount = 2;
        
        for (let i = 0; i < rewardCount; i++) {
            const rewardIndex = Math.floor(Math.random() * levelConfig.rewards.length);
            const reward = levelConfig.rewards[rewardIndex];
            const amount = Math.ceil(reward.amount * qualityConfig.multiplier);
            
            // 添加奖励到玩家物品
            player.items[reward.type] = (player.items[reward.type] || 0) + amount;
            
            // 获取奖励名称
            let rewardName = "";
            switch (reward.type) {
                case "baitCount": rewardName = "鱼饵"; break;
                case "companionKey": rewardName = "伴侣钥匙"; break;
                case "vipPower": rewardName = "VIP能力值"; break;
                case "rose": rewardName = "玫瑰花"; break;
                case "primaryGem": rewardName = "初级宝石"; break;
                case "advancedGem": rewardName = "高级宝石"; break;
                case "superiorGem": rewardName = "极品宝石"; break;
                case "divineGem": rewardName = "神级宝石"; break;
                case "rebornDan": rewardName = "洗髓丹"; break;
                case "rootDetector": rewardName = "灵根检测器"; break;
                case "bloodlineDetector": rewardName = "血脉检测剂"; break;
              case "advanceStone": rewardName = "进阶神石"; break;
             case "yuzhou1": rewardName = "星尘发票"; break;
                case "yuzhou2": rewardName = "暗物质发票"; break;
                case "yuzhou3": rewardName = "宇宙晶体发票"; break;
              case "yuzhou4": rewardName = "神器碎片发票"; break;
            case "banlv1": rewardName = "普通伴侣灵魂"; break;
             case "banlv2": rewardName = "稀有伴侣灵魂"; break;
             case "banlv7": rewardName = "天使伴侣灵魂"; break;
          case "banlv8": rewardName = "恶魔伴侣灵魂"; break;
              case "banlv9": rewardName = "精灵伴侣灵魂"; break;       
            }
            
            rewards.push(`${rewardName} x${amount}`);
        }
        
        rewardText = `获得奖励：${rewards.join("，")}`;
    }
    
    showTreasureReward(rewardText);
}

// 显示藏宝图奖励
function showTreasureReward(message) {
    document.getElementById('treasureRewardContent').innerHTML = message;
    document.getElementById('treasureRewardOverlay').style.display = 'block';
    document.getElementById('treasureRewardUI').style.display = 'block';
}

// 关闭藏宝图奖励界面
function closeTreasureReward() {
    document.getElementById('treasureRewardOverlay').style.display = 'none';
    document.getElementById('treasureRewardUI').style.display = 'none';
}

// 在游戏加载时初始化藏宝图系统
function initTreasureMapSystem() {
    if (!player.treasure) {
        player.treasure = {
            keys: 0,
            maps: [],
            currentBattle: null
        };
    }
}
// 在战斗状态变化时更新状态提示
function updateTreasureBattleStatus() {
    const statusElement = document.getElementById('treasureBattleStatus');
    if (!statusElement) return;
    
    const battle = player.treasure.currentBattle;
    if (!battle) return;
    
    if (battle.battleEnded) {
        if (battle.monster.health <= 0) {
            statusElement.textContent = "战斗胜利";
            statusElement.style.color = "#4CAF50";
        } else if (battle.playerHealth <= 0) {
            statusElement.textContent = "战斗失败";
            statusElement.style.color = "#f44336";
        }
    } else {
        statusElement.textContent = "战斗中...";
        statusElement.style.color = "#FFC107";
    }
}
// 灵根配置
const rootConfig = {
    // 110%品阶
    tier1: [
        { name: "金灵根", bonus: 1.2 },
        { name: "木灵根", bonus: 1.2 },
        { name: "水灵根", bonus: 1.2 },
        { name: "火灵根", bonus: 1.25 },
        { name: "土灵根", bonus: 1.25 },
        { name: "雷灵根", bonus: 1.25 },
        { name: "杂灵根", bonus: 1.25 },
        { name: "钝金根", bonus: 1.2 },
        { name: "弱木根", bonus: 1.3 },
        { name: "浅水灵根", bonus: 1.3 },
        { name: "微火灵根", bonus: 1.3 },
        { name: "散土灵根", bonus: 1.4 },
        { name: "青禾根", bonus: 1.4 },
        { name: "溪水灵根", bonus: 1.4 },
        { name: "岩土根", bonus: 1.2 },
        { name: "铜铁根", bonus: 1.2 },
        { name: "三杂灵根", bonus: 1.2 },
        { name: "脆金根", bonus: 1.2 }
    ],
    // 200%品阶
    tier2: [
        { name: "深水灵根", bonus: 2.0 },
        { name: "炽火根", bonus: 2.0 },
        { name: "雷灵根", bonus: 2.0 },
        { name: "风灵根", bonus: 2.0 },
        { name: "冰灵根", bonus: 2.1 },
        { name: "沙灵根", bonus: 2.0 },
        { name: "雾灵根", bonus: 2.0 },
        { name: "藤木根", bonus: 2.0 },
        { name: "熔岩根", bonus: 2.0 },
        { name: "霜水灵根", bonus: 2.0 },
        { name: "晶金根", bonus: 2.0 },
        { name: "腐木根", bonus: 2.0 },
        { name: "冥水灵根", bonus: 2.1 },
        { name: "焦土根", bonus: 2.1 },
        { name: "双灵根", bonus: 2.1 },
        { name: "云灵根", bonus: 2.1 },
        { name: "毒木根", bonus: 2.1 },
        { name: "罡风根", bonus: 2.1 },
        { name: "寒铁根", bonus: 2.0 },
        { name: "焰木根", bonus: 2.1 },
        { name: "磁金根", bonus: 2.1 },
        { name: "酸水灵根", bonus: 2.0 }
    ],
    // 250%品阶
    tier3: [
        { name: "天灵根光", bonus: 2.5 },
        { name: "暗灵根", bonus: 2.5 },
        { name: "音灵根", bonus: 2.5 },
        { name: "影灵根", bonus: 2.5 },
        { name: "星辰灵根", bonus: 2.5 },
        { name: "月华灵根", bonus: 2.5 },
        { name: "日曦灵根", bonus: 2.5 },
        { name: "虚空灵根", bonus: 2.5 },
        { name: "时间灵根", bonus: 2.5 },
        { name: "圣灵根", bonus: 2.5 },
        { name: "魔灵根", bonus: 2.5 },
        { name: "晶玉灵根", bonus: 2.5 },
        { name: "云雾灵根", bonus: 2.5 },
        { name: "生死灵根", bonus: 2.5 },
        { name: "风火灵根", bonus: 2.5 },
        { name: "光暗灵根", bonus: 2.5 },
        { name: "山海灵根", bonus: 2.5 },
        { name: "混元灵根", bonus: 2.5 },
        { name: "灵植根", bonus: 2.5 },
        { name: "魂灵根", bonus: 2.5 }
    ],
    // 300%品阶
    tier4: [
        { name: "混沌灵根", bonus: 3.0 },
        { name: "鸿蒙灵根", bonus: 3.0 },
        { name: "先天灵根", bonus: 3.0 },
        { name: "虚无灵根", bonus: 3.0 },
        { name: "永恒灵根", bonus: 3.0 },
        { name: "本源灵根", bonus: 3.0 },
        { name: "万物灵根", bonus: 3.0 },
        { name: "太初灵根", bonus: 3.0 },
        { name: "轮回灵根", bonus: 3.0 }
    ],
    // 400%品阶
    tier5: [
        { name: "天道灵根", bonus: 4.0 },
        { name: "星辰本源根", bonus: 4.0 },
        { name: "混沌雷灵根", bonus: 4.0 },
        { name: "寂灭灵根", bonus: 4.0 },
        { name: "太极灵根", bonus: 4.0 }
    ],
    // 500%品阶
    tier6: [
        { name: "大道灵根", bonus: 5.0 },
        { name: "虚空混沌根", bonus: 5.0 },
        { name: "万化灵根", bonus: 5.0 },
        { name: "创世灵根", bonus: 5.0 }
    ],
    // 1000%品阶
    tier7: [
        { name: "无垢灵根", bonus: 10.0 }
    ]
};
const bloodlineConfig = {
    tier1: [
        { name: "凡骨血脉", bonus: 1.0 },
        { name: "麻瓜血脉", bonus: 1.0 },
        { name: "健魄血脉", bonus: 1.0 },
        { name: "灵慧血脉", bonus: 1.0 },
        { name: "野猪血脉", bonus: 1.0 },
        { name: "捷足血脉", bonus: 1.2 },
        { name: "锐目血脉", bonus: 1.2 },
        { name: "佩奇血脉", bonus: 1.2 },
        { name: "稳心血脉", bonus: 1.2 },
        { name: "厚土血脉", bonus: 1.2 }
    ],
    tier2: [
        { name: "天雷血脉", bonus: 1.3 },
        { name: "雷霆血脉", bonus: 1.3 },
        { name: "妖皇血脉", bonus: 1.3 },
        { name: "格斗神血脉", bonus: 1.3 },
        { name: "法神血脉", bonus: 1.3 },
        { name: "拳神血脉", bonus: 1.3 },
        { name: "命运血脉", bonus: 1.3 },
        { name: "太古大妖血脉", bonus: 1.3 },
        { name: "龙族血脉", bonus: 1.4 },
        { name: "邪神血脉", bonus: 1.4 },
        { name: "金龙王血脉", bonus: 1.4 },
        { name: "吞天血脉", bonus: 1.4 },
        { name: "鲲鹏血脉", bonus: 1.4 },
        { name: "穷奇血脉", bonus: 1.4 },
        { name: "灵狐血脉", bonus: 1.4 },
        { name: "烛龙血脉", bonus: 1.4 },
        { name: "神羽血脉", bonus: 1.4 }
    ],
    tier3: [
        { name: "瑞兽血脉", bonus: 1.5 },
        { name: "涅槃血脉", bonus: 1.5 },
        { name: "混沌神魔血脉", bonus: 1.5 },
        { name: "万界诸神血脉", bonus: 1.5 },
        { name: "剑神血脉", bonus: 1.5 },
        { name: "冥魂血脉", bonus: 1.5 },
        { name: "御世血脉", bonus: 1.6 },
        { name: "陆吾血脉", bonus: 1.6 },
        { name: "破邪血脉", bonus: 1.6 },
        { name: "蛟龙血脉", bonus: 1.6 },
        { name: "太阳之子血脉", bonus: 1.6 },
        { name: "大帝血脉", bonus: 1.6 }
    ],
    tier4: [
        { name: "麒麟血脉", bonus: 1.8 },
        { name: "玄武血脉", bonus: 1.8 },
        { name: "白虎血脉", bonus: 1.8 },
        { name: "齐天大圣血脉", bonus: 1.8 },
        { name: "黑山老妖血脉", bonus: 1.8 },
        { name: "神鸡血脉", bonus: 1.8 },
        { name: "宇智波血脉", bonus: 1.8 },
        { name: "漩涡血脉", bonus: 1.8 },
        { name: "疾风迅雷血脉", bonus: 1.8 }
    ],
    tier5: [
        { name: "朱雀血脉", bonus: 2.1 },
        { name: "青龙血脉", bonus: 2.1 },
        { name: "金刚不坏血脉", bonus: 2.5 },
        { name: "万钧巨力血脉", bonus: 2.1 },
        { name: "瞬影血脉", bonus: 2.5 },
        { name: "破妄真瞳血脉", bonus: 2.0 }
    ],
    tier6: [
        { name: "吞天噬地血脉", bonus: 2.5 },
        { name: "星辰之力血脉", bonus: 3.0 },
        { name: "大地脉动血脉", bonus: 3.0 },
        { name: "九天罡风血脉", bonus: 3.0 },
        { name: "幽冥暗影血脉", bonus: 3.0 }
    ],
    tier7: [
        { name: "鸿蒙紫气血脉", bonus: 4.0 },
        { name: "混沌本源血脉", bonus: 4.0 },
        { name: "万象森罗血脉", bonus: 4.0 },
        { name: "诸天法则血脉", bonus: 4.0 }
    ],
    tier8: [
        { name: "永恒不朽血脉", bonus: 5.0 },
        { name: "创世之光血脉", bonus: 5.0 },
        { name: "灭世之影血脉", bonus: 5.0 }
    ],
    tier9: [
        { name: "至高无上血脉", bonus: 10.0 }
    ]
};
// 修仙阶段配置
const cultivationStages = [
    { name: "凡人", expRequired: 0, multiplier: 1 },
    { name: "练气", expRequired: 10000, multiplier: 2 },
    { name: "筑基", expRequired: 20000, multiplier: 5 },
    { name: "灵动", expRequired: 40000, multiplier: 8 },
    { name: "灵虚", expRequired: 60000, multiplier: 10 },
    { name: "灵寂", expRequired: 80000, multiplier: 20 },
    { name: "开光", expRequired: 100000, multiplier: 50 },
    { name: "融合", expRequired: 200000, multiplier: 80 },
    { name: "聚丹", expRequired: 300000, multiplier: 100 },
    { name: "凝丹", expRequired: 400000, multiplier: 200 },
    { name: "韵丹", expRequired: 500000, multiplier: 500 },
    { name: "结丹", expRequired: 600000, multiplier: 800 },
    { name: "金丹", expRequired: 700000, multiplier: 1000 },
    { name: "聚婴", expRequired: 800000, multiplier: 2000 },
    { name: "凝婴", expRequired: 900000, multiplier: 5000 },
    { name: "结婴", expRequired: 1000000, multiplier: 8000 },
    { name: "元婴", expRequired: 1250000, multiplier: 10000 },
    { name: "婴变", expRequired: 1500000, multiplier: 20000 },
    { name: "出窍", expRequired: 1750000, multiplier: 50000 },
    { name: "元神", expRequired: 2000000, multiplier: 80000 },
    { name: "分神", expRequired: 2250000, multiplier: 100000 },
    { name: "化神", expRequired: 2500000, multiplier: 200000 },
    { name: "洞虚", expRequired: 2750000, multiplier: 500000 },
    { name: "化虚", expRequired: 3000000, multiplier: 800000 },
    { name: "返虚", expRequired: 3250000, multiplier: 1000000 },
    { name: "合体", expRequired: 3500000, multiplier: 2000000 },
    { name: "合灵", expRequired: 4000000, multiplier: 5000000 },
    { name: "合魂", expRequired: 4500000, multiplier: 8000000 },
    { name: "空冥", expRequired: 5000000, multiplier: 10000000 },
    { name: "寂灭", expRequired: 5250000, multiplier: 20000000 },
    { name: "问鼎", expRequired: 5500000, multiplier: 50000000 },
    { name: "问道", expRequired: 5750000, multiplier: 80000000 },
    { name: "合道", expRequired: 6000000, multiplier: 100000000 },
    { name: "大帝", expRequired: 6250000, multiplier: 200000000 },
    { name: "半仙", expRequired: 6500000, multiplier: 500000000 },
    { name: "渡劫", expRequired: 6750000, multiplier: 800000000 },
    { name: "人仙", expRequired: 7000000, multiplier: 1000000000 },
    { name: "真仙", expRequired: 7250000, multiplier: 2000000000 },
    { name: "上仙", expRequired: 7500000, multiplier: 5000000000 },
    { name: "地仙", expRequired: 7750000, multiplier: 8000000000 },
    { name: "天仙", expRequired: 8000000, multiplier: 10000000000 },
    { name: "玄仙", expRequired: 8250000, multiplier: 20000000000 },
    { name: "太乙", expRequired: 8500000, multiplier: 50000000000 },
    { name: "九天", expRequired: 8750000, multiplier: 80000000000 },
    { name: "金仙", expRequired: 9000000, multiplier: 100000000000 },
    { name: "仙将", expRequired: 9250000, multiplier: 200000000000 },
    { name: "仙君", expRequired: 9500000, multiplier: 500000000000 },
    { name: "仙王", expRequired: 9750000, multiplier: 800000000000 },
    { name: "仙皇", expRequired: 10000000, multiplier: 1000000000000 },
    { name: "仙尊", expRequired: 15000000, multiplier: 2000000000000 },
    { name: "仙帝", expRequired: 20000000, multiplier: 5000000000000 },
    { name: "半圣", expRequired: 25000000, multiplier: 8000000000000 },
    { name: "真圣", expRequired: 30000000, multiplier: 10000000000000 },
    { name: "人圣", expRequired: 35000000, multiplier: 20000000000000 },
    { name: "地圣", expRequired: 40000000, multiplier: 50000000000000 },
    { name: "天圣", expRequired: 45000000, multiplier: 80000000000000 },
    { name: "玄圣", expRequired: 50000000, multiplier: 100000000000000 },
    { name: "大圣", expRequired: 55000000, multiplier: 200000000000000 },
    { name: "金圣", expRequired: 60000000, multiplier: 500000000000000 },
    { name: "圣将", expRequired: 65000000, multiplier: 800000000000000 },
    { name: "圣君", expRequired: 70000000, multiplier: 1000000000000000 },
    { name: "圣王", expRequired: 75000000, multiplier: 2000000000000000 },
    { name: "圣皇", expRequired: 80000000, multiplier: 5000000000000000 },
    { name: "圣尊", expRequired: 85000000, multiplier: 8000000000000000 },
    { name: "圣帝", expRequired: 90000000, multiplier: 10000000000000000 },
    { name: "半神", expRequired: 95000000, multiplier: 20000000000000000 },
    { name: "真神", expRequired: 100000000, multiplier: 50000000000000000 },
    { name: "人神", expRequired: 150000000, multiplier: 80000000000000000 },
    { name: "地神", expRequired: 200000000, multiplier: 100000000000000000 },
    { name: "天神", expRequired: 250000000, multiplier: 200000000000000000 },
    { name: "玄神", expRequired: 300000000, multiplier: 500000000000000000 },
    { name: "金神", expRequired: 350000000, multiplier: 800000000000000000 },
    { name: "神将", expRequired: 400000000, multiplier: 1000000000000000000 },
    { name: "神灵", expRequired: 450000000, multiplier: 2000000000000000000 },
    { name: "神王", expRequired: 500000000, multiplier: 5000000000000000000 },
    { name: "神皇", expRequired: 550000000, multiplier: 8000000000000000000 },
    { name: "神宗", expRequired: 600000000, multiplier: 10000000000000000000 },
    { name: "神尊", expRequired: 650000000, multiplier: 20000000000000000000 },
    { name: "神帝", expRequired: 700000000, multiplier: 50000000000000000000 },
    { name: "荒帝", expRequired: 750000000, multiplier: 80000000000000000000 },
    { name: "太荒", expRequired: 800000000, multiplier: 100000000000000000000 },
    { name: "仙荒", expRequired: 850000000, multiplier: 200000000000000000000 },
    { name: "神荒", expRequired: 900000000, multiplier: 500000000000000000000 },
    { name: "荒古", expRequired: 1000000000, multiplier: 800000000000000000000 },
    { name: "荒祖", expRequired: 1500000000, multiplier: 1000000000000000000000 },
    { name: "始荒", expRequired: 2000000000, multiplier: 2000000000000000000000 },
    { name: "人道", expRequired: 2500000000, multiplier: 5000000000000000000000 },
    { name: "天道", expRequired: 3000000000, multiplier: 8000000000000000000000 },
    { name: "仙道", expRequired: 3500000000, multiplier: 10000000000000000000000 },
    { name: "神道", expRequired: 4000000000, multiplier: 20000000000000000000000 },
    { name: "帝道", expRequired: 4500000000, multiplier: 50000000000000000000000 },
    { name: "轮回", expRequired: 5000000000, multiplier: 80000000000000000000000 },
    { name: "时空", expRequired: 5500000000, multiplier: 100000000000000000000000 },
    { name: "乾坤", expRequired: 6000000000, multiplier: 200000000000000000000000 },
    { name: "规则", expRequired: 6500000000, multiplier: 500000000000000000000000 },
    { name: "始祖", expRequired: 7000000000, multiplier: 800000000000000000000000 },
    { name: "元神", expRequired: 7500000000, multiplier: 1000000000000000000000000 },
    { name: "人神", expRequired: 8000000000, multiplier: 2000000000000000000000000 },
    { name: "仙神", expRequired: 8500000000, multiplier: 5000000000000000000000000 },
    { name: "帝神", expRequired: 9000000000, multiplier: 8000000000000000000000000 },
    { name: "主宰", expRequired: 9500000000, multiplier: 10000000000000000000000000 },
    { name: "统治者", expRequired: 10000000000, multiplier: 100000000000000000000000000 }

];

// 初始化修仙系统
function initCultivationSystem() {
    if (!player.cultivation) {
        player.cultivation = {
            stage: 0, // 当前阶段索引
            exp: 0,   // 当前经验值
            root: null, // 当前灵根
            bloodline: null,
           bonus: 1 
        };
    }
}

// 切换修仙系统界面
function toggleCultivationSystem() {
    if (player.reincarnationCount < 500) {
        alert("需要达到500转才能开启修仙系统！");
        return;
    }
    initCultivationSystem();
    
    const ui = document.getElementById('cultivationSystemUI');
    const overlay = document.getElementById('cultivationSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateCultivationUI();
    }
}


function updateCultivationUI() {
    // 获取当前阶段信息
    const stageIndex = player.cultivation.stage;
    const stage = cultivationStages[stageIndex];
    
    // 确保阶段信息存在
    if (!stage) {
        console.error("无效的修仙阶段索引:", stageIndex);
        return;
    }
    
    // 更新当前阶段显示
    document.getElementById('currentStageq').textContent = stage.name;
    
    // 其他更新逻辑保持不变...
    const nextStage = cultivationStages[stageIndex + 1];
    
    // 更新灵根信息
    const rootInfo = document.getElementById('currentRootInfo');
    if (player.cultivation.root) {
        rootInfo.innerHTML = `
            <div style="font-size: 18px; font-weight: bold; color: #FFD700;">${player.cultivation.root.name}</div>
            <div>加成: ${player.cultivation.root.bonus * 100}%</div>
        `;
    } else {
        rootInfo.textContent = "尚未检测灵根";
    }
     const bloodlineInfo = document.getElementById('currentBloodlineInfo');
    if (player.cultivation.bloodline) {
        bloodlineInfo.innerHTML = `
            <div style="font-size: 18px; font-weight: bold; color: #d4af37;">${player.cultivation.bloodline.name}</div>
            <div>加成: ${player.cultivation.bloodline.bonus * 100}%</div>
        `;
    } else {
        bloodlineInfo.textContent = "尚未检测血脉";
    }
    // 更新阶段信息
    document.getElementById('stageLevel').textContent = stageIndex;
    document.getElementById('currentExp').textContent = player.cultivation.exp.toFixed(0);
    
    if (nextStage) {
        document.getElementById('nextExp').textContent = nextStage.expRequired;
        
        // 计算经验进度
        const progress = Math.min(100, (player.cultivation.exp / nextStage.expRequired) * 100);
        document.getElementById('expProgress').style.width = `${progress}%`;
    } else {
        document.getElementById('nextExp').textContent = "已达最高境界";
        document.getElementById('expProgress').style.width = '100%';
    }
    
    // 更新加成信息
    document.getElementById('gpsMultiplier').textContent = stage.multiplier;
}
// 打开灵根宝箱界面
function openRootBox() {
    if (player.items.rootDetector < 1) {
        logAction("灵根检测器不足！", "error");
        return;
    }
    
    document.getElementById('rootBoxUI').style.display = 'block';
    document.getElementById('rootBoxOverlay').style.display = 'block';
    document.getElementById('rootResult').textContent = "点击开启获取灵根";
}

// 关闭灵根宝箱界面
function closeRootBox() {
    document.getElementById('rootBoxUI').style.display = 'none';
    document.getElementById('rootBoxOverlay').style.display = 'none';
}

// 抽取灵根
function drawRoot() {
    if (player.items.rootDetector < 1) {
        logAction("灵根检测器不足！", "error");
        return;
    }
    
    player.items.rootDetector--;
    
    // 根据概率抽取灵根品阶
    const rand = Math.random();
    let tier;
    
    if (rand < 0.8) {
        tier = "tier1"; // 80%
    } else if (rand < 0.95) {
        tier = "tier2"; // 15%
    } else if (rand < 0.998889) {
        tier = "tier3"; // 4.8889%
    } else if (rand < 0.999889) {
        tier = "tier4"; // 0.1%
    } else if (rand < 0.999989) {
        tier = "tier5"; // 0.01%
    } else if (rand < 0.999999) {
        tier = "tier6"; // 0.001%
    } else {
        tier = "tier7"; // 0.0001%
    }
    
    // 随机选择该品阶中的一个灵根
    const roots = rootConfig[tier];
    const root = roots[Math.floor(Math.random() * roots.length)];
    
    // 更新玩家灵根
    player.cultivation.root = root;
    
    // 显示结果
    document.getElementById('rootResult').innerHTML = `
        <div style="font-size: 20px; font-weight: bold; color: #FFD700;">获得${root.name}!</div>
        <div>加成: ${root.bonus * 100}%</div>
    `;
    
    logAction(`获得灵根: ${root.name} (加成${root.bonus * 100}%)`, "success");
    updateCultivationUI();
    updateDisplay();
}
// 打开血脉宝箱
function openBloodlineBox() {
    if (player.items.bloodlineDetector < 1) {
        logAction("血脉检测剂不足！", "error");
        return;
    }
    
    document.getElementById('bloodlineBoxUI').style.display = 'block';
    document.getElementById('bloodlineBoxOverlay').style.display = 'block';
    document.getElementById('bloodlineResult').textContent = "点击开启获取血脉";
}

// 关闭血脉宝箱
function closeBloodlineBox() {
    document.getElementById('bloodlineBoxUI').style.display = 'none';
    document.getElementById('bloodlineBoxOverlay').style.display = 'none';
}

// 抽取血脉
function drawBloodline() {
    if (player.items.bloodlineDetector < 1) {
        logAction("血脉检测剂不足！", "error");
        return;
    }
    
    player.items.bloodlineDetector--;
    
    // 根据概率抽取血脉品阶
    const rand = Math.random();
    let tier;
    
    if (rand < 0.8) {
        tier = "tier1"; // 80%
    } else if (rand < 0.95) {
        tier = "tier2"; // 15%
    } else if (rand < 0.998889) {
        tier = "tier3"; // 4.8889%
    } else if (rand < 0.999889) {
        tier = "tier4"; // 0.1%
    } else if (rand < 0.999989) {
        tier = "tier5"; // 0.01%
    } else if (rand < 0.999999) {
        tier = "tier6"; // 0.001%
    } else if (rand < 0.9999999) {
        tier = "tier7"; // 0.0001%
    } else if (rand < 0.99999999) {
        tier = "tier8"; // 0.00001%
    } else {
        tier = "tier9"; // 0.000001%
    }
    
    // 随机选择该品阶中的一个血脉
    const bloodlines = bloodlineConfig[tier];
    const bloodline = bloodlines[Math.floor(Math.random() * bloodlines.length)];
    
    // 更新玩家血脉
    player.cultivation.bloodline = bloodline;
    
    // 显示结果
    document.getElementById('bloodlineResult').innerHTML = `
        <div style="font-size: 20px; font-weight: bold; color: #FFD700;">获得${bloodline.name}!</div>
        <div>加成: ${bloodline.bonus * 100}%</div>
    `;
    
    logAction(`获得血脉: ${bloodline.name} (加成${bloodline.bonus * 100}%)`, "success");
    updateCultivationUI();
    updateDisplay();
}
// 升级修仙阶段
function upgradeCultivation() {
    console.log("升级前阶段:", player.cultivation.stage);
    
    const nextStageIndex = player.cultivation.stage + 1;
    
    // 检查是否有下一阶段
    if (nextStageIndex >= cultivationStages.length) {
        logAction("已达最高境界，无法继续升级", "info");
        return;
    }
    
    const nextStage = cultivationStages[nextStageIndex];
    
    // 检查经验是否足够
    if (player.cultivation.exp < nextStage.expRequired) {
        logAction("经验不足，无法升级", "error");
        return;
    }
    
    // 扣除经验并升级
    player.cultivation.exp -= nextStage.expRequired;
    player.cultivation.stage = nextStageIndex;
    
    console.log("升级后阶段:", player.cultivation.stage);
    logAction(`成功晋升${nextStage.name}境界！`, "success");
    
    // 更新显示
    updateDisplay();
    updateCultivationUI(); // 如果修仙界面打开，也需要更新
}

// 每分钟获取经验
function gainCultivationExp() {
   if (!player.cultivation || !player.cultivation.root || !player.cultivation.bloodline) return;
    
    // 每分钟经验 = 转生次数 × 灵根加成
   const rootBonus = player.cultivation.root.bonus;
    const bloodlineBonus = player.cultivation.bloodline.bonus;
    const expGain = (rootBonus * bloodlineBonus) * player.reincarnationCount;
    player.cultivation.exp += expGain/60;
    const stage = cultivationStages[player.cultivation.stage];
    player.cultivation.bonus = stage.multiplier;
    // 更新UI
 document.getElementById('currentExpPerMinute').textContent = expGain.toFixed(2);
  updateDisplay();
    updateCultivationUI();
}
// 计算离线经验
function calculateOfflineCultivationExp(offlineMinutes) {
    if (!player.cultivation || !player.cultivation.root || !player.cultivation.bloodline) return;
     const rootBonus = player.cultivation.root.bonus;
    const bloodlineBonus = player.cultivation.bloodline.bonus;
    const expGain = offlineMinutes * (rootBonus * bloodlineBonus) * player.reincarnationCount;
    player.cultivation.exp += expGain;
    
    logAction(`离线获得${expGain}点修仙经验`, "info");
}

// 称号配置（按分支分组）
const titleConfig = {
     towerBranyy: [
    { name: "钓竿初握", condition: (p) => p.fishing.level > 2, bonus: { attackMultiplier: 1.1 } },
    { name: "河塘渔夫", condition: (p) => p.fishing.level > 5, bonus: { attackMultiplier: 1.1 } },
    { name: "渔获大师", condition: (p) => p.fishing.level > 7, bonus: { attackMultiplier: 1.1 } },
    { name: "万鱼臣服", condition: (p) => p.fishing.level > 10, bonus: { attackMultiplier: 1.2 } },
    { name: "钓尽乾坤", condition: (p) => p.fishing.level > 14, bonus: { attackMultiplier: 1.2 } },
    { name: "小农夫", condition: (p) => p.farm.level > 2, bonus: { attackMultiplier: 1.1 } },
    { name: "田园熟手", condition: (p) => p.farm.level > 5, bonus: { attackMultiplier: 1.1 } },
    { name: "农耕大师", condition: (p) => p.farm.level > 15, bonus: { attackMultiplier: 1.1 } },
    { name: "庄园尊主", condition: (p) => p.farm.level > 25, bonus: { attackMultiplier: 1.2 } },
    { name: "大地主宰", condition: (p) => p.farm.level > 35, bonus: { attackMultiplier: 1.2 } },
    { name: "车途学徒", condition: (p) => p.parking.level > 2, bonus: { attackMultiplier: 1.1 } },
    { name: "赛道枭雄", condition: (p) => p.parking.level > 7, bonus: { attackMultiplier: 1.1 } },
    { name: "车坛至尊", condition: (p) => p.parking.level > 14, bonus: { attackMultiplier: 1.1 } },
    { name: "巅峰车皇", condition: (p) => p.parking.level > 24, bonus: { attackMultiplier: 1.2 } },
    { name: "寰宇车神", condition: (p) => p.parking.level > 34, bonus: { attackMultiplier: 1.2 } },
    { name: "创世车帝", condition: (p) => p.parking.level > 39, bonus: { attackMultiplier: 1.2 } }
], 
     towerBranch: [
    { name: "关破厉鬼", condition: (p) => p.tower.maxFloor > 10, bonus: { healthMultiplier: 1.1 } },
    { name: "阶碎无常", condition: (p) => p.tower.maxFloor > 100, bonus: { healthMultiplier: 1.1 } },
    { name: "踏塔马面", condition: (p) => p.tower.maxFloor > 100, bonus: { healthMultiplier: 1.1 } },
    { name: "魔修夜叉", condition: (p) => p.tower.maxFloor > 300, bonus: { healthMultiplier: 1.1 } },
    { name: "破阶修罗", condition: (p) => p.tower.maxFloor > 500, bonus: { healthMultiplier: 1.1 } },
    { name: "千层煞主", condition: (p) => p.tower.maxFloor > 1000, bonus: { healthMultiplier: 1.1 } },
    { name: "踏关煞神", condition: (p) => p.tower.maxFloor > 2000, bonus: { healthMultiplier: 1.1 } },
    { name: "关前冥王", condition: (p) => p.tower.maxFloor > 5000, bonus: { healthMultiplier: 1.1 } },
    { name: "踏塔狂魔", condition: (p) => p.tower.maxFloor > 10000, bonus: { healthMultiplier: 1.1 } },
    { name: "混世魔王", condition: (p) => p.tower.maxFloor > 20000, bonus: { healthMultiplier: 1.1 } },
    { name: "屠戮之主", condition: (p) => p.tower.maxFloor > 30000, bonus: { healthMultiplier: 1.1 } },
    { name: "杀戮之神", condition: (p) => p.tower.maxFloor > 40000, bonus: { healthMultiplier: 1.1 } },
    { name: "十殿阎罗", condition: (p) => p.tower.maxFloor > 50000, bonus: { healthMultiplier: 1.1 } },
    { name: "弑神修罗", condition: (p) => p.tower.maxFloor > 60000, bonus: { healthMultiplier: 1.1 } },
    { name: "九幽魔尊", condition: (p) => p.tower.maxFloor > 70000, bonus: { healthMultiplier: 1.1 } },
    { name: "永夜君主", condition: (p) => p.tower.maxFloor > 80000, bonus: { healthMultiplier: 1.1 } },
    { name: "深渊主宰", condition: (p) => p.tower.maxFloor > 90000, bonus: { healthMultiplier: 1.1 } }
],
    // 关卡分支
    stageBranch: [
        { name: "探险者", condition: (p) => p.battle.maxStage > 10, bonus: { attackMultiplier: 2 } },
        { name: "银翼斥候", condition: (p) => p.battle.maxStage > 50, bonus: { attackMultiplier: 2 } },
        { name: "圣域行者", condition: (p) => p.battle.maxStage > 100, bonus: { attackMultiplier: 2 } },
        { name: "苍穹之主", condition: (p) => p.battle.maxStage > 150, bonus: { attackMultiplier: 2 } },
        { name: "九天至尊", condition: (p) => p.battle.maxStage > 200, bonus: { attackMultiplier: 2 } },
        { name: "万域之主", condition: (p) => p.battle.maxStage > 300, bonus: { attackMultiplier: 2 } },
        { name: "寰宇独尊", condition: (p) => p.battle.maxStage > 400, bonus: { attackMultiplier: 2 } },
        { name: "万界臣服", condition: (p) => p.battle.maxStage > 500, bonus: { attackMultiplier: 2 } },
        { name: "天地共主", condition: (p) => p.battle.maxStage > 600, bonus: { attackMultiplier: 5 } },
        { name: "星河主宰", condition: (p) => p.battle.maxStage > 700, bonus: { attackMultiplier: 5 } },
        { name: "太虚之皇", condition: (p) => p.battle.maxStage > 800, bonus: { attackMultiplier: 5 } },
        { name: "六道归一", condition: (p) => p.battle.maxStage > 900, bonus: { attackMultiplier: 5 } }
    ],
    // 转生分支
    reincarnationBranch: [
        { name: "初涉江湖", condition: (p) => p.reincarnationCount > 5, bonus: { healthMultiplier: 1.2 } },
        { name: "俗世门徒", condition: (p) => p.reincarnationCount > 10, bonus: { healthMultiplier: 1.2 } },
        { name: "人中龙凤", condition: (p) => p.reincarnationCount > 50, bonus: { healthMultiplier: 1.2 } },
        { name: "一方翘楚", condition: (p) => p.reincarnationCount > 100, bonus: { healthMultiplier: 1.2 } },
        { name: "超凡入圣", condition: (p) => p.reincarnationCount > 250, bonus: { healthMultiplier: 1.2 } },
        { name: "一代宗师", condition: (p) => p.reincarnationCount > 500, bonus: { healthMultiplier: 1.2 } },
        { name: "盖世之才", condition: (p) => p.reincarnationCount > 1000, bonus: { healthMultiplier: 1.2 } },
        { name: "众仙之师", condition: (p) => p.reincarnationCount > 2000, bonus: { healthMultiplier: 1.2 } },
        { name: "创世之灵", condition: (p) => p.reincarnationCount > 3000, bonus: { healthMultiplier: 1.2 } },
        { name: "万神之主", condition: (p) => p.reincarnationCount > 5000, bonus: { healthMultiplier: 1.2 } },
        { name: "无上真神", condition: (p) => p.reincarnationCount > 10000, bonus: { healthMultiplier: 1.2 } },
        { name: "寰宇神尊", condition: (p) => p.reincarnationCount > 50000, bonus: { healthMultiplier: 1.2 } },
        { name: "创世神帝", condition: (p) => p.reincarnationCount > 100000, bonus: { healthMultiplier: 1.2 } }
    ],
    // 驯兽师分支
    tamerBranch: [
        { name: "初级驯兽师", condition: (p) => p.pets?.thunderKirin?.level > 50, bonus: { critMultiplier: 2 } },
        { name: "中级驯兽师", condition: (p) => p.pets?.netherQiongqi?.level > 30, bonus: { critMultiplier: 2 } },
        { name: "高级驯兽师", condition: (p) => p.pets?.primordialZhuLong?.level > 10, bonus: { critMultiplier: 2 } },
        { name: "圣级驯兽师", condition: (p) => p.pets?.yanYuBiAn?.level > 10, bonus: { critMultiplier: 2 } },
        { name: "神级驯兽师", condition: (p) => p.pets?.yuyu2?.level > 10, bonus: { critMultiplier: 4 } },
        { name: "人级驯兽师", condition: (p) => p.pets?.yuyu3?.level > 10, bonus: { critMultiplier: 4 } },
        { name: "地级驯兽师", condition: (p) => p.pets?.yuyu4?.level > 10, bonus: { critMultiplier: 4 } },
        { name: "天级驯兽师", condition: (p) => p.pets?.yuyu5?.level > 10, bonus: { critMultiplier: 4 } },
        { name: "帝级驯兽师", condition: (p) => p.pets?.yuyu6?.level > 10, bonus: { critMultiplier: 4 } },
        { name: "仙级驯兽师", condition: (p) => p.pets?.yuyu7?.level > 10, bonus: { critMultiplier: 4 } },
        { name: "创世级驯兽师", condition: (p) => p.pets?.yuyu8?.level > 10, bonus: { critMultiplier: 4 } }
    ],
    // 魂环分支
    soulRingBranch: [
        { name: "魂士", condition: (p) => hasSoulRing(p, "year1"), bonus: { attackMultiplier: 2 } },
        { name: "魂师", condition: (p) => hasSoulRing(p, "year100"), bonus: { attackMultiplier: 2 } },
        { name: "大魂师", condition: (p) => hasSoulRing(p, "year10000"), bonus: { attackMultiplier: 2 } },
        { name: "魂尊", condition: (p) => hasSoulRing(p, "year1000000"), bonus: { attackMultiplier: 2 } },
        { name: "魂宗", condition: (p) => hasSoulRing(p, "year3"), bonus: { attackMultiplier: 2 } },
        { name: "魂王", condition: (p) => hasSoulRing(p, "year7"), bonus: { attackMultiplier: 2 } },
        { name: "魂帝", condition: (p) => hasSoulRing(p, "year13"), bonus: { attackMultiplier: 2 } },
        { name: "魂圣", condition: (p) => hasSoulRing(p, "year18"), bonus: { attackMultiplier: 2 } },
        { name: "魂斗罗", condition: (p) => hasSoulRing(p, "year23"), bonus: { attackMultiplier: 4 } },
        { name: "普通封号斗罗", condition: (p) => hasSoulRing(p, "year28"), bonus: { attackMultiplier: 4 } },
        { name: "巅峰斗罗", condition: (p) => hasSoulRing(p, "year33"), bonus: { attackMultiplier: 4 } },
        { name: "绝世斗罗", condition: (p) => hasSoulRing(p, "year37"), bonus: { attackMultiplier: 4 } }
    ],
    // 特殊分支
    specialBranch: [
        { name: "萌新", condition: (p) => p.gold > 1, bonus: { attackMultiplier: 1 } },
        { name: "公测玩家", condition: (p) => p.usedActivationCodes.includes("VIP666777"), bonus: { attackMultiplier: 1 } },
        { name: "持剑学徒", condition: (p) => getEquipLevel(p, "废品") > 1, bonus: { attackMultiplier: 2 } },
        { name: "疾风剑者", condition: (p) => getEquipLevel(p, "废品") > 1000, bonus: { attackMultiplier: 2 } },
        { name: "断水剑师", condition: (p) => getEquipLevel(p, "废品") > 10000, bonus: { attackMultiplier: 2 } },
        { name: "九霄剑王", condition: (p) => getEquipLevel(p, "废品") > 100000, bonus: { attackMultiplier: 2 } },
        { name: "独孤剑皇", condition: (p) => getEquipLevel(p, "废品") > 500000, bonus: { attackMultiplier: 2 } },
        { name: "剑域之主", condition: (p) => getEquipLevel(p, "废品") > 1000000, bonus: { attackMultiplier: 2 } },
        { name: "万剑之神", condition: (p) => getEquipLevel(p, "废品") > 5000000, bonus: { attackMultiplier: 2 } },
        { name: "鸿蒙剑祖", condition: (p) => getEquipLevel(p, "废品") > 10000000, bonus: { attackMultiplier: 2 } },
        { name: "万劫剑神", condition: (p) => getEquipLevel(p, "废品") > 50000000, bonus: { attackMultiplier: 4 } },
        { name: "无上剑神", condition: (p) => getEquipLevel(p, "废品") > 100000000, bonus: { attackMultiplier: 4 } },
        { name: "剑狱之尊", condition: (p) => getEquipLevel(p, "废品") > 200000000, bonus: { attackMultiplier: 4 } },
        { name: "剑主洪荒", condition: (p) => getEquipLevel(p, "废品") > 300000000, bonus: { attackMultiplier: 4 } },
        { name: "御诸剑神", condition: (p) => getEquipLevel(p, "废品") > 400000000, bonus: { attackMultiplier: 4 } }
    ]
};
// 辅助函数：检查是否拥有指定魂环
function hasSoulRing(player, typeName) {
return player.soulRings.some(ring => ring.type === typeName);
}

// 辅助函数：获取指定类型装备的最高等级
function getEquipLevel(player, equipName) {
return player.dungeonEquipment
.filter(eq => eq.name === equipName)
.reduce((max, eq) => Math.max(max, eq.level || 0), 0);
}

// 显示称号界面
function showTitleDialog() {
   if (player.reincarnationCount < 10) {
        alert("需要达到10转才能开启称号系统！");
        return;
    }
    checkTitleUnlocks(); // 先检查解锁状态
    renderTitleBranches(); // 渲染称号
    document.getElementById("titleDialog").style.display = "block";
    document.getElementById("titleOverlay").style.display = "block";
}

// 关闭称号界面
function closeTitleDialog() {
    document.getElementById("titleDialog").style.display = "none";
    document.getElementById("titleOverlay").style.display = "none";
}

// 检查并解锁称号
function checkTitleUnlocks() {
    let newlyUnlocked = false;
    // 遍历所有分支的称号
    Object.values(titleConfig).forEach(branch => {
        branch.forEach(title => {
            if (!player.titles.unlocked.includes(title.name) && title.condition(player)) {
                player.titles.unlocked.push(title.name);
                newlyUnlocked = true;
                
                // 应用称号加成
                if (title.bonus) {
                    applyTitleBonus(title.bonus);
                }
                
                logAction(`解锁新称号：${title.name}`, 'success');
            }
        });
    });
    if (newlyUnlocked) {
        saveGame();
    }
}

// 应用称号加成
function applyTitleBonus(bonus) {
    // 直接修改玩家属性
    if (bonus.attackMultiplier) {
        player.battle.playerAttack *= bonus.attackMultiplier;
    }
    if (bonus.healthMultiplier) {
        player.battle.playerHealth *= bonus.healthMultiplier;
    }
    if (bonus.critMultiplier) {
        player.battle.playerCritDamage *= bonus.critMultiplier;
    }
    // 其他属性...
    
    logAction(`称号加成生效: ${JSON.stringify(bonus)}`, 'success');
    updatePlayerBattleStats();
}

// 渲染称号分支
function renderTitleBranches() {
    // 遍历每个分支并渲染
    Object.entries(titleConfig).forEach(([branchKey, titles]) => {
        const container = document.getElementById(`${branchKey}Container`);
        if (!container) return;
        
        container.innerHTML = "";
        titles.forEach(title => {
            // 只显示已解锁的称号
            if (player.titles.unlocked.includes(title.name)) {
                const isSelected = player.titles.current === title.name;
                const titleEl = document.createElement("div");
                titleEl.className = `titleItem unlocked ${isSelected ? 'selected' : ''}`;
                titleEl.textContent = title.name;
                titleEl.onclick = () => selectTitle(title.name);
                container.appendChild(titleEl);
            }
        });
    });
}

// 选择称号
function selectTitle(titleName) {
    if (player.titles.unlocked.includes(titleName)) {
        player.titles.current = titleName;
        logAction(`已选择称号：${titleName}`, 'info');
        renderTitleBranches(); // 更新选中状态
        updateDisplay(); // 更新玩家名字旁的称号显示
        saveGame();
    }
}
// 计算称号总加成（在属性计算处调用）
function calculateTotalBonuses() {
    const bonuses = {
        attackMultiplier: 1,
        healthMultiplier: 1,
        critMultiplier: 1
    };
    
    // 累加所有已解锁称号的加成
    player.titles.unlocked.forEach(titleName => {
        // 查找对应的称号配置
        for (const branch of Object.values(titleConfig)) {
            for (const title of branch) {
                if (title.name === titleName && title.bonus) {
                    // 累乘加成
                    if (title.bonus.attackMultiplier) {
                        bonuses.attackMultiplier *= title.bonus.attackMultiplier;
                    }
                    if (title.bonus.healthMultiplier) {
                        bonuses.healthMultiplier *= title.bonus.healthMultiplier;
                    }
                    if (title.bonus.critMultiplier) {
                        bonuses.critMultiplier *= title.bonus.critMultiplier;
                    }
                    break;
                }
            }
        }
    });
    
    return bonuses;
}


// 伴侣品阶配置
const companionRarities = {
    white: { 
        name: "普通", 
        color: "#FFFFFF", 
        baseScore: 100,
        upgradeMultiplier: 1,
        talentCount: 4,
        talentRange: [0, 3], // 初级到终极
        decomposeRose: 5,
         soulItem: "banlv1"
    },
    blue: { 
        name: "稀有", 
        color: "#0000FF", 
        baseScore: 500,
        upgradeMultiplier: 3,
        talentCount: 5,
        talentRange: [0, 4], // 初级到圣级
        decomposeRose: 20,
         soulItem: "banlv2"
    },
    epic: { 
        name: "史诗", 
        color: "#800080", 
        baseScore: 1000,
        upgradeMultiplier: 10,
        talentCount: 6,
        talentRange: [0, 5], // 初级到神级
        decomposeRose: 50,
         soulItem: "banlv3"
    },
    pink: { 
        name: "卓越", 
        color: "#FF69B4", 
        baseScore: 3000,
        upgradeMultiplier: 20,
        talentCount: 7,
        talentRange: [0, 6], // 初级到远古
        decomposeRose: 100,
         soulItem: "banlv4"
    },
    orange: { 
        name: "完美", 
        color: "#FFA500", 
        baseScore: 5000,
        upgradeMultiplier: 50,
        talentCount: 8,
        talentRange: [0, 7], // 初级到太古
        decomposeRose: 200,
         soulItem: "banlv5"
    },
    red: { 
        name: "神赐", 
        color: "#FF0000", 
        baseScore: 8000,
        upgradeMultiplier: 100,
        talentCount: 10,
        talentRange: [0, 8], // 初级到洪荒
        decomposeRose: 1000,
         soulItem: "banlv6"
    },
   angel: { 
        name: '天使', 
        color: '#87CEEB',
        baseScore: 1000,
        upgradeMultiplier: 30,
        talentCount: 0, // 动态计算
        talentRange: [0, 8], // 可达到洪荒级别
        decomposeRose: 100,
         soulItem: "banlv7"
    },
  emyyyy: { 
        name: '恶魔', 
        color: '#E63946',
        baseScore: 1000,
        upgradeMultiplier: 25,
        talentCount: 0, // 动态计算
        talentRange: [0, 8], // 可达到洪荒级别
        decomposeRose: 100,
         soulItem: "banlv8"
    },
  jlyyyy: { 
        name: '妖精', 
        color: '#7CFC00',
        baseScore: 1000,
        upgradeMultiplier: 20,
        talentCount: 0, // 动态计算
        talentRange: [0, 8], // 可达到洪荒级别
        decomposeRose: 100,
         soulItem: "banlv9"
    }
};

// 天赋类型配置
const talentTypes = [
    {
        name: "攻击",
        base: 1,
        perLevel: 5,
        description: (level) => `玩家总和攻击+${(1 + 5 * level).toFixed(1)}倍`
    },
    {
        name: "爆伤",
        base: 1,
        perLevel: 5,
        description: (level) => `玩家总和爆伤+${(1 + 5 * level).toFixed(1)}倍`
    },
    {
        name: "生命",
        base: 0.001,
        perLevel: 0.001,
        description: (level) => `玩家总和生命+${(0.001 + 0.001 * level).toFixed(3)}倍`
    },
    {
        name: "全属性",
        base: 0.5,
        perLevel: 2.5,
        description: (level) => `玩家总和全属性+${(0.5 + 2.5 * level).toFixed(1)}倍`
    },
    {
        name: "连击",
        base: 1,
        perLevel: 5,
        description: (level) => `玩家连击+${1 + 5 * level}`
    },
    {
        name: "暴击率",
        base: 0.001,
        perLevel: 0.001,
        description: (level) => `玩家暴击率+${(0.001 + 0.001 * level).toFixed(3)}倍`
    }
];

// 天赋品阶名称
const talentRanks = ["初级", "中级", "高级", "终极", "圣级", "神级", "远古", "太古", "洪荒"];

// 伴侣名字库
const companionNames = ["闫闫", "茶茶", "沈砚山", "苏绾月", "林清瑶", "楚棠溪", "慕玄尘", "许清尘", "温玉珞", "林灵枢", "叶棠音", "陆剑尘", "楚絮晚", "陆星辞", "王富贵", "洛千尘", "白小纯", "白芷晴", "顾长歌", "沈青岚", "慕雨柔", "陆天行", "乔曦", "柳如烟", "香香", "尝试", "小萝莉", "通元", "鱼鱼", "花花"];

// 抽奖概率
const drawProbabilities = [
    {rarity: "white", prob: 0.8},
    {rarity: "blue", prob: 0.15},
    {rarity: "epic", prob: 0.01889},
    {rarity: "pink", prob: 0.001},
    {rarity: "orange", prob: 0.0001},
    {rarity: "red", prob: 0.00001}
];
const guaranteeThresholds = {
    epic: 100,   // 100次保底史诗
    pink: 500,   // 500次保底卓越
    orange: 1000, // 1000次保底完美
    red: 5000    // 5000次保底神赐
};

// 打开伴侣系统
function openCompanionSystem() {
 if (player.reincarnationCount < 30) {
        alert("需要达到30转才能开启伴侣系统！");
        return;
    }
    document.getElementById('companionSystem').style.display = 'block';
    document.getElementById('companionOverlay').style.display = 'block';
    updateCompanionDisplay();
   calculateOfflineExpeditionRewards();
    updateExpeditionUI();
}

// 关闭伴侣系统
function closeCompanionSystem() {
    document.getElementById('companionSystem').style.display = 'none';
    document.getElementById('companionOverlay').style.display = 'none';
}

// 更新伴侣系统显示
function updateCompanionDisplay() {
    // 更新等级和消耗
    document.getElementById('companionLevel').textContent = player.companionLevel;
    document.getElementById('upgradeCost').textContent = 10 * player.companionLevel;
    document.getElementById('companionKeyCount').textContent = player.items.companionKey;
    // 更新保底计数器显示
    document.getElementById('epicGuarantee').textContent = player.companionChestGuarantee.epic;
    document.getElementById('pinkGuarantee').textContent = player.companionChestGuarantee.pink;
    document.getElementById('orangeGuarantee').textContent = player.companionChestGuarantee.orange;
    document.getElementById('redGuarantee').textContent = player.companionChestGuarantee.red;
    // 更新伴侣列表
    const listContainer = document.getElementById('companionList');
    listContainer.innerHTML = '';
    const companion = player.companions.find(c => c.id === player.equippedCompanionId);
    if (companion) {
        const rarityConfig = companionRarities[companion.rarity] || {};
        const bonuses = getCompanionBonuses();
        
        // 更新显示
        document.getElementById('qualityMultiplier').textContent = 
    `${(Math.floor(companion.score / 100) + companionRarities[companion.rarity].upgradeMultiplier).toFixed(2)}x`;
        document.getElementById('attackTotalBonus').textContent = `${bonuses.attackMultiplier.toFixed(3)}倍`;
        document.getElementById('healthTotalBonus').textContent = `${bonuses.healthMultiplier.toFixed(3)}倍`;
        document.getElementById('critRateTotalBonus').textContent = `${bonuses.critRateMultiplier.toFixed(3)}倍`;
        document.getElementById('critDamageTotalBonus').textContent = `${bonuses.critDamageMultiplier.toFixed(3)}倍`;
        document.getElementById('comboTotalBonus').textContent = bonuses.combo;
        document.getElementById('allStatsTotalBonus').textContent = `${bonuses.allStatsMultiplier.toFixed(3)}倍`;
    } else {
        // 未装备伴侣时显示默认值
        const defaultText = '未装备';
        document.getElementById('qualityMultiplier').textContent = defaultText;
        document.getElementById('attackTotalBonus').textContent = defaultText;
        document.getElementById('healthTotalBonus').textContent = defaultText;
        document.getElementById('critRateTotalBonus').textContent = defaultText;
        document.getElementById('critDamageTotalBonus').textContent = defaultText;
        document.getElementById('comboTotalBonus').textContent = defaultText;
        document.getElementById('allStatsTotalBonus').textContent = defaultText;
    }

    player.companions.forEach(companion => {
        const isEquipped = player.equippedCompanionId === companion.id;
const rarityConfig = companionRarities[companion.rarity] || {};
        const rarityName = rarityConfig.name || "未知";
        const rarityColor = rarityConfig.color || "#CCCCCC";
        
        // 特殊处理天使品质的显示
        let displayName = companion.name;
        if (companion.rarity === 'angel') {
            displayName = `天使·${companion.name}`;
        }
        const stars = '★'.repeat(Math.min(10, Math.floor(companion.score / 1000)));
        const emptyStars = '☆'.repeat(10 - Math.min(10, Math.floor(companion.score / 1000)));
        
        const card = document.createElement('div');
        card.style = `background: #222; border: 2px solid ${companionRarities[companion.rarity].color}; border-radius: 5px; padding: 10px; position: relative;`;
        card.innerHTML = `
            <div style="position: absolute; top: 5px; right: 5px; color: ${companionRarities[companion.rarity].color};">
                ${companionRarities[companion.rarity].name}
            </div>
            <h4 style="color: ${companionRarities[companion.rarity].color}; margin-top: 0;">
                ${companion.name}
                <span style="margin-left: 5px; color: #FFD700;">+${companion.advanceLevel || 0}</span>
                ${companion.locked ? '🔒' : ''}
            </h4>
            </div>
    <div>${stars}${emptyStars} (${companion.score}/10000)</div>
            <div style="margin: 5px -2; font-size: 0.8em; max-height: 190px; overflow-y: auto;">
                ${companion.talents.map(t => `${talentRanks[t.rank]}${talentTypes[t.type].name}: ${talentTypes[t.type].description(t.rank)}`).join('<br>')}
            </div>
            <div style="margin-top: 10px; display: flex; gap: 5px;">
                <button onclick="equipCompanion('${companion.id}')" style="flex: 1; background: ${isEquipped ? '#4CAF50' : '#555'}; color: white; border: none; padding: 3px; border-radius: 2px; font-size: 0.8em;">
                    ${isEquipped ? '已装备' : '装备'}
                </button>
                <button onclick="toggleCompanionLock('${companion.id}')" style="width: 30px; background: ${companion.locked ? '#f44336' : '#555'}; color: white; border: none; padding: 3px; border-radius: 2px;">
                    ${companion.locked ? '已锁' : '开锁'}
                </button>
                <button onclick="decomposeCompanion('${companion.id}')" style="width: 30px; background: #f44336; color: white; border: none; padding: 3px; border-radius: 2px;" ${companion.locked ? 'disabled' : ''}>
                    分解
                </button>
       <button onclick="advanceCompanion('${companion.id}')" style="width: 30px; background: #FFD700; color: black; border: none; padding: 3px; border-radius: 2px; margin-left: 2px;" 
    ${companion.locked || !['white','blue','epic','pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity) ? 'disabled' : ''}>
    进阶
</button>
 <button onclick="openWashPanel('${companion.id}')" style="width: 30px; background: #2196F3; color: white; border: none; padding: 3px; border-radius: 2px; margin-left: 2px;"
    ${companion.locked || !['epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity) ? 'disabled' : ''}>
    洗练
</button>
   <button onclick="openCombinePanel('${companion.id}')" style="width: 30px; background: #9C27B0; color: white; border: none; padding: 3px; border-radius: 2px; margin-left: 2px;"
    ${companion.locked || !['epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity) ? 'disabled' : ''}>
    合成
</button>
            </div>
        `;
        listContainer.appendChild(card);
    });
}
const expeditionConfig = {
    tasks: [
        {
            id: "forest",
            name: "迷雾森林",
            difficulty: "简单",
            duration: 30, // 分钟
            baseReward: {
                rose: 30,
                vipPower: 1,
                bait: 1
            },
            description: "探索神秘的迷雾森林，寻找稀有资源",
            companionRequirement: 3000 
        },
        {
            id: "mountain",
            name: "远古山脉",
            difficulty: "中等",
            duration: 60,
            baseReward: {
                rose: 80,
                vipPower: 3,
                bait: 3
            },
            description: "攀登危险的远古山脉，挑战极限",
            companionRequirement: 5000
        },
        {
            id: "ocean",
            name: "深渊海洋",
            difficulty: "困难",
            duration: 120,
            baseReward: {
                rose: 200,
                vipPower: 10,
                bait: 10
            },
            description: "潜入神秘的深渊海洋，探索未知领域",
            companionRequirement: 10000
        },
       {
            id: "volcano",
            name: "熔岩火山",
            difficulty: "极难",
            duration: 240,
            baseReward: {
                rose: 500,
                vipPower: 35,
                bait: 35
            },
            description: "穿越危险的熔岩火山，寻找传说宝藏",
            companionRequirement: 15000
        },
        {
            id: "emshen",
            name: "虚空裂缝",
            difficulty: "噩梦",
            duration: 480,
            baseReward: {
                rose: 1200,
                vipPower: 120,
                bait: 120
            },
            description: "穿越不稳定的虚空裂缝，直面维度之外的恐怖",
            companionRequirement: 20000
        },
        {
            id: "emyuan",
            name: "星际深渊",
            difficulty: "地狱",
            duration: 960,
            baseReward: {
                rose: 3000,
                vipPower: 480,
                bait: 480
            },
            description: "勇闯无尽的星际深渊，挑战宇宙终极奥秘",
            companionRequirement: 25000
        }
    ]
};

// 初始化伴侣探险数据
function initExpeditionData() {
    if (!player.companionExpedition) {
        player.companionExpedition = {
            currentExpedition: null,
            history: [],
            lastUpdate: Date.now()
        };
    }
}

// 切换探险系统显示
function toggleExpeditionSystem() {
    const ui = document.getElementById('expeditionSystemUI');
    const overlay = document.getElementById('expeditionSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initExpeditionData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateExpeditionUI();
    }
}

// 更新探险系统UI
function updateExpeditionUI() {
    // 更新任务列表
    const tasksContainer = document.getElementById('expeditionTasks');
    tasksContainer.innerHTML = '';
    
    expeditionConfig.tasks.forEach(task => {
        const taskElement = document.createElement('div');
        taskElement.style.background = '#333';
        taskElement.style.padding = '15px';
        taskElement.style.borderRadius = '8px';
        taskElement.innerHTML = `
            <h4>${task.name} (${task.difficulty})</h4>
            <p>${task.description}</p>
            <div style="margin: 10px 0;">
                <div>所需时间: ${task.duration}分钟</div>
                <div>最低伴侣评分: ${task.companionRequirement}</div>
            </div>
            <div style="margin: 10px 0;">
                <strong>基础奖励:</strong>
                <div>玫瑰花: ${task.baseReward.rose}</div>
                <div>VIP能力值: ${task.baseReward.vipPower}</div>
                <div>鱼饵: ${task.baseReward.bait}</div>
            </div>
            <button onclick="startExpedition('${task.id}')" 
                    style="background: #9C27B0; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;"
                    ${player.companionExpedition.currentExpedition ? 'disabled' : ''}>
                开始探险
            </button>
        `;
        tasksContainer.appendChild(taskElement);
    });
    
    // 更新当前探险状态
    const currentContainer = document.getElementById('currentExpedition');
    if (player.companionExpedition.currentExpedition) {
        const task = expeditionConfig.tasks.find(t => t.id === player.companionExpedition.currentExpedition.taskId);
        const startTime = player.companionExpedition.currentExpedition.startTime;
        const duration = task.duration * 60 * 1000; // 转换为毫秒
        const endTime = startTime + duration;
        const remainingTime = Math.max(0, endTime - Date.now());
        const remainingMinutes = Math.ceil(remainingTime / (60 * 1000));
        
        currentContainer.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4>${task.name} (${task.difficulty})</h4>
                    <div>伴侣: ${player.companionExpedition.currentExpedition.companionName}</div>
                    <div>伴侣评分: ${player.companionExpedition.currentExpedition.companionScore}</div>
                </div>
                <div>
                    <div>剩余时间: ${remainingMinutes}分钟</div>
                </div>
            </div>
        `;
    } else {
        currentContainer.innerHTML = '<p>没有进行中的探险</p>';
    }
    
    // 更新探险历史
    const historyContainer = document.getElementById('expeditionHistory');
    historyContainer.innerHTML = '';
    
    if (player.companionExpedition.history.length === 0) {
        historyContainer.innerHTML = '<p>暂无探险记录</p>';
    } else {
        player.companionExpedition.history.slice(0, 5).forEach(record => {
            const task = expeditionConfig.tasks.find(t => t.id === record.taskId);
            const recordElement = document.createElement('div');
            recordElement.style.marginBottom = '10px';
            recordElement.style.paddingBottom = '10px';
            recordElement.style.borderBottom = '1px solid #444';
            recordElement.innerHTML = `
                <div><strong>${task.name}</strong> (${record.companionName})</div>
                <div>评分: ${record.companionScore} | 奖励倍数: ${record.rewardMultiplier.toFixed(2)}x</div>
                <div>获得: 玫瑰花 x${record.rewards.rose}, VIP能力值 x${record.rewards.vipPower}, 鱼饵 x${record.rewards.bait}</div>
                <div style="color: #aaa; font-size: 0.9em;">${new Date(record.endTime).toLocaleString()}</div>
            `;
            historyContainer.appendChild(recordElement);
        });
    }
}

// 开始探险
// 伴侣数据结构增强
class Companion {
    constructor(id, name, rarity, score, talents) {
        this.id = id;
        this.name = name;
        this.rarity = rarity;
        this.score = score;
        this.talents = talents;
        this.locked = false; // 用户设置的锁定状态
        this.onExpedition = false; // 是否在探险中
        this.originalLockedState = false; // 原始锁定状态（用于恢复）
    }
}

// 开始探险
function startExpedition(taskId) {
    if (player.companionExpedition.currentExpedition) {
        logAction("已有进行中的探险", "error");
        return;
    }
    
    const task = expeditionConfig.tasks.find(t => t.id === taskId);
    if (!task) return;
    
    // 检查是否有符合条件的伴侣
    const eligibleCompanions = player.companions.filter(c => 
        c.score >= task.companionRequirement && !c.onExpedition
    );
    
    if (eligibleCompanions.length === 0) {
        logAction("没有符合条件的伴侣", "error");
        return;
    }
    
    // 选择评分最高的伴侣
    const companion = eligibleCompanions.reduce((max, c) => 
        c.score > max.score ? c : max, eligibleCompanions[0]
    );
    
    // 保存原始锁定状态
    companion.originalLockedState = companion.locked;
    
    // 强制锁定伴侣
    companion.locked = true;
    
    // 标记伴侣为探险中
    companion.onExpedition = true;
    
    // 开始探险
    player.companionExpedition.currentExpedition = {
        taskId: task.id,
        companionId: companion.id,
        companionName: companion.name,
        companionScore: companion.score,
        startTime: Date.now()
    };
    
    player.companionExpedition.lastUpdate = Date.now();
    
    logAction(`派遣${companion.name}进行${task.name}探险，伴侣已自动锁定`, "success");
    updateExpeditionUI();
    updateCompanionDisplay();
}

// 完成探险
function completeExpedition(forceComplete = false) {
    if (!player.companionExpedition.currentExpedition) return;
    
    const expedition = player.companionExpedition.currentExpedition;
    const task = expeditionConfig.tasks.find(t => t.id === expedition.taskId);
    const companion = player.companions.find(c => c.id === expedition.companionId);
    
    if (!task || !companion) return;
    
    // 计算实际探险时间
    const startTime = expedition.startTime;
    const duration = task.duration * 60 * 1000; // 转换为毫秒
    const endTime = startTime + duration;
    const currentTime = Date.now();
    
    // 如果强制提前结束，计算实际探险时间比例
    const timeRatio = forceComplete ? 
        Math.min(1, (currentTime - startTime) / duration) : 1;
    
    // 计算奖励倍数（基于伴侣评分）
    const scoreRatio = expedition.companionScore / task.companionRequirement;
    const rewardMultiplier = Math.min(5, Math.max(1, scoreRatio * timeRatio));
    
    // 计算实际奖励
    const rewards = {
        rose: Math.floor(task.baseReward.rose * rewardMultiplier),
        vipPower: Math.floor(task.baseReward.vipPower * rewardMultiplier),
        bait: Math.floor(task.baseReward.bait * rewardMultiplier)
    };
    
    // 发放奖励
    player.items.rose += rewards.rose;
    player.items.vipPower += rewards.vipPower;
    player.items.baitCount += rewards.bait;
    
    // 添加历史记录
    player.companionExpedition.history.unshift({
        taskId: task.id,
        companionId: companion.id,
        companionName: companion.name,
        companionScore: companion.score,
        rewardMultiplier: rewardMultiplier,
        rewards: rewards,
        startTime: startTime,
        endTime: currentTime,
        duration: (currentTime - startTime) / (60 * 1000) // 分钟
    });
    
    // 限制历史记录数量
    if (player.companionExpedition.history.length > 10) {
        player.companionExpedition.history.pop();
    }
    
    // 清除当前探险
    player.companionExpedition.currentExpedition = null;
    
    // 解除伴侣的探险状态
    companion.onExpedition = false;
    
    // 恢复原始锁定状态
    companion.locked = companion.originalLockedState;
    
    logAction(
        `${companion.name}完成${task.name}探险，获得奖励: 玫瑰花x${rewards.rose}, VIP能力值x${rewards.vipPower}, 鱼饵x${rewards.bait}`,
        "success"
    );
    
    logAction(
        `${companion.name}已恢复${companion.locked ? "锁定" : "解锁"}状态`,
        "info"
    );
    
    updateExpeditionUI();
    updateCompanionDisplay();
    updateItemDisplay();
}

// 计算离线探险奖励
function calculateOfflineExpeditionRewards() {
    if (!player.companionExpedition || !player.companionExpedition.currentExpedition) return;
    
    const expedition = player.companionExpedition.currentExpedition;
    const task = expeditionConfig.tasks.find(t => t.id === expedition.taskId);
    const companion = player.companions.find(c => c.id === expedition.companionId);
    
    if (!task || !companion) return;
    
    const startTime = expedition.startTime;
    const duration = task.duration * 60 * 1000; // 转换为毫秒
    const endTime = startTime + duration;
    const currentTime = Date.now();
    
    // 如果探险已经完成
    if (currentTime >= endTime) {
        completeExpedition();
    }
}
// 伴侣商店相关函数
function toggleCompanionShop() {
    const shopUI = document.getElementById('companionShopUI');
    const overlay = document.getElementById('companionShopOverlay');
    
    if (shopUI.style.display === 'block') {
        shopUI.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        shopUI.style.display = 'block';
        overlay.style.display = 'block';
        updateSoulCounts();
    }
}

// 更新灵魂道具数量显示
function updateSoulCounts() {
    document.getElementById('soulCount1').textContent = player.items.banlv1 || 0;
    document.getElementById('soulCount2').textContent = player.items.banlv2 || 0;
    document.getElementById('soulCount3').textContent = player.items.banlv3 || 0;
    document.getElementById('soulCount4').textContent = player.items.banlv4 || 0;
    document.getElementById('soulCount5').textContent = player.items.banlv5 || 0;
    document.getElementById('soulCount6').textContent = player.items.banlv6 || 0;
    document.getElementById('soulCount7').textContent = player.items.banlv7 || 0;
    document.getElementById('soulCount8').textContent = player.items.banlv8 || 0;
    document.getElementById('soulCount9').textContent = player.items.banlv9 || 0;
}

// 灵魂道具兑换函数
function exchangeSoul(fromSoul, toSoul, fromAmount, toAmount) {
    // 确保灵魂道具字段存在
    if (player.items[fromSoul] === undefined) {
        player.items[fromSoul] = 0;
    }
    if (player.items[toSoul] === undefined) {
        player.items[toSoul] = 0;
    }
    
    // 检查是否有足够的灵魂道具
    if (player.items[fromSoul] < fromAmount) {
        const fromName = itemEffects[fromSoul]?.name || fromSoul;
        logAction(`${fromName}不足，需要${fromAmount}个`, "error");
        return;
    }
    
    // 执行兑换
    player.items[fromSoul] -= fromAmount;
    player.items[toSoul] += toAmount;
    
    // 获取道具名称
    const fromName = itemEffects[fromSoul]?.name || fromSoul;
    const toName = itemEffects[toSoul]?.name || toSoul;
    
    // 记录日志
    logAction(`成功兑换：${fromAmount}个${fromName} → ${toAmount}个${toName}`, "success");
    
    // 更新显示
    updateSoulCounts();
    updateItemDisplay();
    saveGame();
}
// 批量开启伴侣宝箱
function drawCompanionMultiple(count) {
    if (player.items.companionKey < count) {
        logAction("伴侣钥匙不足！", "error");
        return;
    }
    
    // 用于统计各品质获得数量
    const rarityCount = {
        white: 0,
        blue: 0,
        epic: 0,
        pink: 0,
        orange: 0,
        red: 0,
        angel: 0,
        emyyyy: 0,
        jlyyyy: 0
    };
    
    // 保存获得的伴侣，用于最后显示
    const companionsObtained = [];
    
    // 执行多次开启
    for (let i = 0; i < count; i++) {
        const result = drawOneCompanion();
        if (result) {
            rarityCount[result.rarity]++;
            companionsObtained.push(result);
        }
    }
    
    // 扣除钥匙
    player.items.companionKey -= count;
    
    // 生成汇总消息
    let message = `开启${count}次伴侣宝箱，获得：`;
    let hasCompanion = false;
    
    for (const rarity in rarityCount) {
        if (rarityCount[rarity] > 0) {
            const rarityName = companionRarities[rarity].name;
            message += `${rarityName}x${rarityCount[rarity]} `;
            hasCompanion = true;
        }
    }
    
    if (!hasCompanion) {
        message += "未获得任何伴侣";
    }
    
    logAction(message, 'success');
    
    // 更新显示
    updateCompanionDisplay();
    updateItemDisplay();
}
// 提取单次开启逻辑到独立函数
function drawOneCompanion() {
    // 更新所有保底计数器
    player.companionChestGuarantee.epic++;
    player.companionChestGuarantee.pink++;
    player.companionChestGuarantee.orange++;
    player.companionChestGuarantee.red++;
    
    let selectedRarity;
    let isGuaranteed = false;
    
    // 检查保底机制（优先级从高到低）
    if (player.companionChestGuarantee.red >= guaranteeThresholds.red) {
        selectedRarity = "red";
        isGuaranteed = true;
        player.companionChestGuarantee.red = 0;
    } else if (player.companionChestGuarantee.orange >= guaranteeThresholds.orange) {
        selectedRarity = "orange";
        isGuaranteed = true;
        player.companionChestGuarantee.orange = 0;
    } else if (player.companionChestGuarantee.pink >= guaranteeThresholds.pink) {
        selectedRarity = "pink";
        isGuaranteed = true;
        player.companionChestGuarantee.pink = 0;
    } else if (player.companionChestGuarantee.epic >= guaranteeThresholds.epic) {
        selectedRarity = "epic";
        isGuaranteed = true;
        player.companionChestGuarantee.epic = 0;
    } else {
        // 没有触发保底，按原概率抽取
        let rand = Math.random();
        let cumulativeProb = 0;
        for (const { rarity, prob } of drawProbabilities) {
            cumulativeProb += prob;
            if (rand < cumulativeProb) {
                selectedRarity = rarity;
                break;
            }
        }
    }
    
    // 生成天赋
    const config = companionRarities[selectedRarity];
    const talentCount = config.talentCount;
    const [minRank, maxRank] = config.talentRange;
    const talents = [];
    
    while (talents.length < talentCount) {
        const type = Math.floor(Math.random() * talentTypes.length);
        const rank = Math.floor(Math.random() * (maxRank - minRank + 1)) + minRank;
        talents.push({ type, rank });
    }
    
    // 计算评分
    const baseScore = config.baseScore;
    const talentScore = talents.reduce((sum, t) => sum + (t.rank + 1) * 50, 0);
    const totalScore = Math.min(10000, baseScore + talentScore);
    
    // 生成伴侣
    const companion = {
        id: 'comp_' + Date.now() + Math.floor(Math.random() * 1000),
        name: companionNames[Math.floor(Math.random() * companionNames.length)],
        rarity: selectedRarity,
        talents,
        score: totalScore,
        locked: false,
        advanceLevel: 0,
        qualityMultiplier: 1.0
    };
    
    player.companions.push(companion);
    
    // 返回获得的伴侣信息
    return {
        rarity: selectedRarity,
        name: companion.name,
        isGuaranteed: isGuaranteed
    };
}

// 抽取伴侣
function drawCompanion() {
    if (player.items.companionKey < 1) {
        logAction("伴侣钥匙不足！", "error");
        return;
    }
    
    player.items.companionKey--;
    
    const result = drawOneCompanion();
    if (result) {
        const rarityName = companionRarities[result.rarity].name;
        logAction(`获得了${rarityName}品质伴侣：${result.name}${result.isGuaranteed ? " (保底)" : ""}`, 'success');
        
        updateCompanionDisplay();
        updateItemDisplay();
    }
}
// 添加伴侣进阶函数
function advanceCompanion(id) {
     const companion = player.companions.find(c => c.id === id);
    if (!companion) return;
    
    // 检查伴侣是否在探险中
    if (companion && companion.onExpedition) {
        logAction(`${companion.name}正在探险中，无法进阶！`, "error");
        return;
    }

    // 检查是否为可进阶品质
    if (!['white','blue','epic','pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity)) {
        logAction("品质的伴侣可以进阶！", "error");
        return;
    }

     // 获取对应的灵魂道具配置
    const rarityConfig = companionRarities[companion.rarity];
    if (!rarityConfig || !rarityConfig.soulItem) {
        logAction("未找到该品质的进阶配置！", "error");
        return;
    }
    
    // 计算当前进阶等级和所需消耗
    const currentLevel = companion.advanceLevel || 0;
    const requiredCount = Math.pow(2, currentLevel); // 1, 2, 4, 8...
    
    // 检查是否有足够的灵魂道具
    const soulItemKey = rarityConfig.soulItem;
    if (!player.items[soulItemKey] || player.items[soulItemKey] < requiredCount) {
        const itemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
        logAction(`需要${requiredCount}个${itemName}才能进阶！`, "error");
        return;
    }
    
    // 消耗灵魂道具
    player.items[soulItemKey] -= requiredCount;
    
    // 提升进阶等级
    companion.advanceLevel = (companion.advanceLevel || 0) + 1;
    companion.score += Math.floor(companion.score * 0.1) + 100;
    updateCompanionStats(companion);
    
    // 提示信息
    const rarityName = companionRarities[companion.rarity].name;
    const itemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
    logAction(`${companion.name}使用${requiredCount}个${itemName}进阶成功！当前进阶等级+${companion.advanceLevel}`, "success");
    
    updateCompanionDisplay();
}
// 升级伴侣等级
function upgradeCompanion() {
    const cost = 10 * player.companionLevel;
    if (player.items.rose < cost) {
        logAction("玫瑰花不足！", "error");
        return;
    }
    
    player.items.rose -= cost;
    player.companionLevel++;
    logAction(`伴侣等级提升至Lv.${player.companionLevel}`, 'success');
    updateCompanionDisplay();
}

// 装备伴侣
function equipCompanion(id) {
    player.equippedCompanionId = id;
    logAction(`已装备伴侣：${player.companions.find(c => c.id === id).name}`, 'success');
    updateCompanionDisplay();
}
// 新增洗练面板相关函数
let currentWashCompanionId = null;

function openWashPanel(companionId) {
    const companion = player.companions.find(c => c.id === companionId);
    if (!companion) return;
    
    currentWashCompanionId = companionId;
    document.getElementById('washPanel').style.display = 'block';
    document.getElementById('settingsOverlay').style.display = 'block';
    document.getElementById('rebornDanCount').textContent = player.items.rebornDan || 0;
    
    // 显示当前伴侣信息
    const infoElement = document.getElementById('washCompanionInfo');
    infoElement.innerHTML = `
        <p>名称: ${companion.name}</p>
        <p>品阶: <span style="color: ${companionRarities[companion.rarity].color}">${companionRarities[companion.rarity].name}</span></p>
        <p>天赋数量: ${companion.talents.length}</p>
        <div style="margin-top: 10px; font-size: 0.9em; max-height: 150px; overflow-y: auto;">
            ${companion.talents.map((t, index) => `${index + 1}. ${talentRanks[t.rank]}${talentTypes[t.type].name}: ${talentTypes[t.type].description(t.rank)}`).join('<br>')}
        </div>
    `;
    
    // 隐藏之前的洗练结果
    document.getElementById('washResult').style.display = 'none';
}

function closeWashPanel() {
    document.getElementById('washPanel').style.display = 'none';
    document.getElementById('settingsOverlay').style.display = 'none';
    currentWashCompanionId = null;
}

function washCompanion() {
    if (!currentWashCompanionId) return;
    
    const companion = player.companions.find(c => c.id === currentWashCompanionId);
  if (companion && companion.onExpedition) {
        logAction(`${companion.name}正在探险中，无法洗练！`, "error");
        return;
    }
    if (!companion) {
        closeWashPanel();
        return;
    }
    
    // 检查还童丹数量
    if ((player.items.rebornDan || 0) < 1) {
        logAction("洗髓丹不足！", "error");
        return;
    }
    
    // 消耗还童丹
    player.items.rebornDan--;
    document.getElementById('rebornDanCount').textContent = player.items.rebornDan;
    
    // 计算洗练效果
    const rand = Math.random();
    let resultText = '';
    const originalTalents = [...companion.talents];
    
    if (rand < 0.7) {
        // 70% 概率：随机洗练1个天赋
        if (companion.talents.length > 0) {
            const index = Math.floor(Math.random() * companion.talents.length);
            const oldTalent = companion.talents[index];
            const oldTalentText = `${talentRanks[oldTalent.rank]}${talentTypes[oldTalent.type].name}`;
            
            // 生成新天赋
            const newType = Math.floor(Math.random() * talentTypes.length);
            const newRank = Math.floor(Math.random() * 9); // 0-8级
            companion.talents[index] = { type: newType, rank: newRank };
            
            const newTalentText = `${talentRanks[newRank]}${talentTypes[newType].name}`;
            resultText = `成功洗练天赋#${index + 1}：${oldTalentText} → ${newTalentText}`;
        } else {
            // 如果没有天赋，自动增加一个
            const newType = Math.floor(Math.random() * talentTypes.length);
            const newRank = Math.floor(Math.random() * 9);
            companion.talents.push({ type: newType, rank: newRank });
            resultText = `为伴侣增加了新天赋：${talentRanks[newRank]}${talentTypes[newType].name}`;
        }
    } else if (rand < 0.9) {
        // 20% 概率：随机洗练2个天赋
        const maxTalents = Math.min(2, companion.talents.length);
        if (maxTalents === 0) {
            // 如果没有天赋，增加两个
            for (let i = 0; i < 2; i++) {
                const newType = Math.floor(Math.random() * talentTypes.length);
                const newRank = Math.floor(Math.random() * 9);
                companion.talents.push({ type: newType, rank: newRank });
            }
            resultText = `为伴侣增加了2个新天赋`;
        } else {
            const changedIndices = new Set();
            while (changedIndices.size < maxTalents) {
                changedIndices.add(Math.floor(Math.random() * companion.talents.length));
            }
            
            resultText = `成功洗练多个天赋：`;
            Array.from(changedIndices).forEach(index => {
                const oldTalent = companion.talents[index];
                const oldTalentText = `${talentRanks[oldTalent.rank]}${talentTypes[oldTalent.type].name}`;
                
                const newType = Math.floor(Math.random() * talentTypes.length);
                const newRank = Math.floor(Math.random() * 9);
                companion.talents[index] = { type: newType, rank: newRank };
                
                const newTalentText = `${talentRanks[newRank]}${talentTypes[newType].name}`;
                resultText += ` #${index + 1}(${oldTalentText}→${newTalentText})`;
            });
        }
    } else if (rand < 0.98) {
        // 8% 概率：随机洗练3个天赋
        const maxTalents = Math.min(3, companion.talents.length);
        if (maxTalents === 0) {
            // 如果没有天赋，增加三个
            for (let i = 0; i < 3; i++) {
                const newType = Math.floor(Math.random() * talentTypes.length);
                const newRank = Math.floor(Math.random() * 9);
                companion.talents.push({ type: newType, rank: newRank });
            }
            resultText = `为伴侣增加了3个新天赋`;
        } else {
            const changedIndices = new Set();
            while (changedIndices.size < maxTalents) {
                changedIndices.add(Math.floor(Math.random() * companion.talents.length));
            }
            
            resultText = `成功洗练多个天赋：`;
            Array.from(changedIndices).forEach(index => {
                const oldTalent = companion.talents[index];
                const oldTalentText = `${talentRanks[oldTalent.rank]}${talentTypes[oldTalent.type].name}`;
                
                const newType = Math.floor(Math.random() * talentTypes.length);
                const newRank = Math.floor(Math.random() * 9);
                companion.talents[index] = { type: newType, rank: newRank };
                
                const newTalentText = `${talentRanks[newRank]}${talentTypes[newType].name}`;
                resultText += ` #${index + 1}(${oldTalentText}→${newTalentText})`;
            });
        }
    } else {
        // 2% 概率：增加1个天赋
        const newType = Math.floor(Math.random() * talentTypes.length);
        const newRank = Math.floor(Math.random() * 9);
        companion.talents.push({ type: newType, rank: newRank });
        resultText = `恭喜！为伴侣额外增加了1个天赋：${talentRanks[newRank]}${talentTypes[newType].name}`;
    }
    
    // 更新伴侣评分
    companion.score = Math.min(1000000, calculateCompanionScore(companion));
    
    // 显示洗练结果
    const resultElement = document.getElementById('washResult');
    resultElement.innerHTML = `<p>${resultText}</p>`;
    resultElement.style.display = 'block';
    
    // 更新显示
    updateCompanionDisplay();
    openWashPanel(currentWashCompanionId); // 刷新面板显示
    
    logAction(`伴侣${companion.name}洗练完成`, 'success');
}
function calculateCompanionScore(companion) {
    const baseScore = companion.score - 5;
    return baseScore;


}
// 切换锁定状态
function toggleCompanionLock(id) {
    const companion = player.companions.find(c => c.id === id);
     if (companion.onExpedition) {
        logAction("伴侣在探险中，无法更改锁定状态", "error");
        return;
    }
    if (companion) {
        companion.locked = !companion.locked;
        logAction(`${companion.name}已${companion.locked ? '锁定' : '解锁'}`, 'success');
        updateCompanionDisplay();
    }
}
// 切换自动分解状态
function toggleAutoDecompose() {
    player.autoDecompose.enabled = !player.autoDecompose.enabled;
    const btn = document.getElementById('toggleAutoDecompose');
    btn.textContent = `自动分解：${player.autoDecompose.enabled ? '开启' : '关闭'}`;
    btn.style.background = player.autoDecompose.enabled ? '#4CAF50' : '#ff9800';
    logAction(`${player.autoDecompose.enabled ? '开启' : '关闭'}自动分解低于${getRarityName(player.autoDecompose.belowRarity)}的伴侣`, 'info');
    
    // 如果开启则立即检查一次
    if (player.autoDecompose.enabled) {
        checkAutoDecompose();
    }
}

// 设置自动分解的品阶阈值
function setAutoDecomposeRarity() {
    const rarity = document.getElementById('autoDecomposeBelowRarity').value;
    player.autoDecompose.belowRarity = rarity;
    logAction(`设置自动分解低于${getRarityName(rarity)}的伴侣`, 'info');
}

// 获取品阶名称
function getRarityName(rarity) {
    const names = {
        'white': '普通(白色)',
        'blue': '稀有(蓝色)',
        'epic': '史诗(紫色)',
        'pink': '卓越(粉色)',
        'orange': '完美(橙色)',
        'red': '神赐(红色)',
        'angel': '天使(彩色)',
        'emyyyy': '恶魔(深红色)',
        'jlyyyy': '精灵(绿色)'
    };
    return names[rarity] || '普通(白色)';
}

// 自动分解检查逻辑
function checkAutoDecompose() {
    if (!player.autoDecompose.enabled) return;
    
    const rarityOrder = ['white', 'blue', 'epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'];
    const targetIndex = rarityOrder.indexOf(player.autoDecompose.belowRarity);
    if (targetIndex === -1) return;
    
    // 找出所有低于等于目标品阶且未锁定的伴侣
    const toDecompose = player.companions.filter(c => 
        rarityOrder.indexOf(c.rarity) <= targetIndex && !c.locked
    );
     
    if (toDecompose.length > 0) {
        // 按品质分组统计
        const decomposeByRarity = {};
        toDecompose.forEach(companion => {
            const rarity = companion.rarity;
            if (!decomposeByRarity[rarity]) {
                decomposeByRarity[rarity] = [];
            }
            decomposeByRarity[rarity].push(companion);
        });
        
        // 计算总玫瑰花奖励
        const totalRoses = toDecompose.reduce((sum, c) => sum + companionRarities[c.rarity].decomposeRose, 0);
        player.items.rose += totalRoses;
        
        // 计算并添加灵魂道具
        for (const rarity in decomposeByRarity) {
            const companionsOfRarity = decomposeByRarity[rarity];
            const soulItemKey = companionRarities[rarity]?.soulItem;
            
            if (soulItemKey) {
                // 初始化灵魂道具数量（如果不存在）
                if (player.items[soulItemKey] === undefined) {
                    player.items[soulItemKey] = 0;
                }
                // 添加灵魂道具
                player.items[soulItemKey] += companionsOfRarity.length;
                
                const soulItemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
                logAction(`自动分解获得${companionsOfRarity.length}个${soulItemName}`, 'info');
            }
        }
        
        // 过滤掉分解的伴侣
        player.companions = player.companions.filter(c => 
            !(rarityOrder.indexOf(c.rarity) <= targetIndex && !c.locked)
        );
      
        // 如果装备的伴侣被分解，取消装备
        if (toDecompose.some(c => c.id === player.equippedCompanionId)) {
            player.equippedCompanionId = null;
        }
        
        logAction(`自动分解${toDecompose.length}个低于${getRarityName(player.autoDecompose.belowRarity)}的伴侣，获得${totalRoses}玫瑰花`, 'success');
        updateCompanionDisplay();
        updateItemDisplay();
        saveGame(); // 保存游戏
    }
}

// 添加到页面初始化函数中
function initAutoDecomposeUI() {
    const raritySelect = document.getElementById('autoDecomposeBelowRarity');
    raritySelect.value = player.autoDecompose.belowRarity;
    raritySelect.onchange = setAutoDecomposeRarity;
    
    const btn = document.getElementById('toggleAutoDecompose');
    btn.textContent = `自动分解：${player.autoDecompose.enabled ? '开启' : '关闭'}`;
    btn.style.background = player.autoDecompose.enabled ? '#4CAF50' : '#ff9800';
}



// 添加定时检查（每5秒一次）
setInterval(checkAutoDecompose, 5000);
// 分解单个伴侣
function decomposeCompanion(id) {
    const companion = player.companions.find(c => c.id === id);
    if (!companion) return;
    
    if (companion.locked) {
        logAction("伴侣已锁定，无法分解！", "error");
        return;
    }
    
    // 获取分解奖励
    const rarityConfig = companionRarities[companion.rarity];
    const roses = rarityConfig ? rarityConfig.decomposeRose : 5; // 默认5朵玫瑰
    
    // 获取对应的灵魂道具
    const soulItemKey = rarityConfig.soulItem;
    const soulItemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
    
    // 移除伴侣
    player.companions = player.companions.filter(c => c.id !== id);
    
    // 如果分解的是装备的伴侣，取消装备
    if (player.equippedCompanionId === id) {
        player.equippedCompanionId = null;
    }
    
    // 添加奖励
    player.items.rose += roses;
    
    // 确保灵魂道具字段存在，然后增加1
    if (soulItemKey) {
        // 初始化灵魂道具数量（如果不存在）
        if (player.items[soulItemKey] === undefined) {
            player.items[soulItemKey] = 0;
        }
        player.items[soulItemKey] += 1;
    }
    
    logAction(`分解${companion.name}获得${roses}朵玫瑰花和1个${soulItemName}`, "success");
    updateCompanionDisplay();
    updateItemDisplay();
}

// 批量分解
function batchDecompose() {
    const rarity = document.getElementById('decomposeRarity').value;
    const toDecompose = player.companions.filter(c => c.rarity === rarity && !c.locked);
   
    if (toDecompose.length === 0) {
        logAction("没有可分解的伴侣", "error");
        return;
    }
    
    const totalRoses = toDecompose.reduce((sum, c) => sum + companionRarities[c.rarity].decomposeRose, 0);
    player.items.rose += totalRoses;
    
    // 获取对应的灵魂道具
    const soulItemKey = companionRarities[rarity].soulItem;
    const soulItemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
    
    // 添加灵魂道具
    if (soulItemKey) {
        // 初始化灵魂道具数量（如果不存在）
        if (player.items[soulItemKey] === undefined) {
            player.items[soulItemKey] = 0;
        }
        player.items[soulItemKey] += toDecompose.length;
    }
    
    // 过滤掉分解的伴侣
    player.companions = player.companions.filter(c => !(c.rarity === rarity && !c.locked));
    
    // 如果装备的伴侣被分解，取消装备
    if (toDecompose.some(c => c.id === player.equippedCompanionId)) {
        player.equippedCompanionId = null;
    }
    
    logAction(`批量分解${toDecompose.length}个${companionRarities[rarity].name}伴侣，获得${totalRoses}玫瑰花和${toDecompose.length}个${soulItemName}`, 'success');
    updateCompanionDisplay();
    updateItemDisplay();
}
// 打开合成面板
function openCombinePanel(mainId = null) {
    // 显示面板
    document.getElementById('combinePanel').style.display = 'block';
    
    // 填充可选伴侣列表
    const mainSelect = document.getElementById('mainCompanionSelect');
    const secondarySelect = document.getElementById('secondaryCompanionSelect');
    
    // 清空现有选项
    mainSelect.innerHTML = '';
    secondarySelect.innerHTML = '';
    
    // 只显示可合成的伴侣（史诗及以上且未锁定）
    const eligibleCompanions = player.companions.filter(c => 
        ['epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(c.rarity) && !c.locked
    );
    
    eligibleCompanions.forEach(companion => {
        const option = document.createElement('option');
        option.value = companion.id;
        option.textContent = `${companion.name} (${companionRarities[companion.rarity].name} +${companion.advanceLevel || 0})`;
        mainSelect.appendChild(option.cloneNode(true));
        secondarySelect.appendChild(option);
    });
    
    // 如果有传入主伴侣ID，设置为主选
    if (mainId && eligibleCompanions.some(c => c.id === mainId)) {
        mainSelect.value = mainId;
    }
    
    // 添加选择事件监听
    mainSelect.onchange = updateCombinePreview;
    secondarySelect.onchange = updateCombinePreview;
    
    // 初始更新预览
    updateCombinePreview();
}

// 关闭合成面板
function closeCombinePanel() {
    document.getElementById('combinePanel').style.display = 'none';
}

// 更新合成预览
function updateCombinePreview() {
    const mainId = document.getElementById('mainCompanionSelect').value;
    const secondaryId = document.getElementById('secondaryCompanionSelect').value;
    
    // 清除相同选择
    if (mainId && secondaryId && mainId === secondaryId) {
        document.getElementById('secondaryCompanionSelect').value = '';
    }
    
    const mainCompanion = player.companions.find(c => c.id === mainId);
   // 显示随机品质加成预览
    document.getElementById('previewQualityMultiplier').textContent = 
        `${(Math.random() * 0.6 + 0.7).toFixed(2)}x`;
    const secondaryCompanion = player.companions.find(c => c.id === secondaryId);
    
    // 更新伴侣信息显示
    updateCompanionInfo('mainCompanionInfo', mainCompanion);
    updateCompanionInfo('secondaryCompanionInfo', secondaryCompanion);
    
    // 更新预览信息
    const previewGeneration = document.getElementById('previewGeneration');
    const previewTalentCount = document.getElementById('previewTalentCount');
    const previewScoreRange = document.getElementById('previewScoreRange');
    
    if (mainCompanion && secondaryCompanion) {
        // 计算可能的代数
        const mainGen = getCompanionGeneration(mainCompanion);
        const secondaryGen = getCompanionGeneration(secondaryCompanion);
        const newGen = Math.max(mainGen, secondaryGen) + 1;
        previewGeneration.textContent = `${newGen}代`;
        
        // 计算可能的天赋数量范围
        const totalTalents = mainCompanion.talents.length + secondaryCompanion.talents.length;
        const minT1 = Math.floor(totalTalents * 0.01);
        const maxT1 = Math.floor(totalTalents * 0.5);
        const minT2 = Math.floor(maxT1 + 1);
        const maxT2 = Math.floor(totalTalents * 0.75);
        const minT3 = maxT2 + 1;
        const maxT3 = Math.floor(totalTalents * 1.0);
        previewTalentCount.textContent = `${minT1}-${maxT3} (80%概率 ${minT1}-${maxT1}, 18%概率 ${minT2}-${maxT2}, 2%概率 ${minT3}-${maxT3})`;
        
        // 计算可能的评分范围
        const minScore = Math.min(mainCompanion.score, secondaryCompanion.score);
        const maxScore = Math.max(mainCompanion.score, secondaryCompanion.score);
        const finalMin = Math.floor(minScore * 0.7); // 最低70%
        const finalMax = Math.ceil(maxScore * 1.3); // 最高130%
        previewScoreRange.textContent = `${finalMin}-${finalMax}`;
    } else {
        previewGeneration.textContent = '--';
        previewTalentCount.textContent = '--';
        previewScoreRange.textContent = '--';
    }
}

// 获取伴侣代数
function getCompanionGeneration(companion) {
    // 检查名字中是否包含代数信息
    const match = companion.name.match(/(\d+)代/);
    if (match) {
        return parseInt(match[1]);
    }
    return 1; // 默认1代
}

// 更新伴侣信息显示
function updateCompanionInfo(elementId, companion) {
    const element = document.getElementById(elementId);
    if (!companion) {
        element.innerHTML = '<p>未选择</p>';
        return;
    }
    
    element.innerHTML = `
        <p>名称: ${companion.name}</p>
        <p>品阶: <span style="color: ${companionRarities[companion.rarity].color}">${companionRarities[companion.rarity].name}</span></p>
        <p>评分: ${companion.score}</p>
        <p>天赋数量: ${companion.talents.length}</p>
        <p>进阶等级: +${companion.advanceLevel || 0}</p>
    `;
}

// 合成伴侣
function combineCompanions() {
    const mainId = document.getElementById('mainCompanionSelect').value;
    const secondaryId = document.getElementById('secondaryCompanionSelect').value;
    
    if (!mainId || !secondaryId || mainId === secondaryId) {
        logAction('请选择不同的主副伴侣', 'error');
        return;
    }
    
    const mainCompanion = player.companions.find(c => c.id === mainId);
    const secondaryCompanion = player.companions.find(c => c.id === secondaryId);
     // 检查伴侣是否在探险中
    if (mainCompanion && mainCompanion.onExpedition) {
        logAction(`${mainCompanion.name}正在探险中，无法合成！`, "error");
        return;
    }
    
    if (secondaryCompanion && secondaryCompanion.onExpedition) {
        logAction(`${secondaryCompanion.name}正在探险中，无法合成！`, "error");
        return;
    }
    if (!mainCompanion || !secondaryCompanion) {
        logAction('选择的伴侣不存在', 'error');
        return;
    }


    // 计算新一代数
    const mainGen = getCompanionGeneration(mainCompanion);
    const secondaryGen = getCompanionGeneration(secondaryCompanion);
    const newGen = Math.max(mainGen, secondaryGen) + 1;
    
    // 随机选择新名字（主或副的名字 + 代数）
    const newName = Math.random() > 0.5 ? 
        `${mainCompanion.name.replace(/ \d+代$/, '')} ${newGen}代` : 
        `${secondaryCompanion.name.replace(/ \d+代$/, '')} ${newGen}代`;
    
    // 计算天赋数量
    const totalTalents = mainCompanion.talents.length + secondaryCompanion.talents.length;
    let newTalentCount;
    const rand = Math.random();
    
    if (rand < 0.80) {
        // 80% 概率：1-50%
        newTalentCount = Math.floor(Math.random() * (totalTalents * 0.5) + totalTalents * 0.2);
    } else if (rand < 0.97) {
        // 18% 概率：50-75%
        newTalentCount = Math.floor(Math.random() * (totalTalents * 0.25) + totalTalents * 0.5);
    } else {
        // 2% 概率：75-100%
        newTalentCount = Math.floor(Math.random() * (totalTalents * 0.25) + totalTalents * 0.75);
    }
    newTalentCount = Math.max(1, newTalentCount); // 至少1个天赋
    
    // 计算新评分（基于主副评分范围，上下浮动30%）
    const minScore = Math.min(mainCompanion.score, secondaryCompanion.score);
    const maxScore = Math.max(mainCompanion.score, secondaryCompanion.score);
    const scoreRange = maxScore * 1.3 - minScore * 0.7;
    const newScore = Math.floor(Math.random() * scoreRange + minScore * 0.7);
    
    // 生成新天赋（结合主副天赋的类型，有几率生成新类型）
    const allTalentTypes = [...mainCompanion.talents.map(t => t.type), ...secondaryCompanion.talents.map(t => t.type), ...Array.from({length: 3}, () => Math.floor(Math.random() * talentTypes.length))];
    const newTalents = [];
    
    for (let i = 0; i < newTalentCount; i++) {
        // 随机选择天赋类型（优先从主副天赋中选择）
        const type = allTalentTypes[Math.floor(Math.random() * allTalentTypes.length)];
        
        // 天赋天赋等级（基于主副天赋等级范围）
        const mainRanks = mainCompanion.talents.filter(t => t.type === type).map(t => t.rank);
        const secondaryRanks = secondaryCompanion.talents.filter(t => t.type === type).map(t => t.rank);
        const allRanks = [...mainRanks, ...secondaryRanks];
        
        let rank;
        if (allRanks.length > 0) {
            const minRank = Math.min(...allRanks);
            const maxRank = Math.max(...allRanks);
            // 上下浮动30%
            const newMin = Math.max(0, Math.floor(minRank * 0.7));
            const newMax = Math.min(8, Math.ceil(maxRank * 1.3));
            rank = Math.floor(Math.random() * (newMax - newMin + 1)) + newMin;
        } else {
            // 如果没有相同类型的天赋，随机生成
            rank = Math.floor(Math.random() * 9); // 0-8级
        }
        
        newTalents.push({ type, rank });
    }
   const newAdvanceLevel = Math.max(
        mainCompanion.advanceLevel || 0,
        secondaryCompanion.advanceLevel || 0
    );
  
    const rarities = ['angel', 'emyyyy', 'jlyyyy'];
    const randomIndex = Math.floor(Math.random() * rarities.length);
    const selectedRarity = rarities[randomIndex];
    // 创建新伴侣
    const newCompanion = {
        id: 'comp_' + Date.now() + Math.floor(Math.random() * 1000),
        name: newName,
        rarity: selectedRarity,// 合成后为天使品质
        talents: newTalents,
        score: Math.min(1000000, newScore), // 天使品质上限更高
        locked: false,
        advanceLevel: newAdvanceLevel,
       qualityMultiplier: qualityMultiplier // 添加品质加成
    };
    
    // 移除主副伴侣
    player.companions = player.companions.filter(c => c.id !== mainId && c.id !== secondaryId);
    
    // 如果装备的是被合成的伴侣，取消装备
    if (player.equippedCompanionId === mainId || player.equippedCompanionId === secondaryId) {
        player.equippedCompanionId = null;
    }
    
    // 添加新伴侣
    player.companions.push(newCompanion);
    
    // 提示信息
   logAction(`成功合成${newGen}代特殊伴侣：${newName}（保留最高进阶等级${newAdvanceLevel}）`, 'success');
    
    // 更新显示
    updateCompanionDisplay();
    closeCombinePanel();
}
// 计算伴侣天赋加成（需要整合到属性计算中）
function getCompanionBonuses() {
    if (!player.equippedCompanionId) return {
        attackMultiplier: 1,
        critDamageMultiplier: 1,
        healthMultiplier: 1,
        allStatsMultiplier: 1,
        combo: 0,
        critRateMultiplier: 1
    };
    
    const companion = player.companions.find(c => c.id === player.equippedCompanionId);
    if (!companion) return {
        attackMultiplier: 1,
        critDamageMultiplier: 1,
        healthMultiplier: 1,
        allStatsMultiplier: 1,
        combo: 0,
        critRateMultiplier: 1
    };
    
    // 基础加成
    let bonuses = {
        attackMultiplier: 1,
        critDamageMultiplier: 1,
        healthMultiplier: 1,
        allStatsMultiplier: 1,
        combo: 0,
        critRateMultiplier: 1
    };
    
    // 应用天赋
    companion.talents.forEach(talent => {
        const rank = talent.rank;
        const type = talentTypes[talent.type];
        const baseMultiplier = companionRarities[companion.rarity].upgradeMultiplier;
const scoreDivided = Math.floor(companion.score / 100);
const qualityMultiplier = (scoreDivided + baseMultiplier) * player.companionLevel;
  const advanceMultiplier = 1 + (companion.advanceLevel * 1);;
        switch (talent.type) {
            case 0: // 攻击
                bonuses.attackMultiplier += (type.base + type.perLevel * rank) * qualityMultiplier * advanceMultiplier;
                break;
            case 1: // 爆伤
                bonuses.critDamageMultiplier += (type.base + type.perLevel * rank) * qualityMultiplier * advanceMultiplier;
                break;
            case 2: // 生命
                bonuses.healthMultiplier += (type.base + type.perLevel * rank) * qualityMultiplier * advanceMultiplier;
                break;
            case 3: // 全属性
                bonuses.allStatsMultiplier += (type.base + type.perLevel * rank) * qualityMultiplier * advanceMultiplier;
                break;
            case 4: // 连击
                bonuses.combo += (type.base + type.perLevel * rank) * 50 * advanceMultiplier;
                break;
            case 5: // 暴击率
                bonuses.critRateMultiplier += (type.base + type.perLevel * rank) * qualityMultiplier * advanceMultiplier;
                break;
        }
    });
    
    // 全属性加成应用到攻击和爆伤
    bonuses.attackMultiplier += bonuses.allStatsMultiplier;
    bonuses.critDamageMultiplier += bonuses.allStatsMultiplier;
    
    return bonuses;
}

// 切换通天塔UI
function toggleTowerUI() {
    // 检查转生次数是否达到100次（和普通打怪模式一致）
    if (player.reincarnationCount < 100) {
        alert("需要达到100转才能开启通天塔模式！");
        return;
    }
  
    const towerUI = document.getElementById('towerUI');
    towerUI.style.display = towerUI.style.display === 'none' ? 'block' : 'none';
    if (towerUI.style.display === 'block') {
        // 初始化玩家属性
        generateTowerMonster();
        initTowerPlayerStats();
        player.tower.playerHealth = player.battle.playerHealth;
    player.tower.playerAttack = player.battle.playerAttack;
    player.tower.playerCritRate = player.battle.playerCritRate;
    player.tower.playerCritDamage = player.battle.playerCritDamage;
    player.tower.playerAccuracy = player.battle.playerAccuracy;
    player.tower.playerDodge = player.battle.playerDodge;
        // 如果没有当前怪物，生成一个
        if (!player.tower.monster) {
            generateTowerMonster();
        }
        updateTowerUI();
    }
}

// 初始化通天塔玩家属性
function initTowerPlayerStats() {
    player.tower.playerHealth = player.battle.playerHealth;
    player.tower.playerAttack = player.battle.playerAttack;
    player.tower.playerCritRate = player.battle.playerCritRate;
    player.tower.playerCritDamage = player.battle.playerCritDamage;
    player.tower.playerMultiAttack = player.battle.playerMultiAttack;
}

// 生成通天塔怪物
function generateTowerMonster() {
    const floor = player.tower.currentFloor;
    const monsterRanks = ['普通', '精英', '普通BOSS', '特殊BOSS', '领主BOSS', '霸主级BOSS', '王级BOSS', '皇级BOSS', '帝级BOSS', '神级BOSS', '圣级BOSS'];
    const rankProbabilities = [0.45, 0.20, 0.10, 0.06, 0.05, 0.04, 0.03, 0.03, 0.02, 0.015, 0.005];

    // 随机生成怪物品阶
    let rankIndex = 0;
    let rand = Math.random();
    for (let i = 0; i < rankProbabilities.length; i++) {
        rand -= rankProbabilities[i];
        if (rand < 0) {
            rankIndex = i;
            break;
        }
    }
    const rank = monsterRanks[rankIndex];

    // 根据品阶选择词条
    const modifierPool = monsterRankModifiers[rank].pool;
    const selectCount = monsterRankModifiers[rank].selectCount;
    const selectedModifiers = [];
    const usedModifiers = new Set();

    for (let i = 0; i < selectCount; i++) {
        let modifier;
        do {
            modifier = modifierPool[Math.floor(Math.random() * modifierPool.length)];
        } while (usedModifiers.has(modifier));
        usedModifiers.add(modifier);
        selectedModifiers.push(modifier);
    }

    // 计算怪物属性（通天塔特殊逻辑）
    const baseHealth = 10000000000; // 初始1亿血量
    const healthMultiplier = Math.pow(1.00693, floor); // 每层乘以1.00693
    let attackMultiplier;
    
    if (floor <= 5) {
      attackMultiplier = Math.floor(Math.random() * 50) + 30;
    } else if (floor <= 150) {
      attackMultiplier = Math.floor(Math.random() * 100) + 100;
    } else if (floor <= 300) {
      attackMultiplier = 300 + (floor - 149) * 50;
    } else if (floor <= 1000) {
      attackMultiplier = 1000 + (floor - 299) * 100;
    } else if (floor <= 5000) {
      attackMultiplier = 5000 + (floor - 999) * 10000;
    } else if (floor <= 10000) {
      attackMultiplier = 10000 + (floor - 4999) * 10000000;
    } else if (floor <= 20000) {
      attackMultiplier = 200000 + (floor - 9999) * 10000000000000;
    } else if (floor <= 30000) {
      attackMultiplier = 3000000 + (floor - 19999) * 100000000000000000000;
    } else if (floor <= 50000) {
      attackMultiplier = 50000000 + (floor - 29999) * 100000000000000000000000000000;
    } else if (floor <= 60000) {
      attackMultiplier = 60000000 + (floor - 49999) * 100000000000000000000000000000000000000000;
   }  else if (floor <= 70000) {
     attackMultiplier = 70000000 + (floor - 59999) * 10000000000000000000000000000000000000000000000000000000000;
    } else if (floor <= 80000) {
     attackMultiplier = 80000000 + (floor - 69999) * 10000000000000000000000000000000000000000000000000000000000000000000000;
    } else {
      attackMultiplier = 90000000 + (floor - 79999) * 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    }

    let attack = attackMultiplier * (10 + floor * 500);
    let damageReduction = 0;
    let dodgeChance = 0;
    let blockCount = 0;
    let attackCount = 1;
    let damageTakenMultiplier = 1;

    selectedModifiers.forEach(modifier => {
        const effect = monsterModifiers[modifier];
        if (effect.attackMultiplier) attack *= effect.attackMultiplier;
        if (effect.damageReduction) damageReduction += effect.damageReduction;
        if (effect.dodgeChance) dodgeChance += effect.dodgeChance;
        if (effect.blockCount) blockCount += effect.blockCount;
        if (effect.attackCount) attackCount = effect.attackCount;
        if (effect.damageTakenMultiplier) damageTakenMultiplier *= effect.damageTakenMultiplier;
    });

    // 生成怪物，包含复活次数
    player.tower.monster = {
        name: `${getRandomMonsterName()} 等级${Math.floor(attackMultiplier * 2 + 7)}`,
        rank: rank,
        health: baseHealth * healthMultiplier,
        maxHealth: baseHealth * healthMultiplier,
        attack: attack,
        modifiers: selectedModifiers,
        damageReduction: damageReduction,
        dodgeChance: dodgeChance,
        blockCount: blockCount,
        attackCount: attackCount,
        damageTakenMultiplier: damageTakenMultiplier,
        resurrectionsLeft: 20 // 20次复活机会
    };
}

// 攻击通天塔怪物
function attackTowerMonster() {
// 使用打怪模式属性
    const playerAttack = player.battle.playerAttack;
    const playerCritRate = player.battle.playerCritRate;
    const playerCritDamage = player.battle.playerCritDamage;
    const playerMultiAttack = player.battle.playerMultiAttack;

    if (!player.tower.monster) return;
    
    const monster = player.tower.monster;
    let totalDamage = 0;
    let normalDamage = 0;
    let critDamage = 0;
    let critCount = 0;
    let dodgeCount = 0;
    let totalAttacks = player.tower.playerMultiAttack || 1;
    let battleLogs = [];
    let monsterDefeated = false;

    // 玩家攻击
    for (let i = 0; i < totalAttacks; i++) {
        // 检查是否已被击败
        if (monster.health <= 0) break;
        
        // 检查闪避
        if (Math.random() < monster.dodgeChance) {
            dodgeCount++;
            battleLogs.push(`${monster.name}闪避了你的攻击！`);
            continue;
        }
        
        // 计算基础伤害
        let damage = player.tower.playerAttack;
        
        // 应用伤害减免
        damage *= (1 - monster.damageReduction);
        
        // 应用伤害乘数
        damage *= monster.damageTakenMultiplier;
        
        // 检查暴击
        let isCrit = Math.random() < player.tower.playerCritRate;
        if (isCrit) {
            damage *= player.tower.playerCritDamage;
            critCount++;
            critDamage += damage;
        } else {
            normalDamage += damage;
        }
        
        // 应用伤害
        monster.health -= damage;
        totalDamage += damage;
        
        battleLogs.push(`你对${monster.name}造成了${Math.floor(damage)}点伤害${isCrit ? '（暴击！）' : ''}`);
        
        // 检查怪物是否被击败
        if (monster.health <= 0) {
            // 检查是否还有复活次数
            if (monster.resurrectionsLeft > 0) {
                monster.resurrectionsLeft--;
                monster.health = monster.maxHealth; // 复活回满血
                battleLogs.push(`${monster.name}复活了！剩余复活次数: ${monster.resurrectionsLeft}`);
                
                // BOSS复活后立刻攻击玩家1次
                towerMonsterCounterAttack();
            } else {
                battleLogs.push(`你击败了${monster.name}！`);
                monsterDefeated = true;
            }
            break; // 结束当前连击
          initTowerPlayerStats();
         updateOfficialSystemDisplay();
        updateMonsterUI(); // 更新UI显示
        }
    }

    // 输出综合攻击日志
    battleLogs.push(`你造成了${Math.floor(totalDamage)}点伤害 (${totalAttacks}连击) - 普通伤害: ${Math.floor(normalDamage)}, 闪避x${dodgeCount}, 暴击x${critCount}`);
    
    // 添加到战斗日志
    battleLogs.forEach(log => {
        addTowerBattleLog(log);
    });

    // 如果怪物被彻底击败（无复活次数）
    if (monsterDefeated) {
        player.tower.currentFloor++;
        player.tower.maxFloor = Math.max(player.tower.maxFloor, player.tower.currentFloor);
        addTowerBattleLog(`通关通天塔第${player.tower.currentFloor}层！`);
        checkTitleUnlocks();
        // 更新总属性点
        player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
        player.attributes.remainingPoints++; // 每通关一层增加1点剩余属性点
        initTowerPlayerStats();
        // 自动进入下一关
        generateTowerMonster();
        updateTowerUI();
        return;
    }

    // 怪物反击（如果还活着）
    if (monster.health > 0) {
        towerMonsterCounterAttack();
    }

    // 检查玩家是否被击败
    if (player.tower.playerHealth <= 0) {
        addTowerBattleLog('你被怪物击败了！');
       // 重置当前层怪物
        generateTowerMonster();
        // 重置玩家状态
        initTowerPlayerStats();
      
      
    }

    updateTowerUI();

}

// 通天塔怪物反击
function towerMonsterCounterAttack() {
    const monster = player.tower.monster;
    if (!monster || monster.health <= 0) return;
    
    for (let i = 0; i < monster.attackCount; i++) {
        // 检查玩家闪避
        if (Math.random() < (player.attributes.dodge * 0.001 || 0)) {
            addTowerBattleLog(`你闪避了${monster.name}的攻击！`);
            continue;
        }        
        
        // 玩家受到伤害
        player.tower.playerHealth -= monster.attack;
        addTowerBattleLog(`${monster.name}对你造成了${monster.attack}点伤害`);
        
        // 检查玩家是否被击败
        if (player.tower.playerHealth <= 0) {
            break;
        }
    }
}

// 切换通天塔自动攻击
function toggleTowerAutoAttack() {
    player.tower.isAutoAttacking = !player.tower.isAutoAttacking;
    document.getElementById('towerAutoAttackStatus').textContent = player.tower.isAutoAttacking ? '开' : '关';
    
    if (player.tower.isAutoAttacking) {
        startTowerAutoAttack();
    } else {
        stopTowerAutoAttack();
    }
}

// 开始通天塔自动攻击
function startTowerAutoAttack() {
    // 先停止现有的自动攻击
    stopTowerAutoAttack();
    
    // 每秒攻击10次
    player.tower.autoAttackInterval = setInterval(() => {
        if (player.tower.isAutoAttacking && player.tower.monster) {
            attackTowerMonster();
        }
    }, 100);
}

// 停止通天塔自动攻击
function stopTowerAutoAttack() {
    if (player.tower.autoAttackInterval) {
        clearInterval(player.tower.autoAttackInterval);
        player.tower.autoAttackInterval = null;
    }
}

// 添加通天塔战斗日志
function addTowerBattleLog(message) {
    player.tower.battleLog.push({
        time: new Date(),
        message: message
    });
    
    // 限制日志长度
    if (player.tower.battleLog.length > 10) {
        player.tower.battleLog.shift();
    }
    
    // 更新UI显示
    updateTowerBattleLog();
}

// 更新通天塔战斗日志UI
function updateTowerBattleLog() {
    const logElement = document.getElementById('towerBattleLog');
    logElement.innerHTML = '';
    
    player.tower.battleLog.forEach(entry => {
        const logItem = document.createElement('div');
        logItem.className = 'battle-log-entry';
        logItem.textContent = entry.message;
        logElement.appendChild(logItem);
    });
    
    // 滚动到底部
    logElement.scrollTop = logElement.scrollHeight;
}

// 更新通天塔UI
function updateTowerUI() {
    // 更新玩家信息
    document.getElementById('towerPlayerHealth').textContent = Math.floor(player.tower.playerHealth).toExponential(3);
    document.getElementById('towerPlayerAttack').textContent = player.tower.playerAttack.toExponential(3);
    document.getElementById('towerPlayerCritRate').textContent = (player.tower.playerCritRate * 100).toFixed(1) + '%';
    document.getElementById('towerPlayerCritDamage').textContent = ((player.tower.playerCritDamage - 1) * 100).toFixed(1) + '%';

    // 更新通天塔层数显示
    document.getElementById('towerFloor').textContent = player.tower.currentFloor;
    document.getElementById('towerCurrentFloor').textContent = player.tower.currentFloor;
    
    const bonus = player.tower.currentFloor * 0.1; // 每层增加0.1%
    document.getElementById("towerBonus").textContent = bonus.toFixed(1) + "倍";
    // 更新怪物信息
    if (player.tower.monster) {
        const monster = player.tower.monster;
        document.getElementById('towerMonsterName').textContent = monster.name;
        document.getElementById('towerMonsterRank').textContent = monster.rank;
        document.getElementById('towerMonsterHealth').textContent = Math.floor(monster.health).toExponential(3); + '/' + Math.floor(monster.maxHealth).toExponential(3);
        document.getElementById('towerMonsterAttack').textContent = monster.attack.toExponential(3);
        document.getElementById('towerMonsterModifiers').textContent = monster.modifiers.join(', ');
        document.getElementById('towerMonsterResurrections').textContent = monster.resurrectionsLeft;
    }
    
    // 更新自动攻击状态
    document.getElementById('towerAutoAttackStatus').textContent = player.tower.isAutoAttacking ? '开' : '关';
    // 更新战斗日志
    updateTowerBattleLog();
}






// 官职配置
const officialConfig = [
    { level: 1, name: "将仕郎（九品）", attackMultiplier: 5, cost: 100 },
    { level: 2, name: "文林郎（九品）", attackMultiplier: 10, cost: 1000 },
    { level: 3, name: "登仕郎（九品）", attackMultiplier: 50, cost: 10000 },
    { level: 4, name: "儒林郎（九品）", attackMultiplier: 100, cost: 100000 },
    { level: 5, name: "承务郎（八品）", attackMultiplier: 500, cost: 1000000 },
    { level: 6, name: "承奉郎（八品）", attackMultiplier: 1000, cost: 1000000 },
    { level: 7, name: "征事郎（八品）", attackMultiplier: 5000, cost: 10000000 },
    { level: 8, name: "给事郎（八品）", attackMultiplier: 10000, cost: 100000000 },
    { level: 9, name: "宣议郎（七品）", attackMultiplier: 50000, cost: 1000000000 },
    { level: 10, name: "朝散郎（七品）", attackMultiplier: 100000, cost: 1000000000 },
    { level: 11, name: "武骑尉（七品）", attackMultiplier: 500000, cost: 10000000000 },
    { level: 12, name: "宣德郎（七品）", attackMultiplier: 1000000, cost: 100000000000 },
    { level: 13, name: "朝请郎（七品）", attackMultiplier: 5000000, cost: 1000000000000 },
    { level: 14, name: "云骑尉（七品）", attackMultiplier: 10000000, cost: 10000000000000 },
    { level: 15, name: "通直郎（六品）", attackMultiplier: 50000000, cost: 100000000000000 },
    { level: 16, name: "奉议郎（六品）", attackMultiplier: 100000000, cost: 1000000000000000 },
    { level: 17, name: "飞骑尉（六品）", attackMultiplier: 500000000, cost: 10000000000000000 },
    { level: 18, name: "飞骑尉（六品）", attackMultiplier: 1000000000, cost: 100000000000000000 },
    { level: 19, name: "承议郎（六品）", attackMultiplier: 5000000000, cost: 1000000000000000000 },
    { level: 20, name: "承议郎（六品）", attackMultiplier: 10000000000, cost: 10000000000000000000 },
    { level: 21, name: "朝议郎（六品）", attackMultiplier: 50000000000, cost: 100000000000000000000 },
    { level: 22, name: "晓骑尉（六品）", attackMultiplier: 100000000000, cost: 1000000000000000000000 },
    { level: 23, name: "游击将军（五品）", attackMultiplier: 500000000000, cost: 10000000000000000000000 },
    { level: 24, name: "游击将军（五品）", attackMultiplier: 1000000000000, cost: 100000000000000000000000 },
    { level: 25, name: "游骑将军（五品）", attackMultiplier: 5000000000000, cost: 1000000000000000000000000 },
    { level: 26, name: "骑都尉（五品）", attackMultiplier: 10000000000000, cost: 10000000000000000000000000 },
    { level: 27, name: "怀化郎将（五品）", attackMultiplier: 50000000000000, cost: 100000000000000000000000000 },
    { level: 28, name: "宁远将军（五品）", attackMultiplier: 100000000000000, cost: 1000000000000000000000000000 },
    { level: 29, name: "定远将军（五品）", attackMultiplier: 500000000000000, cost: 10000000000000000000000000000 },
    { level: 30, name: "归德中郎将（四品）", attackMultiplier: 1000000000000000, cost: 100000000000000000000000000000 },
    { level: 31, name: "明威将军（四品）", attackMultiplier: 5000000000000000, cost: 1000000000000000000000000000000 },
    { level: 32, name: "宣威将军（四品）", attackMultiplier: 10000000000000000, cost: 10000000000000000000000000000000 },
    { level: 33, name: "轻车都尉（四品）", attackMultiplier: 50000000000000000, cost: 100000000000000000000000000000000 },
    { level: 34, name: "怀化中郎将（四品）", attackMultiplier: 100000000000000000, cost: 1000000000000000000000000000000000 },
    { level: 35, name: "忠武将军（四品）", attackMultiplier: 500000000000000000, cost: 10000000000000000000000000000000000 },
    { level: 36, name: "归德将军（三品）", attackMultiplier: 1000000000000000000, cost: 100000000000000000000000000000000000 },
    { level: 37, name: "云麾将军（三品）", attackMultiplier: 5000000000000000000, cost: 1000000000000000000000000000000000000 },
    { level: 38, name: "护军（三品）", attackMultiplier: 10000000000000000000, cost: 10000000000000000000000000000000000000 },
    { level: 39, name: "怀化大将军（三品）", attackMultiplier: 50000000000000000000, cost: 100000000000000000000000000000000000000 },
    { level: 40, name: "冠军大将军（三品）", attackMultiplier: 100000000000000000000, cost: 1000000000000000000000000000000000000000 },
    { level: 41, name: "镇军大将军（二品）", attackMultiplier: 500000000000000000000, cost: 10000000000000000000000000000000000000000 },
    { level: 42, name: "辅国大将军（二品）", attackMultiplier: 1000000000000000000000, cost: 100000000000000000000000000000000000000000 },
    { level: 43, name: "骠骑大将军（一品）", attackMultiplier: 5000000000000000000000, cost: 1000000000000000000000000000000000000000000 },
    { level: 44, name: "异地王（特品）", attackMultiplier: 10000000000000000000000, cost: 10000000000000000000000000000000000000000000 },
    { level: 45, name: "王爷（特品）", attackMultiplier: 50000000000000000000000, cost: 100000000000000000000000000000000000000000000 },
    { level: 46, name: "国师（特品）", attackMultiplier: 100000000000000000000000, cost: 1000000000000000000000000000000000000000000000 },
    { level: 47, name: "丞相（特品）", attackMultiplier: 500000000000000000000000, cost: 10000000000000000000000000000000000000000000000 },
    { level: 48, name: "辅佐王（特品）", attackMultiplier: 1000000000000000000000000, cost: 100000000000000000000000000000000000000000000000 },
    { level: 49, name: "监证（圣品）", attackMultiplier: 5000000000000000000000000, cost: 1000000000000000000000000000000000000000000000000 },
    { level: 50, name: "七皇子（圣品）", attackMultiplier: 10000000000000000000000000, cost: 10000000000000000000000000000000000000000000000000 },
    { level: 51, name: "六皇子（圣品）", attackMultiplier: 50000000000000000000000000, cost: 100000000000000000000000000000000000000000000000000 },
    { level: 52, name: "五皇子（圣品）", attackMultiplier: 100000000000000000000000000, cost: 1000000000000000000000000000000000000000000000000000 },
    { level: 53, name: "四皇子（圣品）", attackMultiplier: 500000000000000000000000000, cost: 10000000000000000000000000000000000000000000000000000 },
    { level: 54, name: "三皇子（神品）", attackMultiplier: 1000000000000000000000000000, cost: 100000000000000000000000000000000000000000000000000000 },
    { level: 55, name: "二皇子（神品）", attackMultiplier: 5000000000000000000000000000, cost: 1000000000000000000000000000000000000000000000000000000 },
    { level: 56, name: "一皇子（神品）", attackMultiplier: 10000000000000000000000000000, cost: 10000000000000000000000000000000000000000000000000000000 },
    { level: 57, name: "大殿下（神品）", attackMultiplier: 50000000000000000000000000000, cost: 100000000000000000000000000000000000000000000000000000000 },
    { level: 58, name: "太子爷（仙品）", attackMultiplier: 100000000000000000000000000000, cost: 1000000000000000000000000000000000000000000000000000000000 },
    { level: 59, name: "皇帝（仙品）", attackMultiplier: 500000000000000000000000000000, cost: 10000000000000000000000000000000000000000000000000000000000 },
    { level: 60, name: "太上皇（仙品）", attackMultiplier: 1000000000000000000000000000000, cost: 100000000000000000000000000000000000000000000000000000000000 },
  { level: 61, name: "仙兵（帝品）", attackMultiplier: 10000000000000000000000000000000, cost: 1000000000000000000000000000000000000000000000000000000000000000 },
 { level: 62, name: "仙君（帝品）", attackMultiplier: 50000000000000000000000000000000, cost: 100000000000000000000000000000000000000000000000000000000000000000000 },
 { level: 63, name: "仙皇（帝品）", attackMultiplier: 100000000000000000000000000000000, cost: 10000000000000000000000000000000000000000000000000000000000000000000000000 },
 { level: 64, name: "仙王（帝品）", attackMultiplier: 500000000000000000000000000000000, cost: 1000000000000000000000000000000000000000000000000000000000000000000000000000000 },
 { level: 65, name: "仙帝（帝品）", attackMultiplier: 1000000000000000000000000000000000, cost: 100000000000000000000000000000000000000000000000000000000000000000000000000000000000 }

];

// 切换官职系统界面显示
function toggleOfficialSystem() {
   if (player.reincarnationCount < 10) {
        alert("需要达到10转才能开启官职系统！");
        return;
    }
    const ui = document.getElementById('officialSystemUI');
    const overlay = document.getElementById('officialSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateOfficialSystemDisplay();
    }
}

// 更新官职系统界面显示
function updateOfficialSystemDisplay() {
    const currentLevel = player.officialLevel;
    let currentOfficial = null;
    let nextOfficial = null;
    
    if (currentLevel > 0) {
        currentOfficial = officialConfig.find(oc => oc.level === currentLevel);
    }
    
    if (currentLevel < 65) {
        nextOfficial = officialConfig.find(oc => oc.level === currentLevel + 1);
    }
    
    // 更新当前官职显示
    document.getElementById('officialTitleDisplay').textContent = currentOfficial ? currentOfficial.name : '无';
    document.getElementById('officialLevelDisplay').textContent = currentLevel;
    document.getElementById('officialBonusDisplay').textContent = currentOfficial ? currentOfficial.attackMultiplier : 1;
    document.getElementById('currentOfficialTitle').textContent = currentOfficial ? currentOfficial.name : '无';
    
    // 更新下一阶官职信息
    const nextOfficialEl = document.getElementById('nextOfficialInfo');
    if (nextOfficial) {
        nextOfficialEl.innerHTML = `${nextOfficial.name} - 攻击加成: ${nextOfficial.attackMultiplier}倍, 消耗: ${formatNumber(nextOfficial.cost)}转生币`;
    } else if (currentLevel >= 65) {
        nextOfficialEl.textContent = '已达到最高官职';
    } else {
        nextOfficialEl.textContent = '请升级官职';
    }
}

// 按指定次数升级官职
function upgradeOfficialByAmount() {
    const amount = parseInt(document.getElementById('officialUpgradeAmount').value) || 1;
    let upgraded = 0;
    
    for (let i = 0; i < amount; i++) {
        if (!upgradeOfficial()) {
            break;
        }
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级官职！`, 'success');
        updateOfficialSystemDisplay();
        updateDisplay();
    }
}        

// 一键升级到最大可能等级
function upgradeOfficialMaxPossible() {
    let upgraded = 0;
    
    while (upgradeOfficial()) {
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级官职！`, 'success');
        updateOfficialSystemDisplay();
        updateDisplay();
    }
}

// 升级一级官职
function upgradeOfficial() {
    const nextLevel = player.officialLevel + 1;
    if (nextLevel > 65) {
        logAction("已达到最高官职！", "error");
        return false;
    }
    
    const nextOfficial = officialConfig.find(oc => oc.level === nextLevel);
    if (!nextOfficial) {
        logAction("无法找到下一阶官职配置！", "error");
        return false;
    }
    
    if (player.reincarnationCoin >= nextOfficial.cost) {
        player.reincarnationCoin -= nextOfficial.cost;
        player.officialLevel = nextLevel;
        return true;
    } else {
        logAction("转生币不足，无法升级官职！", "error");
        return false;
    }
}

// 添加格式化大数字的函数（如果没有的话）
function formatNumber(num) {
    if (num >= 1e8) {
        return num.toExponential(3);
    } else {
        return num.toLocaleString();
    }
}
function getOfficialBonus() {
    if (player.officialLevel === 0) return 1;
    
    const official = officialConfig.find(oc => oc.level === player.officialLevel);
    return official ? official.attackMultiplier : 1;
}

// 职业配置
const classConfig = {
    warrior: {
        name: "战士",
        branches: [
            {
                requiredStage: 20,
                options: [
                    {desc: "玩家攻击加成总和提升10倍", type: "attackMultiplier", value: 10},
                    {desc: "玩家爆伤总和提升10倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 10}},
                    {desc: "玩家生命加成总和提升2倍", type: "healthMultiplier", value: 2}
                ]
            },
            {
                requiredStage: 50,
                options: [
                    {desc: "玩家攻击加成总和提升200倍", type: "attackMultiplier", value: 200},
                    {desc: "玩家爆伤总和提升200倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 200}},
                    {desc: "玩家生命加成总和提升4倍", type: "healthMultiplier", value: 5}
                ]
            },
            {
                requiredStage: 100,
                options: [
                    {desc: "玩家攻击加成总和提升2000倍", type: "attackMultiplier", value: 2000},
                    {desc: "玩家爆伤总和提升2000倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 2000}},
                    {desc: "玩家生命加成总和提升5倍", type: "healthMultiplier", value: 5}
                ]
            },
            {
                requiredStage: 200,
                options: [
                    {desc: "玩家攻击加成总和提升20000倍", type: "attackMultiplier", value: 20000},
                    {desc: "玩家爆伤总和提升20000倍伤害", type: "critMultiplier", value: {chance: 0.01, multiplier: 20000}},
                    {desc: "玩家生命加成总和提升8倍", type: "healthMultiplier", value: 8}
                ]
            },
            {
                requiredStage: 300,
                options: [
                    {desc: "玩家攻击加成总和提升200000倍", type: "attackMultiplier", value: 200000},
                    {desc: "玩家爆伤总和提升200000倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 200000}},
                    {desc: "玩家生命加成总和提升10倍", type: "healthMultiplier", value: 10}
                ]
            },
            {
                requiredStage: 400,
                options: [
                    {desc: "玩家攻击加成总和提升2000000倍", type: "attackMultiplier", value: 2000000},
                    {desc: "玩家爆伤总和提升2000000倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 2000000}},
                    {desc: "玩家生命加成总和提升15倍", type: "healthMultiplier", value: 15}
                ]
            },
            {
                requiredStage: 500,
                options: [
                    {desc: "玩家攻击加成总和提升20000000倍", type: "attackMultiplier", value: 20000000},
                    {desc: "玩家爆伤总和提升20000000倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 20000000}},
                    {desc: "玩家生命加成总和提升20倍", type: "healthMultiplier", value: 20}
               ]
            },
            {
                requiredStage: 600,
                options: [
                    {desc: "玩家攻击加成总和提升200000000倍", type: "attackMultiplier", value: 200000000},
                    {desc: "玩家爆伤总和提升200000000倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 200000000}},
                    {desc: "玩家生命加成总和提升25倍", type: "healthMultiplier", value: 25}
               ]
            },
            {
                requiredStage: 700,
                options: [
                    {desc: "玩家攻击加成总和提升2000000000倍", type: "attackMultiplier", value: 2000000000},
                    {desc: "玩家爆伤总和提升2000000000倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 2000000000}},
                    {desc: "玩家生命加成总和提升30倍", type: "healthMultiplier", value: 30}
             ]
            },
            {
                requiredStage: 800,
                options: [
                    {desc: "玩家攻击加成总和提升20000000000倍", type: "attackMultiplier", value: 20000000000},
                    {desc: "玩家爆伤总和提升20000000000倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 20000000000}},
                    {desc: "玩家生命加成总和提升35倍", type: "healthMultiplier", value: 35}
               ]
            },
            {
                requiredStage: 900,
                options: [
                    {desc: "玩家攻击加成总和提升200000000000倍", type: "attackMultiplier", value: 200000000000},
                    {desc: "玩家爆伤总和提升200000000000倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 200000000000}},
                    {desc: "玩家生命加成总和提升40倍", type: "healthMultiplier", value: 40}
                ]
            }
        ]
    },
    mage: {
        name: "法师",
        branches: [
            {
                requiredStage: 20,
                options: [
                    {desc: "玩家生命加成总和提升2倍", type: "healthMultiplier", value: 2},
                    {desc: "副本装备加成总和提升10倍", type: "dungeonEquipMultiplier", value: 10},
                    {desc: "魂环加成总和提升10倍", type: "soulRingMultiplier", value: 10}
                ]
            },
            {
                requiredStage: 50,
                options: [
                    {desc: "玩家生命加成总和提升5倍", type: "healthMultiplier", value: 5},
                    {desc: "副本装备加成总和提升100倍", type: "dungeonEquipMultiplier", value: 100},
                    {desc: "魂环加成总和提升100倍", type: "soulRingMultiplier", value: 100}
                ]
            },
            {
                requiredStage: 100,
                options: [
                    {desc: "玩家生命加成总和提升8倍", type: "healthMultiplier", value: 8},
                    {desc: "副本装备加成总和提升1000倍", type: "dungeonEquipMultiplier", value: 1000},
                    {desc: "魂环加成总和提升1000倍", type: "soulRingMultiplier", value: 1000}
                ]
            },
            {
                requiredStage: 200,
                options: [
                    {desc: "玩家生命加成总和提升12倍", type: "healthMultiplier", value: 12},
                    {desc: "副本装备加成总和提升10000倍", type: "dungeonEquipMultiplier", value: 10000},
                    {desc: "魂环加成总和提升10000倍", type: "soulRingMultiplier", value: 10000}
                ]
            },
            {
                requiredStage: 300,
                options: [
                    {desc: "玩家生命加成总和提升15倍", type: "healthMultiplier", value: 15},
                    {desc: "副本装备加成总和提升100000倍", type: "dungeonEquipMultiplier", value: 100000},
                    {desc: "魂环加成总和提升100000倍", type: "soulRingMultiplier", value: 100000}
                ]
            },
            {
                requiredStage: 400,
                options: [
                    {desc: "玩家生命加成总和提升20倍", type: "healthMultiplier", value: 20},
                    {desc: "副本装备加成总和提升1000000倍", type: "dungeonEquipMultiplier", value: 1000000},
                    {desc: "魂环加成总和提升1000000倍", type: "soulRingMultiplier", value: 1000000}
                ]
            },
            {
                requiredStage: 500,
                options: [
                    {desc: "玩家生命加成总和提升25倍", type: "healthMultiplier", value: 25},
                    {desc: "副本装备加成总和提升10000000倍", type: "dungeonEquipMultiplier", value: 10000000},
                    {desc: "魂环加成总和提升10000000倍", type: "soulRingMultiplier", value: 10000000}
                
                ]
            },
            {
                requiredStage: 600,
                options: [
                    {desc: "玩家生命加成总和提升30倍", type: "healthMultiplier", value: 30},
                    {desc: "副本装备加成总和提升100000000倍", type: "dungeonEquipMultiplier", value: 100000000},
                    {desc: "魂环加成总和提升100000000倍", type: "soulRingMultiplier", value: 100000000}
                  
                ]
            },
            {
                requiredStage: 700,
                options: [
                    {desc: "玩家生命加成总和提升35倍", type: "healthMultiplier", value: 35},
                    {desc: "副本装备加成总和提升1000000000倍", type: "dungeonEquipMultiplier", value: 1000000000},
                    {desc: "魂环加成总和提升1000000000倍", type: "soulRingMultiplier", value: 1000000000}
                
                ]
            },
            {
                requiredStage: 800,
                options: [
                    {desc: "玩家生命加成总和提升40倍", type: "healthMultiplier", value: 40},
                    {desc: "副本装备加成总和提升10000000000倍", type: "dungeonEquipMultiplier", value: 10000000000},
                    {desc: "魂环加成总和提升10000000000倍", type: "soulRingMultiplier", value: 10000000000}
                   
                ]
            },
            {
                requiredStage: 900,
                options: [
                    {desc: "玩家生命加成总和提升45倍", type: "healthMultiplier", value: 45},
                    {desc: "副本装备加成总和提升100000000000倍", type: "dungeonEquipMultiplier", value: 100000000000},
                    {desc: "魂环加成总和提升100000000000倍", type: "soulRingMultiplier", value: 100000000000}
                ]
            }
        ]
    }
};

// 切换职业系统界面显示
function toggleClassSystem() {
 if (player.reincarnationCount < 20) {
        alert("需要达到20转才能开启职业系统！");
        return;
    }
    const ui = document.getElementById('classSystemUI');
    const overlay = document.getElementById('classSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateClassSystemDisplay();
    }
}

// 选择职业
function selectClass(classType) {
    // 检查是否需要消耗转生币更换职业
    if (player.class && player.class !== classType) {
        if (player.reincarnationCoin < 1000) {
            alert("转生币不足，更换职业需要1000转生币！");
            return;
        }
        // 消耗转生币
        player.reincarnationCoin -= 1000;
        logAction(`消耗1000转生币，更换职业为${classConfig[classType].name}`, 'success');
    }
    
    // 设置职业并重置分支
    player.class = classType;
    player.classBranches = [];
    
    // 更新显示
    updateClassSystemDisplay();
    updatePlayerClassNameDisplay();
    updateDisplay(); // 更新整体显示
}

// 更新职业系统界面显示
function updateClassSystemDisplay() {
    // 更新当前职业显示
    const className = player.class ? classConfig[player.class].name : "无";
    document.getElementById('currentClassName').textContent = className;
    
    // 显示或隐藏分支加点
    const branchesContainer = document.getElementById('classBranches');
    const branchPointsContainer = document.getElementById('branchPointsContainer');
    
    if (player.class) {
        branchesContainer.style.display = 'block';
        branchPointsContainer.innerHTML = '';
        
        // 获取当前职业的分支配置
        const branches = classConfig[player.class].branches;
        
        // 生成分支加点HTML
        branches.forEach((branch, index) => {
            const isUnlocked = player.battle.maxStage >= branch.requiredStage;
            const selectedOption = player.classBranches[index] !== undefined ? player.classBranches[index] : -1;
            
            let branchHtml = `<div style="margin: 15px 0; padding: 10px; border: 1px solid #ccc;">`;
            branchHtml += `<div>第${index + 1}排 (需要最高层: ${branch.requiredStage})</div>`;
            
            if (!isUnlocked) {
                branchHtml += `<div style="color: #999;">未解锁，需要达到${branch.requiredStage}层</div>`;
            } else {
                branch.options.forEach((option, optIndex) => {
                    const isSelected = selectedOption === optIndex;
                    branchHtml += `
                        <div style="margin: 5px 0; padding: 5px; ${isSelected ? 'background: #ccf;' : ''}">
                            <button onclick="selectBranch(${index}, ${optIndex})" 
                                style="${isSelected ? 'background: #00f; color: white;' : ''}">
                                ${isSelected ? '✓ ' : ''}选择
                            </button>
                            ${option.desc}
                        </div>
                    `;
                });
            }
            
            branchHtml += `</div>`;
            branchPointsContainer.innerHTML += branchHtml;
        });
    } else {
        branchesContainer.style.display = 'none';
    }
}

// 选择分支选项
function selectBranch(branchIndex, optionIndex) {
    // 检查是否解锁
    const branch = classConfig[player.class].branches[branchIndex];
    if (player.battle.maxStage < branch.requiredStage) {
        alert(`需要达到${branch.requiredStage}层才能解锁此分支！`);
        return;
    }
    
    // 保存选择
    player.classBranches[branchIndex] = optionIndex;
    logAction(`选择了${classConfig[player.class].name}第${branchIndex + 1}排第${optionIndex + 1}个分支`, 'success');
    
    // 更新显示
    updateClassSystemDisplay();
    updatePlayerBattleStats(); // 更新战斗属性
}

 
// 更新玩家名字旁的职业显示
function updatePlayerClassNameDisplay() {
    const classNameElement = document.getElementById('playerClassName');
    if (player.class) {
        classNameElement.textContent = `[${classConfig[player.class].name}]`;
    } else {
        classNameElement.textContent = '';
    }
}
// 新增：计算魂环总加成（含职业分支乘数）
function getTotalSoulRingBonus() {
  let total = 0;
  player.soulRings.forEach(ring => {
    // 基础加成：等级 × 单级倍率
    total += ring.level * ring.multiplier;
  });
  // 应用职业分支的魂环加成乘数
  return total * player.classBonuses.soulRingMultiplier;
}
// 新增：计算副本装备总加成（含职业分支乘数）
function getTotalDungeonEquipBonus() {
  let total = 0;
  player.dungeonEquipment.forEach(eq => {
    // 基础加成：等级 × 成长率（示例，需结合实际装备效果逻辑）
    total += eq.level * eq.growthRate;
  });
  // 应用职业分支的副本装备加成乘数
  return total * player.classBonuses.dungeonEquipMultiplier;
}
// 计算职业加成 (需要在战斗计算相关函数中调用)
function calculateClassBonuses() {
    const bonuses = {
        attackMultiplier: 1,
        healthMultiplier: 1,
        critChance: 0,
        critMultiplier: 1,
        collectionMultiplier: 1,
        dungeonEquipMultiplier: 1,
        soulRingMultiplier: 1
    };
    
    if (!player.class) return bonuses;
    
    const classData = classConfig[player.class];
    
    // 累加所有已选择分支的加成
    player.classBranches.forEach((optionIndex, branchIndex) => {
        if (optionIndex === undefined) return;
        
        const branch = classData.branches[branchIndex];
        const option = branch.options[optionIndex];
        
        switch (option.type) {
            case 'attackMultiplier':
                bonuses.attackMultiplier *= (1 + option.value);
                break;
            case 'healthMultiplier':
                bonuses.healthMultiplier *= (1 + option.value);
                break;
            case 'critMultiplier':
                // 处理暴击倍率加成（如果有特殊结构需要单独处理）
                if (option.value.multiplier) {
                    bonuses.critMultiplier *= (1 + option.value.multiplier);
                } else {
                    bonuses.critMultiplier *= (1 + option.value);
                }
                break;
            // 新增：处理副本装备加成乘数
            case 'dungeonEquipMultiplier':
                bonuses.dungeonEquipMultiplier *= (1 + option.value);
                break;
            // 新增：处理魂环加成乘数
            case 'soulRingMultiplier':
                bonuses.soulRingMultiplier *= (1 + option.value);
                break;
        }
    });
    
    return bonuses;
}

 // 世界BOSS系统数据
        const worldBossData = {
            summonCount: 1,
            lastSummonTime: Date.now(),
            isBossActive: false,
            bossEndTime: 0,
            bossHealth: 0,
            bossMaxHealth: 0,
            bossName: "",
            bossWorld: "",
            bossStars: 0,
            playerDamage: 0,
            isAutoAttacking: false,
            attackInterval: null,
            virtualPlayers: [],
            rankings: [],
            battleLog: [],
            lastSummonTime: Date.now(),
    nextRecoveryTime: 0, // 新增：下次恢复时间
        };

        // BOSS名字池
        const bossNames = [
            "灭世魔尊·阎罗",
            "永恒天帝·太初",
            "混沌主宰·虚无",
            "九幽冥王·黄泉",
            "万界神皇·凌霄",
            "太古龙帝·烛阴",
            "星空吞噬者·饕餮",
            "时间掌控者·岁月",
            "命运编织者·天机",
            "元素始祖·创世"
        ];

        // 世界名字池
        const worldNames = [
            "玄天大陆",
            "九幽冥界",
            "太虚神境",
            "洪荒古界",
            "星辰海域",
            "万界战场",
            "永恒神域",
            "混沌虚空",
            "天元世界",
            "轮回之境"
        ];

        // 虚拟玩家名字池
        const virtualPlayerNames = [
            "萧炎", "林动", "牧尘", "叶凡", "石昊",
            "楚风", "秦羽", "方源", "韩立", "孟浩",
            "苏铭", "王林", "白小纯", "李七夜", "陈平安",
            "宁缺", "许七安", "陆鸣", "周元", "江离",
            "罗峰", "洪易", "纪宁", "滕青山", "唐三",
            "霍雨浩", "唐舞麟", "蓝轩宇", "古月娜", "唐昊", "茶茶", "闫闫", "萧云凡", "叶玄霄", "林昊辰", "楚星河", "秦无痕", "苏九夜", "陆天行", "沈青岚", "顾长歌", "洛千尘", "云清瑶", "柳如烟", "白芷晴", "慕雨柔", "苏灵儿", "凌寒霜", "楚月璃", "花未央", "冷轻衣", "夜琉璃", "夏知微", "苏晚晴", "林浅夏", "乔曦", "李二狗", "张全蛋", "赵日天", "王富贵"
        ];

        // 初始化世界BOSS系统
            function initWorldBossSystem() {
    // 计算离线时间增加的召唤次数
    const currentTime = Date.now();
    const timePassed = currentTime - (worldBossData.lastSummonTime || currentTime);
    const hoursPassed = Math.floor(timePassed / (60 * 60 * 1000));
    
    if (hoursPassed > 0) {
        worldBossData.summonCount = Math.min(worldBossData.summonCount + hoursPassed, 10);
        worldBossData.lastSummonTime = currentTime;
        saveWorldBossData();
    }
    
    // 计算下次恢复时间
    calculateNextRecoveryTime();
    
    // 启动倒计时更新
    updateSummonCountdown();
    
    updateBossUI();
}

// 计算下次恢复时间
function calculateNextRecoveryTime() {
    if (worldBossData.summonCount >= 10) {
        worldBossData.nextRecoveryTime = 0;
        return;
    }
    
    // 距离下次恢复的时间 = 1小时 - (当前时间与上次恢复的时间差 % 1小时)
    const oneHour = 60 * 60 * 1000;
    const timeSinceLastRecovery = Date.now() - worldBossData.lastSummonTime;
    const timeToNextRecovery = oneHour - (timeSinceLastRecovery % oneHour);
    
    worldBossData.nextRecoveryTime = Date.now() + timeToNextRecovery;
}

// 更新召唤次数倒计时显示
function updateSummonCountdown() {
    const countdownElement = document.getElementById('summonCountdown');
    if (!countdownElement) return;
    
    if (worldBossData.summonCount >= 10) {
        countdownElement.textContent = "已达上限";
        setTimeout(updateSummonCountdown, 1000);
        return;
    }
    
    const now = Date.now();
    const timeLeft = Math.max(0, worldBossData.nextRecoveryTime - now);
    
    if (timeLeft === 0 && worldBossData.summonCount < 10) {
        // 强制更新上次召唤时间为当前时间
        worldBossData.lastSummonTime = now;
        worldBossData.summonCount++;
        calculateNextRecoveryTime(); // 重新计算下次恢复时间（1小时后）
        saveWorldBossData();
        document.getElementById('bossSummonCount').textContent = worldBossData.summonCount;
        console.log("恢复次数+1，下次恢复时间：", new Date(worldBossData.nextRecoveryTime).toLocaleTimeString());
    }
    
    // 格式化时间显示
    const hours = Math.floor(timeLeft / (60 * 60 * 1000));
    const minutes = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
    const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);
    countdownElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    setTimeout(updateSummonCountdown, 1000);
}


        // 保存世界BOSS数据
        function saveWorldBossData() {
    worldBossData.lastUpdate = Date.now();
    localStorage.setItem('worldBossSave', JSON.stringify(worldBossData));
}

        // 加载世界BOSS数据
        // 加载世界BOSS数据
function loadWorldBossData() {
    const save = JSON.parse(localStorage.getItem('worldBossSave'));
    if (save) {
        Object.assign(worldBossData, save);
        
        // 如果BOSS活动正在进行中，计算离线期间的伤害
        if (worldBossData.isBossActive) {
            const currentTime = Date.now();
            
            // 检查BOSS是否已超时
            if (currentTime > worldBossData.bossEndTime) {
                endBossFight(false);
            } else {
                // 计算离线时间（秒）
                const offlineSeconds = Math.floor((currentTime - worldBossData.lastUpdate) / 1000);
                
                if (offlineSeconds > 0) {
                    // 1. 计算虚拟玩家在离线期间造成的总伤害（已有逻辑）
                    const virtualDamagePerSecond = worldBossData.virtualPlayers.reduce((sum, player) => {
                        const avgDamage = player.attack * player.multiAttack * 
                                        (1 + (player.critRate * (player.critDamage - 1)));
                        return sum + avgDamage;
                    }, 0);
                    const totalVirtualDamage = Math.floor(virtualDamagePerSecond * offlineSeconds);
                    worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - totalVirtualDamage);
                    const damagePerPlayer = Math.floor(totalVirtualDamage / worldBossData.virtualPlayers.length);
                    worldBossData.virtualPlayers.forEach(player => {
                        player.damage += damagePerPlayer;
                    });
                    addBossBattleLog(`离线期间虚拟玩家共造成 ${formatNumber(totalVirtualDamage)} 点伤害`);
                    
                    // 2. 新增：计算真实玩家的离线自动攻击伤害
                    if (worldBossData.isAutoAttacking) { // 仅当开启自动攻击时计算
                        // 玩家每秒攻击11次（与startAutoAttack一致）
                        const attacksPerSecond = 11;
                        const totalAttacks = offlineSeconds * attacksPerSecond;
                        
                        // 计算单次攻击的平均伤害（参考calculatePlayerDamage逻辑）
                        const playerData = {
                            attack: player.bossBattleSnapshot?.playerAttack || player.battle.playerAttack,
    multiAttack: player.bossBattleSnapshot?.playerMultiAttack || player.battle.playerMultiAttack,
    critRate: player.bossBattleSnapshot?.playerCritRate || player.battle.playerCritRate,
    critDamage: player.bossBattleSnapshot?.playerCritDamage || player.battle.playerCritDamage
                        };
                        // 计算单次攻击的平均伤害（避免循环计算totalAttacks次，优化性能）
                        const singleAttackAvgDamage = playerData.attack * playerData.multiAttack * 
                                                    (1 + (playerData.critRate * (playerData.critDamage - 1)));
                        const totalPlayerDamage = Math.floor(singleAttackAvgDamage * totalAttacks);
                        
                        // 应用玩家离线伤害
                        worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - totalPlayerDamage);
                        worldBossData.playerDamage += totalPlayerDamage;
                        addBossBattleLog(`离线期间你通过自动攻击造成 ${formatNumber(totalPlayerDamage)} 点伤害`);
                    }
                    
                    // 检查BOSS是否被击败
                    if (worldBossData.bossHealth <= 0) {
                        endBossFight(true);
                        return;
                    }
                }
            }
        }
    }
    
    // 重新开始虚拟玩家攻击
    startVirtualPlayerAttacks();
    
    // 更新最后更新时间
    worldBossData.lastUpdate = Date.now();
    initWorldBossSystem();
}

        // 切换世界BOSS界面
        function toggleWorldBossUI() {
           // 检查转生次数是否达到50次
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启世界BOSS系统！");
        return;
    }
            const ui = document.getElementById('worldBossUI');
            const overlay = document.getElementById('bossOverlay');
            
            if (ui.style.display === 'block') {
                ui.style.display = 'none';
                overlay.style.display = 'none';
                
               
            } else {
                ui.style.display = 'block';
                overlay.style.display = 'block';
                updateBossUI();
            }
        }

        // 更新BOSS界面
        function updateBossUI() {
            document.getElementById('bossSummonCount').textContent = worldBossData.summonCount;
    if (worldBossData.isBossActive && player.bossBattleSnapshot) {
        document.getElementById('playerBossAttack').textContent = formatNumber(player.bossBattleSnapshot.playerAttack);
        document.getElementById('playerBossMultiAttack').textContent = player.bossBattleSnapshot.playerMultiAttack;
        document.getElementById('playerBossCritRate').textContent = (player.bossBattleSnapshot.playerCritRate * 100).toFixed(1) + '%';
        document.getElementById('playerBossCritDamage').textContent = ((player.bossBattleSnapshot.playerCritDamage - 1) * 100).toFixed(1) + '%';
    } else {
        // 显示实时属性
        document.getElementById('playerBossAttack').textContent = formatNumber(player.battle.playerAttack);
        document.getElementById('playerBossMultiAttack').textContent = player.battle.playerMultiAttack;
        document.getElementById('playerBossCritRate').textContent = (player.battle.playerCritRate * 100).toFixed(1) + '%';
        document.getElementById('playerBossCritDamage').textContent = ((player.battle.playerCritDamage - 1) * 100).toFixed(1) + '%';
    }
            document.getElementById('playerBossDamage').textContent = formatNumber(worldBossData.playerDamage);
       if (!worldBossData.isBossActive) {
        document.getElementById('playerBossRank').textContent = "未开始";
    } else {
        // 触发一次排行更新
        updateRankings();
    }
            // 新增：检查BOSS是否超时（无论是否在战斗中，强制判断时间）
    if (worldBossData.isBossActive && Date.now() >= worldBossData.bossEndTime) {
        endBossFight(false); // 强制结束战斗
        return; // 结束后无需继续更新UI
    }
          if (!worldBossData.isBossActive) {
        document.getElementById('playerBossRank').textContent = "未开始";
    } else {
        // 触发一次排行更新
        updateRankings();
    }
            // 更新BOSS状态
            if (worldBossData.isBossActive) {
                document.getElementById('bossName').textContent = worldBossData.bossName;
                document.getElementById('bossWorld').textContent = worldBossData.bossWorld;
                document.getElementById('bossStars').textContent = '★'.repeat(worldBossData.bossStars);
                
                const healthPercent = (worldBossData.bossHealth / worldBossData.bossMaxHealth) * 100;
                document.getElementById('bossHealthFill').style.width = healthPercent + '%';
                document.getElementById('bossHealthText').textContent = 
                    formatNumber(worldBossData.bossHealth) + '/' + formatNumber(worldBossData.bossMaxHealth);
                
                const timeLeft = Math.max(0, Math.floor((worldBossData.bossEndTime - Date.now()) / 1000));
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                document.getElementById('bossTimeLeft').textContent = 
                    `剩余: ${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
                
                document.getElementById('bossSummonButton').disabled = true;
                document.getElementById('bossAttackButton').disabled = false;
                
                // 更新排行榜
                updateRankings();
            } else {
                document.getElementById('bossName').textContent = '未召唤BOSS';
                document.getElementById('bossWorld').textContent = '';
                document.getElementById('bossStars').textContent = '';
                document.getElementById('bossHealthFill').style.width = '0%';
                document.getElementById('bossHealthText').textContent = '0/0';
                document.getElementById('bossTimeLeft').textContent = '剩余: 未开始';
                
                document.getElementById('bossSummonButton').disabled = worldBossData.summonCount <= 0;
                document.getElementById('bossAttackButton').disabled = true;
                
                if (worldBossData.summonCount <= 0) {
                    document.getElementById('bossSummonButton').textContent = '无次数';
                } else {
                    document.getElementById('bossSummonButton').textContent = '召唤';
                }
            }
            
            // 更新自动攻击按钮
            document.getElementById('bossAutoAttackButton').textContent = 
                `自动: ${worldBossData.isAutoAttacking ? '开' : '关'}`;
        }

        // 召唤BOSS
        function summonBoss() {
           // 检查转生次数是否达到50次
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能召唤世界BOSS！");
        return;
    }
            if (worldBossData.summonCount <= 0) return;
            
            worldBossData.summonCount--;
            worldBossData.isBossActive = true;
            worldBossData.bossEndTime = Date.now() + 60 * 60 * 1000; // 60分钟
            worldBossData.playerDamage = 0;
            worldBossData.battleLog = [];
            
            // 随机生成BOSS属性
            worldBossData.bossName = bossNames[Math.floor(Math.random() * bossNames.length)];
            worldBossData.bossWorld = worldNames[Math.floor(Math.random() * worldNames.length)];
            worldBossData.bossStars = Math.floor(Math.random() * 30) + 1; // 1-30星
            
            // BOSS生命值为玩家攻击力的100000万-1000000万倍
            const healthMultiplier = 10000000000000000000 + Math.random() * 99000000000000000000000000;
            worldBossData.bossMaxHealth = Math.floor(player.battle.playerAttack * healthMultiplier * player.battle.playerCritDamage);
            worldBossData.bossHealth = worldBossData.bossMaxHealth;
           // 保存玩家属性快照
    player.bossBattleSnapshot = {
        playerAttack: player.battle.playerAttack,
        playerMultiAttack: player.battle.playerMultiAttack,
        playerCritRate: player.battle.playerCritRate,
        playerCritDamage: player.battle.playerCritDamage
    };                   
            // 生成虚拟玩家
            generateVirtualPlayers();
            
            // 开始虚拟玩家攻击
            startVirtualPlayerAttacks();
            
            // 更新UI
            updateBossUI();
            
            // 保存数据
            saveWorldBossData();
            
            // 添加战斗日志
            addBossBattleLog(`召唤了 ${worldBossData.bossName} [${worldBossData.bossWorld}] (${worldBossData.bossStars}★)`);
            
            // 设置BOSS结束检查
            setTimeout(checkBossEnd, 1000);
        }

        // 生成虚拟玩家
        function generateVirtualPlayers() {
            worldBossData.virtualPlayers = [];
            
            for (let i = 0; i < 60; i++) {
                const name = virtualPlayerNames[i] || `玩家${i+1}`;
                const attackMultiplier = 0.2 + Math.random() * 30; 
                const attack = Math.floor(player.battle.playerAttack * attackMultiplier);
                const multiAttack = Math.max(1, 
                    Math.floor(player.battle.playerMultiAttack * (0.3 + Math.random() * 1.5))); 
                const critRate = 0.5 + Math.random() * 1.9; 
                const critDamage = player.battle.playerCritDamage * (0.3 + Math.random() * 1.5);
                
                worldBossData.virtualPlayers.push({
                    name: name,
                    attack: attack,
                    multiAttack: multiAttack,
                    critRate: critRate,
                    critDamage: critDamage,
                    damage: 0
                });
            } 
      }
      // 修改离线虚拟玩家伤害计算逻辑（替换原有的平均分配部分）
function calculateOfflineVirtualDamage() {
    const now = Date.now();
    const timePassed = now - worldBossData.lastVirtualAttackTime;
    const secondsPassed = Math.floor(timePassed / 1000);
    if (secondsPassed <= 0) return;

    // 为每个虚拟玩家单独计算离线伤害（基于其自身属性）
    worldBossData.virtualPlayers.forEach(player => {
        // 计算该玩家的每秒平均伤害（考虑连击和爆伤）
        const avgDps = player.attack * player.multiAttack * 
                      (3 + (player.critRate * (player.critDamage - 1)));
        // 计算离线总伤害
        const playerDamage = Math.floor(avgDps * secondsPassed);
        // 应用伤害
        worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - playerDamage);
        player.damage += playerDamage;
    });

    // 更新最后攻击时间
    worldBossData.lastVirtualAttackTime = now;

    // 记录总离线伤害
    const totalDamage = worldBossData.virtualPlayers.reduce((sum, p) => sum + p.damageAdded, 0);
    addBossBattleLog(`离线期间虚拟玩家共造成 ${formatNumber(totalDamage)} 点伤害`);

    // 检查BOSS是否被击败
    if (worldBossData.bossHealth <= 0) {
        endBossFight(true);
    }
            
            // 更新排行榜
            updateRankings();
            
            // 保存数据
            saveWorldBossData();
        }
// 开始虚拟玩家攻击
        function startVirtualPlayerAttacks() {
            // 清除之前的攻击间隔
            if (worldBossData.virtualAttackInterval) {
                clearInterval(worldBossData.virtualAttackInterval);
            }
            
            // 设置新的攻击间隔 (每秒攻击一次)
            worldBossData.virtualAttackInterval = setInterval(() => {
                if (!worldBossData.isBossActive) {
                    clearInterval(worldBossData.virtualAttackInterval);
                    return;
                }
                
                // 所有虚拟玩家攻击
                worldBossData.virtualPlayers.forEach(player => {
                    const result = calculatePlayerDamage(player);
                    worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - result.total);
                    player.damage += result.total;
                    
                    // 每10次攻击记录一次（显示爆伤）
                    if (Math.random() < 0.1) {
                        let logMessage = `${player.name} 造成 ${formatNumber(result.total)} 伤害 - `;
                        logMessage += `普通: ${formatNumber(result.normalDamage)}, `;
                        logMessage += `暴击x${result.critCount}: ${formatNumber(result.critDamage)}`;
                        addBossBattleLog(logMessage);
                    }
                });
                
                // 更新UI
                updateRankings();
                updateBossUI();
                
                // 检查BOSS是否被击败
                if (worldBossData.bossHealth <= 0) {
                    endBossFight(true);
                }
            }, 1000);
        }

        // 计算玩家伤害
        function calculatePlayerDamage(playerData) {
            let totalDamage = 0;
            let critCount = 0;
            let critDamageTotal = 0;
            let normalDamageTotal = 0;
            
            for (let i = 0; i < playerData.multiAttack; i++) {
                const isCrit = Math.random() < playerData.critRate;
                let damage = playerData.attack;
                
                if (isCrit) {
                    damage *= playerData.critDamage;
                    critCount++;
                    critDamageTotal += damage;
                } else {
                    normalDamageTotal += damage;
                }
                
                totalDamage += damage;
            }
            
            return {
                total: Math.floor(totalDamage),
                critCount: critCount,
                critDamage: Math.floor(critDamageTotal),
                normalDamage: Math.floor(normalDamageTotal)
            };
        }

        // 攻击BOSS（修改为显示爆伤信息）
        function attackBoss() {
            if (!worldBossData.isBossActive) return;
            
    // 使用保存的属性快照而不是实时属性
    const result = calculatePlayerDamage({
        attack: player.bossBattleSnapshot.playerAttack,
        multiAttack: player.bossBattleSnapshot.playerMultiAttack,
        critRate: player.bossBattleSnapshot.playerCritRate,
        critDamage: player.bossBattleSnapshot.playerCritDamage
    });
    
            
            worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - result.total);
            worldBossData.playerDamage += result.total;
            
            // 添加战斗日志（显示爆伤详情）
            let logMessage = `你造成了 ${formatNumber(result.total)} 点伤害 (${player.battle.playerMultiAttack}连击) - `;
            logMessage += `普通伤害: ${formatNumber(result.normalDamage)}, `;
            logMessage += `暴击x${result.critCount}: ${formatNumber(result.critDamage)}`;
            
            addBossBattleLog(logMessage);
            
            // 更新UI
            updateRankings();
            updateBossUI();

           // 新增：保存攻击后的BOSS数据
    saveWorldBossData();
            
            // 检查BOSS是否被击败
            if (worldBossData.bossHealth <= 0) {
                endBossFight(true);
            }
        }

        // 切换自动攻击
        function toggleAutoAttackBoss() {
            worldBossData.isAutoAttacking = !worldBossData.isAutoAttacking;
            
            if (worldBossData.isAutoAttacking) {
                // 启动自动攻击（即使界面关闭也会继续）
                startAutoAttack();
            } else {
                stopAutoAttack();
            }
            
            updateBossUI();
        }

        // 新增专用函数处理自动攻击
function startAutoAttack() {
    // 先停止现有的自动攻击
    stopAutoAttack();
    
    // 每秒攻击20次
    worldBossData.attackInterval = setInterval(() => {
        if (worldBossData.isBossActive && worldBossData.isAutoAttacking) {
            for (let i = 0; i < 20; i++) {
                // 使用属性快照攻击
                const result = calculatePlayerDamage({
                    attack: player.bossBattleSnapshot.playerAttack,
                    multiAttack: player.bossBattleSnapshot.playerMultiAttack,
                    critRate: player.bossBattleSnapshot.playerCritRate,
                    critDamage: player.bossBattleSnapshot.playerCritDamage
                });
                
                worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - result.total);
                worldBossData.playerDamage += result.total;
                
                // 检查BOSS是否被击败
                if (worldBossData.bossHealth <= 0) {
                    endBossFight(true);
                    break;
                }
            }
        }
    }, 1000);
}

        function stopAutoAttack() {
            clearInterval(worldBossData.attackInterval);
        }

        // 更新排行榜
function updateRankings() {
    // 合并真实玩家和虚拟玩家
    const allPlayers = [
        {
            name: "你",
            damage: worldBossData.playerDamage
        },
        ...worldBossData.virtualPlayers.map(p => ({
            name: p.name,
            damage: p.damage
        }))
    ];
    
    // 按伤害排序
    allPlayers.sort((a, b) => b.damage - a.damage);
    worldBossData.rankings = allPlayers;
    
    // 更新玩家排名
    const playerRank = allPlayers.findIndex(p => p.name === "你") + 1;
    document.getElementById('playerBossRank').textContent = playerRank ? 
        `${playerRank} / ${allPlayers.length}` : "未排名";
    
    // 更新UI
    const rankingsContainer = document.getElementById('bossRankings');
    rankingsContainer.innerHTML = '';
    
    allPlayers.slice(0, 10).forEach((player, index) => {
        const div = document.createElement('div');
        div.className = 'boss-ranking-item';
        div.innerHTML = `
            <span>${index + 1}. ${player.name}</span>
            <span>${formatNumber(player.damage)}</span>
        `;
        rankingsContainer.appendChild(div);
    });
    
    if (allPlayers.length === 0) {
        rankingsContainer.innerHTML = '<div>尚未开始战斗</div>';
    }
}

        // 添加战斗日志
        function addBossBattleLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            worldBossData.battleLog.unshift(logEntry);
            if (worldBossData.battleLog.length > 15) { // 减少日志数量
                worldBossData.battleLog.pop();
            }
            
            // 更新UI
            const logContainer = document.getElementById('bossBattleLog');
            logContainer.innerHTML = worldBossData.battleLog.map(log => 
                `<div class="boss-battle-log-entry">${log}</div>`
            ).join('');
        }

        // 检查BOSS是否结束
        function checkBossEnd() {
            if (!worldBossData.isBossActive) return;
            
            if (Date.now() >= worldBossData.bossEndTime) {
                endBossFight(false);
            } else {
                setTimeout(checkBossEnd, 1000);
                updateBossUI();
            }
        }

        // 结束BOSS战斗
        function endBossFight(isDefeated) {
            worldBossData.isBossActive = false;
            clearInterval(worldBossData.virtualAttackInterval);
            
            // 停止自动攻击
            if (worldBossData.isAutoAttacking) {
                worldBossData.isAutoAttacking = false;
                stopAutoAttack();
            }
             player.bossBattleSnapshot = null;
            // 发放奖励
            distributeRewards();
            
            // 添加战斗日志
            if (isDefeated) {
                addBossBattleLog(`BOSS ${worldBossData.bossName} 已被击败！`);
            } else {
                addBossBattleLog(`BOSS ${worldBossData.bossName} 时间结束！`);
            }
            
            // 保存数据
            saveWorldBossData();
            
            // 更新UI
            updateBossUI();
            
            // 记录开奖结果
            recordBossResult();
        }

        // 分发奖励
        function distributeRewards() {
            const playerRank = worldBossData.rankings.findIndex(p => p.name === "你") + 1;
            
            if (playerRank === 1) {
        // 第一名
        player.items.divineGem += 5;
        player.reincarnationCoin += 30000;
        addBossBattleLog("你获得了第1名奖励: 5个神级宝石 + 30000转生币");
        
        // 解锁成就
        if (!player.achievements.world_boss_1st) {
            player.achievements.world_boss_1st = true;
            player.gpsMultiplier += achievementRewards.world_boss_1st.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_1st.description}，GPS奖励 +${achievementRewards.world_boss_1st.gpsMultiplier * 100}%`, 'success');
        }
    } else if (playerRank >= 2 && playerRank <= 10) {
        // 第2-10名
        player.items.superiorGem += 5;
        player.reincarnationCoin += 10000;
        addBossBattleLog(`你获得了第${playerRank}名奖励: 5个极品宝石 + 10000转生币`);
        
        // 解锁成就
        if (!player.achievements.world_boss_top5) {
            player.achievements.world_boss_top5 = true;
            player.gpsMultiplier += achievementRewards.world_boss_top5.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_top5.description}，GPS奖励 +${achievementRewards.world_boss_top5.gpsMultiplier * 100}%`, 'success');
        }
    } else if (playerRank >= 11 && playerRank <= 30) {
        // 第11-30名
        player.items.advancedGem += 3;
        player.reincarnationCoin += 5000;
        addBossBattleLog(`你获得了第${playerRank}名奖励: 3个高级宝石 + 5000转生币`);
        
        // 解锁成就
        if (!player.achievements.world_boss_top10) {
            player.achievements.world_boss_top10 = true;
            player.gpsMultiplier += achievementRewards.world_boss_top10.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_top10.description}，GPS奖励 +${achievementRewards.world_boss_top10.gpsMultiplier * 100}%`, 'success');
        }
    } else {
        // 参与奖
        player.items.primaryGem += 1;
        player.reincarnationCoin += 100;
        addBossBattleLog("你获得了参与奖: 1个初级宝石 + 100转生币");
        
        // 解锁成就
        if (!player.achievements.world_boss_participant) {
            player.achievements.world_boss_participant = true;
            player.gpsMultiplier += achievementRewards.world_boss_participant.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_participant.description}，GPS奖励 +${achievementRewards.world_boss_participant.gpsMultiplier * 100}%`, 'success');
        }
    }
    
    // 更新显示
    updateDisplay();
    updateAchievementsDisplay();
}

        // 记录开奖结果
        function recordBossResult() {
            const top3 = worldBossData.rankings.slice(0, 3).map(p => p.name).join(", ");
            const result = `世界BOSS ${worldBossData.bossName} 结束，前三名: ${top3}`;
            
            player.lotteryResults.unshift({
                time: new Date().toLocaleString(),
                result: result
            });
            
            if (player.lotteryResults.length > 5) {
                player.lotteryResults.pop();
            }
            
            // 更新彩票结果显示
            updateLotteryResultsDisplay();
        }

       // 格式化数字显示
        function formatNumber(value) {
            if (value >= 1e8) {
                return value.toExponential(3);
            } else {
                return value.toLocaleString();
            }
        }

        // 在游戏加载时初始化世界BOSS系统
        loadWorldBossData();
        updateOfficialSystemDisplay();
        updatePlayerClassNameDisplay();
     updateCompanionDisplay();
       updateItemDisplay();
 updateMysterySystemDisplay();
updateItemDisplay();
updateTraditionalLotteryDisplay();
updateTotalBonuses();
</script>
<!--客服 开始-->
<script src="//g8hh.github.io/static/js/jquery.min.js"></script>
<link rel="stylesheet" href="//g8hh.github.io/static/css/kf.css" type="text/css" media="screen" charset="utf-8">
<script src="//g8hh.github.io/static/js/kf.js"></script>
<!-- 客服 结束 -->
<!--站长统计-->
    <div style="display: none">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?828597e93cee632465679b7ef35edfd5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>    </div>
</body>
</html>