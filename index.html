<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta id="viewportMeta" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script>
        (function() {
            var w = window.screen.width;
            if (w <= 1024 && w > 0) {
                var meta = document.getElementById('viewportMeta');
                var scale = Math.max(0.3, Math.min(1, w / 1280));
                if (meta) meta.setAttribute('content', 'width=1280, initial-scale=' + scale + ', maximum-scale=2, user-scalable=yes');
            }
        })();
    </script>
    <script>
       
        (function() {
            try {
                var raw = localStorage.getItem('goldGameSave');
                if (raw) {
                    var save = JSON.parse(raw);
                    if (save && save.lastUpdate != null)
                        window.__goldGameSaveLastUpdate = save.lastUpdate;
                }
            } catch (e) {}
        })();
    </script>
    <title>金币冒险者 - 完整版</title>
    <style>
        
:root {
  --color-primary: #4A6CF7;
  --color-primary-light: #6B8AFF;
  --color-primary-dark: #3451D1;
  --color-primary-bg: rgba(74,108,247,0.08);
  --color-success: #10B981;
  --color-warning: #F59E0B;
  --color-danger: #EF4444;
  --color-info: #3B82F6;
  --color-gold: #D4AF37;
  --color-gold-light: #F1E5AC;
  --color-bg: #F0F2F5;
  --color-surface: #FFFFFF;
  --color-surface-hover: #F8FAFC;
  --color-border: #E2E8F0;
  --color-border-light: #F1F5F9;
  --color-text: #1E293B;
  --color-text-secondary: #64748B;
  --color-text-muted: #94A3B8;
  --color-text-inverse: #FFFFFF;
  --shadow-xs: 0 1px 2px rgba(0,0,0,0.04);
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06);
  --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.07);
  --shadow-xl: 0 20px 25px -5px rgba(0,0,0,0.1);
  --radius-sm: 6px;
  --radius-md: 10px;
  --radius-lg: 14px;
  --radius-full: 9999px;
  --space-xs: 4px;
  --space-sm: 8px;
  --space-md: 16px;
  --space-lg: 24px;
  --space-xl: 32px;
  --text-xs: 11px;
  --text-sm: 13px;
  --text-base: 15px;
  --text-xl: 20px;
  --transition-fast: 0.15s ease;
  --transition-normal: 0.25s ease;
  --z-sidebar: 250;
  --z-fixed: 300;
  --z-overlay: 400;
  --z-modal: 500;
  --sidebar-width: 220px;
  --topbar-height: 56px;
}
*, *::before, *::after { box-sizing: border-box; }
html { scroll-behavior: smooth; }
.card { background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-md); padding: var(--space-md); box-shadow: var(--shadow-xs); }
.card-header { padding-bottom: var(--space-sm); margin-bottom: var(--space-md); border-bottom: 1px solid var(--color-border-light); font-weight: 700; font-size: var(--text-base); color: var(--color-text); }
.currency-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: var(--space-sm); }
.currency-card { background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-sm); padding: var(--space-sm) var(--space-md); display: flex; flex-direction: column; font-size: var(--text-sm); }
.currency-card .currency-label { color: var(--color-text-muted); font-size: var(--text-xs); }
.currency-card .currency-value { color: var(--color-text); font-weight: 700; font-size: var(--text-base); }
.game-sidebar { position: fixed; left: 0; top: var(--topbar-height); width: var(--sidebar-width); height: calc(100vh - var(--topbar-height)); background: var(--color-surface); border-right: 1px solid var(--color-border); overflow-y: auto; z-index: var(--z-sidebar); padding: var(--space-sm) 0; transition: transform var(--transition-normal); }
.game-sidebar::-webkit-scrollbar { width: 4px; }
.sidebar-group { margin-bottom: var(--space-xs); }
.sidebar-group-title { padding: var(--space-sm) var(--space-md); font-size: var(--text-xs); font-weight: 700; color: var(--color-text-muted); text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; user-select: none; }
.sidebar-group-title:hover { color: var(--color-text-secondary); }
.sidebar-group-title .arrow { transition: transform var(--transition-fast); font-size: 10px; }
.sidebar-group.collapsed .arrow { transform: rotate(-90deg); }
.sidebar-group.collapsed .sidebar-group-items { display: none; }
.sidebar-item { display: flex; align-items: center; gap: var(--space-sm); padding: 7px var(--space-md) 7px var(--space-lg); font-size: var(--text-sm); color: var(--color-text-secondary); cursor: pointer; transition: all var(--transition-fast); border: none; background: none; width: 100%; text-align: left; }
.sidebar-item:hover { background: var(--color-primary-bg); color: var(--color-primary); }
.sidebar-item .sidebar-icon { width: 18px; text-align: center; font-size: 14px; }
.sidebar-item .sidebar-lock { margin-left: auto; font-size: var(--text-xs); color: var(--color-text-muted); background: var(--color-bg); padding: 1px 6px; border-radius: var(--radius-full); }
.game-topbar { position: fixed; top: 0; left: 0; right: 0; height: var(--topbar-height); background: var(--color-surface); border-bottom: 1px solid var(--color-border); box-shadow: var(--shadow-xs); z-index: var(--z-fixed); display: flex; align-items: center; padding: 0 var(--space-lg); gap: var(--space-lg); }
.topbar-brand { font-size: var(--text-xl); font-weight: 800; background: linear-gradient(135deg, var(--color-primary), #8B5CF6); -webkit-background-clip: text; background-clip: text; color: transparent; white-space: nowrap; }
.topbar-player { display: flex; align-items: center; gap: var(--space-sm); font-size: var(--text-sm); }
.player-avatar { width: 48px; height: 48px; object-fit: cover; border-radius: 50%; flex-shrink: 0; border: 2px solid var(--color-border); }
.topbar-player .player-class-display { color: var(--color-primary); font-size: var(--text-xs); background: var(--color-primary-bg); padding: 2px 8px; border-radius: var(--radius-full); }
.topbar-player .player-title-display { color: var(--color-gold); font-size: var(--text-xs); }
.topbar-vip { display: flex; align-items: center; gap: var(--space-sm); font-size: var(--text-xs); }
.topbar-vip .vip-badge { background: linear-gradient(135deg, #FFD700, #FFA500); color: #1a1a1a; padding: 2px 10px; border-radius: var(--radius-full); font-weight: 800; font-size: 11px; }
.topbar-vip .vip-bar-wrapper { width: 80px; height: 6px; background: var(--color-bg); border-radius: 3px; overflow: hidden; }
.topbar-vip .vip-bar-fill { height: 100%; border-radius: 3px; background: linear-gradient(90deg, #FFD700, #FFA500); transition: width var(--transition-normal); }
.topbar-actions { margin-left: auto; display: flex; gap: var(--space-sm); align-items: center; }
.topbar-actions .topbar-btn { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-surface); color: var(--color-text-secondary); cursor: pointer; font-size: 16px; transition: all var(--transition-fast); }
.topbar-actions .topbar-btn:hover { background: var(--color-primary-bg); color: var(--color-primary); border-color: var(--color-primary); }
.game-main { margin-left: var(--sidebar-width); margin-top: var(--topbar-height); padding: var(--space-lg); min-height: calc(100vh - var(--topbar-height)); background: var(--color-bg); }
.sidebar-toggle { display: none; width: 36px; height: 36px; border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-surface); color: var(--color-text-secondary); cursor: pointer; font-size: 18px; align-items: center; justify-content: center; }
.game-log-section .log-content { max-height: 200px; overflow-y: auto; font-size: var(--text-xs); line-height: 1.6; }
@media (max-width: 900px) { .game-sidebar { transform: translateX(-100%); } .game-sidebar.open { transform: translateX(0); box-shadow: var(--shadow-xl); } .game-main { margin-left: 0; } .sidebar-toggle { display: flex; } }
        /* 手机端：与电脑相同排版，固定宽度 + 字体略小（仅用设备宽度判断，不受 viewport 影响） */
        @media (max-device-width: 1024px) {
            :root {
                --text-xs: 12px;
                --text-sm: 13px;
                --text-base: 15px;
                --text-xl: 19px;
            }
            body { font-size: 15px !important; }
            /* 手机版页面长度缩短，主内容内部滚动，减少成就下方空白 */
            html, body { height: 100%; max-height: 78vh; overflow: hidden; position: fixed; left: 0; right: 0; top: 0; bottom: 0; }
            .game-main { min-height: 0; max-height: calc(78vh - var(--topbar-height)); height: calc(78vh - var(--topbar-height)); overflow-y: auto; -webkit-overflow-scrolling: touch; padding-bottom: var(--space-sm) !important; }
            .game-sidebar { max-height: calc(78vh - var(--topbar-height)); }
            .game-main .card:last-child { margin-bottom: 0 !important; }
            .game-main .game-log-section { margin-bottom: var(--space-sm) !important; }
            /* 手机版版本号随主内容滚动 */
            #footer { position: static !important; text-align: center; padding: var(--space-sm) 0; margin-top: var(--space-xs); }
        }
.tabs-new { display: flex; gap: 2px; border-bottom: 2px solid var(--color-border); overflow-x: auto; flex-shrink: 0; scrollbar-width: none; }
.tabs-new::-webkit-scrollbar { display: none; }
.tab-item-new { padding: 10px 18px; cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -2px; color: var(--color-text-secondary); font-size: var(--text-sm); font-weight: 500; white-space: nowrap; transition: all var(--transition-fast); background: none; border-top: none; border-left: none; border-right: none; }
.tab-item-new:hover { color: var(--color-primary); background: var(--color-primary-bg); }
.tab-item-new.active { color: var(--color-primary); border-bottom-color: var(--color-primary); font-weight: 700; }
body { margin: 0 !important; padding: 0 !important; background: var(--color-bg) !important; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif !important; color: var(--color-text); font-size: var(--text-base); line-height: 1.6; overflow-x: hidden; }
        /* 以下为原有样式 */
        button { padding: 10px; margin: 5px; cursor: pointer; }
        #equipmentList, #itemList, #collectionList, #reincarnationList, #petList, #stockList, #lotteryList, #bankList, #dungeonEquipmentList, #soulRingList { margin-top: 20px; max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; }
        .log { color: #666; font-size: 0.9em; }
        .common { color: #666; border-left: 4px solid #666; padding: 2px 5px; }
        .rare { color: blue; border-left: 4px solid blue; }
        .epic { color: purple; border-left: 4px solid purple; }
        .legendary { color: orange; border-left: 4px solid orange; }
        .ancient { color: brown; border-left: 4px solid brown; }
        .divine { color: gold; border-left: 4px solid gold; }
        .arcane { color: deepskyblue; border-left: 4px solid deepskyblue; }
        .celestial { color: lightblue; border-left: 4px solid lightblue; }
        .infernal { color: darkred; border-left: 4px solid darkred; }
        .astral { color: violet; border-left: 4px solid violet; }
        .primeval { color: darkgreen; border-left: 4px solid darkgreen; }
        .transcendental { color: fuchsia; border-left: 4px solid fuchsia; }
        .quantum { color: aqua; border-left: 4px solid aqua; }
        .ultimate { color: orange; border-left: 4px solid orange; }
        .chaos { color: #FF4500; border-left: 4px solid #FF4500; }
       .eternal { color: #00CED1; border-left: 4px solid #00CED1; }
         .void { color: #8A2BE2; border-left: 4px solid #8A2BE2; }
        .genesis { color: #FFD700; border-left: 4px solid #FFD700; }
         .divineRealm { color: #FF69B4; border-left: 4px solid #FF69B4; }
         .apocalypse { color: #000000; border-left: 4px solid #000000; }
       .yeyu1 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu2 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu3 { color: #FF4530; border-left: 4px solid #FF4530; }
        .yeyu4 { color: #4B0082; border-left: 4px solid #4B0082; }
         .yeyu5 { color: #FFD770; border-left: 4px solid #FFD770; }
         .yeyu6 { color: #8B0000; border-left: 4px solid #8B0000; }
       .yeyu7 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu8 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu9 { color: #FF4530; border-left: 4px solid #FF4530; }
        .yeyu10 { color: #4B0082; border-left: 4px solid #4B0082; }
         .yeyu11 { color: #FFD770; border-left: 4px solid #FFD770; }
         .yeyu12 { color: #8B0000; border-left: 4px solid #8B0000; }
       .yeyu13 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu14 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu15 { color: #FF4530; border-left: 4px solid #FF4530; }
      .yeyu16 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu17 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu18 { color: #FF4530; border-left: 4px solid #FF4530; }
        .yeyu19 { color: #4B0082; border-left: 4px solid #4B0082; }
         .yeyu20 { color: #FFD770; border-left: 4px solid #FFD770; }
         .yeyu21 { color: #8B0000; border-left: 4px solid #8B0000; }
       .yeyu22 { color: #C0C0C0; border-left: 4px solid #C0C0C0; }
       .yeyu23 { color: #8A2BE5; border-left: 4px solid #8A2BE5; }
         .yeyu24 { color: #FF4530; border-left: 4px solid #FF4530; }
   .ultimate2 { color: #00CED1; border-left: 4px solid #00CED1; }
.ultimate3 { color: #8A2BE2; border-left: 4px solid #8A2BE2; } 
.ultimate4 { color: #FFD700; border-left: 4px solid #FFD700; } 
.ultimate5 { color: #FF69B4; border-left: 4px solid #FF69B4; }
.ultimate6 { color: #000000; border-left: 4px solid #000000; }
.ultimate7 { color: #00FF00; border-left: 4px solid #00FF00; } 
.ultimate8 { color: #FF0000; border-left: 4px solid #FF0000; } 
.ultimate9 { color: #0000FF; border-left: 4px solid #0000FF; }
.ultimate10 { color: #800080; border-left: 4px solid #800080; } 
.ultimate11 { color: #FFA500; border-left: 4px solid #FFA500; } 
.ultimate12 { color: #008080; border-left: 4px solid #008080; } 
.ultimate13 { color: #4B0082; border-left: 4px solid #4B0082; } 
.ultimate14 { color: #FF6347; border-left: 4px solid #FF6347; } 
.ultimate15 { color: #7CFC00; border-left: 4px solid #7CFC00; } 
.ultimate16 { color: #DC143C; border-left: 4px solid #DC143C; } 
.ultimate17 { color: #00FFFF; border-left: 4px solid #00FFFF; } 
.ultimate18 { color: #FF00FF; border-left: 4px solid #FF00FF; } 
.ultimate19 { color: #FFFF00; border-left: 4px solid #FFFF00; }
.ultimate20 { color: #8B0000; border-left: 4px solid #8B0000; } 
.ultimate21 { color: #800000; border-left: 4px solid #800000; } 
.ultimate22 { color: #FFDAB9; border-left: 4px solid #FFDAB9; }
.ultimate23 { color: #000080; border-left: 4px solid #000080; } 
.ultimate24 { color: #FF1493; border-left: 4px solid #FF1493; } 
.ultimate25 { color: #00BFFF; border-left: 4px solid #00BFFF; }
.ultimate26 { color: #FF4500; border-left: 4px solid #FF4500; } 
.ultimate27 { color: #00CED1; border-left: 4px solid #00CED1; }
.ultimate28 { color: #8A2BE2; border-left: 4px solid #8A2BE2; } 
.ultimate29 { color: #FFD700; border-left: 4px solid #FFD700; }
.ultimate30 { color: #FF69B4; border-left: 4px solid #FF69B4; }
.ultimate31 { color: #000000; border-left: 4px solid #000000; }
.ultimate32 { color: #00FF00; border-left: 4px solid #00FF00; }
.ultimate33 { color: #FF0000; border-left: 4px solid #FF0000; } 
.ultimate34 { color: #0000FF; border-left: 4px solid #0000FF; } 
.ultimate35 { color: #800080; border-left: 4px solid #800080; } 
.ultimate36 { color: #FFA500; border-left: 4px solid #FFA500; } 
.ultimate37 { color: #008080; border-left: 4px solid #008080; }
.ultimate38 { color: #4B0082; border-left: 4px solid #4B0082; } 
.ultimate39 { color: #FF6347; border-left: 4px solid #FF6347; } 
.ultimate40 { color: #7CFC00; border-left: 4px solid #7CFC00; } 
.ultimate41 { color: #DC143C; border-left: 4px solid #DC143C; } 
.ultimate42 { color: #00FFFF; border-left: 4px solid #00FFFF; } 
.ultimate43 { color: #FF00FF; border-left: 4px solid #FF00FF; }
.ultimate44 { color: #FFFF00; border-left: 4px solid #FFFF00; }
.ultimate45 { color: #8B0000; border-left: 4px solid #8B0000; } 
.ultimate46 { color: #800000; border-left: 4px solid #800000; } 
.ultimate47 { color: #FFDAB9; border-left: 4px solid #FFDAB9; }
.ultimate48 { color: #000080; border-left: 4px solid #000080; }
.ultimate49 { color: #FF1493; border-left: 4px solid #FF1493; }
.ultimate50 { color: #00BFFF; border-left: 4px solid #00BFFF; }
          .equipment { position: relative; padding: 5px; margin: 3px 0; }
        .tooltip { 
            display: none;
            position: absolute;
            left: 65%;
            top: 0;
            background: white;
            border: 5px solid #ddd;
            padding: 5px;
            min-width: 200px;
            z-index: 0;
            transform: scale(0.5);
            margin-top: -90px;
        }
        .equipment:hover .tooltip { display: block; }
        @keyframes shake {
            -50%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .error { animation: shake 0.3s; color: red; }
        #actionLog {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }
        .offline-reward {
            color: #2ecc71;
            font-weight: bold;
            animation: fadeOut 1.5s ease-out 2s forwards;
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .success { color: #27ae60; }
        .info { color: #2980b9; }
        .auto-buy-container {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .auto-buy-btn { background-color: #e0e0e0; }
        .achievement { margin: 5px 0; padding: 5px; border: 1px solid #ddd; border-radius: 5px; }
        .achievement.unlocked { background-color: #e0f7fa; }
        .tab { cursor: pointer; padding: 10px; border: 1px solid #ccc; display: inline-block; margin-right: 5px; }
        .tab.active { background-color: #ccc; }

        /* 新增样式：装备品质面板缩小 200% */
        #equipmentList {
    transform: scale(1);
    transform-origin: top left;
    width: 100%;
    /* 新增以下样式 */
    max-height: 29.6vh; /* 限制最大高度为屏幕高度的20%，可根据需求调整 */
    overflow-y: auto; /* 允许垂直滚动 */
    -webkit-overflow-scrolling: touch; /* 启用移动端平滑滚动特性 */
    overscroll-behavior-y: contain; /* 阻止滚动到底部时的全局回弹 */
}

        /* 新增样式：游戏日志分页 */
        .log-tab { cursor: pointer; padding: 10px; border: 1px solid #ccc; display: inline-block; margin-right: 5px; }
        .log-tab.active { background-color: #ccc; }
        #gameLogPage1, #gameLogPage2, #gameLogPage3, #gameLogPage4 { display: none; }
        #gameLogPage1.active, #gameLogPage2.active, #gameLogPage3.active, #gameLogPage4.active { display: block; }

        /* 自定义对话框样式 */
        #customDialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            z-index: 1000;
            text-align: center;
        }
        #dialogOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        #dialogConfirm, #dialogCancel {
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
        }

        /* 新增股票样式 */
        #stocksContainer { margin-top: 20px; }
        .stock-item { 
            padding: 10px; 
            border: 1px solid #ddd; 
            margin: 5px 0; 
            cursor: pointer; 
        }
        .stock-item.selected { background-color: #e3f2fd; }
        .stock-control { margin-top: 20px; }
        .stock-control input { 
            padding: 5px;
            width: 120px;
            margin-right: 10px;
        }

        /* 新增彩票样式 */
        #lotteryResults, #traditionalLotteryNumbers {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }

        /* 新增银行系统样式 */
        #bankList {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }

        /* 新增打怪模式样式 */
        #monsterUI {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f9f9f9;
            border: 1px solid #ccc;
            padding: 10px;
            width: 300px;
            z-index: 1000;
        }
        #monsterUI h3 { margin-top: 0; }
        #monsterUI .monster-info { margin-bottom: 10px; }
        #monsterUI .player-info { margin-bottom: 10px; }
        #monsterUI .battle-log { max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; }

        /* 新增魂环样式 */
        #soulRingsContainer .equipment {
            padding: 8px;
            margin: 5px;
            border: 1px solid gold;
            border-radius: 4px;
        }
         /* 功法秘笈样式 */
.technique {
    padding: 10px;
    margin: 5px;
    border: 1px solid #8B4513; /* 棕色边框 */
    border-radius: 4px;
    background-color: #FFF8DC; /* 浅黄色背景 */
} 
#worldBossUI {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px; /* 从800px缩小到600px */
            max-width: 90%;
            max-height: 80vh; /* 限制最大高度 */
            background: #1a1a1a;
            border: 2px solid #d4af37;
            box-shadow: 0 0 15px #d4af37;
            padding: 15px; /* 减少内边距 */
            z-index: 1001;
            display: none;
            color: #fff;
            border-radius: 8px; /* 稍微减小圆角 */
            overflow-y: auto; /* 添加滚动条 */
        }
        
        #worldBossUI h3 {
            color: #d4af37;
            text-align: center;
            margin-top: 0;
            font-size: 20px; /* 减小字号 */
            text-shadow: 0 0 5px #d4af37;
            margin-bottom: 10px; /* 减小下边距 */
        }
        
        .boss-section {
            margin-bottom: 15px; /* 减小间距 */
            padding: 10px; /* 减小内边距 */
            background: #2a2a2a;
            border-radius: 6px;
            border: 1px solid #444;
        }
        
        .boss-section-title {
            color: #d4af37;
            font-weight: bold;
            margin-bottom: 8px; /* 减小下边距 */
            font-size: 16px; /* 减小字号 */
        }
        
        .boss-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px; /* 减小下边距 */
            font-size: 14px; /* 减小字号 */
        }
        
        .boss-name {
            font-size: 18px; /* 从22px减小 */
            color: #d4af37;
            text-align: center;
            margin: 8px 0; /* 减小边距 */
            text-shadow: 0 0 5px #d4af37;
        }
        
        .boss-world {
            font-size: 14px; /* 从16px减小 */
            color: #aaa;
            text-align: center;
            margin-bottom: 10px; /* 减小下边距 */
            font-style: italic;
        }
        
        .boss-stars {
            text-align: center;
            font-size: 16px; /* 从20px减小 */
            color: gold;
            margin-bottom: 10px; /* 减小下边距 */
        }
        
        .boss-health-bar {
            height: 20px; /* 从30px减小 */
            background: #333;
            border-radius: 10px;
            margin-bottom: 10px; /* 减小下边距 */
            overflow: hidden;
            position: relative;
        }
        
        .boss-health-fill {
            height: 100%;
            background: linear-gradient(to right, #d4af37, #f1e5ac);
            width: 100%;
            transition: width 0.3s;
        }
        
        .boss-health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            line-height: 20px; /* 与health-bar高度匹配 */
            color: #000;
            font-weight: bold;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-time-left {
            text-align: center;
            font-size: 14px; /* 从18px减小 */
            margin-bottom: 10px; /* 减小下边距 */
            color: #d4af37;
        }
        
        .boss-button {
            background: linear-gradient(to bottom, #d4af37, #a67c00);
            border: none;
            color: #000;
            padding: 6px 12px; /* 减小内边距 */
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin: 3px; /* 减小外边距 */
            transition: all 0.3s;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-button:hover {
            background: linear-gradient(to bottom, #f1e5ac, #d4af37);
            box-shadow: 0 0 8px #d4af37; /* 减小阴影 */
        }
        
        .boss-button:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }
        
        .boss-rankings {
            max-height: 120px; /* 从200px减小 */
            overflow-y: auto;
            border: 1px solid #444;
            padding: 6px; /* 减小内边距 */
            border-radius: 4px;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0; /* 减小内边距 */
            border-bottom: 1px solid #444;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-battle-log {
            max-height: 100px; /* 从150px减小 */
            overflow-y: auto;
            border: 1px solid #444;
            padding: 6px; /* 减小内边距 */
            border-radius: 4px;
            font-size: 11px; /* 减小字号 */
        }
        
        .boss-battle-log-entry {
            margin-bottom: 3px; /* 减小下边距 */
            padding-bottom: 3px; /* 减小内边距 */
            border-bottom: 1px dotted #444;
        }
        
        .boss-rewards {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        
        .boss-reward-tier {
            background: #333;
            padding: 6px; /* 减小内边距 */
            border-radius: 4px;
            margin: 3px; /* 减小外边距 */
            text-align: center;
            width: 45%; /* 调整宽度使两列显示 */
            min-width: 120px;
            font-size: 12px; /* 减小字号 */
        }
        
        .boss-reward-tier h4 {
            color: #d4af37;
            margin-top: 0;
            font-size: 13px; /* 减小字号 */
        }
        
        .boss-close-button {
            position: absolute;
            top: 5px; /* 减小位置 */
            right: 5px;
            background: none;
            border: none;
            color: #d4af37;
            font-size: 16px; /* 从20px减小 */
            cursor: pointer;
            padding: 2px;
        }
        
        .boss-summon-count {
            position: absolute;
            top: 5px; /* 减小位置 */
            left: 5px;
            color: #d4af37;
            font-weight: bold;
            font-size: 12px; /* 减小字号 */
        }
  .player-name {
  margin: 10px 0;
  padding: 8px 15px;
  font-size: 18px;
  font-weight: bold;
  position: relative;
  display: inline-block;
  background: linear-gradient(90deg, #fff, #f8f9fa, #fff);
  background-size: 200% 100%;
  border-radius: 6px;
  overflow: hidden;
}

.player-name::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    rgba(52, 152, 219, 0) 0%,
    rgba(52, 152, 219, 0.1) 50%,
    rgba(52, 152, 219, 0) 100%);
  animation: shine 3s infinite;
}

#playerName {
  background: linear-gradient(90deg, #3498db, #9b59b6, #e74c3c);
  background-size: 200% 200%;
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  animation: gradientShift 5s ease infinite;
  padding: 0 5px;
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@keyframes shine {
  100% { left: 100%; }
}

.player-name:hover #playerName {
  animation: gradientShift 2s ease infinite, bounce 0.5s ease;
}

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
}

.titleBranch {
    margin: 20px 0;
    padding: 10px;
    border: 1px solid #ddd;
}

.titleRow {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
}

.titleItem {
    padding: 8px 12px;
    background: #f0f0f0;
    border-radius: 4px;
    cursor: pointer;
    width: calc(20% - 10px); /* 每排5个 */
    text-align: center;
    box-sizing: border-box;
}

.titleItem.unlocked {
    background: #4CAF50;
    color: white;
}

.titleItem.selected {
    border: 2px solid #ffd700;
    font-weight: bold;
}
/* 通天塔界面缩小样式 */
#towerUI {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 500px; /* 缩小宽度 */
    max-width: 90%; /* 响应式最大宽度 */
    max-height: 70vh; /* 限制最大高度为屏幕的70% */
    background: #f9f9f9;
    border: 1px solid #ccc;
    padding: 15px; /* 减少内边距 */
    z-index: 1001;
    display: none; /* 默认隐藏 */
    overflow-y: auto; /* 内容过多时显示滚动条 */
    border-radius: 6px;
}

#towerUI h3 {
    font-size: 18px; /* 缩小标题字体 */
    margin: 10px 0;
    text-align: center;
}

#towerUI .floor-info {
    font-size: 14px; /* 缩小信息字体 */
    margin: 8px 0;
    padding: 8px;
    background: #f0f0f0;
    border-radius: 4px;
}

#towerUI button {
    padding: 6px 12px; /* 缩小按钮 */
    font-size: 12px;
    margin: 4px;
}

#towerUI .tower-log {
    max-height: 150px; /* 缩小日志区域 */
    overflow-y: auto;
    font-size: 12px;
    padding: 8px;
    margin-top: 10px;
    border: 1px solid #ddd;
}
#customDialog {
    z-index: 2000 !important; /* 确保高于其他元素 */
}

#dialogOverlay {
    z-index: 1999 !important;
}
.farm-field:hover {
    background-color: #3a3a3a !important;
    transition: background-color 0.3s;
}

.seed-item:hover {
    background-color: #3a3a3a !important;
    border-color: #4CAF50 !important;
    transition: all 0.3s;
}



button:hover {
    background: #666;
}
/* 星域探索系统样式 */
#explorationSystemUI {
    font-family: 'Arial', sans-serif;
}

.attribute-card {
    background: #2a2a4a;
    border-radius: 8px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.3s;
}

.attribute-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(74, 134, 232, 0.3);
}

.attribute-icon {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    margin-bottom: 10px;
}

.attribute-info {
    text-align: center;
    margin-bottom: 10px;
}

.upgrade-btn {
    background: linear-gradient(to bottom, #4a86e8, #1c5bb8);
    color: white;
    border: none;
    padding: 5px 15px;
    border-radius: 15px;
    cursor: pointer;
    width: 100%;
    transition: all 0.3s;
}

.upgrade-btn:hover {
    background: linear-gradient(to bottom, #5a96f8, #2c6bc8);
    transform: scale(1.05);
}

.mission-card {
    background: #2a2a4a;
    border-radius: 8px;
    padding: 15px;
    transition: all 0.3s;
}

.mission-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(74, 134, 232, 0.3);
}

.mission-card[data-difficulty="easy"] {
    border-left: 4px solid #00cc66;
}

.mission-card[data-difficulty="medium"] {
    border-left: 4px solid #4a86e8;
}

.mission-card[data-difficulty="hard"] {
    border-left: 4px solid #ff9900;
}

.mission-card[data-difficulty="extreme"] {
    border-left: 4px solid #ff3333;
}

.mission-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.difficulty-tag {
    background: #4a86e8;
    color: white;
    padding: 3px 10px;
    border-radius: 15px;
    font-size: 12px;
}

.mission-info {
    margin-bottom: 15px;
    font-size: 14px;
}

.start-mission-btn {
    background: linear-gradient(to bottom, #4a86e8, #1c5bb8);
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 5px;
    cursor: pointer;
    width: 100%;
    transition: all 0.3s;
}

.start-mission-btn:hover {
    background: linear-gradient(to bottom, #5a96f8, #2c6bc8);
    transform: scale(1.05);
}

.resource-card {
    background: #2a2a4a;
    border-radius: 8px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.3s;
}

.resource-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 15px rgba(74, 134, 232, 0.3);
}

.resource-icon {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    margin-bottom: 10px;
}

.resource-info {
    text-align: center;
}

.log-entry {
    padding: 8px;
    margin-bottom: 5px;
    background: #2a2a4a;
    border-radius: 5px;
    font-size: 14px;
}

.log-entry:nth-child(odd) {
    background: #33335a;
}
.upgrade-btn:disabled {
    background: #666 !important;
    cursor: not-allowed;
    opacity: 0.7;
}
 .exchange-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
    }
    
    .exchange-info {
        flex: 1;
    }
    
    .exchange-controls {
        display: flex;
        gap: 10px;
    }
 .gem-shop-item {
        background: #2a2a2a;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
    }
    
    .gem-icon {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        font-weight: bold;
        margin: 0 auto 10px;
    }
    
    .gem-icon.red { background: linear-gradient(to bottom, #ff4d4d, #cc0000); }
    .gem-icon.blue { background: linear-gradient(to bottom, #4da6ff, #0066cc); }
    .gem-icon.black { background: linear-gradient(to bottom, #666666, #000000); }
    .gem-icon.green { background: linear-gradient(to bottom, #66ff66, #00cc00); }
    .gem-icon.pink { background: linear-gradient(to bottom, #ff66cc, #cc0099); }
    .gem-icon.yellow { background: linear-gradient(to bottom, #ffff66, #cccc00); }
    
    .gem-item {
        background: #2a2a2a;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        position: relative;
    }
    
    .gem-level {
        position: absolute;
        top: 5px;
        right: 5px;
        background: #d4af37;
        color: black;
        border-radius: 50%;
        width: 25px;
        height: 25px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
    }
.progress-bar {
    width: 100%;
    height: 20px;
    background-color: #333;
    border-radius: 10px;
    overflow: hidden;
    margin-top: 5px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(to right, #9C27B0, #E91E63);
    border-radius: 10px;
    transition: width 0.5s ease;
}

.tablink.active {
    background: #9C27B0 !important;
    font-weight: bold;
}
/* 添加弹幕动画效果 */
@keyframes danmakuMove {
    from {
        transform: translateX(100%);
    }
    to {
        transform: translateX(-100%);
    }
}

.danmaku {
    animation: danmakuMove linear forwards;
   pointer-events: none;
}
/* 添加一些动画效果 */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

#giftBoxBtn {
    animation: pulse 2s infinite;
    transition: all 0.3s;
}

#giftBoxBtn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(255, 94, 98, 0.5);
}

#boxInner {
    cursor: pointer;
    transition: transform 1s;
}

#giftBoxModal div {
    color: #ffffff;
}
 
    .exchange-btn {
        background: linear-gradient(to bottom, #4CAF50, #2E7D32);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
    }
    
    .exchange-btn:hover {
        background: linear-gradient(to bottom, #66BB6A, #388E3C);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .exchange-btn:active {
        transform: translateY(0);
    }
    
    .exchange-item {
        transition: all 0.3s;
    }
    
    .exchange-item:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    .gem-icon {
        box-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
    }
.artifact-tab {
    cursor: pointer;
    padding: 8px 15px;
    background: #333;
    border: 1px solid #d4af37;
    border-radius: 5px;
    color: #d4af37;
    font-weight: bold;
}

.artifact-tab.active {
    background: #d4af37;
    color: black;
}

.set-group {
    margin-bottom: 15px;
    border: 1px solid #444;
    border-radius: 5px;
    overflow: hidden;
}

.set-header {
    background: linear-gradient(to right, #2c2c2c, #1a1a1a);
    padding: 12px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #444;
}

.set-header:hover {
    background: linear-gradient(to right, #3c3c3c, #2a2a2a);
}

.set-name {
    font-weight: bold;
    color: #d4af37;
    font-size: 1.1em;
}

.set-count {
    background: #d4af37;
    color: black;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 0.9em;
}

.set-content {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    padding: 10px;
    background: #222;
}

.set-collapsed .set-content {
    display: none;
}

.folder-arrow {
    transition: transform 0.3s;
}

.set-collapsed .folder-arrow {
    transform: rotate(-90deg);
}
    .lottery-countdown {
            font-size: 14px;
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0;
            padding: 5px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
.dimension-selector {
            margin: 15px 0;
            padding: 10px;
            background: #2c3e50;
            border-radius: 8px;
            color: white;
        }
        .dimension-btn {
            padding: 8px 15px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #34495e;
            color: #ecf0f1;
            transition: all 0.3s;
        }
        .dimension-btn.active {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }
        .dimension-btn:hover:not(.active) {
            background: #4a6572;
        }
        .dimension-info {
            margin-top: 10px;
            font-size: 14px;
            line-height: 1.5;
        }
   /* 新增页脚样式 */
        #footer {
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: #666;
            font-size: 14px;
            z-index: 1000;
            pointer-events: none; /* 防止干扰交互 */
        }
  .currency:has(span:empty) {
    display: none;
}
.tab-container {
    display: flex;
    margin-bottom: 15px;
    border-bottom: 2px solid #444;
}

.tab-btn {
    background: #333;
    color: white;
    border: none;
    padding: 10px 20px;
    cursor: pointer;
    margin-right: 5px;
    border-radius: 5px 5px 0 0;
}

.tab-btn.active {
    background: #FFD700;
    color: black;
    font-weight: bold;
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.good-item, .inventory-item {
    transition: all 0.3s ease;
    border-radius: 3px;
}

.good-item:hover, .inventory-item:hover {
    background-color: #2a2a2a;
    transform: translateY(-1px);
}
.inventory-item {
    border-left: 3px solid transparent;
}

.inventory-item:hover {
    border-left-color: #FFD700;
}

.profit-positive {
    color: #4CAF50;
    font-weight: bold;
}

.profit-negative {
    color: #f44336;
    font-weight: bold;
}

.profit-neutral {
    color: #FFC107;
}

.price-trend-up {
    color: #4CAF50;
    animation: pulseGreen 2s infinite;
}

.price-trend-down {
    color: #f44336;
    animation: pulseRed 2s infinite;
}

@keyframes pulseGreen {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

@keyframes pulseRed {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.region {
    background: #2a2a2a;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 10px;
}

.city {
    padding: 5px;
    margin: 3px 0;
    background: #333;
    border-radius: 3px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.city:hover {
    background: #444;
}


button:hover:not(:disabled) {
    background: #45a049;
}

button:disabled {
    background: #666;
    cursor: not-allowed;
}

#tradingSystemUI {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    border: 2px solid #FFD700;
}

#tradingSystemUI h2, #tradingSystemUI h3, #tradingSystemUI h4 {
    color: #FFD700;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}
#inventorySummaryModal table th {
    background: #333;
    position: sticky;
    top: 0;
}

#inventorySummaryModal table tr:hover {
    background-color: #2a2a2a;
}

#inventorySummaryModal table td, #inventorySummaryModal table th {
    border: 1px solid #444;
}

.inventory-high-profit {
    background: rgba(76, 175, 80, 0.1);
}

.inventory-low-profit {
    background: rgba(244, 67, 54, 0.1);
}

.sortable-header {
    cursor: pointer;
    user-select: none;
}

.sortable-header:hover {
    background-color: #444;
}

.export-btn {
    background: linear-gradient(45deg, #4CAF50, #45a049);
    transition: all 0.3s ease;
}

.export-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.sort-btn {
    background: linear-gradient(45deg, #2196F3, #0b7dda);
    transition: all 0.3s ease;
}

.sort-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}
.region {
    transition: transform 0.3s ease;
}

.region:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.city-button {
    transition: all 0.3s ease;
}

.city-button:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.city-button:disabled {
    opacity: 0.6;
}

#travelInfo {
    border: 1px solid #555;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#travelProgressBar {
    transition: width 0.5s ease-in-out;
}
.auto-trade-status {
    background: #333;
    padding: 15px;
    border-radius: 5px;
    margin-top: 15px;
}

.auto-trade-status h4 {
    color: #FFD700;
    margin-top: 0;
    border-bottom: 1px solid #444;
    padding-bottom: 5px;
}

.auto-trade-progress {
    margin-top: 10px;
}

.route-item {
    background: #2a2a2a;
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
    border-left: 3px solid #4CAF50;
}

.route-item h5 {
    margin: 0;
    color: #FFD700;
}

.route-details {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-top: 5px;
    font-size: 0.9em;
}

.route-details div {
    padding: 3px 0;
}

.auto-trade-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.auto-trade-controls button {
    flex: 1;
    padding: 5px 10px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.auto-trade-controls button:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.auto-trade-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 10px;
}

.stat-item {
    background: #2a2a2a;
    padding: 8px;
    border-radius: 3px;
    text-align: center;
}

.stat-value {
    font-size: 1.2em;
    font-weight: bold;
    color: #FFD700;
}

.stat-label {
    font-size: 0.8em;
    color: #aaa;
}

.auto-trade-route {
    border: 1px solid #444;
    border-radius: 5px;
    padding: 10px;
    margin: 10px 0;
    background: #2a2a2a;
}

.auto-trade-route.active {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.1);
}

.route-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
}

.route-details {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
    font-size: 0.9em;
}

.route-action {
    margin-top: 5px;
    text-align: right;
}
.log-entry {
    transition: all 0.3s ease;
}

.log-entry:hover {
    background: #333 !important;
    transform: translateX(5px);
}

#logSearch:focus, #logFilter:focus {
    outline: none;
    border-color: #FFD700;
}

#autoTradeLogContainer {
    scrollbar-width: thin;
    scrollbar-color: #444 #222;
}

#autoTradeLogContainer::-webkit-scrollbar {
    width: 8px;
}

#autoTradeLogContainer::-webkit-scrollbar-track {
    background: #222;
}

#autoTradeLogContainer::-webkit-scrollbar-thumb {
    background: #444;
    border-radius: 4px;
}

#autoTradeLogContainer::-webkit-scrollbar-thumb:hover {
    background: #555;
}

.auto-trade-progress {
    margin-bottom: 15px;
    padding: 10px;
    background: #2a2a2a;
    border-radius: 5px;
    border-left: 4px solid #FFD700;
}

.progress-label {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-weight: bold;
}

.progress-bar {
    width: 100%;
    height: 15px;
    background: #333;
    border-radius: 7px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    border-radius: 7px;
    transition: width 0.5s;
}

.good-selection-item {
    transition: all 0.3s ease;
    cursor: pointer;
}

.good-selection-item:hover {
    border-color: #FFD700 !important;
    transform: translateY(-2px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.good-selection-item input[type="checkbox"] {
    accent-color: #4CAF50;
}

.auto-trade-route {
    transition: all 0.3s ease;
}

.auto-trade-route:hover {
    border-color: #FFD700 !important;
}

.auto-trade-route.active {
    border-color: #4CAF50 !important;
    background: rgba(76, 175, 80, 0.1) !important;
}

#goodsSelection input[type="number"] {
    background: #333;
    color: white;
    border: 1px solid #555;
    border-radius: 3px;
    padding: 5px;
}

#goodsSelection input[type="number"]:focus {
    outline: none;
    border-color: #FFD700;
}
.auto-trade-progress {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 15px;
    border-left: 4px solid #FFD700;
}

.progress-label {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-weight: bold;
}

.progress-label span:first-child {
    color: #FFD700;
}

.progress-label span:last-child {
    color: #4CAF50;
}

.progress-bar {
    width: 100%;
    height: 12px;
    background: #333;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    border-radius: 6px;
    transition: width 0.3s ease;
    position: relative;
    overflow: hidden;
}

.progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% {
        left: -100%;
    }
    100% {
        left: 100%;
    }
}

.real-time-indicator {
    position: absolute;
    right: 0;
    top: 0;
    background: rgba(0,0,0,0.5);
    color: white;
    padding: 2px 5px;
    font-size: 0.7em;
    border-radius: 0 0 0 3px;
}

.auto-trade-status {
    transition: all 0.3s ease;
}

.auto-trade-status:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}
.background-indicator {
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.background-trade-notice {
    background: linear-gradient(90deg, #2a2a2a, #333);
    border-left: 4px solid #4CAF50;
}

.background-trade-notice h4 {
    color: #4CAF50;
    margin-top: 0;
}

.background-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.background-controls button {
    flex: 1;
    padding: 8px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.background-controls button:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
button:disabled {
    opacity: 0.6;
    cursor: not-allowed !important;
}

.disabled-tooltip {
    position: relative;
}

.disabled-tooltip::after {
    content: "自动贸易已启用，无法手动操作";
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 5px;
    background: #333;
    color: white;
    border-radius: 3px;
    font-size: 0.8em;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}

.disabled-tooltip:hover::after {
    opacity: 1;
    visibility: visible;
}

.auto-trade-notice {
    background: linear-gradient(90deg, #2a2a2a, #333);
    border-left: 4px solid #FF9800;
    animation: pulseNotice 2s infinite;
}

@keyframes pulseNotice {
    0% { opacity: 1; }
    50% { opacity: 0.8; }
    100% { opacity: 1; }
}
.good-selection-item {
    transition: all 0.3s ease;
    cursor: pointer;
}

.good-selection-item:hover {
    border-color: #FFD700 !important;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

.auto-trade-route {
    transition: all 0.3s ease;
}

.auto-trade-route:hover {
    border-color: #FFD700 !important;
    transform: translateY(-1px);
}

.auto-trade-route.active {
    border-color: #4CAF50 !important;
    background: rgba(76, 175, 80, 0.1) !important;
}

.flexible-trade-status {
    background: linear-gradient(135deg, #2a2a2a, #333);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    border-left: 4px solid #FFD700;
}

.status-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 8px;
}

.status-indicator.idle {
    background: #FF9800;
    animation: pulse 2s infinite;
}

.status-indicator.buying {
    background: #4CAF50;
}

.status-indicator.selling {
    background: #2196F3;
}

.status-indicator.traveling {
    background: #9C27B0;
    animation: pulse 1.5s infinite;
}

.status-indicator.monitoring {
    background: #FFC107;
    animation: pulse 3s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.city-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    margin-top: 10px;
}

.city-stat-item {
    background: rgba(255,255,255,0.05);
    padding: 8px;
    border-radius: 4px;
    text-align: center;
}

.city-stat-value {
    font-size: 1.2em;
    font-weight: bold;
    color: #FFD700;
}

.city-stat-label {
    font-size: 0.8em;
    color: #aaa;
}

.trade-opportunity {
    background: linear-gradient(90deg, rgba(76,175,80,0.1), transparent);
    border-left: 3px solid #4CAF50;
    padding: 10px;
    margin: 5px 0;
    border-radius: 4px;
}

.trade-opportunity.warning {
    background: linear-gradient(90deg, rgba(255,152,0,0.1), transparent);
    border-left-color: #FF9800;
}

.trade-opportunity.info {
    background: linear-gradient(90deg, rgba(33,150,243,0.1), transparent);
    border-left-color: #2196F3;
}

.progress-container {
    margin: 15px 0;
}

.progress-bar-flexible {
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
    position: relative;
}

.progress-fill-flexible {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    border-radius: 4px;
    transition: width 0.5s ease;
}

.progress-fill-flexible::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 2s infinite;
}

.control-panel {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 10px;
    margin-top: 15px;
}

.control-btn {
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    transition: all 0.3s ease;
    text-align: center;
}

.control-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.control-btn.primary {
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
}

.control-btn.secondary {
    background: linear-gradient(135deg, #2196F3, #0b7dda);
    color: white;
}

.control-btn.warning {
    background: linear-gradient(135deg, #FF9800, #f57c00);
    color: white;
}

.control-btn.danger {
    background: linear-gradient(135deg, #f44336, #d32f2f);
    color: white;
}

.control-btn:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.price-monitor {
    background: #2a2a2a;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
}

.price-change {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.8em;
    font-weight: bold;
}

.price-change.positive {
    background: rgba(76,175,80,0.2);
    color: #4CAF50;
}

.price-change.negative {
    background: rgba(244,67,54,0.2);
    color: #f44336;
}

.price-change.neutral {
    background: rgba(255,193,7,0.2);
    color: #FFC107;
}

.trade-log-entry {
    border-left: 3px solid;
    padding: 8px 12px;
    margin: 5px 0;
    background: rgba(255,255,255,0.02);
    border-radius: 0 4px 4px 0;
}

.trade-log-entry.success {
    border-left-color: #4CAF50;
}

.trade-log-entry.info {
    border-left-color: #2196F3;
}

.trade-log-entry.warning {
    border-left-color: #FF9800;
}

.trade-log-entry.error {
    border-left-color: #f44336;
}

.opportunity-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.7em;
    font-weight: bold;
    margin-left: 8px;
}

.opportunity-badge.buy {
    background: rgba(76,175,80,0.2);
    color: #4CAF50;
}

.opportunity-badge.sell {
    background: rgba(33,150,243,0.2);
    color: #2196F3;
}

.opportunity-badge.travel {
    background: rgba(156,39,176,0.2);
    color: #9C27B0;
}

.flexible-settings {
    background: #2a2a2a;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
}

.setting-group {
    margin-bottom: 15px;
}

.setting-label {
    display: block;
    margin-bottom: 5px;
    color: #FFD700;
    font-weight: bold;
}

.setting-input {
    width: 100%;
    padding: 8px;
    background: #333;
    border: 1px solid #444;
    border-radius: 4px;
    color: white;
}

.setting-input:focus {
    outline: none;
    border-color: #FFD700;
}

.setting-description {
    font-size: 0.8em;
    color: #aaa;
    margin-top: 5px;
}

@media (max-width: 768px) {
    .city-stats {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .control-panel {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .flexible-trade-status {
        padding: 10px;
    }
}

.loading-spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid #333;
    border-top: 2px solid #FFD700;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 8px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.auto-trade-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: #2a2a2a;
    border-left: 4px solid #FFD700;
    padding: 15px;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 1000;
    max-width: 300px;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.notification-close {
    position: absolute;
    top: 5px;
    right: 10px;
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.2em;
}

.notification-close:hover {
    color: white;
}

.trade-summary {
    background: linear-gradient(135deg, #2a2a2a, #333);
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
}

.summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.summary-item {
    text-align: center;
}

.summary-value {
    font-size: 1.5em;
    font-weight: bold;
    color: #FFD700;
    margin-bottom: 5px;
}

.summary-label {
    font-size: 0.9em;
    color: #aaa;
}

.profit-positive {
    color: #4CAF50;
}

.profit-negative {
    color: #f44336;
}

.efficiency-high {
    color: #4CAF50;
}

.efficiency-medium {
    color: #FFC107;
}

.efficiency-low {
    color: #f44336;
}
.control-btn {
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    transition: all 0.3s ease;
    text-align: center;
}

.control-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.control-btn.primary {
    background: linear-gradient(135deg, #2196F3, #0b7dda);
    color: white;
}

.control-btn.secondary {
    background: linear-gradient(135deg, #9C27B0, #7b1fa2);
    color: white;
}

.control-btn.success {
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
}

.control-btn.info {
    background: linear-gradient(135deg, #00BCD4, #0097a7);
    color: white;
}

.control-btn.warning {
    background: linear-gradient(135deg, #FF9800, #f57c00);
    color: white;
}

.control-btn.danger {
    background: linear-gradient(135deg, #f44336, #d32f2f);
    color: white;
}

.control-btn.default {
    background: linear-gradient(135deg, #607D8B, #455a64);
    color: white;
}

.control-btn:disabled {
    background: #666;
    color: #999;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}
.intelligence-modal {
    animation: modalAppear 0.3s ease;
}

@keyframes modalAppear {
    from {
        transform: scale(0.9);
        opacity: 0;
    }
    to {
        transform: scale(1);
        opacity: 1;
    }
}

.intelligence-item {
    transition: all 0.3s ease;
}

.intelligence-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    background: rgba(255,255,255,0.1) !important;
}

.intelligence-table {
    width: 100%;
    border-collapse: collapse;
    margin: 10px 0;
}

.intelligence-table th {
    background: rgba(255, 215, 0, 0.1);
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #333;
    color: #FFD700;
}

.intelligence-table td {
    padding: 8px 10px;
    border-bottom: 1px solid #333;
}

.intelligence-table tr:last-child td {
    border-bottom: none;
}

.intelligence-table tr:hover {
    background: rgba(255,255,255,0.05);
}

.progress-bar-intel {
    display: inline-block;
    width: 60px;
    height: 6px;
    background: #333;
    border-radius: 3px;
    margin-right: 5px;
    vertical-align: middle;
}

.progress-fill-intel {
    height: 100%;
    border-radius: 3px;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
}

.status-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
}

.status-high {
    background: #4CAF50;
}

.status-medium {
    background: #FFC107;
}

.status-low {
    background: #f44336;
}

.event-impact-positive {
    color: #4CAF50;
    font-weight: bold;
}

.event-impact-negative {
    color: #f44336;
    font-weight: bold;
}

.event-impact-neutral {
    color: #FFC107;
    font-weight: bold;
}
.difficulty-btn {
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    color: white;
    transition: all 0.3s ease;
    min-width: 80px;
}

.difficulty-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 10px currentColor;
}

.difficulty-btn:active {
    transform: scale(0.95);
}
 .landlord-ui {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 90%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow: hidden;
        }
        
        .landlord-header {
            background: linear-gradient(to right, #2c3e50, #4a6491);
            color: white;
            padding: 15px 20px;
            text-align: center;
            border-bottom: 5px solid #f1c40f;
        }
        
        .landlord-header h2 {
            font-size: 2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .landlord-currency {
            font-size: 1.5em;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 50px;
            display: inline-block;
        }
        
        .landlord-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
        }
        
        .landlord-nav {
            display: flex;
            background: #34495e;
            padding: 0;
        }
        
        .landlord-tab {
            flex: 1;
            background: none;
            border: none;
            color: white;
            padding: 12px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .landlord-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .landlord-tab.active {
            background: #1abc9c;
            font-weight: bold;
        }
        
        .landlord-content {
            padding: 20px;
            height: calc(100% - 250px);
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.95);
        }
        
        .landlord-tab-content {
            display: none;
        }
        
        .landlord-tab-content.active {
            display: block;
            animation: fadeIn 0.5s;
        }
        
        /* 商店样式 */
        .landlord-store-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .landlord-seed-item, .landlord-item-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s;
            border: 2px solid #eee;
        }
        
        .landlord-seed-item:hover, .landlord-item-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .landlord-seed-icon, .landlord-item-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            color: white;
        }
        
        .landlord-seed-price, .landlord-item-price {
            font-size: 1.2em;
            font-weight: bold;
            margin: 10px 0;
            color: #e74c3c;
        }
        
        .landlord-buy-button {
            background: #2ecc71;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.3s;
        }
        
        .landlord-buy-button:hover:not(:disabled) {
            background: #27ae60;
        }
        
        .landlord-buy-button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        
        /* 田地样式 */
        .landlord-fields-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .landlord-field {
            background: linear-gradient(to bottom, #8BC34A, #689F38);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            min-height: 220px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .landlord-field.empty {
            background: linear-gradient(to bottom, #A5D6A7, #81C784);
            cursor: pointer;
        }
        
        .landlord-field.empty:hover {
            background: linear-gradient(to bottom, #C8E6C9, #A5D6A7);
        }
        
        .landlord-field-status {
            font-size: 1.2em;
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 10px;
        }
        
        .landlord-plant-info {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .landlord-mutations-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            margin: 10px 0;
        }
        
        .landlord-mutation-tag {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .landlord-mutation-grey { background: #bdc3c7; color: #2c3e50; }
        .landlord-mutation-green { background: #2ecc71; color: white; }
        .landlord-mutation-blue { background: #3498db; color: white; }
        .landlord-mutation-purple { background: #9b59b6; color: white; }
        .landlord-mutation-gold { background: #f1c40f; color: #2c3e50; }
        .landlord-mutation-rainbow { 
            background: linear-gradient(45deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6600ff);
            color: white;
        }
        
        .landlord-field-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .landlord-action-row {
            display: flex;
            gap: 8px;
        }
        
        .landlord-action-button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .landlord-harvest-button {
            background: #f39c12;
            color: white;
        }
        
        .landlord-harvest-button:hover {
            background: #e67e22;
        }
        
        .landlord-remove-button {
            background: #e74c3c;
            color: white;
        }
        
        .landlord-remove-button:hover {
            background: #c0392b;
        }
        
        .landlord-plant-button {
            background: #3498db;
            color: white;
            width: 100%;
            padding: 10px;
        }
        
        .landlord-plant-button:hover {
            background: #2980b9;
        }
        
        .landlord-item-button {
            background: #9b59b6;
            color: white;
        }
        
        .landlord-item-button:hover {
            background: #8e44ad;
        }
        
        /* 仓库样式 */
        .landlord-storage-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .landlord-storage-section {
            flex: 1;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .landlord-storage-section h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .landlord-storage-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .landlord-storage-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
            transition: background 0.3s;
        }
        
        .landlord-storage-item:hover {
            background: #f8f9fa;
        }
        
        .landlord-item-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .landlord-item-weight {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .landlord-item-value {
            color: #27ae60;
            font-weight: bold;
        }
        
        .landlord-total-assets {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .landlord-total-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-top: 10px;
        }
        
        /* 统计页面样式 */
        .landlord-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .landlord-stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .landlord-stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
            text-align: center;
            margin: 10px 0;
        }
        
        .landlord-progress-bar {
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .landlord-progress-fill {
            height: 100%;
            background: linear-gradient(to right, #2ecc71, #3498db);
            border-radius: 10px;
        }
        
        /* 解锁地块样式 */
        .landlord-unlock-container {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .landlord-unlock-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 10px;
            width: 100%;
        }
        
        .landlord-unlock-button:hover:not(:disabled) {
            opacity: 0.9;
        }
        
        .landlord-unlock-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* 通知样式 */
        .landlord-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            animation: slideIn 0.5s, fadeOut 0.5s 2.5s;
        }
        
        .landlord-notification.success {
            background: #2ecc71;
        }
        
        .landlord-notification.error {
            background: #e74c3c;
        }
        
        .landlord-notification.info {
            background: #3498db;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        /* 模态框样式 */
        .landlord-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1002;
        }
        
        .landlord-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            min-width: 300px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
        }
        
        .landlord-modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
        }
.landlord-storage-item.locked {
                position: relative;
                background: linear-gradient(135deg, #fff3cd, #ffeaa7) !important;
                border: 2px solid #f39c12 !important;
            }
            
            .landlord-storage-item.locked::before {
                content: '🔒';
                position: absolute;
                top: 5px;
                right: 5px;
                font-size: 1.2em;
            }
            
            .landlord-storage-item.locked .landlord-item-info {
                opacity: 0.9;
            }
            
            .landlord-lock-button {
                background: #f39c12 !important;
                color: white !important;
            }
            
            .landlord-lock-button:hover {
                background: #e67e22 !important;
            }
            #miningUI {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            background: #1a1a1a;
            color: white;
            padding: 20px;
            border: 3px solid #4CAF50;
            border-radius: 10px;
            z-index: 1001;
            overflow-y: auto;
        }
        
        .mining-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        .mining-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .mining-stat {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .mining-stamina {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .stamina-bar {
            width: 100%;
            height: 20px;
            background: #555;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .stamina-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff9a00);
            border-radius: 10px;
            transition: width 0.5s;
        }
        
        /* 新增：调整控制按钮区域布局 */
        .mining-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        /* 新增：通知栏样式调整 */
        .mining-notifications {
            height: 200px;
            overflow-y: auto;
            background: #222;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .mining-notification {
            padding: 5px;
            margin-bottom: 5px;
            border-left: 3px solid #4CAF50;
            background: #2a2a2a;
        }
        
        /* 新增：按钮组样式 */
        .mining-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        /* 分页标签样式 */
        .mining-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #4CAF50;
        }
        
        .mining-tab {
            padding: 10px 20px;
            cursor: pointer;
            background: #333;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s;
        }
        
        .mining-tab.active {
            background: #4CAF50;
            font-weight: bold;
        }
        
        .mining-tab:hover:not(.active) {
            background: #444;
        }
        
        /* 宝石页面样式 */
        .mining-gems-page {
            display: none;
        }
        
        .mining-gems-page.active {
            display: block;
        }
        
        .mining-gems {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mining-gem {
            background: #333;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* 新增：药水显示在宝石页面内 */
        .mining-potions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #52b788;
        }
        
        .potion-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .potion-icon {
            font-size: 1.5em;
        }
        
        .potion-count {
            font-size: 1.2em;
            font-weight: bold;
            color: #52b788;
        }
        
        /* 升级页面样式 */
        .mining-upgrades-page {
            display: none;
        }
        
        .mining-upgrades-page.active {
            display: block;
        }
        
        .mining-upgrades {
            margin-bottom: 20px;
        }
        
        .mining-upgrade {
            background: #333;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
     /* 房屋系统样式 */
        #houseSystemOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
        }
        
        #houseSystemUI {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            color: white;
            padding: 20px;
            border: 3px solid #8B4513;
            border-radius: 10px;
            z-index: 1001;
            width: 850px;
            max-height: 800px;
            overflow-y: auto;
        }
        
        .house-card {
            background: #333;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            border: 2px solid;
        }
        
        .house-common { border-color: #1E90FF; }
        .house-rare { border-color: #32CD32; }
        .house-epic { border-color: #FFD700; }
        .house-legendary { border-color: #9370DB; }
        .house-mythic { border-color: #FF4500; }
  /* 添加工作选择对话框的样式 */
.job-option:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
}

.job-option {
    transition: all 0.3s ease;
}

/* 响应式设计 */
@media (max-width: 768px) {
    #jobSelectionDialog {
        width: 95vw !important;
        padding: 15px !important;
    }
    
    .job-option {
        padding: 10px !important;
    }
}
.equipment-slots {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 20px;
}

.equipment-slot {
    background: #333;
    padding: 10px;
    border-radius: 5px;
    text-align: center;
    border: 2px solid #555;
    min-height: 120px;
}

.equipment-slot .slot-name {
    font-weight: bold;
    margin-bottom: 5px;
    color: #8a2be2;
}

.equipment-display {
    cursor: pointer;
    padding: 5px;
    border-radius: 3px;
}

.equipment-display:hover {
    background: #444;
}

.equipment-stats {
    font-size: 0.9em;
    color: #ccc;
    margin-top: 5px;
}

.equipment-inventory-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    overflow-y: auto;
}

.equipment-item {
    background: #333;
    padding: 10px;
    border-radius: 5px;
    border-left: 4px solid #8a2be2;
}

.equipment-item.locked {
    border-left: 4px solid #FFD700;
    background: #3a3a3a;
}

.equipment-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
}

.equipment-actions {
    display: flex;
    gap: 5px;
}

.equipment-actions button {
    padding: 3px 8px;
    font-size: 0.8em;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    background: #555;
    color: white;
}

.equipment-actions button:hover:not(:disabled) {
    background: #666;
}

.equipment-actions button:disabled {
    background: #333;
    color: #666;
    cursor: not-allowed;
}

.equipment-info {
    font-size: 0.9em;
    color: #aaa;
    margin-bottom: 5px;
}

.set-bonuses {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}

.set-info {
    background: #333;
    padding: 10px;
    border-radius: 5px;
}

.set-bonus.active {
    color: #4CAF50;
}

.set-bonus.inactive {
    color: #666;
}

.stats-summary {
    background: linear-gradient(45deg, #8a2be2, #4b0082);
    padding: 15px;
    border-radius: 5px;
    text-align: center;
}

.stats-summary h4 {
    margin-top: 0;
    color: #FFD700;
}

.stats-summary div {
    margin: 5px 0;
    font-size: 1.1em;
}
.equipment-item.selected {
    border: 2px solid #f44336 !important;
    background: #3a2a2a !important;
}

.selection-checkbox {
    position: absolute;
    top: 5px;
    right: 5px;
}

.selection-checkbox input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
}

.equipment-item {
    position: relative;
    cursor: pointer;
    transition: all 0.3s ease;
}

.equipment-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/* 批量操作面板样式 */
.batch-controls {
    background: linear-gradient(45deg, #ff6b6b, #ff8e53);
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 10px;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 0.8; }
    50% { opacity: 1; }
    100% { opacity: 0.8; }
}
.drop-time {
    color: #aaa;
    font-size: 0.85em;
    margin-top: 3px;
    font-style: italic;
}
.time-info {
    background: #2a2a2a;
    padding: 10px;
    border-radius: 5px;
    margin: 10px 0;
    border-left: 3px solid #4CAF50;
}

.time-info.expired {
    border-left-color: #f44336;
}

/* 导入历史样式 */
.import-history-list {
    max-height: 300px;
    overflow-y: auto;
}

.import-history-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    margin: 5px 0;
    background: #333;
    border-radius: 5px;
    border-left: 3px solid #FF9800;
}

.import-info {
    flex: 1;
}

.import-time {
    color: #aaa;
    font-size: 0.9em;
}

/* 文本框样式 */
.equipment-code {
    font-family: 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.4;
}
.beast-card {
    transition: all 0.3s ease;
}

.beast-card:hover {
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
}

/* 小宠物 - 灰色渐变 */
.beast-card[data-rarity="小宠物"] {
    background: linear-gradient(135deg,#333333, #444444, #555555, #666666, #777777, #666666, #555555, #444444, #333333);
   background-size: 400% 400%;
    animation: gradientFlow 5s ease infinite;
}

/* 野兽 - 蓝色渐变 */
.beast-card[data-rarity="野兽"] {
    background: linear-gradient(135deg,#1a237e,#283593,#3949ab,#5c6bc0,#7986cb,#00acc1,#8e24aa,#1a237e);
   background-size: 400% 400%;
    animation: gradientFlow 5s ease infinite;
}

/* 凶兽 - 紫色渐变 */
.beast-card[data-rarity="凶兽"] {
    background: linear-gradient(135deg,#4a148c,#7b1fa2,#9c27b0,#ab47bc,#ce93d8,#e1bee7,#ab47bc,#9c27b0,#7b1fa2,#4a148c);
   background-size: 400% 400%;
    animation: gradientFlow 5s ease infinite;
}

/* 灵兽 - 青色渐变 */
.beast-card[data-rarity="灵兽"] {
    background: linear-gradient(135deg,#004d40, #00695c, #00897b, #009688, #26a69a, #4db6ac, #80cbc4, #b2dfdb);
  background-size: 400% 400%;
    animation: gradientFlow 5s ease infinite;
}

/* 圣兽 - 金色渐变 */
.beast-card[data-rarity="圣兽"] {
    background: linear-gradient(135deg,#ffd700, #ffec8b, #ffd700, #ffa500, #ffd700, #ffec8b, #ffd700);
background-size: 400% 400%;
    animation: gradientFlow 5s ease infinite;
}

/* 神兽 - 橙红渐变 */
.beast-card[data-rarity="神兽"] {
    background: linear-gradient(135deg,#ff0000,#ff3300,#ff6600,#ff9900,#ffcc00,#ff9900,#ff6600,#ff3300);
    background-size: 400% 400%;
    animation: gradientFlow 5s ease infinite;
}

/* 炁兽 - 品红渐变（七彩流光效果） */
.beast-card[data-rarity="炁兽"] {
    background: linear-gradient(135deg,#ff00ff,#ff0080,#ff0066,#ff0040,#ff0020,#ff0000,#ff0020,#ff0040,#ff0066,#ff0080,#ff00ff );
    background-size: 400% 400%;
    animation: gradientFlow 5s ease infinite;
}

@keyframes gradientFlow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}
/* 确保弹窗层次 */
#beastSystemUI {
    z-index: 1000;
}

#beastActionOverlay {
    z-index: 1001;
}

#beastActionModal {
    z-index: 1002;
}
.equipped-beast-card {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
    border-radius: 6px;
    padding: 8px 12px;
    border-left: 3px solid;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 180px;
    flex: 1;
    position: relative;
    overflow: hidden;
}

.equipped-beast-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.1));
}

.equipped-beast-card .beast-name {
    font-weight: bold;
    font-size: 0.95em;
    margin-bottom: 3px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.equipped-beast-card .beast-rarity {
    font-size: 0.75em;
    padding: 1px 6px;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.3);
}

.equipped-beast-card .beast-stats {
    font-size: 0.8em;
    color: #4CAF50;
    margin-top: 5px;
}

.equipped-beast-card .beast-slots {
    position: absolute;
    top: 5px;
    right: 5px;
    font-size: 0.7em;
    color: gold;
    background: rgba(0, 0, 0, 0.3);
    padding: 1px 5px;
    border-radius: 3px;
}

/* 空槽位样式 */
.equipped-slot-empty {
    background: rgba(255, 255, 255, 0.05);
    border: 2px dashed rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    padding: 15px;
    text-align: center;
    color: #888;
    font-size: 0.9em;
    cursor: default;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    min-height: 60px;
}

.equipped-slot-empty:hover {
    background: rgba(255, 255, 255, 0.08);
    color: #aaa;
}
select {
    background: #2a2a2a;
    color: white;
    border: 1px solid #444;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    outline: none;
    transition: border-color 0.2s;
}

select:hover {
    border-color: #8A2BE2;
}

select:focus {
    border-color: #8A2BE2;
    box-shadow: 0 0 5px rgba(138, 43, 226, 0.3);
}

/* 快速筛选按钮样式 */
#equippedBeastsSection button {
    transition: all 0.2s ease;
}

#equippedBeastsSection button:hover {
    transform: translateY(-1px);
    opacity: 0.9;
}

/* 装备状态标识 */
.beast-status-icon {
    font-size: 0.8em;
    margin-right: 3px;
}
#shareUpgradeSection input[type="number"] {
    text-align: center;
}

#shareUpgradeSection input[type="number"]::-webkit-inner-spin-button,
#shareUpgradeSection input[type="number"]::-webkit-outer-spin-button {
    opacity: 1;
    height: 30px;
}

/* 神兽蛋图标动画 */
@keyframes eggBounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
}

.egg-icon {
    display: inline-block;
    animation: eggBounce 2s ease-in-out infinite;
    margin-right: 5px;
}

/* 升级按钮悬停效果 */
#shareUpgradeSection button:hover {
    opacity: 0.9;
    transform: translateY(-2px);
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
}

#shareUpgradeSection button:active {
    transform: translateY(1px);
}

/* 进度条动画 */
#upgradeProgressBar {
    transition: width 0.5s ease-in-out;
}

.landlord-field.locked {
        background: linear-gradient(135deg, #556b2f, #6b8e23);
        border: 2px solid #3d5326;
        box-shadow: 0 4px 12px rgba(85, 107, 47, 0.3);
        position: relative;
        overflow: hidden;
    }
    
    .landlord-field.locked::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
            45deg,
            rgba(109, 139, 44, 0.1),
            rgba(109, 139, 44, 0.1) 10px,
            rgba(85, 107, 47, 0.05) 10px,
            rgba(85, 107, 47, 0.05) 20px
        );
        pointer-events: none;
        z-index: 1;
    }
    
    /* 锁定田地的文字颜色 */
    .landlord-field.locked .landlord-field-header {
        background: linear-gradient(to right, rgba(77, 96, 36, 0.8), rgba(109, 139, 44, 0.8));
        border-bottom: 1px solid #5a6f1f;
        color: #f5f5f5;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        position: relative;
        z-index: 2;
    }
    
    .landlord-field.locked .landlord-field-number {
        color: #d4d4aa;
    }
    
    .landlord-field.locked .plant-name {
        color: #ffffff;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }
    
    .landlord-field.locked .landlord-plant-details,
    .landlord-field.locked .landlord-empty-content {
        position: relative;
        z-index: 2;
    }
    

    .landlord-field.locked .landlord-mutation-tag {
        color: #f0f0f0;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
    }
    
    /* 锁定徽章样式 */
    .lock-badge {
        background: linear-gradient(135deg, #556b2f, #3d5326);
        color: #d4d4aa;
        font-size: 0.7em;
        padding: 3px 8px;
        border-radius: 12px;
        border: 1px solid #8f9779;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    /* 锁定按钮样式 - 军绿色 */
    .landlord-lock-button {
        background: linear-gradient(135deg, #8f9779, #6b8e23);
        border: 2px solid #5a6f1f;
        color: #ffffff;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 1.1em;
        transition: all 0.3s;
        padding: 0;
        box-shadow: 0 2px 5px rgba(85, 107, 47, 0.4);
        position: relative;
        z-index: 2;
    }
    
    .landlord-lock-button:hover {
        background: linear-gradient(135deg, #6b8e23, #556b2f);
        border-color: #8f9779;
        transform: scale(1.1) rotate(10deg);
        box-shadow: 0 4px 8px rgba(85, 107, 47, 0.6);
    }
    
    .landlord-lock-button.active {
        background: linear-gradient(135deg, #3d5326, #2c3e1f);
        border-color: #8f9779;
        color: #d4d4aa;
        box-shadow: 0 2px 5px rgba(61, 83, 38, 0.6);
    }
    
    .landlord-lock-button.active:hover {
        background: linear-gradient(135deg, #2c3e1f, #3d5326);
        border-color: #a3b18a;
        transform: scale(1.1) rotate(-10deg);
    }
    
    /* 按钮内部的锁图标装饰 */
    .landlord-lock-button::after {
        content: '';
        position: absolute;
        width: 24px;
        height: 24px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        opacity: 0;
        transition: all 0.3s;
    }
    
    .landlord-lock-button:hover::after {
        opacity: 1;
        transform: scale(1.3);
    }
    
    /* 锁定田地中的操作按钮样式 */
    .landlord-field.locked .landlord-harvest-button {
        background: linear-gradient(135deg, #556b2f, #6b8e23);
        border: 1px solid #8f9779;
        color: #ffffff;
    }
    
    .landlord-field.locked .landlord-harvest-button:hover {
        background: linear-gradient(135deg, #6b8e23, #8f9779);
        border-color: #d4d4aa;
    }
    
    .landlord-field.locked .landlord-remove-button {
        background: linear-gradient(135deg, #8b4513, #a0522d);
        border: 1px solid #8f9779;
        color: #ffffff;
    }
    
    .landlord-field.locked .landlord-remove-button:hover {
        background: linear-gradient(135deg, #a0522d, #8b4513);
        border-color: #d4d4aa;
    }
    
    .landlord-field.locked .landlord-item-button {
        background: linear-gradient(135deg, #2c5282, #2a4365);
        border: 1px solid #8f9779;
        color: #ffffff;
    }
    
    .landlord-field.locked .landlord-item-button:hover {
        background: linear-gradient(135deg, #2a4365, #2c5282);
        border-color: #d4d4aa;
    }
    
    /* 进度条样式调整 */
    .landlord-field.locked .landlord-progress-bar {
        background: rgba(61, 83, 38, 0.5);
        border: 1px solid #8f9779;
    }
    
    .landlord-field.locked .landlord-progress-fill {
        background: linear-gradient(90deg, #8f9779, #d4d4aa);
        box-shadow: 0 0 5px rgba(212, 212, 170, 0.5);
    }
    
    /* 批量锁定按钮的军绿色主题 */
    .lock-all-btn {
        background: linear-gradient(135deg, #556b2f, #6b8e23);
        color: white;
        border: 1px solid #5a6f1f;
    }
    
    .lock-all-btn:hover {
        background: linear-gradient(135deg, #6b8e23, #8f9779);
        border-color: #d4d4aa;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(85, 107, 47, 0.4);
    }
    
    /* 解锁按钮样式 */
    .unlock-all-btn {
        background: linear-gradient(135deg, #8f9779, #a3b18a);
        color: #2c3e50;
        border: 1px solid #8f9779;
    }
    
    .unlock-all-btn:hover {
        background: linear-gradient(135deg, #a3b18a, #d4d4aa);
        border-color: #d4d4aa;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(143, 151, 121, 0.4);
    }
    
    /* 锁定有作物按钮样式 */
    .lock-planted-btn {
        background: linear-gradient(135deg, #2c5282, #2a4365);
        color: white;
        border: 1px solid #2c5282;
    }
    
    .lock-planted-btn:hover {
        background: linear-gradient(135deg, #2a4365, #2c5282);
        border-color: #63b3ed;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(44, 82, 130, 0.4);
    }
    
    /* 锁定成熟按钮样式 */
    .lock-mature-btn {
        background: linear-gradient(135deg, #9b2c2c, #742a2a);
        color: white;
        border: 1px solid #9b2c2c;
    }
    
    .lock-mature-btn:hover {
        background: linear-gradient(135deg, #742a2a, #9b2c2c);
        border-color: #fc8181;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(155, 44, 44, 0.4);
    }
    
    /* 锁定计数显示 */
    #lockedFieldsCount {
        font-weight: bold;
        color: #556b2f;
        font-size: 1.2em;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    /* 锁定动画效果 */
    @keyframes lockGlow {
        0% { box-shadow: 0 0 5px #6b8e23; }
        50% { box-shadow: 0 0 20px #8f9779, 0 0 30px #556b2f; }
        100% { box-shadow: 0 0 5px #6b8e23; }
    }
    
    .landlord-field.locked {
        animation: lockGlow 2s ease-in-out;
    }
    
    @keyframes lockIconSpin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .landlord-lock-button:active {
        animation: lockIconSpin 0.5s ease;
    }
    
    /* 锁定田地中的突变标签调整 */
    .landlord-field.locked .landlord-mutation-tag {
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    /* 添加锁定图标的额外装饰 */
    .landlord-field.locked .landlord-field-header::before {
        content: '🔒';
        position: absolute;
        left: 15px;
        opacity: 0.2;
        font-size: 1.5em;
        z-index: 1;
    }
    
    /* 一键收获按钮的军绿色主题 */
    .harvest-all-button {
        background: linear-gradient(135deg, #556b2f, #28a745);
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
        min-width: 220px;
        box-shadow: 0 4px 10px rgba(85, 107, 47, 0.3);
        position: relative;
        overflow: hidden;
    }
    
    .harvest-all-button::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: linear-gradient(
            to right,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.1) 50%,
            rgba(255, 255, 255, 0) 100%
        );
        transform: rotate(30deg);
        transition: all 0.5s;
    }
    
    .harvest-all-button:hover {
        background: linear-gradient(135deg, #6b8e23, #20c997);
        transform: translateY(-3px);
        box-shadow: 0 6px 15px rgba(85, 107, 47, 0.5);
    }
    
    .harvest-all-button:hover::before {
        left: 100%;
    }
    
    /* 控制面板的军绿色边框 */
    .harvest-controls {
        border: 2px solid #8f9779;
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    }
.investment-game .chart-placeholder {
    height: 300px; /* 增加高度 */
    background: white;
    border-radius: 12px;
    position: relative;
    overflow: hidden;
    border: 1px solid #e2e8f0;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    transition: opacity 0.3s ease;
}

.investment-game .chart-placeholder svg {
    display: block;
    width: 100%;
    height: 100%;
}

.investment-game .chart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e2e8f0;
}

.investment-game .chart-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #2c3e50;
    display: flex;
    align-items: center;
    gap: 8px;
}

.investment-game .chart-title i {
    color: #3b82f6;
    font-size: 1rem;
}

.investment-game .price-range-info {
    display: flex;
    gap: 15px;
    font-size: 0.85rem;
    color: #64748b;
    margin-top: 5px;
}

.investment-game .price-range-item {
    display: flex;
    align-items: center;
    gap: 4px;
}

.investment-game .price-range-label {
    font-weight: 500;
}

.investment-game .price-range-value {
    font-weight: 600;
    color: #334155;
}

/* 模拟投资分页：覆盖全局 .tab { display:none }，保证三个分页可见 */
.investment-game .tabs {
    display: flex !important;
}
.investment-game .tabs .tab {
    display: flex !important;
}

@keyframes pulse-gold {
    0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
    50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
    100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
}

@keyframes glow-red {
    0% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
    50% { box-shadow: 0 0 60px rgba(255, 215, 0, 0.9); }
    100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
}

@keyframes pop-up {
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

.nian-beast-hit {
    animation: shake 0.3s;
}
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* 战斗日志容器样式优化 */
#nianBattleLog {
    background: rgba(0,0,0,0.1) !important;
    padding: 15px;
    border-radius: 15px;
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid #FFD700;
    font-family: 'Courier New', monospace;
    display: flex;
    flex-direction: column-reverse;
}

/* 自定义滚动条 */
#nianBattleLog::-webkit-scrollbar {
    width: 6px;
}

#nianBattleLog::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.3);
    border-radius: 3px;
}

#nianBattleLog::-webkit-scrollbar-thumb {
    background: #FFD700;
    border-radius: 3px;
}

#nianBattleLog::-webkit-scrollbar-thumb:hover {
    background: #FFA500;
}

/* 战斗日志条目悬停效果 */
#nianBattleLog div {
    transition: background-color 0.2s;
}

#nianBattleLog div:hover {
    background-color: rgba(255,215,0,0.1);
}
@keyframes glow-pink {
    0% { box-shadow: 0 0 20px rgba(255,105,180,0.3); }
    50% { box-shadow: 0 0 40px rgba(255,105,180,0.6); }
    100% { box-shadow: 0 0 20px rgba(255,105,180,0.3); }
}
@keyframes pulse-orange {
    0% { box-shadow: 0 0 10px rgba(255,69,0,0.5); }
    50% { box-shadow: 0 0 30px rgba(255,69,0,0.8); }
    100% { box-shadow: 0 0 10px rgba(255,69,0,0.5); }
}
@keyframes pop-up {
    0% {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0;
    }
    100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
    }
}
@keyframes pulse-red {
    0% {
        box-shadow: 0 0 10px rgba(244,67,54,0.5);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 30px rgba(244,67,54,0.8);
        transform: scale(1.05);
    }
    100% {
        box-shadow: 0 0 10px rgba(244,67,54,0.5);
        transform: scale(1);
    }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}
@keyframes pulse-purple {
    0% { box-shadow: 0 0 20px rgba(156,39,176,0.5); }
    50% { box-shadow: 0 0 40px rgba(156,39,176,0.8); }
    100% { box-shadow: 0 0 20px rgba(156,39,176,0.5); }
}

@keyframes glow-purple {
    0% { box-shadow: 0 0 30px rgba(156,39,176,0.6); }
    50% { box-shadow: 0 0 60px rgba(156,39,176,0.9); }
    100% { box-shadow: 0 0 30px rgba(156,39,176,0.6); }
}
@keyframes healFloat {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(0.5);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -100%) scale(1.5);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -150%) scale(2);
    }
}

.tab { display: none !important; }
.tab.tab-item-new { display: block !important; }
#gameLogPage1, #gameLogPage2, #gameLogPage3, #gameLogPage4 { display: none; }
#gameLogPage1.active, #gameLogPage2.active, #gameLogPage3.active, #gameLogPage4.active { display: block; }
/* 攻略/日志弹层：居中 + 遮罩 + 顶部关闭 */
.guide-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 9998; display: none; }
.guide-modal-overlay.show { display: block; }
.guide-modal-box { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999; background: #fff; border-radius: 8px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); max-width: 90vw; width: 420px; max-height: 85vh; display: flex; flex-direction: column; overflow: hidden; min-height: 200px; }
.guide-modal-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #e2e8f0; background: #f8fafc; flex-shrink: 0; }
.guide-modal-title { font-size: 16px; font-weight: 700; color: #1e293b; margin: 0; }
.guide-modal-close { padding: 6px 14px; border: 1px solid #cbd5e1; background: #fff; color: #475569; border-radius: 6px; cursor: pointer; font-size: 13px; }
.guide-modal-close:hover { background: #f1f5f9; border-color: #94a3b8; }
.guide-modal-body { padding: 12px 16px; overflow-y: scroll; overflow-x: hidden; flex: 1; min-height: 0; max-height: 70vh; font-size: 13px; line-height: 1.6; -webkit-overflow-scrolling: touch; }
.guide-modal-body::-webkit-scrollbar { width: 8px; }
.guide-modal-body::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 4px; }
.guide-modal-body::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
.guide-modal-body::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body onload="resetItemDisplay(); resetPetDisplay()">
<!-- 新手必看：由顶栏「攻略」呼出，居中显示 -->
<div id="guideOverlay" class="guide-modal-overlay" onclick="document.getElementById('gameLogPage5').style.display='none'; this.classList.remove('show');"></div>
<div id="gameLogPage5" class="guide-modal-box" style="display: none;">
    <div class="guide-modal-header">
        <span class="guide-modal-title">新手必看</span>
        <button type="button" class="guide-modal-close" onclick="document.getElementById('gameLogPage5').style.display='none'; document.getElementById('guideOverlay').classList.remove('show');">关闭</button>
    </div>
    <div class="guide-modal-body">
        <div class="log">
            <h4>游戏公告介绍</h4>
            <p>QQ群：902481027  ，864788026，  有问题可以进群问（存档异常联系群管理修复）</p>
            <p>1. 转生系统：玩家可以通过转生重置游戏进度，并获得转生币，用于提升转生属性（转生要求必须普通装备10000+转生次数*20）。</p>
            <p> 转生币等级兑换比例：普通10000=1  稀有5000=1 史诗1000=1 传说300=1 远古200=1 神圣125=1 奥术100=1 天空33=1 地狱20=1 星界12.5=1  原初10=1 超凡3=1 量子2=1 究极1=1  混沌1=3 永恒1=5 虚无1=10 创世1=20 神域1=30 终焉1=40 星辰1=50 起源1=60 时光1=70 造物1=80 银河1=90 天界1=100 星云1=200 星河1=300 纪元1=400 鸿蒙1=500 星穹1=600 亘古1=700 万象1=800 太虚1=900 九垓1=1000  穿梭1=2000  恒古1=3000 虚空1=4000 蔚来1=5000 神罚1=6000  时空1=7000  未来1=8000  从前1=9000   星澜1=10000</p>
            <p>货币兑换比例：1e5 → 1e8 → 1e8 → 1e8 → 1e9 → 1e12 → 1e12 → 1e12 → 1e15 → 1e15 → 1e15 → 1e20 → 1e20 → 1e20 </p>
            <p>2. 宠物系统：玩家可以通过升级宠物来提升装备属性加成。</p>
            <p>3. 离线系统：现在离线也能奥秘经验和银行和股票，彩票更新，升级装备。</p>
            <p>4. 股票系统，显示实时股价和持有情况，每10分钟股价随机波动±1%~10%，离线时间自动计算股价波动，所有交易使用转生币结算，实时显示价格变化趋势</p>
            <p>5. 彩票系统：30分钟开奖1次。刮刮卡：直接生效，开奖结果看获取！</p>
            <p>6. 银行系统：存钱每6分钟0.02%收益！</p>
            <p>7. 副本装备系统：副本装备可以提升第一页装备的全属性，使用洗炼石（材料宝箱或者打怪掉）可以重铸副本装备的成长属性或者分解重新获取。成长数值上限：废品0.05%，倚天剑10%，青龙枪15%，白虎斧20%，朱雀弓25%，玄武盾30%，麒麟杖35%，凤凰剑40%，饕餮刀45%，穷奇戟50%，烛龙枪60%，白泽剑70%，混沌斧80%，太初刃90%   后续加深颜色多10%  比如：☆=100%★=110% ○=200% ●=210%  ◇=300%  ◆=310%  □=400%  ■=410%  △=500%  ▲=510%</p>
            <p>8. 魂环系统：魂环可以永久提升装备属性，通过打怪掉落升级。</p>
            <p>9. 打怪模式(必须先打)：1转开启，逃跑等于重置关卡消耗最大关卡*10转生币（取消扫荡增加自动扫荡4秒1次！！！）（优先打！第一次打点逃跑！！！）。</p>
            <p>10. 升级属性：第一次加载要转生一次，在点洗点就正常了（总数和实际不一样点一下洗点）。</p>
            <p>11. 功法秘籍：后期比较强，加成属性直接算到玩家属性乘于里面（如果突然没效果了开一个秘法宝箱就好了，正常不会有问题）</p>
            <p>11. 世界BOSS系统：50转开启，才能打比较难，有连击后期简单。</p>
            <p>12. VIP系统：每一级提升大属性，材料宝箱和打怪模式，各种系统掉落。</p>
            <p>13. 职业系统：20转开启，有法师和战士不同搭配属性，对于关卡解锁属性，选择获得属性，通天塔达到层数2转3转。</p>
            <p>14. 称号系统：10转开启，解锁每一个都可以永久获得属性，自由搭配选择称号(不影响属性效果）。</p>
            <p>14. 官职系统：10转开启，增加总和攻击，一共65级。</p>
            <p>15. 伴侣系统：30转开启，大幅度增加属性。 天赋品阶初级→中级→高级→终极→圣级→神级→远古→太古→洪荒→无上→太初→混沌→虚数→永恒→归墟→炁叕， 进阶玩法：每进阶+1倍率加1倍，未锁定状态才能进阶，点进阶自动消耗道具里面的同品质伴侣灵魂，想保留的伴侣记得锁定，史诗以上才能合成洗练！！！（伴侣钥匙和玫瑰花和洗髓丹：打怪或者材料宝箱各种系统掉落）。</p>
            <p>16. 通天塔：100转开启，只要通过每一层加1点玩家属性，每一层加0.01倍GPS,还有对应称号。</p>
            <p>17. 存档问题：换设备后存档导入一开始进去VIP和伴侣是空的，你直接退出在重新进就恢复了或者刷新页面（点了导出按钮，会自动复制，你黏贴就可以了）</p>
            <p>18. 奥秘系统：100转开启，每阶段只生效第一个效果。</p>
            <p>19. 基金系统：投入的越多波动的幅度越大10-50%，1分钟刷新一次 ，10分钟不能实时卖出，如果跌到总价值20%以下 就全部没收清零。</p>
            <p>20. 钓鱼系统：20转开启，分解鱼类可以获得VIP能力值，玫瑰花，洗髓丹，洗练石，农场种子。鱼饵掉率（打怪模式扫荡，各种系统兑换）（自动钓鱼开启没用，点一下开始钓鱼，自动分解是分解钓到的所有东西）</p>
             <p>21. 农场系统：50转开启，种子靠鱼类分解，可以获得VIP能力值（水滴等于VIP能力值），每级都有每秒GPS和点击加成</p>
            <p>22. 停车场系统：200转开启，靠种子收取时候有几率获得车（进群领取兑换码送 "法拉利" ），每级都有每秒GPS和点击加成</p>
            <p>23. 神器锻造系统：500转开启，探索获取材料，6个品质，集齐套装加格外属性。</p>
           <p>24. 星域探索：300转开启，获取新材料，商店：（发票可以兑换4材料，星尘：杂货铺或者藏宝图。暗物质：购买宝石。宇宙晶体：升级神器。神器碎片：锻造神器）</p>
           <p>25. 宝石系统：800转开启，提供大量属性</p>
           <p>26. 修仙系统：500转开启，开启经验获得条件是：获得一次灵根和血脉。材料都是杂货铺购买，法宝：材料世界地图挖矿掉落</p>
           <p>27. 宝图系统：600转开启，随机奖励或者打BOSS。</p>
           <p>28. 夜店系统：600转开启，店铺每级加点击伤害，特殊事件消耗50-200星币，提升30-60分钟金币或者经验收益，获得的星币可以兑换藏宝图，或者打世界地图怪物消耗（后续会加其他材料兑换）。</p>
           <p>29. 玩家等级：50转开启，每级1倍属性飞升轮回有加成，世界地图怪物打怪升级。每100级可以飞升一次，10次飞升1转轮回，翅膀：打怪次元2以上掉落，坐骑：打怪次元3以上掉落，符文：打怪次元4以上掉落，轮回装备：次元2以上掉落（掉落极低，掉落的装备可以分享给别人），轮回神兽：次元2以上掉落可以分享给别人</p>
           <p>30. 世界地图：50转开启，打怪掉玩家经验，每挑战一次消耗星币，如果打的时候闪退界面，那就是打不过这关。（掉落材料，翅膀，符文，轮回装备，轮回神兽）。</p>
          <p>31. 直播系统：500转开启，每级增加点击伤害，粉丝数增加GPS加成，流量是获得多倍经验（获取大量玫瑰花）</p>
        <p>32. 宗门系统：1000转开启，每级GPS收益，功法库提升功法秘笈加成。</p>
        <p>33.轮回副本： 黑龙潭副本：1轮回开启，掉落大量材料，翅膀升级材料。   圣兽岛副本：2轮回开启，掉落大量材料，坐骑升级材料。. 蓬莱仙岛系统：3轮回开启，掉落大量材料，符文升级材料。 轮回试炼副本(轮回2转开启）：有几率掉落T1装备和S1神兽。轮回仙岛副本(轮回3转开启）：有几率掉落T2装备和S2神兽 </p>             
        <p>34. 跑商系统：1000转开启，可以获得大量星币。</p>         
        <p>35. 娱乐玩法：老虎机。</p>
       <p>36. 秘境：2000转开启，提升临时总数值，和大量神器碎片（藏宝图怪物掉落）。</p>
       <p>37. 疯狂地主：0转开启（打怪模式第三层以上开启），提升总数值根据（总获得地主币），新版农田，10分钟刷新商店，成熟只要不收获也可以吃天气词条，离线也可以吃词条，最高26条。</p>
       <p>38. 无尽挖矿：(升级一下稿子等级不然挖不到普通矿)1500转开启，提升大量世界地图经验，和各项属性。</p>
       <p>39. 新版股票:（打怪模式第三层以上开启）（离线后如果打不开点一下疯狂地主再打开）</p>
      <p>40. 房子系统:200转开启，新版股票资金购买，每秒GPS加成 ，收益点击加成（群里兑换码可以领取别墅）</p>
      <p>41. 结婚系统:(资金总额达到5W开启)，可以生孩子。各种加成</p>
      <p>42. 赌石系统:(资金总额达到5000开启)，一刀穷，一刀富，一刀穿麻布。</p>
      <p>43. 修仙副本:(修仙2级开启)，掉落修仙经验和材料.  新年年兽副本20级开启.试练塔10级开启</p>
      <p>44. 抽象时装:(100转开启)，加少量属性，非常抽象，低概率掉落。</p>
       <p>45. 无限深渊(肉鸽玩法):(2500开启),层数增加少量属性，世界经验（藏宝图购买深渊令牌才能挑战）。</p>
        </div>
    </div>
</div>

<!-- 更新日志：由顶栏「日志」呼出，居中显示 -->
<div id="changelogOverlay" class="guide-modal-overlay" onclick="document.getElementById('changelogPanel').style.display='none'; this.classList.remove('show');"></div>
<div id="changelogPanel" class="guide-modal-box" style="display: none;">
    <div class="guide-modal-header">
        <span class="guide-modal-title">更新日志</span>
        <button type="button" class="guide-modal-close" onclick="document.getElementById('changelogPanel').style.display='none'; document.getElementById('changelogOverlay').classList.remove('show');">关闭</button>
    </div>
    <div class="guide-modal-body">
        <div class="log">
            <h4>1.895更新日志</h4>
            <h4>QQ群：902481027  ，864788026，  有问题可以进群问（存档异常联系群管理修复）</h4>   
            <p>2026/02/28:  无限深渊新增奇遇玩法，增加深渊宝库.  宗门增加新内容。 修复模拟股票BUG,(跑商自动贸易修改策略，更新后记得重新设置，现在只购买策略选的商品，记得修改价格)，修复跑商无限扣星币BUG<p>
            <p>2026/02/27:  修复无限深渊BUG</p>         
            <p>2026/02/27:  跑商趣味玩法：新增「趣味玩法」标签页—黑市（机遇触发）、传闻板、今日幸运；扩展随机事件：神秘商人、路边宝箱、贵人相助、关税、黑市入口、小道消息、捡漏；旅行关税与贵人相助生效。 跑商雇员与风险管理优化：雇员新增账房先生(卖价+2%)、跑腿伙计(旅行-5%)、防损专员(腐败率-30%)、市场顾问(传闻效果+20%)；风险管理新增综合险(货物+运输6%)、运输故障事件(运输险可赔付)、风险偏好(稳健/平衡/激进)。</p>
            <p>2026/02/26:  跑商增加离线自动贸易（开启后才生效）运输购买后永久使用可切换。修复自动购买BUG显示关闭错误，优化存档会流畅一点，增加无限深渊玩法</p>
            <p>2026/02/25:  无限深渊：增加宝石，符文，加入2转后4个分支，加强全部装备技能，宠物技能，修改怪物伤害逻辑</p>
            <p>2026/02/24:  修复离线收益消失BUG.增加无限深渊：2500开启 藏宝图购买深渊令牌才能挑战 。</p>
            <p>2026/02/23:  修复模拟投资导致炸档BUG （如果之前有这个导致炸档这个版本自动修复存档） 。</p>
            <p>2026/02/20:  增加抽象时装：世界地图掉落 。还有玩家头像设置：自行设置</p>
            <p>2026/02/17:  增加新轮回副本：轮回试炼副本(轮回2转开启）：有几率掉落T1装备和S1神兽。轮回仙岛副本(轮回3转开启）：有几率掉落T2装备和S2神兽，修复星际舰队属性不会在重置为1级导入存档也不会。 </p>
            <p>2026/02/16:  修改界面UI </p>
            <p>2026/02/27: 宗门系统新增修仙联动玩法：传功殿（空闲弟子消耗灵石传功给掌门获得修仙经验，资质越高效果越好）、灵泉池（消耗50万灵石浸泡获得修仙经验，12h冷却）、悟道台（消耗20万灵石开启2小时悟道，持续获得修仙经验）、宗门任务新增修仙经验奖励及【寻找仙草】【古地悟道】两任务、声望商店新增灵根检测器/血脉检测剂/香囊兑换</p>
            <p>2026/02/15:  修仙副本新增：试练塔修仙10级开启挑战成功有奖励，每层数增加每秒GPS和点击。增加新职业：探险家。修复离线修仙经验没生效BUG </p>
            <p>2026/02/14:  增加修仙副本(修仙2级开启）：新年年兽修仙副本20级开启（进群领取专属打年兽神器）， 掉落修仙经验，道具。 开启血脉和灵根修改成保存替换，高品质会有提升保存还是取消,修复年兽每次挑战技能没重置</p>
            <p>2026/02/04:  加入赌石系统（前期）：一刀穷，一刀富，一刀穿麻布。</p>
            <p>2026/02/03: 修复符文无法合成，宗门玩家不能派遣</p>
           <p>2026/02/03: 挖矿增加自动使用药水，法宝材料挖矿也有几率掉落。增加股票购买上限， 增加房子，宗门任务增加一键派遣。</p>
            <p>2026/02/01: 增强修仙系统：法宝：世界地图打怪掉落材料合成（群里兑换码可以领取：落宝金钱）。 </p>
            <p>2026/01/29: 修复BUG，增强修仙系统：现在等级可以加量自动购买宝箱数量，五行之力加各种属性。 </p>
            <p>2026/01/17: 修改新版股票显示，方便操作 </p>
           <p>2026/01/15: 修改宗门功法加成，降低连击，提升攻击爆伤，总体输出提升。修复轮回装备筛选丢弃全选异常。疯狂地主田地加了锁定（以后方便一键收获）</p>
           <p>2026/01/11: 修改自动购买功法宝箱新号上限购买0.1，修复轮回神兽丢弃。</p>
           <p>2026/01/10: 增加轮回神兽：可以升级（次元2以上掉落极低，掉落的装备可以分享给别人）.</p>
           <p>2026/01/09: 增强伴侣系统，增强停车场：现在停车场等级可以减少跑商时间，增加次元678.</p>
           <p>2026/01/07:  修复BUG导致游戏暴毙。更新玩家系统，增加轮回装备（次元2以上掉落极低，掉落的装备可以分享给别人）</p>
           <p>2026/01/04:  更新结婚系统玩法，生孩子（恩爱25级开启）有加成，孩子长大也可以工作</p>
           <p>2026/01/03:  增加结婚系统资金5W开启，无尽挖矿增加玩法：挖矿有几率出宝物，出售可以卖资金。</p>
           <p>2025/12/31: 修复新版股票在线无法正常刷新数据。 更新疯狂地主玩法。</p>
           <p>2025/12/29: 更新疯狂地主系统，加强停车场加成，增加房子系统200转开启，股票资金购买（群里兑换码可以领取别墅）</p>
           <p>2025/12/28:修复疯狂地主一键收获BUG，修复严重BUG离线系统异常没生效问题，直播系统过几秒人数只有6人正常不影响送礼（保存机制原因不会暂用内存），加入新版股票，随机波动涨跌，对应称号。 </p>
           <p>2025/12/24:修复无尽挖宝石发现没获得宝石BUG,修复红宝石没生效世界经验加成BUG,修复直播人数越来越少，优化存档内存老玩家点一下保存在点一下加载会流畅很多，降低货币兑换。</p>
           <p>2025/12/22:增加无尽挖矿：开启条件1500转(升级一下稿子等级不然挖不到普通矿)，提升大量世界地图经验，和各项属性，对应称号。</p>
           <p>2025/12/21:修改疯狂地主（新版农田）：开启条件，打怪模式第三层以上开启，增加疯狂地主对应称号。</p>
            <p>2025/12/20:增加疯狂地主（新版农田）：提升大量点击和每秒GPS，十分钟刷新一次。</p>
            <p>2025/12/19:停车场加入批量分解，降低职业转生要求。加入秘境：2000转开启（秘境钥匙，藏宝图打怪掉落）。</p>
           <p>2025/11/06:修改星域获得，现在掉落是发票，增加新轮回副本，掉落符文强化材料，增加娱乐水果机：货币为星辰发票。</p>
           <p>2025/11/05:神器，翅膀，坐骑，增加锁定。</p>
           <p>2025/11/01:增加符文系统：5个属性有增加世界地图经验词条。</p>
           <p>2025/10/30 :增加跑商系统：1000转开启，可以获取大量星币，隐藏游戏日志自动购买宝箱信息</p>
           <p>2025/10/27 :增加坐骑9品质提升大量属性，次元3以上掉落，分解可以获得星币。增加圣兽岛副本2轮回才能进入（掉落升级坐骑材料），世界地图次元调整：降低星币消耗，VIP增加10倍经验效果。</p>
          <p>2025/10/26 : 增加黑龙潭副本1轮回才能进入（掉落升级翅膀材料）。修改职业更换消耗职业转换书，职业增加：二转有分支→三转→四转（通天塔层数解锁职业专职）。（藏宝图打怪掉落或者商店兑换）。世界地图次元修改（轮回解锁次元难度），次元2以上低概率掉落翅膀，增加轮回：每飞升10次→轮回1转。降低世界地图和通天塔复活次数改为3次。打怪模式1000关修改成5000关，通天塔10W层修改50W层，藏宝图打怪掉落增加：副本令牌和职业转换书（商店也可以购买）。修改伴侣洗练：现在是全词条洗练，每锁定1个消耗加2材料。</p>
             <p>2025/10/23 : 由于数值过大导致游戏暴毙，削弱数值。</p>
             <p>2025/10/10 : 修复卡顿（点设置 点保存游戏（多点几次）在点加载游戏，就不卡了（如果还卡就刷新页面。））</p>
             <p>2025/10/09 : 世界地图增加难度次元，切换次元可以多倍经验，会掉落一些道具。通天塔怪物复活次数20次修改为5次</p>
           <p>2025/10/08 : 玩家等级增加飞升，每100级可以飞升一次(飞升后等级变为1级）属性翻倍，世界地图100转修改50转开启。鱼类分解增加获得种子几率。</p>
           <p>2025/10/07 : 修复星域探险任务进行中点开宗门导致星域不更新任务时间奖励</p>
           <p>2025/10/04 : 修复传统彩票不显示开奖结果。另外增加奖励！传统彩票奖励不再是转生币改为星尘发票（开奖后想看结果可以随便购买下面普通2个彩票中的一个刷新开奖结果界面）</p>
           <p>2025/10/03 :修改伴侣进阶要求：对应的伴侣灵魂获得。分解伴侣可以获得对应的伴侣灵魂（宝图小概率获得天使恶魔精灵），伴侣界面增加伴侣商店。宝图购买次数增加10-50次，开启也增加次数。宝图提高品质奖励：增加宝图2合1合成。修改农田浇水，每次浇水消耗30VIP能力值，可以加速成熟3分钟。</p>
           <p>2025/10/02 :神器界面加入筛选，想看什么筛选什么，神器锻造次数增加10-100次，建议不要太多分解再点。</p>
           <p>2025/10/01 :增加星域探索材料兑换转存档的时候可以用，伴侣宝箱开启次数增加10-50次，自动购买宝箱里面增加功法秘籍价格上限自己设置价格(输入10000或者1E4这样都可以)自动购买超出会停止购买转生后会自动开启，增加农场在线自动种植和收货。</p>
           <p>2025/9/30 : 修复宗门BUG</p>
           <p>2025/9/20 : 增加宗门，提升功法秘笈大量加成，忠诚度影响获得任务收益，大于忠诚50加低于减。宗门令牌：宝藏金币兑换，香囊：宝图打怪掉落</p>
           <p>2025/9/16 : 增加TXT导入存档，增加藏宝图商店，宝藏金币：宝图怪物掉落</p>
            <p>2025/9/14 : 优化扫荡严重卡顿，修复杂货铺兑换异常只能兑换1个的BUG</p>
            <p>2025/9/12 : 直播：盲盒出的礼物不加玫瑰花，只加粉丝数量，更新加了新3个宝箱9装备20成就3宠物3称号。</p>
            <p>2025/9/11 : 修复农田和离线时间异常显示，  增加直播：500转开启，每级增加点击伤害，粉丝数增加GPS加成，流量是获得多倍经验（每次进游戏建议结束直播在重新开播，不这样可能没礼物）（第一次加载记得刷新一下页面，第一次直播经验显示异常，刷新后正常）</p>
            <p>2025/9/10 : 玩家等级：50转开启，每一级增加10倍效果。世界地图：100转开启：打怪经验可以给玩家升级每次生成怪物消耗1星币（后续会加掉落材料）（如果属性显示低打一下打怪模式）</p>
            <p>2025/9/9 : 夜店：600转开启，生产星币，获得的星币可以兑换藏宝图或者升级（后续会加入更多东西兑换）已修复</p>
            <p>2025/9/8 : 通天塔失败不会关闭自动攻击</p>
            <p>2025/9/7 : 减少宝图兑换数量，神器增加进阶，消耗进阶神石：宝图掉落。（如果打怪模式显示血负了，脱一件神器在穿上就可以了）</p>

        </div>
    </div>
    </div>
</div>

<!-- ========== 顶栏 (与 1.html 一致) ========== -->
<div class="game-topbar">
  <button class="sidebar-toggle" onclick="document.querySelector('.game-sidebar').classList.toggle('open')">&#9776;</button>
  <div class="topbar-brand">金币冒险者</div>
  <div class="topbar-player">
    <img id="playerAvatar" class="player-avatar" src="" alt="" style="display: none;">
    <span class="player-name-display" id="playerName">勇者</span>
    <span class="player-class-display" id="playerClassName"></span>
    <span class="player-title-display" id="currentTitle"></span>
    <span id="ascentionCountqa" style="color: var(--color-success); font-size: var(--text-xs);">0</span>
    <span id="ascentionCountq" style="color: var(--color-success); font-size: var(--text-xs);">0</span>
    <span id="playerLevelDisplay" style="color: var(--color-success); font-size: var(--text-xs);">Lv.1</span>
  </div>
  <div class="topbar-vip">
    <span class="vip-badge">VIP <span id="vipLevel">1</span></span>
    <div class="vip-bar-wrapper"><div class="vip-bar-fill" id="vipProgressBar" style="width:0%"></div></div>
    <span style="font-size:11px;color:var(--color-text-muted)"><span id="vipProgressText">0/1</span></span>
  </div>
  <div class="topbar-actions">
    <button class="topbar-btn" onclick="useAllVipPower()" title="使用VIP能力值">&#9733;<span id="vipPowerCount" style="font-size:10px;margin-left:2px">0</span></button>
    <button class="topbar-btn" style="width:auto;padding:0 10px;font-size:var(--text-xs);font-weight:600" onclick="var p=document.getElementById('changelogPanel'); var o=document.getElementById('changelogOverlay'); if(p.style.display==='block'){ p.style.display='none'; o.classList.remove('show'); }else{ p.style.display='block'; o.classList.add('show'); }" title="更新日志">更新日志</button>
    <button class="topbar-btn" style="width:auto;padding:0 10px;font-size:var(--text-xs);font-weight:600" onclick="var p=document.getElementById('gameLogPage5'); var o=document.getElementById('guideOverlay'); if(p.style.display==='block'){ p.style.display='none'; o.classList.remove('show'); }else{ p.style.display='block'; o.classList.add('show'); }" title="新手必看">新手必看</button>
    <button class="topbar-btn" style="width:auto;padding:0 10px;font-size:var(--text-xs);font-weight:600" onclick="toggleSettingsUI()" title="设置">设置</button>
  </div>
</div>

<!-- ========== 侧边栏 (与 1.html 一致) ========== -->
<nav class="game-sidebar" id="gameSidebar">
  <div class="sidebar-group collapsed">
    <div class="sidebar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">基础操作 <span class="arrow">&#9660;</span></div>
    <div class="sidebar-group-items">
      <button class="sidebar-item" onclick="clickGold()"><span class="sidebar-icon">&#128176;</span> 点金</button>
      <button class="sidebar-item" onclick="reincarnate()"><span class="sidebar-icon">&#128260;</span> 转生</button>
      <button class="sidebar-item" onclick="toggleShopUI()"><span class="sidebar-icon">&#128230;</span> 宝箱商店</button>
      <button class="sidebar-item" onclick="toggleMonsterUI()"><span class="sidebar-icon">&#9876;</span> 打怪模式 <span class="sidebar-lock">1转</span></button>             
      <button class="sidebar-item" onclick="toggleExchangeShop()"><span class="sidebar-icon">&#127979;</span> 发票商店<span class="sidebar-lock">300转</span></button>     
      <button class="sidebar-item" onclick="toggleGroceriesUI()"><span class="sidebar-icon">&#127978;</span> 杂货铺<span class="sidebar-lock">400转</span></button>
      <button class="sidebar-item" onclick="openTreasureShop()"><span class="sidebar-icon">&#127977;</span> 藏宝图商店<span class="sidebar-lock">600转</span></button>
    </div>
  </div>
<div class="sidebar-group collapsed">
    <div class="sidebar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">修炼系统 <span class="arrow">&#9660;</span></div>
    <div class="sidebar-group-items">      
       <button class="sidebar-item" onclick="showTitleDialog()"><span class="sidebar-icon">&#127942;</span> 称号 <span class="sidebar-lock">10转</span></button>
       <button class="sidebar-item" onclick="toggleOfficialSystem()"><span class="sidebar-icon">&#128081;</span> 官职 <span class="sidebar-lock">10转</span></button>
       <button class="sidebar-item" onclick="toggleClassSystem()"><span class="sidebar-icon">&#9878;</span> 职业 <span class="sidebar-lock">20转</span></button>
       <button class="sidebar-item" onclick="openCompanionSystem()"><span class="sidebar-icon">&#128149;</span> 伴侣 <span class="sidebar-lock">30转</span></button>
       <button class="sidebar-item" onclick="toggleLevelSystem()"><span class="sidebar-icon">&#11088;</span> 等级<span class="sidebar-lock">50转</span></button>
        <button class="sidebar-item" onclick="togglePixelPlayerUI()"><span class="sidebar-icon">&#11093;</span> 抽象时装<span class="sidebar-lock">100转</span></button>
        <button class="sidebar-item" onclick="toggleMysterySystem()"><span class="sidebar-icon">&#128302;</span> 奥秘 <span class="sidebar-lock">100转</span></button>
       <button class="sidebar-item" onclick="toggleCultivationSystem()"><span class="sidebar-icon">&#9775;</span> 修仙 <span class="sidebar-lock">500转</span></button>
      <button class="sidebar-item" onclick="toggleArtifactSystem()"><span class="sidebar-icon">&#128481;</span> 神器 <span class="sidebar-lock">500转</span></button>
     <button class="sidebar-item" onclick="toggleGemSystem()"><span class="sidebar-icon">&#128142;</span> 宝石 <span class="sidebar-lock">800转</span></button>
      <button class="sidebar-item" onclick="toggleSectSystem()"><span class="sidebar-icon">&#9961;</span> 宗门 <span class="sidebar-lock">1000转</span></button>      
    </div>
  </div>
  <div class="sidebar-group collapsed">
    <div class="sidebar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">战斗系统 <span class="arrow">&#9660;</span></div>
    <div class="sidebar-group-items">
      <button class="sidebar-item" onclick="toggleMonsterUI()"><span class="sidebar-icon">&#9876;</span> 打怪模式 <span class="sidebar-lock">1转</span></button>
      <button class="sidebar-item" onclick="toggleWorldMap()"><span class="sidebar-icon">&#127758;</span> 世界地图 <span class="sidebar-lock">50转</span></button>
      <button class="sidebar-item" onclick="toggleWorldBossUI()"><span class="sidebar-icon">&#128121;</span> 世界BOSS <span class="sidebar-lock">50转</span></button>
      <button class="sidebar-item" onclick="toggleTowerUI()"><span class="sidebar-icon">&#127960;</span> 通天塔 <span class="sidebar-lock">100转</span></button>
      <button class="sidebar-item" onclick="toggleAutoBuyShopa()"><span class="sidebar-icon">&#128128;</span> 轮回副本<span class="sidebar-lock">轮回1转</span></button>
     <button class="sidebar-item" onclick="toggleAutoBuyShopb()"><span class="sidebar-icon">&#9775;</span> 修仙副本 <span class="sidebar-lock">修仙2级</span></button>      
    </div>
  </div>
  <div class="sidebar-group collapsed">
    <div class="sidebar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">经济系统 <span class="arrow">&#9660;</span></div>
    <div class="sidebar-group-items">
       <button class="sidebar-item" onclick="toggleLandlordGame()"><span class="sidebar-icon">&#127183;</span> 疯狂地主<span class="sidebar-lock">第3关</span></button>      
      <button class="sidebar-item" onclick="toggleInvestmentGame()"><span class="sidebar-icon">&#128200;</span> 模拟投资<span class="sidebar-lock">第3关</span></button>      
      <button class="sidebar-item" onclick="toggleNightClubSystem()"><span class="sidebar-icon">&#127863;</span> 夜店 <span class="sidebar-lock">600转</span></button>
      <button class="sidebar-item" onclick="toggleTradingSystem()"><span class="sidebar-icon">&#128666;</span> 跑商 <span class="sidebar-lock">1000转</span></button>
      <button class="sidebar-item" onclick="toggleGambleStone()"><span class="sidebar-icon">&#128142;</span> 赌石<span class="sidebar-lock">5000资产</span></button>
      <button class="sidebar-item" onclick="toggleFundSystem()"><span class="sidebar-icon">&#128181;</span> 基金<span class="sidebar-lock">高风险</span></button>
      <button class="sidebar-item" onclick="toggleSlotMachine()"><span class="sidebar-icon">&#127920;</span> 老虎机<span class="sidebar-lock">高风险</span></button>      
    </div>
  </div>
  <div class="sidebar-group collapsed">
    <div class="sidebar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">生活系统 <span class="arrow">&#9660;</span></div>
    <div class="sidebar-group-items">

      <button class="sidebar-item" onclick="toggleFishingSystem()"><span class="sidebar-icon">&#127907;</span> 钓鱼 <span class="sidebar-lock">20转</span></button>
      <button class="sidebar-item" onclick="toggleFarmSystem()"><span class="sidebar-icon">&#127793;</span> 农场 <span class="sidebar-lock">50转</span></button>
      <button class="sidebar-item" onclick="toggleParkingSystem()"><span class="sidebar-icon">&#128663;</span> 停车场 <span class="sidebar-lock">200转</span></button>
      <button class="sidebar-item" onclick="toggleHouseSystem()"><span class="sidebar-icon">&#127968;</span> 房屋 <span class="sidebar-lock">200转</span></button>
      <button class="sidebar-item" onclick="toggleLiveStreamSystem()"><span class="sidebar-icon">&#127909;</span> 直播 <span class="sidebar-lock">500转</span></button>
      <button class="sidebar-item" onclick="toggleMarriageSystem()"><span class="sidebar-icon">&#128141;</span> 结婚<span class="sidebar-lock">5W资产</span></button>      
    </div>
  </div>  
  <div class="sidebar-group collapsed">
    <div class="sidebar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">冒险探索 <span class="arrow">&#9660;</span></div>
    <div class="sidebar-group-items">
       <button class="sidebar-item" onclick="toggleExpeditionSystem()"><span class="sidebar-icon">&#128611;</span> 伴侣探险 <span class="sidebar-lock">30转</span></button>
      <button class="sidebar-item" onclick="toggleExplorationSystem()"><span class="sidebar-icon">&#128640;</span> 星域探索 <span class="sidebar-lock">300转</span></button>
      <button class="sidebar-item" onclick="toggleTreasureMapSystem()"><span class="sidebar-icon">&#128506;</span> 藏宝图 <span class="sidebar-lock">600转</span></button>
      <button class="sidebar-item" onclick="toggleMiningUI()"><span class="sidebar-icon">&#9935;</span> 挖矿 <span class="sidebar-lock">1500转</span></button>      
      <button class="sidebar-item" onclick="toggleTimeSecretRealm()"><span class="sidebar-icon">&#9202;</span> 时光秘境 <span class="sidebar-lock">2000转</span></button>
      <button class="sidebar-item" onclick="toggleAbyssTower()"><span class="sidebar-icon">&#128301;</span> 无限深渊<span class="sidebar-lock">2500转</span></button>
    </div>
  </div>
  <div class="sidebar-group collapsed">
    <div class="sidebar-group-title" onclick="this.parentElement.classList.toggle('collapsed')">自动设置 <span class="arrow">&#9660;</span></div>
    <div class="sidebar-group-items">
      <button class="sidebar-item" onclick="toggleAutoBuyShop()"><span class="sidebar-icon">&#128722;</span> 在线自动购买</button>
      <button class="sidebar-item" onclick="toggleAutoConvertUI()"><span class="sidebar-icon">&#128257;</span> 在线自动兑换</button>
      <button class="sidebar-item" onclick="toggleAutoBuySettings()"><span class="sidebar-icon">&#128203;</span> 功法价格设置</button>
      <button class="sidebar-item" onclick="toggleAutoBuySpeedBoost()"><span class="sidebar-icon">&#9889;</span> 在线百倍购买 <span class="sidebar-lock" id="autoBuySpeedLabel">关</span></button>
      <button class="sidebar-item" onclick="toggleOnlineBoost()"><span class="sidebar-icon">&#128293;</span> 在线百倍加速 <span class="sidebar-lock" id="onlineBoostLabel">关</span></button>
      <button class="sidebar-item" onclick="toggleAutoReincarnation()"><span class="sidebar-icon">&#9203;</span> 自动转生 <span class="sidebar-lock" id="autoReincarnationStatus">关</span></button>
      
    </div>
  </div>
</nav>

<!-- ========== 主内容区 (与 1.html 一致) ========== -->
<div class="game-main">

  <!-- 货币栏 -->
  <div class="card" style="margin-bottom: var(--space-md);">
    <div class="currency-grid">
      <div class="currency-card"><span class="currency-label">金币</span><span class="currency-value" id="gold">0</span></div>
      <div class="currency-card"><span class="currency-label">钻石</span><span class="currency-value" id="diamond">0</span></div>
      <div class="currency-card"><span class="currency-label">钛晶石</span><span class="currency-value" id="titanium">0</span></div>
      <div class="currency-card"><span class="currency-label">星耀石</span><span class="currency-value" id="starstone">0</span></div>
      <div class="currency-card"><span class="currency-label">宇宙石</span><span class="currency-value" id="cosmicstone">0</span></div>
      <div class="currency-card"><span class="currency-label">超能石</span><span class="currency-value" id="superstone">0</span></div>
      <div class="currency-card"><span class="currency-label">异界石</span><span class="currency-value" id="otherworldstone">0</span></div>
      <div class="currency-card"><span class="currency-label">星界石</span><span class="currency-value" id="xingjiestone">0</span></div>
      <div class="currency-card"><span class="currency-label">混沌石</span><span class="currency-value" id="hundunstone">0</span></div>
      <div class="currency-card"><span class="currency-label">灵髓石</span><span class="currency-value" id="lingtone">0</span></div>
      <div class="currency-card"><span class="currency-label">幻空石</span><span class="currency-value" id="huangtone">0</span></div>
      <div class="currency-card"><span class="currency-label">冥源石</span><span class="currency-value" id="mingtone">0</span></div>
      <div class="currency-card"><span class="currency-label">虚空石</span><span class="currency-value" id="xutong">0</span></div>
      <div class="currency-card"><span class="currency-label">时空石</span><span class="currency-value" id="shitone">0</span></div>
      <div class="currency-card"><span class="currency-label">未来石</span><span class="currency-value" id="weitone">0</span></div>
      <div class="currency-card" style="border-color: var(--color-gold);"><span class="currency-label" style="color:var(--color-gold)">转生币</span><span class="currency-value" id="reincarnationCoin" style="color:var(--color-gold)">0</span></div>
    </div>
  </div>

  <!-- 状态数据条 -->
  <div class="card" style="margin-bottom: var(--space-md); padding: var(--space-sm) var(--space-md);">
    <div style="display: flex; flex-wrap: wrap; gap: var(--space-md) var(--space-xl); font-size: var(--text-sm); color: var(--color-text-secondary);">
      <span>GPS <b style="color:var(--color-text)" id="gps">1</b>/秒</span>
      <span>点击 <b style="color:var(--color-text)" id="clickValue">1</b></span>
      <span>资金 <b style="color:var(--color-text)" id="zijze">1</b></span>
      <span>转生 <b style="color:var(--color-primary)" id="reincarnationCount">0</b> 次</span>
      <span>关卡 <b style="color:var(--color-text)" id="maxStage">0</b></span>
      <span>塔层 <b style="color:var(--color-text)" id="towerFloor">0</b></span>
      <span>官职 <b style="color:var(--color-text)" id="currentOfficialTitle">无</b></span>
      <span>奥秘 <b style="color:var(--color-info)" id="currentMysteryTitle">初级秘法师 1阶1级</b></span>
      <span>境界 <b style="color:var(--color-success)" id="currentStageq">凡人</b></span>
      <span id="sectNameDisplay" style="color: var(--color-gold); font-weight: 700;"></span>
    </div>
   </div>




  <!-- 标签页 -->
  <div class="card" style="margin-bottom: var(--space-md); padding: 0; overflow: hidden;">
    <div class="tabs-new">
      <div class="tab tab-item-new active" onclick="switchTab('equipment')">装备</div>
      <div class="tab tab-item-new" onclick="switchTab('items')">道具</div>
      <div class="tab tab-item-new" onclick="switchTab('collections')">收藏物</div>
      <div class="tab tab-item-new" onclick="switchTab('reincarnation')">转生属性</div>
      <div class="tab tab-item-new" onclick="switchTab('pets')">宠物</div>
      <div class="tab tab-item-new" onclick="switchTab('stocks')">股票</div>
      <div class="tab tab-item-new" onclick="switchTab('lottery')">彩票</div>
      <div class="tab tab-item-new" onclick="switchTab('bank')">银行系统</div>
      <div class="tab tab-item-new" onclick="switchTab('dungeonEquipment')">副本装备</div>
      <div class="tab tab-item-new" onclick="switchTab('soulRings')">魂环</div>
      <div class="tab tab-item-new" onclick="switchTab('playerAttributes')">玩家属性</div>
      <div class="tab tab-item-new" onclick="switchTab('techniques')">功法秘籍</div>
    </div>
    <div style="padding: var(--space-md);">

    <h3></h3>
    <div id="equipmentList"></div>
    <h3></h3>
    <div id="itemList" style="display: none;">
    <h3></h3>
    <button onclick="resetItemDisplay()">重置道具页面</button> <!-- 新增按钮 -->
    
    <div id="itemContainer"></div> <!-- 用于显示道具信息的容器 -->
</div>
    <div id="collectionList" style="display: none;">
    <button onclick="resetAllCollectionEffects()">重新计算收藏物效果</button>
    <div id="collectionInfoContainer" style="margin-top: 10px;"></div>
</div>
    <h3></h3>
    <div id="reincarnationList" style="display: none;"></div>
    <h3></h3>
    <div id="petList" style="display: none;">
    <h3></h3>
    <button onclick="resetPetDisplay()">重置宠物页面</button> <!-- 新增按钮 -->
    <div id="petContainer"></div> <!-- 用于显示宠物信息的容器 -->
</div>
    <div id="stockList" style="display: none;">
        <h3>股票市场（每10分钟波动一次）</h3>
        <div id="stocksContainer"></div>
        <div class="stock-control">
            <input type="number" id="stockAmount" placeholder="数量" min="1">
            <button onclick="buyStock()">买入选中股</button>
            <button onclick="sellStock()">卖出选中股</button>
            <button onclick="buyAllStock()">买入选中所有股</button>
            <button onclick="sellAllStock()">卖出选中所有股</button>
        </div>
    </div>
    <h3></h3>
    <div id="lotteryList" style="display: none;">
        <h3></h3>
        <div>
            <h4>传统数字彩票（购买刮刮卡刷新开奖结果）</h4>
            <p>每30分钟开奖，1-50数字中6个100万，中5个10万，中4个1万，中3个1000，中2个100，中1个10（中奖奖励星尘发票）。记得来一注！</p>
            <button onclick="buyTraditionalLottery()">购买传统数字彩票（10转生币）</button>
            <div id="traditionalLotteryNumbers"></div>
            <div id="traditionalLotteryCountdown" class="lottery-countdown">下次开奖: --:--:--</div>
        </div>
        <div>
            <h4>蛇年刮刮卡（购买后刷新开奖结果）</h4>
            <p>60%谢谢惠顾0转生币，35%鼓励奖获得10-100转生币，三等奖3.9%获得100-500，二等奖1%获得500-2000，一等奖0.1%获得2000-10000。</p>
            <button onclick="buySnakeScratchCard()">购买蛇年刮刮卡（50转生币）</button>
        </div>
        <div>
            <h4>发财刮刮卡（购买后刷新开奖结果）</h4>
            <p>60%谢谢惠顾0转生币，35%鼓励奖获得100-1000转生币，三等奖3.9%获得1000-5000，二等奖1%获得5000-20000，一等奖0.1%获得20000-100000。</p>
            <button onclick="buyFortuneScratchCard()">购买发财刮刮卡（500转生币）</button>
        </div>
    </div>

    <!-- 新增银行系统 -->
    <div id="bankList" style="display: none;">
        <h3>银行系统</h3>
        <div>
            <p>当前存款: <span id="bankDeposit">0</span> 转生币</p>
            <p>利息: <span id="bankInterest">0.2%</span> 每6分钟</p>
            <p>总金额: <span id="bankTotal">0</span> 转生币</p>
            <input type="number" id="bankAmount" placeholder="存款金额" min="1">
            <button onclick="depositToBank()">存款</button>
            <button onclick="withdrawFromBank()">取款</button>
            <button onclick="depositAllToBank()">存款所有</button>
            <button onclick="withdrawAllFromBank()">取款所有</button>
        </div>
    </div>

    <!-- 新增副本装备系统 -->
    <div id="dungeonEquipmentList" style="display: none;">
        <h3></h3>
        <div id="dungeonEquipmentContainer"></div>
    </div>

    <!-- 新增魂环系统 -->
    <div id="soulRingList" style="display: none;">
        <h3></h3>
        <div id="soulRingsContainer"></div>
    </div>

        <!-- 玩家属性页面 -->
<div id="playerAttributesList" style="display: none;">
    <h3>玩家属性</h3>
    <div>总属性点: <span id="totalAttributePoints">0</span></div>
    <div>剩余属性点: <span id="remainingAttributePoints">0</span></div>
    <div>
        <strong>生命加成</strong>: 每2点属性点增加2%生命 
        (当前加成: <span id="healthBonus">0%</span>, 已投入: <span id="healthPoints">0</span>)
        <button onclick="addAttributePoint('health', 1)">+1</button>
        <button onclick="addAttributePoint('health', 10)">+10</button>
        <button onclick="addAttributePoint('health', 100)">+100</button>
        <button onclick="addAttributePoint('health', 1000)">+1000</button>
        <button onclick="addAttributePoint('health', 'all')">+全部</button>
    </div>
    <div>
        <strong>攻击加成</strong>: 每2点属性点增加2%攻击 
        (当前加成: <span id="attackBonus">0%</span>, 已投入: <span id="attackPoints">0</span>)
        <button onclick="addAttributePoint('attack', 1)">+1</button>
        <button onclick="addAttributePoint('attack', 10)">+10</button>
        <button onclick="addAttributePoint('attack', 100)">+100</button>
        <button onclick="addAttributePoint('attack', 1000)">+1000</button>
        <button onclick="addAttributePoint('attack', 'all')">+全部</button>
    </div>
    <div>
        <strong>暴击率加成</strong>: 每2点属性点增加0.1%暴击率 
        (当前加成: <span id="critRateBonus">0%</span>, 已投入: <span id="critRatePoints">0</span>)
        <button onclick="addAttributePoint('critRate', 1)">+1</button>
        <button onclick="addAttributePoint('critRate', 10)">+10</button>
        <button onclick="addAttributePoint('critRate', 100)">+100</button>
        <button onclick="addAttributePoint('critRate', 1000)">+1000</button>
        <button onclick="addAttributePoint('critRate', 'all')">+全部</button>
    </div>
    <div>
        <strong>爆伤加成</strong>: 每2点属性点增加1%爆伤 
        (当前加成: <span id="critDamageBonus">0%</span>, 已投入: <span id="critDamagePoints">0</span>)
        <button onclick="addAttributePoint('critDamage', 1)">+1</button>
        <button onclick="addAttributePoint('critDamage', 10)">+10</button>
        <button onclick="addAttributePoint('critDamage', 100)">+100</button>
        <button onclick="addAttributePoint('critDamage', 1000)">+1000</button>
        <button onclick="addAttributePoint('critDamage', 'all')">+全部</button>
    </div>
    <div>
        <strong>连击</strong>: 每300点属性点增加1次攻击 
        (当前加成: <span id="multiAttackBonus">0</span>, 已投入: <span id="multiAttackPoints">0</span>)
        <button onclick="addAttributePoint('multiAttack', 1)">+1</button>
        <button onclick="addAttributePoint('multiAttack', 10)">+10</button>
        <button onclick="addAttributePoint('multiAttack', 100)">+100</button>
        <button onclick="addAttributePoint('multiAttack', 1000)">+1000</button>
        <button onclick="addAttributePoint('multiAttack', 'all')">+全部</button>
    </div>
    <button onclick="resetAttributes()">洗点 (消耗1转生币)</button>
</div>

      <!-- 功法秘籍页面 -->
<div id="techniquesList" style="display: none;" >
    <h3></h3>
    <button onclick="resetTechniquesData()">重置功法页面</button>
    <div id="techniquesContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px;"></div>
 </div>

    </div><!-- 关闭 tab 内容 padding -->
  </div><!-- 关闭 tabs card -->

  <!-- 游戏日志 (与 1 样式一致) -->
  <div class="card game-log-section" style="margin-bottom: var(--space-md);">
    <div class="card-header" style="display:flex; align-items:center; gap:var(--space-sm);">
      游戏日志
      <div style="display:flex; gap:2px; margin-left:auto;">
        <button class="log-tab active" style="padding:4px 8px;font-size:11px;border:1px solid var(--color-border);border-radius:4px;background:transparent;cursor:pointer;" onclick="switchLogTab(1)">记录</button>
        <button class="log-tab" style="padding:4px 8px;font-size:11px;border:1px solid var(--color-border);border-radius:4px;background:transparent;cursor:pointer;" onclick="switchLogTab(2)">公告</button>
        <button class="log-tab" style="padding:4px 8px;font-size:11px;border:1px solid var(--color-border);border-radius:4px;background:transparent;cursor:pointer;" onclick="switchLogTab(3)">开奖</button>
      </div>
    </div>
    <div id="gameLogPage1" class="active">
        <div id="actionLog" class="log log-content"></div>
    </div>
    <div id="gameLogPage2">
        <div class="log log-content"></div>
    </div>
    <div id="gameLogPage3">
        <div id="lotteryResults" class="log log-content"></div>
    </div>
    <div id="gameLogPage4">
        <div id="battleLog" class="log log-content"></div>
    </div>
  </div>

  <!-- 成就系统 -->
  <div class="card" style="margin-bottom: var(--space-md);">
    <div class="card-header">成就系统</div>
    <div id="achievements" style="max-height: 200px; overflow-y: auto;"></div>
  </div>

  <div id="footer">版本号: v1.8.95</div>
</div><!-- 关闭 game-main -->

    <!-- 自定义对话框 -->
    <div id="customDialog">
        <div id="dialogMessage"></div>
        <textarea id="dialogInput" style="width: 100%; height: 100px; margin-bottom: 10px;"></textarea>
        <button id="dialogConfirm">确定</button>
        <button id="dialogCancel">取消</button>
    </div>
    <div id="dialogOverlay"></div>

 <div id="gemUseDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 1px solid #ccc; z-index: 1001; text-align: center;">
    <div id="gemUseMessage"></div>
    <div style="margin: 15px 0;">
        <button id="gemUseConfirm" style="padding: 8px 15px; margin-right: 10px;">确认使用</button>
        <button id="gemUseCancel" style="padding: 8px 15px;">取消</button>
    </div>
</div>
<div id="gemUseOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
  <div id="renameDialog" class="settings-subdialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 28px 36px; border: 1px solid #ccc; border-radius: 10px; z-index: 1001; min-width: 380px; box-shadow: 0 8px 24px rgba(0,0,0,0.15);">
    <div id="renameDialogTitle" style="font-size: 18px; margin-bottom: 14px;">输入新名字:</div>
    <input type="text" id="newNameInput" style="margin: 12px 0; padding: 10px 14px; font-size: 16px; width: 100%; max-width: 320px; box-sizing: border-box;" maxlength="10">
    <div style="margin-top: 18px;">
        <button onclick="confirmRename()" style="padding: 10px 24px; font-size: 15px; margin-right: 10px;">确定</button>
        <button onclick="cancelRename()" style="padding: 10px 24px; font-size: 15px;">取消</button>
    </div>
</div>
<div id="classSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>

<div id="classSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 2px solid #333; z-index: 1000; max-width: 90%; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; text-align: center;">职业系统</h3>
    
    <div style="margin-bottom: 15px;">
        当前职业: <span id="currentClassName">无</span>
    </div>
    
    <div id="classSelection" style="margin: 15px 0; display: flex; gap: 10px; justify-content: center;">
        <button onclick="selectClass('warrior')">战士</button>
        <button onclick="selectClass('mage')">法师</button>
        <button onclick="selectClass('explorer')">探险家</button>
        <button onclick="toggleClassSystem()">关闭页面</button>
    </div>
    
    <div id="classChangeCost" style="color: red; margin: 10px 0; text-align: center; font-size: 0.9em;">
        更换职业将消耗1本职业转换书，所有职业加成将重置
    </div>
    
    <div id="classBranches" style="display: none; margin: 15px 0; padding: 10px; border-top: 1px dashed #333;max-height: 380px; overflow-y: auto">
        <h4 style="margin-top: 0;">职业分支加点</h4>
        <div id="branchPointsContainer"></div>

    </div>
</div>
<div id="renameOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>

<!-- 版本不匹配提示弹窗 -->
<div id="versionErrorDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 32px 40px; border: 3px solid #ff4444; z-index: 10000; min-width: 400px; max-width: 500px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
    <div style="font-size: 24px; font-weight: bold; color: #ff4444; margin-bottom: 16px;">⚠️ 版本不匹配</div>
    <div id="versionErrorMessage" style="font-size: 16px; line-height: 1.6; margin-bottom: 24px; color: #333;"></div>
    <div style="font-size: 14px; color: #666; margin-bottom: 20px;">请使用新版本游戏进行游玩。您的存档已保留在本地，不会丢失。更新到新版本后请手动刷新浏览器页面。</div>
    <button type="button" onclick="document.getElementById('versionErrorDialog').style.display='none'; document.getElementById('versionErrorOverlay').style.display='none';" style="padding: 12px 32px; font-size: 16px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">确定</button>
</div>
<div id="versionErrorOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999;"></div>

 <div id="activationCodeDialog" class="settings-subdialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 28px 36px; border: 2px solid #333; border-radius: 10px; z-index: 1001; min-width: 400px; box-shadow: 0 8px 24px rgba(0,0,0,0.15);">
    <h3 style="font-size: 20px; margin: 0 0 18px 0;">激活码兑换</h3>
    <input type="text" id="activationCodeInput" placeholder="请输入激活码" style="width: 100%; max-width: 360px; padding: 12px 14px; font-size: 16px; margin: 12px 0; box-sizing: border-box;">
    <div style="margin-top: 18px;">
        <button onclick="confirmActivationCode()" style="padding: 10px 24px; font-size: 15px; margin-right: 10px;">确认兑换</button>
        <button onclick="cancelActivationCode()" style="padding: 10px 24px; font-size: 15px;">取消</button>
    </div>
</div>
<div id="activationCodeOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>

    <!-- 新增打怪模式UI -->
    <div id="monsterUI" style="display: none;">
    <button onclick="toggleMonsterUI()" style="position: absolute; top: 5px; right: 200px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 25px; height: 25px; cursor: pointer;">×</button>
        <h3>打怪模式</h3>
        <div class="player-info">
            <p>生命: <span id="playerHealth">0</span></p>
            <p>攻击: <span id="playerAttack">0</span></p>
            <p>暴击率: <span id="playerCritRate">0%</span></p>
            <p>爆伤: <span id="playerCritDamage">0%</span></p>
            <p>命中: <span id="playerAccuracy">0%</span></p>
            <p>闪避: <span id="playerDodge">0%</span></p>
        </div>
        <div class="monster-info">
            <p>当前关卡: <span id="currentStage">0</span></p>
            <p>怪物名称: <span id="monsterName">无</span></p>
            <p>怪物品阶: <span id="monsterRank">无</span></p>
            <p>怪物生命: <span id="monsterHealth">0</span></p>
            <p>怪物攻击: <span id="monsterAttack">0</span></p>
            <p>怪物词条: <span id="monsterModifiers">无</span></p>
        </div>
        <div class="battle-controls">
            <button onclick="attackMonster()">攻击</button>
            <button onclick="fleeFromBattle()">逃跑</button>
            <button onclick="toggleAutoSweep()">自动扫荡: <span id="autoSweepStatus">关</span></button>
            <input type="number" id="jumpStage" placeholder="第一次打点逃跑" min="1">
            <button onclick="jumpToStage()">必看</button>
        </div>
        <div class="battle-log">
            <h4>战斗记录</h4>
            <div id="battleLogContent"></div>
        </div>
    </div>

<!-- 称号系统弹窗 -->
<div id="titleDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1001; width: 80%; max-width: 800px; max-height: 80vh; overflow-y: auto;">
    <h3>称号系统</h3>
    <div id="titleBranches">
        <!-- 关卡分支 -->
        <div class="titleBranch">
            <h4>关卡称号</h4>
            <div class="titleRow" id="stageBranchContainer"></div>
        </div>
        <!-- 转生分支 -->
        <div class="titleBranch">
            <h4>转生称号</h4>
            <div class="titleRow" id="reincarnationBranchContainer"></div>
        </div>
        <!-- 驯兽师分支 -->
        <div class="titleBranch">
            <h4>驯兽师称号</h4>
            <div class="titleRow" id="tamerBranchContainer"></div>
        </div>
        <!-- 魂环分支 -->
        <div class="titleBranch">
            <h4>魂环称号</h4>
            <div class="titleRow" id="soulRingBranchContainer"></div>
        </div>
        <!-- 特殊分支 -->
        <div class="titleBranch">
            <h4>特殊称号</h4>
            <div class="titleRow" id="specialBranchContainer"></div>
        </div>
     <!-- 特殊分支 -->
        <div class="titleBranch">
            <h4>普通称号</h4>
            <div class="titleRow" id="towerBranyyContainer"></div>
        </div>
    <!-- 特殊分支 -->
        <div class="titleBranch">
            <h4>通天塔称号</h4>
            <div class="titleRow" id="towerBranchContainer"></div>
        </div>
    </div>
    <button onclick="closeTitleDialog()" style="margin-top: 20px;">关闭</button>
</div>
<div id="titleOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>


<!-- 官职系统界面 -->
<div id="officialSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="officialSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 2px solid #333; z-index: 1001; max-width: 90%; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; text-align: center;">官职系统</h3>
    
    <div style="margin-bottom: 15px;">
        当前官职: <span id="officialTitleDisplay">无</span> (等级 <span id="officialLevelDisplay">0</span>)
    </div>
    <div style="margin-bottom: 15px;">
        当前加成: 攻击总和提升 <span id="officialBonusDisplay">1</span> 倍
    </div>
    
    <div style="margin: 15px 0;">
        <h4>下一阶官职</h4>
        <div id="nextOfficialInfo">请升级官职</div>
    </div>
    
    <div style="margin: 15px 0;">
        <label for="officialUpgradeAmount">升级次数:</label>
        <input type="number" id="officialUpgradeAmount" value="1" min="1" style="width: 60px;">
        <button onclick="upgradeOfficialByAmount()">升级</button>
        <button onclick="upgradeOfficialMaxPossible()">一键升级</button>
    </div>
    
    <div style="margin-top: 20px; text-align: center;">
        <button onclick="toggleOfficialSystem()">关闭</button>
    </div>
</div>

<div id="companionOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;" onclick="closeCompanionSystem()"></div>
<div id="companionSystem" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <!-- 标题栏（包含标题和关闭按钮） -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
        <h2 style="color: #4CAF50; margin: 0;">伴侣系统</h2>
        <button onclick="closeCompanionSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
      <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 伴侣等级与升级 -->
    <div style="margin: 15px 0; padding: 10px; background: #333; border-radius: 5px;">
        <h3>伴侣等级: Lv. <span id="companionLevel">1</span></h3>
        <p>升级消耗: <span id="upgradeCost">10</span> 玫瑰花</p>
        <button onclick="upgradeCompanion()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">升级</button>
      <button onclick="toggleExpeditionSystem()" style="margin-top: 15px; background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">探险</button>
     <button onclick="toggleCompanionShop()" style="margin-top: 15px; background: #7417B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">伴侣商店</button>

</div> 
 
     <div style="flex: 1; min-width: 400px; background: #2a2a2a; padding: 10px; border-radius: 5px;">
        <h3>伴侣属性加成</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 0.9em;">
            <div>品质加成倍数: <span id="qualityMultiplier">1x</span></div>
            <div>攻击总和加成: <span id="attackTotalBonus">1x</span></div>
            <div>生命总和加成: <span id="healthTotalBonus">1x</span></div>
            <div>暴击率总和加成: <span id="critRateTotalBonus">1x</span></div>
            <div>爆伤总和加成: <span id="critDamageTotalBonus">1x</span></div>
            <div>连击总和加成: <span id="comboTotalBonus">0</span></div>
            <div>全属性总和加成: <span id="allStatsTotalBonus">1x</span></div>
</div>
</div>
</div>
    <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 伴侣宝箱 -->
    <div style="flex: 1; padding: 10px; background: #333; border-radius: 5px;">
        <h3>伴侣宝箱</h3>
        <p>当前钥匙: <span id="companionKeyCount">0</span></p>
        <button onclick="drawCompanion()" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启宝箱 (消耗1钥匙)</button>
    <div style="margin-top: 15px;">
    <h4>批量开启</h4>
    <button onclick="drawCompanionMultiple(10)" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启10次</button>
    <button onclick="drawCompanionMultiple(20)" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">开启20次</button>
</div>
     <div style="margin-top: 15px; padding: 10px; background: #333; border-radius: 5px; font-size: 12px;">
        <h4 style="margin-top: 0; font-size: 13px; color: #d4af37;">保底机制</h4>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
            <div>史诗(紫色): <span id="epicGuarantee">0</span>/100</div>
            <div>卓越(粉色): <span id="pinkGuarantee">0</span>/500</div>
            <div>完美(橙色): <span id="orangeGuarantee">0</span>/1000</div>
            <div>神赐(红色): <span id="redGuarantee">0</span>/5000</div>
        </div>
    </div>
    </div>
    
    <!-- 批量分解 -->
    <div style="flex: 1; padding: 10px; background: #333; border-radius: 5px;">
        <h3>批量分解</h3>
        <select id="decomposeRarity" style="padding: 5px; margin-right: 10px;">
            <option value="white">普通(白色)</option>
            <option value="blue">稀有(蓝色)</option>
            <option value="epic">史诗(紫色)</option>
            <option value="pink">卓越(粉色)</option>
            <option value="orange">完美(橙色)</option>
            <option value="red">神赐(红色)</option>
            <option value="angel">天使(彩色)</option>
            <option value="emyyyy">恶魔(深红色)</option>
           <option value="jlyyyy">精灵(绿色)</option>
        </select>
        <button onclick="batchDecompose()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">批量分解选中品阶(未锁定)</button>
<div style="flex: 1; padding: 10px; background: #333; border-radius: 5px; margin-top: 1px;">
    <h3>自动分解设置</h3>
    <select id="autoDecomposeBelowRarity" style="padding: 5px; margin-right: 10px;">
        <option value="white">普通(白色)及以下</option>
        <option value="blue">稀有(蓝色)及以下</option>
        <option value="epic">史诗(紫色)及以下</option>
        <option value="pink">卓越(粉色)及以下</option>
        <option value="orange">完美(橙色)及以下</option>
        <option value="red">神赐(红色)及以下</option>
        <option value="angel">天使(彩色)及以下</option>
        <option value="emyyyy">恶魔(深红色)及以下</option>
        <option value="jlyyyy">精灵(绿色)及以下</option>
    </select>
    <button id="toggleAutoDecompose" onclick="toggleAutoDecompose()" style="background: #ff9800; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">自动分解：关闭</button>
</div>
    </div>
</div>
    
    <!-- 伴侣列表 -->
    <div style="margin: 15px 0;">
        <h3>我的伴侣</h3>
        <div id="companionList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;max-height: 400px; overflow-y: auto;">
            <!-- 伴侣卡片会动态生成在这里 -->
        </div>
    </div>
  </div>  
 
<div id="towerUI" style="display: none; position: fixed; top: 20%; left: 20%; transform: translate(50%, -10%); width: 30%; max-width: 800px; background: #fff; border: 2px solid #333; border-radius: 10px; padding: 20px; z-index: 1000;">
    <!-- 右上角关闭按钮 -->
    <button onclick="toggleTowerUI()" style="position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
    <h3>通天塔</h3>
     <div>GPS加成: <span id="towerBonus">0%</span> (每层增加0.01倍)</div>
    <div class="player-info">
        <p>生命: <span id="towerPlayerHealth">0</span></p>
        <p>攻击: <span id="towerPlayerAttack">0</span></p>
        <p>暴击率: <span id="towerPlayerCritRate">0%</span></p>
        <p>爆伤: <span id="towerPlayerCritDamage">0%</span></p>
        <p>命中: <span id="towerPlayerAccuracy">0%</span></p>
        <p>闪避: <span id="towerPlayerDodge">0%</span></p>
    </div>
    <div class="monster-info">
        <p>当前层数: <span id="towerCurrentFloor">0</span></p>
        <p>怪物名称: <span id="towerMonsterName">无</span></p>
        <p>怪物品阶: <span id="towerMonsterRank">无</span></p>
        <p>怪物生命: <span id="towerMonsterHealth">0</span></p>
        <p>怪物攻击: <span id="towerMonsterAttack">0</span></p>
        <p>怪物词条: <span id="towerMonsterModifiers">无</span></p>
        <p>剩余复活次数: <span id="towerMonsterResurrections">20</span></p>
    </div>
    <div class="battle-controls">
        <button onclick="attackTowerMonster()">攻击</button>
        <button onclick="toggleTowerAutoAttack()">自动攻击: <span id="towerAutoAttackStatus">关</span></button>
    </div><h4>如果属性是初始没加成，打一次打怪模式恢复在重新点击通天塔</h4>
    <div class="battle-log" id="towerBattleLog"></div>
</div>
</div>
</div>


<!-- 奥秘系统界面 -->
<div id="mysterySystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="mysterySystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border: 2px solid #333; z-index: 1001; max-width: 90%; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; text-align: center;">奥秘系统</h3>
    
    <div style="margin-bottom: 15px;">
        当前奥秘: <span id="mysteryTitleDisplay">初级秘法师 1阶1级</span>
    </div>
    <div style="margin-bottom: 15px;">
        当前加成: GPS加成 <span id="mysteryBonusDisplay">1</span> 倍（每一阶生效）
    </div>
    <div style="margin-bottom: 15px;">
        当前经验: <span id="currentMysteryExp">0</span> / <span id="nextMysteryExp">1000</span>
    </div>
    <div style="margin-bottom: 15px;">
        每分钟经验获取: <span id="expPerMinute">0</span> (通天塔层数 × 职业加成 × VIP等级)
    </div>
    
    <div style="margin: 15px 0;">
        <h4>下一等级</h4>
        <div id="nextMysteryInfo">初级秘法师 1阶2级 - 消耗: 1000经验</div>
    </div>
    
    <div style="margin: 15px 0;">
        <label for="mysteryUpgradeAmount">升级次数:</label>
        <input type="number" id="mysteryUpgradeAmount" value="1" min="1" style="width: 60px;">
        <button onclick="upgradeMysteryByAmount()">升级</button>
        <button onclick="upgradeMysteryMaxPossible()">一键升级</button>
    </div>
    
    <div style="margin-top: 20px; text-align: center;">
        <button onclick="toggleMysterySystem()">关闭</button>
    </div>
</div>
<!-- 基金系统界面 -->
<div id="fundSystem" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 800px; background: #fff; border: 2px solid #333; border-radius: 10px; padding: 20px; z-index: 1001;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2>基金系统</h2>
          <h3>投入的越多波动的幅度越大10-50%（按满仓算50%）。1分钟刷新一次 ，10分钟不能实时卖出，最后5分钟不能投入，如果跌到总价值20%以下 就全部没收清零。每次第一次购买净值会归为1，已购买后正常。</h3> <button onclick="resetFundData()" style="padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">重置基金</button>
        <button onclick="toggleFundSystem()" style="padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭</button>
     <button onclick="updateFundDisplay()" style="padding: 5px 10px; margin-right: 10px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">刷新</button>
    </div>
    
    <div style="max-height: 500px; overflow-y: auto; padding-right: 10px;">
        <div id="fundsContainer"></div>
    </div>
    
   <!-- 基金遮罩层 -->
<div id="fundOverlay" style="display: none;"></div>
</div><!-- 基金遮罩层 -->
<!-- 商店界面HTML (添加到body标签内任意位置) -->
<div id="shopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; border-radius: 10px; z-index: 1000; max-width: 500px; max-height: 80vh; overflow-y: auto;">
    <h2>商店</h2>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button onclick="buyChest(1)">普通宝箱（100金币）</button>
        <button onclick="buyChest(2)">高级宝箱（10钻石）</button>
        <button onclick="buyChest(3)">稀有宝箱（1钛晶石）</button>
        <button onclick="buyChest(4)">史诗宝箱（1星耀石）</button>
        <button onclick="buyChest(5)">传说宝箱（1宇宙石）</button>
        <button onclick="buyChest(6)">混沌宝箱（1超能石）</button>
        <button onclick="buyChest(7)">终焉宝箱（1异界石）</button>
        <button onclick="buyChest(8)">星辰宝箱（1星界石）</button>
        <button onclick="buyChest(9)">银河宝箱（1混沌石）</button>
        <button onclick="buyChest(10)">星云宝箱（1灵髓石）</button>
        <button onclick="buyChest(11)">鸿蒙宝箱（1幻空石）</button>
        <button onclick="buyChest(12)">太虚宝箱（1冥源石）</button>
        <button onclick="buyChest(13)">虚空宝箱（1虚空石）</button>
        <button onclick="buyChest(14)">时空宝箱（1时空石）</button>
        <button onclick="buyChest(15)">未来宝箱（1未来石）</button>
     <button onclick="buyMaterialChest()">材料宝箱（<span id="materialChestCost">1</span>钻石）</button>
    <button onclick="buyTechniqueChest()">功法秘籍宝箱（<span id="techniqueChestCost">1</span>转生币）</button>
    </div>
    <button onclick="toggleShopUI()" style="margin-top: 20px; padding: 10px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭商店</button>
</div>
<!-- 半透明背景遮罩 (添加到body标签内) -->
<div id="shopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
<!-- 设置界面对话框 -->
<div id="settingsDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 28px 36px; border: 1px solid #ccc; border-radius: 10px; z-index: 1000; text-align: center; min-width: 420px; box-shadow: 0 8px 24px rgba(0,0,0,0.12);">
    <h3 style="font-size: 22px; margin: 0 0 20px 0;">游戏设置</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 14px;">
        <button onclick="showRenameDialog()" style="padding: 12px 20px; font-size: 16px;">名字修改</button>
        <button onclick="document.getElementById('avatarInput').click()" style="padding: 12px 20px; font-size: 16px;">更改头像</button>
        <button onclick="clearAvatar()" style="padding: 12px 20px; font-size: 16px;">清除头像</button>
        <button onclick="showActivationCodeDialog()" style="padding: 12px 20px; font-size: 16px;">激活码兑换</button>
        <button onclick="saveGame()" style="padding: 12px 20px; font-size: 16px;">保存游戏</button>
        <button onclick="loadGame()" style="padding: 12px 20px; font-size: 16px;">加载游戏</button>
        <button onclick="exportSave()" style="padding: 12px 20px; font-size: 16px;">导出存档（自动复制）</button>        
        <button onclick="importSave()" style="padding: 12px 20px; font-size: 16px;">导入存档</button>
        <button onclick="downloadSave()" style="padding: 12px 20px; font-size: 16px;">下载TXT存档</button>
         <button onclick="importEncryptedSave()" style="padding: 12px 20px; font-size: 16px;">导入TXT存档</button>
        <button onclick="resetGame()" style="padding: 12px 20px; font-size: 16px; background-color: #ff4444; color: white; border: none;">重置游戏</button>
    </div>
    <button onclick="toggleSettingsUI()" style="margin-top: 20px; padding: 10px 28px; font-size: 15px;">关闭设置</button>
</div>
<input type="file" id="fileInput" accept=".txt" style="display: none;">
<input type="file" id="avatarInput" accept="image/*" style="display: none;">


<!-- 半透明遮罩层 -->
<div id="settingsOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
<!-- 新增合成面板HTML -->
<div id="combinePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; background: #333; border: 2px solid #9C27B0; border-radius: 10px; padding: 20px; z-index: 1001;">
    <button onclick="closeCombinePanel()" style="position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
    <h3 style="color: #fff; text-align: center;">伴侣合成</h3>
    
    <div style="display: flex; gap: 20px; margin: 20px 0;">
        <!-- 主伴侣选择 -->
        <div style="flex: 1;">
            <h4 style="color: #fff;">主伴侣</h4>
            <div id="mainCompanionSlot" style="background: #444; border-radius: 5px; padding: 10px; min-height: 150px;">
                <select id="mainCompanionSelect" style="width: 100%; padding: 5px; background: #555; color: white; border: 1px solid #666;">
                    <!-- 动态填充可选伴侣 -->
                </select>
                <div id="mainCompanionInfo" style="margin-top: 10px; color: #fff; font-size: 0.9em;">
                    <!-- 显示选中的主伴侣信息 -->
                </div>
            </div>
        </div>
        
        <!-- 合成图标 -->
        <div style="display: flex; align-items: center; justify-content: center;">
            <button onclick="combineCompanions()" style="background: #9C27B0; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 20px; cursor: pointer;">→</button>
        </div>
        
        <!-- 副伴侣选择 -->
        <div style="flex: 1;">
            <h4 style="color: #fff;">副伴侣</h4>
            <div id="secondaryCompanionSlot" style="background: #444; border-radius: 5px; padding: 10px; min-height: 150px;">
                <select id="secondaryCompanionSelect" style="width: 100%; padding: 5px; background: #555; color: white; border: 1px solid #666;">
                    <!-- 动态填充可选伴侣 -->
                </select>
                <div id="secondaryCompanionInfo" style="margin-top: 10px; color: #fff; font-size: 0.9em;">
                    <!-- 显示选中的副伴侣信息 -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- 合成预览 -->
    <div style="background: #444; border-radius: 5px; padding: 10px; margin: 10px 0;">
        <h4 style="color: #fff; margin-top: 0;">合成预览</h4>
        <div id="combinePreview" style="color: #fff; font-size: 0.9em;">
            <p>选择主副伴侣查看合成预览</p>
            <p>新一代数: <span id="previewGeneration">--</span></p>
            <p>预计天赋数量: <span id="previewTalentCount">--</span></p>
            <p>预计品质: <span id="previewRarity" style="color: #ff00ff;">天使(彩色)丶</span> <span id="previewRarity" style="color: #E63946;">恶魔(深红色)丶</span> <span id="previewRarity" style="color: #7CFC00;">精灵(绿色)</span></p>
            <p>预计评分范围: <span id="previewScoreRange">--</span></p>
            <p>品质加成倍数: <span id="previewQualityMultiplier">--</span></p>
        </div>
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="combineCompanions()" style="background: #9C27B0; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">确认合成</button>
        <p style="color: #ff4444; font-size: 0.8em; margin-top: 10px;">注意: 合成将消耗主副两只伴侣，且结果随机！</p>
    </div>
</div>
<div id="autoBuyShopa" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1000; max-height: 80vh; overflow-y: auto; width: 500px;">
    <h3>轮回BOSS副本</h3>
    <div class="auto-buy-container">
    <button onclick="toggleBlackDragonAbyss()" style="margin-left: 10px; background: linear-gradient(to bottom, #2c003e, #0f0024); color: #ffd700; border: 1px solid #8a2be2; box-shadow: 0 0 10px #8a2be2;">黑龙潭副本</button>
     <button onclick="toggleHolyBeastIsland()" style="background: linear-gradient(to bottom, #ff0000, #8b0000); color: #ffd700; border: 2px solid #ff4500; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; text-shadow: 0 0 5px #ff0000; box-shadow: 0 0 10px #ff0000;">圣兽岛副本</button>
      <button onclick="togglePenglaiIsland()" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #8b4513; border: 2px solid #ffd700; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; text-shadow: 0 0 5px #ffd700; box-shadow: 0 0 10px #ffd700; margin-left: 10px;">蓬莱仙岛副本</button>
      <button onclick="toggleLunhuiFuben()" style="background: linear-gradient(to bottom, #20b2aa, #008b8b); color: #fff; border: 2px solid #20b2aa; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; margin-left: 10px;">轮回试炼副本</button>
      <button onclick="toggleLunhuiPenglai()" style="background: linear-gradient(to bottom, #9370db, #4b0082); color: #e6e6fa; border: 2px solid #9370db; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; margin-left: 10px;">轮回仙岛副本</button>
    </div>
    <button onclick="toggleAutoBuyShopa()" style="margin-top: 15px;">关闭界面</button>
</div>

<!-- 新增自动购买商店界面 -->
<div id="autoBuyShop" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1000; max-height: 80vh; overflow-y: auto; width: 500px;">
    <h3>自动购买设置</h3>
    <div class="auto-buy-container">
        <button id="autoChest1" class="auto-buy-btn" onclick="toggleAutoBuy(1)">普通宝箱自动购买：关闭</button>
        <button id="autoChest2" class="auto-buy-btn" onclick="toggleAutoBuy(2)">高级宝箱自动购买：关闭</button>
        <button id="autoChest3" class="auto-buy-btn" onclick="toggleAutoBuy(3)">稀有宝箱自动购买：关闭</button>
        <button id="autoChest4" class="auto-buy-btn" onclick="toggleAutoBuy(4)">史诗宝箱自动购买：关闭</button>
        <button id="autoChest5" class="auto-buy-btn" onclick="toggleAutoBuy(5)">传说宝箱自动购买：关闭</button>
        <button id="autoChest6" class="auto-buy-btn" onclick="toggleAutoBuy(6)">混沌宝箱自动购买：关闭</button>
        <button id="autoChest7" class="auto-buy-btn" onclick="toggleAutoBuy(7)">终焉宝箱自动购买：关闭</button>
        <button id="autoChest8" class="auto-buy-btn" onclick="toggleAutoBuy(8)">星辰宝箱自动购买：关闭</button>
        <button id="autoChest9" class="auto-buy-btn" onclick="toggleAutoBuy(9)">银河宝箱自动购买：关闭</button>
        <button id="autoChest10" class="auto-buy-btn" onclick="toggleAutoBuy(10)">星云宝箱自动购买：关闭</button>
        <button id="autoChest11" class="auto-buy-btn" onclick="toggleAutoBuy(11)">鸿蒙宝箱自动购买：关闭</button>
        <button id="autoChest12" class="auto-buy-btn" onclick="toggleAutoBuy(12)">太虚宝箱自动购买：关闭</button>
        <button id="autoChest13" class="auto-buy-btn" onclick="toggleAutoBuy(13)">虚空宝箱自动购买：关闭</button>
        <button id="autoChest14" class="auto-buy-btn" onclick="toggleAutoBuy(14)">时空宝箱自动购买：关闭</button>
        <button id="autoChest15" class="auto-buy-btn" onclick="toggleAutoBuy(15)">未来宝箱自动购买：关闭</button>
        <button id="autoMaterialChest" class="auto-buy-btn" onclick="toggleAutoBuyMaterialChest()">材料宝箱自动购买：关闭</button>
        <button id="autoTechniqueChest" class="auto-buy-btn" onclick="toggleAutoBuyTechniqueChest()">功法秘籍宝箱自动购买：关闭</button>
    </div>
    <button onclick="toggleAutoBuyShop()" style="margin-top: 15px;">关闭商店</button>
     <button onclick="toggleAutoBuySettings()">功法秘籍自动购买设置</button>
</div>
<!-- 自动兑换货币界面 -->
<div id="autoConvertUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #3498db; border-radius: 10px; z-index: 1000; max-width: 500px; max-height: 80vh; overflow-y: auto;">
    <h3 style="margin-top: 0; color: #3498db; text-align: center;">自动兑换设置</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
        <button id="autoConvertGold" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('gold')">金币自动兑换：关闭</button>
        <button id="autoConvertDiamond" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('diamond')">钻石自动兑换：关闭</button>
        <button id="autoConvertTitanium" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('titanium')">钛晶石自动兑换：关闭</button>
        <button id="autoConvertStarstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('starstone')">星耀石自动兑换：关闭</button>
        <button id="autoConvertCosmicstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('cosmicstone')">宇宙石自动兑换：关闭</button>
        <button id="autoConvertSuperstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('superstone')">超能石自动兑换：关闭</button>
        <button id="autoConvertOtherworldstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('otherworldstone')">异界石自动兑换：关闭</button>
        <button id="autoConvertXingjiestone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('xingjiestone')">星界石自动兑换：关闭</button>
        <button id="autoConvertHundunstone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('hundunstone')">混沌石自动兑换：关闭</button>
        <button id="autoConvertLingtone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('lingtone')">灵髓石自动兑换：关闭</button>
        <button id="autoConvertHuangtone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('huangtone')">幻空石自动兑换：关闭</button>
        <button id="autoConvertMingtone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('mingtone')">冥源石自动兑换：关闭</button>
        <button id="autoConvertXutong" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('xutong')">虚空石自动兑换：关闭</button>
        <button id="autoConvertShitone" class="auto-buy-btn" onclick="toggleAutoConvertCurrency('shitone')">时空石自动兑换：关闭</button>
    </div>
    <div style="text-align: center; margin-top: 15px;">
        <button onclick="toggleAutoConvertUI()" style="background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">关闭</button>
    </div>
</div>

<!-- 半透明遮罩层 -->
<div id="autoConvertOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
<!-- 新增洗练面板HTML -->
<div id="washPanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: #333; border: 2px solid #2196F3; border-radius: 10px; padding: 20px; z-index: 1001;">
    <button onclick="closeWashPanel()" style="position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">×</button>
    <h3 style="color: #fff; text-align: center;">伴侣洗练</h3>
    
    <div id="washCompanionInfo" style="background: #444; border-radius: 5px; padding: 10px; margin: 15px 0;">
        <!-- 伴侣信息将在这里动态填充 -->
    </div>
    
    <div style="margin: 15px 0; color: #fff;">
        <p>基础洗练消耗：1 洗髓丹</p>
        <p>每锁定一个天赋额外消耗：2 洗髓丹</p>
        <p>当前洗髓丹数量：<span id="rebornDanCount">0</span></p>
        <p id="totalWashCost">本次洗练总消耗：1 洗髓丹</p>
    </div>
    <!-- 天赋列表与锁定选项 -->
    <div id="talentList" style="background: #444; border-radius: 5px; padding: 10px; margin: 15px 0; max-height: 200px; overflow-y: auto;">
        <!-- 天赋和锁定复选框将在这里动态生成 -->
    </div>

    
    <div id="washResult" style="background: #444; border-radius: 5px; padding: 10px; margin: 15px 0; min-height: 60px;max-height: 200px ;overflow-y: auto;  color: #fff; display: none;">
        <!-- 洗练结果将在这里动态显示 -->
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="washCompanion()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">确认洗练</button>
    </div>
</div>
<div id="fishingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="fishingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #f0f8ff; padding: 20px; border: 3px solid #4682b4; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <!-- 标题栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #4682b4; padding-bottom: 10px;">
        <h2 style="color: #1e3a8a; margin: 0;">钓鱼系统</h2>
        <button onclick="toggleFishingSystem()" style="background: #ff4444; color: white; border: none; border-radius: 5px; padding: 5px 10px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 钓鱼信息 -->
    <div style="margin-bottom: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div>
                <strong>钓鱼等级: </strong><span id="fishingLevel">1</span>
            </div>
            <div>
                <strong>当前经验: </strong><span id="currentFishingExp">0</span>/<span id="nextFishingExp">500</span>
            </div>
            <div>
                <strong>点击收益加成: </strong><span id="fishingBonus">1</span>
            </div>
        </div>
        <div style="margin-top: 10px;">
            <strong>鱼饵数量: </strong><span id="baitCount">0</span>
        </div>
    </div>
    
    <!-- 钓鱼区域 -->
    <div style="background: #87ceeb; height: 200px; border-radius: 8px; margin-bottom: 20px; position: relative; overflow: hidden;">
        <div id="fishingPond" style="width: 100%; height: 100%; position: relative;">
            <!-- 水面效果 -->
            <div style="position: absolute; bottom: 0; width: 100%; height: 120px; background: #1e90ff; opacity: 0.7; border-top: 2px dashed #4682b4;"></div>
            
            <!-- 鱼竿 -->
            <div id="fishingRod" style="position: absolute; bottom: 120px; left: 50px; width: 150px; height: 10px; background: #8b4513; transform-origin: left center; transform: rotate(-30deg); display: none;">
                <div style="position: absolute; right: 0; width: 20px; height: 20px; background: #ffd700; border-radius: 50%;"></div>
            </div>
            
            <!-- 浮标 -->
            <div id="fishingBobber" style="position: absolute; bottom: 130px; left: 180px; width: 15px; height: 15px; background: #ff4500; border-radius: 50%; display: none;"></div>
            
            <!-- 鱼咬钩动画区域 -->
            <div id="biteIndicator" style="position: absolute; bottom: 120px; left: 180px; color: white; font-weight: bold; display: none; text-shadow: 0 0 5px #000;">
                鱼咬钩了！快拉！
            </div>
            
            <!-- 状态文本 -->
            <div id="fishingStatus" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: #1e3a8a; font-weight: bold;">
                点击"开始钓鱼"按钮开始
            </div>
        </div>
    </div>
    
    <!-- 钓鱼控制按钮 -->
    <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
        <button id="startFishingBtn" onclick="startFishing()" style="background: #228b22; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">开始钓鱼</button>
        <button id="reelInBtn" onclick="reelInFish()" style="background: #d2691e; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; display: none;">拉钩上钓</button>
     <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
    <button id="autoFishingBtn" onclick="toggleAutoFishing()" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">
        自动钓鱼: 关闭
    </button>
    <button id="autoDecomposeFishBtn" onclick="toggleAutoDecomposeFish()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">
        自动分解: 关闭
    </button>
</div>
    </div>
    
    <!-- 鱼笼信息 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #1e3a8a; border-bottom: 1px solid #4682b4; padding-bottom: 5px;">鱼笼 (<span id="cageCount">0</span>/20)</h3>
        <div id="fishCage" style="background: white; padding: 10px; border-radius: 8px; max-height: 200px; overflow-y: auto; border: 1px solid #ddd; display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
            <!-- 鱼会动态显示在这里 -->
            <div style="grid-column: 1 / -1; text-align: center; color: #666;">鱼笼是空的，快去钓鱼吧！</div>
        </div>
    </div>
    
    <!-- 分解按钮 -->
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="decomposeSelectedFish()" style="background: #8b0000; color: white; border: none; padding: 10px 30px; border-radius: 5px; cursor: pointer; font-size: 16px;">分解选中的鱼获</button>
    </div>
</div>
<!-- 农场系统界面 -->
<div id="farmSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="farmSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
        <h2 style="color: #4CAF50; margin: 0;">农场系统</h2>
        <button onclick="closeFarmSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 农场信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between;">
            <div>
                <strong>农场等级:</strong> <span id="farmLevel">1</span>
                <strong>经验:</strong> <span id="farmExp">0</span>/<span id="farmExpNext">100</span>
            </div>
            <div>
                <strong>农田数量:</strong> <span id="farmFieldCount">2</span>/<span id="farmMaxFields">5</span>
            </div>
            <div>
                <strong>水滴:</strong> <span id="waterCount">10</span>
            </div>
        </div>
    </div>
    
    <!-- 农田区域 -->
    <div style="margin-bottom: 20px;">
        <h3>农田</h3>
        <div id="farmFields" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 10px;">
            <!-- 农田地块将动态生成 -->
        </div>
    </div>
    
    <!-- 种子仓库 -->
    <div style="margin-bottom: 20px;">
        <h3>种子仓库</h3>
        <div id="seedInventory" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 10px; max-height: 200px; overflow-y: auto;">
            <!-- 种子将动态生成 -->
        </div>
    </div>
    
    <!-- 操作按钮 -->
    <div style="text-align: center; margin-top: 20px;">
        <button onclick="waterAllCrops()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">一键浇水</button>
        <button onclick="harvestAllCrops()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">一键收获</button>

    <button id="autoPlantBtn" onclick="toggleAutoPlant()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">自动种植: 关闭</button>
    <button id="autoHarvestBtn" onclick="toggleAutoHarvest()" style="background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">自动收获: 关闭</button>
    </div>
</div>
<!-- 停车位系统界面 -->
<div id="parkingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="parkingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <!-- 标题栏 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
        <h2 style="color: #4CAF50; margin: 0;">停车位系统</h2>
        <button onclick="closeParkingSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 停车位信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div>
                <strong>停车位等级:</strong> <span id="parkingLevel">1</span>
            </div>
            <div>
                <strong>停车位数量:</strong> <span id="parkingSpotCount">1</span>/<span id="maxParkingSpots">5</span>
            </div>
            <div>
                <strong>停车经验:</strong> <span id="parkingExp">0</span>/<span id="nextLevelExp">150</span>
            </div>
            <div>
                <strong>总收益:</strong> <span id="totalParkingIncome">0</span> 转生币
            </div>
        </div>
        <button onclick="upgradeParking()" style="margin-top: 10px; background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">升级停车位 (消耗经验)</button>
    </div>
    
    <!-- 车辆管理 -->
    <div style="margin-bottom: 20px;">
        <h3>我的车辆</h3>
        <div id="vehicleList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; padding: 10px; background: #333; border-radius: 5px;">
            <!-- 车辆卡片会动态生成在这里 -->
        </div>
    </div>
    
    <!-- 停车操作 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>停车操作</h3>
        <div id="parkingSpotsContainer" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin: 10px 0; max-height: 400px; overflow-y: auto; ">
            <!-- 停车位会动态生成在这里 -->
        </div>
        <div>
            <button onclick="parkAllVehicles()" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; margin-right: 10px;">一键停车</button>
            <button onclick="collectAllParkingIncome()" style="background: #FFC107; color: black; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">收取所有收益</button>
                       
        </div>
    </div>
    
    <!-- 车辆分解 -->
    <div style="background: #333; padding: 15px; border-radius: 8px;">
    <h3>车辆分解</h3>
    <p>选择车辆进行分解，获得转生币</p>
    
    <!-- 批量选择选项 -->
    <div style="margin-bottom: 10px;">
        <strong>批量选择:</strong>
        <button onclick="selectByRarity(5)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">5稀有度以下</button>
        <button onclick="selectByRarity(10)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">10稀有度以下</button>
        <button onclick="selectByRarity(15)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">15稀有度以下</button>
        <button onclick="selectByRarity(20)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">20稀有度以下</button>
        <button onclick="selectByRarity(30)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">30稀有度以下</button>
        <button onclick="selectByRarity(35)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">35稀有度以下</button>
        <button onclick="selectAllVehicles()" style="margin: 2px; padding: 3px 6px; font-size: 12px;">全选</button>
        <button onclick="deselectAllVehicles()" style="margin: 2px; padding: 3px 6px; font-size: 12px;">全不选</button>
    </div>
    
    <div id="decomposeVehicleContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;max-height: 400px; overflow-y: auto;">
        <!-- 分解界面会动态生成在这里 -->
    </div>
    <button onclick="decomposeSelectedVehicle()" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">分解选中车辆</button>
</div>
</div>
<!-- 星域探索系统界面 -->
<div id="explorationSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="explorationSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #0a0a2a; color: white; padding: 20px; border: 3px solid #4a86e8; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #4a86e8; padding-bottom: 10px;">
        <h2 style="color: #4a86e8; margin: 0;">星域探索系统</h2>
        <button onclick="toggleExplorationSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    <div style="text-align: center; margin-top: 15px;">
    <button onclick="toggleExchangeShop()" style="background: #FFD700; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">兑换商店</button>
</div>

    <!-- 舰队属性 -->
    <div style="margin-bottom: 20px; background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">舰队属性</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 15px;">
           <div class="attribute-card">
    <div class="attribute-icon" style="background: linear-gradient(to bottom, #ff9900, #ff6600);">⏱️</div>
    <div class="attribute-info">
        <strong>速度</strong>
        <div>等级: <span id="speedLevel">1</span></div>
        <div>探索时间: <span id="explorationTime">60</span>分钟</div>
    </div>
    <button class="upgrade-btn" data-attr="speed" onclick="upgradeAttribute('speed')">升级</button>
</div>

<div class="attribute-card">
    <div class="attribute-icon" style="background: linear-gradient(to bottom, #00cc66, #00994d);">📦</div>
    <div class="attribute-info">
        <strong>容量</strong>
        <div>等级: <span id="capacityLevel">1</span></div>
        <div>资源获取: <span id="resourceGain">100%</span></div>
    </div>
    <button class="upgrade-btn" data-attr="capacity" onclick="upgradeAttribute('capacity')">升级</button>
</div>

<div class="attribute-card">
    <div class="attribute-icon" style="background: linear-gradient(to bottom, #9966ff, #6600cc);">🛡️</div>
    <div class="attribute-info">
        <strong>耐久</strong>
        <div>等级: <span id="durabilityLevel">1</span></div>
        <div>稀有率: <span id="rareRate">5%</span></div>
        <div>损坏率: <span id="damageRate">10%</span></div>
    </div>
    <button class="upgrade-btn" data-attr="durability" onclick="upgradeAttribute('durability')">升级</button>
</div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="upgradeAllAttributes()" style="background: #4a86e8; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer;">一键升级全部属性</button>
        </div>
    </div>
    
    <!-- 探索任务 -->
    <div style="margin-bottom: 20px; background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">探索任务</h3>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <div class="mission-card" data-difficulty="easy">
                <div class="mission-header">
                    <h4>近地星域</h4>
                    <span class="difficulty-tag">简单</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">60分钟</span></div>
                    <div>资源: 星尘发票</div>
                    <div>资源: 暗物质发票</div>
                    <div>损坏风险: <span class="damage-risk">10%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('easy')">开始探索</button>
            </div>
            
            <div class="mission-card" data-difficulty="medium">
                <div class="mission-header">
                    <h4>深空星域</h4>
                    <span class="difficulty-tag">中等</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">120分钟</span></div>
                    <div>资源: 星尘发票</div>
                    <div>资源: 暗物质发票</div>
                    <div>资源: 宇宙晶体发票</div>
                    <div>损坏风险: <span class="damage-risk">20%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('medium')">开始探索</button>
            </div>
            
            <div class="mission-card" data-difficulty="hard">
                <div class="mission-header">
                    <h4>黑洞边缘</h4>
                    <span class="difficulty-tag">困难</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">180分钟</span></div>
                    <div>资源: 星尘发票</div>
                    <div>资源: 暗物质发票</div>
                    <div>资源: 宇宙晶体发票</div>
                    <div>损坏风险: <span class="damage-risk">30%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('hard')">开始探索</button>
            </div>
            
            <div class="mission-card" data-difficulty="extreme">
                <div class="mission-header">
                    <h4>宇宙边缘</h4>
                    <span class="difficulty-tag">极限</span>
                </div>
                <div class="mission-info">
                    <div>时间: <span class="mission-time">240分钟</span></div>
                    <div>资源: 宇宙晶体发票</div>
                    <div>资源: 神器碎片发票</div>
                    <div>损坏风险: <span class="damage-risk">40%</span></div>
                </div>
                <button class="start-mission-btn" onclick="startMission('extreme')">开始探索</button>
            </div>
        </div>
    </div>
    
    <!-- 资源仓库 -->
    <div style="margin-bottom: 20px; background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">资源仓库</h3>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #cccccc, #999999);">✨</div>
                <div class="resource-info">
                    <strong>星尘</strong>
                    <div id="stardustCount">0</div>
                </div>
            </div>
            
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #333366, #000033);">🌌</div>
                <div class="resource-info">
                    <strong>暗物质</strong>
                    <div id="darkMatterCount">0</div>
                </div>
            </div>
            
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #66ccff, #3399ff);">💎</div>
                <div class="resource-info">
                    <strong>宇宙晶体</strong>
                    <div id="cosmicCrystalCount">0</div>
                </div>
            </div>
            
            <div class="resource-card">
                <div class="resource-icon" style="background: linear-gradient(to bottom, #ffcc00, #ff9900);">🔱</div>
                <div class="resource-info">
                    <strong>神器碎片</strong>
                    <div id="artifactFragmentCount">0</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 探索日志 -->
    <div style="background: #1a1a3a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #4a86e8; margin-top: 0;">探索日志</h3>
        <div id="explorationLog" style="height: 200px; overflow-y: auto; background: #0a0a1a; padding: 10px; border-radius: 5px; margin-top: 10px;">
            <div class="log-entry">欢迎使用星域探索系统！</div>
            <div class="log-entry">选择任务并开始探索宇宙奥秘吧！</div>
        </div>
    </div>
</div>
<!-- 神器锻造系统 -->
<div id="artifactSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="artifactSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 850px; max-height: 800px; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #d4af37; padding-bottom: 10px;">
        <h2 style="color: #d4af37; margin: 0;">神器锻造系统</h2>
        <button onclick="toggleArtifactSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    

    <div style="display: flex; gap: 10px; margin: 15px 0;">
    <!-- 锻造区域 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px; width: 35%;">
        <h3 style="color: #d4af37; margin-top: 0;">锻造神器</h3>
        <p>消耗10神器碎片随机锻造一件神器</p>
        <button onclick="forgeArtifact()" style="background: #d4af37; color: black; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin-top: 10px;">锻造1次</button>
                       <button onclick="forgeArtifact(10)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造10次</button>
                <button onclick="forgeArtifact(20)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造20次</button>
                <button onclick="forgeArtifact(50)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造50次</button>
                <button onclick="forgeArtifact(100)" style="background: #d4af37; color: black; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">锻造100次</button>
    </div>
     <div style="margin-top: 0px; background: #444; padding: 15px; border-radius: 8px; width: 28%;">
        <h4 style="color: #d4af37; margin-top: 0;">进阶系统</h4>
        <h6 style="color: #d4af37; margin-top: 0;">下方神器仓库选择一个点击详情</h6>
        <div id="artifactAdvanceInfo">
            <!-- 进阶信息将动态填充 -->
        </div>
        <button id="advanceArtifactBtn" onclick="advanceArtifact()" style="margin-top: 10px; background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 14px;">进阶神器</button>
    </div>

     <div style="margin-top: 0px; background: #444; padding: 15px; border-radius: 8px; width: 35%;">
        <h7 style="color: #d4af37; margin-top: 0;"></h7>
        <h8 style="color: #d4af37; margin-top: 0;"></h8>
        </div> 
   </div>


    <!-- 装备部位 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d4af37; margin-top: 0;">装备部位</h3>
        <div id="artifactSlots" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
            <!-- 6个装备部位将动态生成 -->
        </div>
    </div>
    
    <!-- 神器仓库 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d4af37; margin-top: 0; overflow-y: auto;">神器仓库</h3>
    <div style="display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 1px solid #d4af37; padding-bottom: 10px; max-height: 400px; overflow-y: auto;">
    <div class="artifact-tab active" onclick="switchArtifactTab('all')">全部神器</div>
    <div class="artifact-tab" onclick="switchArtifactTab('sets')">按套装查看</div>
        <div id="artifactInventory" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-height: 400px; overflow-y: auto; padding: 10px; background: #333; border-radius: 8px;">
            <!-- 神器将动态生成 -->

</div>

<!-- 添加套装查看容器 -->
<div id="artifactSetsView" style="display: none;max-height: 400px; overflow-y: auto; padding: 10px; background: #333; border-radius: 8px;">
    <div id="artifactSetsContainer"></div>
</div>
        </div>
    </div>
   
    <!-- 套装效果 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">套装效果</h3>
        <div id="setBonuses">
            <!-- 套装效果将动态显示 -->
        </div>
    </div>
</div>
<!-- 杂货铺界面 -->
<div id="groceriesOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;"></div>
<div id="groceriesUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; border-radius: 10px; z-index: 1001; width: 500px;">
    <h2>杂货铺</h2>
    <p>当前星尘: <span id="currentStardust">0</span></p>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>鱼饵</strong>
            <div>100星尘 → 2鱼饵</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="baitAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('bait')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>伴侣钥匙</strong>
            <div>200星尘 → 1钥匙</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="keyAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('key')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>玫瑰花</strong>
            <div>100星尘 → 20玫瑰花</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="roseAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('rose')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>VIP能力值</strong>
            <div>100星尘 → 10VIP能力值</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="vipAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('vip')">兑换</button>
        </div>
    </div>
    
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>神级宝石</strong>
            <div>5000星尘 → 1神级宝石</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="gemAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('gem')">兑换</button>
        </div>
    </div>
    <div class="exchange-item">
    <div class="exchange-info">
        <strong>灵根检测器</strong>
        <div>500星尘 → 1个</div>
    </div>
    <div class="exchange-controls">
        <input type="number" id="rootAmount" min="1" value="1" style="width: 60px;">
        <button onclick="exchangeStardust('root')">兑换</button>
    </div>
</div>
    <div class="exchange-item">
    <div class="exchange-info">
        <strong>血脉检测剂</strong>
        <div>500星尘 → 1个</div>
    </div>
    <div class="exchange-controls">
        <input type="number" id="bloodAmount" min="1" value="1" style="width: 60px;">
        <button onclick="exchangeStardust('blood')">兑换</button>
    </div>
</div>
    <div class="exchange-item">
        <div class="exchange-info">
            <strong>转生币</strong>
            <div>100星尘 → 1000000转生币</div>
        </div>
        <div class="exchange-controls">
            <input type="number" id="coinAmount" min="1" value="1" style="width: 60px;">
            <button onclick="exchangeStardust('coin')">兑换</button>
        </div>
    </div>
    
    <button onclick="toggleGroceriesUI()" style="margin-top: 20px; padding: 8px 20px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">关闭</button>
</div>
<!-- 宝石系统界面 -->
<div id="gemSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="gemSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #d4af37; margin: 0;">宝石系统</h2>
        <button onclick="toggleGemSystem()" style="background: #ff4444; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 宝石商店 -->
    <div style="margin-bottom: 30px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">宝石商店</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
            <div class="gem-shop-item">
                <div class="gem-icon red">红</div>
                <div>红宝石 (攻击)</div>
                <div>价格: 100暗物质</div>
                <button onclick="buyGem('red', 1)">购买</button>
            </div>
            <div class="gem-shop-item">
                <div class="gem-icon blue">蓝</div>
                <div>蓝宝石 (生命)</div>
                <div>价格: 100暗物质</div>
                <button onclick="buyGem('blue', 1)">购买</button>
            </div>
            <div class="gem-shop-item">
                <div class="gem-icon black">黑</div>
                <div>黑宝石 (爆伤)</div>
                <div>价格: 100暗物质</div>
                <button onclick="buyGem('black', 1)">购买</button>

            </div>
        </div>
    </div>
    
    <!-- 宝石仓库 -->
    <div style="margin-bottom: 30px;">
        <h3 style="color: #d4af37; margin-top: 0;">宝石仓库</h3>
        <div id="gemInventory" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
            <!-- 宝石将动态生成在这里 -->
        </div>
    </div>
</div>
<!-- 修仙系统UI -->
<div id="cultivationSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="cultivationSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #1a1a2e, #16213e); color: white; padding: 25px; border: 2px solid #4CAF50; border-radius: 15px; z-index: 1001; width: 750px; max-height: 85vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid #4CAF50;">
        <h2 style="color: #4CAF50; margin: 0; text-shadow: 0 2px 5px rgba(0,0,0,0.3); font-size: 28px;">⚡ 修仙系统</h2>
        <button onclick="toggleCultivationSystem()" style="background: linear-gradient(45deg, #f44336, #c62828); color: white; border: none; padding: 8px 20px; border-radius: 6px; cursor: pointer; font-weight: bold; transition: all 0.3s;">关闭</button>
    </div>
    
    <!-- 顶部状态栏 -->
    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 25px;">
        <!-- 当前灵根信息 -->
        <div style="background: linear-gradient(145deg, #2c2c54, #40407a); padding: 20px; border-radius: 12px; border-left: 5px solid #FFD700; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
            <h3 style="color: #FFD700; margin-top: 0; margin-bottom: 15px; font-size: 18px; display: flex; align-items: center;">
                <span style="margin-right: 8px;">🌿</span> 当前灵根
            </h3>
            <div id="currentRootInfo" style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 15px;">
                尚未检测灵根
            </div>
            <button onclick="openRootBox()" style="width: 100%; background: linear-gradient(45deg, #2196F3, #0D47A1); color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s;">开启灵根宝箱</button>
        </div>
        
        <!-- 当前血脉信息 -->
        <div style="background: linear-gradient(145deg, #2c2c54, #40407a); padding: 20px; border-radius: 12px; border-left: 5px solid #d4af37; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
            <h3 style="color: #d4af37; margin-top: 0; margin-bottom: 15px; font-size: 18px; display: flex; align-items: center;">
                <span style="margin-right: 8px;">💉</span> 当前血脉
            </h3>
            <div id="currentBloodlineInfo" style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 15px;">
                尚未检测血脉
            </div>
            <button onclick="openBloodlineBox()" style="width: 100%; background: linear-gradient(45deg, #9C27B0, #6A1B9A); color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s;">开启血脉宝箱</button>
        </div>
        
        <!-- 装备法宝 -->
        <div style="background: linear-gradient(145deg, #2c2c54, #40407a); padding: 20px; border-radius: 12px; border-left: 5px solid #FF5722; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
            <h3 style="color: #FF5722; margin-top: 0; margin-bottom: 15px; font-size: 18px; display: flex; align-items: center;">
                <span style="margin-right: 8px;">🔮</span> 装备法宝
            </h3>
            <div id="currentMagicToolInfo" style="text-align: center; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 15px;">
                无装备法宝
            </div>
            <button onclick="openMagicToolSystem()" style="width: 100%; background: linear-gradient(45deg, #FF5722, #D84315); color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s;">法宝系统</button>
        </div>
    </div>
    
    <!-- 修仙阶段和经验 -->
    <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 25px;">
        <!-- 修仙阶段 -->
        <div style="background: linear-gradient(145deg, #2c2c54, #40407a); padding: 25px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
            <h3 style="color: #4CAF50; margin-top: 0; margin-bottom: 20px; font-size: 20px; display: flex; align-items: center;">
                <span style="margin-right: 10px;">📈</span> 修仙阶段
            </h3>
            
            <div style="margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 16px;">
                    <span>境界等级: <span id="stageLevel" style="color: #FFD700; font-weight: bold;">0</span></span>
                    <span>境界: <span id="currentStageqa" style="color: #4CAF50; font-weight: bold;">凡人</span></span>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span>当前经验: <span id="currentExp" style="color: #4CAF50; font-weight: bold;">0</span></span>
                        <span>升级所需: <span id="nextExp" style="color: #FFD700; font-weight: bold;">1000</span></span>
                    </div>
                    
                    <!-- 经验条 -->
                    <div style="background: #444; height: 20px; border-radius: 10px; overflow: hidden; margin-bottom: 10px;">
                        <div id="expProgress" style="height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); width: 0%; transition: width 0.5s ease; border-radius: 10px;"></div>
                    </div>
                </div>
                
                <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px;">
                    <div style="font-size: 14px; color: #aaa; margin-bottom: 5px;">经验计算公式</div>
                    <div style="font-size: 16px; color: #4CAF50;">(灵根加成 × 血脉加成 × 法宝加成 × 职业加成) × 转生次数</div>
                    <div style="margin-top: 10px; font-size: 16px;">当前每分钟经验: <span id="currentExpPerMinute" style="color: #FFD700; font-weight: bold;">0</span></div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="upgradeCultivation()" style="flex: 1; background: linear-gradient(45deg, #4CAF50, #2E7D32); color: white; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px; transition: all 0.3s;">突破境界</button>
                <button onclick="toggleFiveElementsSystem()" style="flex: 1; background: linear-gradient(45deg, #8A2BE2, #6A1B9A); color: white; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px; transition: all 0.3s;">五行之力</button>
               <button onclick="togglePillSystem()" style="flex: 1; background: linear-gradient(45deg, #8A2BE2, #6A1B9A); color: white; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px; transition: all 0.3s;">
        <span>💊</span> 丹药</button>
               <button onclick="toggleAutoBuyShopb()" style="flex: 1; background: linear-gradient(45deg, #8A2BE2, #6A1B9A); color: white; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px; transition: all 0.3s;">修仙副本</button>
                
            </div>
        </div>

        <!-- 阶段加成和法宝加成 -->
        <div style="display: flex; flex-direction: column; gap: 20px;">
            <!-- 阶段加成 -->
            <div style="background: linear-gradient(145deg, #2c2c54, #40407a); padding: 20px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
                <h3 style="color: #4CAF50; margin-top: 0; margin-bottom: 15px; font-size: 18px; display: flex; align-items: center;">
                    <span style="margin-right: 8px;">✨</span> 阶段加成
                </h3>
                <div id="stageBonusInfo" style="text-align: center; padding: 15px; background: rgba(76, 175, 80, 0.2); border-radius: 8px;">
                    <div style="font-size: 24px; color: #FFD700; font-weight: bold; margin-bottom: 5px;">
                        <span id="gpsMultiplier">1</span>倍
                    </div>
                    <div style="font-size: 14px; color: #aaa;">点击收益+GPS</div>
                </div>
            </div>
            
            <!-- 法宝加成 -->
            <div style="background: linear-gradient(145deg, #2c2c54, #40407a); padding: 20px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
                <h3 style="color: #FF5722; margin-top: 0; margin-bottom: 15px; font-size: 18px; display: flex; align-items: center;">
                    <span style="margin-right: 8px;">⚡</span> 法宝加成
                </h3>
                <div id="magicToolBonusInfo" style="text-align: center; padding: 15px; background: rgba(255, 87, 34, 0.2); border-radius: 8px;">
                    <div style="font-size: 24px; color: #FFD700; font-weight: bold; margin-bottom: 5px;">
                        <span id="magicToolMultiplier">1</span>倍
                    </div>
                    <div style="font-size: 14px; color: #aaa;">修炼速度加成</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 像素玩家UI -->
<div id="pixelPlayerOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1100;"></div>
<div id="pixelPlayerUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #1a1a2e, #16213e); color: #fff; padding: 28px; border: 2px solid #00BCD4; border-radius: 14px; z-index: 1101; width: 680px; max-height: 90vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; border-bottom: 1px solid #00BCD4; padding-bottom: 10px;">
        <h2 style="color: #00BCD4; margin: 0; font-size: 22px;">像素玩家</h2>
        <button onclick="togglePixelPlayerUI()" style="background: #f44336; color: #fff; border: none; padding: 6px 14px; border-radius: 6px; cursor: pointer;">关闭</button>
    </div>
    <div style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap;">
        <div style="flex: 1; min-width: 200px;">
            <div style="background: rgba(76,32,96,0.25); border: 2px solid #5a3070; border-radius: 10px; padding: 12px; text-align: center;">
                <div style="font-size: 14px; color: #C9A0DC; margin-bottom: 8px;">像素小人</div>
                <canvas id="pixelCharacterCanvas" style="image-rendering: pixelated; image-rendering: crisp-edges; image-rendering: -moz-crisp-edges; image-rendering: -webkit-crisp-edges; width: 512px; height: 512px; margin: 0 auto; background: #4C2060; border-radius: 10px; display: block; box-shadow: 0 2px 12px rgba(0,0,0,0.3);"></canvas>
            </div>
            <div style="margin-top: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <div><div style="font-size: 11px; color: #aaa;">头盔</div><div id="pixelHelmetSlot" style="min-height: 32px; padding: 6px; background: rgba(0,0,0,0.3); border-radius: 6px; font-size: 12px;">未装备</div></div>
                <div><div style="font-size: 11px; color: #aaa;">衣服</div><div id="pixelClothesSlot" style="min-height: 32px; padding: 6px; background: rgba(0,0,0,0.3); border-radius: 6px; font-size: 12px;">未装备</div></div>
                <div><div style="font-size: 11px; color: #aaa;">披风</div><div id="pixelCloakSlot" style="min-height: 32px; padding: 6px; background: rgba(0,0,0,0.3); border-radius: 6px; font-size: 12px;">未装备</div></div>
                <div><div style="font-size: 11px; color: #aaa;">裤子</div><div id="pixelPantsSlot" style="min-height: 32px; padding: 6px; background: rgba(0,0,0,0.3); border-radius: 6px; font-size: 12px;">未装备</div></div>
                <div><div style="font-size: 11px; color: #aaa;">鞋子</div><div id="pixelShoesSlot" style="min-height: 32px; padding: 6px; background: rgba(0,0,0,0.3); border-radius: 6px; font-size: 12px;">未装备</div></div>
                <div><div style="font-size: 11px; color: #aaa;">武器</div><div id="pixelWeaponSlot" style="min-height: 32px; padding: 6px; background: rgba(0,0,0,0.3); border-radius: 6px; font-size: 12px;">未装备</div></div>
            </div>
            <div id="pixelPlayerBonus" style="margin-top: 12px; padding: 10px; background: rgba(0,188,212,0.15); border-radius: 8px; font-size: 12px; color: #b0e0e6;"></div>
        </div>
    </div>
    <div style="margin-top: 16px;">
        <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 8px;">
            <span style="font-size: 14px; color: #00BCD4;">时装背包（点击装备）</span>
            <select id="pixelInventoryFilter" onchange="updatePixelPlayerUI()" style="padding: 4px 8px; border-radius: 6px; background: #2a2a4a; color: #00BCD4; border: 1px solid #00BCD4; font-size: 12px;">
                <option value="all">全部</option>
                <option value="helmet">头盔</option>
                <option value="clothes">衣服</option>
                <option value="cloak">披风</option>
                <option value="pants">裤子</option>
                <option value="shoes">鞋子</option>
                <option value="weapon">武器</option>
            </select>
            <button type="button" id="pixelBatchDiscardBtn" onclick="togglePixelBatchDiscardMode()" style="padding: 4px 10px; border-radius: 6px; background: #4a2a2a; color: #ff8888; border: 1px solid #ff6666; cursor: pointer; font-size: 12px;">选择批量丢弃</button>
            <span id="pixelBatchDiscardArea" style="display: none;">
                <button type="button" onclick="confirmPixelBatchDiscard()" style="padding: 4px 10px; border-radius: 6px; background: #8b0000; color: #fff; border: 1px solid #ff4444; cursor: pointer; font-size: 12px;">批量丢弃选中</button>
                <button type="button" onclick="togglePixelBatchDiscardMode()" style="padding: 4px 10px; border-radius: 6px; background: #333; color: #aaa; border: 1px solid #555; cursor: pointer; font-size: 12px;">取消</button>
            </span>
        </div>
        <div id="pixelPlayerInventory" style="max-height: 280px; overflow-y: auto; display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; background: rgba(0,0,0,0.35); border-radius: 10px;"></div>
    </div>
</div>

<!-- 法宝系统UI -->
<div id="magicToolOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="magicToolUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #1a1a2e, #16213e); color: white; padding: 25px; border: 2px solid #FF5722; border-radius: 15px; z-index: 1001; width: 800px; max-height: 85vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid #FF5722;">
        <h2 style="color: #FF5722; margin: 0; text-shadow: 0 2px 5px rgba(0,0,0,0.3); font-size: 28px;">🔮 法宝系统</h2>
        <button onclick="closeMagicToolSystem()" style="background: linear-gradient(45deg, #f44336, #c62828); color: white; border: none; padding: 8px 20px; border-radius: 6px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
    
    <!-- 当前装备的法宝 -->
    <div style="background: linear-gradient(145deg, #2c2c54, #40407a); padding: 20px; border-radius: 12px; margin-bottom: 25px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
        <h3 style="color: #FF5722; margin-top: 0; margin-bottom: 15px; font-size: 20px;">当前装备</h3>
        <div id="equippedMagicTool" style="text-align: center; padding: 20px; background: rgba(255, 87, 34, 0.1); border-radius: 8px; min-height: 80px; display: flex; align-items: center; justify-content: center;">
            未装备任何法宝
        </div>
    </div>
    
    <div style="background: linear-gradient(145deg, #2c2c54, #40407a); padding: 20px; border-radius: 12px; margin-bottom: 25px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
        <h3 style="color: #FF5722; margin-top: 0; margin-bottom: 20px; font-size: 20px;">法宝合成</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1.5fr; gap: 20px;">
            <!-- 左侧：材料选择和合成配方 -->
            <div>
                <!-- 材料选择 -->
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="color: #FFD700; margin-top: 0; margin-bottom: 15px;">材料选择</h4>
                    <div id="magicMaterials" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; max-height: 300px; overflow-y: auto; padding: 5px;">
                        <!-- 材料会通过JS动态生成 -->
                    </div>
                    <div style="margin-top: 10px; color: #aaa; font-size: 12px;">
                        点击材料查看可合成的法宝
                    </div>
                </div>
                
                <!-- 合成配方显示 -->
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px;">
                    <h4 style="color: #4CAF50; margin-top: 0; margin-bottom: 15px;">合成配方</h4>
                    <div id="craftingRecipes" style="min-height: 150px; max-height: 450px; overflow-y: auto; padding: 10px;">
                        <div style="text-align: center; color: #666; padding: 20px;">
                            选择材料查看合成配方
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 右侧：合成预览和操作 -->
            <div style="display: flex; flex-direction: column;">
                <!-- 合成结果预览 -->
                <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 8px; margin-bottom: 15px; flex: 1;">
                    <h4 style="color: #4CAF50; margin-top: 0; margin-bottom: 15px;">合成预览</h4>
                    <div id="magicToolPreview" style="text-align: center; padding: 20px; background: rgba(76, 175, 80, 0.1); border-radius: 8px; min-height: 200px; display: flex; align-items: center; justify-content: center; flex: 1;">
                        <div style="width: 100%;">
                            <div style="font-size: 48px; margin-bottom: 20px;">🔮</div>
                            <div style="font-size: 18px; color: #aaa; margin-bottom: 10px;">法宝合成工坊</div>
                            <div style="color: #666; font-size: 14px;">选择左侧材料开始合成</div>
                        </div>
                    </div>
                </div>
                
                <!-- 操作区域 -->
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px;">
                    <div id="selectedMaterialsInfo" style="color: #aaa; margin-bottom: 10px; min-height: 40px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                        未选择材料
                    </div>
                    <button onclick="craftSelectedTool()" id="craftButton" style="width: 100%; background: #555; color: #888; border: none; padding: 12px; border-radius: 8px; cursor: not-allowed; font-weight: bold; font-size: 16px;" disabled>请选择要合成的法宝</button>
                    <button onclick="clearSelection()" style="width: 100%; background: #666; color: white; border: none; padding: 8px; border-radius: 8px; cursor: pointer; margin-top: 10px;">清空选择</button>
                </div>
            </div>
        </div>
           
          

    
    <!-- 已拥有的法宝 -->
    <div style="background: linear-gradient(145deg, #2c2c54, #40407a); padding: 20px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);">
        <h3 style="color: #FF5722; margin-top: 0; margin-bottom: 15px; font-size: 20px;">我的法宝库</h3>
        <div id="magicToolInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; max-height: 300px; overflow-y: auto; padding: 10px;">
            <!-- 法宝会通过JS动态生成 -->
        </div>
    </div>
</div>
</div>
<!-- 灵根宝箱UI (保持原有样式，稍作美化) -->
<div id="rootBoxOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="rootBoxUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #1a1a2e, #16213e); color: white; padding: 30px; border: 2px solid #FFD700; border-radius: 15px; z-index: 1001; width: 450px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
    <h3 style="color: #FFD700; margin-top: 0; margin-bottom: 15px; font-size: 24px;">🌿 灵根宝箱</h3>
    <p style="color: #aaa; margin-bottom: 20px;">消耗1个灵根检测器开启宝箱</p>
    <div id="rootResult" style="margin: 25px 0; padding: 20px; background: rgba(255, 215, 0, 0.1); border-radius: 10px; font-size: 20px; min-height: 80px; display: flex; align-items: center; justify-content: center;">
        点击开启获取灵根
    </div>
    <div style="display: flex; gap: 10px; justify-content: center;">
        <button onclick="drawRoot()" style="background: linear-gradient(45deg, #FFD700, #FFA000); color: black; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px;">开启宝箱</button>
        <button onclick="closeRootBox()" style="background: linear-gradient(45deg, #f44336, #c62828); color: white; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
</div>

<!-- 血脉宝箱UI (保持原有样式，稍作美化) -->
<div id="bloodlineBoxOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="bloodlineBoxUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #1a1a2e, #16213e); color: white; padding: 30px; border: 2px solid #d4af37; border-radius: 15px; z-index: 1001; width: 450px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
    <h3 style="color: #d4af37; margin-top: 0; margin-bottom: 15px; font-size: 24px;">💉 血脉宝箱</h3>
    <p style="color: #aaa; margin-bottom: 20px;">消耗1个血脉检测剂开启宝箱</p>
    <div id="bloodlineResult" style="margin: 25px 0; padding: 20px; background: rgba(212, 175, 55, 0.1); border-radius: 10px; font-size: 20px; min-height: 80px; display: flex; align-items: center; justify-content: center;">
        点击开启获取血脉
    </div>
    <div style="display: flex; gap: 10px; justify-content: center;">
        <button onclick="drawBloodline()" style="background: linear-gradient(45deg, #d4af37, #b8941f); color: black; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px;">开启宝箱</button>
        <button onclick="closeBloodlineBox()" style="background: linear-gradient(45deg, #f44336, #c62828); color: white; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
</div>

<!-- 五行之力UI (保持原有样式，稍作美化) -->
<div id="fiveElementsOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="fiveElementsUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #8A2BE2; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #8A2BE2;">
        <h2 style="color: #8A2BE2; margin: 0; text-shadow: 0 2px 5px rgba(0,0,0,0.3); font-size: 28px;">🌀 五行之力系统</h2>
        <button onclick="toggleFiveElementsSystem()" style="background: linear-gradient(45deg, #f44336, #c62828); color: white; border: none; padding: 8px 20px; border-radius: 6px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
    
    <!-- 五行之星容器 -->
    <div id="fiveElementsContainer" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; text-align: center;">
        <!-- 动态生成五行元素 -->
    </div>
</div>



<!-- 伴侣探险系统UI -->
<div id="expeditionSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="expeditionSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #9C27B0; margin: 0;">伴侣探险</h2>
        <button onclick="toggleExpeditionSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 探险任务列表 -->
    <div style="margin-bottom: 20px;">
        <h3>探险任务（自动选择最高评分）</h3>
        <div id="expeditionTasks" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 10px;">
            <!-- 任务将动态生成 -->
        </div>
    </div>
    
    <!-- 当前探险状态 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>当前探险（评分有加成倍数）</h3>
        <div id="currentExpedition" style="margin-top: 10px;">
            <p>没有进行中的探险</p>
        </div>
    </div>
    
    <!-- 探险历史记录 -->
    <div style="margin-bottom: 20px;">
        <h3>探险记录</h3>
        <div id="expeditionHistory" style="max-height: 200px; overflow-y: auto; background: #333; padding: 10px; border-radius: 5px;">
            <!-- 记录将动态生成 -->
        </div>
    </div>
</div>
<!-- 藏宝图系统界面 -->
<div id="treasureMapSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureMapSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #d4af37; margin: 0;">藏宝图系统</h2>
        <button onclick="toggleTreasureMapSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 藏宝图钥匙信息 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">藏宝图钥匙</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>当前数量: <span id="treasureKeyCount">0</span></div>
            <button onclick="buyTreasureKey()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换钥匙 (100星尘)</button>
            <button onclick="buyTreasureKey1()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换钥匙 (100星币)</button>
            <button onclick="buyTreasureKey2()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换10个钥匙 (1000星币)</button>
            <button onclick="buyTreasureKey3()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">兑换50个钥匙 (5000星币)</button>
        </div>
    </div>
    
    <!-- 开启藏宝图宝箱 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3 style="color: #d4af37; margin-top: 0;">开启藏宝图宝箱</h3>
        <p>消耗1个藏宝图钥匙随机获得一张藏宝图</p>
        <button onclick="openTreasureChest()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin-top: 10px;">开启宝箱</button>
          <button onclick="openTreasureChestBatch(10)" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开启10次</button>
    <button onclick="openTreasureChestBatch(20)" style="background: #FF9800; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开启20次</button>
    <button onclick="openTreasureChestBatch(50)" style="background: #F44336; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开启50次</button>
        <button onclick="openTreasureShop()" style="background: #9C27B0; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">藏宝图商店</button>
    </div>
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
    <h3 style="color: #d4af37; margin-top: 0;">藏宝图合成</h3>
    <p>将2张同等级同品质的藏宝图合成为1张更高品质的藏宝图</p>
    
    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
        <select id="craftLevel" style="padding: 5px; flex: 1;">
            <option value="1">一级藏宝图</option>
            <option value="2">二级藏宝图</option>
            <option value="3">三级藏宝图</option>
            <option value="4">四级藏宝图</option>
            <option value="5">五级藏宝图</option>
        </select>
        
        <select id="craftQuality" style="padding: 5px; flex: 1;">
            <option value="1">普通</option>
            <option value="2">精良</option>
            <option value="3">稀有</option>
            <option value="4">史诗</option>
            <option value="5">传说</option>
            <!-- 神话品质无法继续合成 -->
        </select>
    </div>
    
    <div style="margin-bottom: 10px;">
        当前拥有: <span id="craftCount">0</span> 张
    </div>
    
    <button onclick="craftTreasureMap()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; width: 100%;">合成</button>
    <button onclick="craftAllTreasureMaps()" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; width: 100%; margin-top: 10px;">一键合成全部</button>
</div>
    <!-- 我的藏宝图 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d4af37; margin-top: 0;">我的藏宝图（开宝图前建议打一下打怪模式刷新属性）</h3>
        <div id="treasureMapList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 300px; overflow-y: auto; padding: 10px; background: #333; border-radius: 5px;">
            <!-- 藏宝图卡片会动态生成在这里 -->
        </div>
    </div>
</div>
<div id="treasureBattleOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureBattleUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #d4af37; border-radius: 10px; z-index: 1001; width: 600px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #d4af37; margin: 0;">宝藏守卫者</h2>
       <div id="treasureBattleStatus" style="color: #4CAF50; font-weight: bold;">战斗中...</div>
    </div>
    
    <div class="player-info">
        <p>生命: <span id="treasurePlayerHealth">0</span></p>
        <p>攻击: <span id="treasurePlayerAttack">0</span></p>
        <p>暴击率: <span id="treasurePlayerCritRate">0%</span></p>
        <p>爆伤: <span id="treasurePlayerCritDamage">0%</span></p>
    </div>
    
    <div class="monster-info">
        <p>怪物名称: <span id="treasureMonsterName">宝藏守卫者</span></p>
        <p>怪物品阶: <span id="treasureMonsterRank">无</span></p>
        <p>怪物生命: <span id="treasureMonsterHealth">0</span></p>
        <p>怪物攻击: <span id="treasureMonsterAttack">0</span></p>
        <p>怪物词条: <span id="treasureMonsterModifiers">无</span></p>
    </div>
    
    <div class="battle-controls">
        <button onclick="attackTreasureMonster()">攻击</button>
    </div>
    
    <div class="battle-log" id="treasureBattleLog" style="margin-top: 20px; height: 100px; overflow-y: auto; background: #333; padding: 10px; border-radius: 5px;"></div>
</div>

<!-- 藏宝图奖励界面 -->
<div id="treasureRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 500px;">
    <h2 style="color: #4CAF50; text-align: center; margin-top: 0;">藏宝图奖励</h2>
    <div id="treasureRewardContent" style="text-align: center; margin: 20px 0;">
        <!-- 奖励内容将在这里显示 -->
    </div>
    <button onclick="closeTreasureReward()" style="background: #2196F3; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; display: block; margin: 0 auto;">关闭</button>
</div>
<!-- 夜店之王系统界面 -->
<div id="nightClubOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="nightClubUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 850px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #9C27B0; padding-bottom: 10px;">
        <h2 style="color: #9C27B0; margin: 0;">夜店之王</h2>
        <button onclick="toggleNightClubSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 店铺信息 -->
    <div style="margin-bottom: 20px; background: #222; padding: 15px; border-radius: 8px; border: 1px solid #444;">
        <div style="display: flex; justify-content: space-between;">
            <div>
                <strong>店铺等级:</strong> <span id="nightClubLevel">1</span>
                <div style="margin-top: 5px;">
                    <div class="progress-bar">
                        <div id="nightClubExpBar" class="progress-fill" style="width: 0%;"></div>
                    </div>
                    <div style="font-size: 0.9em; margin-top: 5px;">
                        经验: <span id="nightClubExp">0</span>/<span id="nightClubExpNext">100</span>
                    </div>
                </div>
            </div>
            <div style="text-align: right;">
                <strong>星币:</strong> <span id="starCoinCount">0</span>
                <div style="margin-top: 5px;">
                    <strong>每分钟收益:</strong>
                    <div>经验: <span id="expPerMinuteq">0</span></div>
                    <div>星币: <span id="coinsPerMinute">0</span></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 标签页 -->
    <div class="nightclub-tabs" style="display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 1px solid #444;">
        <button class="tablink active" onclick="openNightClubTab('staff')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">店员</button>
        <button class="tablink" onclick="openNightClubTab('equipment')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">设备</button>
        <button class="tablink" onclick="openNightClubTab('special')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">特殊人群</button>
        <button class="tablink" onclick="openNightClubTab('events')" style="flex: 1; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">事件</button>
    </div>
    
    <!-- 店员标签页 -->
    <div id="nightClubStaff" class="nightclub-tabcontent">
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <!-- 店员卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 设备标签页 -->
    <div id="nightClubEquipment" class="nightclub-tabcontent" style="display:none;">
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <!-- 设备卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 特殊人群标签页 -->
    <div id="nightClubSpecial" class="nightclub-tabcontent" style="display:none;">
        <div style="background: #222; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <h3 style="margin-top: 0; color: #9C27B0;">VIP客人</h3>
            <p>VIP客人会定期光顾你的夜店，带来大量经验和星币！</p>
            <div id="vipInfo" style="margin-top: 10px;">
                <!-- VIP信息将动态显示 -->
            </div>
        </div>
    </div>
    
    <!-- 事件标签页 -->
    <div id="nightClubEvents" class="nightclub-tabcontent" style="display:none;">
        <div style="background: #222; padding: 15px; border-radius: 8px;">
            <h3 style="margin-top: 0; color: #9C27B0;">当前事件（消耗50-200星币）</h3>
            <div id="currentEvent" style="margin-bottom: 15px;">
                <!-- 当前事件将动态显示 -->
            </div>
            <button onclick="triggerRandomEventa()" style="background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">触发随机事件</button>
        </div>
    </div>
</div>
<!-- 玩家等级系统界面 -->
<div id="levelSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="levelSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1001; width: 500px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #4CAF50; margin: 0;">玩家等级系统</h2>
        <button onclick="toggleLevelSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px;">
        <div>当前等级: <span id="currentPlayerLevel">1</span></div>
        <div>当前经验: <span id="currentPlayerExp">0</span>/<span id="nextLevelExpq">10000</span></div>
        <div>点击收益加成: <span id="clickBonus">0.01%</span></div>
        <div>每秒金币加成: <span id="gpsBonus">0.01</span></div>
         <div>飞升次数: <span id="ascentionCount">0</span></div>
        <div>飞升加成倍数: <span id="ascentionMultiplier">1</span></div>
        <div>下次飞升要求: <span id="nextAscentionRequirement">500</span>级</div>
         <div>轮回转生: <span id="ascentionCounta">0</span></div>
        <div>轮回加成倍数: <span id="ascentionMultipliera">1</span></div>
        <div>下次轮回要求: <span id="nextAscentionRequirementa">500</span>次飞升</div>
    </div>
    
    <div class="exp-bar" style="height: 20px; background: #333; border-radius: 10px; margin: 10px 0;">
        <div id="playerExpProgress" style="height: 100%; background: #4CAF50; border-radius: 10px; width: 0%;"></div>
    </div>
    
    <div style="margin: 15px 0;">
         <button onclick="ascendPlayer()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">飞升</button>
       <button onclick="ascendPlayera()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">轮回</button>
         <button onclick="toggleReincarnationEquipmentUI()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">轮回装备</button> 
      <button onclick="toggleBeastSystem()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">轮回神兽</button>
      <button onclick="toggleWingSystem()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">翅膀</button>
      <button onclick="toggleMountSystem()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">坐骑</button>
     <button onclick="toggleRuneSystem()"  style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-left: 10px;">符文</button>
    </div>
</div>

<!-- 世界地图界面 -->
<div id="worldMapOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="worldMapUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">世界地图</h2> 
        <button onclick="toggleWorldMap()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    <!-- 次元难度选择器 -->
        <div class="dimension-selector">
            <h3>次元难度选择</h3>
            <div>
                <button class="dimension-btn active" onclick="changeDimension(1)">次元1</button>
                <button class="dimension-btn" onclick="changeDimension(2)">次元2</button>
                <button class="dimension-btn" onclick="changeDimension(3)">次元3</button>
                <button class="dimension-btn" onclick="changeDimension(4)">次元4</button>
                <button class="dimension-btn" onclick="changeDimension(5)">次元5</button>
                <button class="dimension-btn" onclick="changeDimension(6)">次元6</button>
                <button class="dimension-btn" onclick="changeDimension(7)">次元7</button>
                <button class="dimension-btn" onclick="changeDimension(8)">次元8</button>
            </div>
            <div class="dimension-info">
                当前难度: <span id="currentDimension">次元1</span><br>
                星币消耗: <span id="dimensionCost">1</span><br>
                经验倍数: <span id="dimensionExpMultiplier">1</span>倍<br>
                怪物攻击: <span id="dimensionAttackMultiplier">1</span>倍
            </div>
        </div>
    <div id="zoneList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
        <!-- 区域列表会动态生成 -->
    </div>
</div>

<!-- 战斗界面 -->
<div id="battleOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="battleUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FF4500; border-radius: 10px; z-index: 1001; width: 600px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FF4500; margin: 0;">战斗</h2>
        <button onclick="closeBattle()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    <div style="color: #FFD700; margin: 0;">
    星币: <span id="battleRebornDanCount">0</span>
    <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
        <div class="player-stats">
            <h3>玩家属性</h3>
            <div>生命: <span id="battlePlayerHealth">0</span></div>
            <div>攻击: <span id="battlePlayerAttack">0</span></div>
            <div>暴击率: <span id="battlePlayerCritRate">0%</span></div>
            <div>爆伤: <span id="battlePlayerCritDamage">0%</span></div>
        </div>
        
        <div class="monster-info">
    <p>怪物名称: <span id="battleMonsterName">无</span></p>
    <p>怪物词条: <span id="battleMonsterModifier">无</span></p>
    <p>怪物生命: <span id="battleMonsterHealth">0</span>/<span id="battleMonsterMaxHealth">0</span></p>
    <p>怪物攻击: <span id="battleMonsterAttack">0</span></p>
    <p>复活次数: <span id="battleMonsterResurrections">0</span>/3</p>
</div>
    </div>
    
    <div class="battle-controls" style="text-align: center; margin: 20px 0;">
<button onclick="toggleWorldMapAutoBattle()" style="background: #4CAF50; color: white; border: none; padding: 8px 20px; border-radius: 5px; cursor: pointer; margin-right: 10px;">
    自动战斗: <span id="worldMapAutoBattleStatus">关闭</span>
</button>
    </div>
    
    <div id="addbattleLog" style="height: 200px; overflow-y: auto; background: #333; padding: 10px; border-radius: 5px; margin-top: 10px;">
        <!-- 战斗日志会动态显示 -->
    </div></div></div>
<!-- 直播系统UI -->
<div id="liveStreamSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="liveStreamSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #0f0f23; color: white; padding: 20px; border: 3px solid #ff00ff; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #ff00ff; padding-bottom: 10px;">
        <h2 style="color: #ff00ff; margin: 0;">直播系统</h2>
        <button onclick="toggleLiveStreamSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 直播状态和等级信息 -->
    <div style="margin-bottom: 20px; background: #1a1a2a; padding: 15px; border-radius: 8px;">
        <div style="display: flex; justify-content: space-between;">
            <div>
                <strong>直播等级:</strong> <span id="liveStreamLevel">1</span>
                <strong>经验:</strong> <span id="liveStreamExp">0</span>/<span id="liveStreamNextExp">100</span>
            </div>
            <div>
                <strong>在线观众:</strong> <span id="liveViewerCount">0</span>
            </div>
            <div>
                <strong>粉丝数:</strong> <span id="totalLiveEarnings">0</span> 
            </div>
        </div>
        <div class="exp-bar" style="margin-top: 10px;">
            <div id="liveExpProgress" class="exp-progress" style="width: 0%;"></div>
        </div>
    </div>
    
    <!-- 直播控制 -->
    <div style="margin-bottom: 20px; text-align: center;">
        <button id="startLiveBtn" onclick="startLiveStream()" style="background: #ff00ff; color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">开始直播</button>
        <button id="boostLiveBtn" onclick="boostLiveStream()" style="background: #2196F3; color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-left: 10px;">推广流量 (1000星币)</button>
        <button id="giftBoxBtn" onclick="openGiftBox()" style="background: linear-gradient(to right, #ff9966, #ff5e62); color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-left: 10px; box-shadow: 0 4px 8px rgba(255, 94, 98, 0.4);">盲盒宝箱</button>
    </div>
    
    <!-- 直播内容区域 -->
    <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
        <!-- 直播窗口 -->
        <div style="background: #000; border-radius: 8px; overflow: hidden; position: relative;">
           <!-- 在直播窗口添加弹幕容器 -->
<div id="liveStreamVideo" style="height: 300px; background: linear-gradient(to bottom, #1a1a2a, #0f0f23); position: relative; overflow: hidden;">
    <div id="liveStatus" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #aaa; text-align: center; z-index: 1;">
        直播未开始
    </div>
    <div id="danmakuContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none;"></div>
</div>

<!-- 在直播控制区域添加弹幕控制 -->
<div style="margin-top: 10px; display: flex; justify-content: space-between;">
    <div>
        <label>
            <input type="checkbox" id="danmakuToggle" checked> 显示弹幕
        </label>
        <label style="margin-left: 10px;">
            速度: <input type="range" id="danmakuSpeed" min="1" max="10" value="5">
        </label>
    </div>
    <div>
        <label>
            密度: <input type="range" id="danmakuDensity" min="1" max="10" value="3">
        </label>
    </div>
</div>
            <div style="padding: 10px; background: #1a1a2a;">
                <h3 style="margin: 0; color: #ff00ff;">我的直播间</h3>
                <div style="display: flex; align-items: center; margin-top: 5px;">
                    <span style="background: #f44336; color: white; padding: 2px 6px; border-radius: 3px; font-size: 12px; margin-right: 10px;">LIVE</span>
                    <span id="liveTopic">转生大陆冒险日记</span>
                </div>
            </div>
        </div>
        
        <!-- 观众列表 -->
        <div style="background: #1a1a2a; border-radius: 8px; padding: 15px;">
            <h3 style="color: #ff00ff; margin-top: 0;">在线观众</h3>
            <div id="viewerList" style="max-height: 320px; overflow-y: auto;">
                <div style="text-align: center; color: #666; padding: 20px 0;">暂无观众</div>
            </div>
        </div>
    </div>
    
    <!-- 弹幕区域 -->
    <div style="margin-top: 20px; background: #1a1a2a; border-radius: 8px; padding: 15px;">
        <h3 style="color: #ff00ff; margin-top: 0;">弹幕互动</h3>
        <div id="danmakuContainerq" style="height: 200px; overflow-y: auto; background: #0a0a1a; border-radius: 5px; padding: 10px; margin-bottom: 10px;">
            <div class="danmaku-message">欢迎来到直播间！发送消息与其他观众互动吧！</div>
        </div>
        <div style="display: flex;">
            <input type="text" id="danmakuInput" placeholder="发送弹幕..." style="flex: 1; padding: 8px; border: 1px solid #444; border-radius: 3px; background: #0a0a1a; color: white;">
            <button onclick="sendDanmaku()" style="background: #ff00ff; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer; margin-left: 10px;">发送</button>
        </div>
    </div>
    
    <!-- 打赏记录 -->
    <div style="margin-top: 20px; background: #1a1a2a; border-radius: 8px; padding: 15px;">
        <h3 style="color: #ff00ff; margin-top: 0;">打赏记录</h3>
        <div id="donationHistory" style="max-height: 150px; overflow-y: auto;">
            <div style="text-align: center; color: #666; padding: 20px 0;">暂无打赏记录</div>
        </div>
    </div>
</div>
<!-- 盲盒宝箱模态框 -->
<div id="giftBoxModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center;">
    <div style="background: #1a1a2a; border-radius: 15px; padding: 30px; width: 80%; max-width: 600px; text-align: center; border: 3px solid #ff9966; box-shadow: 0 0 30px rgba(255, 153, 102, 0.6);">
        <h2 style="color: #ff9966; margin-top: 0;">神秘盲盒宝箱</h2>
        <p style="color: #ccc;">花费 <span style="color: #2196F3; font-weight: bold;">500星币</span> 开启盲盒，有机会获得超值礼物！</p>
        
        <div id="giftBox" style="position: relative; width: 200px; height: 200px; margin: 20px auto; perspective: 1000px;">
            <div id="boxInner" style="position: relative; width: 100%; height: 100%; transform-style: preserve-3d; transition: transform 1s;">
                <div style="position: absolute; width: 100%; height: 100%; backface-visibility: hidden; background: linear-gradient(135deg, #ff9966, #ff5e62); border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 24px; color: white; font-weight: bold; box-shadow: 0 10px 20px rgba(0,0,0,0.3);">
                    <div style="text-align: center;">
                        <div style="font-size: 40px;">🎁</div>
                        <div>点击开启</div>
                    </div>
                </div>
                <div id="giftResult" style="position: absolute; width: 100%; height: 100%; backface-visibility: hidden; background: linear-gradient(135deg, #5c6bc0, #3949ab); border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 24px; color: white; font-weight: bold; transform: rotateY(180deg); flex-direction: column; padding: 20px; box-sizing: border-box;">
                    <div id="giftIcon" style="font-size: 50px; margin-bottom: 15px;">🎁</div>
                    <div id="giftName" style="font-size: 24px; margin-bottom: 10px;">未知礼物</div>
                    <div id="giftValue" style="font-size: 20px;">价值: 0 玫瑰花</div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 20px;">
            <button onclick="drawGift()" style="background: linear-gradient(to right, #ff9966, #ff5e62); color: white; border: none; padding: 10px 30px; border-radius: 30px; cursor: pointer; font-size: 18px; font-weight: bold; box-shadow: 0 4px 8px rgba(255, 94, 98, 0.4);">开启盲盒 (500✨)</button>
            <button onclick="closeGiftBox()" style="background: #555; color: white; border: none; padding: 10px 30px; border-radius: 30px; cursor: pointer; font-size: 18px; margin-left: 15px;">关闭</button>
        </div>
        
        <div style="margin-top: 30px; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px;">
            <h3 style="color: #ff9966; margin-top: 0;">奖品概率</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: left;">
                <div><span style="color: #4CAF50;">鲜花:</span> 70% (10,000)</div>
                <div><span style="color: #2196F3;">墨镜:</span> 19.889% (25,000)</div>
                <div><span style="color: #FFC107;">礼花筒:</span> 7% (50,000)</div>
                <div><span style="color: #E91E63;">比心兔兔:</span> 3% (100,000)</div>
                <div><span style="color: #9C27B0;">热气球:</span> 0.1% (520,000)</div>
                <div><span style="color: #FF5722;">跑车:</span> 0.01% (1,200,000)</div>
                <div><span style="color: #00BCD4;">嘉年华:</span> 0.001% (2,800,000)</div>
            </div>
        </div>
    </div>
</div>
<!-- 翅膀系统界面 -->
<div id="wingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="wingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">翅膀系统</h2>
        <button onclick="toggleWingSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 当前装备的翅膀 -->
    <div id="equippedWing" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 5px;">
        <h3>当前装备的翅膀</h3>
        <div id="currentWingInfo">无</div>
    </div>
    
    <!-- 翅膀等级和升级 -->
    <div style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 5px;">
        <h3>翅膀等级系统</h3>
        <div>当前翅膀等级: <span id="wingLevel">1</span></div>
        <div>翅膀属性加成: <span id="wingBonus">10%</span></div>
        <div>升级所需黑龙王翅膀: <span id="wingUpgradeCost">5</span>个</div>
        <button onclick="upgradeWing()" style="margin-top: 10px;">升级翅膀</button>
    </div>
    
    <!-- 翅膀仓库和筛选功能 -->
    <div style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">翅膀仓库</h3>
            <div>
                <select id="wingRarityFilter" onchange="filterWings()" style="padding: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 3px;">
                    <option value="all">全部品质</option>
                    <option value="劣质级">劣质级</option>
                    <option value="普通级">普通级</option>
                    <option value="优秀级">优秀级</option>
                    <option value="精良级">精良级</option>
                    <option value="卓越级">卓越级</option>
                    <option value="史诗级">史诗级</option>
                    <option value="传说级">传说级</option>
                    <option value="神圣级">神圣级</option>
                    <option value="不朽级">不朽级</option>
                </select>
                <button onclick="decomposeAllFilteredWings()" style="margin-left: 10px; background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">一键分解</button>
            </div>
        </div>
        <div id="wingInventory" style="max-height: 300px; overflow-y: auto; border: 1px solid #555; padding: 10px;">
            <!-- 翅膀列表将在这里显示 -->
        </div>
    </div>
</div>
<!-- 添加坐骑系统界面 -->
<div id="mountSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="mountSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #8B4513; border-radius: 10px; z-index: 1001; width: 700px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #8B4513; margin: 0;">坐骑系统</h2>
        <button onclick="toggleMountSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 当前装备的坐骑 -->
    <div id="equippedMount" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 5px;">
        <h3>当前装备的坐骑</h3>
        <div id="currentMountInfo">无</div>
    </div>
    
    <!-- 坐骑等级和升级 -->
    <div style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 5px;">
        <h3>坐骑等级系统</h3>
        <div>当前坐骑等级: <span id="mountLevel">1</span></div>
        <div>坐骑属性加成: <span id="mountBonus">100%</span></div>
        <div>升级所需远古圣兽精魄: <span id="mountUpgradeCost">5</span>个</div>
        <button onclick="upgradeMount()" style="margin-top: 10px;">升级坐骑</button>
    </div>
    
    <!-- 坐骑仓库和筛选功能 -->
    <div style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">坐骑仓库</h3>
            <div>
                <select id="mountRarityFilter" onchange="filterMounts()" style="padding: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 3px;">
                    <option value="all">全部品质</option>
                    <option value="劣质级">劣质级</option>
                    <option value="普通级">普通级</option>
                    <option value="优秀级">优秀级</option>
                    <option value="精良级">精良级</option>
                    <option value="卓越级">卓越级</option>
                    <option value="史诗级">史诗级</option>
                    <option value="传说级">传说级</option>
                    <option value="神圣级">神圣级</option>
                    <option value="不朽级">不朽级</option>
                </select>
                <button onclick="decomposeAllFilteredMounts()" style="margin-left: 10px; background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">一键分解</button>
            </div>
        </div>
        <div id="mountInventory" style="max-height: 300px; overflow-y: auto; border: 1px solid #555; padding: 10px;">
            <!-- 坐骑列表将在这里显示 -->
        </div>
    </div>
</div>
<!-- 符文系统界面 -->
<div id="runeSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(75, 0, 130, 0.9); z-index: 1020;"></div>
<div id="runeSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #4b0082, #2e0854); color: #e6e6fa; padding: 25px; border: 3px solid #9370db; border-radius: 15px; box-shadow: 0 0 30px #8a2be2, inset 0 0 20px #4b0082; z-index: 1021; width: 800px; max-height: 90vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #9370db; padding-bottom: 10px;">
        <h2 style="color: #e6e6fa; margin: 0; text-shadow: 0 0 10px #8a2be2;">符文系统</h2>
        <button onclick="toggleRuneSystem()" style="background: #9370db; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 材料显示 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d8bfd8; border-bottom: 1px solid #9370db; padding-bottom: 5px;">符文材料</h3>
        <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 10px;">
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #ffd700;">
                <div>金</div>
                <div id="runeMaterialGold">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #32cd32;">
                <div>木</div>
                <div id="runeMaterialWood">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #1e90ff;">
                <div>水</div>
                <div id="runeMaterialWater">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #ff4500;">
                <div>火</div>
                <div id="runeMaterialFire">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #daa520;">
                <div>土</div>
                <div id="runeMaterialEarth">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #f0e68c;">
                <div>光</div>
                <div id="runeMaterialLight">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #483d8b;">
                <div>暗</div>
                <div id="runeMaterialDark">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #87ceeb;">
                <div>风</div>
                <div id="runeMaterialWind">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #add8e6;">
                <div>冰</div>
                <div id="runeMaterialIce">0</div>
            </div>
            <div class="rune-material" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #ffff00;">
                <div>电</div>
                <div id="runeMaterialElectric">0</div>
            </div>
        </div>
    </div>
    
    <!-- 符文合成区域 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d8bfd8; border-bottom: 1px solid #9370db; padding-bottom: 5px;">符文合成</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #9370db;">
                <h4 style="color: #e6e6fa; margin-top: 0;">选择5种材料</h4>
                <div id="runeMaterialSelection" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 10px;">
                    <!-- 材料选择按钮将通过JavaScript动态生成 -->
                </div>
                <button onclick="synthesizeRune()" style="background: linear-gradient(to bottom, #9370db, #6a5acd); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; width: 100%; font-size: 16px;">合成符文</button>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #9370db;">
                <h4 style="color: #e6e6fa; margin-top: 0;">当前选择</h4>
                <div id="selectedMaterials" style="min-height: 100px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; margin-bottom: 10px; border: 1px dashed #9370db;">
                    <!-- 已选材料将显示在这里 -->
                </div>
                <div style="font-size: 12px; color: #d8bfd8;">
                    提示: 选择5种不同材料组合将生成不同属性的符文
                </div>
            </div>
        </div>
    </div>
    
    <!-- 装备的符文 -->
    <div style="margin-bottom: 20px;">
        <h3 style="color: #d8bfd8; border-bottom: 1px solid #9370db; padding-bottom: 5px;">已装备符文</h3>
        <div id="equippedRune" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 2px solid #ffd700; min-height: 100px;">
            <!-- 装备的符文信息将显示在这里 -->
        </div>
    </div>
    
    <!-- 符文背包 -->
    <div style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="color: #d8bfd8; margin: 0;">符文背包</h3>
            <div>
                <button onclick="decomposeAllRunes()" style="background: linear-gradient(to bottom, #dc143c, #8b0000); color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">一键分解</button>
                <button onclick="toggleRuneFilter()" id="runeFilterBtn" style="background: linear-gradient(to bottom, #9370db, #6a5acd); color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">显示全部</button>
            </div>
        </div>
        <div id="runeInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto;">
            <!-- 符文背包内容将通过JavaScript动态生成 -->
        </div>
    </div>
    
    <!-- 符文升级 -->
    <div>
        <h3 style="color: #d8bfd8; border-bottom: 1px solid #9370db; padding-bottom: 5px;">符文升级</h3>
        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 1px solid #9370db;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div>当前符文等级: <span id="runeLevel">1</span></div>
                <div>升级消耗: <span id="runeUpgradeCost">10</span> 个秘法符文</div>
            </div>
            <button onclick="upgradeRune()" id="upgradeRuneBtn" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #4b0082; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; width: 100%; font-size: 16px; font-weight: bold;">升级符文 (提升100%属性)</button>
        </div>
    </div>
</div>










<!-- 在页面底部添加黑龙潭副本的HTML结构 -->
<div id="blackDragonAbyssOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="blackDragonAbyssUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a0825; color: #e0b0ff; padding: 20px; border: 3px solid #8a2be2; border-radius: 10px; box-shadow: 0 0 20px #8a2be2, inset 0 0 10px #4b0082; z-index: 1001; width: 700px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #8a2be2; padding-bottom: 10px;">
        <h2 style="color: #ffd700; margin: 0; text-shadow: 0 0 10px #ffd700;">黑龙潭副本</h2>
        <button onclick="toggleBlackDragonAbyss()" style="background: #8a2be2; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 20px; text-align: center;">
        <div style="font-size: 18px; color: #ff6347; margin-bottom: 10px;">副本令牌: <span id="dungeonTokenCount">0</span></div>
        <button onclick="startBlackDragonBattle()" id="startBattleBtn" style="background: linear-gradient(to bottom, #8b0000, #600000); color: #ffd700; border: 2px solid #ff0000; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; box-shadow: 0 0 10px #ff0000;">挑战黑龙王 (消耗1副本令牌)</button>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div class="battle-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #4b0082;">
            <h3 style="color: #ffd700; margin-top: 0; border-bottom: 1px solid #8a2be2; padding-bottom: 5px;">玩家属性</h3>
            <div>生命: <span id="bdaPlayerHealth">0</span></div>
            <div>攻击: <span id="bdaPlayerAttack">0</span></div>
            <div>暴击率: <span id="bdaPlayerCritRate">0%</span></div>
            <div>爆伤: <span id="bdaPlayerCritDamage">0%</span></div>
        </div>
        
        <div class="boss-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #4b0082;">
            <h3 style="color: #ff6347; margin-top: 0; border-bottom: 1px solid #ff0000; padding-bottom: 5px;">黑龙王属性</h3>
            <div>等级: <span id="bdaBossLevel">1</span></div>
            <div>生命: <span id="bdaBossHealth">0</span>/<span id="bdaBossMaxHealth">0</span></div>
            <div>攻击: <span id="bdaBossAttack">0</span></div>
            <div>复活次数: <span id="bdaBossResurrections">0</span>/10</div>
        </div>
    </div>
    
    <div class="battle-controls" style="text-align: center; margin: 20px 0;">
        <button onclick="attackBlackDragon()" id="attackBossBtn" style="display: none; background: linear-gradient(to bottom, #ff4500, #cc3700); color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px;">攻击</button>
        <button onclick="fleeBlackDragonBattle()" id="fleeBossBtn" style="display: none; background: linear-gradient(to bottom, #6a5acd, #483d8b); color: white; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px;">逃跑</button>
    </div>
    
    <div id="bdaBattleLog" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace;"></div>
</div>

<!-- 奖励弹窗 -->
<div id="bdaRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1010;"></div>
<div id="bdaRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a0825; color: #e0b0ff; padding: 25px; border: 3px solid #ffd700; border-radius: 10px; box-shadow: 0 0 30px #ffd700, inset 0 0 15px #daa520; z-index: 1011; width: 500px; text-align: center;">
    <h2 style="color: #ffd700; margin-top: 0; text-shadow: 0 0 10px #ffd700;">挑战奖励</h2>
    <div style="margin: 20px 0; font-size: 18px;">
        <div>BOSS等级: <span id="rewardBossLevel">1</span></div>
        <div>奖励倍数: <span id="rewardMultiplier">1</span>x</div>
    </div>
    <div id="rewardItems" style="margin: 20px 0; text-align: left; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;"></div>
    <button onclick="closeBdaReward()" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #000; border: none; padding: 10px 25px; border-radius: 5px; cursor: pointer; font-size: 16px;">确认</button>
</div>
<!-- 圣兽岛副本界面 -->
<div id="holyBeastIslandOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(139, 0, 0, 0.9); z-index: 1000;"></div>
<div id="holyBeastIslandUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #8b0000, #450000); color: #ffd700; padding: 25px; border: 3px solid #ff4500; border-radius: 15px; box-shadow: 0 0 30px #ff0000, inset 0 0 20px #8b0000; z-index: 1001; width: 700px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #ff4500; padding-bottom: 10px;">
        <h2 style="color: #ffd700; margin: 0; text-shadow: 0 0 10px #ff0000;">圣兽岛副本</h2>
        <button onclick="toggleHolyBeastIsland()" style="background: #ff4500; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 20px;">
        <div style="font-size: 18px; color: #ff6347; margin-bottom: 10px;">
            副本令牌: <span id="hbiTokenCount">0</span>
        </div>
        <button onclick="startHolyBeastBattle()" id="startHbiBattleBtn" style="background: linear-gradient(to bottom, #ff0000, #8b0000); color: #ffd700; border: 2px solid #ff4500; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; text-shadow: 0 0 5px #ff0000; box-shadow: 0 0 15px #ff0000;">
            挑战上古火麒麟 (消耗1副本令牌)
        </button>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div class="hbi-player-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #ffd700;">
            <h3 style="color: #ffd700; margin-top: 0; border-bottom: 1px solid #ffd700; padding-bottom: 5px;">玩家属性</h3>
            <div>生命: <span id="hbiPlayerHealth">0</span></div>
            <div>攻击: <span id="hbiPlayerAttack">0</span></div>
            <div>暴击率: <span id="hbiPlayerCritRate">0%</span></div>
            <div>爆伤: <span id="hbiPlayerCritDamage">0%</span></div>
        </div>
        
        <div class="hbi-boss-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #ff4500;">
            <h3 style="color: #ff6347; margin-top: 0; border-bottom: 1px solid #ff4500; padding-bottom: 5px;">上古火麒麟</h3>
            <div>等级: <span id="hbiBossLevel">1</span></div>
            <div>生命: <span id="hbiBossHealth">0</span>/<span id="hbiBossMaxHealth">0</span></div>
            <div>攻击: <span id="hbiBossAttack">0</span></div>
            <div>复活次数: <span id="hbiBossResurrections">0</span>/10</div>
        </div>
    </div>
    
    <div class="hbi-battle-controls" style="text-align: center; margin: 20px 0;">
        <button onclick="attackHolyBeastBoss()" id="attackHbiBossBtn" style="display: none; background: linear-gradient(to bottom, #ff4500, #cc3700); color: white; border: none; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px; box-shadow: 0 0 10px #ff4500;">攻击</button>
        <button onclick="fleeHolyBeastBattle()" id="fleeHbiBossBtn" style="display: none; background: linear-gradient(to bottom, #8b0000, #600000); color: white; border: none; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; box-shadow: 0 0 10px #8b0000;">逃跑</button>
    </div>
    
    <div id="hbiBattleLog" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace; border: 1px solid #ff4500;"></div>
</div>

<!-- 圣兽岛奖励弹窗 -->
<div id="hbiRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(139, 0, 0, 0.95); z-index: 1010;"></div>
<div id="hbiRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #8b0000, #450000); color: #ffd700; padding: 30px; border: 3px solid #ffd700; border-radius: 15px; box-shadow: 0 0 40px #ffd700, inset 0 0 20px #daa520; z-index: 1011; width: 550px; text-align: center;">
    <h2 style="color: #ffd700; margin-top: 0; text-shadow: 0 0 15px #ffd700;">挑战奖励</h2>
    <div style="margin: 20px 0; font-size: 18px;">
        <div>BOSS等级: <span id="hbiRewardBossLevel">1</span></div>
        <div>奖励倍数: <span id="hbiRewardMultiplier">1</span>x</div>
    </div>
    <div id="hbiRewardItems" style="margin: 20px 0; text-align: left; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; border: 1px solid #ffd700;"></div>
    <button onclick="closeHbiReward()" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #8b0000; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 0 15px #ffd700;">确认</button>
</div>



<!-- 蓬莱仙岛副本界面 -->
<div id="penglaiIslandOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(75, 0, 130, 0.95); z-index: 1030;"></div>
<div id="penglaiIslandUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #2e0854, #1a0033); color: #d8bfd8; padding: 25px; border: 3px solid #4b0082; border-radius: 15px; box-shadow: 0 0 30px #4b0082, inset 0 0 20px #2e0854; z-index: 1031; width: 700px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #4b0082; padding-bottom: 10px;">
        <h2 style="color: #9370db; margin: 0; text-shadow: 0 0 10px #4b0082; font-family: '楷体', 'KaiTi', serif;">蓬莱仙岛副本</h2>
        <button onclick="togglePenglaiIsland()" style="background: #4b0082; color: #d8bfd8; border: 1px solid #9370db; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
    
    <div style="margin-bottom: 20px;">
        <div style="font-size: 18px; color: #9370db; margin-bottom: 10px; text-shadow: 0 0 5px #4b0082;">
            副本令牌: <span id="penglaiTokenCount" style="color: #ffd700;">0</span>
        </div>
        <button onclick="startPenglaiBattle()" id="startPenglaiBattleBtn" style="background: linear-gradient(to bottom, #4b0082, #2e0854); color: #ffd700; border: 2px solid #9370db; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; text-shadow: 0 0 5px #4b0082; box-shadow: 0 0 15px #4b0082;">
            挑战太古饕鬄 (消耗1副本令牌)
        </button>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div class="penglai-player-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #9370db;">
            <h3 style="color: #9370db; margin-top: 0; border-bottom: 1px solid #9370db; padding-bottom: 5px; text-shadow: 0 0 5px #4b0082;">玩家属性</h3>
            <div style="color: #d8bfd8;">生命: <span id="penglaiPlayerHealth" style="color: #ff6b6b;">0</span></div>
            <div style="color: #d8bfd8;">攻击: <span id="penglaiPlayerAttack" style="color: #ffa500;">0</span></div>
            <div style="color: #d8bfd8;">暴击率: <span id="penglaiPlayerCritRate" style="color: #00ff00;">0%</span></div>
            <div style="color: #d8bfd8;">爆伤: <span id="penglaiPlayerCritDamage" style="color: #ff00ff;">0%</span></div>
        </div>
        
        <div class="penglai-boss-stats" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #8a2be2;">
            <h3 style="color: #8a2be2; margin-top: 0; border-bottom: 1px solid #8a2be2; padding-bottom: 5px; text-shadow: 0 0 5px #4b0082;">太古饕鬄</h3>
            <div style="color: #d8bfd8;">等级: <span id="penglaiBossLevel" style="color: #ffd700;">1</span></div>
            <div style="color: #d8bfd8;">生命: <span id="penglaiBossHealth" style="color: #ff6b6b;">0</span>/<span id="penglaiBossMaxHealth" style="color: #ff6b6b;">0</span></div>
            <div style="color: #d8bfd8;">攻击: <span id="penglaiBossAttack" style="color: #ffa500;">0</span></div>
            <div style="color: #d8bfd8;">复活次数: <span id="penglaiBossResurrections" style="color: #00ff00;">0</span>/10</div>
        </div>
    </div>
    
    <div class="penglai-battle-controls" style="text-align: center; margin: 20px 0;">
        <button onclick="attackPenglaiBoss()" id="attackPenglaiBossBtn" style="display: none; background: linear-gradient(to bottom, #8a2be2, #4b0082); color: #d8bfd8; border: 1px solid #9370db; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px; box-shadow: 0 0 10px #8a2be2;">攻击</button>
        <button onclick="fleePenglaiBattle()" id="fleePenglaiBossBtn" style="display: none; background: linear-gradient(to bottom, #4b0082, #2e0854); color: #d8bfd8; border: 1px solid #9370db; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; box-shadow: 0 0 10px #4b0082;">逃跑</button>
    </div>
    
    <div id="penglaiBattleLog" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace; border: 1px solid #4b0082; color: #d8bfd8;"></div>
</div>

<!-- 蓬莱仙岛奖励弹窗 - 深色版本 -->
<div id="penglaiRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(75, 0, 130, 0.98); z-index: 1040;"></div>
<div id="penglaiRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #2e0854, #1a0033); color: #d8bfd8; padding: 30px; border: 3px solid #9370db; border-radius: 15px; box-shadow: 0 0 40px #9370db, inset 0 0 20px #2e0854; z-index: 1041; width: 550px; text-align: center;">
    <h2 style="color: #9370db; margin-top: 0; text-shadow: 0 0 15px #4b0082; font-family: '楷体', 'KaiTi', serif;">挑战奖励</h2>
    <div style="margin: 20px 0; font-size: 18px;">
        <div style="color: #d8bfd8;">BOSS等级: <span id="penglaiRewardBossLevel" style="color: #ffd700;">1</span></div>
        <div style="color: #d8bfd8;">奖励倍数: <span id="penglaiRewardMultiplier" style="color: #ffd700;">1</span>x</div>
    </div>
    <div id="penglaiRewardItems" style="margin: 20px 0; text-align: left; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; border: 1px solid #9370db; color: #d8bfd8;"></div>
    <button onclick="closePenglaiReward()" style="background: linear-gradient(to bottom, #9370db, #4b0082); color: #ffd700; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 0 15px #9370db;">确认</button>
</div>

<!-- 轮回试炼副本界面（数值同蓬莱仙岛，掉落：30% T1轮回装备+S1轮回宠物，70% 神兽蛋） -->
<div id="lunhuiFubenOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 100, 100, 0.95); z-index: 1030;"></div>
<div id="lunhuiFubenUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #0d3d3d, #0a2525); color: #b8e0e0; padding: 25px; border: 3px solid #20b2aa; border-radius: 15px; box-shadow: 0 0 30px #20b2aa, inset 0 0 20px #0d3d3d; z-index: 1031; width: 700px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #20b2aa; padding-bottom: 10px;">
        <h2 style="color: #20b2aa; margin: 0; text-shadow: 0 0 10px #008b8b; font-family: '楷体', 'KaiTi', serif;">轮回试炼副本</h2>
        <button onclick="toggleLunhuiFuben()" style="background: #008b8b; color: #b8e0e0; border: 1px solid #20b2aa; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
    <div style="margin-bottom: 20px;">
        <div style="font-size: 18px; color: #20b2aa; margin-bottom: 10px;">副本令牌: <span id="lunhuiFubenTokenCount" style="color: #ffd700;">0</span></div>
        <button onclick="startLunhuiFubenBattle()" id="startLunhuiFubenBattleBtn" style="background: linear-gradient(to bottom, #008b8b, #0d3d3d); color: #ffd700; border: 2px solid #20b2aa; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold;">挑战太古混沌 (消耗1副本令牌)</button>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #20b2aa;">
            <h3 style="color: #20b2aa; margin-top: 0; border-bottom: 1px solid #20b2aa; padding-bottom: 5px;">玩家属性</h3>
            <div style="color: #b8e0e0;">生命: <span id="lunhuiFubenPlayerHealth" style="color: #ff6b6b;">0</span></div>
            <div style="color: #b8e0e0;">攻击: <span id="lunhuiFubenPlayerAttack" style="color: #ffa500;">0</span></div>
            <div style="color: #b8e0e0;">暴击率: <span id="lunhuiFubenPlayerCritRate" style="color: #00ff00;">0%</span></div>
            <div style="color: #b8e0e0;">爆伤: <span id="lunhuiFubenPlayerCritDamage" style="color: #ff00ff;">0%</span></div>
        </div>
        <div style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #20b2aa;">
            <h3 style="color: #20b2aa; margin-top: 0; border-bottom: 1px solid #20b2aa; padding-bottom: 5px;">太古混沌</h3>
            <div style="color: #b8e0e0;">等级: <span id="lunhuiFubenBossLevel" style="color: #ffd700;">1</span></div>
            <div style="color: #b8e0e0;">生命: <span id="lunhuiFubenBossHealth">0</span>/<span id="lunhuiFubenBossMaxHealth">0</span></div>
            <div style="color: #b8e0e0;">攻击: <span id="lunhuiFubenBossAttack">0</span></div>
            <div style="color: #b8e0e0;">复活次数: <span id="lunhuiFubenBossResurrections">0</span>/10</div>
        </div>
    </div>
    <div style="text-align: center; margin: 20px 0;">
        <button onclick="attackLunhuiFubenBoss()" id="attackLunhuiFubenBossBtn" style="display: none; background: linear-gradient(to bottom, #20b2aa, #008b8b); color: #fff; border: 1px solid #20b2aa; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px;">攻击</button>
        <button onclick="fleeLunhuiFubenBattle()" id="fleeLunhuiFubenBossBtn" style="display: none; background: linear-gradient(to bottom, #008b8b, #0d3d3d); color: #b8e0e0; border: 1px solid #20b2aa; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px;">逃跑</button>
    </div>
    <div id="lunhuiFubenBattleLog" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace; border: 1px solid #20b2aa; color: #b8e0e0;"></div>
</div>
<div id="lunhuiFubenRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 100, 100, 0.98); z-index: 1040;"></div>
<div id="lunhuiFubenRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #0d3d3d, #0a2525); color: #b8e0e0; padding: 30px; border: 3px solid #20b2aa; border-radius: 15px; box-shadow: 0 0 40px #20b2aa; z-index: 1041; width: 550px; text-align: center;">
    <h2 style="color: #20b2aa; margin-top: 0;">挑战奖励</h2>
    <div style="margin: 20px 0; font-size: 18px;">
        <div style="color: #b8e0e0;">BOSS等级: <span id="lunhuiFubenRewardBossLevel" style="color: #ffd700;">1</span></div>
        <div style="color: #b8e0e0;">奖励倍数: <span id="lunhuiFubenRewardMultiplier" style="color: #ffd700;">1</span>x</div>
    </div>
    <div id="lunhuiFubenRewardItems" style="margin: 20px 0; text-align: left; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; border: 1px solid #20b2aa; color: #b8e0e0;"></div>
    <button onclick="closeLunhuiFubenReward()" style="background: linear-gradient(to bottom, #20b2aa, #008b8b); color: #ffd700; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">确认</button>
</div>

<!-- 轮回仙岛副本界面（数值=蓬莱仙岛×1e3，掉落：20% T2+S2 / 20% 神兽蛋 / 20% 秘法符文 / 20% 黑龙王翅膀 / 20% 远古圣兽精魄） -->
<div id="lunhuiPenglaiOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(75, 0, 130, 0.95); z-index: 1030;"></div>
<div id="lunhuiPenglaiUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #2e0854, #1a0033); color: #d8bfd8; padding: 25px; border: 3px solid #8a2be2; border-radius: 15px; box-shadow: 0 0 30px #8a2be2; z-index: 1031; width: 700px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #8a2be2; padding-bottom: 10px;">
        <h2 style="color: #9370db; margin: 0; font-family: '楷体', 'KaiTi', serif;">轮回仙岛副本</h2>
        <button onclick="toggleLunhuiPenglai()" style="background: #4b0082; color: #d8bfd8; border: 1px solid #9370db; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
    <div style="margin-bottom: 20px;">
        <div style="font-size: 18px; color: #9370db; margin-bottom: 10px;">副本令牌: <span id="lunhuiPenglaiTokenCount" style="color: #ffd700;">0</span></div>
        <button onclick="startLunhuiPenglaiBattle()" id="startLunhuiPenglaiBattleBtn" style="background: linear-gradient(to bottom, #4b0082, #2e0854); color: #ffd700; border: 2px solid #9370db; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold;">挑战太古玄冥 (消耗1副本令牌)</button>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #9370db;">
            <h3 style="color: #9370db; margin-top: 0; border-bottom: 1px solid #9370db; padding-bottom: 5px;">玩家属性</h3>
            <div style="color: #d8bfd8;">生命: <span id="lunhuiPenglaiPlayerHealth" style="color: #ff6b6b;">0</span></div>
            <div style="color: #d8bfd8;">攻击: <span id="lunhuiPenglaiPlayerAttack" style="color: #ffa500;">0</span></div>
            <div style="color: #d8bfd8;">暴击率: <span id="lunhuiPenglaiPlayerCritRate" style="color: #00ff00;">0%</span></div>
            <div style="color: #d8bfd8;">爆伤: <span id="lunhuiPenglaiPlayerCritDamage" style="color: #ff00ff;">0%</span></div>
        </div>
        <div style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #8a2be2;">
            <h3 style="color: #8a2be2; margin-top: 0; border-bottom: 1px solid #8a2be2; padding-bottom: 5px;">太古玄冥</h3>
            <div style="color: #d8bfd8;">等级: <span id="lunhuiPenglaiBossLevel" style="color: #ffd700;">1</span></div>
            <div style="color: #d8bfd8;">生命: <span id="lunhuiPenglaiBossHealth">0</span>/<span id="lunhuiPenglaiBossMaxHealth">0</span></div>
            <div style="color: #d8bfd8;">攻击: <span id="lunhuiPenglaiBossAttack">0</span></div>
            <div style="color: #d8bfd8;">复活次数: <span id="lunhuiPenglaiBossResurrections">0</span>/10</div>
        </div>
    </div>
    <div style="text-align: center; margin: 20px 0;">
        <button onclick="attackLunhuiPenglaiBoss()" id="attackLunhuiPenglaiBossBtn" style="display: none; background: linear-gradient(to bottom, #8a2be2, #4b0082); color: #d8bfd8; border: 1px solid #9370db; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; margin-right: 10px;">攻击</button>
        <button onclick="fleeLunhuiPenglaiBattle()" id="fleeLunhuiPenglaiBossBtn" style="display: none; background: linear-gradient(to bottom, #4b0082, #2e0854); color: #d8bfd8; border: 1px solid #9370db; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px;">逃跑</button>
    </div>
    <div id="lunhuiPenglaiBattleLog" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace; border: 1px solid #4b0082; color: #d8bfd8;"></div>
</div>
<div id="lunhuiPenglaiRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(75, 0, 130, 0.98); z-index: 1040;"></div>
<div id="lunhuiPenglaiRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #2e0854, #1a0033); color: #d8bfd8; padding: 30px; border: 3px solid #9370db; border-radius: 15px; box-shadow: 0 0 40px #9370db; z-index: 1041; width: 550px; text-align: center;">
    <h2 style="color: #9370db; margin-top: 0;">挑战奖励</h2>
    <div style="margin: 20px 0; font-size: 18px;">
        <div style="color: #d8bfd8;">BOSS等级: <span id="lunhuiPenglaiRewardBossLevel" style="color: #ffd700;">1</span></div>
        <div style="color: #d8bfd8;">奖励倍数: <span id="lunhuiPenglaiRewardMultiplier" style="color: #ffd700;">1</span>x</div>
    </div>
    <div id="lunhuiPenglaiRewardItems" style="margin: 20px 0; text-align: left; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; border: 1px solid #9370db; color: #d8bfd8;"></div>
    <button onclick="closeLunhuiPenglaiReward()" style="background: linear-gradient(to bottom, #9370db, #4b0082); color: #ffd700; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">确认</button>
</div>















<!-- 老虎机界面 -->
<div id="slotMachineOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; backdrop-filter: blur(5px);"></div>
<div id="slotMachineUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #8B0000, #B22222); color: white; padding: 20px; border: 5px solid #FFD700; border-radius: 15px; z-index: 1001; width: 500px; box-shadow: 0 0 20px rgba(255,215,0,0.5);">
<button onclick="toggleSlotMachine()" style="background: #4b0082; color: #d8bfd8; border: 1px solid #9370db; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    <div style="text-align: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin: 0;">幸运老虎机</h2>
        <div style="color: #FFD700; font-size: 14px;">使用星尘发票赢取更多奖励！</div>
    </div>
    
    <!-- 余额和下注控制 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
        <div>
            <span style="color: #FFD700;">星尘发票: </span>
            <span id="slotMachineBalance">0</span>
        </div>
        <div>
            <span style="color: #FFD700;">下注: </span>
            <button onclick="changeBet(-1)" style="background: #444; color: white; border: none; width: 30px; height: 30px; border-radius: 15px; margin: 0 5px;">-</button>
            <span id="currentBet">10</span>
            <button onclick="changeBet(1)" style="background: #444; color: white; border: none; width: 30px; height: 30px; border-radius: 15px; margin: 0 5px;">+</button>
        </div>
    </div>
    
    <!-- 老虎机转轴 -->
    <div id="slotReels" style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; perspective: 1000px;">
        <div class="reel-container" style="position: relative; width: 100px; height: 300px; background: #000; border: 3px solid #FFD700; border-radius: 10px; overflow: hidden; transform-style: preserve-3d;">
            <div class="reel" id="reel1" style="position: absolute; width: 100%; transition: top 3s cubic-bezier(0.17, 0.67, 0.83, 0.67);">
                <!-- 符号将通过JavaScript动态生成 -->
            </div>
        </div>
        <div class="reel-container" style="position: relative; width: 100px; height: 300px; background: #000; border: 3px solid #FFD700; border-radius: 10px; overflow: hidden; transform-style: preserve-3d;">
            <div class="reel" id="reel2" style="position: absolute; width: 100%; transition: top 3s cubic-bezier(0.17, 0.67, 0.83, 0.67);">
                <!-- 符号将通过JavaScript动态生成 -->
            </div>
        </div>
        <div class="reel-container" style="position: relative; width: 100px; height: 300px; background: #000; border: 3px solid #FFD700; border-radius: 10px; overflow: hidden; transform-style: preserve-3d;">
            <div class="reel" id="reel3" style="position: absolute; width: 100%; transition: top 3s cubic-bezier(0.17, 0.67, 0.83, 0.67);">
                <!-- 符号将通过JavaScript动态生成 -->
            </div>
        </div>
    </div>
    
    <!-- 控制按钮 -->
    <div style="display: flex; justify-content: center; gap: 15px;">
        <button id="spinButton" onclick="spinSlotMachine()" style="background: linear-gradient(45deg, #FFD700, #FF8C00); color: black; border: none; padding: 12px 25px; border-radius: 25px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">旋转</button>
        <button id="autoSpinButton" onclick="toggleAutoSpin()" style="background: #444; color: white; border: none; padding: 12px 25px; border-radius: 25px; font-weight: bold; cursor: pointer;">自动旋转: 关闭</button>
    </div>
    
    <!-- 中奖信息和历史记录 -->
    <div style="margin-top: 20px;">
        <div id="slotResult" style="text-align: center; min-height: 40px; font-weight: bold; color: #FFD700;"></div>
        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; max-height: 100px; overflow-y: auto;">
            <div style="color: #FFD700; margin-bottom: 5px;">最近结果:</div>
            <div id="slotHistory"></div>
        </div>
    </div>
    
    <!-- 赔率表 -->
    <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
        <div style="color: #FFD700; margin-bottom: 5px;">赔率表:</div>
        <div style="font-size: 12px; line-height: 1.4;">
            <div>🍒🍒🍒: 5倍</div>
            <div>🍋🍋🍋: 10倍</div>
            <div>🍊🍊🍊: 15倍</div>
            <div>🍇🍇🍇: 20倍</div>
            <div>🍉🍉🍉: 25倍</div>
            <div>🍎🍎🍎: 50倍</div>
            <div>7️⃣7️⃣7️⃣: 100倍 Jackpot!</div>
        </div>
    </div>
</div>






<!-- 时光秘境主界面 -->
<div id="timeSecretRealmOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 105, 148, 0.95); z-index: 1050;"></div>
<div id="timeSecretRealmUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #006994, #004d73); color: #e6f7ff; padding: 25px; border: 3px solid #00bfff; border-radius: 15px; box-shadow: 0 0 30px #00bfff, inset 0 0 20px #006994; z-index: 1051; width: 800px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #00bfff; padding-bottom: 10px;">
        <h2 style="color: #e6f7ff; margin: 0; text-shadow: 0 0 10px #00bfff;">时光秘境</h2>
        <button onclick="toggleTimeSecretRealm()" style="background: #00bfff; color: #004d73; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
      <!-- 在这里添加难度选择区域 -->
    <div id="tsrDifficultySelection" style="margin-bottom: 20px;">
        <h3 style="color: #00bfff; border-bottom: 1px solid #00bfff; padding-bottom: 5px; margin-bottom: 10px;">难度选择</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 15px;">
            <button onclick="selectTsrDifficulty('easy')" id="difficultyEasy" class="difficulty-btn" style="background: linear-gradient(to bottom, #32cd32, #228b22); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">简单</button>
            <button onclick="selectTsrDifficulty('normal')" id="difficultyNormal" class="difficulty-btn" style="background: linear-gradient(to bottom, #1e90ff, #006994); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">普通</button>
            <button onclick="selectTsrDifficulty('hard')" id="difficultyHard" class="difficulty-btn" style="background: linear-gradient(to bottom, #ffa500, #daa520); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">困难</button>
            <button onclick="selectTsrDifficulty('nightmare')" id="difficultyNightmare" class="difficulty-btn" style="background: linear-gradient(to bottom, #ff4500, #cc3700); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">噩梦</button>
            <button onclick="selectTsrDifficulty('hell')" id="difficultyHell" class="difficulty-btn" style="background: linear-gradient(to bottom, #8b0000, #600000); color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-weight: bold;">地狱</button>
        </div>
        <div id="tsrDifficultyInfo" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff; font-size: 14px;">
            <div id="difficultyDescription">选择难度开始冒险</div>
            <div id="difficultyUnlockCondition" style="font-size: 12px; color: #d8bfd8; margin-top: 5px;"></div>
        </div>
    </div>
<!-- 开始冒险按钮 -->
<button onclick="startTimeSecretRealm()" id="startTsrBtn" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #004d73; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold; margin: 10px 0;">开始冒险</button>
    <!-- 秘境信息显示 -->
    <div style="margin-bottom: 20px;">
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px;">
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">秘境币</div>
                <div id="tsrCurrency" style="font-size: 18px; color: #ffd700;">0</div>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">最佳层数</div>
                <div id="tsrBestFloor" style="font-size: 18px; color: #ffd700;">0</div>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">通关次数</div>
                <div id="tsrClearCount" style="font-size: 18px; color: #ffd700;">0</div>
            </div>
        </div>
    </div>

    <!-- 秘境控制区域 -->
    <div style="margin-bottom: 20px;">
      
        <button onclick="openTsrShop()" id="openTsrShopBtn" style="background: linear-gradient(to bottom, #ffd700, #daa520); color: #004d73; border: 2px solid #ffd700; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; text-shadow: 0 0 5px #ffd700; box-shadow: 0 0 15px #ffd700; margin-left: 10px;">
            秘境商店
        </button>
    </div>
    <!-- 秘境状态显示 -->
    <div id="tsrStatusDisplay" style="display: none; margin-bottom: 20px;">
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px;">
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">当前层数</div>
                <div id="tsrCurrentFloor" style="font-size: 16px; color: #ffd700;">1</div>
            </div>
          <div id="tsrBuffsDisplay" style="display: none; margin-bottom: 20px;">
    <h3 style="color: #90ee90; border-bottom: 1px solid #90ee90; padding-bottom: 5px; margin-bottom: 10px;">当前增益效果</h3>
    <div id="tsrCurrentBuffs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; max-height: 150px; overflow-y: auto;"></div>
</div>
<div id="tsrHealthBar" style="display: none; margin-bottom: 15px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
        <span style="color: #ff6b6b; font-weight: bold;">生命值:</span>
        <span id="tsrHealthText" style="color: #ff6b6b; font-weight: bold;">100%</span>
    </div>
    <div style="width: 100%; height: 20px; background: rgba(255, 107, 107, 0.2); border-radius: 10px; overflow: hidden;">
        <div id="tsrHealthBarFill" style="height: 100%; background: linear-gradient(to right, #ff6b6b, #ff0000); border-radius: 10px; transition: width 0.3s ease; width: 100%;"></div>
    </div>
    <div style="font-size: 11px; color: #ff6b6b; text-align: center; margin-top: 3px;">
        <span id="tsrHealthWarning" style="display: none;">⚠️ 生命值低于30%，危险！</span>
    </div>
</div>
<div id="tsrSkillsDisplay" style="display: none; margin-bottom: 20px;">
    <h3 style="color: #00bfff; border-bottom: 1px solid #00bfff; padding-bottom: 5px; margin-bottom: 10px;">陷阱技能</h3>
    <div id="tsrCurrentSkills" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;"></div>
</div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">剩余时间</div>
                <div id="tsrTimeLeft" style="font-size: 16px; color: #ff6b6b;">300秒</div>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">临时强化</div>
                <div id="tsrTempBuffs" style="font-size: 16px; color: #90ee90;">0个</div>
            </div>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; border: 1px solid #00bfff;">
                <div style="color: #00bfff;">秘境币</div>
                <div id="tsrCurrentCurrency" style="font-size: 16px; color: #ffd700;">0</div>
            </div>
        </div>
    </div>
    
    <!-- 秘境房间显示 -->
    <div id="tsrRoomDisplay" style="display: none; margin-bottom: 20px;">
        <h3 style="color: #00bfff; margin-bottom: 10px;">当前房间</h3>
        <div id="tsrCurrentRoom" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; border: 2px solid #00bfff; min-height: 100px;"></div>
    </div>
    
    <!-- 秘境行动控制 -->
    <div id="tsrActionControls" style="display: none; margin-bottom: 20px;">
        <div style="display: flex; justify-content: center; gap: 10px;">
            <button onclick="tsrExploreRoom()" id="tsrExploreBtn" style="background: linear-gradient(to bottom, #32cd32, #228b22); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">探索房间</button>
            <button onclick="tsrRest()" id="tsrRestBtn" style="background: linear-gradient(to bottom, #1e90ff, #006994); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">休息恢复</button>
            <button onclick="tsrNextFloor()" id="tsrNextFloorBtn" style="background: linear-gradient(to bottom, #ffa500, #daa520); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">前往下一层</button>
            <button onclick="tsrExitRealm()" id="tsrExitBtn" style="background: linear-gradient(to bottom, #dc143c, #8b0000); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">退出秘境</button>
        </div>
    </div>
    
    <!-- 秘境日志 -->
    <div id="tsrLogContainer" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; margin-top: 10px; border: 1px solid #00bfff;">
        <div id="tsrBattleLog" style="font-family: monospace; color: #e6f7ff;"></div>
    </div>
</div>

<!-- 时光秘境商店 -->
<div id="tsrShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 105, 148, 0.98); z-index: 1060;"></div>
<div id="tsrShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #006994, #004d73); color: #e6f7ff; padding: 30px; border: 3px solid #ffd700; border-radius: 15px; box-shadow: 0 0 40px #ffd700, inset 0 0 20px #006994; z-index: 1061; width: 700px; text-align: center;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #ffd700; margin: 0; text-shadow: 0 0 15px #ffd700;">秘境商店</h2>
        <button onclick="closeTsrShop()" style="background: #00bfff; color: #004d73; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">关闭</button>
    </div>
    
    <div style="margin-bottom: 20px; font-size: 18px;">
        <span style="color: #00bfff;">秘境币: </span>
        <span id="tsrShopCurrency" style="color: #ffd700; font-weight: bold;">0</span>
    </div>
     <!-- 新增：永久加成显示区域 -->
    <div id="tsrPermanentBonuses" style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 5px; border: 1px solid #00bfff; margin-bottom: 20px;">
        <div style="color: #888; text-align: center;">暂无永久加成</div>
    </div>
    <div id="tsrShopItems" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 400px; overflow-y: auto;"></div>
</div>
  <div id="worldBossUI">
        <button class="boss-close-button" onclick="toggleWorldBossUI()">×</button>
        <div class="boss-summon-count">
    召唤: <span id="bossSummonCount">1</span>/10
    <br>
    下次恢复: <span id="summonCountdown">00:00:00</span>
</div>
        <h3>世界BOSS系统</h3>
        
        <div class="boss-section">
            <div class="boss-section-title">BOSS状态</div>
            <div class="boss-name" id="bossName">未召唤BOSS</div>
            <div class="boss-world" id="bossWorld"></div>
            <div class="boss-stars" id="bossStars"></div>
            <div class="boss-health-bar" id="bossHealthBar">
                <div class="boss-health-fill" id="bossHealthFill"></div>
                <div class="boss-health-text" id="bossHealthText">0/0</div>
            </div>
            <div class="boss-time-left" id="bossTimeLeft">剩余: 未开始</div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">你的状态</div>
            <div class="boss-info">攻击: <span id="playerBossAttack">0</span></div>
            <div class="boss-info">连击: <span id="playerBossMultiAttack">0</span></div>
            <div class="boss-info">暴击: <span id="playerBossCritRate">0%</span></div>
            <div class="boss-info">爆伤: <span id="playerBossCritDamage">0%</span></div>
            <div class="boss-info">伤害: <span id="playerBossDamage">0</span></div>
            <div class="boss-info">当前排行: <span id="playerBossRank">未排名</span></div>
            <div style="text-align: center; margin-top: 8px;">
                <button class="boss-button" id="bossAttackButton" onclick="attackBoss()">攻击</button>
                <button class="boss-button" id="bossAutoAttackButton" onclick="toggleAutoAttackBoss()">自动</button>
                <button class="boss-button" id="bossSummonButton" onclick="summonBoss()">召唤</button>
            </div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">排行榜</div>
            <div class="boss-rankings" id="bossRankings">
                <div>尚未开始战斗</div>
            </div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">战斗记录</div>
            <div class="boss-battle-log" id="bossBattleLog"></div>
        </div>
        
        <div class="boss-section">
            <div class="boss-section-title">奖励</div>
            <div class="boss-rewards">
                <div class="boss-reward-tier">
                    <h4>第1名</h4>
                    <div>5神级宝石</div>
                    <div>30000转生币</div>
                </div>
                <div class="boss-reward-tier">
                    <h4>第2-10名</h4>
                    <div>5极品宝石</div>
                    <div>10000转生币</div>
                </div>
                <div class="boss-reward-tier">
                    <h4>第11-30名</h4>
                    <div>3高级宝石</div>
                    <div>5000转生币</div>
                </div>
                <div class="boss-reward-tier">
                    <h4>参与奖</h4>
                    <div>1初级宝石</div>
                    <div>100转生币</div>
                </div>
            </div>
        </div>
    </div>
    <div id="bossOverlay"></div>
<!-- 新增宝石商店模态框 -->
<div id="treasureShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #9C27B0; margin: 0;">藏宝图商店</h2>
        <button onclick="closeTreasureShop()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px; text-align: center; font-size: 18px;">
        当前宝藏金币: <span id="currentPrimaryGemqCount" style="color: #FFD700; font-weight: bold;">0</span>
    </div>
    
    <div style="display: grid; grid-template-columns: 1fr; gap: 15px;">
        <!-- 兑换选项1: 50玫瑰花 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #e91e63;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #e91e63;">玫瑰花束</h4>
                    <p style="margin: 0;">兑换50朵玫瑰花</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(1)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项2: VIP能力值 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">VIP能力值</h4>
                    <p style="margin: 0;">兑换10点VIP能力值</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(2)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项3: 鱼饵 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #4CAF50;">鱼饵</h4>
                    <p style="margin: 0;">兑换1个鱼饵</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(3)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项4: 伴侣钥匙 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #FF9800;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #FF9800;">伴侣钥匙</h4>
                    <p style="margin: 0;">兑换1把伴侣钥匙</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">2</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(4)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项5: 灵根检测器 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #9C27B0;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #9C27B0;">灵根检测器</h4>
                    <p style="margin: 0;">兑换1个灵根检测器</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">5</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(5)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项6: 血脉检测剂 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #673AB7;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #673AB7;">血脉检测剂</h4>
                    <p style="margin: 0;">兑换1个血脉检测剂</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">5</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(6)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
        
        <!-- 兑换选项7: 进阶神石 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F44336;">进阶神石</h4>
                    <p style="margin: 0;">兑换1个进阶神石</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">20</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(7)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
     <!-- 兑换选项9: 副本令牌 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F34336;">副本令牌</h4>
                    <p style="margin: 0;">兑换1个副本令牌</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">10</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(9)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
      <!-- 兑换选项10: 职业转换书 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F91336;">职业转换书</h4>
                    <p style="margin: 0;">兑换1个职业转换书</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">10</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(10)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
          <!-- 兑换选项10: 职业转换书 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F91336;">深渊令牌</h4>
                    <p style="margin: 0;">兑换3个深渊令牌</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">1</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(11)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
  <!-- 兑换选项7: 宗门令牌 -->
        <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #F44336;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4 style="margin: 0 0 5px 0; color: #F54336;">宗门令牌</h4>
                    <p style="margin: 0;">兑换1个宗门令牌</p>
                </div>
                <div style="text-align: right;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 5px;">
                        <span style="margin-right: 5px;">消耗:</span>
                        <span class="gem-cost" style="color: #FFD700; font-weight: bold;">50</span>
                        <span class="gem-icon" style="display: inline-block; width: 20px; height: 20px; background: linear-gradient(to bottom, #FFD700, #B8860B); border-radius: 50%; margin-left: 5px;"></span>
                    </div>
                    <button onclick="exchangeItem(8)" class="exchange-btn">兑换</button>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- 宗门系统界面 -->
<div id="sectSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="sectSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #8B4513; border-radius: 10px; z-index: 1001; width: 850px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #8B4513; padding-bottom: 10px;">
        <h2 style="color: #8B4513; margin: 0;">宗门系统</h2>
        <button onclick="toggleSectSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 宗门信息区域 -->
    <div id="sectInfoContainer" style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <!-- 宗门信息将动态生成 -->
    </div>
    
    <!-- 标签页导航 -->
    <div class="sect-tabs" style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 15px; border-bottom: 1px solid #444;">
        <button class="sect-tablink active" onclick="openSectTab('members', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">成员管理</button>
        <button class="sect-tablink" onclick="openSectTab('missions', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">任务派遣</button>
        <button class="sect-tablink" onclick="openSectTab('techniques', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">功法库</button>
        <button class="sect-tablink" onclick="openSectTab('tribute', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">供奉殿</button>
        <button class="sect-tablink" onclick="openSectTab('trial', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">试炼塔</button>
        <button class="sect-tablink" onclick="openSectTab('library', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">藏经阁</button>
        <button class="sect-tablink" onclick="openSectTab('shop', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">声望商店</button>
        <button class="sect-tablink" onclick="openSectTab('grotto', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">洞府</button>
        <button class="sect-tablink" onclick="openSectTab('transmit', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">传功殿</button>
        <button class="sect-tablink" onclick="openSectTab('spiritpool', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">灵泉池</button>
        <button class="sect-tablink" onclick="openSectTab('enlightenment', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">悟道台</button>
        <button class="sect-tablink" onclick="openSectTab('settings', event)" style="flex: 1; min-width: 70px; background: #333; color: white; border: none; padding: 8px; border-radius: 5px 5px 0 0; cursor: pointer;">宗门设置</button>
    </div>
    
    <!-- 成员管理标签页 -->
    <div id="sectMembers" class="sect-tabcontent">
        <div style="margin-bottom: 15px;">
            <button onclick="recruitMember()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">招募弟子</button>
            <span>消耗: <span id="recruitCost">100</span> 灵石</span>
        </div>
        <div id="memberList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; max-height: 300px; overflow-y: auto;">
            <!-- 成员卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 任务派遣标签页 -->
    <div id="sectMissions" class="sect-tabcontent" style="display:none;">
    <div style="margin-bottom: 15px;">
        <button onclick="startAllAvailableMissions()" style="background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">一键派遣所有任务</button>
          <button onclick="recallAllMissions()" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;" title="立即召回所有弟子，但不会获得奖励">一键召回</button>
        <span style="font-size: 0.9em;">自动派遣符合条件的弟子执行所有可接任务</span>
    </div>
        <div id="missionList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
            <!-- 任务卡片将动态生成 -->
        </div>
        <div id="activeMissions" style="background: #333; padding: 15px; border-radius: 8px;">
            <h3 style="color: #8B4513; margin-top: 0;">进行中的任务</h3>
            <div id="activeMissionList">
                <!-- 进行中的任务将动态生成 -->
            </div>
        </div>
    </div>
    
    <!-- 功法库标签页 -->
    <div id="sectTechniques" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px;">
            <button onclick="upgradeAllTechniques()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">一键升级所有功法</button>
            <span>消耗: <span id="upgradeAllCost">1000</span> 灵石</span>
        </div>
        <div id="techniqueList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-height: 300px; overflow-y: auto;">
            <!-- 功法卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 供奉殿标签页 -->
    <div id="sectTribute" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px; background: #333; padding: 15px; border-radius: 8px;">
            <h4 style="color: #8B4513; margin-top: 0;">灵石供奉与兑换</h4>
            <p style="font-size: 0.9em;">宗门灵石与玩家灵石互通，供奉可获得宗门祝福加成</p>
            <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-top: 10px;">
                <div>玩家灵石: <span id="tributePlayerStones" style="color: #FFD700;">0</span></div>
                <div>宗门灵石: <span id="tributeSectStones" style="color: #FFD700;">0</span></div>
            </div>
            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                <input type="number" id="tributeAmount" min="1" value="1000" style="width: 100px; padding: 5px; background: #444; color: white; border: 1px solid #666;">
                <button onclick="tributeToSect()" style="background: #4CAF50;">供奉入宗门</button>
                <button onclick="withdrawFromSect()" style="background: #2196F3;">从宗门提取</button>
            </div>
            <p style="font-size: 0.85em; color: #999; margin-top: 10px;">供奉：玩家灵石→宗门灵石 | 提取：宗门灵石→玩家灵石（1:1）</p>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 8px;">
            <h4 style="color: #8B4513; margin-top: 0;">宗门祝福</h4>
            <p>累计供奉总额: <span id="tributeTotal" style="color: #4CAF50;">0</span> 灵石</p>
            <p>祝福加成: 每供奉1万灵石，GPS+1%（当前: <span id="tributeBonusPercent">0</span>%）</p>
        </div>
    </div>
    
    <!-- 试炼塔标签页 -->
    <div id="sectTrial" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px; background: #333; padding: 15px; border-radius: 8px;">
            <h4 style="color: #8B4513; margin-top: 0;">宗门试炼塔</h4>
            <p style="font-size: 0.9em;">空闲弟子可自动参与试炼，获得额外宗门声望与灵石</p>
            <label style="display: flex; align-items: center; gap: 10px; margin-top: 10px;">
                <input type="checkbox" id="trialAutoToggle" onchange="toggleSectTrialAuto()"> 自动试炼（空闲弟子每6小时获得一次奖励）
            </label>
            <div style="margin-top: 15px;">
                <button id="trialRunBtn" onclick="runSectTrial()" style="background: #9C27B0; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">立即试炼</button>
                <span style="margin-left: 10px; font-size: 0.9em;">下次可试炼: <span id="trialNextTime">--</span></span>
                <div id="trialCooldownHint" style="font-size: 0.85em; color: #999; margin-top: 5px;"></div>
            </div>
            <p style="font-size: 0.85em; margin-top: 10px;">奖励: 每名空闲弟子 1000声望 + 宗门等级×5000 灵石</p>
        </div>
    </div>
    
    <!-- 藏经阁标签页 -->
    <div id="sectLibrary" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px; background: #333; padding: 15px; border-radius: 8px;">
            <h4 style="color: #8B4513; margin-top: 0;">传承功法</h4>
            <p style="font-size: 0.9em;">五项传承独立升级，每项10级，消耗=100万×目标等级，加成【年兽副本】【试练塔】等修仙副本</p>
            <div id="libraryActiveBonus" style="margin-top: 10px; padding: 8px; background: #2a2a2a; border-radius: 5px; font-size: 0.9em; color: #4CAF50;"></div>
        </div>
        <div id="libraryList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <!-- 传承功法卡片将动态生成 -->
        </div>
    </div>
    
    <!-- 声望商店标签页 -->
    <div id="sectShop" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px;">
            <p>当前宗门声望: <span id="shopSectExp" style="color: #FFD700; font-weight: bold;">0</span></p>
        </div>
        <div id="sectShopList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <!-- 商店商品将动态生成 -->
        </div>
    </div>
    
    <!-- 洞府标签页 -->
    <div id="sectGrotto" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px; background: #333; padding: 15px; border-radius: 8px;">
            <h4 style="color: #8B4513; margin-top: 0;">聚灵阵</h4>
            <p style="font-size: 0.9em;">每级提升修仙经验获取+10%，每5级灵田+1位置（初始3个）</p>
            <div style="margin-top: 10px;">当前等级: <span id="grottoSpiritArrayLevel" style="color: #4CAF50; font-weight: bold;">0</span> / 100</div>
            <div>当前修仙经验加成: <span id="grottoExpBonus" style="color: #FFD700;">0%</span></div>
            <div style="margin-top: 8px;">下一级消耗: <span id="grottoUpgradeCost" style="color: #FF9800;">100万</span> 宗门灵石</div>
            <button id="grottoUpgradeBtn" onclick="upgradeGrottoSpiritArray()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-top: 8px;">升级聚灵阵</button>
        </div>
        <div style="margin-bottom: 15px; background: #333; padding: 15px; border-radius: 8px;">
            <h4 style="color: #8B4513; margin-top: 0;">灵田</h4>
            <p style="font-size: 0.9em;">种植草药收获丹药，种子可在声望商店兑换</p>
            <div style="margin-top: 8px;">灵田位置: <span id="grottoFieldCount" style="color: #4CAF50;">0</span> / <span id="grottoMaxFields">3</span></div>
        </div>
        <div id="grottoSpiritFields" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
            <!-- 灵田格子将动态生成 -->
        </div>
    </div>
    
    <!-- 传功殿标签页：弟子传功给掌门修仙经验 -->
    <div id="sectTransmit" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px; background: #333; padding: 15px; border-radius: 8px;">
            <h4 style="color: #4CAF50; margin-top: 0;">⚡ 传功殿</h4>
            <p style="font-size: 0.9em;">空闲弟子可将自身修为传予掌门，消耗宗门灵石，获得修仙经验。资质越高传功效果越好。</p>
            <div style="margin-top: 10px;">宗门灵石: <span id="transmitSectStones" style="color: #FFD700;">0</span></div>
            <div style="margin-top: 8px;">当前修仙经验: <span id="transmitCultivationExp" style="color: #4CAF50;">0</span></div>
        </div>
        <div id="transmitMemberList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
            <!-- 可传功弟子列表动态生成 -->
        </div>
    </div>
    
    <!-- 灵泉池标签页：消耗灵石浸泡获得修仙经验 -->
    <div id="sectSpiritpool" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px; background: #333; padding: 15px; border-radius: 8px;">
            <h4 style="color: #2196F3; margin-top: 0;">💧 灵泉池</h4>
            <p style="font-size: 0.9em;">在宗门灵泉池中浸泡可吸收灵气，直接转化为修仙经验。宗门等级和聚灵阵等级越高，收益越大。</p>
            <div style="margin-top: 10px;">消耗: <span id="spiritPoolCost" style="color: #FF9800;">500000</span> 宗门灵石</div>
            <div style="margin-top: 5px;">预计获得: <span id="spiritPoolReward" style="color: #4CAF50;">0</span> 修仙经验</div>
            <div style="margin-top: 5px;">冷却: 12小时（下次可浸泡: <span id="spiritPoolNext">--</span>）</div>
            <button id="spiritPoolBtn" onclick="useSpiritPool()" style="background: #2196F3; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">浸泡灵泉</button>
        </div>
    </div>
    
    <!-- 悟道台标签页：挂机悟道获得修仙经验 -->
    <div id="sectEnlightenment" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px; background: #333; padding: 15px; border-radius: 8px;">
            <h4 style="color: #9C27B0; margin-top: 0;">🧘 悟道台</h4>
            <p style="font-size: 0.9em;">在悟道台静心悟道，消耗宗门灵石开启悟道状态，持续获得修仙经验（受聚灵阵与宗门等级加成）。</p>
            <div id="enlightenmentStatus" style="margin-top: 10px; padding: 10px; background: #2a2a2a; border-radius: 5px;"></div>
            <div style="margin-top: 10px;">消耗: <span id="enlightenmentCost" style="color: #FF9800;">200000</span> 宗门灵石 | 持续时间: 2小时</div>
            <button id="enlightenmentBtn" onclick="startEnlightenment()" style="background: #9C27B0; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin-top: 10px;">开始悟道</button>
        </div>
    </div>
    
    <!-- 宗门设置标签页 -->
    <div id="sectSettings" class="sect-tabcontent" style="display:none;">
        <div style="margin-bottom: 15px;">
            <label for="sectNameInput">宗门名称:</label>
            <input type="text" id="sectNameInput" style="margin-left: 10px; padding: 5px; background: #444; color: white; border: 1px solid #666; border-radius: 3px;">
            <button onclick="changeSectName()" style="background: #FF9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 10px;">修改名称</button>
        </div>
        <div style="margin-bottom: 15px;">
            <p>创建于: <span id="sectCreationDate">未创建</span></p>
            <p>宗门宗旨: <span id="sectMotto">自强不息，厚德载物</span></p>
        </div>
        <div>
            <button onclick="disbandSect()" style="background: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">解散宗门</button>
            <p style="color: #ff4444; font-size: 0.9em; margin-top: 5px;">警告: 解散宗门将失去所有成员和宗门等级！！！</p>
        </div>
    </div>
</div>
<!-- 兑换商店界面 -->
<div id="exchangeShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="exchangeShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 500px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">兑换商店</h2>
        <button onclick="toggleExchangeShop()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px;">
        <p>在这里可以将探索资源与对应的发票道具互相兑换（1:1比例）</p>
    </div>
    
    <!-- 星尘兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <h3 style="color: #cccccc; margin-top: 0;">星尘 ↔ 星尘发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前星尘: <span id="currentStardustExchange">0</span></span>
                <span style="margin-left: 15px;">星尘发票: <span id="currentStardustTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="stardustAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('stardust', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('stardust', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换星尘</button>
            </div>
        </div>
    </div>
    
    <!-- 暗物质兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <h3 style="color: #333366; margin-top: 0;">暗物质 ↔ 暗物质发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前暗物质: <span id="currentDarkMatterExchange">0</span></span>
                <span style="margin-left: 15px;">暗物质发票: <span id="currentDarkMatterTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="darkMatterAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('darkMatter', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('darkMatter', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换暗物质</button>
            </div>
        </div>
    </div>
    
    <!-- 宇宙晶体兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <h3 style="color: #66ccff; margin-top: 0;">宇宙晶体 ↔ 宇宙晶体发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前宇宙晶体: <span id="currentCosmicCrystalExchange">0</span></span>
                <span style="margin-left: 15px;">宇宙晶体发票: <span id="currentCosmicCrystalTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="cosmicCrystalAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('cosmicCrystal', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('cosmicCrystal', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换晶体</button>
            </div>
        </div>
    </div>
    
    <!-- 神器碎片兑换 -->
    <div class="exchange-item" style="background: #2a2a2a; padding: 15px; border-radius: 8px;">
        <h3 style="color: #ffcc00; margin-top: 0;">神器碎片 ↔ 神器碎片发票</h3>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span>当前神器碎片: <span id="currentArtifactFragmentExchange">0</span></span>
                <span style="margin-left: 15px;">神器碎片发票: <span id="currentArtifactFragmentTicket">0</span></span>
            </div>
            <div>
                <input type="number" id="artifactFragmentAmount" min="1" value="1" style="width: 60px; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <button onclick="exchangeResource('artifactFragment', 'toTicket')" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换发票</button>
                <button onclick="exchangeResource('artifactFragment', 'toResource')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-left: 5px;">兑换碎片</button>
            </div>
        </div>
    </div>
</div>
<div id="autoBuySettings" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #333; z-index: 1000;">
    <h3>自动购买设置</h3>
    
    <div style="margin: 15px 0;">
        <label for="techniqueMaxCost">功法秘籍宝箱自动购买价格上限: </label>
        <input type="number" id="techniqueMaxCost" min="1" step="1">
        <button onclick="setTechniqueMaxCost()">设置</button>
    </div>
    
    <button onclick="toggleAutoBuySettings()" style="margin-top: 15px;">关闭</button>
</div>
<!-- 伴侣商店界面 -->
<div id="companionShopOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="companionShopUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #9C27B0; padding-bottom: 10px;">
        <h2 style="color: #9C27B0; margin: 0;">伴侣商店</h2>
        <button onclick="toggleCompanionShop()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 当前灵魂道具数量显示 -->
    <div style="margin-bottom: 20px; padding: 10px; background: #333; border-radius: 5px;">
        <h3 style="margin-top: 0;">当前灵魂道具数量</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
            <div>普通伴侣灵魂: <span id="soulCount1">0</span></div>
            <div>稀有伴侣灵魂: <span id="soulCount2">0</span></div>
            <div>史诗伴侣灵魂: <span id="soulCount3">0</span></div>
            <div>卓越伴侣灵魂: <span id="soulCount4">0</span></div>
            <div>完美伴侣灵魂: <span id="soulCount5">0</span></div>
            <div>神赐伴侣灵魂: <span id="soulCount6">0</span></div>
            <div>天使伴侣灵魂: <span id="soulCount7">0</span></div>
            <div>恶魔伴侣灵魂: <span id="soulCount8">0</span></div>
            <div>精灵伴侣灵魂: <span id="soulCount9">0</span></div>
        </div>
    </div>
    
    <!-- 兑换选项 -->
    <div>
        <h3>灵魂道具兑换</h3>
        
        <!-- 稀有伴侣灵魂兑换普通伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>稀有伴侣灵魂 → 普通伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">100个稀有伴侣灵魂兑换500个普通伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv2', 'banlv1', 100, 500)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换史诗伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 史诗伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">100个普通伴侣灵魂兑换1个史诗伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv3', 100, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换天使伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 天使伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">250个普通伴侣灵魂兑换1个天使伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv7', 250, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换恶魔伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 恶魔伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">220个普通伴侣灵魂兑换1个恶魔伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv8', 220, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换精灵伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 精灵伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">200个普通伴侣灵魂兑换1个精灵伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv9', 200, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换卓越伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 卓越伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">500个普通伴侣灵魂兑换1个卓越伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv4', 500, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换完美伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 完美伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">1000个普通伴侣灵魂兑换1个完美伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv5', 1000, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
        
        <!-- 普通伴侣灵魂兑换神赐伴侣灵魂 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>普通伴侣灵魂 → 神赐伴侣灵魂</strong><br>
                    <span style="font-size: 0.9em;">5000个普通伴侣灵魂兑换1个神赐伴侣灵魂</span>
                </div>
                <button onclick="exchangeSoul('banlv1', 'banlv6', 5000, 1)" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">兑换</button>
            </div>
        </div>
    </div>
</div>
<div id="tradingSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="tradingSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 900px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">跑商系统</h2>
        <button onclick="toggleTradingSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>

    <!-- 顶部状态栏 -->
    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px; background: #333; padding: 10px; border-radius: 5px;">
        <div>
            <strong>当前城市:</strong> <span id="currentCity">王都</span>
        </div>
        <div>
            <strong>星币:</strong> <span id="tradingStarCoins">0</span>
        </div>
        <div>
            <strong>货仓:</strong> <span id="warehouseCapacity">20/20</span>
        </div>
        <div>
            <strong>运输工具:</strong> <span id="transportType">手推车</span>
        </div>
    </div>

    <!-- 主界面标签页 -->
    <div class="tab-container" style="margin-bottom: 20px;">
        <button class="tab-btn active" onclick="switchTradingTab('market')">市场交易</button>
        <button class="tab-btn" onclick="switchTradingTab('map')">世界地图</button>
        <button class="tab-btn" onclick="switchTradingTab('auto')">自动贸易</button>
        <button class="tab-btn" onclick="switchTradingTab('management')">经营管理</button>
        <button class="tab-btn" onclick="switchTradingTab('fun')">趣味玩法</button>
    </div>

    <!-- 市场交易标签页 -->
    <div id="marketTab" class="tab-content active">
        <div style="margin-bottom: 15px;">
            <h3>当前城市商品价格 <span id="priceRefreshCountdown" style="font-size: 0.75em; color: #888; font-weight: normal;"></span></h3>
            <div id="cityGoodsList" style="max-height: 300px; overflow-y: auto;">
                <!-- 商品列表将在这里动态生成 -->
            </div>
        </div>
        
        <div>
            <h3>我的库存</h3>
            <div id="playerInventory" style="max-height: 200px; overflow-y: auto;">
                <!-- 库存列表将在这里动态生成 -->
            </div>
        </div>
    </div>

    <!-- 世界地图标签页 -->
    <div id="mapTab" class="tab-content">
        <div style="text-align: center; margin-bottom: 15px;">
            <h3>世界地图</h3>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <div class="region">
                    <h4>森林区</h4>
                    <div class="city" onclick="travelToCity('绿叶镇')">绿叶镇</div>
                    <div class="city" onclick="travelToCity('林荫城')">林荫城</div>
                    <div class="city" onclick="travelToCity('精灵之都')">精灵之都</div>
                </div>
                <div class="region">
                    <h4>山区</h4>
                    <div class="city" onclick="travelToCity('铁石堡')">铁石堡</div>
                    <div class="city" onclick="travelToCity('高山城')">高山城</div>
                    <div class="city" onclick="travelToCity('矿石镇')">矿石镇</div>
                </div>
                <div class="region">
                    <h4>沿海区</h4>
                    <div class="city" onclick="travelToCity('海港城')">海港城</div>
                    <div class="city" onclick="travelToCity('渔村')">渔村</div>
                    <div class="city" onclick="travelToCity('珍珠港')">珍珠港</div>
                </div>
                <div class="region">
                    <h4>平原区</h4>
                    <div class="city" onclick="travelToCity('谷物乡')">谷物乡</div>
                    <div class="city" onclick="travelToCity('牧野城')">牧野城</div>
                    <div class="city" onclick="travelToCity('平原镇')">平原镇</div>
                </div>
                <div class="region">
                    <h4>沙漠区</h4>
                    <div class="city" onclick="travelToCity('金沙城')">金沙城</div>
                    <div class="city" onclick="travelToCity('绿洲镇')">绿洲镇</div>
                    <div class="city" onclick="travelToCity('香料市')">香料市</div>
                </div>
                <div class="region">
                    <h4>都市区</h4>
                    <div class="city" onclick="travelToCity('王都')">王都</div>
                    <div class="city" onclick="travelToCity('商盟总部')">商盟总部</div>
                    <div class="city" onclick="travelToCity('贸易中心')">贸易中心</div>
                    <div class="city" onclick="travelToCity('工艺之都')">工艺之都</div>
                    <div class="city" onclick="travelToCity('魔法学院')">魔法学院</div>
                </div>
            </div>
        </div>
        
        <div id="travelInfo" style="margin-top: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <div>当前位置: <span id="currentLocation">王都</span></div>
            <div>目标城市: <span id="targetCity">-</span></div>
            <div>预计时间: <span id="travelTime">-</span></div>
            <div>状态: <span id="travelStatus">准备出发</span></div>
            <button id="startTravelBtn" onclick="startTravel()" style="margin-top: 10px;">开始旅行</button>
        </div>
    </div>

    <!-- 自动贸易标签页 -->
    <div id="autoTab" class="tab-content">
        <h3>自动贸易设置</h3>
        <div style="margin-bottom: 15px;">
            <label>
                <input type="checkbox" id="autoTradeEnabled" onchange="toggleAutoTrade()">
                启用自动贸易
            </label>
        </div>
        
        <div id="autoTradeSettings" style="display: none;">
            <div style="margin-bottom: 10px;">
                <label>采购城市: 
                    <select id="buyCity">
                        <!-- 城市选项将动态生成 -->
                    </select>
                </label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>销售城市: 
                    <select id="sellCity">
                        <!-- 城市选项将动态生成 -->
                    </select>
                </label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>采购商品: 
                    <select id="tradeGoods">
                        <!-- 商品选项将动态生成 -->
                    </select>
                </label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>最大买入价: <input type="number" id="maxBuyPrice" value="0"></label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>最小利润率: <input type="number" id="minProfitMargin" value="10">%</label>
            </div>
            <div style="margin-bottom: 10px;">
                <label>单次资金: <input type="number" id="tradeCapital" value="10000"></label>
            </div>
            <button onclick="saveAutoTradeRoute()">保存路线</button>
        </div>
        
        <div id="autoTradeStatus" style="margin-top: 15px;">
            <h4>自动贸易状态</h4>
            <div>状态: <span id="autoTradeState">未启用</span></div>
            <div>效率: <span id="autoTradeEfficiency">0%</span></div>
            <div>今日利润: <span id="todayProfit">0</span></div>
        </div>
    </div>

    <!-- 经营管理标签页 -->
    <div id="managementTab" class="tab-content">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <!-- 商人声望与等级 -->
            <div>
                <h3>商人声望与等级</h3>
                <div>声望: <span id="merchantReputation">0</span></div>
                <div>等级: <span id="merchantLevel">1</span> / 20</div>
                <div id="merchantLevelDesc" style="font-size: 12px; color: #888;">L2+卖价+2%/级 · L3+情报折扣 · L4+被劫减免 · L5/10/15/20货仓+5/10/15/20格</div>
            </div>
            <!-- 商会每日任务 -->
            <div>
                <h3>商会每日任务</h3>
                <div id="guildQuestsBlock">
                    <!-- 任务列表由 updateManagementTab 填充 -->
                </div>
            </div>
            <!-- 货仓升级 -->
            <div>
                <h3>货仓升级</h3>
                <div>当前等级: <span id="warehouseLevel">1</span></div>
                <div>当前容量: <span id="currentCapacity">20</span>格</div>
                <div>升级费用: <span id="upgradeCosta">300000</span>星币</div>
                <button onclick="upgradeWarehouse()">升级货仓</button>
            </div>
            
            <!-- 运输工具 -->
            <div>
                <h3>运输工具</h3>
                <div id="transportList">
                    <!-- 运输工具列表将动态生成 -->
                </div>
            </div>
            
            <!-- 雇员管理 -->
            <div>
                <h3>雇员管理</h3>
                <p style="font-size:0.85em; color:#888;">每类雇员限雇1名，效果可叠加。每日自动扣工资。</p>
                <div id="employeeList">
                    <!-- 雇员列表将动态生成 -->
                </div>
            </div>
            
            <!-- 风险管理 -->
            <div>
                <h3>风险管理</h3>
                <div id="insuranceBlock">
                    <div><label><input type="checkbox" id="goodsInsurance" onchange="toggleInsurance('goods')"> 货物险（被劫时赔付，保费交易额5%）</label></div>
                    <div><label><input type="checkbox" id="transportInsurance" onchange="toggleInsurance('transport')"> 运输险（运输故障时赔付，保费3%）</label></div>
                    <div><label><input type="checkbox" id="bundleInsurance" onchange="toggleInsurance('bundle')"> 综合险（货物+运输打包，保费合计6%）</label></div>
                </div>
                <div style="margin-top:10px;">
                    <span style="font-size:0.9em;">风险偏好：</span>
                    <select id="riskAppetite" onchange="setRiskAppetite(this.value)" style="padding:4px 8px; background:#333; color:#fff; border:1px solid #555;">
                        <option value="steady">稳健（负面事件-10%）</option>
                        <option value="balanced">平衡</option>
                        <option value="aggressive">激进（收益+5%，负面+5%）</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <!-- 趣味玩法标签页 -->
    <div id="funTab" class="tab-content">
        <h3 style="color: #FFD700;">趣味玩法</h3>
        <div id="funTabContent" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #9C27B0;">
                <h4 style="color: #9C27B0; margin-top: 0;">黑市</h4>
                <div id="blackMarketBlock"></div>
            </div>
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #FF9800;">
                <h4 style="color: #FF9800; margin-top: 0;">传闻板</h4>
                <div id="rumorBlock"></div>
            </div>
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50; grid-column: span 2;">
                <h4 style="color: #4CAF50; margin-top: 0;">今日幸运</h4>
                <div id="dailyLuckyBlock"></div>
            </div>
        </div>
    </div>
</div>
            </div>
        </div>
    </div>
</div>
  <div id="landlordUI" class="landlord-ui">
        <div class="landlord-header">
            <h2>疯狂地主</h2>
            <div class="landlord-currency">
                地主币: <span id="landlordCoinBalance">0</span>
            </div>
            <button class="landlord-close" onclick="closeLandlordGame()">×</button>
        </div>
        
        <div class="landlord-nav">
            <button class="landlord-tab active" onclick="switchLandlordTab('store')">种子商店</button>
            <button class="landlord-tab" onclick="switchLandlordTab('itemStore')">道具商店</button>
            <button class="landlord-tab" onclick="switchLandlordTab('fields')">田地</button>
            <button class="landlord-tab" onclick="switchLandlordTab('storage')">仓库</button>
            <button class="landlord-tab" onclick="switchLandlordTab('stats')">统计</button>
        </div>
        
        <div class="landlord-content">
            <!-- 种子商店页面 -->
            <div id="landlordStoreTab" class="landlord-tab-content active">
                <div class="landlord-refresh-info">
                    种子商店每10分钟自动刷新一次
                    <br>
                    下次刷新: <span id="landlordSeedRefreshTimer">10:00</span>
                </div>
                <div class="landlord-store-grid" id="landlordStoreItems">
                    <!-- 种子将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <!-- 道具商店页面 -->
            <div id="landlordItemStoreTab" class="landlord-tab-content">
                <div class="landlord-refresh-info">
                    道具商店每10分钟自动刷新一次
                    <br>
                    下次刷新: <span id="landlordItemRefreshTimer">10:00</span>
                </div>
                <div class="landlord-store-grid" id="landlordItemStoreItems">
                    <!-- 道具将通过JavaScript动态生成 -->
                </div>
            </div>
            
            <!-- 田地页面 -->
            <div id="landlordFieldsTab" class="landlord-tab-content">
                <div id="landlordFieldsContainer" class="landlord-fields-container">
                    <!-- 地块将通过JavaScript动态生成 -->
                </div>
                <div class="landlord-unlock-container" id="landlordUnlockSection">
                    <!-- 解锁地块信息将动态生成 -->
                </div>
            </div>
            
            <!-- 仓库页面 -->
            <div id="landlordStorageTab" class="landlord-tab-content">
                <div class="landlord-total-assets">
                    <div>仓库总资产</div>
                    <div class="landlord-total-value" id="landlordTotalAssetsValue">0 地主币</div>
                </div>
                <div class="landlord-storage-container">
                    <div class="landlord-storage-section">
                        <h3>种子仓库</h3>
                        <div id="landlordSeedStorage" class="landlord-storage-list">
                            <!-- 种子仓库内容将动态生成 -->
                        </div>
                    </div>
                    <div class="landlord-storage-section">
                        <h3>果实仓库</h3>
                        <div id="landlordFruitStorage" class="landlord-storage-list">
                            <!-- 果实仓库内容将动态生成 -->
                        </div>
                    </div>
                    <div class="landlord-storage-section">
                        <h3>道具仓库</h3>
                        <div id="landlordItemStorage" class="landlord-storage-list">
                            <!-- 道具仓库内容将动态生成 -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 统计页面 -->
            <div id="landlordStatsTab" class="landlord-tab-content">
                <div class="landlord-stats-grid">
                    <div class="landlord-stat-card">
                        <h3>游戏统计</h3>
                        <div>总种植次数: <span id="landlordTotalPlants">0</span></div>
                        <div>总收获次数: <span id="landlordTotalHarvests">0</span></div>
                        <div>合成次数: <span id="landlordSynthesisCount">0</span></div>
                        <div>升级种子数: <span id="landlordSeedsUpgraded">0</span></div>
                        <div>总获得地主币: <span id="landlordTotalCoinsEarned">0</span></div>
                        <div>当前天气: <span id="landlordCurrentWeather">晴朗</span></div>
                    </div>
                    
                    <div class="landlord-stat-card">
                        <h3>突变统计</h3>
                        <div>基础突变: <span id="landlordBasicMutations">0</span></div>
                        <div>天气突变: <span id="landlordWeatherMutations">0</span></div>
                        <div>特殊突变: <span id="landlordSpecialMutations">0</span></div>
                        <div>最高突变倍率: <span id="landlordHighestMultiplier">1x</span></div>
                    </div>
                    
                    <div class="landlord-stat-card">
                        <h3>进度</h3>
                        <div>已解锁地块: <span id="landlordUnlockedFields">5</span>/50</div>
                        <div>种子仓库容量: <span id="landlordSeedStorageCount">0</span>/∞</div>
                        <div>果实仓库容量: <span id="landlordFruitStorageCount">0</span>/200</div>
                        <div>道具使用次数: <span id="landlordItemUsageCount">0</span>/∞</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 通知区域 -->
    <div id="landlordNotificationArea"></div>
    
    <!-- 选择种子模态框 -->
    <div id="landlordSeedModal" class="landlord-modal">
        <div class="landlord-modal-content">
            <h3 style="text-align: center; margin-bottom: 20px;">选择种子</h3>
            <div id="landlordSeedModalContent" style="max-height: 300px; overflow-y: auto;">
                <!-- 种子列表将动态生成 -->
            </div>
            <button onclick="closeLandlordSeedModal()" style="margin-top: 20px; width: 100%; padding: 10px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer;">取消</button>
        </div>
    </div>
    
    <!-- 选择道具模态框 -->
    <div id="landlordItemModal" class="landlord-modal">
        <div class="landlord-modal-content">
            <h3 style="text-align: center; margin-bottom: 20px;">选择道具</h3>
            <div id="landlordItemModalContent" style="max-height: 300px; overflow-y: auto;">
                <!-- 道具列表将动态生成 -->
            </div>
            <button onclick="closeLandlordItemModal()" style="margin-top: 20px; width: 100%; padding: 10px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer;">取消</button>
        </div>
    </div>
   <div id="miningUI">
        <div class="mining-header">
            <h2>⛏️ 无尽挖矿系统</h2>
            <button onclick="toggleMiningUI()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        
        <div class="mining-stats">
            <div class="mining-stat">
                <div>当前深度</div>
                <div id="miningDepth">0 米</div>
            </div>
            <div class="mining-stat">
                <div>挖掘力量</div>
                <div id="miningPower">1</div>
            </div>
            <div class="mining-stat">
                <div>体力上限</div>
                <div id="miningMaxStamina">100</div>
            </div>
        </div>
        
        <div class="mining-stamina">
            <div>体力值: <span id="miningStaminaText">100 / 100</span></div>
            <div class="stamina-bar">
                <div class="stamina-progress" id="miningStaminaBar" style="width: 100%"></div>
            </div>
            <div style="font-size: 0.8em; color: #ff6b6b; margin-top: 5px;">
                ⚠️ 体力不会自动恢复，只能使用体力药水恢复
            </div>
        </div>
        
        <!-- 调整后的控制区域 -->
        <div class="mining-controls">
            <!-- 通知栏移动到按钮上方 -->
            <div class="mining-notifications" id="miningNotifications">
                <div class="mining-notification">游戏开始！点击"开始自动挖矿"开始冒险！</div>
            </div>
            
            <!-- 按钮组 -->
            <div class="mining-buttons">
                <button id="miningToggleBtn" onclick="toggleMining()">开始自动挖矿</button>
                <button onclick="useMiningPotion()">使用体力药水</button>
                <button onclick="buyMiningPotion()">购买药水 (1个宝藏金币)</button>
                <button id="autoPotionToggleBtn" onclick="toggleAutoPotion()">开启自动药水</button>
                <button onclick="adjustPotionThreshold()">调整药水阈值</button>
                <button onclick="clearMiningNotifications()">清空通知</button>
            </div>
        </div>
        
        <!-- 分页标签 -->
        <div class="mining-tabs">
            <div class="mining-tab active" onclick="switchMiningTab('gems')">宝石收集</div>
            <div class="mining-tab" onclick="switchMiningTab('upgrades')">装备升级</div>
            <button onclick="toggleTreasureSystem()" style="margin: 5px; padding: 8px 15px; background: linear-gradient(45deg, #FFD700, #FFA500); color: black; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">宝物界面</button>
        </div>
        
        <!-- 宝石页面 -->
        <div id="miningGemsPage" class="mining-gems-page active">
            <!-- 药水显示移动到宝石页面内 -->
            <div class="mining-potions">
                <div class="potion-info">
                    <span class="potion-icon">💊</span>
                    <div>
                        <div>体力药水</div>
                        <div style="font-size: 0.8em; color: #8da1b9;">恢复全部体力</div>
                    </div>
                </div>
                <div class="potion-count" id="miningPotionCount">3</div>
            </div>
            
            <div class="mining-gems">
                <div class="mining-gem" style="border-left: 4px solid #ff6b6b;">
                    <span>💎</span>
                    <div>
                        <div>红宝石(世界地图经验）</div>
                        <div id="miningRuby">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #48cae4;">
                    <span>🔷</span>
                    <div>
                        <div>蓝宝石（攻击力）</div>
                        <div id="miningSapphire">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #52b788;">
                    <span>💚</span>
                    <div>
                        <div>翡翠（生命）</div>
                        <div id="miningEmerald">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #7b2cbf;">
                    <span>🔮</span>
                    <div>
                        <div>紫水晶（爆伤）</div>
                        <div id="miningAmethyst">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #caf0f8;">
                    <span>💎</span>
                    <div>
                        <div>钻石（每秒GPS）</div>
                        <div id="miningDiamond">0</div>
                    </div>
                </div>
                <div class="mining-gem" style="border-left: 4px solid #ffd166;">
                    <span>⛏️</span>
                    <div>
                        <div>矿石总量</div>
                        <div id="miningOre">100</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 升级页面 -->
        <div id="miningUpgradesPage" class="mining-upgrades-page">
            <div class="mining-upgrades">
                <h3>装备升级</h3>
                <div class="mining-upgrade">
                    <div>
                        <div>强化镐头 (等级 <span id="miningPowerLevel">1</span>/100)</div>
                        <div style="font-size: 0.8em;">提高挖掘深度和矿石获取</div>
                    </div>
                    <button onclick="upgradeMiningPower()" id="upgradeMiningPowerBtn">升级 (50)</button>
                </div>
                <div class="mining-upgrade">
                    <div>
                        <div>体力上限 (等级 <span id="miningStaminaLevel">1</span>/10)</div>
                        <div style="font-size: 0.8em;">每级增加10点体力上限</div>
                    </div>
                    <button onclick="upgradeMiningStamina()" id="upgradeMiningStaminaBtn">升级 (150)</button>
                </div>
                <div class="mining-upgrade">
                    <div>
                        <div>宝石探测器 (等级 <span id="miningDetectorLevel">1</span>/10)</div>
                        <div style="font-size: 0.8em;">每级提高0.5%宝石发现几率</div>
                    </div>
                    <button onclick="upgradeMiningDetector()" id="upgradeMiningDetectorBtn">升级 (200)</button>
                </div>
            </div>
        </div>
    </div>
<!-- 模拟投资交易游戏界面 -->
<div id="investmentGameUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 95%; max-width: 1500px; height: 90vh; background: #f5f7fa; border: 3px solid #3b82f6; border-radius: 15px; z-index: 1002; overflow: hidden;">
    <div style="position: absolute; top: 10px; right: 10px;">
        <button onclick="closeInvestmentGame()" style="background: #ef4444; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 16px;">
            <i class="fas fa-times"></i> 关闭
        </button>
    </div>
    
    <div id="investmentGameContent" style="height: 100%; overflow-y: auto; padding: 20px;">
        <!-- 模拟投资交易游戏的内容将通过JavaScript动态生成 -->
    </div>
</div>
 <!-- 房屋系统界面 -->
    <div id="houseSystemOverlay"></div>
    <div id="houseSystemUI">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #8B4513; padding-bottom: 10px;">
            <h2 style="color: #8B4513; margin: 0;">房屋系统</h2>
            <button onclick="closeHouseSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
        </div>
        
        <!-- 房屋信息 -->
        <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
            <div style="display: flex; justify-content: space-between;">
                <div>
                    <strong>房屋等级:</strong> <span id="houseLevel">1</span>
                    <strong>经验:</strong> <span id="houseExp">0</span>/<span id="houseExpNext">100</span>
                </div>
                <button onclick="upgradeHouseSystem()" 
                style="background: #8B4513; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">
            升级房屋系统
        </button>
                <div>
                    <strong>房屋数量:</strong> <span id="houseCount">0</span>/<span id="maxHouses">5</span>
                </div>
                <div>
                    <strong>房子总收益:</strong> <span id="totalHouseIncome">0</span> 资金
                </div>
                <div>
                    <strong>当前资产:</strong> <span id="totalHouseIncoma">0</span> 资金
                </div>
            </div>
        
       
         <!-- 房屋购买区域 -->
        <div style="margin-bottom: 20px;">
            <h3>购买房屋</h3>
            <div id="houseStore" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 10px;">
                <!-- 房屋购买选项将动态生成 -->
            </div>
        </div>
        </div>
               
        <!-- 我的房屋 -->
        <div style="margin-bottom: 20px;">
            <h3>我的房屋</h3>
            <div id="houseList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; padding: 10px; background: #333; border-radius: 5px;">
                <!-- 房屋卡片会动态生成在这里 -->
            </div>
        </div>
        
        <!-- 房屋操作 -->
        <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
            <h3>房屋操作</h3>
            <div id="houseSlotsContainer" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin: 10px 0; max-height: 400px; overflow-y: auto;">
                <!-- 房屋槽位会动态生成在这里 -->
            </div>
            <div>
                <button onclick="rentAllHouses()" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; margin-right: 10px;">一键出租</button>
                <button onclick="collectAllHouseIncome()" style="background: #FFC107; color: black; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">收取所有收益</button>
            </div>
        </div>
        
        <!-- 房屋分解 -->
        <div style="background: #333; padding: 15px; border-radius: 8px;">
            <h3>房屋分解</h3>
            <p>选择房屋进行分解，获得转生币</p>
            
            <!-- 批量选择选项 -->
            <div style="margin-bottom: 10px;">
                <strong>批量选择:</strong>
                <button onclick="selectHousesByRarity(5)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">5稀有度以下</button>
                <button onclick="selectHousesByRarity(10)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">10稀有度以下</button>
                <button onclick="selectHousesByRarity(15)" style="margin: 2px; padding: 3px 6px; font-size: 12px;">15稀有度以下</button>
                <button onclick="selectAllHouses()" style="margin: 2px; padding: 3px 6px; font-size: 12px;">全选</button>
                <button onclick="deselectAllHouses()" style="margin: 2px; padding: 3px 6px; font-size: 12px;">全不选</button>
            </div>
            
            <div id="decomposeHouseContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; max-height: 400px; overflow-y: auto;">
                <!-- 分解界面会动态生成在这里 -->
            </div>
            <button onclick="decomposeSelectedHouse()" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">分解选中房屋</button>
        </div>
    </div>
 </div>
 </div>
<!-- 结婚系统界面 -->
<div id="marriageSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="marriageSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FF69B4; border-radius: 10px; z-index: 1001; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #FF69B4; padding-bottom: 10px;">
        <h2 style="color: #FF69B4; margin: 0;">结婚系统</h2>
        <button onclick="closeMarriageSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 结婚状态 -->
    <div id="marriageStatus" style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>当前状态</h3>
        <div id="spouseInfo"></div>
    </div>
    
    <!-- 求婚/结婚界面 -->
    <div id="proposalSection" style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>求婚</h3>
        <div style="margin-bottom: 10px;">
            <label for="spouseNameInput">伴侣名字:</label>
            <input type="text" id="spouseNameInput" placeholder="输入伴侣名字" style="padding: 5px; width: 200px; margin-left: 10px;">
        </div>
        <div style="margin-bottom: 10px;">
            <label for="spouseGenderSelect">伴侣性别:</label>
            <select id="spouseGenderSelect" style="padding: 5px; margin-left: 10px;">
                <option value="male">男性</option>
                <option value="female">女性</option>
            </select>
        </div>
        <button onclick="proposeMarriage()" style="background: #FF69B4; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">求婚 (消耗 388888彩礼)</button>
    </div>
    
    <!-- 婚姻互动 -->
    <div id="marriageInteraction" style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>婚姻互动</h3>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
            <button onclick="giveGiftToSpouse()" style="background: #FF69B4; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">赠送礼物 (消耗 1314 元)</button>
            <button onclick="spendTimeWithSpouse()" style="background: #FF69B4; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">共度时光 (消耗 99999 元)</button>
            <button onclick="spendAimeWithSpouse()" style="background: #FF69B4; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">全国旅行 (消耗 5201314 元)</button>
            <button onclick="toggleChildSystem()" style="background: #FF69B4; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">生小孩</button>
            <button onclick="divorce()" style="background: #f44336; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">离婚</button>
            <button onclick="renameSpouse()" style="background: #2196F3; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;">重命名伴侣</button>
        </div>
    </div>
    
    <!-- 婚姻加成 -->
    <div id="marriageBonuses" style="background: #333; padding: 15px; border-radius: 8px;">
        <h3>婚姻加成</h3>
        <div id="bonusInfo"></div>
    </div>
</div>
    </div>
</div>
<!-- 宝物系统界面 -->
<div id="treasureSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="treasureSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #FFD700; padding-bottom: 10px;">
        <h2 style="color: #FFD700; margin: 0;">稀有宝物</h2>
        <button onclick="closeTreasureSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 宝物信息统计 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>宝物统计</h3>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
            <div>总宝物数量: <span id="totalTreasures">0</span></div>
            <div>总价值: <span id="totalTreasureValue">0</span> 资金</div>
            <div>已出售: <span id="totalSoldValue">0</span> 资金</div>
        </div>
    </div>
    
    <!-- 宝物展示区域 -->
    <div style="margin-bottom: 20px;">
        <h3>我的宝物收藏</h3>
        <div id="treasureCollection" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; max-height: 300px; overflow-y: auto; padding: 10px; background: #333; border-radius: 5px;">
            <!-- 宝物卡片会动态生成在这里 -->
        </div>
    </div>
    
    <!-- 宝物出售区域 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>宝物出售</h3>
        <div style="margin-bottom: 10px;">
            <label for="sellAmount">出售数量:</label>
            <input type="number" id="sellAmount" value="1" min="1" style="padding: 5px; width: 80px; margin-left: 10px;">
            <button onclick="selectAllTreasures()" style="margin-left: 10px; background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">全选</button>
            <button onclick="deselectAllTreasures()" style="margin-left: 5px; background: #FF9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">全不选</button>
        </div>
        
        <div id="treasureSellList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; max-height: 200px; overflow-y: auto;">
            <!-- 出售列表会动态生成在这里 -->
        </div>
        
        <div style="margin-top: 10px;">
            <button onclick="sellSelectedTreasures()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">出售选中宝物</button>
            <button onclick="sellAllTreasures()" style="background: #FF5722; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">一键出售所有</button>
        </div>
    </div>
    
    <!-- 宝物图鉴 -->
    <div style="background: #333; padding: 15px; border-radius: 8px;">
        <h3>宝物图鉴</h3>
        <div id="treasureEncyclopedia" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; max-height: 300px; overflow-y: auto;">
            <!-- 宝物图鉴会动态生成在这里 -->
        </div>
    </div>
</div>
</div>
<!-- 生小孩系统界面 -->
<div id="childSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="childSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FF69B4; border-radius: 10px; z-index: 1001; width: 900px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #FF69B4; padding-bottom: 10px;">
        <h2 style="color: #FF69B4; margin: 0;">生小孩系统</h2>
        <button onclick="closeChildSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-size: 14px;">关闭</button>
    </div>
    
    <!-- 家庭状态 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>家庭状态</h3>
        <div id="familyStatus" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
            <!-- 家庭信息会动态生成 -->
        </div>
    </div>
    
    <!-- 怀孕状态 -->
    <div id="pregnancySection" style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px; display: none;">
        <h3>怀孕状态</h3>
        <div id="pregnancyInfo"></div>
    </div>
    
    <!-- 生育功能 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>生育功能</h3>
        <div id="conceptionSection">
            <div style="margin-bottom: 10px;">
                <label for="childNameInput">孩子名字:</label>
                <input type="text" id="childNameInput" placeholder="输入孩子名字" style="padding: 5px; width: 200px; margin-left: 10px;">
            </div>
            <div style="margin-bottom: 10px;">
                <label for="childGenderSelect">孩子性别:</label>
                <select id="childGenderSelect" style="padding: 5px; margin-left: 10px;">
                    <option value="boy">男孩</option>
                    <option value="girl">女孩</option>
                </select>
            </div>
            <button onclick="conceiveChild()" id="conceiveBtn" style="background: #FF69B4; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">怀孕 (消耗 5200 转生币)</button>
        </div>
    </div>
    
    <!-- 孩子列表 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>我的孩子</h3>
        <div id="childrenList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-height: 300px; overflow-y: auto; padding: 10px;">
            <!-- 孩子卡片会动态生成 -->
        </div>
    </div>
    
    <!-- 孩子培养 -->
    <div style="margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;">
        <h3>孩子培养</h3>
        <div id="childTrainingSection" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
            <!-- 培养选项会动态生成 -->
        </div>
    </div>
    
    <!-- 孩子加成 -->
    <div style="background: #333; padding: 15px; border-radius: 8px;">
        <h3>孩子加成</h3>
        <div id="childBonuses"></div>
    </div>
</div>
    </div>
</div>
<!-- 轮回装备系统界面 -->
<div id="reincarnationEquipmentOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="reincarnationEquipmentUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #8a2be2; border-radius: 10px; z-index: 1001; width: 900px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #8a2be2; margin: 0;">轮回装备系统</h2>
        <button onclick="toggleReincarnationEquipmentUI()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 装备属性总览 -->
    <div id="equipmentStatsSummary" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 5px;"></div>
    
    <!-- 已装备的装备 -->
    <div style="margin-bottom: 20px;">
        <h3>已装备</h3>
        <div id="equippedEquipmentContainer"></div>
    </div>
    
    <!-- 套装效果 -->
    <div style="margin-bottom: 20px;">
        <h3>套装效果</h3>
        <div id="setBonusesContainer"></div>
    </div>
    
    <!-- 装备仓库 -->
    <div style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">装备仓库</h3><div>
            <button id="batchDiscardBtn" onclick="toggleBatchDiscardMode()" 
                    style="background: #ff9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">
                批量丢弃
            </button>
           <button onclick="showImportHistory()"  style="background: #FF9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">
                    导入历史
                </button>
            <button onclick="showImportDialog()" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">导入装备</button>
        </div>
        </div>
        <!-- 筛选条件 -->
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px;">
            <div>
                <label>T等级: </label>
                <select id="inventoryFilterTier" onchange="updateReincarnationEquipmentUI()">
                    <option value="all">全部</option>
                    <option value="1">T1</option>
                    <option value="2">T2</option>
                    <option value="3">T3</option>
                    <option value="4">T4</option>
                    <option value="5">T5</option>
                    <option value="6">T6</option>
                    <option value="7">T7</option>
                    <option value="8">T8</option>
                    <option value="9">T9</option>
                    <option value="10">T10</option>
                </select>
            </div>
            <div>
                <label>品质: </label>
                <select id="inventoryFilterRarity" onchange="updateReincarnationEquipmentUI()">
                    <option value="all">全部</option>
                    <option value="common">普通</option>
                    <option value="uncommon">优秀</option>
                    <option value="rare">精良</option>
                    <option value="epic">史诗</option>
                    <option value="legendary">传说</option>
                    <option value="mythic">神话</option>
                    <option value="supreme">至尊</option>
                    <option value="ancient">远古</option>
                    <option value="primordial">上古</option>
                    <option value="eternal">荒古</option>
                </select>
            </div>
            <div>
                <label>部位: </label>
                <select id="inventoryFilterSlot" onchange="updateReincarnationEquipmentUI()">
                    <option value="all">全部</option>
                    <option value="helmet">头盔</option>
                    <option value="chest">衣服</option>
                    <option value="pants">裤子</option>
                    <option value="shoes">鞋子</option>
                    <option value="necklace">项链</option>
                    <option value="weapon">武器</option>
                </select>
            </div>
            <div>
                <label>套装: </label>
                <select id="inventoryFilterSet" onchange="updateReincarnationEquipmentUI()">
                    <option value="all">全部</option>
                    <option value="hasSet">有套装</option>
                    <option value="noSet">无套装</option>
                </select>
            </div>
        </div>
        
        <div id="equipmentInventoryContainer" style="max-height: 300px; overflow-y: auto;"></div>
    </div>
</div>

<!-- 导出对话框 -->
<!-- 导出对话框 -->
<div id="exportOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1010;"></div>
<div id="exportDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #4CAF50; border-radius: 10px; z-index: 1011; width: 500px;">
    <h3>导出装备</h3>
    <p>复制以下代码分享给其他玩家（10分钟内有效）：</p>
    
    <div id="exportTimeInfo"></div>
    
    <textarea id="exportEquipmentData" style="width: 100%; height: 100px; background: #333; color: white; border: 1px solid #555; padding: 10px; margin: 10px 0; font-family: monospace;"></textarea>
    
    <div style="display: flex; gap: 10px;">
        <button id="copyExportBtn" onclick="copyExportCode()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer;">复制代码</button>
        <button onclick="hideExportDialog()" style="background: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
</div>

<!-- 导入对话框 -->
<div id="importOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1010;"></div>
<div id="importDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #2196F3; border-radius: 10px; z-index: 1011; width: 500px;">
    <h3>导入装备</h3>
    <p>粘贴装备代码（10分钟内有效）：</p>
    
    <textarea id="importEquipmentData" oninput="validateImportCode()" style="width: 100%; height: 100px; background: #333; color: white; border: 1px solid #555; padding: 10px; margin: 10px 0; font-family: monospace;"></textarea>
    
    <div id="importTimeInfo"></div>
    
    <div style="display: flex; gap: 10px;">
        <button onclick="importEquipment()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer;">导入装备</button>
        <button onclick="hideImportDialog()" style="background: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer;">取消</button>
    </div>
</div>

<!-- 导入历史对话框 -->
<div id="importHistoryOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1010;"></div>
<div id="importHistoryDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FF9800; border-radius: 10px; z-index: 1011; width: 500px; max-height: 400px; overflow-y: auto;">
    <h3>导入历史</h3>
    <div id="importHistoryList"></div>
    <div style="margin-top: 15px; text-align: center;">
        <button onclick="hideImportHistory()" style="background: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
</div>
</div>
</div>
<!-- 轮回神兽系统覆盖层和主界面 -->
<div id="beastSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000;"></div>
<div id="beastSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #8A2BE2; border-radius: 10px; z-index: 1001; width: 800px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #8A2BE2; margin: 0;">轮回神兽系统</h2>
        <button onclick="toggleBeastSystem()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <!-- 系统说明区域 -->
    <div style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 5px;">
        <p>在次元2及以上的世界地图战斗中有几率掉落轮回神兽。S级别越高、品质越好的神兽，加成的属性越强大。</p>
        <p>当前轮回次数: <span id="currentAscentionCounta">0</span> | 可装备最高S级别: <span id="maxEquipSLevel">S1</span> |
       神兽蛋: <span id="globalBeastEggCount" style="color: #FFD700;">0</span> 🥚
    </p></p>
    </div>
  <!-- 在系统说明区域后，筛选操作前添加已装备神兽显示 -->
<div id="equippedBeastsSection" style="margin-bottom: 15px; padding: 15px; background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(138, 43, 226, 0.1)); border-radius: 8px; border-left: 4px solid #8A2BE2;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;">
        <h4 style="color: #8A2BE2; margin: 0; display: flex; align-items: center; gap: 5px;">
            <span>⚡ 当前已装备的神兽</span>
            <span style="font-size: 0.8em; background: #8A2BE2; color: white; padding: 2px 8px; border-radius: 10px;">
                ${player.beasts.equipped.length}/${getMaxBeastSlots()}
            </span>
        </h4>
        <div style="display: flex; gap: 5px;">
            <button onclick="quickFilterEquipped()" style="background: rgba(76, 175, 80, 0.2); color: #4CAF50; border: 1px solid #4CAF50; padding: 3px 10px; border-radius: 12px; cursor: pointer; font-size: 0.8em;">
                只看已装备
            </button>
            <button onclick="quickFilterUnequipped()" style="background: rgba(33, 150, 243, 0.2); color: #2196F3; border: 1px solid #2196F3; padding: 3px 10px; border-radius: 12px; cursor: pointer; font-size: 0.8em;">
                只看未装备
            </button>
            <button onclick="quickFilterEquippable()" style="background: rgba(255, 152, 0, 0.2); color: #FF9800; border: 1px solid #FF9800; padding: 3px 10px; border-radius: 12px; cursor: pointer; font-size: 0.8em;">
                只看可装备
            </button>
        </div>
    </div>
    <div id="equippedBeastsList" style="display: flex; flex-wrap: wrap; gap: 10px; min-height: 60px;">
        <!-- 已装备神兽将动态显示在这里 -->
    </div>
    <div style="font-size: 0.85em; color: #aaa; margin-top: 8px; display: flex; justify-content: space-between;">
        <span>点击神兽可快速查看详情</span>
        <button onclick="resetAllFilters()" style="background: none; color: #888; border: none; padding: 0; cursor: pointer; font-size: 0.85em;">
            重置筛选
        </button>
    </div>
</div>
    <!-- 筛选与操作栏 -->
    <div style="display: flex; justify-content: space-between; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
    <div style="display: flex; gap: 10px; align-items: center;">
    <div>
        <span>筛选: </span>
        <select id="beastSLevelFilter" onchange="filterBeasts()" style="margin-right: 5px;">
            <option value="all">全部S级别</option>
            <option value="S1">S1</option>
            <option value="S2">S2</option>
            <option value="S3">S3</option>
            <option value="S4">S4</option>
            <option value="S5">S5</option>
            <option value="S6">S6</option>
            <option value="S7">S7</option>
            <option value="S8">S8</option>
            <option value="S9">S9</option>
            <option value="S10">S10</option>
        </select>
        <select id="beastRarityFilter" onchange="filterBeasts()" style="margin-right: 5px;">
            <option value="all">全部品质</option>
            <option value="小宠物">小宠物</option>
            <option value="野兽">野兽</option>
            <option value="凶兽">凶兽</option>
            <option value="灵兽">灵兽</option>
            <option value="圣兽">圣兽</option>
            <option value="神兽">神兽</option>
            <option value="炁兽">炁兽</option>
        </select>
        <select id="beastEquipFilter" onchange="filterBeasts()">
            <option value="all">全部状态</option>
            <option value="equipped">已装备</option>
            <option value="unequipped">未装备</option>
            <option value="equippable">可装备</option>
            <option value="unequippable">未达标</option>
        </select>
    </div>
</div>
  <button onclick="showImportCodeModal()" style="background: #9C27B0; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">
        导入兑换码
    </button>
    <div>
        <button onclick="lockAllFilteredBeasts()" style="background: #FF9800; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">锁定筛选</button>
        <button onclick="unlockAllFilteredBeasts()" style="background: #FF9800; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">
            解锁筛选
        </button>
        <button onclick="discardAllUnlockedFilteredBeasts()"  style="background: #FF9800; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">批量丢弃未锁定</button>
    </div>
</div>

    <!-- 神兽仓库展示 -->
    <div id="beastInventoryContainer">
        <h3>神兽仓库</h3>
        <div id="beastInventory" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 10px; max-height: 400px; overflow-y: auto;">
            <!-- 神兽列表将通过JavaScript动态生成 -->
        </div>
    </div>
<div style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 5px;">
    <h4>神兽总属性</h4>
    <div id="totalBeastBonus">
        <!-- 总属性将通过JavaScript动态更新 -->
    </div>
</div>
  

<!-- 在神兽操作弹窗的按钮区域添加升级按钮 -->
<div id="shareUpgradeSection" style="display: none; margin-top: 20px; padding: 15px; background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05)); border-radius: 8px; border-left: 4px solid #4CAF50;">
    <h4 style="color: #4CAF50; margin-top: 0; margin-bottom: 10px; display: flex; align-items: center; gap: 5px;">
        <span>🌟 共享升级</span>
        <span style="font-size: 0.8em; background: #4CAF50; color: white; padding: 2px 8px; border-radius: 10px;">
            Lv. <span id="currentShareLevel">0</span>
        </span>
    </h4>
    
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
        <div>
            <div style="color: #aaa; font-size: 0.9em;">当前加成：</div>
            <div style="color: #4CAF50; font-size: 1.2em; font-weight: bold;">+<span id="currentBonusPercent">0</span>%</div>
        </div>
        <div>
            <div style="color: #aaa; font-size: 0.9em;">拥有神兽蛋：</div>
            <div style="color: #FFD700; font-size: 1.2em; font-weight: bold;">
                <span id="beastEggCount">0</span> 🥚
            </div>
        </div>
        <div>
            <div style="color: #aaa; font-size: 0.9em;">下一级消耗：</div>
            <div style="color: #FF9800; font-size: 1.2em; font-weight: bold;">
                <span id="nextLevelCost">10</span> 🥚
            </div>
        </div>
    </div>
    
    <!-- 升级按钮区域 -->
    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
        <button onclick="upgradeShareLevel(1)" style="background: #4CAF50; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; flex: 1; font-size: 1em;">
            升级1级
        </button>
        <button onclick="upgradeShareLevel(10)" style="background: #2196F3; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; flex: 1; font-size: 1em;">
            升级10级
        </button>
        <button onclick="upgradeShareLevel(50)" style="background: #9C27B0; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; flex: 1; font-size: 1em;">
            升级50级
        </button>
    </div>
    
    <!-- 批量升级输入 -->
    <div style="display: flex; gap: 5px; margin-bottom: 15px;">
        <input type="number" id="customUpgradeAmount" min="1" max="1000" value="1" 
               style="flex: 2; padding: 10px; background: #333; color: white; border: 1px solid #555; border-radius: 5px;">
        <button onclick="upgradeShareLevelCustom()" style="flex: 1; background: #FF9800; color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer;">
            自定义升级
        </button>
        <button onclick="upgradeShareLevelMax()" style="flex: 1; background: #f44336; color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer;">
            最大升级
        </button>
    </div>
    
    <!-- 进度条 -->
    <div style="margin-bottom: 10px;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <span style="color: #aaa; font-size: 0.85em;">升级进度</span>
            <span style="color: #FFD700; font-size: 0.85em;">
                <span id="consumedEggs">0</span>/<span id="totalEggsForNext">20</span> 蛋
            </span>
        </div>
        <div style="width: 100%; height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
            <div id="upgradeProgressBar" style="height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); width: 0%; border-radius: 4px;"></div>
        </div>
    </div>
    
    <!-- 等级效果说明 -->
    <div style="background: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 5px; margin-top: 10px;">
        <div style="color: #FFD700; font-size: 0.9em; margin-bottom: 5px;">📈 升级效果</div>
        <div style="color: #aaa; font-size: 0.85em;">
            • 每级提升所有神兽总属性 <span style="color: #4CAF50;">2%</span><br>
            • 当前等级对所有神兽生效<br>
            • 加成计算公式：总属性 × (1 + 等级 × 0.02)<br>
            • 等级无上限，但每级消耗增加
        </div>
    </div>
    </div>
</div>
<!-- 在现有的神兽系统UI中添加独立操作弹窗 -->
<div id="beastActionModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #8A2BE2; border-radius: 10px; z-index: 1002; width: 600px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #8A2BE2; margin: 0;">神兽操作</h2>
        <button onclick="closeBeastActionModal()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div id="selectedBeastInfo" style="margin-bottom: 20px;">
        <!-- 神兽详细信息会动态填充到这里 -->
    </div>
    
    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <button id="btnLockUnlock" onclick="toggleLockBeast()" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; flex: 1;">锁定</button>
        <button id="btnExportCode" onclick="exportBeastCode()" style="background: #2196F3; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; flex: 1;">生成兑换码</button>
        <button id="btnDiscard" onclick="discardBeast()" style="background: #d32f2f; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; flex: 1;">丢弃</button>
    </div>
    
    <div id="exportCodeSection" style="display: none; margin-top: 20px; padding: 15px; background: #2a2a2a; border-radius: 5px;">
        <h4>兑换码</h4>
        <p style="color: #aaa; font-size: 0.9em;">兑换码有效期为10分钟，复制下方代码给其他玩家：</p>
        <textarea id="beastCodeOutput" readonly style="width: 100%; height: 60px; background: #333; color: #fff; border: 1px solid #555; padding: 5px; margin-bottom: 10px;"></textarea>
        <button onclick="copyBeastCode()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">复制代码</button>
    </div>
</div>

<!-- 操作弹窗遮罩层 -->
<div id="beastActionOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1001;"></div>    </div>
</div>    </div>

<!-- 在现有弹窗后添加导入兑换码弹窗 -->
<div id="importCodeModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #9C27B0; border-radius: 10px; z-index: 1003; width: 500px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="color: #9C27B0; margin: 0;">导入兑换码</h3>
        <button onclick="closeImportCodeModal()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
    </div>
    
    <div style="margin-bottom: 15px;">
        <p style="color: #aaa; font-size: 0.9em; margin-bottom: 10px;">
            请输入其他玩家分享的兑换码（有效期10分钟）：
        </p>
        <textarea id="importCodeInput" placeholder="粘贴兑换码..." style="width: 100%; height: 80px; background: #333; color: #fff; border: 1px solid #555; padding: 10px; border-radius: 5px; font-family: monospace;"></textarea>
    </div>
    
    <div style="margin-bottom: 15px; padding: 10px; background: rgba(156, 39, 176, 0.1); border-radius: 5px;">
        <div style="color: #9C27B0; font-size: 0.9em; margin-bottom: 5px;">💡 提示</div>
        <ul style="color: #aaa; font-size: 0.85em; margin: 0; padding-left: 20px;">
            <li>兑换码有效期为10分钟</li>
            <li>每个兑换码只能使用一次</li>
            <li>导入后神兽的掉落者将变为当前玩家</li>
        </ul>
    </div>
    
    <div style="display: flex; gap: 10px;">
        <button onclick="redeemBeastCodeFromImport()" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; flex: 1;">兑换</button>
        <button onclick="closeImportCodeModal()" style="background: #757575; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; flex: 1;">取消</button>
    </div>
</div>

<div id="importCodeOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1002;">
</div>
</div>


</div>
</div>
<div id="gambleStoneUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 95%; max-width: 1000px; height: 85vh; background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); border: 3px solid #f59e0b; border-radius: 15px; z-index: 1003; overflow: hidden; box-shadow: 0 10px 30px rgba(245, 158, 11, 0.3);">
    <div style="position: absolute; top: 10px; right: 10px;">
        <button onclick="closeGambleStone()" style="background: #ef4444; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">
            <i class="fas fa-times"></i> 关闭
        </button>
    </div>
    
    <div id="gambleStoneContent" style="height: 100%; overflow-y: auto; padding: 20px;">
        <!-- 赌石系统的内容将通过JavaScript动态生成 -->
    </div>
</div>
</div>
</div>
<div id="autoBuyShopb" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #fff5e6, #ffe4e1); padding: 25px; border: 4px solid #c41e3a; border-radius: 16px; box-shadow: 0 0 30px rgba(255, 215, 0, 0.9), 0 0 0 4px rgba(255, 69, 0, 0.3); z-index: 2147483647; max-height: 80vh; overflow-y: auto; width: 520px; font-family: '楷体', 'KaiTi', sans-serif; outline: 3px solid #ffaa33;">
    
    <!-- 红灯笼装饰 -->
    <div style="position: absolute; top: -10px; left: -10px; font-size: 42px;">🏮</div>
    <div style="position: absolute; top: -10px; right: -10px; font-size: 42px;">🏮</div>
    <div style="position: absolute; bottom: -10px; left: -10px; font-size: 42px;">🏮</div>
    <div style="position: absolute; bottom: -10px; right: -10px; font-size: 42px;">🏮</div>
    
    <!-- 额外上层装饰 - 金色流苏 -->
    <div style="position: absolute; top: -20px; left: 30%; width: 40%; height: 10px; background: linear-gradient(90deg, transparent, #ffd700, #ffaa00, #ffd700, transparent); border-radius: 10px;"></div>
    
    <!-- 春联风格标题 -->
    <h3 style="text-align: center; color: #b22222; font-size: 28px; margin-top: 5px; margin-bottom: 20px; text-shadow: 2px 2px 0 #ffd700, 3px 3px 8px rgba(255,100,0,0.5); border-bottom: 3px solid #ffaa33; padding-bottom: 12px;">
        ✨ 新春修仙副本 ✨
        <span style="display: block; font-size: 16px; color: #8b4513; margin-top: 8px; background: rgba(255,255,200,0.5); padding: 4px 12px; border-radius: 30px; display: inline-block;">🧧 金马赐福 · 仙缘加倍 🧧</span>
    </h3>
    
    <div class="auto-buy-container" style="background: rgba(255, 235, 205, 0.8); backdrop-filter: blur(2px); border-radius: 20px; padding: 15px; border: 2px dashed #ff8c00; box-shadow: inset 0 0 15px rgba(255,200,0,0.3);">
        <div class="auto-buy-container" style="background: rgba(255, 235, 205, 0.7); border-radius: 20px; padding: 15px; border: 2px dashed #ff8c00;">
       <button onclick="openNianBeastDungeon()" style="background: linear-gradient(145deg, #FF6B6B, #C41E3A); color: white; border: 2px solid #FFD700; padding: 15px 20px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 18px; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); animation: pulse-gold 2s infinite;">
        <div style="display: flex; flex-direction: column; align-items: center;">
            <span style="font-size: 20px;">🧧</span>
            <span style="font-size: 13px; color: #FFD700;">年兽副本</span>
            <span style="font-size: 9px; color: #fff; background: rgba(255,0,0,0.7); padding: 2px 10px; border-radius: 10px; margin-top: 5px;">新春限定</span>
   <div style="position: fixed; right: 20px; top: 320px; z-index: 100;">
    <button onclick="openTrialTower()" style="background: linear-gradient(145deg, #4A2C4A, #2A1A2A); color: white; border: 2px solid #9C27B0; padding: 15px 20px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 18px; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); animation: pulse-gold 2s infinite;">
        <div style="display: flex; flex-direction: column; align-items: center;">
            <span style="font-size: 20px;">🗼</span>
            <span style="font-size: 13px; color: #9C27B0;">试练塔</span>
            <span style="font-size: 9px; color: #fff; background: rgba(156,39,176,0.7); padding: 2px 10px; border-radius: 10px; margin-top: 5px;">无限挑战</span>         
    </div>
    
    <button onclick="toggleAutoBuyShopb()" style="display: block; margin: 25px auto 10px; padding: 12px 36px; background: linear-gradient(145deg, #ff4d4d, #b22222); color: #fff9e6; border: 2px solid #ffd700; border-radius: 40px; font-size: 20px; font-weight: bold; cursor: pointer; box-shadow: 0 6px 0 #8b0000, 0 8px 20px rgba(255,0,0,0.6); transition: 0.1s; font-family: '楷体', 'KaiTi', sans-serif; position: relative; z-index: 2147483647;">
        🎉 恭贺新禧 · 关闭 🎉
    </button>
    
    <!-- 底部鞭炮装饰 -->
    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 8px; font-size: 24px; text-shadow: 0 0 8px orange;">
        <span>🧨</span> <span>🧨</span> <span style="color: #ff5500;">✧ 岁岁平安 ✧</span> <span>🧨</span> <span>🧨</span>
    </div>
    
    <!-- 增加浮动金币效果增强存在感 -->
    <div style="position: absolute; top: 5px; right: 20px; font-size: 20px; animation: float 3s infinite;">🧧</div>
    <div style="position: absolute; bottom: 5px; left: 20px; font-size: 20px; animation: float 2.5s infinite;">🧧</div>
    
    <style>
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
            100% { transform: translateY(0px); }
        }
    </style>
</div>
   </div>
</div>
</div>
<!-- 年兽副本UI弹窗 -->
<div id="nianBeastOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000;"></div>
<div id="nianBeastUI" style="
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(145deg, #8B0000, #630000);
    color: white;
    padding: 30px;
    border: 5px solid #FFD700;
    border-radius: 30px;
    z-index: 2001;
    width: 1200px;              /* 👈 从 900 → 1200 */
    max-width: 95vw;           /* 👈 防止超宽屏幕溢出 */
    max-height: 90vh;          /* 👈 稍微放松 */
    overflow-y: auto;          /* 👈 保留滚动，但内容撑大后会减少滚动 */
    box-shadow: 0 0 50px rgba(255, 215, 0, 0.6);
    animation: glow-red 3s infinite;
">
    
    <!-- 新年装饰 -->
    <div style="position: absolute; top: -20px; left: -20px; font-size: 50px; transform: rotate(-15deg);">🧧</div>
    <div style="position: absolute; top: -20px; right: -20px; font-size: 50px; transform: rotate(15deg);">🏮</div>
    <div style="position: absolute; bottom: -20px; left: -20px; font-size: 50px; transform: rotate(15deg);">🎋</div>
    <div style="position: absolute; bottom: -20px; right: -20px; font-size: 50px; transform: rotate(-15deg);">🎊</div>
    
    <!-- 标题区域 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 3px solid #FFD700;">
        <div style="display: flex; align-items: center; gap: 15px;">
            <h2 style="color: #FFD700; margin: 0; text-shadow: 0 0 20px #FFD700; font-size: 36px; font-weight: bold;">🐉 新春年兽讨伐</h2>
            <div style="background: #C41E3A; padding: 5px 15px; border-radius: 20px; border: 2px solid #FFD700;">
                <span style="color: #FFD700; font-weight: bold;">🧧 2026 丙午年</span>
            </div>
        </div>
        <button onclick="closeNianBeastDungeon()" style="background: #C41E3A; color: white; border: 2px solid #FFD700; padding: 8px 25px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 18px;">关闭</button>
    </div>
    
    <!-- 玩家信息和副本令牌 -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 20px; border: 2px solid #FFD700;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 28px;">⚔️</span>
                <span style="font-size: 18px; color: #FFD700; font-weight: bold;">讨伐者属性</span>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                <div>
                    <div style="font-size: 14px; color: #aaa;">生命值</div>
                    <div style="font-size: 20px; color: #FF6B6B; font-weight: bold;" id="nianPlayerHp">0</div>
                </div>
                <div>
                    <div style="font-size: 14px; color: #aaa;">攻击力</div>
                    <div style="font-size: 20px; color: #FF6B6B; font-weight: bold;" id="nianPlayerAtk">0</div>
                </div>
                <div>
                    <div style="font-size: 14px; color: #aaa;">暴击伤害</div>
                    <div style="font-size: 20px; color: #FFD700; font-weight: bold;" id="nianPlayerCrit">0%</div>
                </div>
                <div>
                    <div style="font-size: 14px; color: #aaa;">暴击几率</div>
                    <div style="font-size: 20px; color: #FFD700; font-weight: bold;" id="nianPlayerCritRate">30%</div>
                </div>
            </div>
           <div style="background: rgba(255,107,107,0.1); padding: 10px; border-radius: 10px; margin-top: 10px; border: 1px solid #FF6B6B;">
    <div style="display: flex; align-items: center; gap: 5px;">
        <span style="font-size: 16px;">🌟</span>
        <span style="color: #FF6B6B; font-size: 13px; font-weight: bold;">法宝暴伤</span>
    </div>
    <div style="font-size: 11px; color: #FFD700; margin-top: 5px;" id="artifactCritPreview">
        当前法宝加成: <span id="currentArtifactBonus">1.0</span>倍 → 触发 <span id="currentArtifactMultiplier">1</span>倍暴伤
    </div>
<div id="chaosCauldronTip" style="display: none; margin-top: 10px;"></div>
</div>
        </div>
        
        <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 20px; border: 2px solid #FFD700;">
            <div style="display: flex; align-items: center; gap: 10px; justify-content: space-between;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 28px;">🎫</span>
                    <span style="font-size: 18px; color: #FFD700; font-weight: bold;">修仙令牌</span>
                </div>
                <div>
                    <span style="font-size: 24px; color: #FFD700; font-weight: bold;" id="nianDungeonToken">0</span>
                    <span style="font-size: 14px; color: #aaa;">个</span>
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
    <button onclick="challengeNianBeast()" id="challengeNianBtn" style="flex: 2; background: linear-gradient(145deg, #FFD700, #FFA500); color: #8B0000; border: none; padding: 12px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 18px; border: 2px solid #FFD700; display: flex; align-items: center; justify-content: center; gap: 8px;">
        <span>🎫</span> 消耗1令牌挑战年兽
        <span style="background: #8B0000; color: #FFD700; padding: 2px 8px; border-radius: 10px; font-size: 14px;" id="nianTokenDisplay">0</span>
    </button>
      <button onclick="buyNianToken()" style="flex: 1; background: linear-gradient(145deg, #4CAF50, #2E7D32); color: white; border: none; padding: 12px 20px; border-radius: 15px; cursor: pointer; font-weight: bold; display: flex; align-items: center; justify-content: center; gap: 5px;">
        <span>🛒</span> 购买
    </button>
</div>
        </div>
    </div>
    
    <!-- BOSS信息和战斗区域 -->
    <div style="display: grid; grid-template-columns: 1fr 1.2fr; gap: 20px; margin-bottom: 20px;">
        <!-- BOSS信息 -->
        <div style="background: linear-gradient(145deg, #C41E3A, #8B0000); padding: 20px; border-radius: 25px; border: 3px solid #FFD700; position: relative; overflow: hidden;">
            <div style="position: absolute; top: 10px; right: 10px; font-size: 60px; opacity: 0.2;">🐅</div>
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                <span style="font-size: 64px;">🐅</span>
                <div>
                    <div style="font-size: 28px; font-weight: bold; color: #FFD700;">新年年兽</div>
                    <div style="display: flex; gap: 10px; margin-top: 5px;">
                        <span style="background: rgba(255,215,0,0.3); padding: 3px 12px; border-radius: 15px; font-size: 14px;">Lv.<span id="nianBeastLevel">1</span></span>
                        <span style="background: rgba(255,215,0,0.3); padding: 3px 12px; border-radius: 15px; font-size: 14px;">复活: <span id="nianBeastReviveCount">10</span>次</span>
                    </div>
                </div>
            </div>
            
            <!-- BOSS血条 -->
            <div style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span style="color: #FFD700;">❤️ 年兽生命值</span>
                    <span style="color: #fff;" id="nianBeastHpText">1e10 / 1e10</span>
                </div>
                <div style="width: 100%; height: 20px; background: #630000; border-radius: 10px; border: 2px solid #FFD700; overflow: hidden;">
                    <div id="nianBeastHpBar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #FF6B6B, #FFD700); border-radius: 8px; transition: width 0.3s;"></div>
                </div>
            </div>
            
            <!-- BOSS属性 -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 15px;">
                <div>
                    <div style="font-size: 12px; color: #aaa;">攻击力</div>
                    <div style="font-size: 18px; color: #FFD700; font-weight: bold;" id="nianBeastAtk">1e5</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #aaa;">防御力</div>
                    <div style="font-size: 18px; color: #FFD700; font-weight: bold;">5e4</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #aaa;">狂暴时间</div>
                    <div style="font-size: 18px; color: #FFD700; font-weight: bold;">∞</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #aaa;">属性倍率</div>
                    <div style="font-size: 18px; color: #FFD700; font-weight: bold;" id="nianBeastMultiplier">1倍</div>
                </div>
            </div>
        </div>
        
        <!-- 战斗操作区域 -->
        <div style="background: rgba(196,30,58,0.3); padding: 20px; border-radius: 25px; border: 3px solid #FFD700; display: flex; flex-direction: column;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
                <span style="font-size: 32px;">⚔️</span>
                <span style="font-size: 20px; color: #FFD700; font-weight: bold;">战斗操作</span>
            </div>
            
            <!-- 玩家状态 -->
            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 15px; margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span style="color: #FFD700;">❤️ 你的生命值</span>
                    <span style="color: #FF6B6B; font-weight: bold;" id="nianBattlePlayerHp">0</span>
                </div>
                <div style="width: 100%; height: 10px; background: #630000; border-radius: 5px; margin-top: 5px; overflow: hidden;">
                    <div id="nianBattlePlayerHpBar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #4CAF50, #FFD700); border-radius: 5px;"></div>
                </div>
            </div>
            
            <!-- 攻击按钮 -->
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px; margin-bottom: 15px;">
                <button onclick="nianBeastAttack()" id="nianAttackBtn" style="background: linear-gradient(145deg, #FFD700, #FFA500); color: #8B0000; border: none; padding: 15px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 22px; border: 2px solid #FFD700;">
                    ⚡ 攻击年兽
                </button>
                <button onclick="nianBeastDefend()" id="nianDefendBtn" style="background: linear-gradient(145deg, #4CAF50, #2E7D32); color: white; border: none; padding: 15px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 18px;">
                    🛡️ 防御
                </button>
               <button onclick="nianBeastEscape()" id="nianEscapeBtn" style="background: linear-gradient(145deg, #f44336, #c62828); color: white; border: none; padding: 15px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 18px; border: 2px solid #FFD700; display: flex; align-items: center; justify-content: center; gap: 5px; animation: pulse-red 1.5s infinite;">
        🏃 逃跑
    </button>
            </div>
            
            <!-- 战斗日志 -->
            <div style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 15px; flex: 1; max-height: 150px; overflow-y: auto;">
                <div style="color: #FFD700; font-size: 14px; margin-bottom: 10px;">📜 战斗记录</div>
                <div id="nianBattleLog" style="font-size: 12px; color: #aaa; display: flex; flex-direction: column; gap: 5px;">
                    点击攻击按钮开始讨伐年兽！
                </div>
            </div>
        </div>
    </div>
    
    <!-- 奖励预览 -->
    <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 20px; border: 2px solid #FFD700; margin-top: 10px;" id="rewardPreviewContainer">
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
        <span style="font-size: 24px;">🎁</span>
        <span style="font-size: 16px; color: #FFD700; font-weight: bold;">奖励解锁预览 (Lv.<span id="previewRewardLevel">1</span>)</span>
    </div>
    <div id="rewardPreviewContent" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 8px;">
        <!-- 动态生成奖励预览 -->
    </div>
    <div id="firstLevelTip" style="margin-top: 10px; padding: 8px; background: rgba(255,107,107,0.2); border-radius: 8px; border: 1px solid #FF6B6B; text-align: center;">
        <span style="color: #FF6B6B; font-weight: bold;">⚠️ 试炼阶段</span>
        <span style="color: #aaa; font-size: 12px; margin-left: 10px;">第一层只有远古圣兽精魄</span>
    </div>
</div>
        </div>
    </div>
</div>

<!-- 年兽副本奖励弹窗 -->
<div id="nianRewardOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 3000;"></div>
<div id="nianRewardUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #FFD700, #FFA500); color: #8B0000; padding: 40px; border: 5px solid #FFD700; border-radius: 40px; z-index: 3001; width: 650px; max-height: 80vh; overflow-y: auto; box-shadow: 0 0 60px rgba(255, 215, 0, 0.8); animation: pop-up 0.5s;">
    
    <div style="position: absolute; top: -30px; left: 50%; transform: translateX(-50%); font-size: 60px; filter: drop-shadow(0 0 20px rgba(255,215,0,0.8));">🏆</div>
    
    <div style="text-align: center; margin-bottom: 30px;">
        <h2 style="font-size: 48px; margin: 20px 0 10px; text-shadow: 0 0 20px #8B0000;">🎉 讨伐成功！</h2>
        <div style="font-size: 24px; background: #8B0000; color: #FFD700; padding: 10px 30px; border-radius: 50px; display: inline-block; font-weight: bold;">
            击败 Lv.<span id="rewardBeastLevel">1</span> 年兽
        </div>
    </div>
    
    <div style="background: #8B0000; border-radius: 30px; padding: 25px; border: 3px solid #FFD700; margin-bottom: 25px;">
        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
            <span style="font-size: 36px;">🎁</span>
            <span style="font-size: 24px; color: #FFD700; font-weight: bold;">讨伐奖励</span>
        </div>
        
        <div id="nianRewardItems" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
            <!-- 奖励动态生成 -->
        </div>
    </div>
    
    <div style="display: flex; gap: 20px; justify-content: center;">
        <button onclick="claimNianRewards()" style="background: linear-gradient(145deg, #8B0000, #630000); color: #FFD700; border: 3px solid #FFD700; padding: 15px 40px; border-radius: 40px; cursor: pointer; font-weight: bold; font-size: 22px;">
            ✨ 领取奖励
        </button>
        <button onclick="closeNianRewards()" style="background: rgba(0,0,0,0.5); color: white; border: 3px solid #aaa; padding: 15px 40px; border-radius: 40px; cursor: pointer; font-weight: bold; font-size: 22px;">
            关闭
        </button>
    </div>
</div>
    </div>
</div>
</div>
<div id="pillSystemOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;"></div>
<div id="pillSystemUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #4A2C4A, #2A1A2A); color: white; padding: 30px; border: 3px solid #FF69B4; border-radius: 20px; z-index: 1001; width: 700px; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(255,105,180,0.3); animation: glow-pink 3s infinite;">
    
    <div style="position: absolute; top: -15px; left: -15px; font-size: 40px; transform: rotate(-10deg);">💊</div>
    <div style="position: absolute; top: -15px; right: -15px; font-size: 40px; transform: rotate(10deg);">✨</div>
    
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 2px solid #FF69B4;">
        <div style="display: flex; align-items: center; gap: 15px;">
            <h2 style="color: #FF69B4; margin: 0; text-shadow: 0 0 15px #FF69B4; font-size: 32px;">💊 丹药系统</h2>
            <div style="background: #C71585; padding: 5px 15px; border-radius: 20px; border: 2px solid #FF69B4;">
                <span style="color: #FFD700; font-weight: bold;">一键转换经验</span>
            </div>
        </div>
        <button onclick="togglePillSystem()" style="background: linear-gradient(45deg, #f44336, #c62828); color: white; border: none; padding: 8px 25px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 16px;">关闭</button>
    </div>
    
    <!-- 当前修仙经验显示 -->
    <div style="background: linear-gradient(145deg, #3A1F3A, #2A152A); padding: 20px; border-radius: 15px; margin-bottom: 25px; border: 2px solid #FF69B4;">
        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
            <span style="font-size: 28px;">📈</span>
            <span style="color: #FFD700; font-size: 18px; font-weight: bold;">当前修仙经验</span>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="font-size: 32px; color: #4CAF50; font-weight: bold;" id="pillCurrentExp">0</div>
            <div style="font-size: 16px; color: #aaa;">
                下一级需要: <span style="color: #FFD700;" id="pillNextExp">1000</span>
            </div>
        </div>
        <div style="width: 100%; height: 12px; background: #2A152A; border-radius: 6px; margin-top: 15px; overflow: hidden; border: 1px solid #FF69B4;">
            <div id="pillExpProgress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4CAF50, #FF69B4); border-radius: 6px;"></div>
        </div>
    </div>
    
    <!-- 丹药转换列表 -->
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 25px;">
        
        <div style="background: linear-gradient(145deg, #3A1F3A, #2A152A); padding: 20px; border-radius: 15px; border: 2px solid #4CAF50; position: relative; overflow: hidden;">
            <div style="position: absolute; top: 5px; right: 5px; font-size: 20px; opacity: 0.3;">💊</div>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <span style="font-size: 28px;"></span>
                <span style="color: #4CAF50; font-size: 18px; font-weight: bold;">蕴灵筑基丹</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span style="color: #aaa;">拥有数量:</span>
                <span style="color: #FFD700; font-weight: bold;" id="pillSoulCount">0</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                <span style="color: #aaa;">转换经验:</span>
                <span style="color: #4CAF50; font-weight: bold;">10,000 经验/个</span>
            </div>
             <div style="display: flex; gap: 10px;">   
            </div>
        </div>
        
        <!-- 初级宝石 -->
        <div style="background: linear-gradient(145deg, #3A1F3A, #2A152A); padding: 20px; border-radius: 15px; border: 2px solid #2196F3; position: relative; overflow: hidden;">
            <div style="position: absolute; top: 5px; right: 5px; font-size: 20px; opacity: 0.3;">💊</div>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <span style="font-size: 28px;"></span>
                <span style="color: #2196F3; font-size: 18px; font-weight: bold;">凝元固窍丹</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span style="color: #aaa;">拥有数量:</span>
                <span style="color: #FFD700; font-weight: bold;" id="pillGemCount">0</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                <span style="color: #aaa;">转换经验:</span>
                <span style="color: #2196F3; font-weight: bold;">100,000 经验/个</span>
            </div>
<div style="display: flex; gap: 10px;">
            </div>
        </div>
        
        <!-- 洗髓丹 -->
        <div style="background: linear-gradient(145deg, #3A1F3A, #2A152A); padding: 20px; border-radius: 15px; border: 2px solid #9C27B0; position: relative; overflow: hidden;">
            <div style="position: absolute; top: 5px; right: 5px; font-size: 20px; opacity: 0.3;">💊</div>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <span style="font-size: 28px;"></span>
                <span style="color: #9C27B0; font-size: 18px; font-weight: bold;">渡厄金还丹</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span style="color: #aaa;">拥有数量:</span>
                <span style="color: #FFD700; font-weight: bold;" id="pillPillCount">0</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                <span style="color: #aaa;">转换经验:</span>
                <span style="color: #9C27B0; font-weight: bold;">1,000,000 经验/个</span>
            </div>
            <div style="display: flex; gap: 10px;">

            </div>
        </div>
        
        <!-- 香囊 -->
        <div style="background: linear-gradient(145deg, #3A1F3A, #2A152A); padding: 20px; border-radius: 15px; border: 2px solid #FF5722; position: relative; overflow: hidden;">
            <div style="position: absolute; top: 5px; right: 5px; font-size: 20px; opacity: 0.3;">💊</div>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <span style="font-size: 28px;"></span>
                <span style="color: #FF5722; font-size: 18px; font-weight: bold;">九转轮回丹</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span style="color: #aaa;">拥有数量:</span>
                <span style="color: #FFD700; font-weight: bold;" id="pillPouchCount">0</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                <span style="color: #aaa;">转换经验:</span>
                <span style="color: #FF5722; font-weight: bold;">10,000,000 经验/个</span>
            </div>
<div style="display: flex; gap: 10px;">
            </div>
        </div>
        
        <!-- 星辰发票 -->
        <div style="background: linear-gradient(145deg, #3A1F3A, #2A152A); padding: 20px; border-radius: 15px; border: 2px solid #FFD700; grid-column: span 2; position: relative; overflow: hidden;">
            <div style="position: absolute; top: 5px; right: 5px; font-size: 20px; opacity: 0.3;">💊</div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <span style="font-size: 32px;"></span>
                <div style="flex: 1;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="color: #FFD700; font-size: 18px; font-weight: bold;">混元道果丹</span>
                        <span style="color: #FFD700; font-weight: bold;" id="pillStarBillCount">0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #aaa;">转换经验:</span>
                        <span style="color: #FFD700; font-weight: bold;">100,000,000 经验/个</span>
                    </div>
                </div>
                <div style="display: flex; gap: 10px;">

                </div>
            </div>
        </div>
    </div>
    
    <!-- 一键使用所有按钮 -->
    <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
        <button onclick="useAllPills()" style="background: linear-gradient(45deg, #FF69B4, #C71585); color: white; border: none; padding: 15px 40px; border-radius: 30px; cursor: pointer; font-weight: bold; font-size: 18px; border: 2px solid #FFD700; box-shadow: 0 0 20px rgba(255,105,180,0.5);">
            ✨ 一键使用所有丹药
        </button>
    </div>
</div>
</div>
</div>
<!-- 逃跑确认弹窗 -->
<div id="escapeConfirmOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2147483647;"></div>
<div id="escapeConfirmDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #8B0000, #630000); color: white; padding: 30px; border: 5px solid #FFD700; border-radius: 20px; z-index: 2147483647; width: 450px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.8); animation: pop-up 0.3s;">
    <div style="position: absolute; top: -20px; left: -20px; font-size: 40px;">⚠️</div>
    <div style="position: absolute; top: -20px; right: -20px; font-size: 40px;">🏃</div>
    
    <div style="font-size: 64px; margin-bottom: 20px; animation: shake 0.5s infinite;">😱</div>
    
    <h3 style="color: #FFD700; margin-bottom: 20px; font-size: 28px; text-shadow: 0 0 10px #FFD700;">确认逃跑？</h3>
    
    <div style="background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px; margin-bottom: 25px; border: 2px solid #FFD700;">
        <div style="color: #FFD700; font-size: 18px; margin-bottom: 10px;">⚠️ 逃跑后果：</div>
        <div style="color: #fff; font-size: 16px; margin-bottom: 5px;">• 立即战败死亡</div>
        <div style="color: #fff; font-size: 16px; margin-bottom: 5px;">• 根据当前层数结算奖励</div>
        <div style="color: #FFD700; font-size: 16px;">• 当前层数: Lv.<span id="escapeCurrentLevel">1</span></div>
    </div>
    
    <div style="display: flex; gap: 15px; justify-content: center;">
        <button onclick="confirmEscape()" style="background: linear-gradient(45deg, #f44336, #c62828); color: white; border: 3px solid #FFD700; padding: 15px 30px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 18px; flex: 1; animation: pulse-red 1s infinite;">
            🏃 确认逃跑
        </button>
        <button onclick="cancelEscape()" style="background: linear-gradient(45deg, #4CAF50, #2E7D32); color: white; border: 3px solid #4CAF50; padding: 15px 30px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 18px; flex: 1;">
            ✨ 继续战斗
        </button>
    </div>
</div>
</div>
</div>
<!-- 试练塔UI弹窗 -->
<div id="trialTowerOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000;"></div>
<div id="trialTowerUI" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, #2A1A2A, #1A0A1A); color: white; padding: 30px; border: 5px solid #9C27B0; border-radius: 30px; z-index: 2001; width: 900px; max-height: 85vh; overflow-y: auto; box-shadow: 0 0 50px rgba(156,39,176,0.6); animation: glow-purple 3s infinite;">
    
    <div style="position: absolute; top: -20px; left: -20px; font-size: 50px; transform: rotate(-15deg);">🗼</div>
    <div style="position: absolute; top: -20px; right: -20px; font-size: 50px; transform: rotate(15deg);">⚔️</div>
    
    <!-- 标题区域 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 3px solid #9C27B0;">
        <div style="display: flex; align-items: center; gap: 15px;">
            <h2 style="color: #9C27B0; margin: 0; text-shadow: 0 0 20px #9C27B0; font-size: 36px; font-weight: bold;">🗼 无限试练塔</h2>
            <div style="background: #4A2C4A; padding: 5px 15px; border-radius: 20px; border: 2px solid #9C27B0;">
                <span style="color: #9C27B0; font-weight: bold;">当前层数: <span id="trialCurrentFloor">1</span>层</span>
            </div>
        </div>
        <button onclick="closeTrialTower()" style="background: #4A2C4A; color: white; border: 2px solid #9C27B0; padding: 8px 25px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 18px;">关闭</button>
    </div>
    
    <!-- 玩家和怪物信息区域 -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
        <!-- 玩家信息 -->
        <div style="background: rgba(156,39,176,0.1); padding: 20px; border-radius: 20px; border: 2px solid #9C27B0;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <span style="font-size: 28px;">⚔️</span>
                <span style="font-size: 20px; color: #9C27B0; font-weight: bold;">挑战者属性</span>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <div style="font-size: 14px; color: #aaa;">生命值</div>
                    <div style="font-size: 24px; color: #FF6B6B; font-weight: bold;" id="trialPlayerHp">0</div>
                </div>
                <div>
                    <div style="font-size: 14px; color: #aaa;">攻击力</div>
                    <div style="font-size: 24px; color: #FF6B6B; font-weight: bold;" id="trialPlayerAtk">0</div>
                </div>
                <div>
                    <div style="font-size: 14px; color: #aaa;">暴击伤害</div>
                    <div style="font-size: 20px; color: #FFD700; font-weight: bold;" id="trialPlayerCrit">0%</div>
                </div>
                <div>
                    <div style="font-size: 14px; color: #aaa;">暴击几率</div>
                    <div style="font-size: 20px; color: #FFD700; font-weight: bold;">30%</div>
                </div>
            </div>
        </div>
        
        <!-- 怪物信息 -->
        <div style="background: rgba(156,39,176,0.1); padding: 20px; border-radius: 20px; border: 2px solid #FF6B6B;" id="trialMonsterInfo">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <span style="font-size: 28px;">👾</span>
                <span style="font-size: 20px; color: #FF6B6B; font-weight: bold;" id="trialMonsterName">试练怪物</span>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <div style="font-size: 14px; color: #aaa;">生命值</div>
                    <div style="font-size: 24px; color: #FF6B6B; font-weight: bold;" id="trialMonsterHp">0</div>
                </div>
                <div>
                    <div style="font-size: 14px; color: #aaa;">攻击力</div>
                    <div style="font-size: 24px; color: #FF6B6B; font-weight: bold;" id="trialMonsterAtk">0</div>
                </div>
            </div>
            <!-- 怪物血条 -->
            <div style="margin-top: 15px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span style="color: #aaa;">怪物血量</span>
                    <span style="color: #FFD700;" id="trialMonsterHpText">0/0</span>
                </div>
                <div style="width: 100%; height: 15px; background: #4A2C4A; border-radius: 8px; overflow: hidden; border: 1px solid #FF6B6B;">
                    <div id="trialMonsterHpBar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #FF6B6B, #FFD700); border-radius: 8px;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 战斗操作区域 -->
    <div style="background: rgba(156,39,176,0.1); padding: 20px; border-radius: 20px; border: 2px solid #9C27B0; margin-bottom: 20px;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
            <span style="font-size: 24px;">⚔️</span>
            <span style="font-size: 18px; color: #9C27B0; font-weight: bold;">战斗操作</span>
        </div>
        
        <!-- 玩家状态 -->
        <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 15px; margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #FFD700;">❤️ 你的生命值</span>
                <span style="color: #FF6B6B; font-weight: bold;" id="trialBattlePlayerHp">0</span>
            </div>
            <div style="width: 100%; height: 10px; background: #4A2C4A; border-radius: 5px; margin-top: 5px; overflow: hidden;">
                <div id="trialBattlePlayerHpBar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #4CAF50, #FFD700); border-radius: 5px;"></div>
            </div>
        </div>
        
        <!-- 战斗按钮 -->
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
            <button onclick="trialTowerAttack()" id="trialAttackBtn" style="background: linear-gradient(145deg, #FFD700, #FFA500); color: #8B0000; border: none; padding: 15px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 18px; border: 2px solid #FFD700;">
                ⚔️ 攻击
            </button>
            <button onclick="trialTowerDefend()" id="trialDefendBtn" style="background: linear-gradient(145deg, #4CAF50, #2E7D32); color: white; border: none; padding: 15px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 18px; border: 2px solid #4CAF50;">
                🛡️ 防御
            </button>
            <button onclick="trialTowerRestart()" id="trialRestartBtn" style="background: linear-gradient(145deg, #9C27B0, #6A1B9A); color: white; border: none; padding: 15px; border-radius: 15px; cursor: pointer; font-weight: bold; font-size: 18px; border: 2px solid #9C27B0;">
                🔄 重新挑战
            </button>
        </div>
        
        <!-- 战斗日志 -->
        <div style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 15px; max-height: 150px; overflow-y: auto; border: 1px solid #9C27B0; display: flex; flex-direction: column-reverse;" id="trialBattleLog">
            <div style="color: #666; text-align: center;">点击攻击按钮开始挑战</div>
        </div>
    </div>
    
    <!-- 层数信息和奖励预览 -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <div style="background: rgba(156,39,176,0.1); padding: 15px; border-radius: 15px; border: 2px solid #9C27B0;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <span style="font-size: 20px;">📊</span>
                <span style="color: #9C27B0; font-weight: bold;">层数信息</span>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <div>
                    <div style="color: #aaa; font-size: 12px;">当前层数</div>
                    <div style="color: #FFD700; font-size: 24px; font-weight: bold;" id="trialFloorDisplay">1</div>
                </div>
                <div>
                    <div style="color: #aaa; font-size: 12px;">最高层数</div>
                    <div style="color: #4CAF50; font-size: 24px; font-weight: bold;" id="trialHighestFloor">0</div>
                </div>
                <div>
                    <div style="color: #aaa; font-size: 12px;">总挑战次数</div>
                    <div style="color: #9C27B0; font-size: 20px; font-weight: bold;" id="trialTotalChallenges">0</div>
                </div>
                <div>
                    <div style="color: #aaa; font-size: 12px;">总胜利次数</div>
                    <div style="color: #4CAF50; font-size: 20px; font-weight: bold;" id="trialTotalWins">0</div>
                </div>
            </div>
        </div>
        
        <div style="background: rgba(156,39,176,0.1); padding: 15px; border-radius: 15px; border: 2px solid #9C27B0;">
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
        <span style="font-size: 20px;">🎁</span>
        <span style="color: #9C27B0; font-weight: bold;">层数奖励预览</span>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
        <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 8px; text-align: center;">
            <div style="color: #FFD700; font-size: 20px; font-weight: bold;" id="trialNextRewardFloor">10</div>
            <div style="color: #aaa; font-size: 12px;">下一10层奖励</div>
            <div style="color: #4CAF50; font-size: 14px;" id="trialNextRewardDesc1">洗髓丹×10</div>
        </div>
        <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 8px; text-align: center;">
            <div style="color: #FFD700; font-size: 20px; font-weight: bold;" id="trialNextRewardFloor2">20</div>
            <div style="color: #aaa; font-size: 12px;">再下一层奖励</div>
            <div style="color: #4CAF50; font-size: 14px;" id="trialNextRewardDesc2">初级宝石×20</div>
        </div>
    </div>
    <div id="trialRewardDetail"></div>
</div>
    </div>
</div>
</div>
</div>

<!-- 无限深渊系统 -->
<div id="abyssTowerOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2050;"></div>
<div id="abyssTowerUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a0a2e,#0d0518);color:#e0e0e0;padding:20px;border:4px solid #6a0dad;border-radius:20px;z-index:2051;width:1120px;max-height:90vh;overflow-y:auto;box-shadow:0 0 40px rgba(106,13,173,0.5);">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid #6a0dad;flex-wrap:wrap;gap:10px;">
        <div style="display:flex;align-items:center;gap:12px;">
            <h2 style="color:#b388ff;margin:0;">&#128301; 无限深渊</h2>
            <div id="abyssHeaderPlayer" style="display:flex;align-items:center;gap:8px;">
                <img id="abyssPlayerAvatar" src="" alt="" style="width:36px;height:36px;object-fit:cover;border-radius:50%;border:2px solid #b388ff;background:#2a1a4a;" onerror="this.style.display='none';this.nextElementSibling&&(this.nextElementSibling.style.display='flex');">
                <span id="abyssPlayerAvatarPlaceholder" style="display:none;width:36px;height:36px;border-radius:50%;border:2px solid #b388ff;background:linear-gradient(145deg,#6a0dad,#4a0072);align-items:center;justify-content:center;font-size:16px;color:#ce93d8;font-weight:bold;">?</span>
                <span id="abyssPlayerName" style="color:#e0e0e0;font-weight:bold;font-size:15px;">勇者</span>
            </div>
        </div>
        <div style="display:flex;gap:10px;align-items:center;">
            <span style="color:#ffd700;">深渊币: <b id="abyssExclusiveCurrency">0</b></span>
            <span style="color:#4caf50;">最佳层数: <b id="abyssBestFloor">0</b></span>
            <button id="abyssEscapeBtn" onclick="abyssEscapeAndClaim()" style="display:none;background:#5a2a2a;color:#ff9999;border:2px solid #c2185b;padding:6px 18px;border-radius:8px;cursor:pointer;font-weight:bold;">逃跑</button>
            <button onclick="closeAbyssTower()" style="background:#4a2c4a;color:#fff;border:2px solid #6a0dad;padding:6px 18px;border-radius:8px;cursor:pointer;font-weight:bold;">关闭</button>
        </div>
    </div>
    <div id="abyssStartPanel" style="text-align:center;padding:20px;">
        <p style="color:#aaa;margin-bottom:15px;">层数无限，每10关一个BOSS。通关可获得临时装备与属性，失败获得深渊币用于永久加成。</p>
        <p style="color:#b388ff;margin-bottom:8px;">选择职业</p>
        <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-bottom:12px;">
            <button type="button" onclick="abyssSelectClass('warrior')" id="abyssClassWarrior" style="background:linear-gradient(145deg,#8b4513,#5d2e0a);color:#ffd700;border:2px solid #daa520;padding:12px 24px;border-radius:10px;cursor:pointer;font-weight:bold;">⚔ 战士</button>
            <button type="button" onclick="abyssSelectClass('mage')" id="abyssClassMage" style="background:linear-gradient(145deg,#4a148c,#1a0a2e);color:#ce93d8;border:2px solid #7c4dff;padding:12px 24px;border-radius:10px;cursor:pointer;font-weight:bold;">🔮 法师</button>
            <button type="button" onclick="abyssSelectClass('archer')" id="abyssClassArcher" style="background:linear-gradient(145deg,#1b5e20,#0d3d0d);color:#81c784;border:2px solid #4caf50;padding:12px 24px;border-radius:10px;cursor:pointer;font-weight:bold;">🏹 射手</button>
        </div>
        <p id="abyssClassDesc" style="color:#888;font-size:13px;margin-bottom:15px;">战士：攻击+18，生命+320，防御+18；力量、体力转化收益+20%</p>
        <p style="color:#ffd700;margin-bottom:10px;">开局装备: <span id="abyssStartGearCount">0</span>/20 件（专属商店购买，每买1次+1件）</p>
        <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-bottom:15px;">
            <button onclick="startAbyssRun()" id="abyssStartBtn" style="background:linear-gradient(145deg,#6a0dad,#4a0072);color:#fff;border:2px solid #b388ff;padding:14px 40px;border-radius:12px;cursor:pointer;font-size:18px;font-weight:bold;">开始闯关</button>
            <button onclick="openAbyssExclusiveShop()" style="background:linear-gradient(145deg,#2e7d32,#1b5e20);color:#fff;border:2px solid #4caf50;padding:14px 28px;border-radius:12px;cursor:pointer;font-size:16px;font-weight:bold;">专属商店（永久加成）</button>
            <button onclick="openAbyssVault()" style="background:linear-gradient(145deg,#4a148c,#6a1b9a);color:#fff;border:2px solid #b388ff;padding:14px 28px;border-radius:12px;cursor:pointer;font-size:16px;font-weight:bold;">深渊宝库（永久加成）</button>
        </div>
    </div>
    <div id="abyssRunPanel" style="display:none;">
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-bottom:15px;">
            <div style="background:rgba(106,13,173,0.2);padding:15px;border-radius:12px;border:1px solid #6a0dad;">
                <div style="color:#b388ff;font-weight:bold;margin-bottom:8px;">当前层数: <span id="abyssCurrentFloor">1</span> &nbsp; 等级: <span id="abyssPlayerLevel">0</span> <span id="abyssPlayerZhuan" style="color:#ffd700;"></span></div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:13px;">
                    <div>生命: <span id="abyssPlayerHp" style="color:#ff6b6b;">0</span>/<span id="abyssPlayerMaxHp">0</span> <span id="abyssPlayerShieldWrap" style="display:none;">护盾: <span id="abyssPlayerShield" style="color:#00bcd4;">0</span></span></div>
                    <div>魔法: <span id="abyssPlayerMp" style="color:#00bcd4;">0</span>/<span id="abyssPlayerMaxMp">0</span></div>
                    <div>攻击: <span id="abyssPlayerAtk" style="color:#ffd700;">0</span></div>
                    <div>防御: <span id="abyssPlayerDef">0</span></div>
                    <div>暴击: <span id="abyssPlayerCritRate">0%</span></div>
                    <div>爆伤: <span id="abyssPlayerCritDmg">0%</span></div>
                    <div>闪避: <span id="abyssPlayerDodge">0%</span></div>
                    <div>吸血: <span id="abyssPlayerLifesteal">0%</span></div>
                    <div>连击: <span id="abyssPlayerCombo">0%</span></div>
                    <div>技能伤害加成: <span id="abyssPlayerSkillDmg">0%</span></div>
                    <div>减少怪物防御: <span id="abyssPlayerReduceDef">0%</span></div>
                    <div style="color:#b388ff;">五行攻(金/木/水/火/土): <span id="abyssPlayerElementAtk">0/0/0/0/0</span></div>
                    <div style="color:#b388ff;">五行抗(金/木/水/火/土): <span id="abyssPlayerElementRes">0%/0%/0%/0%/0%</span></div>
                    <div style="color:#b388ff;">力量/敏捷/智力/体力: <span id="abyssPlayerStrAgiIntSta">0/0/0/0</span></div>
                    <div>经验: <span id="abyssPlayerExp">0</span></div>
                </div>
                <div style="margin-top:10px;padding:8px;background:rgba(106,13,173,0.2);border-radius:8px;border:1px solid #6a0dad;font-size:12px;">
                    <div style="color:#b388ff;margin-bottom:6px;">📈 本次闯关加成</div>
                    <div id="abyssCurseTrialHint" style="font-size:11px;color:#ce93d8;margin-bottom:4px;min-height:14px;"></div>
                    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px 12px;">
                        <span>攻击: <span id="abyssBonusAtk">0</span>%</span>
                        <span>生命: <span id="abyssBonusHp">0</span>%</span>
                        <span>防御: <span id="abyssBonusDef">0</span>%</span>
                        <span>吸血: <span id="abyssBonusLifesteal">0</span>%</span>
                        <span>暴击率: <span id="abyssBonusCritRate">0</span>%</span>
                        <span>爆伤: <span id="abyssBonusCritDmg">0</span>%</span>
                        <span>闪避: <span id="abyssBonusDodge">0</span>%</span>
                        <span>宠物攻: <span id="abyssBonusPetAtk">0</span>%</span>
                        <span>宠物防: <span id="abyssBonusPetDef">0</span>%</span>
                        <span>宠物生命: <span id="abyssBonusPetHp">0</span>%</span>
                        <span>金币: <span id="abyssBonusGold">0</span>%</span>
                        <span>经验: <span id="abyssBonusExp">0</span>%</span>
                    </div>
                </div>
                <div style="margin-top:8px;"><div style="height:8px;background:#333;border-radius:4px;overflow:hidden;"><div id="abyssPlayerHpBar" style="height:100%;background:linear-gradient(90deg,#4caf50,#ff9800);width:100%;border-radius:4px;"></div></div></div>
                <div style="margin-top:4px;"><div style="height:6px;background:#333;border-radius:3px;overflow:hidden;"><div id="abyssPlayerMpBar" style="height:100%;background:linear-gradient(90deg,#00bcd4,#2196f3);width:100%;border-radius:3px;"></div></div></div>
            </div>
            <div style="flex:1;min-width:0;">
                <div style="color:#ff6b6b;font-size:12px;margin-bottom:6px;">怪物（点击选择攻击目标）</div>
                <div id="abyssMonstersContainer" style="display:flex;flex-wrap:wrap;gap:10px;"></div>
            </div>
        </div>
        <div style="margin-bottom:10px;">
            <div style="color:#b388ff;font-size:12px;margin-bottom:6px;">人物技能（点击后下次攻击释放）</div>
            <div id="abyssSkillRow" style="display:flex;gap:8px;flex-wrap:wrap;"></div>
        </div>
        <div style="display:flex;gap:10px;margin-bottom:15px;flex-wrap:wrap;">
            <button onclick="abyssAttack()" style="background:linear-gradient(145deg,#c62828,#8b0000);color:#fff;border:none;padding:12px 20px;border-radius:8px;cursor:pointer;font-weight:bold;">⚔ 攻击</button>
            <button onclick="toggleAbyssAutoAttack()" id="abyssAttackBtn" style="background:linear-gradient(145deg,#ff6b6b,#c62828);color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:bold;">自动攻击: <span id="abyssAutoAttackStatus">关</span></button>
            <button onclick="useAbyssPotion()" id="abyssPotionBtn" style="background:linear-gradient(145deg,#4caf50,#2e7d32);color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:bold;">使用药剂</button>
            <button onclick="openAbyssTempShop()" id="abyssShopBtn" style="display:none;background:linear-gradient(145deg,#ffd700,#daa520);color:#333;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:bold;">临时商店</button>
            <button onclick="openAbyssEquipmentPanel()" style="background:linear-gradient(145deg,#6a0dad,#4a0072);color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:bold;">装备/背包</button>
            <button onclick="openAbyssTalentPanel()" style="background:linear-gradient(145deg,#ff9800,#e65100);color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:bold;">天赋</button>
            <button onclick="openAbyssSkillPanel()" style="background:linear-gradient(145deg,#9c27b0,#6a1b9a);color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:bold;">技能</button>
            <button onclick="openAbyssPetPanel()" style="background:linear-gradient(145deg,#e91e63,#ad1457);color:#fff;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:bold;">宠物</button>
            <button onclick="openAbyssChallengeShop()" style="background:linear-gradient(145deg,#ffd700,#daa520);color:#333;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:bold;">闯关商店</button>
        </div>
        <div style="margin-bottom:6px;font-size:12px;color:#e91e63;"><span id="abyssDeployedPetInfo">出战宠物: 无</span> &nbsp; <button type="button" id="abyssPetGuardBtn" onclick="abyssTogglePetGuard()" style="background:#4a2c4a;color:#ff80ab;border:1px solid #c2185b;padding:4px 10px;border-radius:6px;cursor:pointer;font-size:12px;">守护: 关</button></div>
        <div id="abyssBattleLog" style="height:120px;overflow-y:auto;background:rgba(0,0,0,0.5);padding:10px;border-radius:8px;font-size:13px;border:1px solid #6a0dad;"></div>
    </div>
</div>

<!-- 无限深渊-宠物面板（梦幻西游风格） -->
<div id="abyssPetOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2074;" onclick="closeAbyssPetPanel()"></div>
<div id="abyssPetUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(160deg,#2a1a3a 0%,#1a0a22 50%,#0d0515 100%);color:#e0e0e0;padding:0;border:3px solid #c2185b;border-radius:12px;z-index:2075;width:620px;max-height:88vh;overflow:hidden;box-shadow:0 0 30px rgba(194,24,91,0.4);">
    <div style="background:linear-gradient(90deg,#4a1942,#2d0f28);padding:12px 16px;border-bottom:2px solid #c2185b;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;">
        <h3 style="color:#ff80ab;margin:0;font-size:18px;">🐾 宠物</h3>
        <span style="color:#b388ff;font-size:13px;">复活药水: <b id="abyssPetReviveCount">0</b></span>
        <span style="color:#ffb74d;font-size:13px;">宠物兽决: <b id="abyssPetSkillBookCount">0</b></span>
        <button type="button" id="abyssPetGuardBtnPanel" onclick="abyssTogglePetGuard(); if(abyssRun && abyssRun.active) updateAbyssRunUI();" style="background:#4a2c4a;color:#ff80ab;border:1px solid #c2185b;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:12px;">守护: 关</button>
        <button type="button" onclick="openAbyssPetSynthesisPanel()" style="background:#6a1b9a;color:#ff80ab;border:1px solid #b388ff;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:12px;">宠物合成</button>
        <button onclick="closeAbyssPetPanel()" style="background:#5c3d5c;color:#ff80ab;border:1px solid #c2185b;padding:6px 14px;border-radius:6px;cursor:pointer;">关闭</button>
    </div>
    <div style="display:flex;height:380px;">
        <div style="width:200px;border-right:2px solid #4a1942;overflow-y:auto;background:rgba(0,0,0,0.25);">
            <div style="padding:8px;color:#b388ff;font-size:12px;display:flex;justify-content:space-between;align-items:center;"><span>宠物列表</span><span id="abyssPetCount" style="color:#ff80ab;">0/10</span></div>
            <div id="abyssPetList" style="padding:4px;"></div>
        </div>
        <div style="flex:1;padding:16px;overflow-y:auto;">
            <div id="abyssPetDetail" style="min-height:320px;">
                <div style="color:#888;text-align:center;padding:40px 20px;">选择左侧宠物查看详情</div>
            </div>
            <div id="abyssPetDetailActions" style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;"></div>
        </div>
    </div>
</div>

<!-- 无限深渊-宠物合成弹窗（梦幻西游风格） -->
<div id="abyssPetSynthesisOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2076;" onclick="closeAbyssPetSynthesisPanel()"></div>
<div id="abyssPetSynthesisUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(160deg,#2a1a4a 0%,#1a0a2e 50%,#0d0518 100%);color:#e0e0e0;padding:20px;border:3px solid #b388ff;border-radius:12px;z-index:2077;width:480px;box-shadow:0 0 30px rgba(179,136,255,0.4);" onclick="event.stopPropagation();">
    <h3 style="color:#b388ff;margin:0 0 12px 0;font-size:18px;">🔮 宠物合成</h3>
    <p style="color:#aaa;font-size:12px;margin-bottom:12px;">选择两只宠物合成：50%继承第一只/50%继承第二只；资质在继承基础上±20%波动；技能从两只宠物技能池中随机抽取，数量按概率：5%得10%、20%得25%、50%得50%、20%得75%、5%得100%。</p>
    <div style="margin-bottom:12px;">
        <label style="color:#ce93d8;font-size:13px;">第一只</label>
        <select id="abyssSynthesisPet1" style="width:100%;padding:8px;background:#1a0a2e;color:#fff;border:1px solid #b388ff;border-radius:6px;margin-top:4px;"></select>
    </div>
    <div style="margin-bottom:12px;">
        <label style="color:#ce93d8;font-size:13px;">第二只</label>
        <select id="abyssSynthesisPet2" style="width:100%;padding:8px;background:#1a0a2e;color:#fff;border:1px solid #b388ff;border-radius:6px;margin-top:4px;"></select>
    </div>
    <div style="margin-bottom:12px;">
        <label style="color:#ce93d8;font-size:13px;">可能获得的全部技能（共 <span id="abyssSynthesisSkillCount">0</span> 个）</label>
        <div id="abyssSynthesisSkillPool" style="margin-top:6px;padding:8px;background:rgba(0,0,0,0.35);border-radius:6px;border:1px solid #555;font-size:12px;color:#b388ff;min-height:24px;max-height:120px;overflow-y:auto;"></div>
    </div>
    <div style="display:flex;gap:10px;justify-content:flex-end;">
        <button type="button" onclick="closeAbyssPetSynthesisPanel()" style="background:#555;color:#ccc;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">取消</button>
        <button type="button" id="abyssSynthesisConfirmBtn" onclick="abyssDoPetSynthesis()" style="background:#6a1b9a;color:#ff80ab;border:1px solid #b388ff;padding:8px 20px;border-radius:6px;cursor:pointer;font-weight:bold;">确认合成</button>
    </div>
</div>

<!-- 无限深渊-天赋树面板 -->
<div id="abyssTalentOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2074;" onclick="closeAbyssTalentPanel()"></div>
<div id="abyssTalentUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(160deg,#2a1a1a 0%,#1a0a0a 50%,#0d0505 100%);color:#e0e0e0;padding:20px;border:3px solid #ff9800;border-radius:12px;z-index:2075;width:520px;max-height:85vh;overflow-y:auto;box-shadow:0 0 30px rgba(255,152,0,0.3);">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;border-bottom:2px solid #ff9800;padding-bottom:10px;">
        <h3 style="color:#ffb74d;margin:0;">🌳 天赋树</h3>
        <span style="color:#ffd700;">天赋点: <b id="abyssTalentPointsDisplay">0</b></span>
        <button onclick="closeAbyssTalentPanel()" style="background:#5c3d2e;color:#ffb74d;border:1px solid #ff9800;padding:6px 14px;border-radius:6px;cursor:pointer;">关闭</button>
    </div>
    <p style="color:#aaa;font-size:12px;margin-bottom:12px;">每升1级获得1点天赋点。点击+学习天赋。</p>
    <div id="abyssTalentList" style="display:flex;flex-direction:column;gap:8px;"></div>
</div>

<!-- 无限深渊-技能面板（学习+装备，最多装备3个） -->
<div id="abyssSkillOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2074;" onclick="closeAbyssSkillPanel()"></div>
<div id="abyssSkillUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(160deg,#2a1a3a 0%,#1a0a2e 50%,#0d0518 100%);color:#e0e0e0;padding:20px;border:3px solid #9c27b0;border-radius:12px;z-index:2075;width:640px;max-height:88vh;overflow-y:auto;box-shadow:0 0 30px rgba(156,39,176,0.4);">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;border-bottom:2px solid #9c27b0;padding-bottom:10px;">
        <h3 style="color:#ce93d8;margin:0;">&#9889; 技能</h3>
        <span style="color:#ffd700;">闯关金币: <b id="abyssSkillPanelGold">0</b></span>
        <button onclick="closeAbyssSkillPanel()" style="background:#4a2c4a;color:#ce93d8;border:1px solid #9c27b0;padding:6px 14px;border-radius:6px;cursor:pointer;">关闭</button>
    </div>
    <p style="color:#aaa;font-size:12px;margin-bottom:10px;">学习技能后可在下方装备栏装备，最多装备3个技能；战斗中只能使用已装备的技能。</p>
    <div style="margin-bottom:15px;">
        <div style="color:#b388ff;font-size:13px;margin-bottom:8px;">已装备技能（3格）</div>
        <div id="abyssEquippedSkillSlots" style="display:flex;gap:10px;flex-wrap:wrap;"></div>
    </div>
    <div>
        <div style="color:#b388ff;font-size:13px;margin-bottom:8px;">学习技能（按转生解锁，学习消耗闯关金币）</div>
        <div id="abyssSkillLearnList" style="display:flex;flex-direction:column;gap:8px;"></div>
    </div>
</div>

<!-- 无限深渊-二转分支选择弹窗（4个分支） -->
<div id="abyssBranchOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2059;"></div>
<div id="abyssBranchUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1a4a,#1a0a2e);color:#fff;padding:25px;border:3px solid #ffd700;border-radius:15px;z-index:2060;width:620px;text-align:center;">
    <h3 style="color:#ffd700;margin-bottom:12px;">达到2转！选择职业分支</h3>
    <p id="abyssBranchHint" style="color:#aaa;font-size:13px;margin-bottom:18px;">选择后不可更改，将决定3转、4转技能路线</p>
    <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap;">
        <button type="button" id="abyssBranchABtn" style="background:linear-gradient(145deg,#c62828,#8b0000);color:#fff;border:2px solid #ff6b6b;padding:14px 22px;border-radius:12px;cursor:pointer;font-weight:bold;font-size:14px;">分支A</button>
        <button type="button" id="abyssBranchBBtn" style="background:linear-gradient(145deg,#1565c0,#0d47a1);color:#fff;border:2px solid #42a5f5;padding:14px 22px;border-radius:12px;cursor:pointer;font-weight:bold;font-size:14px;">分支B</button>
        <button type="button" id="abyssBranchCBtn" style="background:linear-gradient(145deg,#2e7d32,#1b5e20);color:#fff;border:2px solid #4caf50;padding:14px 22px;border-radius:12px;cursor:pointer;font-weight:bold;font-size:14px;">分支C</button>
        <button type="button" id="abyssBranchDBtn" style="background:linear-gradient(145deg,#6a1b9a,#4a148c);color:#fff;border:2px solid #9c27b0;padding:14px 22px;border-radius:12px;cursor:pointer;font-weight:bold;font-size:14px;">分支D</button>
    </div>
    <div id="abyssBranchDesc" style="margin-top:16px;text-align:left;font-size:13px;color:#ce93d8;"></div>
</div>

<!-- 无限深渊-三选一属性弹窗（通关5选1） -->
<div id="abyssChoiceOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2060;"></div>
<div id="abyssChoiceUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1a4a,#1a0a2e);color:#fff;padding:25px;border:3px solid #b388ff;border-radius:15px;z-index:2061;width:680px;text-align:center;">
    <h3 style="color:#b388ff;margin-bottom:15px;">通关奖励 - 选择一项属性提升（5选1）</h3>
    <div id="abyssChoiceOptions" style="display:grid;grid-template-columns:repeat(5,1fr);gap:10px;"></div>
</div>

<!-- 无限深渊-升级奖励弹窗（3选1，可花120闯关金币刷新） -->
<div id="abyssUpgradeChoiceOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2060;"></div>
<div id="abyssUpgradeChoiceUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a2a1a,#0d1a0d);color:#fff;padding:25px;border:3px solid #4caf50;border-radius:15px;z-index:2061;width:560px;text-align:center;">
    <h3 style="color:#4caf50;margin-bottom:8px;">⬆ 升级奖励 - 选择一项加成（3选1）</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:12px;">闯关金币: <span id="abyssUpgradePanelGold" style="color:#ffd700;">0</span></p>
    <div id="abyssUpgradeChoiceOptions" style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:14px;"></div>
    <button type="button" id="abyssUpgradeRefreshBtn" onclick="abyssRefreshUpgradeChoice()" style="background:linear-gradient(145deg,#ff9800,#e65100);color:#fff;border:2px solid #ffb74d;padding:8px 20px;border-radius:8px;cursor:pointer;font-weight:bold;">刷新选项（120 闯关金币）</button>
</div>

<!-- 无限深渊-奇遇·闫闫（每5层有几率触发，选一项奖励） -->
<div id="abyssEncounterOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2060;"></div>
<div id="abyssEncounterUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a2a1a,#0d1a0d);color:#fff;padding:25px;border:3px solid #4caf50;border-radius:15px;z-index:2061;width:560px;text-align:center;">
    <h3 style="color:#4caf50;margin-bottom:8px;">✨ 奇遇·闫闫 ✨</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">深渊中偶遇闫闫，选择一项奖励：</p>
    <div id="abyssEncounterOptions" style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;"></div>
</div>

<!-- 无限深渊-BOSS临时商店 -->
<div id="abyssTempShopOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2062;"></div>
<div id="abyssTempShopUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a0a2e,#0d0518);color:#e0e0e0;padding:20px;border:3px solid #ffd700;border-radius:15px;z-index:2063;width:700px;max-height:85vh;overflow-y:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
        <h3 style="color:#ffd700;margin:0;">BOSS临时商店</h3>
        <div>本次金币: <span id="abyssTempShopGold" style="color:#ffd700;font-weight:bold;">0</span> <button onclick="closeAbyssTempShop()" style="margin-left:10px;background:#6a0dad;color:#fff;border:none;padding:6px 14px;border-radius:5px;cursor:pointer;">关闭</button></div>
    </div>
    <div id="abyssTempShopContent" style="display:grid;grid-template-columns:repeat(2,1fr);gap:12px;"></div>
</div>

<!-- 无限深渊-装备/背包面板 -->
<div id="abyssEquipOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2064;" onclick="closeAbyssEquipmentPanel()"></div>
<div id="abyssEquipUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a0a2e,#0d0518);color:#e0e0e0;padding:20px;border:3px solid #6a0dad;border-radius:15px;z-index:2065;width:750px;max-height:88vh;overflow-y:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
        <h3 style="color:#b388ff;margin:0;">装备与背包</h3>
        <div>闯关金币: <span id="abyssEquipGold" style="color:#ffd700;">0</span> | 升级石: <span id="abyssUpgradeStoneCount" style="color:#00bcd4;">0</span> | 强化石: <span id="abyssEnhanceStoneCount" style="color:#ffd700;">0</span> | 附魔书: <span id="abyssEnchantBookCount" style="color:#9c27b0;">0</span> | 生命药剂: <span id="abyssPotionCount" style="color:#4caf50;">0</span> | 符文: <span id="abyssRuneCount" style="color:#b388ff;">0</span> | 宝石: <span id="abyssGemCount" style="color:#ffd700;">0</span> | 符文开孔器: <span id="abyssRuneOpenerCount" style="color:#7b1fa2;">0</span> | 宝石开孔器: <span id="abyssGemOpenerCount" style="color:#e65100;">0</span></div>
        <button onclick="closeAbyssEquipmentPanel()" style="background:#4a2c4a;color:#fff;border:none;padding:6px 14px;border-radius:5px;cursor:pointer;">关闭</button>
    </div>
    <div style="margin-bottom:15px;">
        <div style="color:#aaa;margin-bottom:8px;">已装备</div>
        <div id="abyssEquippedSlots" style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;"></div>
    </div>
    <div>
        <div style="color:#aaa;margin-bottom:8px;">背包</div>
        <div id="abyssInventorySlots" style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;min-height:80px;"></div>
    </div>
</div>

<!-- 无限深渊-闯关商店弹窗 -->
<div id="abyssChallengeShopOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2072;" onclick="closeAbyssChallengeShop()"></div>
<div id="abyssChallengeShopUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a0a2e,#0d0518);color:#e0e0e0;padding:20px;border:3px solid #ffd700;border-radius:15px;z-index:2073;width:420px;max-height:85vh;overflow-y:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
        <h3 style="color:#ffd700;margin:0;">🛒 闯关商店</h3>
        <div>闯关金币: <span id="abyssChallengeShopGold" style="color:#ffd700;font-weight:bold;">0</span> <button onclick="closeAbyssChallengeShop()" style="margin-left:10px;background:#6a0dad;color:#fff;border:none;padding:6px 14px;border-radius:5px;cursor:pointer;">关闭</button></div>
    </div>
    <p style="color:#aaa;font-size:13px;margin-bottom:12px;">使用闯关金币购买道具，仅本次闯关有效。</p>
    <div id="abyssChallengeShopContent" style="display:flex;flex-direction:column;gap:10px;"></div>
</div>

<!-- 无限深渊-装备操作弹窗(强化/附魔/卸下/丢弃/符文/宝石) -->
<div id="abyssEquipActionOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:2066;"></div>
<div id="abyssEquipActionUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#2a1a4a;color:#fff;padding:20px;border:2px solid #b388ff;border-radius:12px;z-index:2067;width:420px;max-height:90vh;overflow-y:auto;">
    <div id="abyssEquipActionDetail" style="margin-bottom:15px;font-size:14px;"></div>
    <div id="abyssEquipRuneGemBlock" style="margin-bottom:12px;font-size:12px;border:1px solid #6a0dad;padding:8px;border-radius:6px;background:rgba(0,0,0,0.3);"></div>
    <div style="display:flex;flex-wrap:wrap;gap:8px;">
        <button id="abyssEquipUpgradeBtn" onclick="abyssEquipUpgrade()" style="background:#00bcd4;color:#000;border:none;padding:8px 14px;border-radius:5px;cursor:pointer;">升级(1个升级石)</button>
        <button id="abyssEquipEnhanceBtn" onclick="abyssEquipEnhance()" style="background:#ff9800;color:#000;border:none;padding:8px 14px;border-radius:5px;cursor:pointer;">强化</button>
        <button onclick="abyssEquipEnchant()" style="background:#9c27b0;color:#fff;border:none;padding:8px 14px;border-radius:5px;cursor:pointer;">附魔</button>
        <button id="abyssEquipUnequipBtn" onclick="abyssEquipUnequip()" style="background:#2196f3;color:#fff;border:none;padding:8px 14px;border-radius:5px;cursor:pointer;">卸下</button>
        <button onclick="abyssEquipDismantle()" style="background:#f44336;color:#fff;border:none;padding:8px 14px;border-radius:5px;cursor:pointer;">分解</button>
        <button onclick="closeAbyssEquipAction()" style="background:#555;color:#fff;border:none;padding:8px 14px;border-radius:5px;cursor:pointer;">取消</button>
    </div>
</div>

<!-- 无限深渊-装备对比弹窗（背包点击装备时：已装备 vs 新装备） -->
<div id="abyssEquipCompareOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2068;" onclick="closeAbyssEquipCompare()"></div>
<div id="abyssEquipCompareUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a0a2e,#0d0518);color:#e0e0e0;padding:20px;border:3px solid #b388ff;border-radius:12px;z-index:2069;width:720px;max-width:95vw;" onclick="event.stopPropagation();">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;border-bottom:1px solid #555;padding-bottom:8px;">
        <h3 style="color:#b388ff;margin:0;font-size:16px;">装备对比</h3>
        <button type="button" onclick="closeAbyssEquipCompare()" style="background:#555;color:#fff;border:none;padding:6px 12px;border-radius:5px;cursor:pointer;">关闭</button>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
        <div style="background:rgba(0,0,0,0.4);border-radius:8px;padding:12px;border:1px solid #555;">
            <div style="color:#2196f3;font-weight:bold;margin-bottom:8px;">已装备</div>
            <div id="abyssCompareEquippedDetail" style="font-size:13px;min-height:80px;"></div>
        </div>
        <div style="background:rgba(0,0,0,0.4);border-radius:8px;padding:12px;border:1px solid #b388ff;">
            <div style="color:#ff9800;font-weight:bold;margin-bottom:8px;">新装备</div>
            <div id="abyssCompareNewDetail" style="font-size:13px;min-height:80px;"></div>
        </div>
    </div>
    <div style="margin-top:14px;display:flex;gap:10px;justify-content:flex-end;">
        <button type="button" onclick="abyssCompareDoDismantle()" style="background:#f44336;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">分解新装备</button>
        <button type="button" onclick="closeAbyssEquipCompare()" style="background:#555;color:#ccc;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">取消</button>
        <button type="button" id="abyssCompareEquipBtn" onclick="abyssCompareDoEquip()" style="background:#4caf50;color:#fff;border:none;padding:8px 20px;border-radius:6px;cursor:pointer;font-weight:bold;">装备</button>
    </div>
</div>

<!-- 无限深渊-专属商店 -->
<div id="abyssExclusiveOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2068;"></div>
<div id="abyssExclusiveUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a2a1a,#0d180d);color:#e0e0e0;padding:20px;border:3px solid #4caf50;border-radius:15px;z-index:2069;width:500px;max-height:85vh;overflow-y:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
        <h3 style="color:#4caf50;margin:0;">深渊专属商店</h3>
        <div>深渊币: <span id="abyssExclusiveShopCurrency" style="color:#ffd700;font-weight:bold;">0</span> <button onclick="closeAbyssExclusiveShop()" style="margin-left:10px;background:#2e7d32;color:#fff;border:none;padding:6px 14px;border-radius:5px;cursor:pointer;">关闭</button></div>
    </div>
    <p style="color:#aaa;font-size:13px;margin-bottom:12px;">失败后获得的深渊币可在此购买<strong style="color:#4caf50;">永久</strong>属性提升，仅对无限深渊生效。</p>
    <div id="abyssExclusiveShopContent" style="display:grid;grid-template-columns:1fr;gap:10px;"></div>
</div>

<!-- 无限深渊-深渊宝库（BOSS掉落宝物，永久加成可叠加） -->
<div id="abyssVaultOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2068;" onclick="closeAbyssVault()"></div>
<div id="abyssVaultUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a0a2e,#0d0518);color:#e0e0e0;padding:20px;border:3px solid #b388ff;border-radius:15px;z-index:2069;width:580px;max-height:85vh;overflow-y:auto;" onclick="event.stopPropagation();">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
        <h3 style="color:#b388ff;margin:0;">&#128230; 深渊宝库</h3>
        <button onclick="closeAbyssVault()" style="background:#6a0dad;color:#fff;border:none;padding:6px 14px;border-radius:5px;cursor:pointer;">关闭</button>
    </div>
    <p style="color:#aaa;font-size:13px;margin-bottom:12px;">BOSS层击败后有<strong style="color:#b388ff;">2%</strong>概率掉落宝物，宝物可<strong style="color:#ffd700;">叠加数量</strong>，提供永久属性加成，仅对无限深渊生效。</p>
    <div id="abyssVaultContent" style="display:grid;grid-template-columns:1fr;gap:8px;"></div>
</div>

<!-- 无限深渊-宝物掉落弹窗 -->
<div id="abyssTreasureDropOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:2078;" onclick="closeAbyssTreasureDropPopup()"></div>
<div id="abyssTreasureDropUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1a4a,#1a0a2e);color:#fff;padding:28px;border:3px solid #ffd700;border-radius:15px;z-index:2079;width:420px;text-align:center;box-shadow:0 0 40px rgba(255,215,0,0.4);" onclick="event.stopPropagation();">
    <div style="font-size:22px;margin-bottom:8px;">&#127873; 获得宝物！</div>
    <div id="abyssTreasureDropName" style="font-size:24px;color:#ffd700;font-weight:bold;margin:12px 0;">【宝物名】</div>
    <div id="abyssTreasureDropEff" style="font-size:16px;color:#81c784;margin-bottom:20px;">永久+5防御</div>
    <button type="button" onclick="closeAbyssTreasureDropPopup()" style="background:linear-gradient(145deg,#ffd700,#daa520);color:#333;border:none;padding:12px 40px;border-radius:8px;cursor:pointer;font-weight:bold;">确认</button>
</div>

<!-- 无限深渊-深渊诅咒·抉择（每15层，选诅咒换奖励） -->
<div id="abyssCurseOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssCurseUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1020,#1a0810);color:#fff;padding:25px;border:3px solid #9c27b0;border-radius:15px;z-index:2063;width:580px;">
    <h3 style="color:#ce93d8;margin:0 0 12px 0;">☠ 深渊诅咒·抉择</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">接受诅咒以换取丰厚回报，持续5层。</p>
    <div id="abyssCurseOptions" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;"></div>
    <button type="button" onclick="abyssSkipCurse()" style="margin-top:12px;background:#555;color:#ccc;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">跳过（不选）</button>
</div>

<!-- 无限深渊-神秘流浪商人（每8层，赌博交易） -->
<div id="abyssMerchantOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssMerchantUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a2a1a,#0d180d);color:#fff;padding:25px;border:3px solid #ff9800;border-radius:15px;z-index:2063;width:520px;">
    <h3 style="color:#ffb74d;margin:0 0 12px 0;">🧙 神秘流浪商人</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">神秘商人带来未知礼包，可能血赚可能血亏！当前闯关金币: <span id="abyssMerchantGold" style="color:#ffd700;">0</span></p>
    <div id="abyssMerchantOptions" style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;"></div>
    <button type="button" onclick="abyssSkipMerchant()" style="margin-top:12px;background:#555;color:#ccc;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">离开</button>
</div>

<!-- 无限深渊-深渊试炼（每20层，挑战任务） -->
<div id="abyssTrialOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssTrialUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a1a2a,#0d0d18);color:#fff;padding:25px;border:3px solid #2196f3;border-radius:15px;z-index:2063;width:480px;">
    <h3 style="color:#64b5f6;margin:0 0 12px 0;">⚔ 深渊试炼</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">选择一项试炼，完成后接下来10层获得额外加成！</p>
    <div id="abyssTrialOptions" style="display:flex;flex-direction:column;gap:10px;"></div>
    <button type="button" onclick="abyssSkipTrial()" style="margin-top:12px;background:#555;color:#ccc;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">跳过</button>
</div>

<!-- 无限深渊-远古遗迹·探宝（每12层，稳健/冒险） -->
<div id="abyssRuinOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssRuinUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1a0a,#1a0d05);color:#fff;padding:25px;border:3px solid #8b4513;border-radius:15px;z-index:2063;width:480px;">
    <h3 style="color:#d2691e;margin:0 0 12px 0;">🏛 远古遗迹·探宝</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">发现远古遗迹！选择探索方式：</p>
    <div id="abyssRuinOptions" style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;"></div>
</div>

<!-- 无限深渊-幸运轮盘（每6层） -->
<div id="abyssWheelOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssWheelUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a2a1a,#0d180d);color:#fff;padding:25px;border:3px solid #4caf50;border-radius:15px;z-index:2063;width:420px;text-align:center;">
    <h3 style="color:#81c784;margin:0 0 12px 0;">🎡 幸运轮盘</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">转动轮盘，获得随机奖励！</p>
    <div id="abyssWheelResult" style="font-size:18px;color:#4caf50;margin-bottom:15px;font-weight:bold;"></div>
    <button type="button" id="abyssWheelSpinBtn" onclick="abyssSpinWheel()" style="background:linear-gradient(145deg,#4caf50,#2e7d32);color:#fff;border:2px solid #81c784;padding:12px 30px;border-radius:8px;cursor:pointer;font-weight:bold;">转动</button>
</div>

<!-- 无限深渊-深渊锻造坊（每14层，品质升级） -->
<div id="abyssForgeOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssForgeUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1a0a,#1a1005);color:#fff;padding:25px;border:3px solid #d2691e;border-radius:15px;z-index:2063;width:520px;">
    <h3 style="color:#ffb74d;margin:0 0 12px 0;">⚒ 深渊锻造坊</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">花费闯关金币将背包装备品质+1（最高橙）或获取升级石。当前金币: <span id="abyssForgeGold" style="color:#ffd700;">0</span></p>
    <div id="abyssForgeOptions" style="display:flex;flex-direction:column;gap:10px;"></div>
    <button type="button" onclick="abyssSkipForge()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">跳过</button>
</div>

<!-- 无限深渊-深渊附魔台（每9层，装备附魔） -->
<div id="abyssEnchantTableOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssEnchantTableUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a1a2a,#0d0d18);color:#fff;padding:25px;border:3px solid #7c4dff;border-radius:15px;z-index:2063;width:500px;">
    <h3 style="color:#b388ff;margin:0 0 12px 0;">✨ 深渊附魔台</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">免费为一件已装备装备附魔！属性增幅15%~25%</p>
    <div id="abyssEnchantTableOptions" style="display:flex;flex-direction:column;gap:10px;"></div>
    <button type="button" onclick="abyssSkipEnchantTable()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">跳过</button>
</div>

<!-- 无限深渊-深渊鉴宝师（每11层，添加符文/宝石） -->
<div id="abyssAppraiserOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssAppraiserUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a2a2a,#0d1818);color:#fff;padding:25px;border:3px solid #26c6da;border-radius:15px;z-index:2063;width:520px;">
    <h3 style="color:#4dd0e1;margin:0 0 12px 0;">🔮 深渊鉴宝师</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">鉴定背包一件装备，随机添加一个符文或宝石孔位！</p>
    <div id="abyssAppraiserOptions" style="display:flex;flex-direction:column;gap:10px;"></div>
    <button type="button" onclick="abyssSkipAppraiser()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">跳过</button>
</div>

<!-- 无限深渊-深渊装备箱（每7层，购买装备） -->
<div id="abyssEquipChestOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssEquipChestUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a2a1a,#0d180d);color:#fff;padding:25px;border:3px solid #66bb6a;border-radius:15px;z-index:2063;width:520px;">
    <h3 style="color:#81c784;margin:0 0 12px 0;">📦 深渊装备箱</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">用闯关金币购买随机品质装备！当前金币: <span id="abyssEquipChestGold" style="color:#ffd700;">0</span></p>
    <div id="abyssEquipChestOptions" style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;"></div>
    <button type="button" onclick="abyssSkipEquipChest()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">跳过</button>
</div>

<!-- 无限深渊-深渊强化祭坛（每13层，装备强化） -->
<div id="abyssEnhanceAltarOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssEnhanceAltarUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1a2a,#1a0d18);color:#fff;padding:25px;border:3px solid #f06292;border-radius:15px;z-index:2063;width:500px;">
    <h3 style="color:#f48fb1;margin:0 0 12px 0;">⚡ 深渊强化祭坛</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">免费强化一件已装备装备等级+1，或获得强化石x3！</p>
    <div id="abyssEnhanceAltarOptions" style="display:flex;flex-direction:column;gap:10px;"></div>
    <button type="button" onclick="abyssSkipEnhanceAltar()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">跳过</button>
</div>

<!-- 无限深渊-深渊占卜师（每4层，礼包抽奖有加有减） -->
<div id="abyssDivinerOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssDivinerUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a1a2a,#0d0d18);color:#fff;padding:25px;border:3px solid #9c27b0;border-radius:15px;z-index:2063;width:520px;">
    <h3 style="color:#ce93d8;margin:0 0 12px 0;">🔮 深渊占卜师</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">礼包抽奖，攻击/生命/防御随机一项，有加有减！选择占卜等级：</p>
    <div id="abyssDivinerOptions" style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;"></div>
    <button type="button" onclick="abyssSkipDiviner()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">跳过</button>
</div>

<!-- 无限深渊-深渊共鸣水晶（每17层，金币激活增益） -->
<div id="abyssCrystalOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssCrystalUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a2a3a,#0d1a28);color:#fff;padding:25px;border:3px solid #00bcd4;border-radius:15px;z-index:2063;width:500px;">
    <h3 style="color:#4dd0e1;margin:0 0 12px 0;">💎 深渊共鸣水晶</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">消耗金币激活水晶共鸣，本局获得永久属性增益！当前金币: <span id="abyssCrystalGold" style="color:#ffd700;">0</span></p>
    <div id="abyssCrystalOptions" style="display:flex;flex-direction:column;gap:10px;"></div>
    <button type="button" onclick="abyssSkipCrystal()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">跳过</button>
</div>

<!-- 无限深渊-深渊幻境迷宫（每18层，稳健/冒险） -->
<div id="abyssMazeOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssMazeUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1a3a,#1a0d2a);color:#fff;padding:25px;border:3px solid #e040fb;border-radius:15px;z-index:2063;width:520px;">
    <h3 style="color:#ea80fc;margin:0 0 12px 0;">🌀 深渊幻境迷宫</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">发现幻境迷宫入口！选择探索路线：</p>
    <div id="abyssMazeOptions" style="display:flex;gap:16px;flex-wrap:wrap;justify-content:center;"></div>
</div>

<!-- 无限深渊-深渊材料商人（每16层，金币购买材料） -->
<div id="abyssMaterialMerchantOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssMaterialMerchantUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a2a1a,#0d180d);color:#fff;padding:25px;border:3px solid #8bc34a;border-radius:15px;z-index:2063;width:540px;max-height:85vh;overflow-y:auto;">
    <h3 style="color:#aed581;margin:0 0 12px 0;">🛒 深渊材料商人</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">材料商人带来稀罕物资！当前金币: <span id="abyssMaterialMerchantGold" style="color:#ffd700;">0</span>　剩余购买: <span id="abyssMaterialMerchantPurchases" style="color:#8bc34a;">3</span>/3</p>
    <div id="abyssMaterialMerchantOptions" style="display:grid;grid-template-columns:repeat(2,1fr);gap:10px;"></div>
    <button type="button" onclick="abyssSkipMaterialMerchant()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">离开</button>
</div>

<!-- 无限深渊-深渊装备回收站（每19层，分解装备换材料/金币） -->
<div id="abyssEquipRecycleOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssEquipRecycleUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1a0a,#1a0d05);color:#fff;padding:25px;border:3px solid #a1887f;border-radius:15px;z-index:2063;width:520px;max-height:85vh;overflow-y:auto;">
    <h3 style="color:#d7ccc8;margin:0 0 12px 0;">♻ 深渊装备回收站</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">分解背包装备，换取材料或金币。</p>
    <div id="abyssEquipRecycleOptions" style="display:flex;flex-direction:column;gap:8px;"></div>
    <button type="button" onclick="abyssSkipEquipRecycle()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">离开</button>
</div>

<!-- 无限深渊-深渊神秘宝库（每21层，开宝箱获装备/材料） -->
<div id="abyssMysteryVaultOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssMysteryVaultUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a1a2a,#0d0d18);color:#fff;padding:25px;border:3px solid #7c4dff;border-radius:15px;z-index:2063;width:520px;">
    <h3 style="color:#b388ff;margin:0 0 12px 0;">📦 深渊神秘宝库</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">远古宝库，花费金币开启宝箱！当前金币: <span id="abyssMysteryVaultGold" style="color:#ffd700;">0</span></p>
    <div id="abyssMysteryVaultOptions" style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;"></div>
    <button type="button" onclick="abyssSkipMysteryVault()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">离开</button>
</div>

<!-- 无限深渊-深渊符文工坊（每22层，免费镶符文或获得符文） -->
<div id="abyssRuneWorkshopOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssRuneWorkshopUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#1a1a2a,#0d0d18);color:#fff;padding:25px;border:3px solid #7b1fa2;border-radius:15px;z-index:2063;width:500px;max-height:85vh;overflow-y:auto;">
    <h3 style="color:#ce93d8;margin:0 0 12px 0;">📜 深渊符文工坊</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">免费为装备镶嵌符文，或领取随机符文！</p>
    <div id="abyssRuneWorkshopOptions" style="display:flex;flex-direction:column;gap:10px;"></div>
    <button type="button" onclick="abyssSkipRuneWorkshop()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">离开</button>
</div>

<!-- 无限深渊-深渊宝石匠（每23层，免费镶宝石或获得宝石） -->
<div id="abyssGemSmithOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2062;"></div>
<div id="abyssGemSmithUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#2a1a0a,#1a1005);color:#fff;padding:25px;border:3px solid #ff9800;border-radius:15px;z-index:2063;width:500px;max-height:85vh;overflow-y:auto;">
    <h3 style="color:#ffb74d;margin:0 0 12px 0;">💎 深渊宝石匠</h3>
    <p style="color:#aaa;font-size:13px;margin-bottom:15px;">免费为装备镶嵌宝石，或领取随机宝石！</p>
    <div id="abyssGemSmithOptions" style="display:flex;flex-direction:column;gap:10px;"></div>
    <button type="button" onclick="abyssSkipGemSmith()" style="margin-top:12px;background:#555;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;">离开</button>
</div>

<!-- 无限深渊-失败结算 -->
<div id="abyssFailOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:2070;"></div>
<div id="abyssFailUI" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(145deg,#4a2020,#2a1010);color:#fff;padding:30px;border:3px solid #ff6b6b;border-radius:20px;z-index:2071;width:400px;text-align:center;">
    <h3 style="color:#ff6b6b;margin-bottom:15px;">挑战失败</h3>
    <p style="margin-bottom:10px;">到达层数: <span id="abyssFailFloor" style="color:#ffd700;">0</span></p>
    <p style="margin-bottom:15px;">获得深渊币: <span id="abyssFailCurrency" style="color:#4caf50;">0</span></p>
    <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
        <button onclick="abyssOpenExclusiveShopFromFail()" style="background:linear-gradient(145deg,#2e7d32,#1b5e20);color:#fff;border:none;padding:12px 24px;border-radius:10px;cursor:pointer;font-weight:bold;">专属商店（永久加成）</button>
        <button onclick="closeAbyssFailAndRestart()" style="background:#6a0dad;color:#fff;border:none;padding:12px 30px;border-radius:10px;cursor:pointer;font-weight:bold;">确定</button>
    </div>
</div>

    <script>
        
        const GAME_VERSION = "1.8.95";
        let versionErrorBlocked = false;

        
        function isCurrentVersionOlderThan(saveVersion) {
            if (!saveVersion) return false;
            var cur = (GAME_VERSION + "").split(".").map(Number);
            var sav = (saveVersion + "").split(".").map(Number);
            for (var i = 0; i < Math.max(cur.length, sav.length); i++) {
                var c = cur[i] || 0, s = sav[i] || 0;
                if (c < s) return true;
                if (c > s) return false;
            }
            return false;
        }

        
        function showVersionError(saveVersion) {
            versionErrorBlocked = true;
            setTimeout(function() {
                var dialog = document.getElementById('versionErrorDialog');
                var overlay = document.getElementById('versionErrorOverlay');
                var messageEl = document.getElementById('versionErrorMessage');
                if (dialog && overlay && messageEl) {
                    messageEl.textContent = "该存档是在更新版本（v" + saveVersion + "）中保存的，当前游戏版本为 v" + GAME_VERSION + "。";
                    dialog.style.display = 'block';
                    overlay.style.display = 'block';
                } else {
                    alert("该存档是在更新版本（v" + saveVersion + "）中保存的，当前游戏版本为 v" + GAME_VERSION + "。\n请使用新版本游戏进行游玩。");
                }
            }, 100);
        }

        
        function checkVersionBlocked() {
            return versionErrorBlocked;
        }

        // 定时器统一管理：页面卸载时统一清理，避免遗漏导致越来越卡
        window._gameIntervals = window._gameIntervals || [];
        function registerInterval(fn, ms) {
            var id = (arguments.length > 2) ? setInterval.apply(window, arguments) : setInterval(fn, ms);
            window._gameIntervals.push(id);
            return id;
        }

        // 初始化玩家数据
    let player = {
    name: "勇者",
    avatar: "",  // 玩家头像 base64，显示为 48x48
    gold: 0,
    diamond: 0,
    titanium: 0,
    starstone: 0,
    cosmicstone: 0,
    superstone: 0,
    otherworldstone: 0,
    xingjiestone: 0,
    hundunstone: 0,
    lingtone: 0,
    huangtone: 0,
    mingtone: 0,
    xutong: 0,
    shitone: 0,
    weitone: 0,
    reincarnationCoin: 0,
    reincarnationCount: 0,
    equipment: [],
    usedActivationCodes: [],
    dimensionLevel: 1,
    class: null, // 当前职业: null, 'warrior', 'mage'
    classSecond: null,    // 二转职业
    classThird: null,    // 三转职业  
    classFourth: null, 
    classBranches: [], // 已选择的分支 [0, 2, 1] 表示第1排选第0个，第2排选第2个等
    classBonuses: { // 新增：存储职业分支选择的加成
    soulRingMultiplier: 1,    // 魂环总加成乘数（默认1倍）
    dungeonEquipMultiplier: 1 // 副本装备总加成乘数（默认1倍）
  },
trialTower: {
            currentFloor: 1,
            highestFloor: 0,
            totalChallenges: 0,
            totalWins: 0
        },
        abyssTower: {
            exclusiveCurrency: 0,
            bestFloor: 0,
            level: 0,
            startGearCount: 0,
            startGearPurchaseCount: 0,
            startGoldBonus: 0,
            startPetCount: 0,
            deployedSlotsPurchases: 0,
            permanentBonuses: { hp: 0, atk: 0, def: 0, critRate: 0, critDmg: 0, dodge: 0, lifesteal: 0, combo: 0 },
            abyssVault: {}
        },
nianBeast: {
            dungeonToken: 0, // 副本令牌
            highestLevel: 0, // 最高通关层数
            totalKills: 0, // 总击杀次数
            rewardsCollected: 0 // 总奖励数量
        },
beasts: {
        inventory: [], // 拥有的神兽列表
        equipped: [],
        selectedId: null, // 当前选中的神兽ID
        shareLevel: {
        level: 0, // 共享等级
        totalExp: 0, // 总消耗的神兽蛋数量
        bonusMultiplier: 1.0 // 总属性加成倍率
    }
    },
reincarnationEquipment: {
            equipped: {
                helmet: null,
                chest: null,
                pants: null,
                shoes: null,
                necklace: null,
                weapon: null
            },
            inventory: [],
            lockedItems: [] // 锁定的装备ID列表
        },
 treasures: {
            inventory: [], // 拥有的宝物列表
            totalFound: 0, // 总共找到的宝物数量
            totalSold: 0, // 总共出售获得的金钱
            foundCount: Array(10).fill(0), // 每个宝物找到的数量
            soldCount: Array(10).fill(0) // 每个宝物出售的数量
        }, 
       magicTools: {
            equipped: null, // 当前装备的法宝ID
            inventory: [],  // 拥有的法宝ID列表
            materials: {},  // 拥有的材料数量
            // 初始化基础材料
            materials: {
                spirit_stone: 0,
                wood: 0,
                water_crystal: 0,
                fire_crystal: 0,
                metal_crystal: 0,
                wood_crystal: 0,
                earth_crystal: 0,
                yin_stone: 0,
                yang_stone: 0,
                immortal_feather: 0,
                celestial_silk: 0,
                chaos_fragment: 0,
                space_stone: 0,
                time_sand: 0,
                destiny_fragment: 0,
                star_dust: 0,
                law_crystal: 0,
                eternity_core: 0,
                time_essence: 0,
                space_crystal: 0
            }
        },
children: {
            isPregnant: false,
            pregnancyStart: 0,
            pregnancyProgress: 0,
            children: [],
            totalChildren: 0,
            trainingHistory: [],
            childBonuses: {
                gpsMultiplier: 1.0,
                clickMultiplier: 1.0,
                critRateBonus: 0,
                goldMultiplier: 1.0
            }
        },
  marriage: {
            isMarried: false,
            spouseName: "",
            spouseGender: "female",
            marriageDate: null,
            loveLevel: 1,
            loveExp: 0,
            totalGifts: 0,
            totalTimeSpent: 0,
            totalAimeSpent: 0,
            marriageBonuses: {
                gpsMultiplier: 1.0,
                clickMultiplier: 1.0,
                critRateBonus: 0,
                critDamageBonus: 0
            }
        },
  houses: {
                    level: 1,
                    exp: 0,
                    maxHouses: 5,
                    ownedHouses: [],
                    rentedHouses: [],
                    lastUpdate: Date.now(),
                    totalIncome: 0
                },
 investmentGame: {
            stocks: [
                {code: "zj0001", name: "鱼鱼基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0002", name: "闫闫基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},           
                {code: "zj0003", name: "茶茶金股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0004", name: "麒麟企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0005", name: "云南白药", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0006", name: "黑三逢源", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0007", name: "乐途企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0008", name: "PDD企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0009", name: "空白控股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0010", name: "慢手企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0011", name: "斗音公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0012", name: "阿里妈妈", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0013", name: "淘宝宝", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0014", name: "千达有限", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0015", name: "通元房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0016", name: "预言鱼塘", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0017", name: "新股长虹", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0018", name: "萩萩萩萩音乐", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0019", name: "盛通快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0020", name: "十鼎洗浴", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0021", name: "九鼎红楼", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0022", name: "星巴克", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0023", name: "大吴疆土", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0024", name: "九转仙股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0025", name: "乌龟科技", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0026", name: "阿斯塔特", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0027", name: "万里药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0028", name: "万里证券", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0029", name: "顶峰相见", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0030", name: "顺封快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0031", name: "晋商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0032", name: "爆涨房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0033", name: "书法银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0034", name: "阳城银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0035", name: "程羽银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0036", name: "中铁银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0037", name: "工商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0038", name: "明港基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0039", name: "东坑企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0040", name: "黑龙银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0041", name: "韵达银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0042", name: "巴士企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0043", name: "京东公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0044", name: "科技企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0045", name: "羊同药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0046", name: "风雪药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0047", name: "霸王别姬", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0048", name: "一点点奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0049", name: "古茗奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0050", name: "蜜雪冰城", price: 10.00, change: 0, holdings: 0, costPrice: 0}
            ],
            userData: {
                availableFunds: 1000.00,
                totalAssets: 1000.00,
                holdingPercent: 0.00,
                todayProfit: 0.00,
                totalProfitAmount: 0.00,  // 新增：总盈亏金额
                totalProfitPercent: 0.00,
                tradeCount: 16,
                initialFunds: 1000.00,
                lastUpdateTime: Date.now()
            },
            currentStockIndex: 0,
            tradeData: {
                quantity: 0,
                type: "buy",
                feeRate: 0.0048
            },
            chartHistoryCache: {},
            priceUpdateTimer: null,
            chartUpdateTimer: null
        },
    mining: {
            depth: 0,
            power: 1,
            isMining: false,
            ore: 1500,
            stamina: 100,
            baseMaxStamina: 100,
            staminaUpgradeLevel: 1,
            potions: 3,
            gems: {
                ruby: 0,
                sapphire: 0,
                emerald: 0,
                amethyst: 0,
                diamond: 0
            },
            upgrades: {
                power: 1,
                detector: 1
            },
            notifications: [],
            lastUpdate: Date.now(),
            autoPotion: false,
            autoPotionThreshold: 5
        },

        fiveElements: {
        metal: { name: "金", level: 0, cost: 1, symbol: "⭐" }, // 金
        wood: { name: "木", level: 0, cost: 1, symbol: "🌳" }, // 木
        water: { name: "水", level: 0, cost: 1, symbol: "💧" }, // 水
        fire: { name: "火", level: 0, cost: 1, symbol: "🔥" }, // 火
        earth: { name: "土", level: 0, cost: 1, symbol: "🏔️" }  // 土
    },
    pixelPlayer: {
        helmetSkin: null,
        clothesSkin: null,
        cloakSkin: null,
        pantsSkin: null,
        shoesSkin: null,
        weaponSkin: null,
        inventory: []
    },
landlord: {
                coins: 10000,
                unlockedFields: 5,
                fields: Array(50).fill(null),
                lockedFields: Array(50).fill(false),
                seedStorage: {},
                fruitStorage: [],
                itemStorage: {},
                storeItems: {},
                itemStoreItems: {},
                lastSeedRefreshTime: Date.now(),
                lastItemRefreshTime: Date.now(),
                weather: "晴朗",
                lastWeatherChange: Date.now(),
           lottery: {
        drawCount: 0, // 当前抽奖次数
        totalDraws: 0, // 总抽奖次数
        prizesWon: {}, // 获得的奖品统计
        lastDrawTime: 0, // 上次抽奖时间
        drawHistory: [] // 抽奖历史记录
    },
                stats: {
                    totalPlants: 0,
                    totalHarvests: 0,
                    totalCoinsEarned: 0,
                    basicMutations: 0,
                    weatherMutations: 0,
                    specialMutations: 0,
                    highestMultiplier: 1,
                    itemsUsed: 0
                },
                selectedFieldIndex: null
            },
        
 penglaiIsland: {
    bossLevel: 1,
    bossHealth: 1e150,
    bossAttack: 1e20,
    bossMaxHealth: 1e150,
    bossResurrections: 0,
    isBattling: false,
    playerHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
},
lunhuiFuben: {
    bossLevel: 1,
    bossHealth: 1e98,
    bossAttack: 1e8,
    bossMaxHealth: 1e98,
    bossResurrections: 0,
    isBattling: false,
    playerHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
},
lunhuiPenglai: {
    bossLevel: 1,
    bossHealth: 1e123,
    bossAttack: 1e23,
    bossMaxHealth: 1e123,
    bossResurrections: 0,
    isBattling: false,
    playerHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
},
holyBeastIsland: {
    bossLevel: 1,
    bossHealth: 1e100,
    bossAttack: 1e10,
    bossMaxHealth: 1e100,
    bossResurrections: 0,
    isBattling: false,
    playerHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
},
runes: {
    materials: {
        gold: 0,
        wood: 0,
        water: 0,
        fire: 0,
        earth: 0,
        light: 0,
        dark: 0,
        wind: 0,
        ice: 0,
        electric: 0
    },
    equipped: null,
    inventory: [],
    level: 1,
    upgradeCost: 10,
    selectedMaterials: [],
    currentFilter: 'all'
},
  sect: {
            created: false,
            name: "",
            level: 0,
            exp: 0,
            spiritStones: 0,
            members: [],
            missions: [],
            techniques: {},
            creationTime: 0,
            maxMembers: 5,
            grotto: {
                spiritArrayLevel: 0,
                spiritFields: []
            }
        },
   battle: {
    currentZone: null,
    currentMonster: null,
    monsterResurrections: 0,
},
  worldMapBattle: {
    autoBattle: false,
    autoBattleInterval: null
},
liveStream: {
            level: 1,
            exp: 0,
            totalEarnings: 1000,
            isLive: false,
            lastLiveStart: 0,
            totalLiveTime: 0,
            expMultiplier: 1,
            viewers: [],
            donationHistory: [],
           lastDanmaku: null
        },
level: {
    current: 1,
    exp: 0,
    nextLevelExp: 10000,
    clickBonus: 1,
    gpsBonus: 1,
    ascentionCount: 0, // 飞升次数
    ascentionMultiplier: 1, // 飞升加成倍数
    ascentionCounta: 0, 
    ascentionMultipliera: 1 
},
cultivation: {
            stage: 0, // 当前阶段索引
            exp: 0,   // 当前经验值
            root: null, // 当前灵根
            bloodline: null,
           bonus: 1
        },
 artifacts: {
            fragments: 0,
            crystals: 0,
            inventory: [],
            equipped: {
                helmet: null,
                clothes: null,
                pants: null,
                shoes: null,
                necklace: null,
                weapon: null
            },
        advanceLevels: {}
        },
   mystery: {
        stage: 1,
        level: 1,
        exp: 0,
        bonus: 1, // 默认加成1倍
        lastUpdateTime: Date.now() // 添加这个字段
    },
    autoReincarnation: false, // 新增自动转生状态
    officialLevel: 0, // 官职等级，初始为0
    officialBonus: 1, // 初始加成1倍
    vip: {
        level: 1,
        power: 0 // 累计VIP能力值数量
    },
   companionExpedition: {
            currentExpedition: null,
            history: [],
            lastUpdate: Date.now()
        },
   bossBattleSnapshot: {
    playerAttack: 0,
    playerMultiAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
},
 backgroundBattle: {
    active: false,
    interval: null
},
battleLog: [], // 世界地图战斗日志（关闭再打开界面时显示），addBattleLog 会限制最多 100 条
treasure: {
        keys: 0, // 藏宝图钥匙数量
        maps: [], // 拥有的藏宝图
        currentBattle: null // 当前战斗信息
    },
 parking: {
    level: 1, // 停车位等级
    exp: 0, // 停车经验
    expToNextLevel: [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000, 10000000, 20000000, 50000000, 100000000, 200000000], // 每级所需经验
    parkingLots: [], // 停车位数组，每个元素是一个对象 { carId: 'car1', parkTime: 1234567890 }
    cars: [] // 拥有的车辆数组，每个元素是车辆ID
},
   companionChestGuarantee: {
    epic: 0,     // 史诗保底计数器
    pink: 0,     // 卓越保底计数器
    orange: 0,  // 完美保底计数器
    red: 0       // 神赐保底计数器
},
 fishing: {
    level: 1,
    currentExp: 0,
    fishCage: [],
    isFishing: false,
    isBiting: false,
    biteTimer: null,
    biteWindowTimer: null,
    biteTime: 0,
    bonus: 1,
    autoFishingEnabled: false,
    autoDecomposeFishEnabled: false

},
mounts: {
            inventory: [], // 拥有的坐骑列表
            equipped: null, // 当前装备的坐骑ID
            level: 1, // 坐骑等级
            upgradeCost: 5 // 升级所需远古圣兽精魄数量
        },

wings: {
    inventory: [], // 拥有的翅膀列表
    equipped: null, // 当前装备的翅膀ID
    level: 1, // 翅膀等级（共享）
    upgradeCost: 5 // 下次升级所需的黑龙王翅膀数量
},
exploration: {
            speed: { level: 1, cost: 100 },
            capacity: { level: 1, cost: 100 },
            durability: { level: 1, cost: 100 },
            resources: {
                stardust: 0,
                darkMatter: 0,
                cosmicCrystal: 0,
                artifactFragment: 0
            },
            activeMission: null,
            missionEndTime: 0,
            logs: []
        },
tower: {
    currentFloor: 0,
    maxFloor: 0,
    isAutoAttacking: false,
    autoAttackInterval: null,
    battleLog: [],
    playerHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0,
    monster: null
},
gems: {
            red: {},   // {等级: 数量}
            blue: {},
            black: {},
            green: {},
            pink: {},
            yellow: {}
        },
        companions: [], // 伴侣列表
    equippedCompanionId: null, // 当前装备的伴侣ID
    companionLevel: 1, // 共享的伴侣等级
   autoDecompose: {
    enabled: false,
    belowRarity: 'white' // 默认分解普通及以下
},
    items: {
        primaryGem: 0,
        advancedGem: 0,
        superiorGem: 0,
        divineGem: 0,
        refineStone: 0,
        vipPower: 0,
        rose: 0, // 玫瑰花
        companionKey: 0, // 伴侣钥匙
        rebornDan: 0,
        baitCount: 0,
        rootDetector: 0,
        bloodlineDetector: 0,
        advanceStone: 0,
        primaryGemq: 0,
        zongmen: 0,
        roseq: 0,
        yuzhou1: 0,  
       yuzhou2: 0, 
      yuzhou3: 0, 
     yuzhou4: 0, 
    banlv1: 0, 
     banlv2: 0, 
    banlv3: 0, 
    banlv4: 0, 
    banlv5: 0, 
     banlv6: 0, 
    banlv7: 0,
   banlv8: 0,
   banlv9: 0,
   zhiye1: 0,
   chiban1: 0,
   zuoqi1: 0,
   fuben1: 0,
  shenshou1: 0,
   fuwen1: 0,
  fuben2: 0,
 danyao1: 0, 
     danyao2: 0, 
    danyao3: 0, 
    danyao4: 0, 
    danyao5: 0,
   fubeng1: 0,
  seed_herb1: 0,
  seed_herb2: 0,
  seed_herb3: 0,
  seed_herb4: 0,
  seed_herb5: 0
    },
timeSecretRealm: {
    currency: 0, // 秘境币
    bestFloor: 0, // 最佳层数
    clearCount: 0, // 总通关次数（显示用）
    clearCountByDifficulty: { easy: 0, normal: 0, hard: 0, nightmare: 0, hell: 0 }, // 各难度通关次数，用于按描述解锁下一难度
    unlockedItems: [], // 已解锁商店物品
    currentRun: {
        isActive: false, // 是否正在进行冒险
        currentFloor: 1, // 当前层数
        timeLeft: 300, // 剩余时间（秒）
        tempBuffs: [], // 临时强化
        currentRoom: null, // 当前房间
        exploredRooms: 0, // 已探索房间数
        currencyEarned: 0, // 本次冒险获得的秘境币
        playerHealth: 0, // 玩家生命值（临时）
        playerAttack: 0, // 玩家攻击力（临时）
    },
   difficulty: {
   levels: {
        easy: { 
            name: '简单', 
            multiplier: 0.8, 
            rewardMultiplier: 0.7, 
            description: '适合新手玩家', 
            unlockCondition: '无',
            clearFloor: 10  // 通关层数要求
        },
        normal: { 
            name: '普通', 
            multiplier: 1.0, 
            rewardMultiplier: 1.0, 
            description: '标准难度', 
            unlockCondition: '通关简单难度3次',
            clearFloor: 15
        },
        hard: { 
            name: '困难', 
            multiplier: 1.5, 
            rewardMultiplier: 1.5, 
            description: '更具挑战性', 
            unlockCondition: '通关普通难度5次',
            clearFloor: 20
        },
        nightmare: { 
            name: '噩梦', 
            multiplier: 2.0, 
            rewardMultiplier: 2.5, 
            description: '极限挑战', 
            unlockCondition: '通关困难难度10次',
            clearFloor: 25
        },
        hell: { 
            name: '地狱', 
            multiplier: 3.0, 
            rewardMultiplier: 4.0, 
            description: '终极考验', 
            unlockCondition: '通关噩梦难度20次',
            clearFloor: 30
        }
    },
    current: 'easy',
    unlocked: ['easy']
},
    roomTypes: {
        battle: { weight: 40, name: '战斗房间' },
        event: { weight: 25, name: '事件房间' },
        treasure: { weight: 20, name: '宝箱房间' },
        rest: { weight: 10, name: '休息房间' },
        shop: { weight: 5, name: '商店房间' }
    },  
    tempBuffs: {
              attack: { 
        name: '攻击强化', 
        description: '攻击力提升50%，探索时间+30秒', 
        effect: 'attack', 
        value: 0.5, 
        duration: 0,
        timeBonus: 30  // 新增：增加20秒探索时间
    },
    health: { 
        name: '生命强化', 
        description: '生命值提升50%，探索时间+60秒', 
        effect: 'health', 
        value: 0.5, 
        duration: 0,
        timeBonus: 60  // 新增：增加40秒探索时间
    },
    critRate: { 
        name: '暴击强化', 
        description: '暴击率提升10%，探索时间+90秒', 
        effect: 'critRate', 
        value: 0.1, 
        duration: 0,
        timeBonus: 90  // 新增：增加60秒探索时间
    },
    critDamage: { 
        name: '爆伤强化', 
        description: '爆伤提升50%，探索时间+120秒', 
        effect: 'critDamage', 
        value: 0.5, 
        duration: 0,
        timeBonus: 120  // 新增：增加80秒探索时间
    },
    speed: { 
        name: '速度强化', 
        description: '探索速度提升，探索时间+150秒', 
        effect: 'speed', 
        value: 10, 
        duration: 0,
        timeBonus: 150  // 新增：增加100秒探索时间
    },
                luck: { name: '幸运强化', description: '获得双倍秘境币', effect: 'luck', value: 1, duration: 0  }
    },
    shopItems: {
        permanentAttack: { 
            name: '永恒攻击符文', 
            description: '临时提升现有攻击力50%可以叠加（转生失效）', 
            cost: 100000, 
            type: 'permanent',
            effect: 'attack'
        },
        permanentHealth: { 
            name: '永恒生命符文', 
            description: '临时提升现有生命值50%可以叠加（转生失效）', 
            cost: 100000, 
            type: 'permanent',
            effect: 'health'
        },
        timeExtension: { 
        name: '时间沙漏', 
        description: '永久增加探索时间60秒（限购50个）', 
        cost: 500000, 
        type: 'permanent',
        effect: 'time',
        maxPurchase: 50, // 限购50个
        purchased: 0, // 已购买数量
        permanentEffect: true // 永久效果
    },
    startingBuff: { 
        name: '起始祝福', 
        description: '每次冒险开始时永久获得1个随机增益效果（限购2个）', 
        cost: 800000, 
        type: 'permanent',
        effect: 'startingBuff',
        maxPurchase: 2, // 限购2个
        purchased: 0, // 已购买数量
        permanentEffect: true // 永久效果
    },
       trapSkillBook1: {
    name: '侦查技能书·初级',
    description: '提升陷阱侦查成功率到60%',
    cost: 500000,
    type: 'permanent',
    effect: 'detection_advanced'
},
 trapSkillBook2: {
    name: '侦查技能书·高级',
    description: '提升陷阱侦查成功率到80%',
    cost: 800000,
    type: 'permanent',
    effect: 'detection_expert'
},
 trapSkillBook3: {
    name: '解除技能书·初级',
    description: '提升陷阱解除成功率到70%',
    cost: 500000,
    type: 'permanent',
    effect: 'disarm_advanced'
},
 trapSkillBook4: {
    name: '解除技能书·高级',
    description: '提升陷阱解除成功率到85%',
    cost: 800000,
    type: 'permanent',
    effect: 'disarm_expert'
},
 trapSense: {
    name: '陷阱感知药水',
    description: '下次冒险陷阱侦查成功率提升30%',
    cost: 10000,
    type: 'permanent',
    effect: 'detection_boost'
},
        rareMaterial: { 
            name: '秘境结晶', 
            description: '神器碎片1000个', 
            cost: 100000, 
            type: 'material',
            effect: 'material'
        }
    },
traps: {
    // 陷阱类型配置
    types: {
        poison: { weight: 20, name: '毒液陷阱', damageType: 'percentage', damage: 0.15, duration: 3 },
        spike: { weight: 15, name: '尖刺陷阱', damageType: 'fixed', damage: 1000, duration: 1 },
        curse: { weight: 10, name: '诅咒陷阱', damageType: 'debuff', effect: 'attack', value: -0.3, duration: 5 },
        slow: { weight: 12, name: '迟缓陷阱', damageType: 'time', damage: 30, duration: 0 },
        confusion: { weight: 8, name: '混乱陷阱', damageType: 'random', damage: 0.2, duration: 2 },
        disarm: { weight: 5, name: '缴械陷阱', damageType: 'debuff', effect: 'critRate', value: -0.5, duration: 4 }
    },
    
    // 陷阱检测技能
    detectionSkills: {
        basic: { name: '基础侦查', successRate: 0.3, cost: 5 },
        advanced: { name: '高级侦查', successRate: 0.6, cost: 15 },
        expert: { name: '专家侦查', successRate: 0.8, cost: 25 },
        master: { name: '大师侦查', successRate: 0.95, cost: 40 }
    },
    // 陷阱解除技能
    disarmSkills: {
        basic: { name: '基础解除', successRate: 0.4, cost: 10 },
        advanced: { name: '高级解除', successRate: 0.7, cost: 20 },
        expert: { name: '专家解除', successRate: 0.85, cost: 35 },
        master: { name: '大师解除', successRate: 1.0, cost: 50 }
    },
    // 玩家掌握的陷阱技能
    playerSkills: {
        detection: 'basic',
        disarm: 'basic'
    }
}
},
  nightClub: {
    level: 1,
    exp: 0,
    starCoins: 0,
    staff: [
        { type: 'waiter', level: 1, expOutput: 0.5, coinsOutput: 0.2 },
        { type: 'guard', level: 1, expOutput: 0.3, coinsOutput: 0.1 },
        { type: 'dj', level: 1, expOutput: 1.0, coinsOutput: 0.5 },
        { type: 'chef', level: 1, expOutput: 0.4, coinsOutput: 0.3 },
        { type: 'hostess', level: 1, expOutput: 0.7, coinsOutput: 0.4 }
    ],
    equipment: [
        { type: 'sound', level: 1, bonus: 1.05 },
        { type: 'light', level: 1, bonus: 1.03 },
        { type: 'bar', level: 1, bonus: 1.02 },
        { type: 'dancefloor', level: 1, bonus: 1.04 }
    ],
    vip: {
        lastVisit: 0,
        nextVisit: 0
    },
    activeEvent: null,
    lastUpdate: Date.now()
},
    collections: {
        lightSpeedHand: 0,
        empHand: 0,
        godlyHand: 0,
        quickHand: 0,
        shadowHand: 0,
        quantumHand: 0,
        lightningHand: 0,
        divineHand: 0
    },
    pets: {
        thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
        chaosTaotie: { level: 0, cost: 1, multiplier: 0.30 },
        netherQiongqi: { level: 0, cost: 1, multiplier: 0.90 },
        abyssKun: { level: 0, cost: 1, multiplier: 2.70 },
        primordialZhuLong: { level: 0, cost: 1, multiplier: 8.10 },
        wanJunSuanNi: { level: 0, cost: 1, multiplier: 24.30 },
         yanYuBiAn: { level: 0, cost: 1, multiplier: 72.90 },
        yuyu1: { level: 0, cost: 1, multiplier: 218.70 },
         yuyu2: { level: 0, cost: 1, multiplier: 656.10 },   
              yuyu3: { level: 0, cost: 1, multiplier: 1968.30 },
         yuyu4: { level: 0, cost: 1, multiplier: 5904.90 },
              yuyu5: { level: 0, cost: 1, multiplier: 17714.70 },
              yuyu6: { level: 0, cost: 1, multiplier: 53144.10 },
         yuyu7: { level: 0, cost: 1, multiplier: 159432.30 },
              yuyu8: { level: 0, cost: 1, multiplier: 478296.50 }   
    },
    dungeonEquipment: [],
     techniques: {}, 
            soulRings: [], 
            attributes: {
              totalPoints: 0,
               remainingPoints: 0,
                health: 0,
            attack: 0,
             critRate: 0,
              critDamage: 0,
             multiAttack: 0,
           block: 0
            },
      farm: {
    level: 1,
    exp: 0,
    expToNextLevel: 100,
    fields: [],
    maxFields: 2,
    seeds: {},
    water: 10,
    lastUpdate: Date.now(),
    autoPlant: false,    // 新增自动种植设置
    autoHarvest: false
},
            lastUpdate: Date.now(),
            achievements: {
    "first_equipment": false,
    "first_rare": false,
    "first_epic": false,
    "first_legendary": false,
    "first_ancient": false,
    "first_divine": false,
    "first_arcane": false,
    "first_celestial": false,
    "first_infernal": false,
    "first_astral": false,
    "first_primeval": false,
    "first_transcendental": false,
    "first_quantum": false,
    "first_ultimate": false,
    "first_chaos": false,
    "first_eternal": false,
    "first_void": false,
    "first_genesis": false,
    "first_divineRealm": false,
    "first_apocalypse": false,
    "first_yeyu1": false,
    "first_yeyu2": false,
    "first_yeyu3": false,
    "first_yeyu4": false,
    "first_yeyu5": false,
    "first_yeyu6": false,
    "first_yeyu7": false,
    "first_yeyu8": false,
    "first_yeyu9": false,
    "first_yeyu10": false,
    "first_yeyu11": false,
    "first_yeyu12": false,
    "first_yeyu13": false,
    "first_yeyu14": false,
    "first_yeyu15": false,
    "first_yeyu16": false,
    "first_yeyu17": false,
    "first_yeyu18": false,
    "first_yeyu19": false,
    "first_yeyu20": false,
    "first_yeyu21": false,
    "first_yeyu22": false,
    "first_yeyu23": false,
    "first_yeyu24": false,
    "common_chest_100": false,
    "common_chest_10000": false,
    "common_chest_1000000": false,
    "common_chest_10000000": false,
    "common_chest_100000000": false,
    "advanced_chest_100": false,
    "advanced_chest_10000": false,
    "advanced_chest_1000000": false,
    "advanced_chest_10000000": false,
    "advanced_chest_100000000": false,
    "rare_chest_100": false,
    "rare_chest_10000": false,
    "rare_chest_1000000": false,
    "rare_chest_10000000": false,
    "rare_chest_100000000": false,
    "epic_chest_100": false,
    "epic_chest_10000": false,
    "epic_chest_1000000": false,
    "epic_chest_10000000": false,
    "epic_chest_100000000": false,
    "legendary_chest_100": false,
    "legendary_chest_10000": false,
    "legendary_chest_1000000": false,
    "legendary_chest_10000000": false,
    "legendary_chest_100000000": false,
    "chaos_chest_100": false,
    "chaos_chest_10000": false,
    "chaos_chest_1000000": false,
    "chaos_chest_10000000": false,
    "chaos_chest_100000000": false,
    "apocalypse_chest_100": false,
    "apocalypse_chest_10000": false,
    "apocalypse_chest_1000000": false,
    "apocalypse_chest_10000000": false,
    "apocalypse_chest_100000000": false,
    "yeyu1_chest_100": false,
    "yeyu1_chest_10000": false,
    "yeyu1_chest_1000000": false,
    "yeyu1_chest_10000000": false,
    "yeyu1_chest_100000000": false,
    "yeyu2_chest_100": false,
    "yeyu2_chest_10000": false,
    "yeyu2_chest_1000000": false,
    "yeyu2_chest_10000000": false,
    "yeyu2_chest_100000000": false,
    "yeyu3_chest_100": false,
    "yeyu3_chest_10000": false,
    "yeyu3_chest_1000000": false,
    "yeyu3_chest_10000000": false,
    "yeyu3_chest_100000000": false,
    "yeyu4_chest_100": false,
    "yeyu4_chest_10000": false,
    "yeyu4_chest_1000000": false,
    "yeyu4_chest_10000000": false,
    "yeyu4_chest_100000000": false,
    "yeyu5_chest_100": false,
    "yeyu5_chest_10000": false,
    "yeyu5_chest_1000000": false,
    "yeyu5_chest_10000000": false,
    "yeyu5_chest_100000000": false,
    "yeyu6_chest_100": false,
    "yeyu6_chest_10000": false,
    "yeyu6_chest_1000000": false,
    "yeyu6_chest_10000000": false,
    "yeyu6_chest_100000000": false,
    "yeyu7_chest_100": false,
    "yeyu7_chest_10000": false,
    "yeyu7_chest_1000000": false,
    "yeyu7_chest_10000000": false,
    "yeyu7_chest_100000000": false,
    "yeyu8_chest_100": false,
    "yeyu8_chest_10000": false,
    "yeyu8_chest_1000000": false,
    "yeyu8_chest_10000000": false,
    "yeyu8_chest_100000000": false,
    "max_stage_10": false,
    "max_stage_30": false,
    "max_stage_60": false,
    "max_stage_90": false,
    "max_stage_120": false,
    "max_stage_200": false,
    "max_stage_300": false,
    "max_stage_400": false,
    "max_stage_500": false,
    "max_stage_600": false,
    "max_stage_700": false,
    "max_stage_800": false,
    "max_stage_900": false,
    "max_stage_1000": false,

    // 新增宠物成就状态
    "thunderKirin_10": false,
    "thunderKirin_50": false,
    "thunderKirin_100": false,
    "chaosTaotie_10": false,
    "chaosTaotie_50": false,
    "chaosTaotie_100": false,
    "netherQiongqi_10": false,
    "netherQiongqi_50": false,
    "netherQiongqi_100": false,
    "abyssKun_10": false,
    "abyssKun_50": false,
    "abyssKun_100": false,
    "primordialZhuLong_10": false,
    "primordialZhuLong_50": false,
    "primordialZhuLong_100": false,
    "wanJunSuanNi_10": false,
    "wanJunSuanNi_50": false,
    "wanJunSuanNi_100": false,
    "yanYuBiAn_10": false,
    "yanYuBiAn_50": false,
    "yanYuBiAn_100": false,
    "yuyu1_10": false,
    "yuyu1_50": false,
    "yuyu1_100": false,
    "yuyu2_10": false,
    "yuyu2_50": false,
    "yuyu2_100": false,
    "yuyu3_10": false,
    "yuyu3_50": false,
    "yuyu3_100": false,
    "yuyu4_10": false,
    "yuyu4_50": false,
    "yuyu4_100": false,
    "yuyu5_10": false,
    "yuyu5_50": false,
    "yuyu5_100": false,
    "yuyu6_10": false,
    "yuyu6_50": false,
    "yuyu6_100": false,
    "yuyu7_10": false,
    "yuyu7_50": false,
    "yuyu7_100": false,
    "yuyu8_10": false,
    "yuyu8_50": false,
    "yuyu8_100": false,

    // 新增魂环成就状态
    "year1_10": false,
    "year10_10": false,
    "year100_10": false,
    "year1000_10": false,
    "year10000_10": false,
    "year100000_10": false,
    "year1000000_10": false,
    "year10000000_10": false,
    "year100000000_10": false,
    "year1_100": false,
    "year10_100": false,
    "year100_100": false,
    "year1000_100": false,
    "year10000_100": false,
    "year100000_100": false,
    "year1000000_100": false,
    "year10000000_100": false,
    "year100000000_100": false,
    "year1_1000": false,
    "year10_1000": false,
    "year100_1000": false,
    "year1000_1000": false,
    "year10000_1000": false,
    "year100000_1000": false,
    "year1000000_1000": false,
    "year10000000_1000": false,
    "year100000000_1000": false,
    "year1_10000": false,
    "year10_10000": false,
    "year100_10000": false,
    "year1000_10000": false,
    "year10000_10000": false,
    "year100000_10000": false,
    "year1000000_10000": false,
    "year10000000_10000": false,
    "year100000000_10000": false,
    "year2_10": false,
    "year2_100": false,
    "year2_1000": false,
    "year2_10000": false,
    "year3_10": false,
    "year3_100": false,
    "year3_1000": false,
    "year3_10000": false,
    "year4_10": false,
    "year4_100": false,
    "year4_1000": false,
    "year4_10000": false,
    "year5_10": false,
    "year5_100": false,
    "year5_1000": false,
    "year5_10000": false,
    "year6_10": false,
    "year6_100": false,
    "year6_1000": false,
    "year6_10000": false,
    "year7_10": false,
    "year7_100": false,
    "year7_1000": false,
    "year7_10000": false,
    "year8_10": false,
    "year8_100": false,
    "year8_1000": false,
    "year8_10000": false,
    "year9_10": false,
    "year9_100": false,
    "year9_1000": false,
    "year9_10000": false,
    "year11_10": false,
    "year11_100": false,
    "year11_1000": false,
    "year11_10000": false,
    "year12_10": false,
    "year12_100": false,
    "year12_1000": false,
    "year12_10000": false,
    "year13_10": false,
    "year13_100": false,
    "year13_1000": false,
    "year13_10000": false,
    "year14_10": false,
    "year14_100": false,
    "year14_1000": false,
    "year14_10000": false,
    "year15_10": false,
    "year15_100": false,
    "year15_1000": false,
    "year15_10000": false,
    "year16_10": false,
    "year16_100": false,
    "year16_1000": false,
    "year16_10000": false,
    "year17_10": false,
    "year17_100": false,
    "year17_1000": false,
    "year17_10000": false,
    "year18_10": false,
    "year18_100": false,
    "year18_1000": false,
    "year18_10000": false,
    "year19_10": false,
    "year19_100": false,
    "year19_1000": false,
    "year19_10000": false,
    "year20_10": false,
    "year20_100": false,
    "year20_1000": false,
    "year20_10000": false,
    "year21_10": false,
    "year21_100": false,
    "year21_1000": false,
    "year21_10000": false,
    "year22_10": false,
    "year22_100": false,
    "year22_1000": false,
    "year22_10000": false,
    "year23_10": false,
    "year23_100": false,
    "year23_1000": false,
    "year23_10000": false,
    "year24_10": false,
    "year24_100": false,
    "year24_1000": false,
    "year24_10000": false,
    "year25_10": false,
    "year25_100": false,
    "year25_1000": false,
    "year25_10000": false,
    "year26_10": false,
    "year26_100": false,
    "year26_1000": false,
    "year26_10000": false,
    "year27_10": false,
    "year27_100": false,
    "year27_1000": false,
    "year27_10000": false,
    "year28_10": false,
    "year28_100": false,
    "year28_1000": false,
    "year28_10000": false,
    "year29_10": false,
    "year29_100": false,
    "year29_1000": false,
    "year29_10000": false,
    "year30_10": false,
    "year30_100": false,
    "year30_1000": false,
    "year30_10000": false,
    "year31_10": false,
    "year31_100": false,
    "year31_1000": false,
    "year31_10000": false,
    "year32_10": false,
    "year32_100": false,
    "year32_1000": false,
    "year32_10000": false,
    "year33_10": false,
    "year33_100": false,
    "year33_1000": false,
    "year33_10000": false,
    "year34_10": false,
    "year34_100": false,
    "year34_1000": false,
    "year34_10000": false,
    "year35_10": false,
    "year35_100": false,
    "year35_1000": false,
    "year35_10000": false,
    "year36_10": false,
    "year36_100": false,
    "year36_1000": false,
    "year36_10000": false,
    "year37_10": false,
    "year37_100": false,
    "year37_1000": false,
    "year37_10000": false,
    "world_boss_1st": false,
    "world_boss_top5": false,
    "world_boss_top10": false,
    "world_boss_participant": false,
    "reincarnation_10": false,
    "reincarnation_100": false,
    "reincarnation_1000": false,
    "reincarnation_10000": false
      },
            actionLogs: [], 
            goldLogs: [],
            autoBuy: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], 
            autoBuySpeedBoost: false,
            onlineBoostEnabled: false,
            autoBuyMaterialChest: false, 
            autoBuyTechniqueChest: false, 
            autoBuyTechniqueMaxCost: 0.1,
            gpsMultiplier: 1, 
            clickMultiplier: 1,
            autoConvert: false,
            autoConvertCurrency: { 
                gold: false,
                diamond: false,
                titanium: false,
                starstone: false
            },
            clickTimestamps: [], 
            chestCounts: { 
                common: 0,
                advanced: 0,
                rare: 0,
                epic: 0,
                legendary: 0
            },
            reincarnationStats: { 
                gpsBonus: { level: 0, cost: 1 },
                equipmentLevelBonus: { level: 0, cost: 1 },
                clickLimitBonus: { level: 0, cost: 1 }
            },
            materialChestCost: 1,
            techniqueChestCost: 1,
            stockData: { 
                stocks: [
                    { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                    { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                    { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                    { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                    { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
                ],
                lastStockUpdate: Date.now()
            },
     fundData: {
    funds: [
        { name: "稳健型基金", netValue: 1.00, maxInvestment: 100000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "平衡型基金", netValue: 1.00, maxInvestment: 1000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "成长型基金", netValue: 1.00, maxInvestment: 100000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "进取型基金", netValue: 1.00, maxInvestment: 1e15, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "激进型基金", netValue: 1.00, maxInvestment: 1e30, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
        { name: "风险型基金", netValue: 1.00, maxInvestment: 1e50, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 }
    ],
    lastFundUpdate: Date.now()
},
            lotteryResults: [],
            traditionalLotteryNumbers: [],
         traditionalLotteryPurchased: false,
          traditionalLotteryBought: false,
         traditionalLotteryDrawTime: 0,
            lastLotteryDraw: Date.now(),
           titles: {
        unlocked: [], // 已解锁称号列表
        current: null // 当前选择的称号
    },
            bank: { 
                deposit: 0, 
                lastInterestUpdate: Date.now() 
            },
         parking: {
            level: 1,
            exp: 0,
            maxSpots: 1,
            vehicles: [],
            parkedVehicles: [],
            lastUpdate: Date.now(),
            totalIncome: 0
        },
            battle: {
                currentStage: 0,
        maxStage: 0,
        monster: null,
        playerHealth: 0,
        playerAttack: 0,
        playerCritRate: 0.1,
        playerCritDamage: 1.5,
        playerAccuracy: 0.9,
        playerDodge: 0.1,
        autoSweepEnabled: false  
    }
};
        // 成就奖励配置
        const achievementRewards = {
    "common": { gpsMultiplier: 0.15, description: "获得普通装备，GPS +15%" },
    "rare": { gpsMultiplier: 0.30, description: "获得稀有装备，GPS +30%" },
    "epic": { gpsMultiplier: 0.45, description: "获得史诗装备，GPS +45%" },
    "legendary": { gpsMultiplier: 0.60, description: "获得传说装备，GPS +60%" },
    "ancient": { gpsMultiplier: 0.75, description: "获得远古装备，GPS +75%" },
    "divine": { gpsMultiplier: 0.90, description: "获得神圣装备，GPS +90%" },
    "arcane": { gpsMultiplier: 1.05, description: "获得奥术装备，GPS +105%" },
    "celestial": { gpsMultiplier: 1.30, description: "获得天空装备，GPS +130%" },
    "infernal": { gpsMultiplier: 1.45, description: "获得地狱装备，GPS +145%" },
    "astral": { gpsMultiplier: 1.60, description: "获得星界装备，GPS +160%" },
    "primeval": { gpsMultiplier: 1.75, description: "获得原初装备，GPS +175%" },
    "transcendental": { gpsMultiplier: 1.90, description: "获得超凡装备，GPS +190%" },
    "quantum": { gpsMultiplier: 2.05, description: "获得量子装备，GPS +205%" },
    "ultimate": { gpsMultiplier: 2.20, description: "获得究极装备，GPS +220%" },
    "chaos": { gpsMultiplier: 2.35, description: "获得混沌装备，GPS +235%" },
    "eternal": { gpsMultiplier: 2.50, description: "获得永恒装备，GPS +250%" },
    "void": { gpsMultiplier: 2.70, description: "获得虚无装备，GPS +270%" },
    "genesis": { gpsMultiplier: 2.80, description: "获得创世装备，GPS +280%" },
    "divineRealm": { gpsMultiplier: 2.90, description: "获得神域装备，GPS +290%" },
    "apocalypse": { gpsMultiplier: 3.00, description: "获得终焉装备，GPS +300%" },
    "yeyu1": { gpsMultiplier: 3.10, description: "获得星辰装备，GPS +310%" },
    "yeyu2": { gpsMultiplier: 3.20, description: "获得起源装备，GPS +320%" },
    "yeyu3": { gpsMultiplier: 3.30, description: "获得时光装备，GPS +330%" },
    "yeyu4": { gpsMultiplier: 3.40, description: "获得造物装备，GPS +340%" },
    "yeyu5": { gpsMultiplier: 3.50, description: "获得银河装备，GPS +350%" },
    "yeyu6": { gpsMultiplier: 3.60, description: "获得天界装备，GPS +360%" },
    "yeyu7": { gpsMultiplier: 3.70, description: "获得星云装备，GPS +370%" },
    "yeyu8": { gpsMultiplier: 3.80, description: "获得星河装备，GPS +380%" },
    "yeyu9": { gpsMultiplier: 3.90, description: "获得纪元装备，GPS +390%" },
    "yeyu10": { gpsMultiplier: 4.00, description: "获得鸿蒙装备，GPS +400%" },
    "yeyu11": { gpsMultiplier: 4.10, description: "获得星穹装备，GPS +410%" },
    "yeyu12": { gpsMultiplier: 4.20, description: "获得亘古装备，GPS +420%" },
    "yeyu13": { gpsMultiplier: 4.30, description: "获得万象装备，GPS +430%" },
    "yeyu14": { gpsMultiplier: 4.40, description: "获得太虚装备，GPS +440%" },
    "yeyu15": { gpsMultiplier: 4.50, description: "获得九垓装备，GPS +450%" },
    "yeyu16": { gpsMultiplier: 4.60, description: "获得穿梭装备，GPS +460%" },
    "yeyu17": { gpsMultiplier: 4.70, description: "获得恒古装备，GPS +470%" },
    "yeyu18": { gpsMultiplier: 4.80, description: "获得虚空装备，GPS +480%" },    
     "yeyu19": { gpsMultiplier: 4.90, description: "获得蔚来装备，GPS +490%" },
    "yeyu20": { gpsMultiplier: 5.00, description: "获得神罚装备，GPS +500%" },
    "yeyu21": { gpsMultiplier: 5.10, description: "获得时空装备，GPS +510%" },    
    "yeyu22": { gpsMultiplier: 5.20, description: "获得未来装备，GPS +520%" },
    "yeyu23": { gpsMultiplier: 5.30, description: "获得从前装备，GPS +530%" },
    "yeyu24": { gpsMultiplier: 5.40, description: "获得星澜装备，GPS +540%" },    
    // 新增成就奖励
    "common_chest_100": { gpsMultiplier: 0.10, description: "购买普通宝箱总数达到100个，GPS +10%" },
    "common_chest_10000": { gpsMultiplier: 0.20, description: "购买普通宝箱总数达到1万个，GPS +20%" },
    "common_chest_1000000": { gpsMultiplier: 0.40, description: "购买普通宝箱总数达到100万个，GPS +40%" },
    "common_chest_10000000": { gpsMultiplier: 0.80, description: "购买普通宝箱总数达到1000万个，GPS +80%" },
    "common_chest_100000000": { gpsMultiplier: 1.00, description: "购买普通宝箱总数达到1亿个，GPS +100%" },
    "advanced_chest_100": { gpsMultiplier: 0.20, description: "购买高级宝箱总数达到100个，GPS +20%" },
    "advanced_chest_10000": { gpsMultiplier: 0.40, description: "购买高级宝箱总数达到1万个，GPS +40%" },
    "advanced_chest_1000000": { gpsMultiplier: 0.70, description: "购买高级宝箱总数达到100万个，GPS +70%" },
    "advanced_chest_10000000": { gpsMultiplier: 1.20, description: "购买高级宝箱总数达到1000万个，GPS +120%" },
    "advanced_chest_100000000": { gpsMultiplier: 1.70, description: "购买高级宝箱总数达到1亿个，GPS +170%" },
    "rare_chest_100": { gpsMultiplier: 0.30, description: "购买稀有宝箱总数达到100个，GPS +30%" },
    "rare_chest_10000": { gpsMultiplier: 0.60, description: "购买稀有宝箱总数达到1万个，GPS +60%" },
    "rare_chest_1000000": { gpsMultiplier: 1.00, description: "购买稀有宝箱总数达到100万个，GPS +100%" },
    "rare_chest_10000000": { gpsMultiplier: 1.60, description: "购买稀有宝箱总数达到1000万个，GPS +160%" },
    "rare_chest_100000000": { gpsMultiplier: 2.40, description: "购买稀有宝箱总数达到1亿个，GPS +240%" },
    "epic_chest_100": { gpsMultiplier: 0.40, description: "购买史诗宝箱总数达到100个，GPS +40%" },
    "epic_chest_10000": { gpsMultiplier: 0.80, description: "购买史诗宝箱总数达到1万个，GPS +80%" },
    "epic_chest_1000000": { gpsMultiplier: 1.30, description: "购买史诗宝箱总数达到100万个，GPS +130%" },
    "epic_chest_10000000": { gpsMultiplier: 2.00, description: "购买史诗宝箱总数达到1000万个，GPS +200%" },
    "epic_chest_100000000": { gpsMultiplier: 3.10, description: "购买史诗宝箱总数达到1亿个，GPS +310%" },
    "legendary_chest_100": { gpsMultiplier: 0.50, description: "购买传说宝箱总数达到100个，GPS +50%" },
    "legendary_chest_10000": { gpsMultiplier: 1.00, description: "购买传说宝箱总数达到1万个，GPS +100%" },
    "legendary_chest_1000000": { gpsMultiplier: 1.60, description: "购买传说宝箱总数达到100万个，GPS +160%" },
    "legendary_chest_10000000": { gpsMultiplier: 2.40, description: "购买传说宝箱总数达到1000万个，GPS +240%" },
    "legendary_chest_100000000": { gpsMultiplier: 3.80, description: "购买传说宝箱总数达到1亿个，GPS +380%" },
    "chaos_chest_100": { gpsMultiplier: 0.60, description: "购买混沌宝箱总数达到100个，GPS +60%" },
    "chaos_chest_10000": { gpsMultiplier: 1.20, description: "购买混沌宝箱总数达到1万个，GPS +120%" },
    "chaos_chest_1000000": { gpsMultiplier: 1.90, description: "购买混沌宝箱总数达到100万个，GPS +190%" },
    "chaos_chest_10000000": { gpsMultiplier: 2.80, description: "购买混沌宝箱总数达到1000万个，GPS +280%" },
    "chaos_chest_100000000": { gpsMultiplier: 4.50, description: "购买混沌宝箱总数达到1亿个，GPS +450%" },
    "apocalypse_chest_100": { gpsMultiplier: 0.70, description: "购买终焉宝箱总数达到100个，GPS +70%" },
    "apocalypse_chest_10000": { gpsMultiplier: 1.40, description: "购买终焉宝箱总数达到1万个，GPS +140%" },
    "apocalypse_chest_1000000": { gpsMultiplier: 2.20, description: "购买终焉宝箱总数达到100万个，GPS +220%" },
    "apocalypse_chest_10000000": { gpsMultiplier: 3.20, description: "购买终焉宝箱总数达到1000万个，GPS +320%" },
    "apocalypse_chest_100000000": { gpsMultiplier: 5.20, description: "购买终焉宝箱总数达到1亿个，GPS +520%" },
    "yeyu1_chest_100": { gpsMultiplier: 0.80, description: "购买星辰宝箱总数达到100个，GPS +80%" },
    "yeyu1_chest_10000": { gpsMultiplier: 1.50, description: "购买星辰宝箱总数达到1万个，GPS +150%" },
    "yeyu1_chest_1000000": { gpsMultiplier: 2.30, description: "购买星辰宝箱总数达到100万个，GPS +230%" },
    "yeyu1_chest_10000000": { gpsMultiplier: 3.30, description: "购买星辰宝箱总数达到1000万个，GPS +330%" },
    "yeyu1_chest_100000000": { gpsMultiplier: 5.30, description: "购买星辰宝箱总数达到1亿个，GPS +530%" },
    "yeyu2_chest_100": { gpsMultiplier: 0.90, description: "购买银河宝箱总数达到100个，GPS +90%" },
    "yeyu2_chest_10000": { gpsMultiplier: 1.60, description: "购买银河宝箱总数达到1万个，GPS +160%" },
    "yeyu2_chest_1000000": { gpsMultiplier: 2.40, description: "购买银河宝箱总数达到100万个，GPS +240%" },
    "yeyu2_chest_10000000": { gpsMultiplier: 3.40, description: "购买银河宝箱总数达到1000万个，GPS +340%" },
    "yeyu2_chest_100000000": { gpsMultiplier: 5.40, description: "购买银河宝箱总数达到1亿个，GPS +540%" },
        "yeyu3_chest_100": { gpsMultiplier: 1.00, description: "购买星云宝箱总数达到100个，GPS +100%" },
    "yeyu3_chest_10000": { gpsMultiplier: 1.70, description: "购买星云宝箱总数达到1万个，GPS +170%" },
    "yeyu3_chest_1000000": { gpsMultiplier: 2.50, description: "购买星云宝箱总数达到100万个，GPS +250%" },
    "yeyu3_chest_10000000": { gpsMultiplier: 3.50, description: "购买星云宝箱总数达到1000万个，GPS +350%" },
    "yeyu3_chest_100000000": { gpsMultiplier: 5.50, description: "购买星云宝箱总数达到1亿个，GPS +550%" },
        "yeyu4_chest_100": { gpsMultiplier: 1.10, description: "购买鸿蒙宝箱总数达到100个，GPS +110%" },
    "yeyu4_chest_10000": { gpsMultiplier: 1.80, description: "购买鸿蒙宝箱总数达到1万个，GPS +180%" },
    "yeyu4_chest_1000000": { gpsMultiplier: 2.60, description: "购买鸿蒙宝箱总数达到100万个，GPS +260%" },
    "yeyu4_chest_10000000": { gpsMultiplier: 3.60, description: "购买鸿蒙宝箱总数达到1000万个，GPS +360%" },
    "yeyu4_chest_100000000": { gpsMultiplier: 5.60, description: "购买鸿蒙宝箱总数达到1亿个，GPS +560%" },
        "yeyu5_chest_100": { gpsMultiplier: 1.20, description: "购买太虚宝箱总数达到100个，GPS +120%" },
    "yeyu5_chest_10000": { gpsMultiplier: 1.90, description: "购买太虚宝箱总数达到1万个，GPS +190%" },
    "yeyu5_chest_1000000": { gpsMultiplier: 2.70, description: "购买太虚宝箱总数达到100万个，GPS +270%" },
    "yeyu5_chest_10000000": { gpsMultiplier: 3.70, description: "购买太虚宝箱总数达到1000万个，GPS +370%" },
    "yeyu5_chest_100000000": { gpsMultiplier: 5.70, description: "购买太虚宝箱总数达到1亿个，GPS +570%" },
       "yeyu6_chest_100": { gpsMultiplier: 1.30, description: "购买星云宝箱总数达到100个，GPS +130%" },
    "yeyu6_chest_10000": { gpsMultiplier: 2.00, description: "购买星云宝箱总数达到1万个，GPS +200%" },
    "yeyu6_chest_1000000": { gpsMultiplier: 2.80, description: "购买星云宝箱总数达到100万个，GPS +280%" },
    "yeyu6_chest_10000000": { gpsMultiplier: 3.70, description: "购买星云宝箱总数达到1000万个，GPS +370%" },
    "yeyu6_chest_100000000": { gpsMultiplier: 5.70, description: "购买星云宝箱总数达到1亿个，GPS +570%" },
    "yeyu7_chest_100": { gpsMultiplier: 1.40, description: "购买鸿蒙宝箱总数达到100个，GPS +140%" },
    "yeyu7_chest_10000": { gpsMultiplier: 2.10, description: "购买鸿蒙宝箱总数达到1万个，GPS +210%" },
    "yeyu7_chest_1000000": { gpsMultiplier: 2.90, description: "购买鸿蒙宝箱总数达到100万个，GPS +290%" },
    "yeyu7_chest_10000000": { gpsMultiplier: 3.80, description: "购买鸿蒙宝箱总数达到1000万个，GPS +380%" },
    "yeyu7_chest_100000000": { gpsMultiplier: 5.80, description: "购买鸿蒙宝箱总数达到1亿个，GPS +580%" },
    "yeyu8_chest_100": { gpsMultiplier: 1.50, description: "购买太虚宝箱总数达到100个，GPS +120%" },
    "yeyu8_chest_10000": { gpsMultiplier: 2.20, description: "购买太虚宝箱总数达到1万个，GPS +220%" },
    "yeyu8_chest_1000000": { gpsMultiplier: 3.00, description: "购买太虚宝箱总数达到100万个，GPS +300%" },
    "yeyu8_chest_10000000": { gpsMultiplier: 3.90, description: "购买太虚宝箱总数达到1000万个，GPS +390%" },
    "yeyu8_chest_100000000": { gpsMultiplier: 5.90, description: "购买太虚宝箱总数达到1亿个，GPS +590%" },
    "max_stage_10": { gpsMultiplier: 0.20, description: "达到最大关卡10，GPS +20%" },
    "max_stage_30": { gpsMultiplier: 0.50, description: "达到最大关卡30，GPS +50%" },
    "max_stage_60": { gpsMultiplier: 0.80, description: "达到最大关卡60，GPS +80%" },
    "max_stage_90": { gpsMultiplier: 1.20, description: "达到最大关卡90，GPS +120%" },
    "max_stage_120": { gpsMultiplier: 1.50, description: "达到最大关卡120，GPS +150%" },
    "max_stage_200": { gpsMultiplier: 1.80, description: "达到最大关卡200，GPS +180%" },
    "max_stage_300": { gpsMultiplier: 2.10, description: "达到最大关卡300，GPS +210%" },
    "max_stage_400": { gpsMultiplier: 2.40, description: "达到最大关卡400，GPS +240%" },
    "max_stage_500": { gpsMultiplier: 2.70, description: "达到最大关卡500，GPS +270%" },
    "max_stage_600": { gpsMultiplier: 3.00, description: "达到最大关卡600，GPS +300%" },
    "max_stage_700": { gpsMultiplier: 3.30, description: "达到最大关卡700，GPS +330%" },
    "max_stage_800": { gpsMultiplier: 3.60, description: "达到最大关卡800，GPS +360%" },
    "max_stage_900": { gpsMultiplier: 3.90, description: "达到最大关卡900，GPS +390%" },
    "max_stage_1000": { gpsMultiplier: 4.10, description: "达到最大关卡1000，GPS +410%" },

    // 新增宠物成就
    "thunderKirin_10": { gpsMultiplier: 0.10, description: "苍雷麒麟达到10级，GPS +10%" },
    "thunderKirin_50": { gpsMultiplier: 0.30, description: "苍雷麒麟达到50级，GPS +30%" },
    "thunderKirin_100": { gpsMultiplier: 1.00, description: "苍雷麒麟达到100级，GPS +100%" },
    "chaosTaotie_10": { gpsMultiplier: 0.20, description: "混沌饕餮达到10级，GPS +20%" },
    "chaosTaotie_50": { gpsMultiplier: 0.40, description: "混沌饕餮达到50级，GPS +40%" },
    "chaosTaotie_100": { gpsMultiplier: 1.20, description: "混沌饕餮达到100级，GPS +120%" },
    "netherQiongqi_10": { gpsMultiplier: 0.20, description: "九幽穷奇达到10级，GPS +20%" },
    "netherQiongqi_50": { gpsMultiplier: 0.50, description: "九幽穷奇达到50级，GPS +50%" },
    "netherQiongqi_100": { gpsMultiplier: 1.50, description: "九幽穷奇达到100级，GPS +150%" },
    "abyssKun_10": { gpsMultiplier: 0.30, description: "霸渊巨鲲达到10级，GPS +30%" },
    "abyssKun_50": { gpsMultiplier: 0.70, description: "霸渊巨鲲达到50级，GPS +70%" },
    "abyssKun_100": { gpsMultiplier: 2.00, description: "霸渊巨鲲达到100级，GPS +200%" },
    "primordialZhuLong_10": { gpsMultiplier: 0.50, description: "太初烛龙达到10级，GPS +50%" },
    "primordialZhuLong_50": { gpsMultiplier: 1.00, description: "太初烛龙达到50级，GPS +100%" },
    "primordialZhuLong_100": { gpsMultiplier: 2.50, description: "太初烛龙达到100级，GPS +250%" },
    "wanJunSuanNi_10": { gpsMultiplier: 0.70, description: "万钧狻猊达到10级，GPS +70%" },
    "wanJunSuanNi_50": { gpsMultiplier: 1.50, description: "万钧狻猊达到50级，GPS +150%" },
    "wanJunSuanNi_100": { gpsMultiplier: 3.00, description: "万钧狻猊达到100级，GPS +300%" },
    "yanYuBiAn_10": { gpsMultiplier: 1.00, description: "炎狱狴犴达到10级，GPS +100%" },
    "yanYuBiAn_50": { gpsMultiplier: 2.00, description: "炎狱狴犴达到50级，GPS +200%" },
    "yanYuBiAn_100": { gpsMultiplier: 3.50, description: "炎狱狴犴达到100级，GPS +350%" },
     "yuyu1_10": { gpsMultiplier: 1.00, description: "赤霄夔龙达到10级，GPS +100%" },
    "yuyu1_50": { gpsMultiplier: 2.50, description: "赤霄夔龙达到50级，GPS +250%" },
    "yuyu1_100": { gpsMultiplier: 4.00, description: "赤霄夔龙达到100级，GPS +400%" },
    "yuyu2_10": { gpsMultiplier: 1.30, description: "震岳白泽达到10级，GPS +130%" },
    "yuyu2_50": { gpsMultiplier: 3.00, description: "震岳白泽达到50级，GPS +300%" },
    "yuyu2_100": { gpsMultiplier: 4.50, description: "震岳白泽达到100级，GPS +450%" },
    "yuyu3_10": { gpsMultiplier: 1.60, description: "焚天蛊雕达到10级，GPS +160%" },
    "yuyu3_50": { gpsMultiplier: 3.50, description: "焚天蛊雕达到50级，GPS +350%" },
    "yuyu3_100": { gpsMultiplier: 5.00, description: "焚天蛊雕达到100级，GPS +500%" },
    "yuyu4_10": { gpsMultiplier: 1.90, description: "血煞梼杌达到10级，GPS +190%" },
    "yuyu4_50": { gpsMultiplier: 4.00, description: "血煞梼杌达到50级，GPS +400%" },
    "yuyu4_100": { gpsMultiplier: 5.50, description: "血煞梼杌达到100级，GPS +550%" },
    "yuyu5_10": { gpsMultiplier: 2.20, description: "玄渊白犼达到10级，GPS +220%" },
    "yuyu5_50": { gpsMultiplier: 4.50, description: "玄渊白犼达到50级，GPS +450%" },
    "yuyu5_100": { gpsMultiplier: 6.00, description: "玄渊白犼达到100级，GPS +600%" },
    "yuyu6_10": { gpsMultiplier: 2.50, description: "灾祸蜚牛达到10级，GPS +250%" },
    "yuyu6_50": { gpsMultiplier: 5.00, description: "灾祸蜚牛达到50级，GPS +500%" },
    "yuyu6_100": { gpsMultiplier: 6.50, description: "灾祸蜚牛达到100级，GPS +650%" },
    "yuyu7_10": { gpsMultiplier: 2.80, description: "寂灭罗睺达到10级，GPS +280%" },
    "yuyu7_50": { gpsMultiplier: 5.50, description: "寂灭罗睺达到50级，GPS +550%" },
    "yuyu7_100": { gpsMultiplier: 7.00, description: "寂灭罗睺达到100级，GPS +700%" },
    "yuyu8_10": { gpsMultiplier: 3.10, description: "永劫蚩尤达到10级，GPS +310%" },
    "yuyu8_50": { gpsMultiplier: 6.50, description: "永劫蚩尤达到50级，GPS +650%" },
    "yuyu8_100": { gpsMultiplier: 7.50, description: "永劫蚩尤达到100级，GPS +750%" },

    // 新增魂环成就
    "year1_10": { gpsMultiplier: 0.20, description: "一年魂环达到10级，GPS +20%" },
    "year10_10": { gpsMultiplier: 0.30, description: "十年魂环达到10级，GPS +30%" },
    "year100_10": { gpsMultiplier: 0.40, description: "百年魂环达到10级，GPS +40%" },
    "year1000_10": { gpsMultiplier: 0.50, description: "千年魂环达到10级，GPS +50%" },
    "year10000_10": { gpsMultiplier: 0.60, description: "万年魂环达到10级，GPS +60%" },
    "year100000_10": { gpsMultiplier: 0.70, description: "十万年魂环达到10级，GPS +70%" },
    "year1000000_10": { gpsMultiplier: 0.80, description: "百万年魂环达到10级，GPS +80%" },
    "year10000000_10": { gpsMultiplier: 0.90, description: "千万年魂环达到10级，GPS +90%" },
    "year100000000_10": { gpsMultiplier: 1.00, description: "亿年魂环达到10级，GPS +100%" },
    "year1_100": { gpsMultiplier: 0.50, description: "一年魂环达到100级，GPS +50%" },
    "year10_100": { gpsMultiplier: 0.60, description: "十年魂环达到100级，GPS +60%" },
    "year100_100": { gpsMultiplier: 0.70, description: "百年魂环达到100级，GPS +70%" },
    "year1000_100": { gpsMultiplier: 0.80, description: "千年魂环达到100级，GPS +80%" },
    "year10000_100": { gpsMultiplier: 0.90, description: "万年魂环达到100级，GPS +90%" },
    "year100000_100": { gpsMultiplier: 1.00, description: "十万年魂环达到100级，GPS +100%" },
    "year1000000_100": { gpsMultiplier: 1.10, description: "百万年魂环达到100级，GPS +110%" },
    "year10000000_100": { gpsMultiplier: 1.20, description: "千万年魂环达到100级，GPS +120%" },
    "year100000000_100": { gpsMultiplier: 1.30, description: "亿年魂环达到100级，GPS +130%" },
    "year1_1000": { gpsMultiplier: 1.00, description: "一年魂环达到1000级，GPS +100%" },
    "year10_1000": { gpsMultiplier: 1.10, description: "十年魂环达到1000级，GPS +110%" },
    "year100_1000": { gpsMultiplier: 1.20, description: "百年魂环达到1000级，GPS +120%" },
    "year1000_1000": { gpsMultiplier: 1.30, description: "千年魂环达到1000级，GPS +130%" },
    "year10000_1000": { gpsMultiplier: 1.40, description: "万年魂环达到1000级，GPS +140%" },
    "year100000_1000": { gpsMultiplier: 1.50, description: "十万年魂环达到1000级，GPS +150%" },
    "year1000000_1000": { gpsMultiplier: 1.60, description: "百万年魂环达到1000级，GPS +160%" },
    "year10000000_1000": { gpsMultiplier: 1.70, description: "千万年魂环达到1000级，GPS +170%" },
    "year100000000_1000": { gpsMultiplier: 1.80, description: "亿年魂环达到1000级，GPS +180%" },
    "year1_10000": { gpsMultiplier: 2.00, description: "一年魂环达到10000级，GPS +200%" },
    "year10_10000": { gpsMultiplier: 2.10, description: "十年魂环达到10000级，GPS +210%" },
    "year100_10000": { gpsMultiplier: 2.20, description: "百年魂环达到10000级，GPS +220%" },
    "year1000_10000": { gpsMultiplier: 2.30, description: "千年魂环达到10000级，GPS +230%" },
    "year10000_10000": { gpsMultiplier: 2.40, description: "万年魂环达到10000级，GPS +240%" },
    "year100000_10000": { gpsMultiplier: 2.50, description: "十万年魂环达到10000级，GPS +250%" },
    "year1000000_10000": { gpsMultiplier: 2.60, description: "百万年魂环达到10000级，GPS +260%" },
    "year10000000_10000": { gpsMultiplier: 2.70, description: "千万年魂环达到10000级，GPS +270%" },
    "year100000000_10000": { gpsMultiplier: 2.80, description: "亿年魂环达到10000级，GPS +280%" },
    "year2_10": { gpsMultiplier: 1.10, description: "太古·混沌亿年魂环达到10级，GPS +110%" },
    "year2_100": { gpsMultiplier: 1.40, description: "太古·混沌亿年魂环达到100级，GPS +140%" },
    "year2_1000": { gpsMultiplier: 1.90, description: "太古·混沌亿年魂环达到1000级，GPS +190%" },
    "year2_10000": { gpsMultiplier: 3.80, description: "太古·混沌亿年魂环达到10000级，GPS +380%" },
    "year3_10": { gpsMultiplier: 1.20, description: "鸿蒙·始源亿年魂环达到10级，GPS +120%" },
    "year3_100": { gpsMultiplier: 1.50, description: "鸿蒙·始源亿年魂环达到100级，GPS +150%" },
    "year3_1000": { gpsMultiplier: 2.00, description: "鸿蒙·始源亿年魂环达到1000级，GPS +200%" },
    "year3_10000": { gpsMultiplier: 3.90, description: "鸿蒙·始源亿年魂环达到10000级，GPS +390%" },
    "year4_10": { gpsMultiplier: 1.30, description: "亘古·时空亿年魂环达到10级，GPS +130%" },
    "year4_100": { gpsMultiplier: 1.60, description: "亘古·时空亿年魂环达到100级，GPS +160%" },
    "year4_1000": { gpsMultiplier: 2.10, description: "亘古·时空亿年魂环达到1000级，GPS +210%" },
    "year4_10000": { gpsMultiplier: 4.00, description: "亘古·时空亿年魂环达到10000级，GPS +400%" },
    "year5_10": { gpsMultiplier: 1.40, description: "九幽·冥渊亿年魂环达到10级，GPS +140%" },
    "year5_100": { gpsMultiplier: 1.70, description: "九幽·冥渊亿年魂环达到100级，GPS +170%" },
    "year5_1000": { gpsMultiplier: 2.20, description: "九幽·冥渊亿年魂环达到1000级，GPS +220%" },
    "year5_10000": { gpsMultiplier: 4.10, description: "九幽·冥渊亿年魂环达到10000级，GPS +410%" },
    "year6_10": { gpsMultiplier: 1.50, description: "皓宇·星辰亿年魂环达到10级，GPS +150%" },
    "year6_100": { gpsMultiplier: 1.80, description: "皓宇·星辰亿年魂环达到100级，GPS +180%" },
    "year6_1000": { gpsMultiplier: 2.30, description: "皓宇·星辰亿年魂环达到1000级，GPS +230%" },
    "year6_10000": { gpsMultiplier: 4.20, description: "皓宇·星辰亿年魂环达到10000级，GPS +420%" },
    "year7_10": { gpsMultiplier: 1.60, description: "炎狱·焚天亿年魂环达到10级，GPS +160%" },
    "year7_100": { gpsMultiplier: 1.90, description: "炎狱·焚天亿年魂环达到100级，GPS +190%" },
    "year7_1000": { gpsMultiplier: 2.40, description: "炎狱·焚天亿年魂环达到1000级，GPS +240%" },
    "year7_10000": { gpsMultiplier: 4.30, description: "炎狱·焚天亿年魂环达到10000级，GPS +430%" },
    "year8_10": { gpsMultiplier: 1.70, description: "霜烬·极寒亿年魂环达到10级，GPS +170%" },
    "year8_100": { gpsMultiplier: 2.00, description: "霜烬·极寒亿年魂环达到100级，GPS +200%" },
    "year8_1000": { gpsMultiplier: 2.50, description: "霜烬·极寒亿年魂环达到1000级，GPS +250%" },
    "year8_10000": { gpsMultiplier: 4.40, description: "霜烬·极寒亿年魂环达到10000级，GPS +440%" },
    "year9_10": { gpsMultiplier: 1.80, description: "灵幻·万象亿年魂环达到10级，GPS +180%" },
    "year9_100": { gpsMultiplier: 2.10, description: "灵幻·万象亿年魂环达到100级，GPS +210%" },
    "year9_1000": { gpsMultiplier: 2.60, description: "灵幻·万象亿年魂环达到1000级，GPS +260%" },
    "year9_10000": { gpsMultiplier: 4.50, description: "灵幻·万象亿年魂环达到10000级，GPS +450%" },
    "year11_10": { gpsMultiplier: 1.90, description: "炽阳·耀世亿年魂环达到10级，GPS +190%" },
    "year11_100": { gpsMultiplier: 2.20, description: "炽阳·耀世亿年魂环达到100级，GPS +220%" },
    "year11_1000": { gpsMultiplier: 2.70, description: "炽阳·耀世亿年魂环达到1000级，GPS +270%" },
    "year11_10000": { gpsMultiplier: 4.60, description: "炽阳·耀世亿年魂环达到10000级，GPS +460%" },
    "year12_10": { gpsMultiplier: 2.00, description: "暗蚀·灭世亿年魂环达到10级，GPS +200%" },
    "year12_100": { gpsMultiplier: 2.30, description: "暗蚀·灭世亿年魂环达到100级，GPS +230%" },
    "year12_1000": { gpsMultiplier: 2.80, description: "暗蚀·灭世亿年魂环达到1000级，GPS +280%" },
    "year12_10000": { gpsMultiplier: 4.70, description: "暗蚀·灭世亿年魂环达到10000级，GPS +470%" },
    "year13_10": { gpsMultiplier: 2.10, description: "圣辉·救赎亿年魂环达到10级，GPS +210%" },
    "year13_100": { gpsMultiplier: 2.40, description: "圣辉·救赎亿年魂环达到100级，GPS +240%" },
    "year13_1000": { gpsMultiplier: 2.90, description: "圣辉·救赎亿年魂环达到1000级，GPS +290%" },
    "year13_10000": { gpsMultiplier: 4.80, description: "圣辉·救赎亿年魂环达到10000级，GPS +480%" },
    "year14_10": { gpsMultiplier: 2.30, description: "紫霄·雷罚亿年魂环达到10级，GPS +220%" },
    "year14_100": { gpsMultiplier: 2.50, description: "紫霄·雷罚亿年魂环达到100级，GPS +250%" },
    "year14_1000": { gpsMultiplier: 3.00, description: "紫霄·雷罚亿年魂环达到1000级，GPS +300%" },
    "year14_10000": { gpsMultiplier: 4.90, description: "紫霄·雷罚亿年魂环达到10000级，GPS +490%" },
    "year15_10": { gpsMultiplier: 2.30, description: "青木·生机亿年魂环达到10级，GPS +230%" },
    "year15_100": { gpsMultiplier: 2.60, description: "青木·生机亿年魂环达到100级，GPS +260%" },
    "year15_1000": { gpsMultiplier: 3.00, description: "青木·生机亿年魂环达到1000级，GPS +300%" },
    "year15_10000": { gpsMultiplier: 5.00, description: "青木·生机亿年魂环达到10000级，GPS +500%" },
    "year16_10": { gpsMultiplier: 2.40, description: "星澜·幻梦亿年魂环达到10级，GPS +240%" },
    "year16_100": { gpsMultiplier: 2.70, description: "星澜·幻梦亿年魂环达到100级，GPS +270%" },
    "year16_1000": { gpsMultiplier: 3.10, description: "星澜·幻梦亿年魂环达到1000级，GPS +310%" },
    "year16_10000": { gpsMultiplier: 5.10, description: "星澜·幻梦亿年魂环达到10000级，GPS +510%" },
    "year17_10": { gpsMultiplier: 2.50, description: "渊海·无尽亿年魂环达到10级，GPS +250%" },
    "year17_100": { gpsMultiplier: 2.80, description: "渊海·无尽亿年魂环达到100级，GPS +280%" },
    "year17_1000": { gpsMultiplier: 3.20, description: "渊海·无尽亿年魂环达到1000级，GPS +320%" },
    "year17_10000": { gpsMultiplier: 5.20, description: "渊海·无尽亿年魂环达到10000级，GPS +520%" },
    "year18_10": { gpsMultiplier: 2.60, description: "荒古·遗世亿年魂环达到10级，GPS +260%" },
    "year18_100": { gpsMultiplier: 2.90, description: "荒古·遗世亿年魂环达到100级，GPS +290%" },
    "year18_1000": { gpsMultiplier: 3.30, description: "荒古·遗世亿年魂环达到1000级，GPS +330%" },
    "year18_10000": { gpsMultiplier: 5.30, description: "荒古·遗世亿年魂环达到10000级，GPS +530%" },
    "year19_10": { gpsMultiplier: 2.70, description: "净世·光明亿年魂环达到10级，GPS +270%" },
    "year19_100": { gpsMultiplier: 3.00, description: "净世·光明亿年魂环达到100级，GPS +300%" },
    "year19_1000": { gpsMultiplier: 3.40, description: "净世·光明亿年魂环达到1000级，GPS +340%" },
    "year19_10000": { gpsMultiplier: 5.40, description: "净世·光明亿年魂环达到10000级，GPS +540%" },
    "year20_10": { gpsMultiplier: 2.80, description: "蚀灵·诅咒亿年魂环达到10级，GPS +280%" },
    "year20_100": { gpsMultiplier: 3.10, description: "蚀灵·诅咒亿年魂环达到100级，GPS +310%" },
    "year20_1000": { gpsMultiplier: 3.50, description: "蚀灵·诅咒亿年魂环达到1000级，GPS +350%" },
    "year20_10000": { gpsMultiplier: 5.50, description: "蚀灵·诅咒亿年魂环达到10000级，GPS +550%" },
    "year21_10": { gpsMultiplier: 2.90, description: "逆乱·时空亿年魂环达到10级，GPS +290%" },
    "year21_100": { gpsMultiplier: 3.20, description: "逆乱·时空亿年魂环达到100级，GPS +320%" },
    "year21_1000": { gpsMultiplier: 3.60, description: "逆乱·时空亿年魂环达到1000级，GPS +360%" },
    "year21_10000": { gpsMultiplier: 5.60, description: "逆乱·时空亿年魂环达到10000级，GPS +560%" },
    "year22_10": { gpsMultiplier: 3.00, description: "龙渊·霸者亿年魂环达到10级，GPS +300%" },
    "year22_100": { gpsMultiplier: 3.30, description: "龙渊·霸者亿年魂环达到100级，GPS +330%" },
    "year22_1000": { gpsMultiplier: 3.70, description: "龙渊·霸者亿年魂环达到1000级，GPS +370%" },
    "year22_10000": { gpsMultiplier: 5.70, description: "龙渊·霸者亿年魂环达到10000级，GPS +570%" },
    "year23_10": { gpsMultiplier: 3.10, description: "凤羽·炎舞亿年魂环达到10级，GPS +310%" },
    "year23_100": { gpsMultiplier: 3.40, description: "凤羽·炎舞亿年魂环达到100级，GPS +340%" },
    "year23_1000": { gpsMultiplier: 3.80, description: "凤羽·炎舞亿年魂环达到1000级，GPS +380%" },
    "year23_10000": { gpsMultiplier: 5.80, description: "凤羽·炎舞亿年魂环达到10000级，GPS +580%" },
    "year24_10": { gpsMultiplier: 3.20, description: "星辰·命数亿年魂环达到10级，GPS +320%" },
    "year24_100": { gpsMultiplier: 3.50, description: "星辰·命数亿年魂环达到100级，GPS +350%" },
    "year24_1000": { gpsMultiplier: 3.90, description: "星辰·命数亿年魂环达到1000级，GPS +390%" },
    "year24_10000": { gpsMultiplier: 5.90, description: "星辰·命数亿年魂环达到10000级，GPS +590%" },
    "year25_10": { gpsMultiplier: 3.30, description: "荒炎·破灭亿年魂环达到10级，GPS +330%" },
    "year25_100": { gpsMultiplier: 3.60, description: "荒炎·破灭亿年魂环达到100级，GPS +360%" },
    "year25_1000": { gpsMultiplier: 4.00, description: "荒炎·破灭亿年魂环达到1000级，GPS +400%" },
    "year25_10000": { gpsMultiplier: 6.00, description: "荒炎·破灭亿年魂环达到10000级，GPS +600%" },
    "year26_10": { gpsMultiplier: 3.40, description: "玄冰·永冻亿年魂环达到10级，GPS +340%" },
    "year26_100": { gpsMultiplier: 3.70, description: "玄冰·永冻亿年魂环达到100级，GPS +370%" },
    "year26_1000": { gpsMultiplier: 4.10, description: "玄冰·永冻亿年魂环达到1000级，GPS +410%" },
    "year26_10000": { gpsMultiplier: 6.10, description: "玄冰·永冻亿年魂环达到10000级，GPS +610%" },
    "year27_10": { gpsMultiplier: 3.50, description: "灵犀·心眼亿年魂环达到10级，GPS +350%" },
    "year27_100": { gpsMultiplier: 3.80, description: "灵犀·心眼亿年魂环达到100级，GPS +380%" },
    "year27_1000": { gpsMultiplier: 4.20, description: "灵犀·心眼亿年魂环达到1000级，GPS +420%" },
    "year27_10000": { gpsMultiplier: 6.20, description: "灵犀·心眼亿年魂环达到10000级，GPS +620%" },
    "year28_10": { gpsMultiplier: 3.60, description: "圣谕·裁决亿年魂环达到10级，GPS +360%" },
    "year28_100": { gpsMultiplier: 3.90, description: "圣谕·裁决亿年魂环达到100级，GPS +390%" },
    "year28_1000": { gpsMultiplier: 4.30, description: "圣谕·裁决亿年魂环达到1000级，GPS +430%" },
    "year28_10000": { gpsMultiplier: 6.30, description: "圣谕·裁决亿年魂环达到10000级，GPS +630%" },
    "year29_10": { gpsMultiplier: 3.70, description: "九幽·黄泉亿年魂环达到10级，GPS +370%" },
    "year29_100": { gpsMultiplier: 4.00, description: "九幽·黄泉亿年魂环达到100级，GPS +400%" },
    "year29_1000": { gpsMultiplier: 4.40, description: "九幽·黄泉亿年魂环达到1000级，GPS +440%" },
    "year29_10000": { gpsMultiplier: 6.40, description: "九幽·黄泉亿年魂环达到10000级，GPS +640%" },
    "year30_10": { gpsMultiplier: 3.80, description: "灵蕴·造化亿年魂环达到10级，GPS +380%" },
    "year30_100": { gpsMultiplier: 4.10, description: "灵蕴·造化亿年魂环达到100级，GPS +410%" },
    "year30_1000": { gpsMultiplier: 4.50, description: "灵蕴·造化亿年魂环达到1000级，GPS +450%" },
    "year30_10000": { gpsMultiplier: 6.50, description: "灵蕴·造化亿年魂环达到10000级，GPS +650%" },
    "year31_10": { gpsMultiplier: 3.90, description: "混沌·元始亿年魂环达到10级，GPS +390%" },
    "year31_100": { gpsMultiplier: 4.20, description: "混沌·元始亿年魂环达到100级，GPS +420%" },
    "year31_1000": { gpsMultiplier: 4.60, description: "混沌·元始亿年魂环达到1000级，GPS +460%" },
    "year31_10000": { gpsMultiplier: 6.60, description: "混沌·元始亿年魂环达到10000级，GPS +660%" },
    "year32_10": { gpsMultiplier: 4.00, description: "苍穹·御天亿年魂环达到10级，GPS +400%" },
    "year32_100": { gpsMultiplier: 4.30, description: "苍穹·御天亿年魂环达到100级，GPS +430%" },
    "year32_1000": { gpsMultiplier: 4.70, description: "苍穹·御天亿年魂环达到1000级，GPS +470%" },
    "year32_10000": { gpsMultiplier: 6.70, description: "苍穹·御天亿年魂环达到10000级，GPS +670%" },
    "year33_10": { gpsMultiplier: 4.10, description: "龙炎·焚天亿年魂环达到10级，GPS +410%" },
    "year33_100": { gpsMultiplier: 4.40, description: "龙炎·焚天亿年魂环达到100级，GPS +440%" },
    "year33_1000": { gpsMultiplier: 4.80, description: "龙炎·焚天亿年魂环达到1000级，GPS +480%" },
    "year33_10000": { gpsMultiplier: 6.80, description: "龙炎·焚天亿年魂环达到10000级，GPS +680%" },
    "year34_10": { gpsMultiplier: 4.20, description: "血狱·魔神亿年魂环达到10级，GPS +420%" },
    "year34_100": { gpsMultiplier: 4.50, description: "血狱·魔神亿年魂环达到100级，GPS +450%" },
    "year34_1000": { gpsMultiplier: 4.90, description: "血狱·魔神亿年魂环达到1000级，GPS +490%" },
    "year34_10000": { gpsMultiplier: 6.90, description: "血狱·魔神亿年魂环达到10000级，GPS +690%" },
    "year35_10": { gpsMultiplier: 4.30, description: "赤霄·苍穹亿年魂环达到10级，GPS +430%" },
    "year35_100": { gpsMultiplier: 4.60, description: "赤霄·苍穹亿年魂环达到100级，GPS +460%" },
    "year35_1000": { gpsMultiplier: 5.00, description: "赤霄·苍穹亿年魂环达到1000级，GPS +500%" },
    "year35_10000": { gpsMultiplier: 7.00, description: "赤霄·苍穹亿年魂环达到10000级，GPS +700%" },
    "year36_10": { gpsMultiplier: 4.40, description: "炎凤·涅槃亿年魂环达到10级，GPS +440%" },
    "year36_100": { gpsMultiplier: 4.70, description: "炎凤·涅槃亿年魂环达到100级，GPS +470%" },
    "year36_1000": { gpsMultiplier: 5.10, description: "炎凤·涅槃亿年魂环达到1000级，GPS +510%" },
    "year36_10000": { gpsMultiplier: 7.10, description: "炎凤·涅槃亿年魂环达到10000级，GPS +710%" },
    "year37_10": { gpsMultiplier: 4.50, description: "闫闫·黑丝亿年魂环达到10级，GPS +450%" },
    "year37_100": { gpsMultiplier: 4.80, description: "闫闫·黑丝亿年魂环达到100级，GPS +480%" },
    "year37_1000": { gpsMultiplier: 5.20, description: "闫闫·黑丝亿年魂环达到1000级，GPS +520%" },
    "year37_10000": { gpsMultiplier: 7.20, description: "闫闫·黑丝亿年魂环达到10000级，GPS +720%" },
    "world_boss_1st": { gpsMultiplier: 10.0, description: "在世界BOSS中获得第1名，GPS +1000%"  },
    "world_boss_top5": { gpsMultiplier: 5.0, description: "在世界BOSS中获得第2-10名，GPS +500%"  },
    "world_boss_top10": { gpsMultiplier: 3.0, description: "在世界BOSS中获得第11-30名，GPS +300%"  },
    "world_boss_participant": { gpsMultiplier: 1.00, description: "参与世界BOSS战斗，GPS +100%"  },
    // 新增转生成就奖励
    "reincarnation_10": { gpsMultiplier: 0.50, description: "转生10次，GPS +50%" },
    "reincarnation_100": { gpsMultiplier: 1.00, description: "转生100次，GPS +100%" },
    "reincarnation_1000": { gpsMultiplier: 5.00, description: "转生1000次，GPS +500%" },
    "reincarnation_10000": { gpsMultiplier: 10.00, description: "转生10000次，GPS +1000%" }
};
 
// 功法秘笈配置
const techniqueConfig = {
    "immortalAsuraBody": { name: "不灭修罗体", type: "health", effect: 0.0001, description: "每一级增加0.01%生命永久属性" },
    "eightDesolationsWarDemonBody": { name: "八荒战魔躯", type: "health", effect: 0.001, description: "每一级增加0.1%生命永久属性" },
    "nineRevolutionsProfoundBody": { name: "九转玄黄身", type: "health", effect: 0.005, description: "每一级增加0.5%生命永久属性" },
    "loneDestinyBone": { name: "天煞孤星骨", type: "health", effect: 0.01, description: "每一级增加1%生命永久属性" },
    "bloodPrisonMadGodArmor": { name: "血狱狂神铠", type: "health", effect: 0.10, description: "每一级增加10%生命永久属性" },
    "godSlayingBurningHeavenArt": { name: "弑神焚天诀", type: "attack", effect: 0.0001, description: "每一级增加0.01%攻击永久属性" },
    "burialHeavenBladePrisonManual": { name: "葬天刀狱谱", type: "attack", effect: 0.001, description: "每一级增加0.1%攻击永久属性" },
    "tenDirectionsAnnihilationSpearCodex": { name: "十方俱灭枪典", type: "attack", effect: 0.005, description: "每一级增加0.5%攻击永久属" },
    "thousandCalamitiesVoidArrowArt": { name: "千劫裂空箭术", type: "attack", effect: 0.05, description: "每一级增加5%攻击永久属性" },
    "ancientAnnihilationHalberdArt": { name: "万古寂灭戟法", type: "attack", effect: 0.10, description: "每一级增加10%攻击永久属性" },
    "nineCalamitiesWorldDestroyingPalm": { name: "九劫灭世掌", type: "critDamage", effect: 0.001, description: "每一级增加0.1%爆伤永久属性" },
    "chaosCreationForce": { name: "混沌开天劲", type: "critDamage", effect: 0.005, description: "每一级增加0.5%爆伤永久属性" },
    "dragonElephantShatteringVoidArt": { name: "龙象碎穹功", type: "critDamage", effect: 0.01, description: "每一级增加1%爆伤永久属性" },
    "greatSunFallingStarFist": { name: "大日陨星拳", type: "critDamage", effect: 0.10, description: "每一级增加10%爆伤永久属性" },
    "nineHeavensThunderboltTruth": { name: "九霄雷殛真解", type: "critRate", effect: 0.00001, description: "每一级增加0.001%暴击率永久属性" },
    "netherBloodSeaDiagram": { name: "幽冥血海图录", type: "critRate", effect: 0.0005, description: "每一级增加0.05%暴击率永久属性" },
    "riverStarsHangingSecretScroll": { name: "星河倒悬秘卷", type: "critRate", effect: 0.0001, description: "每一级增加0.01%暴击率永久属性" },
    "eightDesolationsFireDragonRecord": { name: "八荒火龙焚世录", type: "critRate", effect: 0.001, description: "每一级增加0.1%暴击率永久属性" },
    "iceSealThreeThousandRealmArt": { name: "冰封三千界心法", type: "critRate", effect: 0.01, description: "每一级增加1%暴击率永久属性" },
    "greatVoidReturnToVoidCodex": { name: "太虚归墟典", type: "multiAttack", effect: 2, description: "每一级攻击次数+2永久属性" },
    "samsaraCalamityAnnihilationSutra": { name: "轮回劫灭经", type: "multiAttack", effect: 3, description: "每一级攻击次数+3永久属性" },
    "yinYangReversalArt": { name: "阴阳逆命术", type: "multiAttack", effect: 5, description: "每一级攻击次数+5永久属性" },
    "zhouHeavenStarsFallingWay": { name: "周天星陨道", type: "multiAttack", effect: 10, description: "每一级攻击次数+10永久属性" },
    "ancientVoidRecord": { name: "万古空冥录", type: "multiAttack", effect: 50, description: "每一级攻击次数+50永久属性" }
};
const vipConfig = [
    { level: 1, requiredPower: 0, bonus: 1 }, 
    { level: 2, requiredPower: 5, bonus: 2 }, 
    { level: 3, requiredPower: 15, bonus: 4 }, 
    { level: 4, requiredPower: 32, bonus: 6 }, 
    { level: 5, requiredPower: 64, bonus: 8 },
    { level: 6, requiredPower: 128, bonus: 10 },
    { level: 7, requiredPower: 648, bonus: 20 }, 
    { level: 8, requiredPower: 1280, bonus: 40 }, 
    { level: 9, requiredPower: 3280, bonus: 60 }, 
    { level: 10, requiredPower: 6480, bonus: 80 }, 
    { level: 11, requiredPower: 10000, bonus: 100 },
    { level: 12, requiredPower: 20000, bonus: 200 },
    { level: 13, requiredPower: 30000, bonus: 400 },
    { level: 14, requiredPower: 40000, bonus: 600 },
    { level: 15, requiredPower: 50000, bonus: 800 },
    { level: 16, requiredPower: 60000, bonus: 1000 },
    { level: 17, requiredPower: 70000, bonus: 2000 },
    { level: 18, requiredPower: 80000, bonus: 4000 },
    { level: 19, requiredPower: 90000, bonus: 6000 },
    { level: 20, requiredPower: 100000, bonus: 8000 },
    { level: 21, requiredPower: 125000, bonus: 10000 },
    { level: 22, requiredPower: 150000, bonus: 20000 },
    { level: 23, requiredPower: 200000, bonus: 40000 },
    { level: 24, requiredPower: 250000, bonus: 60000 },
    { level: 25, requiredPower: 300000, bonus: 80000 },
    { level: 26, requiredPower: 400000, bonus: 100000 },
    { level: 27, requiredPower: 500000, bonus: 200000 },
    { level: 28, requiredPower: 600000, bonus: 400000 },
    { level: 29, requiredPower: 750000, bonus: 600000 },
    { level: 30, requiredPower: 1000000, bonus: 800000 },
    { level: 31, requiredPower: 2000000, bonus: 1000000 },
    { level: 32, requiredPower: 4000000, bonus: 2000000 },
    { level: 33, requiredPower: 6000000, bonus: 4000000 },
    { level: 34, requiredPower: 8000000, bonus: 6000000 },
    { level: 35, requiredPower: 10000000, bonus: 8000000 },
    { level: 36, requiredPower: 20000000, bonus: 10000000 },
    { level: 37, requiredPower: 40000000, bonus: 20000000 },
    { level: 38, requiredPower: 60000000, bonus: 40000000 },
    { level: 39, requiredPower: 80000000, bonus: 60000000 },
    { level: 40, requiredPower: 100000000, bonus: 80000000 }
];
        // 道具配置
        const itemEffects = {
    primaryGem: { name: '初级宝石', effect: 10.00, description: '增加装备属性+1000%' },
    advancedGem: { name: '高级宝石', effect: 50.00, description: '增加装备属性+5000%' },
    superiorGem: { name: '极品宝石', effect: 500.00, description: '增加装备属性+50000%' },
    divineGem: { name: '神级宝石', effect: 5000.00, description: '增加装备属性+500000%' },
    vipPower: { name: 'VIP能力值', effect: 1, description: '提升VIP等级的特殊道具' },
    refineStone: { name: '洗炼石', effect: 0, description: '用于重铸副本装备的成长属性' }, // 新增洗炼石
    rose: { name: '玫瑰花', effect: 1, description: '用于升级伴侣等级' },
    companionKey: { name: '伴侣钥匙', effect: 0, description: '用于开启伴侣宝箱' }, 
    rebornDan: { name: '洗髓丹', effect: 0, description: '用于洗练伴侣天赋' },
    baitCount: { name: '鱼饵', effect: 0, description: '用于钓鱼消耗品' },
    rootDetector: { name: '灵根检测器', effect: 0, description: '用于开启灵根宝箱' },
    bloodlineDetector: { name: '血脉检测剂', effect: 0, description: '用于开启血脉宝箱' },
    advanceStone: { name: '进阶神石', effect: 0, description: '用于进阶神器' },  
   primaryGemq: { name: '宝藏金币', effect: 0, description: '用于兑换藏宝图商店物品' },
   zongmen: { name: '宗门令牌', effect: 0, description: '创建宗门消耗的必须品' },  
   roseq: { name: '香囊', effect: 0, description: '赠送宗门成员增加忠诚度' }, 
  yuzhou1: { name: '星尘发票', effect: 0, description: '兑换星尘专用' }, 
   yuzhou2: { name: '暗物质发票', effect: 0, description: '兑换暗物质专用' }, 
   yuzhou3: { name: '宇宙晶体发票', effect: 0, description: '兑换宇宙晶体专用' }, 
   yuzhou4: { name: '神器碎片发票', effect: 0, description: '兑换神器碎片专用' },
  banlv1: { name: '普通伴侣灵魂', effect: 0, description: '普通伴侣进阶必需品' },
 banlv2: { name: '稀有伴侣灵魂', effect: 0, description: '稀有伴侣进阶必需品' },
 banlv3: { name: '史诗伴侣灵魂', effect: 0, description: '史诗伴侣进阶必需品' },
 banlv4: { name: '卓越伴侣灵魂', effect: 0, description: '卓越伴侣进阶必需品' },
banlv5: { name: '完美伴侣灵魂', effect: 0, description: '完美伴侣进阶必需品' },
banlv6: { name: '神赐伴侣灵魂', effect: 0, description: '神赐伴侣进阶必需品' },
banlv7: { name: '天使伴侣灵魂', effect: 0, description: '天使伴侣进阶必需品' },
banlv8: { name: '恶魔伴侣灵魂', effect: 0, description: '恶魔伴侣进阶必需品' },
banlv9: { name: '精灵伴侣灵魂', effect: 0, description: '精灵伴侣进阶必需品' },
zhiye1: { name: '职业转换书', effect: 0, description: '用于更换职业' },
chiban1: { name: '黑龙王翅膀', effect: 0, description: '用于强化翅膀' },
zuoqi1: { name: '远古圣兽精魄', effect: 0, description: '用于强化坐骑' },
fuben1: { name: '副本令牌', effect: 0, description: '用于挑战副本' },
shenshou1: { name: '神兽蛋', effect: 0, description: '用于强化轮回神兽' },
fuwen1: { name: '秘法符文', effect: 0, description: '用于强化符文' },
fuben2: { name: '秘境钥匙', effect: 0, description: '用于开启秘境' },
danyao1: { name: '蕴灵筑基丹', effect: 0, description: '用于提升微量修仙经验' },
danyao2: { name: '凝元固窍丹', effect: 0, description: '用于提升少量修仙经验' },
danyao3: { name: '渡厄金还丹', effect: 0, description: '用于提升中量修仙经验' },
danyao4: { name: '九转轮回丹', effect: 0, description: '用于提升大量修仙经验' },
danyao5: { name: '混元道果丹', effect: 0, description: '用于提升极量修仙经验' },
fubeng1: { name: '深渊令牌', effect: 0, description: '用于挑战无限深渊' },
seed_herb1: { name: '蕴灵草药种子', effect: 0, description: '洞府灵田可种植，收获蕴灵筑基丹' },
seed_herb2: { name: '凝元草药种子', effect: 0, description: '洞府灵田可种植，收获凝元固窍丹' },
seed_herb3: { name: '渡厄草药种子', effect: 0, description: '洞府灵田可种植，收获渡厄金还丹' },
seed_herb4: { name: '九转草药种子', effect: 0, description: '洞府灵田可种植，收获九转轮回丹' },
seed_herb5: { name: '混元草药种子', effect: 0, description: '洞府灵田可种植，收获混元道果丹' }
};

        // 收藏物配置
        const collectionEffects = {
             lightSpeedHand: { name: '光速幻影手', effect: 0.01, description: '增加全部装备属性 +1%' },
    empHand: { name: '电磁脉冲快手', effect: 0.05, description: '增加全部装备属性 +5%' },
    godlyHand: { name: '神级手速怪', effect: 0.30, description: '增加全部装备属性 +30%' },
    quickHand: { name: '秒点快手侠', effect: 2.00, description: '增加全部装备属性 +200%' },
    shadowHand: { name: '无影闪击手', effect: 5.00, description: '增加全部装备属性 +500%' },
    quantumHand: { name: '量子跃迁快手', effect: 10.00, description: '增加全部装备属性 +1000%' },
    lightningHand: { name: '闪电连点器之手', effect: 100.00, description: '增加全部装备属性 +10000%' },
    divineHand: { name: '天神之手', effect: 5000.00, description: '增加全部装备属性 +500000%' }
};

        // 材料宝箱掉落概率配置
        const materialChestProbabilities = [
     { type: 'lightSpeedHand', prob: 0.71188 },
    { type: 'empHand', prob: 0.2305 },
    { type: 'godlyHand', prob: 0.0324 },
    { type: 'quickHand', prob: 0.01 },
    { type: 'shadowHand', prob: 0.005 },
    { type: 'quantumHand', prob: 0.0005 },
    { type: 'lightningHand', prob: 0.00005 },
    { type: 'divineHand', prob: 0.00001 },
    { type: 'primaryGem', prob: 0.005 },
    { type: 'advancedGem', prob: 0.0005 },
    { type: 'superiorGem', prob: 0.00005 },
    { type: 'divineGem', prob: 0.00001 },
    { type: 'vipPower', prob: 0.001 },
    { type: 'refineStone', prob: 0.001 }, 
    { type: 'companionKey', prob: 0.001 }, 
     { type: 'rebornDan', prob: 0.001 }, 
    
];
    const techniqueChestDrops = [
    // 第一档 22%~21.8%
    { id: "immortalAsuraBody", prob: 0.21 },          // 不灭修罗体 21%
    { id: "godSlayingBurningHeavenArt", prob: 0.21 }, // 弑神焚天诀 21%
    { id: "nineHeavensThunderboltTruth", prob: 0.23299 }, // 九霄雷殛真解 20.65%
    
    // 第二档 5%
    { id: "eightDesolationsWarDemonBody", prob: 0.05 },  // 八荒战魔躯 5%
    { id: "burialHeavenBladePrisonManual", prob: 0.05 }, // 葬天刀狱谱 5%
    { id: "nineCalamitiesWorldDestroyingPalm", prob: 0.05 }, // 九劫灭世掌 5%
    { id: "netherBloodSeaDiagram", prob: 0.05 },        // 幽冥血海图录 5%
    
    // 第三档 2%
    { id: "nineRevolutionsProfoundBody", prob: 0.02 },  // 九转玄黄身 2%
    { id: "tenDirectionsAnnihilationSpearCodex", prob: 0.02 }, // 十方俱灭枪典 2%
    { id: "chaosCreationForce", prob: 0.02 },           // 混沌开天劲 2%
    { id: "riverStarsHangingSecretScroll", prob: 0.02 }, // 星河倒悬秘卷 2%
    
    // 第四档 1%
    { id: "loneDestinyBone", prob: 0.01 },              // 天煞孤星骨 1%
    { id: "thousandCalamitiesVoidArrowArt", prob: 0.01 }, // 千劫裂空箭术 1%
    { id: "dragonElephantShatteringVoidArt", prob: 0.01 }, // 龙象碎穹功 1%
    { id: "eightDesolationsFireDragonRecord", prob: 0.01 }, // 八荒火龙焚世录 1%
    
    // 第五档 0.5%
    { id: "bloodPrisonMadGodArmor", prob: 0.0051 },      // 血狱狂神铠 0.5%
    { id: "ancientAnnihilationHalberdArt", prob: 0.0051 }, // 万古寂灭戟法 0.5%
    { id: "greatSunFallingStarFist", prob: 0.0051 },     // 大日陨星拳 0.5%
    { id: "iceSealThreeThousandRealmArt", prob: 0.0051 }, // 冰封三千界心法 0.5%
    
    // 第六档 0.5%~0.001%
    { id: "greatVoidReturnToVoidCodex", prob: 0.005 },  // 太虚归墟典 0.5%
    { id: "samsaraCalamityAnnihilationSutra", prob: 0.001 }, // 轮回劫灭经 0.1%
    { id: "yinYangReversalArt", prob: 0.0005 },         // 阴阳逆命术 0.05%
    { id: "zhouHeavenStarsFallingWay", prob: 0.0001 },  // 周天星陨道 0.01%
    { id: "ancientVoidRecord", prob: 0.00001 }          // 万古空冥录 0.001%
];
 // 奥秘系统配置
const mysteryConfig = [
    { stage: 1, name: "初级秘法师", levelCost: 100, totalBonus: 1 },
    { stage: 2, name: "奥法转运者", levelCost: 10000, totalBonus: 2 },
    { stage: 3, name: "奥术掌握者", levelCost: 100000, totalBonus: 4 },
    { stage: 4, name: "秘能大师", levelCost: 500000, totalBonus: 6 },
    { stage: 5, name: "奥术之灵", levelCost: 1000000, totalBonus: 8 },
    { stage: 6, name: "神圣秘灵师", levelCost: 5000000, totalBonus: 10 },
    { stage: 7, name: "神之奥术掌握者", levelCost: 10000000, totalBonus: 20 },
    { stage: 8, name: "先知大师", levelCost: 50000000, totalBonus: 40 },
    { stage: 9, name: "恒星秘法师", levelCost: 100000000, totalBonus: 60 },
    { stage: 10, name: "暗能量宗师", levelCost: 200000000, totalBonus: 80 },
    { stage: 11, name: "星光秘耀使者", levelCost: 300000000, totalBonus: 100 },
    { stage: 12, name: "混沌秘能主宰", levelCost: 400000000, totalBonus: 200 },
    { stage: 13, name: "维度漫游大师", levelCost: 500000000, totalBonus: 400 },
    { stage: 14, name: "终焉秘法先知", levelCost: 600000000, totalBonus: 600 },
    { stage: 15, name: "时律操纵者", levelCost: 800000000, totalBonus: 800 },
    { stage: 16, name: "创世星芒导师", levelCost: 1000000000, totalBonus: 1000 },
    { stage: 17, name: "虚无之光缔造者", levelCost: 2000000000, totalBonus: 2000 },
    { stage: 18, name: "神谕秘能神", levelCost: 4000000000, totalBonus: 4000 },
    { stage: 19, name: "永恒奥术神", levelCost: 6000000000, totalBonus: 6000 },
    { stage: 20, name: "超维秘耀神", levelCost: 8000000000, totalBonus: 8000 },
    { stage: 21, name: "奥秘本身", levelCost: 10000000000, totalBonus: 10000 },
    { stage: 22, name: "万物创造者", levelCost: 25000000000, totalBonus: 20000 },
    { stage: 23, name: "奥秘创造者", levelCost: 50000000000, totalBonus: 60000 },
    { stage: 24, name: "创世神", levelCost: 75000000000, totalBonus: 80000 },
    { stage: 25, name: "位面之子", levelCost: 100000000000, totalBonus: 100000 },
    { stage: 26, name: "版本之子", levelCost: 500000000000, totalBonus: 200000 },
    { stage: 27, name: "维度主宰", levelCost: 1000000000000, totalBonus: 400000 },
    { stage: 28, name: "时空旅者", levelCost: 5000000000000, totalBonus: 600000 },
    { stage: 29, name: "次元神", levelCost: 10000000000000, totalBonus: 800000 },
    { stage: 30, name: "超越者", levelCost: 50000000000000, totalBonus: 1000000 }
];
        // 装备配置
      const equipmentTypes = {
            common: { name: '普通', gps: 1, click: 0, prob: 0.6, growthRate: 0.025 },
            rare: { name: '稀有', gps: 3, click: 3, prob: 0.15, growthRate: 0.05 },
            epic: { name: '史诗', gps: 15, click: 15, prob: 0.1, growthRate: 0.10 },
            legendary: { name: '传说', gps: 20, click: 20, prob: 0.05, growthRate: 0.15 },
            ancient: { name: '远古', gps: 50, click: 50, prob: 0.03, growthRate: 0.20 },
            divine: { name: '神圣', gps: 100, click: 100, prob: 0.02, growthRate: 0.30 },
            arcane: { name: '奥术', gps: 300, click: 300, prob: 0.015, growthRate: 0.35 },
            celestial: { name: '天空', gps: 1000, click: 1000, prob: 0.01, growthRate: 0.40 },
            infernal: { name: '地狱', gps: 5000, click: 5000, prob: 0.005, growthRate: 0.50 },
            astral: { name: '星界', gps: 10000, click: 10000, prob: 0.003, growthRate: 0.60 },
            primeval: { name: '原初', gps: 50000, click: 50000, prob: 0.002, growthRate: 0.70 },
            transcendental: { name: '超凡', gps: 100000, click: 100000, prob: 0.001, growthRate: 0.80 },
            quantum: { name: '量子', gps: 500000, click: 500000, prob: 0.0005, growthRate: 0.90 },
            ultimate: { name: '究极', gps: 1000000, click: 1000000, prob: 0.0134, growthRate: 1.00 },
            chaos: { name: '混沌', gps: 10000000, click: 10000000, prob: 0.01, growthRate: 1.20 },
            eternal: { name: '永恒', gps: 20000000, click: 20000000, prob: 0.01, growthRate: 1.50 },
           void: { name: '虚无', gps: 50000000, click: 50000000, prob: 0.001, growthRate: 2.00 },
          genesis: { name: '创世', gps: 1e9, click: 1e9, prob: 0.01, growthRate: 2.50 },
          divineRealm: { name: '神域', gps: 2e9, click: 2e9, prob: 0.01, growthRate: 2.70 },
          apocalypse: { name: '终焉', gps: 5e9, click: 5e9, prob: 0.01, growthRate: 3.00 },
         yeyu1: { name: '星辰', gps: 1e11, click: 1e11, prob: 0.0001, growthRate: 3.20 },
         yeyu2: { name: '起源', gps: 2e11, click: 2e11, prob: 0.00005, growthRate: 3.50 },
         yeyu3: { name: '时光', gps: 5e11, click: 5e11, prob: 0.00001, growthRate: 4.00 },
         yeyu4: { name: '造物', gps: 1e13, click: 1e13, prob: 0.000005, growthRate: 4.20 },
         yeyu5: { name: '银河', gps: 2e13, click: 2e13, prob: 0.000001, growthRate: 4.50 },
         yeyu6: { name: '天界', gps: 5e13, click: 5e13, prob: 0.0000001, growthRate: 5.00 },
         yeyu7: { name: '星云', gps: 1e15, click: 1e15, prob: 0.0000001, growthRate: 5.50 },
         yeyu8: { name: '星河', gps: 2e15, click: 2e15, prob: 0.0000001, growthRate: 6.00 },
         yeyu9: { name: '纪元', gps: 5e15, click: 5e15, prob: 0.0000001, growthRate: 6.50 }, 
         yeyu10: { name: '鸿蒙', gps: 1e17, click: 1e17, prob: 0.0000001, growthRate: 7.00 },
         yeyu11: { name: '星穹', gps: 2e17, click: 2e17, prob: 0.0000001, growthRate: 7.50 },
         yeyu12: { name: '亘古', gps: 5e17, click: 5e17, prob: 0.0000001, growthRate: 8.00 },
         yeyu13: { name: '万象', gps: 1e19, click: 1e19, prob: 0.0000001, growthRate: 8.50 },
         yeyu14: { name: '太虚', gps: 2e19, click: 2e19, prob: 0.0000001, growthRate: 9.00 },
         yeyu15: { name: '九垓', gps: 5e19, click: 5e19, prob: 0.0000001, growthRate: 9.50 },
         yeyu16: { name: '穿梭', gps: 1e21, click: 1e21, prob: 0.0000001, growthRate: 10.00 },
         yeyu17: { name: '恒古', gps: 2e21, click: 2e21, prob: 0.0000001, growthRate: 10.50 },
         yeyu18: { name: '虚空', gps: 5e21, click: 5e21, prob: 0.0000001, growthRate: 11.00 },
         yeyu19: { name: '蔚来', gps: 1e23, click: 1e23, prob: 0.0000001, growthRate: 11.50 },
         yeyu20: { name: '神罚', gps: 2e23, click: 2e23, prob: 0.0000001, growthRate: 12.00 },
         yeyu21: { name: '时空', gps: 5e23, click: 5e23, prob: 0.0000001, growthRate: 12.50 },
         yeyu22: { name: '未来', gps: 1e25, click: 1e26, prob: 0.0000001, growthRate: 13.00 },
         yeyu23: { name: '从前', gps: 2e25, click: 2e26, prob: 0.0000001, growthRate: 13.50 },
         yeyu24: { name: '星澜', gps: 5e25, click: 5e26, prob: 0.0000001, growthRate: 14.00 }
        };
        // 副本装备配置
        const dungeonEquipmentTypes = {
            common: { name: '废品', growthRange: [0.00001, 0.0005] },
            rare: { name: '倚天剑', growthRange: [0.001, 0.10] },
            epic: { name: '青龙枪', growthRange: [0.001, 0.15] },
            legendary: { name: '白虎斧', growthRange: [0.001, 0.20] },
            ancient: { name: '朱雀弓', growthRange: [0.001, 0.25] },
            divine: { name: '玄武盾', growthRange: [0.001, 0.30] },
            arcane: { name: '麒麟杖', growthRange: [0.001, 0.35] },
            celestial: { name: '凤凰剑', growthRange: [0.001, 0.40] },
            infernal: { name: '饕餮刀', growthRange: [0.001, 0.45] },
            astral: { name: '穷奇戟', growthRange: [0.001, 0.50] },
            primeval: { name: '烛龙枪', growthRange: [0.001, 0.60] },
            transcendental: { name: '白泽剑', growthRange: [0.001, 0.70] },
            quantum: { name: '混沌斧', growthRange: [0.001, 0.80] },
            ultimate: { name: '太初刃', growthRange: [0.001, 0.90] },
            ultimate1: { name: '幻梦·洪荒刃☆', growthRange: [0.001, 1.00] },
            ultimate2: { name: '灵蕴神界剑★', growthRange: [0.001, 1.10] },
            ultimate3: { name: '蚀魂·地狱斧★★', growthRange: [0.001, 1.20] },
            ultimate4: { name: '蚀魂·暗夜枪★★★', growthRange: [0.001, 1.30] },
            ultimate5: { name: '遗梦·异界弓★★★★', growthRange: [0.001, 1.40] },
            ultimate6: { name: '幻月·现代盾★★★★★', growthRange: [0.001, 1.50] },
            ultimate7: { name: '寒星·风神杖★★★★★★', growthRange: [0.001, 1.60] },
            ultimate8: { name: '炎凤·雷霆戟★★★★★★★', growthRange: [0.001, 1.70] },
            ultimate9: { name: '雾霭·星辰刃★★★★★★★★', growthRange: [0.001, 1.80] },
            ultimate10: { name: '月尘·虚空斧★★★★★★★★', growthRange: [0.001, 1.90] },
            ultimate11: { name: '焚天·混沌枪○', growthRange: [0.001, 2.00] },
            ultimate12: { name: '焚天·永恒剑●', growthRange: [0.001, 2.10] },
            ultimate13: { name: '混沌·幽冥弓●●', growthRange: [0.001, 2.20] },
            ultimate14: { name: '星辰·天启盾●●●', growthRange: [0.001, 2.30] },
            ultimate15: { name: '太古·破晓杖●●●●', growthRange: [0.001, 2.40] },
            ultimate16: { name: '月尘·末日戟●●●●●', growthRange: [0.001, 2.50] },
            ultimate17: { name: '月尘·苍穹刃●●●●●●', growthRange: [0.001, 2.60] },
            ultimate18: { name: '流萤·幻影斧●●●●●●●', growthRange: [0.001, 2.70] },
            ultimate19: { name: '皓宇·天罚枪●●●●●●●●', growthRange: [0.001, 2.80] },
            ultimate20: { name: '灵幻·神罚剑●●●●●●●●●', growthRange: [0.001, 2.90] },
            ultimate21: { name: '炽阳·魔界弓◇', growthRange: [0.001, 3.00] },
            ultimate22: { name: '琥珀·圣光盾◆', growthRange: [0.001, 3.10] },
            ultimate23: { name: '紫霄·暗影杖◆◆', growthRange: [0.001, 3.20] },
            ultimate24: { name: '荒古·龙魂戟◆◆◆', growthRange: [0.001, 3.30] },
            ultimate25: { name: '破晓·天穹刃◆◆◆◆', growthRange: [0.001, 3.40] },
            ultimate26: { name: '星澜·炎狱斧◆◆◆◆◆', growthRange: [0.001, 3.50] },
            ultimate27: { name: '龙炎·神枪戟◆◆◆◆◆◆', growthRange: [0.001, 3.60] },
            ultimate28: { name: '鸿蒙·冥界剑◆◆◆◆◆◆◆', growthRange: [0.001, 3.70] },
            ultimate29: { name: '鸿蒙·天界弓◆◆◆◆◆◆◆◆', growthRange: [0.001, 3.80] },
            ultimate30: { name: '荒古·地狱盾◆◆◆◆◆◆◆◆◆', growthRange: [0.001, 3.90] },
            ultimate31: { name: '荒炎·太古杖□', growthRange: [0.001, 4.00] },
            ultimate32: { name: '荒炎·异界戟■', growthRange: [0.001, 4.10] },
            ultimate33: { name: '荒炎·现代刃■■', growthRange: [0.001, 4.20] },
            ultimate34: { name: '凤羽·风神斧■■■', growthRange: [0.001, 4.30] },
            ultimate35: { name: '荒炎·雷霆枪■■■■', growthRange: [0.001, 4.40] },
            ultimate36: { name: '荒炎·星辰剑■■■■■', growthRange: [0.001, 4.50] },
            ultimate37: { name: '虚空·玄冰弓■■■■■■', growthRange: [0.001, 4.60] },
            ultimate38: { name: '虚空·混沌盾■■■■■■■', growthRange: [0.001, 4.70] },
            ultimate39: { name: '虚空·永恒杖■■■■■■■■', growthRange: [0.001, 4.80] },
            ultimate40: { name: '虚空·幽冥戟■■■■■■■■■', growthRange: [0.001, 4.90] },
            ultimate41: { name: '天启·穿越刃△', growthRange: [0.001, 5.00] },
            ultimate42: { name: '天启·破晓斧▲', growthRange: [0.001, 5.10] },
            ultimate43: { name: '时空·末日枪▲▲', growthRange: [0.001, 5.20] },
            ultimate44: { name: '九幽·苍穹剑▲▲▲', growthRange: [0.001, 5.30] },
            ultimate45: { name: '幻影·雷电弓▲▲▲▲', growthRange: [0.001, 5.40] },
            ultimate46: { name: '天罚·雷霆盾▲▲▲▲▲', growthRange: [0.001, 5.50] },
            ultimate47: { name: '神罚·雷霆杖▲▲▲▲▲▲', growthRange: [0.001, 5.60] },
            ultimate48: { name: '魔界·邪战戟▲▲▲▲▲▲▲', growthRange: [0.001, 5.70] },
            ultimate49: { name: '圣光·灭世剑▲▲▲▲▲▲▲▲', growthRange: [0.001, 5.80] },
            ultimate50: { name: '宇宙·神王剑▲▲▲▲▲▲▲▲▲', growthRange: [0.001, 5.90] }      
        };

        // 宝箱概率配置
        const chestProbabilities = {
    1: [ { rarity: 'common', prob: 0.8 }, { rarity: 'rare', prob: 0.2 } ],
    2: [ { rarity: 'rare', prob: 0.8 }, { rarity: 'epic', prob: 0.14 }, { rarity: 'legendary', prob: 0.05 }, { rarity: 'ancient', prob: 0.01 } ],
    3: [ { rarity: 'ancient', prob: 0.8 }, { rarity: 'divine', prob: 0.14 }, { rarity: 'arcane', prob: 0.05 }, { rarity: 'celestial', prob: 0.01 } ],
    4: [ { rarity: 'celestial', prob: 0.8 }, { rarity: 'infernal', prob: 0.14 }, { rarity: 'astral', prob: 0.05 }, { rarity: 'primeval', prob: 0.01 } ],
    5: [ { rarity: 'primeval', prob: 0.8 }, { rarity: 'transcendental', prob: 0.14 }, { rarity: 'quantum', prob: 0.05 }, { rarity: 'ultimate', prob: 0.01 } ],
    6: [ { rarity: 'ultimate', prob: 0.8 }, { rarity: 'chaos', prob: 0.14 }, { rarity: 'eternal', prob: 0.05 }, { rarity: 'void', prob: 0.01 } ],
    7: [ { rarity: 'void', prob: 0.8 }, { rarity: 'genesis', prob: 0.14 }, { rarity: 'divineRealm', prob: 0.05 }, { rarity: 'apocalypse', prob: 0.01 } ],
    8: [ { rarity: 'apocalypse', prob: 0.8 }, { rarity: 'yeyu1', prob: 0.14 }, { rarity: 'yeyu2', prob: 0.05 }, { rarity: 'yeyu3', prob: 0.01 } ],
    9: [ { rarity: 'yeyu3', prob: 0.8 }, { rarity: 'yeyu4', prob: 0.14 }, { rarity: 'yeyu5', prob: 0.05 }, { rarity: 'yeyu6', prob: 0.01 } ],
    10: [ { rarity: 'yeyu6', prob: 0.8 }, { rarity: 'yeyu7', prob: 0.14 }, { rarity: 'yeyu8', prob: 0.05 }, { rarity: 'yeyu9', prob: 0.01 } ],
    11: [ { rarity: 'yeyu9', prob: 0.8 }, { rarity: 'yeyu10', prob: 0.14 }, { rarity: 'yeyu11', prob: 0.05 }, { rarity: 'yeyu12', prob: 0.01 } ],
    12: [ { rarity: 'yeyu12', prob: 0.8 }, { rarity: 'yeyu13', prob: 0.14 }, { rarity: 'yeyu14', prob: 0.05 }, { rarity: 'yeyu15', prob: 0.01 } ],
    13: [ { rarity: 'yeyu15', prob: 0.8 }, { rarity: 'yeyu16', prob: 0.14 }, { rarity: 'yeyu17', prob: 0.05 }, { rarity: 'yeyu18', prob: 0.01 } ],
    14: [ { rarity: 'yeyu18', prob: 0.8 }, { rarity: 'yeyu19', prob: 0.14 }, { rarity: 'yeyu20', prob: 0.05 }, { rarity: 'yeyu21', prob: 0.01 } ],
    15: [ { rarity: 'yeyu21', prob: 0.8 }, { rarity: 'yeyu22', prob: 0.14 }, { rarity: 'yeyu23', prob: 0.05 }, { rarity: 'yeyu24', prob: 0.01 } ]
};

        // 宠物配置
        const petConfig = {
            thunderKirin: { name: '苍雷麒麟', currency: 'gold', multiplier: 0.10 }, 
            chaosTaotie: { name: '混沌饕餮', currency: 'diamond', multiplier: 0.30 }, 
            netherQiongqi: { name: '九幽穷奇', currency: 'titanium', multiplier: 0.90 }, 
            abyssKun: { name: '霸渊巨鲲', currency: 'starstone', multiplier: 2.70 }, 
            primordialZhuLong: { name: '太初烛龙', currency: 'cosmicstone', multiplier: 8.10 }, 
        wanJunSuanNi: { name: '万钧狻猊', currency: 'superstone', multiplier: 24.30 }, 
          yanYuBiAn: { name: '炎狱狴犴', currency: 'otherworldstone', multiplier: 72.90 }, 
          yuyu1: { name: '赤霄夔龙', currency: 'xingjiestone', multiplier: 218.70 }, 
          yuyu2: { name: '震岳白泽', currency: 'hundunstone', multiplier: 656.10 }, 
         yuyu3: { name: '焚天蛊雕', currency: 'lingtone', multiplier: 1968.30 }, 
         yuyu4: { name: '血煞梼杌', currency: 'huangtone', multiplier: 5904.90 }, 
        yuyu5: { name: '玄渊白犼', currency: 'mingtone', multiplier: 17714.70 },
         yuyu6: { name: '灾祸蜚牛', currency: 'xutong', multiplier: 53144.10 }, 
         yuyu7: { name: '寂灭罗睺', currency: 'shitone', multiplier: 159432.30 }, 
        yuyu8: { name: '永劫蚩尤', currency: 'weitone', multiplier: 478296.90 } 
     };

        // 魂环配置
        const soulRingTypes = {
            year1: { name: '一年魂环', baseMult: 0.02, costBase: 1000 },
            year10: { name: '十年魂环', baseMult: 0.05, costBase: 1000 },
            year100: { name: '百年魂环', baseMult: 0.08, costBase: 1000 },
            year1000: { name: '千年魂环', baseMult: 0.10, costBase: 1000 },
            year10000: { name: '万年魂环', baseMult: 0.12, costBase: 1000 },
            year100000: { name: '十万年魂环', baseMult: 0.15, costBase: 1000 },
            year1000000: { name: '百万年魂环', baseMult: 0.18, costBase: 1000 },
            year10000000: { name: '千万年魂环', baseMult: 0.20, costBase: 1000 },
            year100000000: { name: '亿年魂环', baseMult: 0.25, costBase: 1000 },
            year2: { name: '太古·混沌亿年魂环', baseMult: 0.30, costBase: 1000 },
            year3: { name: '鸿蒙·始源亿年魂环', baseMult: 0.35, costBase: 1000 },
            year4: { name: '亘古·时空亿年魂环', baseMult: 0.40, costBase: 1000 },
            year5: { name: '九幽·冥渊亿年魂环', baseMult: 0.45, costBase: 1000 },
            year6: { name: '皓宇·星辰亿年魂环', baseMult: 0.50, costBase: 1000 },
            year7: { name: '炎狱·焚天亿年魂环', baseMult: 0.55, costBase: 1000 },
            year8: { name: '霜烬·极寒亿年魂环', baseMult: 0.60, costBase: 1000 },
            year9: { name: '灵幻·万象亿年魂环', baseMult: 0.65, costBase: 1000 },
            year11: { name: '炽阳·耀世亿年魂环', baseMult: 0.70, costBase: 1000 },
            year12: { name: '暗蚀·灭世亿年魂环', baseMult: 0.75, costBase: 1000 },
            year13: { name: '圣辉·救赎亿年魂环', baseMult: 0.80, costBase: 1000 },
            year14: { name: '紫霄·雷罚亿年魂环', baseMult: 0.85, costBase: 1000 },
            year15: { name: '青木·生机亿年魂环', baseMult: 0.90, costBase: 1000 },
            year16: { name: '星澜·幻梦亿年魂环', baseMult: 0.95, costBase: 1000 },
            year17: { name: '渊海·无尽亿年魂环', baseMult: 1.00, costBase: 1000 },
            year18: { name: '荒古·遗世亿年魂环', baseMult: 1.10, costBase: 1000 },
            year19: { name: '净世·光明亿年魂环', baseMult: 1.20, costBase: 1000 },
            year20: { name: '蚀灵·诅咒亿年魂环', baseMult: 1.30, costBase: 1000 },
            year21: { name: '逆乱·时空亿年魂环', baseMult: 1.40, costBase: 1000 },
            year22: { name: '龙渊·霸者亿年魂环', baseMult: 1.50, costBase: 1000 },
            year23: { name: '凤羽·炎舞亿年魂环', baseMult: 1.60, costBase: 1000 },
            year24: { name: '星辰·命数亿年魂环', baseMult: 1.70, costBase: 1000 },
            year25: { name: '荒炎·破灭亿年魂环', baseMult: 1.80, costBase: 1000 },
            year26: { name: '玄冰·永冻亿年魂环', baseMult: 1.90, costBase: 1000 },
            year27: { name: '灵犀·心眼亿年魂环', baseMult: 2.00, costBase: 1000 },
            year28: { name: '圣谕·裁决亿年魂环', baseMult: 2.10, costBase: 1000 },
            year29: { name: '九幽·黄泉亿年魂环', baseMult: 2.20, costBase: 1000 },
            year30: { name: '灵蕴·造化亿年魂环', baseMult: 2.30, costBase: 1000 },
            year31: { name: '混沌·元始亿年魂环', baseMult: 2.40, costBase: 1000 },
            year32: { name: '苍穹·御天亿年魂环', baseMult: 2.50, costBase: 1000 },
            year33: { name: '龙炎·焚天亿年魂环', baseMult: 2.60, costBase: 1000 }, 
            year34: { name: '血狱·魔神亿年魂环', baseMult: 2.70, costBase: 1000 },  
            year35: { name: '赤霄·苍穹亿年魂环', baseMult: 2.80, costBase: 1000 },
            year36: { name: '炎凤·涅槃亿年魂环', baseMult: 2.90, costBase: 1000 },
            year37: { name: '闫闫·黑丝亿年魂环', baseMult: 3.00, costBase: 1000 }
        };
           const TECHNIQUE_DISPLAY_ORDER = [
    // 生命类（防御型）
    "immortalAsuraBody",       // 不灭修罗体
    "eightDesolationsWarDemonBody", // 八荒战魔躯
    "nineRevolutionsProfoundBody",  // 九转玄黄身
    "loneDestinyBone",         // 天煞孤星骨
    "bloodPrisonMadGodArmor",  // 血狱狂神铠
    
    // 攻击类（输出型）
    "godSlayingBurningHeavenArt",  // 弑神焚天诀
    "burialHeavenBladePrisonManual", // 葬天刀狱谱
    "tenDirectionsAnnihilationSpearCodex", // 十方俱灭枪典
    "thousandCalamitiesVoidArrowArt", // 千劫裂空箭术
    "ancientAnnihilationHalberdArt", // 万古寂灭戟法
    
    // 暴击类
    "nineHeavensThunderboltTruth", // 九霄雷殛真解
    "netherBloodSeaDiagram",    // 幽冥血海图录
    "riverStarsHangingSecretScroll", // 星河倒悬秘卷
    "eightDesolationsFireDragonRecord", // 八荒火龙焚世录
    "iceSealThreeThousandRealmArt", // 冰封三千界心法
    
    // 爆伤类
    "nineCalamitiesWorldDestroyingPalm", // 九劫灭世掌
    "chaosCreationForce",      // 混沌开天劲
    "dragonElephantShatteringVoidArt", // 龙象碎穹功
    "greatSunFallingStarFist", // 大日陨星拳
    
    // 特殊效果类（连击/多段攻击）
    "greatVoidReturnToVoidCodex", // 太虚归墟典
    "samsaraCalamityAnnihilationSutra", // 轮回劫灭经
    "yinYangReversalArt",      // 阴阳逆命术
    "zhouHeavenStarsFallingWay", // 周天星陨道
    "ancientVoidRecord"        // 万古空冥录
];
   const DUNGEON_EQUIPMENT_ORDER = [
    'common',     
    'rare',       
    'epic',       
    'legendary',  
    'ancient',    
    'divine',    
    'arcane',     
    'celestial',  
    'infernal',  
    'astral',     
    'primeval',  
    'transcendental', 
    'quantum',   
    'ultimate',
    'ultimate1',     
    'ultimate2',   
    'ultimate3',       
    'ultimate4',   
    'ultimate5', 
    'ultimate6',    
    'ultimate7',     
    'ultimate8',   
    'ultimate9',       
    'ultimate10',   
    'ultimate11', 
    'ultimate12',     
    'ultimate13',     
    'ultimate14',   
    'ultimate15',       
    'ultimate16',   
    'ultimate17', 
    'ultimate18',   
    'ultimate19',     
    'ultimate20',   
    'ultimate21',       
    'ultimate22',   
    'ultimate23', 
    'ultimate24',   
    'ultimate25',   
    'ultimate26',       
    'ultimate27',   
    'ultimate28', 
    'ultimate29',     
    'ultimate30',     
    'ultimate31',   
    'ultimate32',       
    'ultimate33',   
    'ultimate34', 
    'ultimate35',     
    'ultimate36',     
    'ultimate37',   
    'ultimate38',       
    'ultimate39',   
    'ultimate40', 
    'ultimate41',    
    'ultimate42',     
    'ultimate43',   
    'ultimate44',       
    'ultimate45',   
    'ultimate46', 
    'ultimate47', 
    'ultimate48',   
    'ultimate49', 
    'ultimate50'
];

// 切换自动转生状态
function toggleAutoReincarnation() {
    player.autoReincarnation = !player.autoReincarnation;
    document.getElementById('autoReincarnationStatus').textContent = player.autoReincarnation ? '开启' : '关闭';
    logAction(`自动转生已${player.autoReincarnation ? '开启' : '关闭'}`, 'info');
}

// 检查自动转生条件
function checkAutoReincarnation() {
    if (!player.autoReincarnation) return;
    
    // 计算当前转生所需的总等级
    const requiredLevel = 10000 + player.reincarnationCount * 20;
    
    // 计算所有普通装备的总等级
    const totalCommonLevel = player.equipment
        .filter(eq => eq.rarity === 'common')
        .reduce((sum, eq) => sum + eq.level, 0);
    
    if (totalCommonLevel >= requiredLevel) {
        // 直接执行转生逻辑，不弹出确认对话框
        autoReincarnate();
    }
}

// 自动转生逻辑（不弹出确认对话框）
function autoReincarnate() {
    // 计算当前转生所需的总等级
    const requiredLevel = 10000 + player.reincarnationCount * 20;
    
    // 计算所有普通装备的总等级
    const totalCommonLevel = player.equipment
        .filter(eq => eq.rarity === 'common')
        .reduce((sum, eq) => sum + eq.level, 0);
    
    if (totalCommonLevel < requiredLevel) {
        logAction(`自动转生失败：普通装备总等级不足（需要${requiredLevel}级，当前${totalCommonLevel}级）`, "error");
        return;
    }

    let totalReincarnationCoin = 0;

    // 计算转生币奖励
    player.equipment.forEach(eq => {
        switch (eq.rarity) {
            case 'common':
                totalReincarnationCoin += eq.level * 0.0001;
                break;
            case 'rare':
                totalReincarnationCoin += eq.level * 0.0002;
                break;
            case 'epic':
                totalReincarnationCoin += eq.level * 0.001;
                break;
            case 'legendary':
                totalReincarnationCoin += eq.level * 0.003;
                break;
            case 'ancient':
                totalReincarnationCoin += eq.level * 0.005;
                break;
            case 'divine':
                totalReincarnationCoin += eq.level * 0.008;
                break;
            case 'arcane':
                totalReincarnationCoin += eq.level * 0.01;
                break;
            case 'celestial':
                totalReincarnationCoin += eq.level * 0.03;
                break;
            case 'infernal':
                totalReincarnationCoin += eq.level * 0.05;
                break;
            case 'astral':
                totalReincarnationCoin += eq.level * 0.08;
                break;
            case 'primeval':
                totalReincarnationCoin += eq.level * 0.1;
                break;
            case 'transcendental':
                totalReincarnationCoin += eq.level * 0.3;
                break;
            case 'quantum':
                totalReincarnationCoin += eq.level * 0.5;
                break;
            case 'ultimate':
                totalReincarnationCoin += eq.level * 1.0;
                break;
            case 'chaos':
                totalReincarnationCoin += eq.level * 3.0;
                break;
            case 'eternal':
                totalReincarnationCoin += eq.level * 5.0;
                break;
            case 'void':
                totalReincarnationCoin += eq.level * 10.0;
                break;
            case 'genesis':
                totalReincarnationCoin += eq.level * 20.0;
                break;
            case 'divineRealm':
                totalReincarnationCoin += eq.level * 30.0;
                break;
            case 'apocalypse':
                totalReincarnationCoin += eq.level * 40.0;
                break;
            case 'yeyu1':
                totalReincarnationCoin += eq.level * 50.0;
                break;
            case 'yeyu2':
                totalReincarnationCoin += eq.level * 60.0;
                break;
            case 'yeyu3':
                totalReincarnationCoin += eq.level * 70.0;
                break;
            case 'yeyu4':
                totalReincarnationCoin += eq.level * 80.0;
                break;
            case 'yeyu5':
                totalReincarnationCoin += eq.level * 90.0;
                break;
            case 'yeyu6':
                totalReincarnationCoin += eq.level * 100.0;
                break;
            case 'yeyu7':
                totalReincarnationCoin += eq.level * 200.0;
                break;
            case 'yeyu8':
                totalReincarnationCoin += eq.level * 300.0;
                break;
            case 'yeyu9':
                totalReincarnationCoin += eq.level * 400.0;
                break;
            case 'yeyu10':
                totalReincarnationCoin += eq.level * 500.0;
                break;
            case 'yeyu11':
                totalReincarnationCoin += eq.level * 600.0;
                break;
            case 'yeyu12':
                totalReincarnationCoin += eq.level * 700.0;
                break;
            case 'yeyu13':
                totalReincarnationCoin += eq.level * 800.0;
                break;
            case 'yeyu14':
                totalReincarnationCoin += eq.level * 900.0;
                break;
            case 'yeyu15':
                totalReincarnationCoin += eq.level * 1000.0;
                break;
            case 'yeyu16':
                totalReincarnationCoin += eq.level * 2000.0;
                break;
            case 'yeyu17':
                totalReincarnationCoin += eq.level * 3000.0;
                break;
            case 'yeyu18':
                totalReincarnationCoin += eq.level * 4000.0;
                break;
            case 'yeyu19':
                totalReincarnationCoin += eq.level * 5000.0;
                break;
            case 'yeyu20':
                totalReincarnationCoin += eq.level * 6000.0;
                break;
            case 'yeyu21':
                totalReincarnationCoin += eq.level * 7000.0;
                break;
            case 'yeyu22':
                totalReincarnationCoin += eq.level * 8000.0;
                break;
            case 'yeyu23':
                totalReincarnationCoin += eq.level * 9000.0;
                break;
            case 'yeyu24':
                totalReincarnationCoin += eq.level * 10000.0;
                break;
        }
    });

    // 重置装备等级
    player.equipment.forEach(eq => {
        eq.level = 1 + player.reincarnationStats.equipmentLevelBonus.level * 200; // 转生属性加成
        eq.gps = equipmentTypes[eq.rarity].gps * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
        eq.click = equipmentTypes[eq.rarity].click * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
    });

    // 清空货币
    player.gold = 0;
    player.diamond = 0;
    player.titanium = 0;
    player.starstone = 0;
    player.cosmicstone = 0;
    player.superstone = 0;
    player.otherworldstone = 0;
    player.xingjiestone = 0;
    player.hundunstone = 0;
    player.lingtone = 0;
    player.huangtone = 0;
    player.mingtone = 0;
    player.xutong = 0;
    player.shitone = 0;
    player.weitone = 0;   
 // 重置材料宝箱购买成本
            player.materialChestCost = 1;
            player.techniqueChestCost = 1;
    // 增加转生币
    player.reincarnationCoin += totalReincarnationCoin;
    player.reincarnationCount++;
 player.autoBuyTechniqueChest = true;
    // 修改属性点计算逻辑
    player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
    player.attributes.remainingPoints += 1; // 每次转生增加1点剩余属性点

    // 检查转生成就
    checkReincarnationAchievements();

    logAction(`自动转生成功！获得转生币: ${totalReincarnationCoin.toFixed(4)}`, 'success');
    updateDisplay();
    updateTechniqueBonuses(); // 转生后更新功法加成
    updatePlayerBattleStats(); // 更新战斗属性
}


        // 转生系统
        function reincarnate() {
   // 计算当前转生所需的总等级
    const requiredLevel = 10000 + player.reincarnationCount * 20;
    
    // 计算所有普通装备的总等级
    const totalCommonLevel = player.equipment
        .filter(eq => eq.rarity === 'common')
        .reduce((sum, eq) => sum + eq.level, 0);
    
    if (totalCommonLevel < requiredLevel) {
        logAction(`转生需要普通装备总等级达到${requiredLevel}级（当前${totalCommonLevel}级）！`, "error");
        return;
    }

    showCustomConfirm(`确定要转生吗？需要普通装备总等级≥${requiredLevel}级，所有装备等级将重置为1级，货币将被清空！`, (confirmed) => {
        if (confirmed) {
            let totalReincarnationCoin = 0;

            // 计算转生币奖励
            player.equipment.forEach(eq => {
                switch (eq.rarity) {
                    case 'common':
                        totalReincarnationCoin += eq.level * 0.0001;
                        break;
                    case 'rare':
                        totalReincarnationCoin += eq.level * 0.0002;
                        break;
                    case 'epic':
                        totalReincarnationCoin += eq.level * 0.001;
                        break;
                    case 'legendary':
                        totalReincarnationCoin += eq.level * 0.003;
                        break;
                    case 'ancient':
                        totalReincarnationCoin += eq.level * 0.005;
                        break;
                    case 'divine':
                        totalReincarnationCoin += eq.level * 0.008;
                        break;
                    case 'arcane':
                        totalReincarnationCoin += eq.level * 0.01;
                        break;
                    case 'celestial':
                        totalReincarnationCoin += eq.level * 0.03;
                        break;
                    case 'infernal':
                        totalReincarnationCoin += eq.level * 0.05;
                        break;
                    case 'astral':
                        totalReincarnationCoin += eq.level * 0.08;
                        break;
                    case 'primeval':
                        totalReincarnationCoin += eq.level * 0.1;
                        break;
                    case 'transcendental':
                        totalReincarnationCoin += eq.level * 0.3;
                        break;
                    case 'quantum':
                        totalReincarnationCoin += eq.level * 0.5;
                        break;
                    case 'ultimate':
                        totalReincarnationCoin += eq.level * 1.0;
                        break;
                    case 'chaos':
                        totalReincarnationCoin += eq.level * 3.0;
                        break;
                   case 'eternal':
                        totalReincarnationCoin += eq.level * 5.0;
                        break;
                   case 'void':
                        totalReincarnationCoin += eq.level * 10.0;
                        break;
                   case 'genesis':
                        totalReincarnationCoin += eq.level * 20.0;
                        break;
                   case 'divineRealm':
                        totalReincarnationCoin += eq.level * 30.0;
                        break;
                   case 'apocalypse':
                        totalReincarnationCoin += eq.level * 40.0;
                        break;
                    case 'yeyu1':
                        totalReincarnationCoin += eq.level * 50.0;
                        break;
                    case 'yeyu2':
                        totalReincarnationCoin += eq.level * 60.0;
                        break;
                     case 'yeyu3':
                        totalReincarnationCoin += eq.level * 70.0;
                        break;
                     case 'yeyu4':
                        totalReincarnationCoin += eq.level * 80.0;
                        break;
                     case 'yeyu5':
                        totalReincarnationCoin += eq.level * 90.0;
                        break;
                     case 'yeyu6':
                        totalReincarnationCoin += eq.level * 100.0;
                        break;
                    case 'yeyu7':
                        totalReincarnationCoin += eq.level * 200.0;
                        break;
                    case 'yeyu8':
                        totalReincarnationCoin += eq.level * 300.0;
                        break;
                     case 'yeyu9':
                        totalReincarnationCoin += eq.level * 400.0;
                        break;
                     case 'yeyu10':
                        totalReincarnationCoin += eq.level * 500.0;
                        break;
                     case 'yeyu11':
                        totalReincarnationCoin += eq.level * 600.0;
                        break;
                     case 'yeyu12':
                        totalReincarnationCoin += eq.level * 700.0;
                        break; 
                       case 'yeyu13':
                        totalReincarnationCoin += eq.level * 800.0;
                        break;
                    case 'yeyu14':
                        totalReincarnationCoin += eq.level * 900.0;
                        break;
                     case 'yeyu15':
                        totalReincarnationCoin += eq.level * 1000.0;
                        break;
                    case 'yeyu16':
                        totalReincarnationCoin += eq.level * 2000.0;
                        break;
                    case 'yeyu17':
                        totalReincarnationCoin += eq.level * 3000.0;
                        break;
                     case 'yeyu18':
                        totalReincarnationCoin += eq.level * 4000.0;
                        break;
                     case 'yeyu19':
                        totalReincarnationCoin += eq.level * 5000.0;
                        break;
                     case 'yeyu20':
                        totalReincarnationCoin += eq.level * 6000.0;
                        break;
                     case 'yeyu21':
                        totalReincarnationCoin += eq.level * 7000.0;
                        break; 
                       case 'yeyu22':
                        totalReincarnationCoin += eq.level * 8000.0;
                        break;
                    case 'yeyu23':
                        totalReincarnationCoin += eq.level * 9000.0;
                        break;
                     case 'yeyu24':
                        totalReincarnationCoin += eq.level * 10000.0;
                        break;
                }
            });

            // 重置装备等级
            player.equipment.forEach(eq => {
                eq.level = 1 + player.reincarnationStats.equipmentLevelBonus.level * 200; // 转生属性加成
                eq.gps = equipmentTypes[eq.rarity].gps * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
                eq.click = equipmentTypes[eq.rarity].click * (1 + player.reincarnationStats.gpsBonus.level); // 每级装备属性乘以100%
            });

            // 清空货币
            player.gold = 0;
            player.diamond = 0;
            player.titanium = 0;
            player.starstone = 0;
            player.cosmicstone = 0;
            player.superstone = 0;
            player.otherworldstone = 0;
            player.xingjiestone = 0;
            player.hundunstone = 0;
            player.lingtone = 0;
            player.huangtone = 0;
            player.mingtone = 0;
            player.xutong = 0;
            player.shitone = 0;
            player.weitone = 0;

            // 重置材料宝箱购买成本
            player.materialChestCost = 1;
            player.techniqueChestCost = 1;

            // 增加转生币
            player.reincarnationCoin += totalReincarnationCoin;
            player.reincarnationCount++;
            player.autoBuyTechniqueChest = true;
            // 修改属性点计算逻辑
            player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
            player.attributes.remainingPoints += 1; // 每次转生增加1点剩余属性点

            // 检查转生成就
            checkReincarnationAchievements();
       
            logAction(`转生成功！获得转生币: ${totalReincarnationCoin.toFixed(4)}`, 'success');
            updateDisplay();
            updateTechniqueBonuses(); // 转生后更新功法加成
            updatePlayerBattleStats(); // 更新战斗属性
        }
    });
}
        // 检查转生成就
        function checkReincarnationAchievements() {
            const achievements = [
                { count: 10, key: 'reincarnation_10' },
                { count: 100, key: 'reincarnation_100' },
                { count: 1000, key: 'reincarnation_1000' },
                { count: 10000, key: 'reincarnation_10000' }
            ];

            achievements.forEach(({ count, key }) => {
                if (player.reincarnationCount >= count && !player.achievements[key]) {
                    player.achievements[key] = true;
                    const reward = achievementRewards[key];
                    if (reward) {
                        player.gpsMultiplier += reward.gpsMultiplier;
                        logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                        updateAchievementsDisplay();
                    }
                }
            });
        }
      function showActivationCodeDialog() {
        if (player.battle.maxStage < 2) {
        alert("需要打怪模式达到第3层才能开启激活码兑换！");
        return;
    }
    document.getElementById("activationCodeDialog").style.display = "block";
    document.getElementById("activationCodeOverlay").style.display = "block";
    document.getElementById("activationCodeInput").focus();
}

function cancelActivationCode() {
    document.getElementById("activationCodeDialog").style.display = "none";
    document.getElementById("activationCodeOverlay").style.display = "none";
}

function confirmActivationCode() {
      if (player.battle.maxStage < 2) {
        alert("需要打怪模式达到第3层才能开启激活码兑换！");
        return;
    }
    const code = document.getElementById("activationCodeInput").value.trim().toUpperCase();
    const usedCodes = player.usedActivationCodes || [];
    
    if (!code) {
        logAction("请输入激活码", "error");
        return;
    }
    
    if (usedCodes.includes(code)) {
        logAction("该激活码已使用过", "error");
        cancelActivationCode();
        return;
    }
    
    let rewardMsg = "";
    let success = false;
    
    switch(code) {
        case "VIP666":
            player.reincarnationCoin += 1000;
            rewardMsg = "获得1000转生币";
            success = true;
            break;
        case "VIP777":
            // 假设洗炼石字段为refineStone，若实际字段不同请修改
            player.items.refineStone = (player.items.refineStone || 0) + 10;
            rewardMsg = "获得10个洗炼石";
            success = true;
            break;
        case "VIP888":
            player.items.advancedGem = (player.items.advancedGem || 0) + 3;
            rewardMsg = "获得3个高级宝石";
            success = true;
            break;
        case "XINGBI":
            player.nightClub.starCoins = (player.nightClub.starCoins || 0) + 300;
            rewardMsg = "获得300星币";
            success = true;
            break;
        case "YUYU":
            player.cosmicstone += 2;
            rewardMsg = "获得2个宇宙石";
            success = true;
            break;
       case "BANLV":
            player.items.companionKey += 10; 
            player.items.rose += 520;
            rewardMsg = "获得10个伴侣钥匙和520朵玫瑰花";
            success = true;
            break;  
          case "BANLV1":
            player.items.companionKey += 30; 
            player.items.rose += 520;
            rewardMsg = "获得30个伴侣钥匙和520朵玫瑰花";
            success = true;
            break;     
          case "XISUIDAN":
            player.items.rebornDan = (player.items.rebornDan || 0) + 10;
            rewardMsg = "获得10个洗髓丹";
            success = true;
            break;
           case "XIUXIAN":
            player.items.rootDetector = (player.items.rootDetector || 0) + 5;
            rewardMsg = "获得5个灵根检测器";
            success = true;
            break;
            case "XIUXIAN1":
            player.items.bloodlineDetector = (player.items.bloodlineDetector || 0) + 5;
            rewardMsg = "获得5个血脉检测剂";
            success = true;
            break;
           case "WOYAOCHE":
            const models = ["Portofino", "Roma", "SF90"];
            const randomModel = models[Math.floor(Math.random() * models.length)];
            const newVehicle = {
                id: 'vehicle_' + Date.now(),
                brand: "法拉利",
                model: randomModel,
                rarity: 15, // 普通稀有度
                parkTime: 0,
                income: 0
            };
            
            player.parking.vehicles.push(newVehicle);
            rewardMsg = `获得一辆法拉利${randomModel}汽车`;
            success = true;
            break;
      case "WOYAOBYFANG":
            // 兑换别墅
            const villaType = houseTypes.find(h => h.id === 5); // 别墅的id为5
            if (!villaType) {
                logAction("无效的房屋类型", "error");
                return false;
            }
            
            // 创建别墅实例
            const newHouse = {
                id: 'house_' + Date.now(),
                type: villaType.id,
                name: villaType.name,
                rarity: villaType.rarity,
                baseIncome: villaType.income,
                rentTime: 0,
                isRented: false
            };
            
            // 添加到拥有的房屋列表
            player.houses.ownedHouses.push(newHouse);            
         rewardMsg ="成功兑换激活码  获得别墅！";     
          success = true;
            break;
        case "SHENQI":
            player.items.yuzhou4 = (player.items.yuzhou4 || 0) + 200;
            rewardMsg = "获得200个神器碎片发票";
            success = true;
            break;       
       case "YUZHOU":
            player.items.yuzhou3 = (player.items.yuzhou3 || 0) + 200;
            rewardMsg = "获得200个宇宙晶体发票";
            success = true;
            break;    
       case "ANBAO":
            player.items.yuzhou2 = (player.items.yuzhou2 || 0) + 1000;
            rewardMsg = "获得1000个暗物质发票";
            success = true;
            break; 
       case "MIMI":
            player.items.fuben1 = (player.items.fuben1 || 0) + 10;
            rewardMsg = "获得10个副本令牌";
            success = true;
            break; 
       case "FUBEN":
            player.items.fuben2 = (player.items.fuben2 || 0) + 10;
            rewardMsg = "获得10个秘境钥匙";
            success = true;
            break; 
       case "YUANDAN":
            player.items.baitCount = (player.items.baitCount || 0) + 200;
            rewardMsg = "获得200个鱼饵";
            success = true;
            break; 
       case "YUANDAN1":
            player.items.vipPower = (player.items.vipPower || 0) + 500;
            rewardMsg = "500个VIP能力值";
            success = true;
            break; 
       case "YUANDAN2":
            player.items.companionKey = (player.items.companionKey || 0) + 100;
            rewardMsg = "获得100个伴侣钥匙";
            success = true;
            break; 
        case "YUER":
            player.items.baitCount = (player.items.baitCount || 0) + 20;
            rewardMsg = "获得20个鱼饵";
            success = true;
            break;
        case "VIP666666":
        player.items.vipPower = (player.items.vipPower || 0) + 10;
        rewardMsg = "获得10个VIP能力值";
        success = true;
        break;
        case "ZHIYESHU1":
        player.items.zhiye1 = (player.items.zhiye1 || 0) + 10;
        rewardMsg = "获得10个职业转换书";
        success = true;
        break;
        case "DAGUAIWU1":
        player.items.fuben1 = (player.items.fuben1 || 0) + 3;
        rewardMsg = "获得3个副本令牌";
        success = true;
        break;
            case "HUOBAN1":
        player.items.roseq = (player.items.roseq || 0) + 20;
        rewardMsg = "获得20个香囊";
        success = true;
        break;   
       case "VIP666777":
            // 添加"公测玩家"称号
            if (!player.titles.unlocked.includes("公测玩家")) {
                player.titles.unlocked.push("公测玩家");
                rewardMsg = "获得称号：公测玩家";
                success = true;
                // 自动选择新称号
                player.titles.current = "公测玩家";
                updateDisplay();
            } else {
                logAction("您已拥有此称号", "info");
            }
            break;
case "LINGQI1":
  
    if (player.magicTools.inventory.includes("moonlight_pearlu")) {
        logAction("已拥有落宝金钱法宝，无法重复兑换", "error");
        success = false;
    } else {
        // 添加法宝到库存
        player.magicTools.inventory.push("moonlight_pearlu");
        rewardMsg = "获得法宝：落宝金钱";
        success = true;
        // 可选：自动装备该法宝
        player.magicTools.equipped = "moonlight_pearlu";
    }
    break;
  case "DANIANSHOU":
    
    if (player.magicTools.inventory.includes("yin_yang_mirrorbaab")) {
        logAction("已拥有驱年爆竹法宝，无法重复兑换", "error");
        success = false;
    } else {
        // 添加法宝到库存
        player.magicTools.inventory.push("yin_yang_mirrorbaab");
        rewardMsg = "获得法宝：驱年爆竹";
        success = true;
        // 可选：自动装备该法宝
        player.magicTools.equipped = "yin_yang_mirrorbaab";
    }
    break;
   case "XIUXIANA":
            player.items.rootDetector = (player.items.rootDetector || 0) + 17;
            rewardMsg = "获得17个灵根检测器";
            success = true;
            break;
            case "XIUXIANB":
            player.items.bloodlineDetector = (player.items.bloodlineDetector || 0) + 17;
            rewardMsg = "获得17个血脉检测剂";
            success = true;
            break;
       case "XIANNIANHONGBAO":
            player.investmentGame.userData.availableFunds += 1000000;
            rewardMsg = "获得1000000元资金";
            success = true;
            break;
             case "SHENYUAN2":
            player.abyssTower.exclusiveCurrency += 1000;
            rewardMsg = "获得1000深渊币";
            success = true;
            break;
        case "XIUXIANFUBEN":
        player.nianBeast.dungeonToken = (player.nianBeast.dungeonToken || 0) + 10;
        rewardMsg = "获得10个修仙令牌";
        success = true;
        break;
        case "SHENYUAN1":
        player.items.fubeng1 = (player.items.fubeng1 || 0) + 20;
        rewardMsg = "获得20个深渊令牌";
        success = true;
        break;
        case "补偿宝石损失":
        player.items.divineGem = (player.items.divineGem || 0) + 1;
        rewardMsg = "获得1个神级宝石";
        success = true;
        break;
        default:
            logAction("无效的激活码", "error");
            return;
    }
    
    if (success) {
        // 记录已使用的激活码
        usedCodes.push(code);
        player.usedActivationCodes = usedCodes;
        
        logAction(`激活码兑换成功：${rewardMsg}`, "success");
        updateDisplay(); // 更新界面显示
        cancelActivationCode();
         saveGame();
      setTimeout(() => {
                location.reload(true);
            }, 1000);
    }
}
// 添加VIP等级计算函数
function calculateVipLevel() {
    let currentLevel = 1;
    const { power } = player.vip;
    
    for (let i = vipConfig.length - 1; i >= 0; i--) {
        if (power >= vipConfig[i].requiredPower) {
            currentLevel = vipConfig[i].level;
            break;
        }
    }
    
    return currentLevel;
}

// 获取当前VIP等级的加成
function getVipBonus() {
    const level = player.vip.level;
    const config = vipConfig.find(c => c.level === level) || vipConfig[0];
    return config.bonus;
}

// 更新VIP显示（loadSave 时 DOM 可能尚未就绪，需判空避免报错）
function updateVipDisplay() {
    if (!player.vip) return;
    const { level, power } = player.vip;
    const currentConfig = vipConfig.find(c => c.level === level) || vipConfig[0];
    const nextConfig = vipConfig.find(c => c.level === level + 1);
    
    var elLevel = document.getElementById('vipLevel');
    if (elLevel) elLevel.textContent = level;
    
    let progressPercent = 0;
    let progressText = '';
    
    if (nextConfig) {
        const progress = power - currentConfig.requiredPower;
        const total = nextConfig.requiredPower - currentConfig.requiredPower;
        progressPercent = Math.min(100, (progress / total) * 100);
        progressText = `${progress}/${total}`;
    } else {
        progressPercent = 100;
        progressText = '已达最高级';
    }
    
    var elBar = document.getElementById('vipProgressBar');
    if (elBar) elBar.style.width = progressPercent + '%';
    var elText = document.getElementById('vipProgressText');
    if (elText) elText.textContent = progressText;
    
    var elVipDisplay = document.querySelector('.vip-level-display');
    if (elVipDisplay) {
        var hue = (level - 1) * (360 / 20);
        elVipDisplay.style.background = 'linear-gradient(to right, hsl(' + hue + ', 100%, 50%), hsl(' + ((hue + 60) % 360) + ', 100%, 50%))';
        elVipDisplay.style.webkitBackgroundClip = 'text';
    }
}
function useAllVipPower() {
    if (player.items.vipPower && player.items.vipPower > 0) {
        const useCount = player.items.vipPower;
        player.items.vipPower = 0;
        player.vip.power += useCount;
        
        const newLevel = calculateVipLevel();
        if (newLevel > player.vip.level) {
            const oldLevel = player.vip.level;
            player.vip.level = newLevel;
            logAction(`VIP等级提升至${newLevel}级！全属性装备提升${vipConfig[newLevel - 1].bonus * 100}%`, 'success');
            
            // 刷新所有装备属性
            const newVipBonus = 1 + getVipBonus();
            player.equipment.forEach(eq => {
                eq.gps = safeNumber(eq.gps / (1 + getVipBonusByLevel(oldLevel)) * newVipBonus); 
                eq.click = safeNumber(eq.click / (1 + getVipBonusByLevel(oldLevel)) * newVipBonus);
            });
        }
        
        updateVipDisplay();
        updateDisplay();
        logAction(`使用了${useCount}个VIP能力值`, "info");
    } else {
        logAction("VIP能力值不足！", "error");
    }
}

// 辅助函数：根据等级获取旧的VIP加成（需要实现）
function getVipBonusByLevel(level) {
    const config = vipConfig.find(c => c.level === level) || vipConfig[0];
    return config.bonus;
}
// 计算总GPS时，实时应用当前VIP加成
function calculateTotalGPS() {
    let totalGps = 0;
    player.equipment.forEach(eq => {
        totalGps += eq.gps * (1 + getVipBonus()); // 实时获取最新VIP加成
    });
    // 其他加成（如成就、转生等）
    return totalGps;
}
// 添加设置界面切换函数
function toggleAutoBuySettings() {
    const settings = document.getElementById('autoBuySettings');
    if (settings.style.display === 'none') {
        settings.style.display = 'block';
        // 将当前设置的值填入输入框
        document.getElementById('techniqueMaxCost').value = player.autoBuyTechniqueMaxCost;
    } else {
        settings.style.display = 'none';
    }
}

// 添加设置价格上限函数
function setTechniqueMaxCost() {
    const input = document.getElementById('techniqueMaxCost');
    const value = parseFloat(input.value);
    
    if (!isNaN(value) && value > 0) {
        player.autoBuyTechniqueMaxCost = value;
        logAction(`已设置功法秘籍宝箱自动购买价格上限为: ${formatNumber(value)}`, 'success');
    } else {
        logAction("请输入有效的价格上限", "error");
    }
}

        // 加载存档
       function loadSave() {
    var _tradingOfflineMs = 0; // 用于末尾统一执行跑商离线结算，避免被中间逻辑跳过
    // 若本会话已跑过离线结算则不再覆盖，避免重复结算
    if (!window._tradingOfflineRunThisSession) window._tradingOfflineMs = 0;
    try {
        const save = JSON.parse(localStorage.getItem('goldGameSave'));
        if (save) {
            // 跑商离线：用「第一次读档」的 lastUpdate 立即固定离线时长，避免后面有人写回存档导致第二次 loadSave 读到 lastUpdate=现在 从而变成 0
            if (save.lastUpdate != null && !window._tradingOfflineRunThisSession) {
                var offFirst = Date.now() - save.lastUpdate;
                if (offFirst > 0) {
                    var offCapped = Math.min(offFirst, 24 * 3600 * 1000);
                    if (window._tradingOfflineMsFromSave == null || window._tradingOfflineMsFromSave === 0)
                        window._tradingOfflineMsFromSave = offCapped;
                }
            }
            // 仅当从未记录过「离开时间」时，用存档时间作为回退（供跑商离线结算用）；有记录则不覆盖，避免把离线时长算成 0
            if (save.lastUpdate != null) {
                var cur = parseInt(localStorage.getItem('goldGameLastUnload') || '0', 10);
                if (cur === 0) localStorage.setItem('goldGameLastUnload', String(save.lastUpdate));
            }
            if (save.lastUpdate != null && !window._tradingOfflineRunThisSession) {
                var off = Date.now() - save.lastUpdate;
                if (off > 0) {
                    _tradingOfflineMs = Math.min(off, 24 * 3600 * 1000);
                    window._tradingOfflineMs = _tradingOfflineMs;
                    window._tradingOfflineMsSnapshot = _tradingOfflineMs;
                }
            }
            if (save.gameVersion && isCurrentVersionOlderThan(save.gameVersion)) {
                showVersionError(save.gameVersion);
                return;
            }
            if (save.lastUpdate && save.lastUpdate > Date.now()) {
                throw new Error("检测到时间回退，强制重置游戏");
            }
            player = migrateSaveData(save);
            player.equipment = validateEquipmentList(save.equipment);
            // ========== 离线收益：尽早执行，避免后续初始化抛错导致被跳过 ==========
            (function() {
                const currentTime = Date.now();
                const maxOfflineTime = 86400 * 1000;
                const lastUpdateTime = (save.lastUpdate != null ? save.lastUpdate : player.lastUpdate) || currentTime;
                const offlineTime = Math.min(currentTime - lastUpdateTime, maxOfflineTime);
                // 与其它离线系统一致：把离线时长交给跑商离线结算用，避免跑商用错来源导致不结算
                if (offlineTime > 0 && !window._tradingOfflineRunThisSession) {
                    window._tradingOfflineMsFromSave = Math.min(offlineTime, maxOfflineTime);
                }
                const offlineSeconds = Math.floor(offlineTime / 1000);
                if (offlineTime <= 1000) return;
                const offlineMinutes = Math.floor(offlineSeconds / 60);
                if (!Array.isArray(player.equipment)) return;
                player.equipment.forEach(eq => {
                    eq.level = (eq.level || 1) + offlineMinutes * 1000;
                    var config = typeof equipmentTypes !== 'undefined' && equipmentTypes[eq.rarity] ? equipmentTypes[eq.rarity] : (equipmentTypes && equipmentTypes.common) || { gps: 0, click: 0, growthRate: 0.01 };
                    var vipBonus = 1 + (typeof getVipBonus === 'function' ? getVipBonus() : 0);
                    var gpsBonusLv = (player.reincarnationStats && player.reincarnationStats.gpsBonus && player.reincarnationStats.gpsBonus.level) ? player.reincarnationStats.gpsBonus.level : 0;
                    eq.gps = typeof safeNumber === 'function' ? safeNumber(config.gps * (1 + (config.growthRate * eq.level * 0.01)) * (1 + gpsBonusLv) * vipBonus, 0) : (config.gps * (1 + (config.growthRate * eq.level * 0.01)) * (1 + gpsBonusLv) * vipBonus);
                    eq.click = typeof safeNumber === 'function' ? safeNumber(config.click * (1 + (config.growthRate * eq.level * 0.01)) * (1 + gpsBonusLv) * vipBonus, 0) : (config.click * (1 + (config.growthRate * eq.level * 0.01)) * (1 + gpsBonusLv) * vipBonus);
                });
                var offlineGPS = 0;
                try { if (typeof getTotalGPS === 'function') offlineGPS = getTotalGPS(); } catch (err) { console.warn('离线 getTotalGPS 异常', err); }
                player.gold = (player.gold || 0) + offlineSeconds * offlineGPS;
                if (typeof logAction === 'function' && typeof formatTime === 'function') {
                    var fm = (offlineSeconds * offlineGPS) >= 1e8 ? (offlineSeconds * offlineGPS).toExponential(3) : (offlineSeconds * offlineGPS).toLocaleString();
                    logAction('离线收益: +' + fm + '金币 (' + formatTime(offlineTime) + ')，装备每件+' + (offlineMinutes * 1000) + '级', 'offline-reward');
                }
                if (typeof simulateOfflineAutoBuy === 'function') simulateOfflineAutoBuy(offlineSeconds);
                if (player.traditionalLotteryNumbers && player.traditionalLotteryNumbers.length > 0 && typeof checkTraditionalLotteryResult === 'function') {
                    var lotteryIntervals = Math.floor(offlineTime / 1800000);
                    for (var i = 0; i < lotteryIntervals; i++) checkTraditionalLotteryResult();
                }
                if (typeof calculateOfflineCultivationExp === 'function') calculateOfflineCultivationExp(offlineMinutes);
                if (typeof calculateBankInterest === 'function') calculateBankInterest();
            })();
            // 恢复星域探索舰队属性，避免重启后变回1级
            if (typeof restoreExplorationDataFromSave === 'function') restoreExplorationDataFromSave(save);
            if (save.battle && save.battle.autoSweepEnabled !== undefined) {
            player.battle.autoSweepEnabled = save.battle.autoSweepEnabled;
        }
         
        if (!player.battle) {
        player.battle = {
            playerHealth: 100 + player.reincarnationCount * 10,
            playerAttack: getTotalClickValue(),
            playerCritRate: 0.1 + player.attributes.critRate * 0.0005,
            playerCritDamage: 1.5 + player.attributes.critDamage * 0.005,
            currentZone: null,
            currentMonster: null,
            monsterResurrections: 0,
            autoBattle: false,
            autoBattleInterval: null
        };
    }
        if (save.autoBuyTechniqueMaxCost !== undefined) {
    player.autoBuyTechniqueMaxCost = save.autoBuyTechniqueMaxCost;
}
  

 if (!player.wings) {
        player.wings = {
            inventory: [],
            equipped: null,
            level: 1,
            upgradeCost: 5
        };
    }

          if (save.level) {
                player.level = {
                    current: save.level.current || 1,
                    exp: save.level.exp || 0,
                    nextLevelExp: save.level.nextLevelExp || 10000,
                    clickBonus: save.level.clickBonus || 0,
                    gpsBonus: save.level.gpsBonus || 0,
                    ascentionCount: save.level.ascentionCount || 0,
                    ascentionMultiplier: save.level.ascentionMultiplier || 1,
                     ascentionCounta: save.level.ascentionCounta || 0,
                    ascentionMultipliera: save.level.ascentionMultipliera || 1                 
                };
            }

             // 确保加载通天塔数据
          if (!player.fishing) {
        player.fishing = {
            level: 1,
            currentExp: 0,
            fishCage: [],
            isFishing: false,
            isBiting: false,
            biteTimer: null,
            biteWindowTimer: null,
            biteTime: 0,
            bonus: 1
        };
    }
         
           
           updateTowerUI();
          // 延后执行，避免在 classConfig 尚未定义时（如首次初始化）访问导致 TDZ 报错
          setTimeout(calculateOfflineMysteryExp, 0);
            // 重置并重新计算收藏物效果
            resetAllCollectionEffects();
         // 新增：加载存档后自动计算并更新VIP等级
            const actualVipLevel = calculateVipLevel();
            player.vip.level = actualVipLevel;
            updateVipDisplay(); // 立即更新VIP显示
               updateAutoConvertDisplay();
            // 确保自动购买状态被正确加载
            player.autoBuy = save.autoBuy || [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            player.autoBuyMaterialChest = save.autoBuyMaterialChest || false;
           player.autoBuyTechniqueChest = save.autoBuyTechniqueChest || false;
            // 强制覆盖宠物的 multiplier，同时保留等级和其他数据
            Object.keys(player.pets).forEach(petKey => {
                if (petConfig[petKey]) {
                    player.pets[petKey].multiplier = petConfig[petKey].multiplier;
                }
            });
       
            // 初始化自动购买按钮状态
            player.autoBuy.forEach((enabled, index) => {
                const btn = document.getElementById(`autoChest${index + 1}`);
                if (btn) {
                    btn.textContent = `${['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'][index]}宝箱自动购买：${enabled ? '开启' : '关闭'}`;
                }
            });
   

            // 初始化材料宝箱自动购买按钮状态
            const materialChestBtn = document.getElementById('autoMaterialChest');
            if (materialChestBtn) {
                materialChestBtn.textContent = `材料宝箱自动购买：${player.autoBuyMaterialChest ? '开启' : '关闭'}`;
            }
 const techniqueChestBtn = document.getElementById('autoTechniqueChest');
    if (techniqueChestBtn) {
        techniqueChestBtn.textContent = `功法秘籍宝箱自动购买：${player.autoBuyTechniqueChest ? '开启' : '关闭'}`;
    }
         // 在初始化自动购买按钮状态的地方添加
const speedBoostBtn = document.getElementById('autoBuySpeedBoost');
if (speedBoostBtn) {
    speedBoostBtn.textContent = `在线自动购买100倍数量：${player.autoBuySpeedBoost ? '开启' : '关闭'}`;
    var autoBuyLabel = document.getElementById('autoBuySpeedLabel');
    if (autoBuyLabel) autoBuyLabel.textContent = player.autoBuySpeedBoost ? '开' : '关';
}
      const onlineBoostBtn = document.getElementById('toggleOnlineBoost');
    if (onlineBoostBtn) {
        onlineBoostBtn.textContent = `在线金币加速100倍: ${player.onlineBoostEnabled ? '开启' : '关闭'}`;
    }
    var onlineBoostLabel = document.getElementById('onlineBoostLabel');
    if (onlineBoostLabel) onlineBoostLabel.textContent = player.onlineBoostEnabled ? '开' : '关';
    // 同步自动转生侧栏显示
    var autoReincEl = document.getElementById('autoReincarnationStatus');
    if (autoReincEl) autoReincEl.textContent = player.autoReincarnation ? '开启' : '关闭';
      
            // 确保日志不超过 20 条
            player.actionLogs = player.actionLogs.slice(0, 20);
            player.lotteryResults = player.lotteryResults.slice(0, 5);

         
          initSlotMachine();
          initMountData();
          initFarmData();
        updateSectNameDisplay();
         initExplorationSystem();
        initExpeditionData();
    initTreasureMapSystem();
   initNightClubSystem();
    // 计算离线探险奖励
    calculateOfflineExpeditionRewards();
   initHouseSystemOnLoad();
    // 离线跑商结算：传入存档以便用 save.lastUpdate 计算离线时长（避免被后面代码改掉）
    if (typeof initTradingData === 'function' && player.reincarnationCount >= 1000) {
        initTradingData(save);
    }
  
       if (save.tower) {
                player.tower = save.tower;
            }
        // 加载投资游戏数据
            if (save.investmentGame) {
                player.investmentGame = save.investmentGame;
                if (player.investmentGame) player.investmentGame.chartHistoryCache = {}; // 走势图缓存仅运行时用，不读档
                if (typeof normalizeInvestmentGamePrices === 'function') normalizeInvestmentGamePrices();
            }
            
            // 初始化投资游戏
            initInvestmentGameOnLoad();
            loadInvestmentGameData();       
 // 初始化投资游戏数据
            if (!player.investmentGame) {
                initInvestmentGame();
            } else {
                // 模拟离线期间的价格变化
                simulateOfflinePriceChanges();
            }
          if (save.runes) {
                player.runes = save.runes;
                           }
          
    if (save.traditionalLotteryBought && save.traditionalLotteryDrawTime) {
                        if (Date.now() >= save.traditionalLotteryDrawTime) {
                            // 立即开奖
                            checkTraditionalLotteryResult();
                        } else {
                            // 设置开奖时间
                            player.traditionalLotteryDrawTime = save.traditionalLotteryDrawTime;
                        }
                    }
        }
    } catch (e) {
        console.warn('存档加载失败，使用默认数据:', e);
    }
    // 跑商离线：不在 loadSave 内调用（游戏初始化时 tradingConfig 未定义会报错），由 window.onload / setTimeout(800) / loadGame 执行
    player.lastUpdate = Date.now();
}

  



        // 模拟离线期间的自动购买
        function simulateOfflineAutoBuy(offlineSeconds) {
    const maxOfflineTime = 86400; // 24小时（秒）
    const actualOfflineTime = Math.min(offlineSeconds, maxOfflineTime);
    const minutes = Math.floor(actualOfflineTime / 86400); // 转换为分钟数
    const chestsPerMinute = 1; // 每分钟购买数量

    player.autoBuy.forEach((enabled, index) => {
        if (enabled) {
            const type = index + 1;
            const costConfig = [
                { currency: "gold", amount: 100 },
                { currency: "diamond", amount: 10 },
                { currency: "titanium", amount: 1 },
                { currency: "starstone", amount: 1 },
                { currency: "cosmicstone", amount: 1 },
                { currency: "superstone", amount: 1 },
                { currency: "otherworldstone", amount: 1 },
                { currency: "xingjiestone", amount: 1 },
                { currency: "hundunstone", amount: 1 },
                { currency: "lingtone", amount: 1 },
                { currency: "huangtone", amount: 1 },
                { currency: "mingtone", amount: 1 },
                { currency: "xutong", amount: 1 },
                { currency: "shitone", amount: 1 },
                { currency: "weitone", amount: 1 }                
            ][index];

            // 计算最大可购买数量：分钟数 × 每分钟500个
            const maxPossible = minutes * chestsPerMinute;
            // 计算实际能购买的数量（受限于货币数量）
            const affordable = Math.floor(player[costConfig.currency] / costConfig.amount);
            const actualBuy = Math.min(maxPossible, affordable);

            if (actualBuy > 0) {
                // 扣除总消耗
                player[costConfig.currency] -= actualBuy * costConfig.amount;
                
                // 更新宝箱计数
                const chestType = ['common', 'advanced', 'rare', 'epic', 'legendary', 'chaos', 'apocalypse','yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6', 'yeyu7', 'yeyu8'][index];
                player.chestCounts[chestType] += actualBuy;
                
                // 批量处理装备获取（这里简化处理，实际可根据需要调整概率计算）
                for (let i = 0; i < actualBuy; i++) {
                    const selectedRarity = selectRarity(type);
                    handleEquipment(selectedRarity);
                }
                
                // 检查成就（会自动处理区间判断）
                checkChestAchievements(chestType, player.chestCounts[chestType]);
            }
        }
    });




    // 材料宝箱类似处理
    if (player.autoBuyMaterialChest) {
        const maxPossible = minutes * chestsPerMinute;
        let remaining = maxPossible;
        let totalCost = 0;
        
        // 计算材料宝箱可购买数量（考虑成本递增）
        while (remaining > 0 && player.diamond >= player.materialChestCost + totalCost) {
            totalCost += player.materialChestCost;
            player.materialChestCost *= 2; // 成本翻倍
            remaining--;
        }
        
        if (maxPossible - remaining > 0) {
            player.diamond -= totalCost;
            // 批量处理材料宝箱奖励
            for (let i = 0; i < maxPossible - remaining; i++) {
                const selectedItem = selectMaterialChestItem();
                if (selectedItem.type in player.collections) {
                    player.collections[selectedItem.type]++;
                    applyCollectionEffect(selectedItem.type);
                } else if (selectedItem.type in player.items) {
                    player.items[selectedItem.type]++;
                }
            }
        }
    }

    autoConvertCurrency();
}
function handleVipPowerGain() {
    player.vip.power++;
    const newLevel = calculateVipLevel();
    
    if (newLevel > player.vip.level) {
        const oldLevel = player.vip.level;
        player.vip.level = newLevel;
        logAction(`VIP等级提升至${newLevel}级！全属性装备提升${vipConfig[newLevel - 1].bonus * 100}%`, 'success');
    }
    
    updateVipDisplay();
}
        // 数据迁移
        function migrateSaveData(oldSave) {
    return {
        ...player,
        ...oldSave,
        achievements: {
            ...player.achievements, // 使用默认成就数据
            ...(oldSave.achievements || {}) // 覆盖旧存档的成就数据
        },
        equipment: oldSave.equipment || [],
        items: oldSave.items || { primaryGem: 0, advancedGem: 0, superiorGem: 0, divineGem: 0, vipPower: 0, refineStone: 0, rose: 0, companionKey: 0, rebornDan: 0, baitCount: 0, rootDetector: 0, bloodlineDetector: 0, advanceStone: 0, primaryGemq: 0, zongmen: 0, roseq: 0, yuzhou1: 0, yuzhou2: 0, yuzhou3: 0, yuzhou4: 0, banlv1: 0, banlv2: 0, banlv3: 0, banlv4: 0, banlv5: 0, banlv6: 0, banlv7: 0, banlv8: 0, banlv9: 0, zhiye1: 0, chiban1: 0, zuoqi1: 0, fuben1: 0, shenshou1: 0, fuwen1: 0, fuben2: 0, danyao1: 0, danyao2: 0, danyao3: 0, danyao4: 0, danyao5: 0, fubeng1: 0, seed_herb1: 0, seed_herb2: 0, seed_herb3: 0, seed_herb4: 0, seed_herb5: 0},
        collections: oldSave.collections || {
            lightSpeedHand: 0,
            empHand: 0,
            godlyHand: 0,
            quickHand: 0,
            shadowHand: 0,
            quantumHand: 0,
            lightningHand: 0,
            divineHand: 0
        },
     houses: oldSave.houses || {
                    level: 1,
                    exp: 0,
                    maxHouses: 5,
                    ownedHouses: [],
                    rentedHouses: [],
                    lastUpdate: Date.now(),
                    totalIncome: 0
                },
        pets: oldSave.pets || {
            thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
            chaosTaotie: { level: 0, cost: 1, multiplier: 0.30 },
            netherQiongqi: { level: 0, cost: 1, multiplier: 0.90 },
            abyssKun: { level: 0, cost: 1, multiplier: 2.70 },
            primordialZhuLong: { level: 0, cost: 1, multiplier: 8.10 },
           wanJunSuanNi: { level: 0, cost: 1, multiplier: 24.30 },
           yanYuBiAn: { level: 0, cost: 1, multiplier: 72.90 },
          yuyu1: { level: 0, cost: 1, multiplier: 218.70 },
         yuyu2: { level: 0, cost: 1, multiplier: 656.10 },
          yuyu3: { level: 0, cost: 1, multiplier: 1968.30 },
         yuyu4: { level: 0, cost: 1, multiplier: 5904.90 },
          yuyu5: { level: 0, cost: 1, multiplier: 17714.70 },
          yuyu6: { level: 0, cost: 1, multiplier: 53144.10 },
         yuyu7: { level: 0, cost: 1, multiplier: 159432.30 },
          yuyu8: { level: 0, cost: 1, multiplier: 478296.90 }
        },
        dungeonEquipment: oldSave.dungeonEquipment || [],
        soulRings: oldSave.soulRings || [],
        achievements: oldSave.achievements || player.achievements,
        autoBuy: oldSave.autoBuy || [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], // 新增宝箱自动购买状态
        autoBuyMaterialChest: oldSave.autoBuyMaterialChest || false,
        autoBuyTechniqueChest: oldSave.autoBuyTechniqueChest || false,
       autoBuyTechniqueMaxCost: oldSave.autoBuyTechniqueMaxCost ||0.1,
        gpsMultiplie: oldSave.gpsMultiplier ||1,
        clickMultiplier: oldSave.clickMultiplier || 1,
        autoConvert: oldSave.autoConvert || false,
        autoConvertCurrency: oldSave.autoConvertCurrency || { gold: false, diamond: false, titanium: false, starstone: false },
        clickTimestamps: oldSave.clickTimestamps || [],
        chestCounts: oldSave.chestCounts || { common: 0, advanced: 0, rare: 0, epic: 0, legendary: 0, chaos: 0, apocalypse: 0, yeyu1: 0, yeyu2: 0, yeyu3: 0, yeyu4: 0, yeyu5: 0, yeyu6: 0, yeyu7: 0, yeyu8: 0 }, // 新增宝箱计数
        reincarnationCoin: oldSave.reincarnationCoin || 0,
        reincarnationCount: oldSave.reincarnationCount || 0,
        reincarnationStats: oldSave.reincarnationStats || {
            gpsBonus: { level: 0, cost: 1 },
            equipmentLevelBonus: { level: 0, cost: 1 },
            clickLimitBonus: { level: 0, cost: 1 }
        },
        materialChestCost: oldSave.materialChestCost || 1,
        stockData: oldSave.stockData || {
            stocks: [
                { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
            ],
            lastStockUpdate: Date.now()
        },
        lotteryResults: oldSave.lotteryResults || [],
        traditionalLotteryNumbers: oldSave.traditionalLotteryNumbers || [],
        lastLotteryDraw: oldSave.lastLotteryDraw || Date.now(),
        bank: oldSave.bank || {
            deposit: 0,
            lastInterestUpdate: Date.now()
        }
    };
}

        // 装备验证
        function validateEquipmentList(equipmentList) {
            return (equipmentList || []).map(eq => ({
                name: eq.name || getEquipmentName(eq),
                rarity: validateRarity(eq.rarity),
                level: Math.max(1, parseInt(eq.level) || 1),
                gps: safeNumber(eq.gps, 0),
                click: safeNumber(eq.click, 0),
                growthRate: safeNumber(eq.growthRate, getDefaultGrowthRate(eq.rarity)),
                gemMultiplier: safeNumber(eq.gemMultiplier, 0),
                collectionMultiplier: safeNumber(eq.collectionMultiplier, 0)
            }));
        }

        // 安全数值处理
        function safeNumber(value, fallback = 0) {
            return typeof value === 'number' ? value : parseFloat(value) || fallback;
        }

        // 核心游戏逻辑
        function getTotalGPS() {
    const towerMultiplier = 1 + player.tower.currentFloor * 0.01;
    const gpsBonus = player.reincarnationStats.gpsBonus.level * 1.00; // 每级增加100% GPS
    const petMultiplier = Object.values(player.pets).reduce((sum, pet) => sum + pet.level * pet.multiplier, 1);

    // 改为使用带职业加成的总装备加成
    const dungeonBonus = getTotalDungeonEquipBonus();
    // 改为使用带职业加成的总魂环加成
    const soulRingBonus = getTotalSoulRingBonus();
 const mysteryBonus = player.mystery.bonus || 1;
const cultivationBonus = player.cultivation.bonus || 1;
const gpsEnhancements =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
const farmGPSEnhancement  = gpsEnhancements[player.farm.level - 1] || gpsEnhancements[gpsEnhancements.length - 1];

const gpsEnhancementss =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
const farmGPSEnhancements  = gpsEnhancementss[player.parking.level - 1] || gpsEnhancementss[gpsEnhancementss.length - 1];

const gpsEnhancemenzss =  [1, 3, 6, 8, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 150, 200, 250, 300, 350, 400, 1];
const farmGPSEnhancemezts  = gpsEnhancemenzss[player.houses.level - 1] || gpsEnhancemenzss[gpsEnhancemenzss.length - 1];
    const gpsBonuqqqq = 1+player.fiveElements.metal.level * 3.00;  
   const gpsBonuqqqa = player.trialTower.currentFloor * 1.00; 
    const gpsBonuss = player.level.gpsBonus * 1.00;   
   const gpsBonusssq = player.liveStream.totalEarnings * 0.00001;  
const gpsBonusssqaa = player.landlord.stats.totalCoinsEarned * 0.0001;  
 const gpsBonussbb = player.mining.gems.diamond * 1.00;  
   const gpsBonusssqasa = 1+player.abyssTower.bestFloor * 2.00;  
const gpsEnhancementsp =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
const farmGPSEnhancementp  = gpsEnhancementsp[player.sect.level - 1] || gpsEnhancementsp[gpsEnhancementsp.length - 1];
 const marriageBonus = player.marriage && player.marriage.isMarried ?  player.marriage.marriageBonuses.gpsMultiplier : 1;
        const childBonus = player.children ? player.children.childBonuses.gpsMultiplier : 1;
    const sectTributeBonus = typeof getSectTributeGPSBonus === 'function' ? getSectTributeGPSBonus() : 1;

    return (1 + player.equipment.reduce((sum, eq) => sum + eq.gps * (1+eq.gemMultiplier + eq.collectionMultiplier), 0)) 
        * player.gpsMultiplier 
        * (1 + gpsBonus) 
        * petMultiplier * (1 + dungeonBonus) * (1 + soulRingBonus) * towerMultiplier * mysteryBonus * farmGPSEnhancement * farmGPSEnhancements  * cultivationBonus * gpsBonuss * (1 + gpsBonusssq) * farmGPSEnhancementp * (1 + gpsBonusssqaa) * (1 + gpsBonussbb)*farmGPSEnhancemezts * marriageBonus * childBonus * gpsBonuqqqq * gpsBonuqqqa * gpsBonusssqasa * sectTributeBonus;
}

function getTotalClickValue() {
    const petMultiplier = Object.values(player.pets).reduce((sum, pet) => sum + pet.level * pet.multiplier, 1);
    // 改为使用带职业加成的总装备加成
    const dungeonBonus = getTotalDungeonEquipBonus();
    // 改为使用带职业加成的总魂环加成
   const fishingBonus = player.fishing ? player.fishing.bonus : 1;
    const soulRingBonus = getTotalSoulRingBonus();
   const cultivationBonus = player.cultivation.bonus || 1;
    const farmClickMultipliers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
 const farmClickBonus = farmClickMultipliers[player.farm.level - 1] || farmClickMultipliers[farmClickMultipliers.length - 1];

const farmClickMultiplierss = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
    const farmClickBonuss = farmClickMultiplierss[player.parking.level - 1] || farmClickMultiplierss[farmClickMultiplierss.length - 1];
const farmClickMultipliersss = [1, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 1];
    const farmClickBonusss = farmClickMultipliersss[player.nightClub.level - 1] || farmClickMultipliersss[farmClickMultipliersss.length - 1];     
     const gpsBonuvvs = player.houses.totalIncome *  0.0001;
    const gpsBonubbs = player.parking.totalIncome *  0.0001;
    const gpsBonusss = player.level.clickBonus * 1.00; 
    const gpsBonuqregg = 1+player.fiveElements.wood.level * 3.00; 
    const gpsBonuqregga = 1+player.trialTower.currentFloor * 0.10; 
    const gpsBonuqreggsa = 1+player.abyssTower.bestFloor * 2.00;
const farmClickMultiplierssa = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 1];
    const farmClickBonussa = farmClickMultiplierssa[player.liveStream.level - 1] || farmClickMultiplierssa[farmClickMultiplierssa.length - 1];
       const farmClickBonussw = player.landlord.stats.totalCoinsEarned * 0.0001;      
     const marriageBonus = player.marriage && player.marriage.isMarried ?  player.marriage.marriageBonuses.clickMultiplier : 1;
   const childBonus = player.children ? player.children.childBonuses.clickMultiplier : 1;
    return (1 + player.equipment.reduce((sum, eq) => sum + eq.click * (1+eq.gemMultiplier + eq.collectionMultiplier), 0)) 
        * player.clickMultiplier 
        * petMultiplier 
        * (1 + dungeonBonus)  // 应用副本装备总加成（含职业乘数）
        * (1 + soulRingBonus) * fishingBonus * farmClickBonus * farmClickBonuss * cultivationBonus * farmClickBonusss * gpsBonusss * farmClickBonussa* (1 + farmClickBonussw) * (1+gpsBonuvvs) * (1+gpsBonubbs) * marriageBonus * childBonus * gpsBonuqregg * gpsBonuqregga * gpsBonuqreggsa; 
}


     
        // 自动兑换货币
        function autoConvertCurrency() {
    const conversions = [
        { from: 'gold', to: 'diamond', rate: 1e5 },
        { from: 'diamond', to: 'titanium', rate: 1e8 },
        { from: 'titanium', to: 'starstone', rate: 1e8 },
        { from: 'starstone', to: 'cosmicstone', rate: 1e8 },
        { from: 'cosmicstone', to: 'superstone', rate: 1e9 },
        { from: 'superstone', to: 'otherworldstone', rate: 1e12 },
        { from: 'otherworldstone', to: 'xingjiestone', rate: 1e12 },
        { from: 'xingjiestone', to: 'hundunstone', rate: 1e12 },
        { from: 'hundunstone', to: 'lingtone', rate: 1e15 },
        { from: 'lingtone', to: 'huangtone', rate: 1e15 },
        { from: 'huangtone', to: 'mingtone', rate: 1e15 },
        { from: 'mingtone', to: 'xutong', rate: 1e20 },
        { from: 'xutong', to: 'shitone', rate: 1e20 },
        { from: 'shitone', to: 'weitone', rate: 1e20 }        
    ];

    conversions.forEach(({ from, to, rate }) => {
        if (player.autoConvertCurrency[from]) {
            const converted = Math.floor(player[from] / rate);
            player[to] += converted;
            player[from] %= rate;
        }
    });
}

        // 点击获取金币，限制每秒10次
        function clickGold() {
            const now = Date.now();
            // 移除超过1秒的点击记录
            player.clickTimestamps = player.clickTimestamps.filter(timestamp => now - timestamp < 1000);

            const clickLimit = 10 + player.reincarnationStats.clickLimitBonus.level; // 每级增加1次点击上限
            if (player.clickTimestamps.length >= clickLimit) {
                logAction("点击速度过快，请稍后再试！", "error");
                return;
            }

            player.clickTimestamps.push(now);

            const value = getTotalClickValue();
            player.gold += value;
            logAction(`点击获取金币: +${value}`, 'info');
            updateDisplay();
        }

        function buyChest(type) {
    const costConfig = [
        { currency: "gold", amount: 100 },
        { currency: "diamond", amount: 10 },
        { currency: "titanium", amount: 1 },
        { currency: "starstone", amount: 1 },
        { currency: "cosmicstone", amount: 1 },
        { currency: "superstone", amount: 1 }, 
        { currency: "otherworldstone", amount: 1 }, 
        { currency: "xingjiestone", amount: 1 },
        { currency: "hundunstone", amount: 1 },
        { currency: "lingtone", amount: 1 }, 
        { currency: "huangtone", amount: 1 },
        { currency: "mingtone", amount: 1 }, 
        { currency: "xutong", amount: 1 }, 
        { currency: "shitone", amount: 1 },
        { currency: "weitone", amount: 1 }       
    ][type - 1];

    if (player[costConfig.currency] >= costConfig.amount) {
        player[costConfig.currency] -= costConfig.amount;
        const selectedRarity = selectRarity(type);
        console.log(`购买宝箱类型: ${type}, 掉落装备品质: ${selectedRarity}`); // 调试信息
        handleEquipment(selectedRarity);

        // 更新宝箱购买计数
        const chestType = ['common', 'advanced', 'rare', 'epic', 'legendary', 'chaos', 'apocalypse', 'yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6', 'yeyu7', 'yeyu8'][type - 1];
        player.chestCounts[chestType]++;
        checkChestAchievements(chestType, player.chestCounts[chestType]);
    } else {
        logAction(`${costConfig.currency}不足！无法购买${['普通','高级','稀有','史诗','传说','混沌','终焉','星辰','银河','星云','鸿蒙','太虚', '虚空', '时空', '未来'][type-1]}宝箱`, 'error');
    }
    updateDisplay();
}

        // 检查宝箱成就
        function checkChestAchievements(chestType, count) {
    const achievements = [
        { count: 100, key: `${chestType}_chest_100` },
        { count: 10000, key: `${chestType}_chest_10000` },
        { count: 1000000, key: `${chestType}_chest_1000000` },
        { count: 10000000, key: `${chestType}_chest_10000000` },
        { count: 100000000, key: `${chestType}_chest_100000000` }
    ];

    achievements.forEach(({ count: targetCount, key }) => {
        if (count >= targetCount && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updateAchievementsDisplay();
            }
        }
    });
}

        function buyMaterialChest() {
    const cost = player.materialChestCost;
    if (player.diamond >= cost) {
        player.diamond -= cost;
        const selectedItem = selectMaterialChestItem();
        
        if (selectedItem.type in player.collections) {
            player.collections[selectedItem.type]++;
            onCollectionAdded(selectedItem.type); // 应用效果
            logAction(`获得收藏物：${collectionEffects[selectedItem.type].name}`, 'success');
            updateCollectionDisplay(); // 更新收藏物页面
        } else if (selectedItem.type in player.items) {
            player.items[selectedItem.type]++;
            logAction(`获得道具：${itemEffects[selectedItem.type].name}`, 'success');
            updateItemDisplay(); // 更新道具页面
        }
// 新增：处理VIP能力值道具
        else if (selectedItem.type === 'vipPower') {
            handleVipPowerGain(); // 调用VIP能力值处理函数
        }
        // 更新材料宝箱购买成本
             player.materialChestCost *= 2;
            updateDisplay();
      }   else {
        logAction("钻石不足！无法购买材料宝箱", "error");
    }
}
     function buyTechniqueChest() {
    const cost = player.techniqueChestCost;
    if (player.reincarnationCoin >= cost) {
        player.reincarnationCoin -= cost;
        player.techniqueChestCost *= 2;  // 下次消耗翻倍
        player.techniqueChestLevel++;
        
        // 根据概率随机选择功法
        const roll = Math.random();
        let cumulativeProb = 0;
        
        for (const drop of techniqueChestDrops) {
            cumulativeProb += drop.prob;
            if (roll <= cumulativeProb) {
                addTechnique(drop.id);
                break;
            }
        }
        
        logAction("打开了功法秘笈宝箱！", "success");
        updateDisplay();
    } else {
        logAction("转生币不足！", "error");

    }
}
   // 初始化或重置时调用
function resetAllCollectionEffects() {
    // 重置所有装备的收藏物加成
    player.equipment.forEach(eq => {
        eq.collectionMultiplier = 0;
    });
    
    // 重新应用所有收藏物效果
    applyAllCollectionEffects();
}

// 应用所有收藏物效果
function applyAllCollectionEffects() {
    // 先重置所有效果
    player.equipment.forEach(eq => {
        eq.collectionMultiplier = 0;
    });
    
    // 累加所有收藏物效果
    Object.entries(player.collections).forEach(([type, count]) => {
        if(count > 0) {
            const effect = collectionEffects[type].effect * count;
            player.equipment.forEach(eq => {
                eq.collectionMultiplier += effect;
            });
        }
    });
    
    updateCollectionDisplay();
}

// 获得新收藏物时调用
function onCollectionAdded(collectionType) {
    const effect = collectionEffects[collectionType].effect;
    player.equipment.forEach(eq => {
        eq.collectionMultiplier += effect;
    });
    updateCollectionDisplay();
}


        // 选择材料宝箱掉落物品
        function selectMaterialChestItem() {
            let totalProb = materialChestProbabilities.reduce((sum, p) => sum + p.prob, 0);
            let rand = Math.random() * totalProb;
            for (const { type, prob } of materialChestProbabilities) {
                if (rand < prob) return { type };
                rand -= prob;
            }
            return { type: 'lightSpeedHand' }; // 默认掉落
        }

        function selectRarity(type) {
    const probConfig = chestProbabilities[type];
    let totalProb = probConfig.reduce((sum, p) => sum + p.prob, 0);
    let rand = Math.random() * totalProb;
    for (const { rarity, prob } of probConfig) {
        if (rand < prob) return validateRarity(rarity);
        rand -= prob;
    }
    return 'common';
}

        function handleEquipment(rarity) {
    const existingIndex = player.equipment.findIndex(eq => eq.rarity === rarity);
    if (existingIndex >= 0) {
        upgradeExistingEquipment(existingIndex, rarity);
    } else {
        addNewEquipment(rarity);
    }
    checkAchievement(rarity);
}

        function upgradeExistingEquipment(index, rarity) {
            const eq = player.equipment[index];
            const config = equipmentTypes[rarity];
            eq.level++;
            const vipBonus = 1 + getVipBonus();
            eq.gps = safeNumber(config.gps * (1 + (config.growthRate * eq.level*0.01)) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%
            eq.click = safeNumber(config.click * (1 + (config.growthRate * eq.level*0.01)) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%

        }

        function addNewEquipment(rarity) {
            const config = equipmentTypes[rarity] || equipmentTypes.common;
            const newEq = {
                name: config.name,
                gps: config.gps * (1 + player.reincarnationStats.gpsBonus.level), // 每级装备属性乘以100%
                click: config.click * (1 + player.reincarnationStats.gpsBonus.level), // 每级装备属性乘以100%
                rarity: rarity,
                level: 1 + player.reincarnationStats.equipmentLevelBonus.level * 200, // 转生属性加成
                growthRate: config.growthRate,
                gemMultiplier: 0,
                collectionMultiplier: 0
            };
            player.equipment.push(newEq);
            logAction(`获得 ${newEq.name}装备`, rarity);
        }

        function upgradeEquipment(index) {
            const eq = player.equipment[index];
            const cost = Math.floor(100 * Math.pow(1.5, eq.level));
            if (player.gold >= cost) {
                player.gold -= cost;
                eq.level++;
                const vipBonus = 1 + getVipBonus();
                eq.gps = safeNumber(eq.gps * (1 + eq.growthRate) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%
                eq.click = safeNumber(eq.click * (1 + eq.growthRate) * (1 + player.reincarnationStats.gpsBonus.level)* vipBonus); // 每级装备属性乘以100%
                logAction(`主动升级 ${eq.name}装备 至 Lv.${eq.level}`, eq.rarity);
                updateDisplay();
              updateVipDisplay();
            } else {
                logAction("金币不足！", "error");
            }
        }

        // 自动购买逻辑
       function checkAutoBuy() {
    const speedMultiplier = player.autoBuySpeedBoost ? 600 : 1;
    player.autoBuy.forEach((enabled, index) => {
        if (enabled) {
            const type = index + 1;
            const costConfig = [
                { currency: "gold", amount: 100 },
                { currency: "diamond", amount: 10 },
                { currency: "titanium", amount: 1 },
                { currency: "starstone", amount: 1 },
                { currency: "cosmicstone", amount: 1 },
                { currency: "superstone", amount: 1 },
                { currency: "otherworldstone", amount: 1 },
                { currency: "xingjiestone", amount: 1 },
                { currency: "hundunstone", amount: 1 },
                { currency: "lingtone", amount: 1 },
                { currency: "huangtone", amount: 1 },
                { currency: "mingtone", amount: 1 },
                { currency: "xutong", amount: 1 },
                { currency: "shitone", amount: 1 },
                { currency: "weitone", amount: 1 }              
            ][index];
            
            if (player[costConfig.currency] >= costConfig.amount) {
                // 计算最大可购买数量（最多1000个）
                const maxBuy = Math.min(speedMultiplier, (100+player.cultivation.stage * 3));
                const affordable = Math.floor(player[costConfig.currency] / costConfig.amount);
                const actualBuy = Math.min(maxBuy, affordable);
                
                if (actualBuy > 0) {
                    // 批量扣除货币
                    player[costConfig.currency] -= actualBuy * costConfig.amount;
                    
                    // 统计装备升级总级数
                    let totalLevelsUp = 0;
                    const chestTypeName = ['普通','高级','稀有','史诗','传说','混沌','终焉','星辰','银河','星云','鸿蒙','太虚', '虚空', '时空', '未来'][index];
                    
                    // 批量处理装备获取并统计升级计数
                    for (let i = 0; i < actualBuy; i++) {
                        const selectedRarity = selectRarity(type);
                        // 临时修改handleEquipment，使其返回升级的级数
                        const levelsUp = handleEquipment(selectedRarity);
                        totalLevelsUp += levelsUp;
                    }
                    
                    // 更新宝箱计数
                    const chestType = ['common', 'advanced', 'rare', 'epic', 'legendary', 'chaos', 'apocalypse', 'yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6', 'yeyu7', 'yeyu8'][index];
                    player.chestCounts[chestType] += actualBuy;
                    checkChestAchievements(chestType, player.chestCounts[chestType]);
                    
                    // 统一记录日志
                    logAction(`自动购买${chestTypeName}宝箱 x${actualBuy},${name}`, 'success');
                    updateDisplay();
                }
            }
        }
    });
if (player.autoBuyTechniqueChest && player.reincarnationCoin >= player.techniqueChestCost) {
       // 检查价格是否超过上限
        if (player.techniqueChestCost <= player.autoBuyTechniqueMaxCost) {
            buyTechniqueChest();
        } else {
            // 可选: 记录日志或通知玩家
           player.autoBuyTechniqueChest = false;
            logAction("功法秘籍宝箱价格超过上限，停止自动购买", "info");
        }
    }

    

    // 新增：自动购买材料宝箱
    if (player.autoBuyMaterialChest && player.diamond >= player.materialChestCost) {
        buyMaterialChest();
    }
}

        // 切换自动购买状态
        function toggleAutoBuy(typeIndex) {
    const index = typeIndex - 1; // 将宝箱类型转换为数组索引
    player.autoBuy[index] = !player.autoBuy[index]; // 切换状态
    const btn = document.getElementById(`autoChest${typeIndex}`);
    btn.textContent = `${['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'][index]}宝箱自动购买：${player.autoBuy[index] ? '开启' : '关闭'}`;
    logAction(`${player.autoBuy[index] ? '开启' : '关闭'}自动购买${['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'][index]}宝箱`, 'info');
}

        // 切换自动购买材料宝箱状态
        function toggleAutoBuyMaterialChest() {
    player.autoBuyMaterialChest = !player.autoBuyMaterialChest;
    const btn = document.getElementById('autoMaterialChest');
    btn.textContent = `材料宝箱自动购买：${player.autoBuyMaterialChest ? '开启' : '关闭'}`;
    logAction(`${player.autoBuyMaterialChest ? '开启' : '关闭'}自动购买材料宝箱`, 'info');
}
  function toggleAutoBuyTechniqueChest() {
    player.autoBuyTechniqueChest = !player.autoBuyTechniqueChest;
    const btn = document.getElementById('autoTechniqueChest');
    btn.textContent = `功法秘籍宝箱自动购买：${player.autoBuyTechniqueChest ? '开启' : '关闭'}`;
    logAction(`${player.autoBuyTechniqueChest ? '开启' : '关闭'}功法秘籍宝箱自动购买`, 'info');
}
     function toggleOnlineBoost() {
    player.onlineBoostEnabled = !player.onlineBoostEnabled;
    const btn = document.getElementById('toggleOnlineBoost');
    if (btn) btn.textContent = `在线金币加速100倍: ${player.onlineBoostEnabled ? '开启' : '关闭'}`;
    var olbl = document.getElementById('onlineBoostLabel');
    if (olbl) olbl.textContent = player.onlineBoostEnabled ? '开' : '关';
    logAction(`${player.onlineBoostEnabled ? '开启' : '关闭'}在线金币100倍加速`, 'info');
}
     function toggleAutoBuySpeedBoost() {
    player.autoBuySpeedBoost = !player.autoBuySpeedBoost;
    const btn = document.getElementById('autoBuySpeedBoost');
     if (btn) btn.textContent = `在线自动购买100倍数量：${player.autoBuySpeedBoost ? '开启' : '关闭'}`;
    var olbl = document.getElementById('autoBuySpeedLabel');
     if (olbl) olbl.textContent = player.autoBuySpeedBoost ? '开' : '关';
    logAction(`${player.autoBuySpeedBoost ? '开启' : '关闭'}在线自动购买100倍数量`, 'info');
}

     // 根据存档同步侧栏「在线百倍购买/在线百倍加速/自动转生」显示，避免下线再上线显示为关
     function syncOnlineOptionLabels() {
         if (typeof player === 'undefined') return;
         var lbl = document.getElementById('autoBuySpeedLabel');
         if (lbl) lbl.textContent = player.autoBuySpeedBoost ? '开' : '关';
         var olbl = document.getElementById('onlineBoostLabel');
         if (olbl) olbl.textContent = player.onlineBoostEnabled ? '开' : '关';
         var reincLbl = document.getElementById('autoReincarnationStatus');
         if (reincLbl) reincLbl.textContent = player.autoReincarnation ? '开启' : '关闭';
     }

     // 根据存档同步「在线自动购买」面板内所有宝箱/材料/功法按钮显示，打开面板时调用
     function syncAutoBuyPanelDisplay() {
         if (typeof player === 'undefined' || !player.autoBuy) return;
         var names = ['普通', '高级', '稀有', '史诗', '传说', '混沌', '终焉', '星辰', '银河', '星云', '鸿蒙', '太虚', '虚空', '时空', '未来'];
         player.autoBuy.forEach(function(enabled, index) {
             var btn = document.getElementById('autoChest' + (index + 1));
             if (btn) btn.textContent = names[index] + '宝箱自动购买：' + (enabled ? '开启' : '关闭');
         });
         var materialBtn = document.getElementById('autoMaterialChest');
         if (materialBtn) materialBtn.textContent = '材料宝箱自动购买：' + (player.autoBuyMaterialChest ? '开启' : '关闭');
         var techniqueBtn = document.getElementById('autoTechniqueChest');
         if (techniqueBtn) techniqueBtn.textContent = '功法秘籍宝箱自动购买：' + (player.autoBuyTechniqueChest ? '开启' : '关闭');
     }

     // 添加更新自动兑换货币显示的函数
function updateAutoConvertDisplay() {
    const currencies = ['gold', 'diamond', 'titanium', 'starstone', 'cosmicstone', 
                        'superstone', 'otherworldstone', 'xingjiestone', 'hundunstone', 
                        'lingtone', 'huangtone', 'mingtone', 'xutong', 'shitone', 'weitone'];
    
    currencies.forEach(currency => {
        const btn = document.getElementById(`autoConvert${currency.charAt(0).toUpperCase() + currency.slice(1)}`);
        if (btn) {
            btn.textContent = `${getCurrencyName(currency)}自动兑换：${player.autoConvertCurrency[currency] ? '开启' : '关闭'}`;
        }
    });
}

// 辅助函数：获取货币中文名称
function getCurrencyName(currency) {
    const names = {
        gold: '金币',
        diamond: '钻石',
        titanium: '钛晶石',
        starstone: '星耀石',
        cosmicstone: '宇宙石',
        superstone: '超能石',
        otherworldstone: '异界石',
        xingjiestone: '星界石',
        hundunstone: '混沌石',
        lingtone: '灵髓石',
        huangtone: '幻空石',
        mingtone: '冥源石',
        xutong: '虚空石',
        shitone: '时空石',
        weitone: '未来石'      
    };
    return names[currency] || currency;
}

// 修改切换函数，确保更新显示
function toggleAutoConvertCurrency(currency) {
    player.autoConvertCurrency[currency] = !player.autoConvertCurrency[currency];
    
    // 更新按钮显示
    const btn = document.getElementById(`autoConvert${currency.charAt(0).toUpperCase() + currency.slice(1)}`);
    if (btn) {
        btn.textContent = `${getCurrencyName(currency)}自动兑换：${player.autoConvertCurrency[currency] ? '开启' : '关闭'}`;
    }
    
    logAction(`${getCurrencyName(currency)}自动兑换${player.autoConvertCurrency[currency] ? '开启' : '关闭'}`, 'info');
}
        // 成就检查
        function checkAchievement(rarity) {
    if (!player.achievements[rarity]) {
        player.achievements[rarity] = true;
        const reward = achievementRewards[rarity];
        if (reward) {
            player.gpsMultiplier += reward.gpsMultiplier;
            logAction(`成就达成：获得${equipmentTypes[rarity].name}装备，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
            updateAchievementsDisplay();
        }
    }
}

        // 更新成就显示
       function updateAchievementsDisplay() {
    const achievementsContainer = document.getElementById('achievements');
    const unlockedAchievements = Object.entries(player.achievements)
        .filter(([key, unlocked]) => unlocked)
        .map(([key]) => key);

    // 定义排序优先级
    const achievementOrder = [
     'common', 'rare', 'epic', 'legendary',
     'ancient', 'divine', 'arcane', 'celestial',
     'infernal', 'astral', 'primeval', 'transcendental',
     'quantum', 'ultimate', 'chaos', 'eternal',
     'void', 'genesis', 'divineRealm', 'apocalypse', 'yeyu1', 'yeyu2', 'yeyu3', 'yeyu4', 'yeyu5', 'yeyu6','yeyu7', 'yeyu8', 'yeyu9', 'yeyu10', 'yeyu11', 'yeyu12','yeyu13', 'yeyu14', 'yeyu15', 'yeyu16', 'yeyu17', 'yeyu18','yeyu19', 'yeyu20', 'yeyu21', 'yeyu22', 'yeyu23', 'yeyu24', 
    'common_chest_100',
    'common_chest_10000',
    'common_chest_1000000',
    'common_chest_10000000',
    'common_chest_100000000',
    'advanced_chest_100',
    'advanced_chest_10000',
    'advanced_chest_1000000',
    'advanced_chest_10000000',
    'advanced_chest_100000000',
    'rare_chest_100',
    'rare_chest_10000',
    'rare_chest_1000000',
    'rare_chest_10000000',
    'rare_chest_100000000',
    'epic_chest_100',
    'epic_chest_10000',
    'epic_chest_1000000',
    'epic_chest_10000000',
    'epic_chest_100000000',
    'legendary_chest_100',
    'legendary_chest_10000',
    'legendary_chest_1000000',
    'legendary_chest_10000000',
    'legendary_chest_100000000',
    'chaos_chest_100',
    'chaos_chest_10000',
    'chaos_chest_1000000',
    'chaos_chest_10000000',
    'chaos_chest_100000000',
    'apocalypse_chest_100',
    'apocalypse_chest_10000',
    'apocalypse_chest_1000000',
    'apocalypse_chest_10000000',
    'apocalypse_chest_100000000',
    'yeyu1_chest_100',
    'yeyu1_chest_10000',
    'yeyu1_chest_1000000',
    'yeyu1_chest_10000000',
    'yeyu1_chest_100000000',
    'yeyu2_chest_100',
    'yeyu2_chest_10000',
    'yeyu2_chest_1000000',
    'yeyu2_chest_10000000',
    'yeyu2_chest_100000000',
    'yeyu3_chest_100',
    'yeyu3_chest_10000',
    'yeyu3_chest_1000000',
    'yeyu3_chest_10000000',
    'yeyu3_chest_100000000',
    'yeyu4_chest_100',
    'yeyu4_chest_10000',
    'yeyu4_chest_1000000',
    'yeyu4_chest_10000000',
    'yeyu4_chest_100000000',
    'yeyu5_chest_100',
    'yeyu5_chest_10000',
    'yeyu5_chest_1000000',
    'yeyu5_chest_10000000',
    'yeyu5_chest_100000000',
    'yeyu6_chest_100',
    'yeyu6_chest_10000',
    'yeyu6_chest_1000000',
    'yeyu6_chest_10000000',
    'yeyu6_chest_100000000',
    'yeyu7_chest_100',
    'yeyu7_chest_10000',
    'yeyu7_chest_1000000',
    'yeyu7_chest_10000000',
    'yeyu7_chest_100000000',
    'yeyu8_chest_100',
    'yeyu8_chest_10000',
    'yeyu8_chest_1000000',
    'yeyu8_chest_10000000',
    'yeyu8_chest_100000000',
  'max_stage_10', 'max_stage_30', 'max_stage_60', 'max_stage_90',
   'max_stage_120', 'max_stage_200', 'max_stage_300', 'max_stage_400',
   'max_stage_500', 'max_stage_600', 'max_stage_700', 'max_stage_800',
   'max_stage_900', 'max_stage_1000',
 'thunderKirin_10',
    'thunderKirin_50',
    'thunderKirin_100',
    'chaosTaotie_10',
    'chaosTaotie_50',
    'chaosTaotie_100',
    'netherQiongqi_10',
    'netherQiongqi_50',
    'netherQiongqi_100',
    'abyssKun_10',
    'abyssKun_50',
    'abyssKun_100',
    'primordialZhuLong_10',
    'primordialZhuLong_50',
    'primordialZhuLong_100',
    'wanJunSuanNi_10',
    'wanJunSuanNi_50',
    'wanJunSuanNi_100',
    'yanYuBiAn_10',
    'yanYuBiAn_50',
    'yanYuBiAn_100',
    'yuyu1_10',
    'yuyu1_50',
    'yuyu1_100',
    'yuyu2_10',
    'yuyu2_50',
    'yuyu2_100',
    'yuyu3_10',
    'yuyu3_50',
    'yuyu3_100',
    'yuyu4_10',
    'yuyu4_50',
    'yuyu4_100',
    'yuyu5_10',
    'yuyu5_50',
    'yuyu5_100',
    'yuyu6_10',
    'yuyu6_50',
    'yuyu6_100',
    'yuyu7_10',
    'yuyu7_50',
    'yuyu7_100',
    'yuyu8_10',
    'yuyu8_50',
    'yuyu8_100',
     'year1_10',
    'year10_10',
    'year100_10',
    'year1000_10',
    'year10000_10',
    'year100000_10',
    'year1000000_10',
    'year10000000_10',
    'year100000000_10',
    'year1_100',
    'year10_100',
    'year100_100',
    'year1000_100',
    'year10000_100',
    'year100000_100',
    'year1000000_100',
    'year10000000_100',
    'year100000000_100',
    'year1_1000',
    'year10_1000',
    'year100_1000',
    'year1000_1000',
    'year10000_1000',
    'year100000_1000',
    'year1000000_1000',
    'year10000000_1000',
    'year100000000_1000',
    'year1_10000',
    'year10_10000',
    'year100_10000',
    'year1000_10000',
    'year10000_10000',
    'year100000_10000',
    'year1000000_10000',
    'year10000000_10000',
    'year100000000_10000',
    'year2_10',
    'year2_100',
    'year2_1000',
    'year2_10000',
    'year3_10',
    'year3_100',
    'year3_1000',
    'year3_10000',
    'year4_10',
    'year4_100',
    'year4_1000',
    'year4_10000',
    'year5_10',
    'year5_100',
    'year5_1000',
    'year5_10000',
    'year6_10',
    'year6_100',
    'year6_1000',
    'year6_10000',
    'year7_10',
    'year7_100',
    'year7_1000',
    'year7_10000',
    'year8_10',
    'year8_100',
    'year8_1000',
    'year8_10000',
    'year9_10',
    'year9_100',
    'year9_1000',
    'year9_10000',
    'year11_10',
    'year11_100',
    'year11_1000',
    'year11_10000',
    'year12_10',
    'year12_100',
    'year12_1000',
    'year12_10000',
    'year13_10',
    'year13_100',
    'year13_1000',
    'year13_10000',
    'year14_10',
    'year14_100',
    'year14_1000',
    'year14_10000',
    'year15_10',
    'year15_100',
    'year15_1000',
    'year15_10000',
    'year16_10',
    'year16_100',
    'year16_1000',
    'year16_10000',
    'year17_10',
    'year17_100',
    'year17_1000',
    'year17_10000',
    'year18_10',
    'year18_100',
    'year18_1000',
    'year18_10000',
    'year19_10',
    'year19_100',
    'year19_1000',
    'year19_10000',
    'year20_10',
    'year20_100',
    'year20_1000',
    'year20_10000',
    'year21_10',
    'year21_100',
    'year21_1000',
    'year21_10000',
    'year22_10',
    'year22_100',
    'year22_1000',
    'year22_10000',
    'year23_10',
    'year23_100',
    'year23_1000',
    'year23_10000',
    'year24_10',
    'year24_100',
    'year24_1000',
    'year24_10000',
    'year25_10',
    'year25_100',
    'year25_1000',
    'year25_10000',
    'year26_10',
    'year26_100',
    'year26_1000',
    'year26_10000',
    'year27_10',
    'year27_100',
    'year27_1000',
    'year27_10000',
    'year28_10',
    'year28_100',
    'year28_1000',
    'year28_10000',
    'year29_10',
    'year29_100',
    'year29_1000',
    'year29_10000',
    'year30_10',
    'year30_100',
    'year30_1000',
    'year30_10000',
    'year31_10',
    'year31_100',
    'year31_1000',
    'year31_10000',
    'year32_10',
    'year32_100',
    'year32_1000',
    'year32_10000',
    'year33_10',
    'year33_100',
    'year33_1000',
    'year33_10000',
    'year34_10',
    'year34_100',
    'year34_1000',
    'year34_10000',
    'year35_10',
    'year35_100',
    'year35_1000',
    'year35_10000',
    'year36_10',
    'year36_100',
    'year36_1000',
    'year36_10000',
    'year37_10',
    'year37_100',
    'year37_1000',
    'year37_10000',
   'reincarnation_10', 'reincarnation_100', 
   'reincarnation_1000', 'reincarnation_10000', 'world_boss_1st', 'world_boss_top5', 'world_boss_top10', 'world_boss_participant'
    ];

    // 按定义顺序过滤并排序已解锁成就
    const sortedAchievements = achievementOrder
        .filter(key => unlockedAchievements.includes(key))
        .map(key => ({
            key,
            ...achievementRewards[key]
        }));

    achievementsContainer.innerHTML = Object.entries(player.achievements)
        .filter(([key, value]) => value && achievementRewards[key]) // 只显示已解锁的成就
        .map(([key, value]) => {
            const reward = achievementRewards[key];
            return `<div class="achievement unlocked">${reward.description}</div>`;
        })
        .join('');
}

        // 切换装备、道具和收藏物页面
        function switchTab(tab) {
            document.getElementById('equipmentList').style.display = tab === 'equipment' ? 'block' : 'none';
            document.getElementById('itemList').style.display = tab === 'items' ? 'block' : 'none';
            document.getElementById('collectionList').style.display = tab === 'collections' ? 'block' : 'none';
            document.getElementById('reincarnationList').style.display = tab === 'reincarnation' ? 'block' : 'none';
            document.getElementById('petList').style.display = tab === 'pets' ? 'block' : 'none';
            document.getElementById('stockList').style.display = tab === 'stocks' ? 'block' : 'none';
            document.getElementById('lotteryList').style.display = tab === 'lottery' ? 'block' : 'none';
            document.getElementById('bankList').style.display = tab === 'bank' ? 'block' : 'none';
            document.getElementById('dungeonEquipmentList').style.display = tab === 'dungeonEquipment' ? 'block' : 'none'; // 新增副本装备页面
            document.getElementById('soulRingList').style.display = tab === 'soulRings' ? 'block' : 'none'; // 新增魂环页面
            document.getElementById('playerAttributesList').style.display = tab === 'playerAttributes' ? 'block' : 'none';
            document.getElementById('techniquesList').style.display = tab === 'techniques' ? 'block' : 'none';
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            var oldTab = document.querySelector(`.tab[onclick="switchTab('${tab}')"]`);
            if (oldTab) oldTab.classList.add('active');
            document.querySelectorAll('.tab-item-new').forEach(t => t.classList.remove('active'));
            var newTab = document.querySelector(`.tab-item-new[onclick="switchTab('${tab}')"]`);
            if (newTab) newTab.classList.add('active');
            if (tab === 'items') updateItemDisplay();
            if (tab === 'collections') updateCollectionDisplay();
            if (tab === 'reincarnation') updateReincarnationDisplay();
            if (tab === 'pets') updatePetDisplay();
            if (tab === 'stocks') updateStockDisplay();
            if (tab === 'bank') updateBankDisplay();
            if (tab === 'dungeonEquipment') updateDungeonEquipmentDisplay(); // 新增：更新副本装备显示
            if (tab === 'soulRings') updateSoulRingDisplay(); // 新增：更新魂环显示
            if (tab === 'techniques') updateTechniquesDisplay();
            if (tab === 'playerAttributes') updatePlayerAttributesDisplay();
        }

        // 更新道具显示
        function updateItemDisplay() {
            const itemContainer = document.getElementById('itemList');
            itemContainer.innerHTML = Object.entries(player.items)
                .map(([key, value]) => {
                    const item = itemEffects[key];
                    return `<div>${item.name}: ${value} - ${item.description}</div>`;
                })
                .join('');
        }

       // 重置收藏物显示
function resetCollectionDisplay() {
resetCollectionEffects();
    logAction("已完全重置收藏物效果计算", "success");
}
    // 重新计算所有收藏物效果（确保加法叠加）
    Object.keys(player.collections).forEach(collectionType => {
        const effect = collectionEffects[collectionType].effect;
        const count = player.collections[collectionType];
        const totalEffect = count * effect;
        
        player.equipment.forEach(eq => {
            eq.collectionMultiplier = totalEffect;
        });
    });
    
    updateCollectionDisplay();
    logAction("已重置收藏物效果计算", "info");

// 更新后的收藏物显示函数
function updateCollectionDisplay() {
    const container = document.getElementById("collectionInfoContainer");
    
    // 计算全部收藏物总加成
    const totalEffect = player.equipment.length > 0 ? 
        player.equipment[0].collectionMultiplier * 100 : 0;
    
    // 顶部总加成显示（保持不变）
    container.innerHTML = `
        <div style="margin-bottom: 15px; font-weight: bold;">
            当前全部收藏物总加成: +${totalEffect.toFixed(0)}%
        </div>
    `;
    
    // 每个收藏物的详细显示（增加总效果）
    container.innerHTML += Object.entries(player.collections)
        .map(([key, value]) => {
            const collection = collectionEffects[key];
            const singleEffect = collection.effect * 100;
            const totalEffect = value * singleEffect;
            
            return `
                <div style="margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #eee;">
                    <strong>${collection.name}</strong>: 
                    <span>数量: ${value}</span> | 
                    <span>单个效果: +${singleEffect.toFixed(0)}%</span> |
                    <span>总效果: +${totalEffect.toFixed(0)}%</span>
                    <div style="color:#666; font-size:0.9em; margin-top: 3px;">${collection.description}</div>
                </div>
            `;
        })
        .join('');
}
        // 更新转生属性显示
        function updateReincarnationDisplay() {
    const reincarnationContainer = document.getElementById('reincarnationList');
    reincarnationContainer.innerHTML = `
        <div>
            <h3>转生属性</h3>
            <div>
                <strong>收益加成</strong>: 每级装备属性 +${player.reincarnationStats.gpsBonus.level * 100}% (等级: ${player.reincarnationStats.gpsBonus.level})
                <button onclick="upgradeReincarnationStat('gpsBonus')">升级 (消耗 ${player.reincarnationStats.gpsBonus.cost.toFixed(0)} 转生币)</button>
            </div>
            <div>
                <strong>装备等级</strong>: 全部装备初始等级 +${player.reincarnationStats.equipmentLevelBonus.level * 200} 级 (等级: ${player.reincarnationStats.equipmentLevelBonus.level})
                <button onclick="upgradeReincarnationStat('equipmentLevelBonus')">升级 (消耗 ${player.reincarnationStats.equipmentLevelBonus.cost.toFixed(0)} 转生币)</button>
            </div>
            <div>
                <strong>点击上限</strong>: 每秒点击上限 +${player.reincarnationStats.clickLimitBonus.level} 次 (等级: ${player.reincarnationStats.clickLimitBonus.level})
                <button onclick="upgradeReincarnationStat('clickLimitBonus')">升级 (消耗 ${player.reincarnationStats.clickLimitBonus.cost.toFixed(0)} 转生币)</button>
            </div>
        </div>
    `;
}
   function updateTechniquesDisplay() {
    const container = document.getElementById('techniquesContainer');
    
    // 按预定顺序筛选已获得的功法
    const sortedTechniques = TECHNIQUE_DISPLAY_ORDER
        .filter(id => player.techniques[id])
        .map(id => {
            const tech = techniqueConfig[id];
            return {
                id,
                name: tech.name,
                level: player.techniques[id],
                description: tech.description,
                effect: tech.effect,
                type: tech.type
            };
        });

    // 生成HTML
    container.innerHTML = sortedTechniques.map(tech => `
        <div class="technique ${tech.type}">
            <h4>${tech.name} [Lv.${tech.level}]</h4>
            <p>${tech.description}</p>
            <div class="tech-effect">
                当前效果: ${
                    tech.type === 'multiAttack' 
                        ? `攻击次数+${tech.level * tech.effect}`
                        : `${(tech.level * tech.effect * 100).toFixed(tech.type === 'critRate' ? 4 : 4)}%`
                }
            </div>
        </div>
    `).join('');
}

// 添加功法秘笈获取函数
function addTechnique(type) {
    if (player.techniques[type]) {
        player.techniques[type]++;
    } else {
        player.techniques[type] = 1;
    }
    logAction(`获得功法: ${techniqueConfig[type].name} Lv.${player.techniques[type]}`, 'success');
    updateTechniqueBonuses(); // 新增调用
    updateTechniquesDisplay();
}

function calculateTechniqueBonuses() {
    const bonuses = {
        health: 0,
        attack: 0,
        critRate: 0,
        critDamage: 0,
        multiAttack: 0
    };

    // 计算所有功法加成
    Object.entries(player.techniques).forEach(([techId, level]) => {
        const tech = techniqueConfig[techId];
        if (tech && tech.effect) {
            // 获取宗门功法等级加成
            const sectLevel = player.sect.techniques[techId] || 0;
            const sectMultiplier = 1 + (sectLevel * 2); // 每级增加2倍效果
            
            // 应用宗门加成
            bonuses[tech.type] += level * tech.effect * sectMultiplier;
        }
    });

    return bonuses;
}
        // 重置宠物页面
function resetPetDisplay() {
    // 保留宠物的等级和升级成本
    const petData = {};
    Object.keys(player.pets).forEach(petKey => {
        petData[petKey] = {
            level: player.pets[petKey].level, // 保留等级
            cost: player.pets[petKey].cost    // 保留升级成本
        };
    });

    // 重置宠物页面（重新生成宠物数据）
    player.pets = {
        thunderKirin: { level: petData.thunderKirin?.level || 0, cost: petData.thunderKirin?.cost || 1, multiplier: 0.10 },
        chaosTaotie: { level: petData.chaosTaotie?.level || 0, cost: petData.chaosTaotie?.cost || 1, multiplier: 0.30 },
        netherQiongqi: { level: petData.netherQiongqi?.level || 0, cost: petData.netherQiongqi?.cost || 1, multiplier: 0.90 },
        abyssKun: { level: petData.abyssKun?.level || 0, cost: petData.abyssKun?.cost || 1, multiplier: 2.70 },
        primordialZhuLong: { level: petData.primordialZhuLong?.level || 0, cost: petData.primordialZhuLong?.cost || 1, multiplier: 8.10 },
        wanJunSuanNi: { level: petData.wanJunSuanNi?.level || 0, cost: petData.wanJunSuanNi?.cost || 1, multiplier: 24.30 },
        yanYuBiAn: { level: petData.yanYuBiAn?.level || 0, cost: petData.yanYuBiAn?.cost || 1, multiplier: 72.90 },
       yuyu1: { level: petData.yuyu1?.level || 0, cost: petData.yuyu1?.cost || 1, multiplier: 218.70 },
        yuyu2: { level: petData.yuyu2?.level || 0, cost: petData.yuyu2?.cost || 1, multiplier: 656.10 },
       yuyu3: { level: petData.yuyu3?.level || 0, cost: petData.yuyu3?.cost || 1, multiplier: 1968.30 },
        yuyu4: { level: petData.yuyu4?.level || 0, cost: petData.yuyu4?.cost || 1, multiplier: 5904.90 },
       yuyu5: { level: petData.yuyu5?.level || 0, cost: petData.yuyu5?.cost || 1, multiplier: 17714.70 },
       yuyu6: { level: petData.yuyu6?.level || 0, cost: petData.yuyu6?.cost || 1, multiplier: 53144.10 },
        yuyu7: { level: petData.yuyu7?.level || 0, cost: petData.yuyu7?.cost || 1, multiplier: 159432.30 },
       yuyu8: { level: petData.yuyu8?.level || 0, cost: petData.yuyu8?.cost || 1, multiplier: 478296.90 }
    };

    // 更新宠物页面显示
    updatePetDisplay();
    logAction('宠物页面已重置，等级和升级消耗保留', 'success');
}

// 更新宠物页面显示
function updatePetDisplay() {
    const petContainer = document.getElementById('petContainer');
    if (!petContainer) {
        console.error('宠物容器未找到！');
        return;
    }
    
    // 货币类型到中文名称的映射
    const currencyNames = {
        gold: '金币',
        diamond: '钻石',
        titanium: '钛晶石',
        starstone: '星耀石',
        cosmicstone: '宇宙石',
        superstone: '超能石',
        otherworldstone: '异界石',
        xingjiestone: '星界石',
        hundunstone: '混沌石',
        lingtone: '灵髓石',
        huangtone: '幻空石',
        mingtone: '冥源石',
        xutong: '虚空石',
        shitone: '时空石',
        weitone: '未来石'  
    };
    
    petContainer.innerHTML = Object.entries(player.pets)
        .map(([key, pet]) => {
            const config = petConfig[key];
            if (!config) {
                console.error(`宠物配置未找到：${key}`);
                return '';
            }
            const cost = pet.cost;
            const formattedCost = cost >= 1e8 ? cost.toExponential(3) : cost.toLocaleString();
            
            // 获取货币中文名称
            const currencyName = currencyNames[config.currency] || config.currency;
            
            return `
                <div>
                    <strong>${config.name}</strong>: 等级 ${pet.level} - 装备属性加成 ${(pet.level * pet.multiplier * 100).toFixed(2)}%
                    <button onclick="upgradePet('${key}')">升级 (消耗 ${formattedCost} ${currencyName})</button>
                </div>
            `;
        })
        .join('');
}
    // 如果需要真正的重置功能（保留等级但刷新效果），可以添加这个函数
function resetTechniquesData() {
    showCustomConfirm('确定要重置功法数据吗？这将保留等级但重置所有效果计算！', (confirmed) => {
        if (confirmed) {
            // 重新计算所有功法效果
            updateTechniqueBonuses();
            updateTechniquesDisplay();
            logAction('功法数据已重置，效果重新计算', 'success');
        }
    });
}






   // 重置道具页面
function resetItemDisplay() {
    // 保留道具的数量
    const itemCounts = { ...player.items }; // 复制当前道具数量

    // 重置道具页面（重新生成道具数据）
    player.items = {
        primaryGem: itemCounts.primaryGem || 0,
        advancedGem: itemCounts.advancedGem || 0,
        superiorGem: itemCounts.superiorGem || 0,
        divineGem: itemCounts.divineGem || 0,
        vipPower: itemCounts.vipPower || 0,
        refineStone: itemCounts.refineStone || 0,
        rose: itemCounts.rose || 0,
        companionKey: itemCounts.companionKey || 0,
         rebornDan: itemCounts.rebornDan || 0,
      baitCount: itemCounts.baitCount || 0,
   rootDetector: itemCounts.rootDetector || 0,
 bloodlineDetector: itemCounts.bloodlineDetector || 0,
 advanceStone: itemCounts.advanceStone || 0, 
 primaryGemq: itemCounts.primaryGemq || 0, 
  zongmen: itemCounts.zongmen || 0, 
roseq: itemCounts.roseq || 0,
 yuzhou1: itemCounts.yuzhou1 || 0, 
  yuzhou2: itemCounts.yuzhou2 || 0, 
  yuzhou3: itemCounts.yuzhou3 || 0, 
  yuzhou4: itemCounts.yuzhou4 || 0,
  banlv1: itemCounts.banlv1 || 0,
  banlv2: itemCounts.banlv2 || 0,
  banlv3: itemCounts.banlv3 || 0,
  banlv4: itemCounts.banlv4 || 0,
  banlv5: itemCounts.banlv5 || 0,
  banlv6: itemCounts.banlv6 || 0,
  banlv7: itemCounts.banlv7 || 0,
  banlv8: itemCounts.banlv8 || 0,
  banlv9: itemCounts.banlv9 || 0,
  zhiye1: itemCounts.zhiye1 || 0,
  chiban1: itemCounts.chiban1 || 0,
  zuoqi1: itemCounts.zuoqi1 || 0,
  fuben1: itemCounts.fuben1 || 0,
  shenshou1: itemCounts.shenshou1 || 0,
 fuwen1: itemCounts.fuwen1 || 0,
  fuben2: itemCounts.fuben2 || 0,
  danyao1: itemCounts.danyao1 || 0,
  danyao2: itemCounts.danyao2 || 0,
  danyao3: itemCounts.danyao3 || 0,
  danyao4: itemCounts.danyao4 || 0,
  danyao5: itemCounts.danyao5 || 0,
  fubeng1: itemCounts.fubeng1 || 0,
  seed_herb1: itemCounts.seed_herb1 || 0,
seed_herb2: itemCounts.seed_herb2 || 0,
seed_herb3: itemCounts.seed_herb3 || 0,
seed_herb4: itemCounts.seed_herb4 || 0,
seed_herb5: itemCounts.seed_herb5 || 0
    };

    // 更新道具页面显示
    updateItemDisplay();
    logAction('道具页面已重置，道具数量保留', 'success');
}

// 更新道具页面显示
function updateItemDisplay() {
    const itemContainer = document.getElementById('itemContainer');
    if (!itemContainer) {
        console.error('道具容器未找到！');
        return;
    }
    itemContainer.innerHTML = Object.entries(player.items)
        .map(([key, value]) => {
            const item = itemEffects[key];
            if (!item) {
                console.error(`道具配置未找到：${key}`);
                return '';
            }
            return `
                <div>
                    <strong>${item.name}</strong>: ${value} - ${item.description}
                </div>
            `;
        })
        .join('');
}
 window.onload = function() {
    loadSave();
    if (typeof runTradingOfflineIfNeeded === 'function') runTradingOfflineIfNeeded();
    // 跑商：初始化主循环（更新城市价格、旅行状态）并启动自动贸易定时器
    if (player && player.reincarnationCount >= 1000) {
        if (!player.trading && typeof initTradingData === 'function') initTradingData();
        if (typeof initTradingSystem === 'function') initTradingSystem();
        if (player.trading && player.trading.autoTrade && player.trading.autoTrade.enabled && typeof startAutoTradeSystem === 'function') startAutoTradeSystem();
    }
      // 执行重置函数
    resetItemDisplay();
    resetPetDisplay();
    updateExplorationUI();
   updateDimensionUI();
    // 恢复自动扫荡状态显示
    document.getElementById('autoSweepStatus').textContent = 
        player.battle.autoSweepEnabled ? '开' : '关';
    
    // 如果自动扫荡是开启状态，重新启动
    if (player.battle.autoSweepEnabled) {
        startAutoSweep();
    }
};
        // 更新股票显示
        function updateStockDisplay() {
    const container = document.getElementById('stocksContainer');
    container.innerHTML = player.stockData.stocks.map((stock, index) => `
        <div class="stock-item" data-index="${index}" onclick="this.parentNode.querySelectorAll('.stock-item').forEach(e=>e.classList.remove('selected'));this.classList.add('selected')">
            <strong>${stock.name}</strong><br>
            当前价: ${stock.currentPrice.toFixed(2)} | 涨跌幅: ${((stock.currentPrice / stock.lastPrice - 1) * 100).toFixed(2)}%<br>
            持有: ${stock.shares}股 | 均价: ${stock.avgCost.toFixed(2)}<br>
            市值: ${(stock.shares * stock.currentPrice).toFixed(2)} | 收益率: ${stock.avgCost ? ((stock.currentPrice / stock.avgCost - 1) * 100).toFixed(2) + '%' : '-'}
        </div>
    `).join('');
}
/* 新手必看由顶栏「攻略」、更新日志由顶栏「日志」呼出，已移除原浮动按钮 */
        // 升级宠物
        function upgradePet(petKey) {
    const pet = player.pets[petKey];
    const config = petConfig[petKey];
    if (player[config.currency] >= pet.cost) {
        player[config.currency] -= pet.cost;
        pet.level++;
        pet.cost *= 2; // 每次升级成本翻倍

        // 检查宠物成就
        checkPetAchievements(petKey, pet.level);

        logAction(`升级 ${config.name} 成功！`, 'success');
        updatePetDisplay();
        updateDisplay();
    } else {
        logAction(`${config.currency}不足！`, "error");
    }
}

function checkPetAchievements(petKey, level) {
    const achievements = [
        { level: 10, key: `${petKey}_10` },
        { level: 50, key: `${petKey}_50` },
        { level: 100, key: `${petKey}_100` },
    ];

    achievements.forEach(({ level: targetLevel, key }) => {
        if (level >= targetLevel && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updateAchievementsDisplay();
            }
        }
    });
}

        // 升级转生属性
        function upgradeReincarnationStat(stat) {
            const statData = player.reincarnationStats[stat];
            if (player.reincarnationCoin >= statData.cost) {
                player.reincarnationCoin -= statData.cost;
                statData.level++;
                if (stat === 'equipmentLevelBonus') {
                    statData.cost *= 5; // 装备等级加成每次升级消耗增加5倍
                } else {
                    statData.cost *= 1.2; // 其他属性每次升级消耗增加20%
                }
                logAction(`升级 ${stat} 成功！`, 'success');
                updateReincarnationDisplay();
                updateDisplay();
            } else {
                logAction("转生币不足！", "error");
            }
        }

function resetGemEffects() {
    player.equipment.forEach(eq => {
        eq.gemMultiplier = 0;
    });
    logAction("已重置所有宝石效果", "info");
    updateDisplay();
}
        // 使用宝石升级装备
        function useGem(index, gemType) {
    const eq = player.equipment[index];
    const gem = itemEffects[gemType];
    
    if (player.items[gemType] > 0) {
        player.items[gemType]--;
        // 改为加法叠加
        eq.gemMultiplier += gem.effect;
        
        logAction(`使用${gem.name}升级 ${eq.name}装备 (当前加成: +${(eq.gemMultiplier * 100).toFixed(2)}%)`, 'success');
        updateDisplay();
    } else {
        logAction(`${gem.name}不足！`, "error");
    }
}
// 新增一键使用宝石函数
function useAllGems(index, gemType) {
    const eq = player.equipment[index];
    const gem = itemEffects[gemType];
    const count = player.items[gemType];
    
    if (count > 0) {
        // 计算总加成
        const totalEffect = gem.effect * count;
        // 减少宝石数量
        player.items[gemType] = 0;
        // 增加装备宝石加成
        eq.gemMultiplier += totalEffect;
        
        logAction(`一键使用${count}个${gem.name}升级 ${eq.name}装备 (当前总加成: +${(eq.gemMultiplier * 100).toFixed(2)}%)`, 'success');
        updateDisplay();
    } else {
        logAction(`${gem.name}不足！`, "error");
    }
}
        // 股票价格波动函数
        function updateStockPrices() {
            const now = Date.now();
            const elapsed = now - player.stockData.lastStockUpdate;
            const intervals = Math.floor(elapsed / (10 * 60 * 1000));

            player.stockData.stocks.forEach(stock => {
                for (let i = 0; i < intervals; i++) {
                    stock.lastPrice = stock.currentPrice;

                    // 计算当前价格与初始价格的比例
                    const priceRatio = stock.currentPrice / stock.basePrice;

                    // 根据比例动态调整涨跌概率
                    let riseProbability; // 涨的概率
                    if (priceRatio <= 0.7) {
                        riseProbability = 0.8; 
                    } else if (priceRatio <= 0.8) {
                        riseProbability = 0.7; 
                    } else if (priceRatio <= 0.9) {
                        riseProbability = 0.6; 
                    } else if (priceRatio >= 1.6) {
                        riseProbability = 0.35; 
                    } else if (priceRatio >= 1.8) {
                        riseProbability = 0.25; 
                    } else if (priceRatio >= 2.0) {
                        riseProbability = 0.1; 
                    } else {
                        riseProbability = 0.5;
                    }

                    // 根据涨跌概率决定价格波动
                    const willRise = Math.random() < riseProbability; // 是否上涨
                    const fluctuation = willRise ? Math.random() * 0.1 : -Math.random() * 0.1; // 涨跌幅度
                    stock.currentPrice *= 1 + fluctuation;

                    // 价格保护机制
                    const minPrice = stock.basePrice * 0.3;
                    if (stock.currentPrice < minPrice) stock.currentPrice = minPrice;
                }
            });
            player.stockData.lastStockUpdate = now - (elapsed % (10 * 60 * 1000));
        }

        // 股票购买逻辑
        function buyStock() {
            const amount = parseInt(document.getElementById('stockAmount').value) || 0;
            const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
            
            if(selectedIndex === undefined || amount < 1) {
                logAction("请先选择股票并输入有效数量", "error");
                return;
            }

            const stock = player.stockData.stocks[selectedIndex];
            const totalCost = stock.currentPrice * amount;
            
            if(player.reincarnationCoin >= totalCost) {
                player.reincarnationCoin -= totalCost;
                const totalShares = stock.shares + amount;
                stock.avgCost = (stock.avgCost * stock.shares + totalCost) / totalShares;
                stock.shares += amount;
                logAction(`成功购买${stock.name} ${amount}股`, "success");
            } else {
                logAction("转生币不足！", "error");
            }
            updateStockDisplay();
        }

        // 股票出售逻辑
        function sellStock() {
            const amount = parseInt(document.getElementById('stockAmount').value) || 0;
            const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
            
            if(selectedIndex === undefined || amount < 1) {
                logAction("请先选择股票并输入有效数量", "error");
                return;
            }

            const stock = player.stockData.stocks[selectedIndex];
            if(stock.shares < amount) {
                logAction("持有份额不足！", "error");
                return;
            }

            const totalValue = stock.currentPrice * amount;
            player.reincarnationCoin += totalValue;
            stock.shares -= amount;
            logAction(`成功出售${stock.name} ${amount}股`, "success");
            
            if(stock.shares === 0) stock.avgCost = 0;
            updateStockDisplay();
        }
      // 购买所有股票
function buyAllStock() {
    const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
    if (selectedIndex === undefined) {
        logAction("请先选择股票", "error");
        return;
    }

    const stock = player.stockData.stocks[selectedIndex];
    const maxShares = Math.floor(player.reincarnationCoin / stock.currentPrice);

    if (maxShares > 0) {
        const totalCost = stock.currentPrice * maxShares;
        player.reincarnationCoin -= totalCost;
        const totalShares = stock.shares + maxShares;
        stock.avgCost = (stock.avgCost * stock.shares + totalCost) / totalShares;
        stock.shares += maxShares;
        logAction(`成功购买${stock.name} ${maxShares}股`, "success");
    } else {
        logAction("转生币不足，无法购买任何股票", "error");
    }
    updateStockDisplay();
}

// 出售所有股票
function sellAllStock() {
    const selectedIndex = document.querySelector('.stock-item.selected')?.dataset.index;
    if (selectedIndex === undefined) {
        logAction("请先选择股票", "error");
        return;
    }

    const stock = player.stockData.stocks[selectedIndex];
    if (stock.shares <= 0) {
        logAction("没有持有该股票", "error");
        return;
    }

    const totalValue = stock.currentPrice * stock.shares;
    player.reincarnationCoin += totalValue;
    logAction(`成功出售${stock.name} ${stock.shares}股`, "success");
    stock.shares = 0;
    stock.avgCost = 0;
    updateStockDisplay();
}

        // 购买传统数字彩票
     function buyTraditionalLottery() {
    if (player.traditionalLotteryBought) {
        logAction("您已购买过传统数字彩票，需等待开奖后才能重新购买。", "error");
        return;
    }

    if (player.reincarnationCoin >= 10) {
        player.reincarnationCoin -= 10;
        const numbers = generateTraditionalLotteryNumbers();
        player.traditionalLotteryNumbers = numbers;
        player.traditionalLotteryBought = true; // 设置购买标记
         player.traditionalLotteryDrawTime = Date.now() + 30 * 60 * 1000;
        updateTraditionalLotteryDisplay();
        logAction(`购买了传统数字彩票，号码为：${numbers.join(', ')}`, 'info');
        
        setTimeout(() => {
            checkTraditionalLotteryResult();
            resetTraditionalLottery(); // 开奖后重置状态
        }, 1800000);
    } else {
        logAction("转生币不足！无法购买传统数字彩票", "error");
    }
}

// 新增重置函数
function resetTraditionalLottery() {
    player.traditionalLotteryNumbers = [];
    player.traditionalLotteryBought = false; // 重置购买标记
    player.traditionalLotteryPurchased = false; // 重置原有限购标记
   player.traditionalLotteryDrawTime = 0;
    updateTraditionalLotteryDisplay();
}


        // 生成传统数字彩票号码
        function generateTraditionalLotteryNumbers() {
            const numbers = [];
            while (numbers.length < 6) {
                const num = Math.floor(Math.random() * 50) + 1; // 生成1到50的随机数
                if (!numbers.includes(num)) { // 确保号码不重复
                    numbers.push(num);
                }
            }
            return numbers.sort((a, b) => a - b); // 返回排序后的号码
        }

        // 检查传统数字彩票结果
        function checkTraditionalLotteryResult() {
    const winningNumbers = generateTraditionalLotteryNumbers();
    const matchedNumbers = player.traditionalLotteryNumbers.filter(num => winningNumbers.includes(num)).length;
    let reward = 0;
    switch (matchedNumbers) {
        case 6:
            reward = 1000000;
            break;
        case 5:
            reward = 100000;
            break;
        case 4:
            reward = 10000;
            break;
        case 3:
            reward = 1000;
            break;
        case 2:
            reward = 100;
            break;
        case 1:
            reward = 10;
            break;
      }
    player.items.yuzhou1 += reward;

     // 添加开奖结果
    player.lotteryResults.unshift({
        type: '传统数字彩票',
        numbers: winningNumbers,
        matched: matchedNumbers,
        reward: reward,
       timestamp: new Date().toLocaleTimeString()
    });

    // 保持开奖结果不超过 20 条
    if (player.lotteryResults.length > 20) {
        player.lotteryResults.pop(); // 移除最旧的一条开奖结果
    }
    
    logAction(`传统数字彩票开奖结果：中奖号码为 ${winningNumbers.join(', ')}，你中了 ${matchedNumbers} 个号码，获得 ${reward} 星尘发票`, 'success');
  // 开奖后重置购买状态
     resetTraditionalLottery();
    player.traditionalLotteryPurchased = false;
    updateLotteryResultsDisplay();
    saveGame();

}

  

        // 购买蛇年刮刮卡
        function buySnakeScratchCard() {
            if (player.reincarnationCoin >= 50) {
                player.reincarnationCoin -= 50;
                const reward = getSnakeScratchCardReward();
                player.reincarnationCoin += reward;

              // 添加开奖结果
        player.lotteryResults.unshift({
            type: '蛇年刮刮卡',
            reward: reward,
            timestamp: new Date().toLocaleTimeString()
        });

        // 保持开奖结果不超过 20 条
        if (player.lotteryResults.length > 20) {
            player.lotteryResults.pop(); // 移除最旧的一条开奖结果
        }
                logAction(`购买了蛇年刮刮卡，获得 ${reward} 转生币`, 'info');
                updateLotteryResultsDisplay();
            } else {
                logAction("转生币不足！无法购买蛇年刮刮卡", "error");
            }
        }

        // 获取蛇年刮刮卡奖励
        function getSnakeScratchCardReward() {
            const rand = Math.random();
            if (rand < 0.6) return 0;
            if (rand < 0.95) return Math.floor(Math.random() * 91) + 10; // 10-100
            if (rand < 0.989) return Math.floor(Math.random() * 401) + 100; // 100-500
            if (rand < 0.999) return Math.floor(Math.random() * 1501) + 500; // 500-2000
            return Math.floor(Math.random() * 8001) + 2000; // 2000-10000
        }

        // 购买发财刮刮卡
        function buyFortuneScratchCard() {
            if (player.reincarnationCoin >= 500) {
                player.reincarnationCoin -= 500;
                const reward = getFortuneScratchCardReward();
                player.reincarnationCoin += reward;

                 // 添加开奖结果
        player.lotteryResults.unshift({
            type: '发财刮刮卡',
            reward: reward,
            timestamp: new Date().toLocaleTimeString()
        });

        // 保持开奖结果不超过 20 条
        if (player.lotteryResults.length > 20) {
            player.lotteryResults.pop(); // 移除最旧的一条开奖结果
        }
                logAction(`购买了发财刮刮卡，获得 ${reward} 转生币`, 'info');
                updateLotteryResultsDisplay();
            } else {
                logAction("转生币不足！无法购买发财刮刮卡", "error");
            }
        }

        // 获取发财刮刮卡奖励
        function getFortuneScratchCardReward() {
            const rand = Math.random();
            if (rand < 0.6) return 0;
            if (rand < 0.95) return Math.floor(Math.random() * 901) + 100; // 100-1000
            if (rand < 0.989) return Math.floor(Math.random() * 4001) + 1000; // 1000-5000
            if (rand < 0.999) return Math.floor(Math.random() * 15001) + 5000; // 5000-20000
            return Math.floor(Math.random() * 80001) + 20000; // 20000-100000
        }

        // 更新传统数字彩票显示
     function updateTraditionalLotteryDisplay() {
            const container = document.getElementById('traditionalLotteryNumbers');
            const buyBtn = document.querySelector('.buy-traditional-lottery-btn');
            if (!container) return;
            if (player.traditionalLotteryBought) {
                container.textContent = `您的号码：${(player.traditionalLotteryNumbers || []).join(', ')} (已购买，等待开奖...)`;
                if (buyBtn) buyBtn.style.display = 'none';
            } else {
                container.textContent = "您还没有购买彩票";
                if (buyBtn) buyBtn.style.display = 'block';
            }
            // 更新倒计时显示
            updateLotteryCountdown();
        }
      // 更新彩票倒计时
        function updateLotteryCountdown() {
            const countdownElement = document.getElementById('traditionalLotteryCountdown');
            if (!countdownElement) return;

            if (player.traditionalLotteryBought && player.traditionalLotteryDrawTime > 0) {
                const now = Date.now();
                const timeLeft = player.traditionalLotteryDrawTime - now;
                
                if (timeLeft <= 0) {
                    countdownElement.textContent = '开奖中...';
                    // 时间到了，立即开奖
                    checkTraditionalLotteryResult();
                } else {
                    const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                    const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                    countdownElement.textContent = `下次开奖: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            } else {
                countdownElement.textContent = '下次开奖: --:--:--';
            }
        }
        // 更新开奖结果显示
        function updateLotteryResultsDisplay() {
    const container = document.getElementById('lotteryResults');
    container.innerHTML = player.lotteryResults
        .slice(0, 20)
        .map(result => {
            if (result.type === '传统数字彩票') {
                return `<div>${result.type} - 中奖号码: ${result.numbers.join(', ')}，你中了 ${result.matched} 个号码，获得 ${result.reward} 星尘发票</div>`;
            } else {
                return `<div>${result.type} - 获得 ${result.reward} 转生币</div>`;
            }
        })
        .join('');
}

        // 银行系统逻辑
        function depositToBank() {
            const amount = parseInt(document.getElementById('bankAmount').value) || 0;
            if (amount < 1) {
                logAction("请输入有效的存款金额", "error");
                return;
            }
            if (player.reincarnationCoin >= amount) {
                player.reincarnationCoin -= amount;
                player.bank.deposit += amount;
                logAction(`成功存款 ${amount} 转生币`, "success");
                updateBankDisplay();
            } else {
                logAction("转生币不足！", "error");
            }
        }

        function withdrawFromBank() {
            const amount = parseInt(document.getElementById('bankAmount').value) || 0;
            if (amount < 1) {
                logAction("请输入有效的取款金额", "error");
                return;
            }
            if (player.bank.deposit >= amount) {
                player.bank.deposit -= amount;
                player.reincarnationCoin += amount;
                logAction(`成功取款 ${amount} 转生币`, "success");
                updateBankDisplay();
            } else {
                logAction("存款不足！", "error");
            }
        }
     // 存款所有转生币
function depositAllToBank() {
    const amount = player.reincarnationCoin; // 获取当前所有转生币
    if (amount < 1) {
        logAction("没有可存款的转生币", "error");
        return;
    }

    player.reincarnationCoin -= amount;
    player.bank.deposit += amount;
    logAction(`成功存款所有 ${amount} 转生币`, "success");
    updateBankDisplay();
}

// 取款所有转生币
function withdrawAllFromBank() {
    const amount = player.bank.deposit; // 获取当前所有存款
    if (amount < 1) {
        logAction("没有可取款的转生币", "error");
        return;
    }

    player.bank.deposit -= amount;
    player.reincarnationCoin += amount;
    logAction(`成功取款所有 ${amount} 转生币`, "success");
    updateBankDisplay();
    }      
        function calculateBankInterest() {
            const now = Date.now();
            const elapsed = now - player.bank.lastInterestUpdate;
            const intervals = Math.floor(elapsed / (6 * 60 * 1000)); // 每6分钟计算一次利息

            if (intervals > 0) {
                const interestRate = 0.002; // 0.2% 利息
                const interest = player.bank.deposit * interestRate * intervals;
                player.bank.deposit += interest;
                player.bank.lastInterestUpdate = now - (elapsed % (6 * 60 * 1000));
                logAction(`银行利息: +${interest.toFixed(2)} 转生币`, "info");
            }
        }

       function formatSci(value) {
    if (value >= 1e8) {
        return value.toExponential(3);
    } else {
        return value.toLocaleString();
    }
}

// 更新银行显示函数
function updateBankDisplay() {
    document.getElementById("bankDeposit").textContent = formatSci(player.bank.deposit);
    document.getElementById("bankTotal").textContent = formatSci(player.bank.deposit);
}

        // 新增：副本装备系统
        function addDungeonEquipment(rarity) {
    const config = dungeonEquipmentTypes[rarity];
    const growthRate = Math.random() * (config.growthRange[1] - config.growthRange[0]) + config.growthRange[0];

    // 检查是否已经有相同的副本装备
    const existingEq = player.dungeonEquipment.find(eq => eq.rarity === rarity);
    if (existingEq) {
        existingEq.quantity = (existingEq.quantity || 1) + 1; // 增加数量
        if (existingEq.quantity >= 3) {
            existingEq.level++; // 升级装备等级
            existingEq.quantity = 0; // 重置数量
            
       
        }
    } else {
        // 如果没有相同的副本装备，则添加新的装备
        const newEq = {
            name: config.name,
            rarity: rarity,
            level: 1,
            growthRate: growthRate,
            quantity: 1 // 初始化数量
        };
        player.dungeonEquipment.push(newEq);
        logAction(`获得副本装备：${newEq.name}`, rarity);
    }

    updateDungeonEquipmentDisplay(); // 更新副本装备显示
}

        function upgradeDungeonEquipment(index) {
            const eq = player.dungeonEquipment[index];
            const cost = eq.level * 100;
            if (player.reincarnationCoin >= cost) {
                player.reincarnationCoin -= cost;
                eq.level++;
                logAction(`升级副本装备：${eq.name} 至 Lv.${eq.level}`, eq.rarity);
                updateDungeonEquipmentDisplay(); // 刷新副本装备页面
                updateDisplay();
            } else {
                logAction("转生币不足！", "error");
            }
        }

        function refineDungeonEquipment(index) {
            const eq = player.dungeonEquipment[index];
            if (player.items.refineStone > 0) {
                player.items.refineStone--;
                const config = dungeonEquipmentTypes[eq.rarity];
                eq.growthRate = Math.random() * (config.growthRange[1] - config.growthRange[0]) + config.growthRange[0];
                logAction(`洗炼副本装备：${eq.name}，新的成长属性为 ${(eq.growthRate * 100).toFixed(2)}%`, 'success');
                updateDungeonEquipmentDisplay(); // 刷新副本装备页面
                updateDisplay();
            } else {
                logAction("洗炼石不足！", "error");
            }
        }

       function updateDungeonEquipmentDisplay() {

    const container = document.getElementById('dungeonEquipmentContainer');
    const rarityOrder = [
        'common',     
    'rare',       
    'epic',       
    'legendary',  
    'ancient',    
    'divine',    
    'arcane',     
    'celestial',  
    'infernal',  
    'astral',     
    'primeval',  
    'transcendental', 
    'quantum',    
    'ultimate',  
    'ultimate1',     
    'ultimate2',   
    'ultimate3',       
    'ultimate4',   
    'ultimate5', 
    'ultimate6',    
    'ultimate7',     
    'ultimate8',   
    'ultimate9',       
    'ultimate10',   
    'ultimate11', 
    'ultimate12',     
    'ultimate13',     
    'ultimate14',   
    'ultimate15',       
    'ultimate16',   
    'ultimate17', 
    'ultimate18',   
    'ultimate19',     
    'ultimate20',   
    'ultimate21',       
    'ultimate22',   
    'ultimate23', 
    'ultimate24',   
    'ultimate25',   
    'ultimate26',       
    'ultimate27',   
    'ultimate28', 
    'ultimate29',     
    'ultimate30',     
    'ultimate31',   
    'ultimate32',       
    'ultimate33',   
    'ultimate34', 
    'ultimate35',     
    'ultimate36',     
    'ultimate37',   
    'ultimate38',       
    'ultimate39',   
    'ultimate40', 
    'ultimate41',    
    'ultimate42',     
    'ultimate43',   
    'ultimate44',       
    'ultimate45',   
    'ultimate46', 
    'ultimate47', 
    'ultimate48',   
    'ultimate49', 
    'ultimate50'
    ];
    
    // 按品质排序
    const sortedEquipment = player.dungeonEquipment.sort((a, b) => {
        // 先按品质排序
        const rarityDiff = rarityOrder.indexOf(a.rarity) - rarityOrder.indexOf(b.rarity);
        if (rarityDiff !== 0) return rarityDiff;
        
        // 同品质按成长属性降序
        return b.growthRate - a.growthRate;
    });
    const totalBonus = player.dungeonEquipment.reduce((sum, eq) => sum + eq.level * eq.growthRate, 0);
    container.innerHTML = `
        <div>总加成: +${(totalBonus * 100).toFixed(2)}%</div>
        ${player.dungeonEquipment.map((eq, index) => `
            <div class="equipment ${eq.rarity}">
                ${eq.name} Lv.${eq.level} (数量: ${eq.quantity}/3, 成长属性: +${(eq.growthRate * 100).toFixed(2)}%)
                <button onclick="refineDungeonEquipment(${index})">洗炼</button>
                <button onclick="dismantleDungeonEquipment(${index})">分解</button>
            </div>
        `).join('')}
    `;
}

        // 分解副本装备
        function dismantleDungeonEquipment(index) {
            const eq = player.dungeonEquipment[index];
            player.dungeonEquipment.splice(index, 1);
            logAction(`分解了副本装备：${eq.name}`, 'success');
            updateDungeonEquipmentDisplay();
        }

        // 新增：魂环系统
        function addSoulRing(type) {
            const existing = player.soulRings.find(r => r.type === type);
            if(existing) {
                existing.level++;
            } else {
                player.soulRings.push({
                    type: type,
                    level: 1,
                    multiplier: soulRingTypes[type].baseMult
                });
            }
        }

        function upgradeSoulRing(type) {
    const ring = player.soulRings.find(r => r.type === type);
    const cost = ring.level * soulRingTypes[type].costBase * 1000;

    if (player.reincarnationCoin >= cost) {
        player.reincarnationCoin -= cost;
        ring.level++;

        // 检查魂环成就
        checkSoulRingAchievements(type, ring.level);

        logAction(`${soulRingTypes[type].name} 升级到 Lv.${ring.level}`, 'success');
    } else {
        logAction("转生币不足！", "error");
    }
}

function checkSoulRingAchievements(type, level) {
    const achievements = [
        { level: 10, key: `${type}_10` },
        { level: 100, key: `${type}_100` },
        { level: 1000, key: `${type}_1000` },
        { level: 10000, key: `${type}_10000` },
    ];

    achievements.forEach(({ level: targetLevel, key }) => {
        if (level >= targetLevel && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updateAchievementsDisplay();
            }
        }
    });
}
        function updateSoulRingDisplay() {
            const container = document.getElementById('soulRingsContainer');
            container.innerHTML = player.soulRings.map(ring => `
                <div class="equipment">
                    ${soulRingTypes[ring.type].name} Lv.${ring.level}
                    (全属性+${(ring.level * ring.multiplier * 100).toFixed(1)}%)

                    </button>
                </div>
            `).join('');
        }
      function showRenameDialog() {
    document.getElementById("renameDialog").style.display = "block";
    document.getElementById("renameOverlay").style.display = "block";
    document.getElementById("renameDialogTitle").textContent = "输入新名字:";
    document.getElementById("newNameInput").value = player.name;
    document.getElementById("newNameInput").focus();
}

function cancelRename() {
    document.getElementById("renameDialog").style.display = "none";
    document.getElementById("renameOverlay").style.display = "none";
}

function updatePlayerAvatarDisplay() {
    var el = document.getElementById("playerAvatar");
    if (!el) return;
    if (player.avatar) {
        el.src = player.avatar;
        el.style.display = "";
        el.alt = player.name + "的头像";
    } else {
        el.src = "";
        el.style.display = "none";
    }
}

function clearAvatar() {
    player.avatar = "";
    updatePlayerAvatarDisplay();
    saveGame();
    logAction("已清除头像", "info");
}

(function initAvatarInput() {
    var input = document.getElementById("avatarInput");
    if (!input) return;
    input.addEventListener("change", function(e) {
        var file = e.target.files[0];
        if (!file || !file.type.match(/^image\//)) {
            e.target.value = "";
            return;
        }
        var reader = new FileReader();
        reader.onload = function() {
            var img = new Image();
            img.onload = function() {
                var canvas = document.createElement("canvas");
                canvas.width = 48;
                canvas.height = 48;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0, 48, 48);
                player.avatar = canvas.toDataURL("image/png");
                updatePlayerAvatarDisplay();
                saveGame();
                logAction("头像已更新", "success");
                e.target.value = "";
            };
            img.onerror = function() { e.target.value = ""; };
            img.src = reader.result;
        };
        reader.readAsDataURL(file);
    });
})();

function confirmRename() {
    const newName = document.getElementById("newNameInput").value.trim();
    if (newName && newName.length <= 10) {
        player.name = newName;
        document.getElementById("playerName").textContent = newName;
        saveGame();  // 确保保存玩家数据
        cancelRename();
    } else {
        alert("请输入有效的名字（1-10个字符）");
    }
}

        // 界面更新
        function updateDisplay() {
        syncOnlineOptionLabels();
        const soulRingRingBonus = getTotalSoulRingBonus();
  const dungeonEquipBonus = getTotalDungeonEquipBonus();
      document.getElementById("playerName").textContent = player.name;
      updatePlayerAvatarDisplay();
       const currentTitleEl = document.getElementById("currentTitle");
    currentTitleEl.textContent = player.titles.current ? `[${player.titles.current}]` : "";
    const runeBonuses = calculateRuneBonuses();
    let runeBonusText = '';
    
    if (player.runes.equipped) {
        runeBonusText = '符文加成: ';
        const bonuses = [];
        
        if (runeBonuses.attack > 0) bonuses.push(`攻击+${(runeBonuses.attack * 100).toFixed(1)}%`);
        if (runeBonuses.health > 0) bonuses.push(`生命+${(runeBonuses.health * 100).toFixed(1)}%`);
        if (runeBonuses.critRate > 0) bonuses.push(`暴击+${(runeBonuses.critRate * 100).toFixed(2)}%`);
        if (runeBonuses.critDamage > 0) bonuses.push(`爆伤+${(runeBonuses.critDamage * 100).toFixed(1)}%`);
        if (runeBonuses.combo > 0) bonuses.push(`连击+${runeBonuses.combo.toFixed(0)}次`);
        if (runeBonuses.worldExp > 0) bonuses.push(`世界经验+${(runeBonuses.worldExp * 100).toFixed(1)}%`);
        
        runeBonusText += bonuses.join(' ');
    }
    
    // 将符文加成信息添加到界面中合适的位置
    const runeBonusElement = document.getElementById('runeBonusDisplay');
    if (!runeBonusElement) {
        // 如果不存在，创建一个新的元素
        const newElement = document.createElement('div');
        newElement.id = 'runeBonusDisplay';
        newElement.style.cssText = 'color: #90ee90; font-size: 12px; margin-top: 5px;';
        newElement.textContent = runeBonusText;
        
        // 找到合适的位置插入（例如在玩家属性显示区域）
        const playerStatsContainer = document.querySelector('.player-stats-container');
        if (playerStatsContainer) {
            playerStatsContainer.appendChild(newElement);
        }
    } else {
        runeBonusElement.textContent = runeBonusText;
    }
    
 
    // 数值显示
    const display = (value) => {
    if (value >= 1e8) {  // 当数值大于等于 100,000,000 时使用科学计数法
        return value.toExponential(3);
    } else {
        return value.toLocaleString();  // 否则使用常规的数值显示
    }
};
   
  
    // 更新显示
   const currencies = ['gold', 'diamond', 'titanium', 'starstone', 'cosmicstone', 
                       'superstone', 'otherworldstone', 'xingjiestone', 'hundunstone', 
                       'lingtone', 'huangtone', 'mingtone', 'xutong', 'shitone', 'weitone'];
    
    currencies.forEach(currency => {
        const element = document.getElementById(currency);
        if (player[currency] === 0) {
            element.textContent = ''; // 设置为空
        } else {
            element.textContent = display(player[currency]);
        }
    });
    // 钻石/钛晶石/星耀石等数量为0时隐藏对应货币卡片（金币、转生币始终显示）
    const hideWhenZero = ['diamond', 'titanium', 'starstone', 'cosmicstone', 'superstone', 'otherworldstone', 'xingjiestone', 'hundunstone', 'lingtone', 'huangtone', 'mingtone', 'xutong', 'shitone', 'weitone'];
    hideWhenZero.forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        const card = el.closest('.currency-card');
        if (!card) return;
        card.style.display = player[id] === 0 ? 'none' : '';
    });
    document.getElementById("reincarnationCoin").textContent = display(player.reincarnationCoin);
    const totalAssets = player.investmentGame && player.investmentGame.userData && Number.isFinite(Number(player.investmentGame.userData.totalAssets))
        ? Number(player.investmentGame.userData.totalAssets) : 0;
    document.getElementById("zijze").textContent = `${totalAssets.toFixed(3)}元`;
    document.getElementById("reincarnationCount").textContent = player.reincarnationCount;
    document.getElementById("maxStage").textContent = player.battle.maxStage;
    document.getElementById("gps").textContent = display(getTotalGPS());
    document.getElementById("clickValue").textContent = display(getTotalClickValue());
    document.getElementById("vipPowerCount").textContent = player.items.vipPower || 0;
   document.getElementById("mysteryBonusDisplay").textContent = player.mystery.bonus;
  document.getElementById('playerLevelDisplay').textContent = `Lv.${player.level.current}级`;
  document.getElementById('ascentionCountq').textContent = `飞升.${player.level.ascentionCount}次`;
document.getElementById('ascentionCountqa').textContent = `轮回.${player.level.ascentionCounta}转`;

    // 更新材料宝箱购买成本显示
    document.getElementById("materialChestCost").textContent = display(player.materialChestCost);

        // 更新宝箱成本显示
     document.getElementById("techniqueChestCost").textContent = display(player.techniqueChestCost);

    // 更新怪物生命和攻击显示
    if (player.battle.monster) {
        document.getElementById("monsterHealth").textContent = display(player.battle.monster.health);
        document.getElementById("monsterAttack").textContent = display(player.battle.monster.attack);
    }
   
    // 更新玩家攻击显示
    document.getElementById("playerAttack").textContent = display(player.battle.playerAttack);

            // 装备列表
            const fragment = document.createDocumentFragment();
   player.equipment.forEach((eq, index) => {
    const div = document.createElement("div");
    div.className = `equipment ${eq.rarity}`;
    div.innerHTML = `
        ${getEquipmentName(eq)} Lv.${eq.level}
        (GPS +${eq.gps.toExponential(3)} 点击 +${eq.click.toExponential(3)})
        <button onclick="useAllGems(${index}, 'primaryGem')">一键使用初级宝石</button>
        <button onclick="useAllGems(${index}, 'advancedGem')">一键使用高级宝石</button>
        <button onclick="useAllGems(${index}, 'superiorGem')">一键使用极品宝石</button>
        <button onclick="useAllGems(${index}, 'divineGem')">一键使用神级宝石</button>
        <div class="tooltip">
                品质: ${eq.name}<br>
                等级: ${eq.level}<br>
                成长率: +${(eq.growthRate * 100).toFixed(1)}%/级<br>
                宝石加成: +${(eq.gemMultiplier * 100).toFixed(2)}%<br>
            </div>
        `;
        fragment.appendChild(div);
    });
    document.getElementById("equipmentList").innerHTML = "";
    document.getElementById("equipmentList").appendChild(fragment);

            // 日志
            document.getElementById("actionLog").innerHTML = player.actionLogs
                .map(log => `<div class="${log.type}">[${log.timestamp}] ${log.message}</div>`)
                .join("");

            // 成就
            updateAchievementsDisplay();
            // 节流自动存档：每 30 秒最多写一次，避免每秒 JSON.stringify+localStorage 导致严重卡顿
            if (!versionErrorBlocked) {
                const now = Date.now();
                if (!player._lastAutoSave || now - player._lastAutoSave > 30000) {
                    player._lastAutoSave = now;
                    var chartCache = player.investmentGame && player.investmentGame.chartHistoryCache;
                    if (chartCache) player.investmentGame.chartHistoryCache = {};
                    try { localStorage.setItem("goldGameSave", JSON.stringify(player)); } catch (e) {}
                    if (chartCache) player.investmentGame.chartHistoryCache = chartCache;
                }
            }
        }

        // 辅助函数
        function getEquipmentName(eq) {
            return eq.name || equipmentTypes[eq.rarity]?.name || '神秘装备';
        }

        function validateRarity(rarity) {
            return equipmentTypes[rarity] ? rarity : 'common';
        }

        function getDefaultGrowthRate(rarity) {
            return equipmentTypes[rarity]?.growthRate || 0.01;
        }
            function formatSci(number) {
    if (number >= 1e9) {
        return number.toExponential(3)
            .replace(/(\.\d+?)0+e/, '$1e')
            .replace(/\.?e\+?/, 'e');
    }
    return Math.floor(number).toLocaleString();
}


        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            return [hours && `${hours}小时`, minutes && `${minutes}分`, `${secs}秒`]
                .filter(Boolean).join(' ');
        }

       function logAction(message, type = 'info') {
    // 过滤包含"自动购买"的消息
    if (message.includes('自动购买')) {
        return; // 直接返回，不记录这类消息
    }
    if (message.includes("获得了轮回神兽")) {
        // 提取神兽名和品质
        const match = message.match(/获得了轮回神兽：(.*?)（(.*?)·(.*?)）/);
        if (match) {
            const [, beastName, rarity, sLevel] = match;
            const rarityColor = beastConfig.rarities[rarity]?.color || '#FFFFFF';
            // 可以用特殊样式显示
        }
    }
    const timestamp = new Date().toLocaleTimeString();

    // 辅助函数：将大数值转换为科学计数法
    const formatNumber = (value) => {
        if (value >= 1e8) { // 当数值大于等于 100,000,000 时使用科学计数法
            return value.toExponential(3);
        } else {
            return value.toLocaleString(); // 否则使用常规的数值显示
        }
    };

    // 格式化消息中的数值
    const formattedMessage = message.replace(/\d+(\.\d+)?/g, (match) => {
        const number = parseFloat(match);
        return formatNumber(number);
    });

    // 添加到统一日志数组
    player.actionLogs.unshift({ message: formattedMessage, type, timestamp });
    // 保持日志长度不超过 20 条
    if (player.actionLogs.length > 20) {
        player.actionLogs.pop(); // 移除最旧的一条日志
    }

    // 原有 DOM 更新逻辑保持不变...
    const logEntry = document.createElement('div');
    logEntry.className = type;
    logEntry.textContent = `[${timestamp}] ${message}`;

    const logContainer = document.getElementById('actionLog');
    if (logContainer.firstChild) {
        logContainer.insertBefore(logEntry, logContainer.firstChild);
    } else {
        logContainer.appendChild(logEntry);
    }
    if (logContainer.children.length > 20) {
        logContainer.removeChild(logContainer.lastChild);
    }
}


        // 保存游戏
        function saveGame() {
    if (versionErrorBlocked) return; // 版本被阻止时不写入，避免覆盖新版本存档
    player.gameVersion = GAME_VERSION;
    player.lastUpdate = Date.now(); // 确保保存时更新最后更新时间   
    player.actionLogs = player.actionLogs.slice(0, 5);
    player.lotteryResults = player.lotteryResults.slice(0, 5);
   
    if (player.liveStream && player.liveStream.donationHistory) {
        player.liveStream.donationHistory = player.liveStream.donationHistory.slice(-5);
    }
     if (player.investmentGame && player.investmentGame.userData) {
        player.investmentGame.userData.lastUpdateTime = Date.now();
    }
    if (player.liveStream && player.liveStream.viewers) {
        player.liveStream.viewers = player.liveStream.viewers.slice(-5);
    }
    if (player.reincarnationEquipment) {
        player.reincarnationEquipment.inventory = player.reincarnationEquipment.inventory.filter(eq => eq);
    }
    player.mystery.lastUpdateTime = Date.now();
   cleanupArtifactAdvanceLevels(); 
    saveInvestmentGameData();
    player.tower.lastUpdate = Date.now();
    player.exploration = {
        speed: explorationData.speed,
        capacity: explorationData.capacity,
        durability: explorationData.durability,
        resources: explorationData.resources,
        activeMission: explorationData.activeMission,
        missionEndTime: explorationData.missionEndTime,
        logs: explorationData.logs
    };
    
    var chartCache = player.investmentGame && player.investmentGame.chartHistoryCache;
    if (chartCache) player.investmentGame.chartHistoryCache = {};
    try { localStorage.setItem('goldGameSave', JSON.stringify(player)); } finally { if (chartCache) player.investmentGame.chartHistoryCache = chartCache; }
    localStorage.setItem('traditionalLotteryPurchased', player.traditionalLotteryPurchased);
    // 不在 saveGame 里写 goldGameLastUnload，否则自动/手动保存会覆盖「离开时间」，导致重开时离线时长恒为 0；仅 beforeunload 写入
    logAction('游戏已保存', 'success');
}

        // 加载游戏
        function loadGame() {
    window._tradingOfflineRunThisSession = false; // 主动加载存档时允许本次离线结算
    loadSave();
    if (typeof runTradingOfflineIfNeeded === 'function') runTradingOfflineIfNeeded();
    if (player && player.trading && player.trading.autoTrade && player.trading.autoTrade.enabled && typeof startAutoTradeSystem === 'function') {
        startAutoTradeSystem();
    }
  initReincarnationEquipmentSystem();
   updateSectNameDisplay();
    updateDisplay();
   calculateTotalGPS();
  initMarriageSystem();
 initTreasureData();
 initChildData();
addChildSystemToGameLoop();
      if (player.investmentGame) {
        // 先模拟离线变化
        simulateOfflinePriceChanges();
        
        // 再启动实时模拟
        setTimeout(() => {
            startPriceSimulation();
        }, 1000);
    }
  if (!player.timeSecretRealm) {
        player.timeSecretRealm = {
            currency: 0,
            bestFloor: 0,
            clearCount: 0,
            unlockedItems: [],
            currentRun: {
                isActive: false,
                currentFloor: 1,
                timeLeft: 300,
                tempBuffs: [],
                currentRoom: null,
                exploredRooms: 0,
                currencyEarned: 0,
                playerHealth: 0,
                playerAttack: 0
            },
         difficulty: {
   levels: {
        easy: { 
            name: '简单', 
            multiplier: 0.8, 
            rewardMultiplier: 0.7, 
            description: '适合新手玩家', 
            unlockCondition: '无',
            clearFloor: 10  // 通关层数要求
        },
        normal: { 
            name: '普通', 
            multiplier: 1.0, 
            rewardMultiplier: 1.0, 
            description: '标准难度', 
            unlockCondition: '通关简单难度3次',
            clearFloor: 15
        },
        hard: { 
            name: '困难', 
            multiplier: 1.5, 
            rewardMultiplier: 1.5, 
            description: '更具挑战性', 
            unlockCondition: '通关普通难度5次',
            clearFloor: 20
        },
        nightmare: { 
            name: '噩梦', 
            multiplier: 2.0, 
            rewardMultiplier: 2.5, 
            description: '极限挑战', 
            unlockCondition: '通关困难难度10次',
            clearFloor: 25
        },
        hell: { 
            name: '地狱', 
            multiplier: 3.0, 
            rewardMultiplier: 4.0, 
            description: '终极考验', 
            unlockCondition: '通关噩梦难度20次',
            clearFloor: 30
        }
    },
    current: 'easy',
    unlocked: ['easy']
},
            roomTypes: {
                battle: { weight: 40, name: '战斗房间' },
                event: { weight: 25, name: '事件房间' },
                treasure: { weight: 20, name: '宝箱房间' },
                rest: { weight: 10, name: '休息房间' },
                shop: { weight: 5, name: '商店房间' }
            },
            tempBuffs: {
                attack: { 
        name: '攻击强化', 
        description: '攻击力提升50%，探索时间+30秒', 
        effect: 'attack', 
        value: 0.5, 
        duration: 0,
        timeBonus: 30  // 新增：增加20秒探索时间
    },
    health: { 
        name: '生命强化', 
        description: '生命值提升50%，探索时间+60秒', 
        effect: 'health', 
        value: 0.5, 
        duration: 0,
        timeBonus: 60  // 新增：增加40秒探索时间
    },
    critRate: { 
        name: '暴击强化', 
        description: '暴击率提升10%，探索时间+90秒', 
        effect: 'critRate', 
        value: 0.1, 
        duration: 0,
        timeBonus: 90  // 新增：增加60秒探索时间
    },
    critDamage: { 
        name: '爆伤强化', 
        description: '爆伤提升50%，探索时间+120秒', 
        effect: 'critDamage', 
        value: 0.5, 
        duration: 0,
        timeBonus: 120  // 新增：增加80秒探索时间
    },
    speed: { 
        name: '速度强化', 
        description: '探索速度提升，探索时间+150秒', 
        effect: 'speed', 
        value: 10, 
        duration: 0,
        timeBonus: 150  // 新增：增加100秒探索时间
    },
                luck: { name: '幸运强化', description: '获得双倍秘境币', effect: 'luck', value: 1, duration: 0  }
            },
            shopItems: {
                permanentAttack: { 
                    name: '永恒攻击符文', 
                    description: '临时提升现有攻击力50%可以叠加（转生失效)', 
                    cost: 100000, 
                    type: 'permanent',
                    effect: 'attack'
                },
                permanentHealth: { 
                    name: '永恒生命符文', 
                    description: '临时提升现有生命值50%可以叠加（转生失效)', 
                    cost: 100000, 
                    type: 'permanent',
                    effect: 'health'
                },
                timeExtension: { 
        name: '时间沙漏', 
        description: '永久增加探索时间60秒（限购50个）', 
        cost: 500000, 
        type: 'permanent',
        effect: 'time',
        maxPurchase: 50, // 限购50个
        purchased: 0, // 已购买数量
        permanentEffect: true // 永久效果
    },
    startingBuff: { 
        name: '起始祝福', 
        description: '每次冒险开始时永久获得1个随机增益效果（限购2个）', 
        cost: 800000, 
        type: 'permanent',
        effect: 'startingBuff',
        maxPurchase: 2, // 限购2个
        purchased: 0, // 已购买数量
        permanentEffect: true // 永久效果
    },
           trapSkillBook1: {
    name: '侦查技能书·初级',
    description: '提升陷阱侦查成功率到60%',
    cost: 500000,
    type: 'permanent',
    effect: 'detection_advanced'
},
 trapSkillBook2: {
    name: '侦查技能书·高级',
    description: '提升陷阱侦查成功率到80%',
    cost: 800000,
    type: 'permanent',
    effect: 'detection_expert'
},
 trapSkillBook3: {
    name: '解除技能书·初级',
    description: '提升陷阱解除成功率到70%',
    cost: 500000,
    type: 'permanent',
    effect: 'disarm_advanced'
},
 trapSkillBook4: {
    name: '解除技能书·高级',
    description: '提升陷阱解除成功率到85%',
    cost: 800000,
    type: 'permanent',
    effect: 'disarm_expert'
},
 trapSense: {
    name: '陷阱感知药水',
    description: '下次冒险陷阱侦查成功率提升30%',
    cost: 10000,
    type: 'consumable',
    effect: 'detection_boost'
},
                rareMaterial: { 
                    name: '秘境结晶', 
                    description: '神器碎片1000个', 
                    cost: 100000, 
                    type: 'material',
                    effect: 'material'
                }
            },
traps: {
    // 陷阱类型配置
    types: {
        poison: { weight: 20, name: '毒液陷阱', damageType: 'percentage', damage: 0.15, duration: 3 },
        spike: { weight: 15, name: '尖刺陷阱', damageType: 'fixed', damage: 1000, duration: 1 },
        curse: { weight: 10, name: '诅咒陷阱', damageType: 'debuff', effect: 'attack', value: -0.3, duration: 5 },
        slow: { weight: 12, name: '迟缓陷阱', damageType: 'time', damage: 30, duration: 0 },
        confusion: { weight: 8, name: '混乱陷阱', damageType: 'random', damage: 0.2, duration: 2 },
        disarm: { weight: 5, name: '缴械陷阱', damageType: 'debuff', effect: 'critRate', value: -0.5, duration: 4 }
    },
    
    // 陷阱检测技能
    detectionSkills: {
        basic: { name: '基础侦查', successRate: 0.3, cost: 5 },
        advanced: { name: '高级侦查', successRate: 0.6, cost: 15 },
        expert: { name: '专家侦查', successRate: 0.8, cost: 25 },
        master: { name: '大师侦查', successRate: 0.95, cost: 40 }
    },
    
    // 陷阱解除技能
    disarmSkills: {
        basic: { name: '基础解除', successRate: 0.4, cost: 10 },
        advanced: { name: '高级解除', successRate: 0.7, cost: 20 },
        expert: { name: '专家解除', successRate: 0.85, cost: 35 },
        master: { name: '大师解除', successRate: 1.0, cost: 50 }
    },
    
    // 玩家掌握的陷阱技能
    playerSkills: {
        detection: 'basic',
        disarm: 'basic'
    }
 }
        };
    
    
    updateTimeSecretRealmUI();
}
 player.traditionalLotteryPurchased = localStorage.getItem('traditionalLotteryPurchased') === 'true';
 if (player.parking) {
        calculateOfflineParkingIncome();
    }
    logAction('游戏已加载', 'success');
}
 const ENCRYPTION_KEY = "your-secure-key-here-123";
        // 导出存档
        function exportSave() {
        try {
            // 转换玩家数据为JSON字符串
            const saveData = JSON.stringify(player);
            // 使用AES加密
            const encryptedData = CryptoJS.AES.encrypt(
                saveData,
                ENCRYPTION_KEY
            ).toString();
            
            // 复制加密后的数据到剪贴板
            const textArea = document.createElement('textarea');
            textArea.value = encryptedData;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            logAction('加密存档已复制到剪贴板', 'success');
        } catch (error) {
            logAction('存档导出失败', 'error');
            console.error('导出错误:', error);
        }
    }
 // 导出存档到文件（新增功能）
function downloadSave() {
    try {
        // 获取当前存档数据
        const saveData = JSON.stringify(player);
        
        // 使用AES加密存档
        const encryptedData = CryptoJS.AES.encrypt(
            saveData,
            ENCRYPTION_KEY
        ).toString();
        
        // 创建Blob对象
        const blob = new Blob([encryptedData], { type: 'text/plain' });
        
        // 创建下载链接
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `gold_adventurer_save_${new Date().toISOString().slice(0, 10)}.txt`;
        
        // 触发下载
        document.body.appendChild(a);
        a.click();
        
        // 清理
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        logAction('存档已加密并下载', 'success');
    } catch (error) {
        logAction('存档下载失败: ' + error.message, 'error');
        console.error('存档下载错误:', error);
    }
}
function importEncryptedSave() {
    // 检查冷却时间
    const lastImportTime = localStorage.getItem('lastImportTime');
    if (lastImportTime) {
        const currentTime = Date.now();
        const timeDiff = currentTime - parseInt(lastImportTime);
        const cooldown = 6 * 60 * 60 * 1000; // 6小时冷却时间
        
        if (timeDiff < cooldown) {
            const remaining = Math.ceil((cooldown - timeDiff) / (60 * 1000));
            logAction(`导入功能冷却中，请等待 ${remaining} 分钟后再试`, "error");
            return;
        }
    }
    
    // 触发文件选择器
    document.getElementById('fileInput').click();
    
    // 添加文件选择事件监听
    document.getElementById('fileInput').addEventListener('change', handleFileSelect);
}

// 处理文件选择
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // 检查文件类型
    if (file.type !== "text/plain" && !file.name.endsWith('.txt')) {
        logAction("请选择.txt格式的存档文件", "error");
        return;
    }
    
    // 读取文件内容
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const encryptedData = e.target.result;
            decryptAndLoadSave(encryptedData);
        } catch (error) {
            logAction("存档导入失败：" + error.message, "error");
            console.error("存档导入错误:", error);
        }
    };
    reader.readAsText(file);
}

// 解密并加载存档
function decryptAndLoadSave(encryptedData) {
    try {
        // 解密数据
        const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
        const saveData = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
        
        // 应用存档数据
        player = migrateSaveData(saveData);
        // 恢复星域舰队属性，避免导入后 saveGame 把默认1级写回
        if (typeof restoreExplorationDataFromSave === 'function') restoreExplorationDataFromSave(saveData);
        updateDisplay();
        logAction('加密存档导入成功！', 'success');
        
        // 更新导入时间
        localStorage.setItem('lastImportTime', Date.now().toString());
       saveGame();
      setTimeout(() => {
                location.reload(true);
            }, 1000);
    } catch (error) {
        logAction('存档导入失败：无效的存档或密钥错误', 'error');
        console.error('导入错误:', error);
    }
}
// 存档迁移函数（确保兼容性）
function migrateSaveData(save) {
    // 这里添加必要的存档迁移逻辑
    // 确保旧版存档能兼容新版游戏
    
    return {
        ...player, // 使用默认值
        ...save    // 覆盖为导入的数据
    };
}

        // 导入存档
    function importSave() {
    // 检查冷却时间
    const lastImportTime = localStorage.getItem('lastImportTime');
    if (lastImportTime) {
        const currentTime = Date.now();
        const timeDiff = currentTime - parseInt(lastImportTime);
        const cooldown = 6 * 60 * 60 * 1000; // 6小时冷却时间
        
        if (timeDiff < cooldown) {
            const remaining = Math.ceil((cooldown - timeDiff) / (60 * 1000));
            logAction(`导入功能冷却中，请等待 ${remaining} 分钟后再试`, "error");
            return;
        }
    }
    
    showCustomPrompt('请输入加密存档代码：', async (encryptedData) => {
        if (!encryptedData) return;
        
        try {
            // 解密存档数据
            const decrypted = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
            const saveData = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
            
            // 应用存档数据
            player = migrateSaveData(saveData);
            // 恢复星域舰队属性，避免导入后 saveGame 把默认1级写回
            if (typeof restoreExplorationDataFromSave === 'function') restoreExplorationDataFromSave(saveData);
            updateDisplay();
            logAction('存档已成功导入！', 'success');
            
            // 更新导入时间
            localStorage.setItem('lastImportTime', Date.now().toString());
      saveGame();
      setTimeout(() => {
                location.reload(true);
            }, 1000);
        } catch (error) {
            logAction('存档导入失败：无效的存档或密钥错误', 'error');
            console.error('导入错误:', error);
        }
    });
}

// 获取加密的时间戳
async function getEncryptedTime(key) {
    const encrypted = localStorage.getItem(key);
    if (!encrypted) return null;
    try {
        const decrypted = CryptoJS.AES.decrypt(encrypted, ENCRYPTION_KEY);
        return parseInt(decrypted.toString(CryptoJS.enc.Utf8));
    } catch {
        return null;
    }
}

// 设置加密的时间戳
async function setEncryptedTime(key, value) {
    const encrypted = CryptoJS.AES.encrypt(String(value), ENCRYPTION_KEY);
    localStorage.setItem(key, encrypted.toString());
}

// 格式化时间显示
function formatTime(milliseconds) {
    const hours = Math.floor(milliseconds / 3600000);
    const mins = Math.floor((milliseconds % 3600000) / 60000);
    return `${hours}小时${mins}分钟`;
}
          function resetItems() {
      showCustomConfirm('确定要重置道具数据吗？所有道具将被清除！', (confirmed) => {
          if (confirmed) {
            // 重置道具数据
            player.items = {
                primaryGem: 0,
                advancedGem: 0,
                superiorGem: 0,
                divineGem: 0,
                vipPower: 0,
                refineStone: 0
            };

            // 更新道具页面
            updateItemDisplay();
            logAction('道具数据已重置', 'success');
           }
        });
   }
        // 重置游戏
        function resetGame() {
            showCustomConfirm('确定要重置游戏吗？所有进度将丢失！', (confirmed) => {
                if (confirmed) {
                    localStorage.removeItem('goldGameSave');
                    player = {
                        gold: 0,
                        diamond: 0,
                        titanium: 0,
                        starstone: 0,
                        cosmicstone: 0,
                        superstone: 0,
                        otherworldstone: 0, 
                        xingjiestone: 0, 
                        hundunstone: 0,  
                        lingtone: 0,
                        huangtone: 0,
                        mingtone: 0,
                        xutong: 0,
                        shitone: 0,
                        weitone: 0,
                        reincarnationCoin: 0,
                        reincarnationCount: 0,
                        equipment: [],
                        vip: {
        level: 1,
        power: 0, // 累计VIP能力值数量
    },
                        items: {
                            primaryGem: 0,
                            advancedGem: 0,
                            superiorGem: 0,
                            divineGem: 0,
                            vipPower: 0,
                            refineStone: 0 // 新增洗炼石
                           
                        },
                        collections: {
                            lightSpeedHand: 0,
                            empHand: 0,
                            godlyHand: 0,
                            quickHand: 0,
                            shadowHand: 0,
                            quantumHand: 0,
                            lightningHand: 0,
                            divineHand: 0
                        },
                        pets: {
                             thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
                             chaosTaotie: { level: 0, cost: 1, multiplier: 0.30 },
                             netherQiongqi: { level: 0, cost: 1, multiplier: 0.90 },
                             abyssKun: { level: 0, cost: 1, multiplier: 2.70 },
                             primordialZhuLong: { level: 0, cost: 1, multiplier: 8.10 },
                            wanJunSuanNi: { level: 0, cost: 1, multiplier: 24.30 },
                            yanYuBiAn: { level: 0, cost: 1, multiplier: 72.30 },
                            yuyu1: { level: 0, cost: 1, multiplier: 218.70 },
                              yuyu2: { level: 0, cost: 1, multiplier: 656.10 },
                            yuyu3: { level: 0, cost: 1, multiplier: 1968.30 },
                              yuyu4: { level: 0, cost: 1, multiplier: 5904.90 },
                            yuyu5: { level: 0, cost: 1, multiplier: 17714.70 },
                            yuyu6: { level: 0, cost: 1, multiplier: 53144.10 },
                              yuyu7: { level: 0, cost: 1, multiplier: 159432.30 },
                            yuyu8: { level: 0, cost: 1, multiplier: 478296.90 }
                        },
                        dungeonEquipment: [], // 新增副本装备
                        soulRings: [], // 新增魂环系统
                        techniques: {},
                        attributes: {
                         totalPoints: 0,
                        remainingPoints: 0,
                        health: 0,
                        attack: 0,
                        critRate: 0,
                         critDamage: 0,
                       multiAttack: 0,
                         block: 0
                        },
                        lastUpdate: Date.now(),
                        achievements: {
        first_equipment: false,
        first_rare: false,
        first_epic: false,
        first_legendary: false,
        first_ancient: false,
        first_divine: false,
        first_arcane: false,
        first_celestial: false,
        first_infernal: false,
        first_astral: false,
        first_primeval: false,
        first_transcendental: false,
        first_quantum: false,
        first_ultimate: false,
        first_chaos: false,
        first_eternal: false,
        first_void: false,
        first_genesis: false,
        first_divineRealm: false,
        first_apocalypse: false,
        first_yeyu1: false,
        first_yeyu2: false,
        first_yeyu3: false,
        first_yeyu4: false,
        first_yeyu5: false,
        first_yeyu6: false,
        first_yeyu7: false,
        first_yeyu8: false,
        first_yeyu9: false,
        first_yeyu10: false,
        first_yeyu11: false,
        first_yeyu12: false,
        first_yeyu13: false,
        first_yeyu14: false,
        first_yeyu15: false,
        first_yeyu16: false,
        first_yeyu17: false,
        first_yeyu18: false,
        first_yeyu19: false,
        first_yeyu20: false,
        first_yeyu21: false,
        first_yeyu22: false,
        first_yeyu23: false,
        first_yeyu24: false,
        // 宝箱成就
        common_chest_100: false,
        common_chest_10000: false,
        common_chest_1000000: false,
        common_chest_10000000: false,
        common_chest_100000000: false,
        advanced_chest_100: false,
        advanced_chest_10000: false,
        advanced_chest_1000000: false,
        advanced_chest_10000000: false,
        advanced_chest_100000000: false,
        rare_chest_100: false,
        rare_chest_10000: false,
        rare_chest_1000000: false,
        rare_chest_10000000: false,
        rare_chest_100000000: false,
        epic_chest_100: false,
        epic_chest_10000: false,
        epic_chest_1000000: false,
        epic_chest_10000000: false,
        epic_chest_100000000: false,
        legendary_chest_100: false,
        legendary_chest_10000: false,
        legendary_chest_1000000: false,
        legendary_chest_10000000: false,
        legendary_chest_100000000: false,
        chaos_chest_100: false,
        chaos_chest_10000: false,
        chaos_chest_1000000: false,
        chaos_chest_10000000: false,
        chaos_chest_100000000: false,
        apocalypse_chest_100: false,
        apocalypse_chest_10000: false,
        apocalypse_chest_1000000: false,
        apocalypse_chest_10000000: false,
        apocalypse_chest_100000000: false,
        yeyu1_chest_100: false,
        yeyu1_chest_10000: false,
        yeyu1_chest_1000000: false,
        yeyu1_chest_10000000: false,
        yeyu1_chest_100000000: false,
        yeyu2_chest_100: false,
        yeyu2_chest_10000: false,
        yeyu2_chest_1000000: false,
        yeyu2_chest_10000000: false,
        yeyu2_chest_100000000: false,
        yeyu3_chest_100: false,
        yeyu3_chest_10000: false,
        yeyu3_chest_1000000: false,
        yeyu3_chest_10000000: false,
        yeyu3_chest_100000000: false,
        yeyu4_chest_100: false,
        yeyu4_chest_10000: false,
        yeyu4_chest_1000000: false,
        yeyu4_chest_10000000: false,
        yeyu4_chest_100000000: false,
        yeyu5_chest_100: false,
        yeyu5_chest_10000: false,
        yeyu5_chest_1000000: false,
        yeyu5_chest_10000000: false,
        yeyu5_chest_100000000: false,
        yeyu6_chest_100: false,
        yeyu6_chest_10000: false,
        yeyu6_chest_1000000: false,
        yeyu6_chest_10000000: false,
        yeyu6_chest_100000000: false,
        yeyu7_chest_100: false,
        yeyu7_chest_10000: false,
        yeyu7_chest_1000000: false,
        yeyu7_chest_10000000: false,
        yeyu7_chest_100000000: false,
        yeyu8_chest_100: false,
        yeyu8_chest_10000: false,
        yeyu8_chest_1000000: false,
        yeyu8_chest_10000000: false,
        yeyu8_chest_100000000: false,
        "max_stage_10": false,
    "max_stage_30": false,
    "max_stage_60": false,
    "max_stage_90": false,
    "max_stage_120": false,
    "max_stage_200": false,
    "max_stage_300": false,
    "max_stage_400": false,
    "max_stage_500": false,
    "max_stage_600": false,
    "max_stage_700": false,
    "max_stage_800": false,
    "max_stage_900": false,
    "max_stage_1000": false,

    // 新增宠物成就状态
    "thunderKirin_10": false,
    "thunderKirin_50": false,
    "thunderKirin_100": false,
    "chaosTaotie_10": false,
    "chaosTaotie_50": false,
    "chaosTaotie_100": false,
    "netherQiongqi_10": false,
    "netherQiongqi_50": false,
    "netherQiongqi_100": false,
    "abyssKun_10": false,
    "abyssKun_50": false,
    "abyssKun_100": false,
    "primordialZhuLong_10": false,
    "primordialZhuLong_50": false,
    "primordialZhuLong_100": false,
    "wanJunSuanNi_10": false,
    "wanJunSuanNi_50": false,
    "wanJunSuanNi_100": false,
    "yanYuBiAn_10": false,
    "yanYuBiAn_50": false,
    "yanYuBiAn_100": false,
    "yuyu1_10": false,
    "yuyu1_50": false,
    "yuyu1_100": false,
    "yuyu2_10": false,
    "yuyu2_50": false,
    "yuyu2_100": false,
    "yuyu3_10": false,
    "yuyu3_50": false,
    "yuyu3_100": false,
    "yuyu4_10": false,
    "yuyu4_50": false,
    "yuyu4_100": false,
    "yuyu5_10": false,
    "yuyu5_50": false,
    "yuyu5_100": false,
    "yuyu6_10": false,
    "yuyu6_50": false,
    "yuyu6_100": false,
    "yuyu7_10": false,
    "yuyu7_50": false,
    "yuyu7_100": false,
    "yuyu8_10": false,
    "yuyu8_50": false,
    "yuyu8_100": false,
    // 新增魂环成就状态
    "year1_10": false,
    "year10_10": false,
    "year100_10": false,
    "year1000_10": false,
    "year10000_10": false,
    "year100000_10": false,
    "year1000000_10": false,
    "year10000000_10": false,
    "year100000000_10": false,
    "year1_100": false,
    "year10_100": false,
    "year100_100": false,
    "year1000_100": false,
    "year10000_100": false,
    "year100000_100": false,
    "year1000000_100": false,
    "year10000000_100": false,
    "year100000000_100": false,
    "year1_1000": false,
    "year10_1000": false,
    "year100_1000": false,
    "year1000_1000": false,
    "year10000_1000": false,
    "year100000_1000": false,
    "year1000000_1000": false,
    "year10000000_1000": false,
    "year100000000_1000": false,
    "year1_10000": false,
    "year10_10000": false,
    "year100_10000": false,
    "year1000_10000": false,
    "year10000_10000": false,
    "year100000_10000": false,
    "year1000000_10000": false,
    "year10000000_10000": false,
    "year100000000_10000": false,
    "year2_10": false,
    "year2_100": false,
    "year2_1000": false,
    "year2_10000": false,
    "year3_10": false,
    "year3_100": false,
    "year3_1000": false,
    "year3_10000": false,
    "year4_10": false,
    "year4_100": false,
    "year4_1000": false,
    "year4_10000": false,
    "year5_10": false,
    "year5_100": false,
    "year5_1000": false,
    "year5_10000": false,
    "year6_10": false,
    "year6_100": false,
    "year6_1000": false,
    "year6_10000": false,
    "year7_10": false,
    "year7_100": false,
    "year7_1000": false,
    "year7_10000": false,
    "year8_10": false,
    "year8_100": false,
    "year8_1000": false,
    "year8_10000": false,
    "year9_10": false,
    "year9_100": false,
    "year9_1000": false,
    "year9_10000": false,
    "year11_10": false,
    "year11_100": false,
    "year11_1000": false,
    "year11_10000": false,
    "year12_10": false,
    "year12_100": false,
    "year12_1000": false,
    "year12_10000": false,
    "year13_10": false,
    "year13_100": false,
    "year13_1000": false,
    "year13_10000": false,
    "year14_10": false,
    "year14_100": false,
    "year14_1000": false,
    "year14_10000": false,
    "year15_10": false,
    "year15_100": false,
    "year15_1000": false,
    "year15_10000": false,
    "year16_10": false,
    "year16_100": false,
    "year16_1000": false,
    "year16_10000": false,
    "year17_10": false,
    "year17_100": false,
    "year17_1000": false,
    "year17_10000": false,
    "year18_10": false,
    "year18_100": false,
    "year18_1000": false,
    "year18_10000": false,
    "year19_10": false,
    "year19_100": false,
    "year19_1000": false,
    "year19_10000": false,
    "year20_10": false,
    "year20_100": false,
    "year20_1000": false,
    "year20_10000": false,
    "year21_10": false,
    "year21_100": false,
    "year21_1000": false,
    "year21_10000": false,
    "year22_10": false,
    "year22_100": false,
    "year22_1000": false,
    "year22_10000": false,
    "year23_10": false,
    "year23_100": false,
    "year23_1000": false,
    "year23_10000": false,
    "year24_10": false,
    "year24_100": false,
    "year24_1000": false,
    "year24_10000": false,
    "year25_10": false,
    "year25_100": false,
    "year25_1000": false,
    "year25_10000": false,
    "year26_10": false,
    "year26_100": false,
    "year26_1000": false,
    "year26_10000": false,
    "year27_10": false,
    "year27_100": false,
    "year27_1000": false,
    "year27_10000": false,
    "year28_10": false,
    "year28_100": false,
    "year28_1000": false,
    "year28_10000": false,
    "year29_10": false,
    "year29_100": false,
    "year29_1000": false,
    "year29_10000": false,
    "year30_10": false,
    "year30_100": false,
    "year30_1000": false,
    "year30_10000": false,
    "year31_10": false,
    "year31_100": false,
    "year31_1000": false,
    "year31_10000": false,
    "year32_10": false,
    "year32_100": false,
    "year32_1000": false,
    "year32_10000": false,
    "year33_10": false,
    "year33_100": false,
    "year33_1000": false,
    "year33_10000": false,
    "year34_10": false,
    "year34_100": false,
    "year34_1000": false,
    "year34_10000": false,
    "year35_10": false,
    "year35_100": false,
    "year35_1000": false,
    "year35_10000": false,
    "year36_10": false,
    "year36_100": false,
    "year36_1000": false,
    "year36_10000": false,
    "year37_10": false,
    "year37_100": false,
    "year37_1000": false,
    "year37_10000": false,
    "world_boss_1st": false,
    "world_boss_top5": false,
    "world_boss_top10": false,
    "world_boss_participant": false,
    
        // 转生成就
        reincarnation_10: false,
        reincarnation_100: false,
        reincarnation_1000: false,
        reincarnation_10000: false
                        },
                        actionLogs: [], // 新增：统一存储所有操作日志
                        goldLogs: [], // 保留原有金币日志（如果仍需单独使用）
                        autoBuy: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], // 对应 7 种宝箱的自动购买状态
                        autoBuyMaterialChest: false, // 新增：自动购买材料宝箱的状态
                      autoBuyTechniqueChest: false,
                     autoBuyTechniqueMaxCost: 0.1,
                        gpsMultiplier: 1,
                        clickMultiplier: 1,
                        autoConvert: false,
                        autoConvertCurrency: { gold: false, diamond: false, titanium: false, starstone: false }, // 新增：自动兑换货币状态
                        clickTimestamps: [],
                        chestCounts: { common: 0, advanced: 0, rare: 0, epic: 0, legendary: 0 },
                        reincarnationStats: {
                            gpsBonus: { level: 0, cost: 1 },
                            equipmentLevelBonus: { level: 0, cost: 1 },
                            clickLimitBonus: { level: 0, cost: 1 }
                        },
                        materialChestCost: 1,
                        stockData: { // 新增股票数据
                            stocks: [
                                { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                                { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                                { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                                { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                                { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
                            ],
                            lastStockUpdate: Date.now()
                        },
                        lotteryResults: [], // 新增：彩票开奖结果
                        traditionalLotteryNumbers: [], // 新增：传统数字彩票号码
                        lastLotteryDraw: Date.now(), // 新增：上次开奖时间
                        bank: { // 新增银行系统
                            deposit: 0, // 存款金额
                            lastInterestUpdate: Date.now() // 上次利息计算时间
                        }
                    };
                    updateDisplay();
                    logAction('游戏已重置', 'success');
                }
            });
        }

        // 自定义对话框逻辑
        function showCustomConfirm(message, callback) {
            const dialog = document.getElementById('customDialog');
            const overlay = document.getElementById('dialogOverlay');
            document.getElementById('dialogMessage').textContent = message;
            
            dialog.style.display = 'block';
            overlay.style.display = 'block';

            const confirmBtn = document.getElementById('dialogConfirm');
            const cancelBtn = document.getElementById('dialogCancel');

            const handler = (result) => {
                dialog.style.display = 'none';
                overlay.style.display = 'none';
                callback(result);
                confirmBtn.removeEventListener('click', confirmHandler);
                cancelBtn.removeEventListener('click', cancelHandler);
            };

            const confirmHandler = () => handler(true);
            const cancelHandler = () => handler(false);

            confirmBtn.addEventListener('click', confirmHandler);
            cancelBtn.addEventListener('click', cancelHandler);
        }

        function showCustomPrompt(message, callback) {
            const dialog = document.getElementById('customDialog');
            const overlay = document.getElementById('dialogOverlay');
            document.getElementById('dialogMessage').textContent = message;
            document.getElementById('dialogInput').style.display = 'block'; // 显示输入框
            document.getElementById('dialogInput').value = ''; // 清空输入框

            dialog.style.display = 'block';
            overlay.style.display = 'block';

            const confirmBtn = document.getElementById('dialogConfirm');
            const cancelBtn = document.getElementById('dialogCancel');

            const handler = (result) => {
                dialog.style.display = 'none';
                overlay.style.display = 'none';
                document.getElementById('dialogInput').style.display = 'none'; // 隐藏输入框
                callback(result);
                confirmBtn.removeEventListener('click', confirmHandler);
                cancelBtn.removeEventListener('click', cancelHandler);
            };

            const confirmHandler = () => handler(document.getElementById('dialogInput').value);
            const cancelHandler = () => handler(null);

            confirmBtn.addEventListener('click', confirmHandler);
            cancelBtn.addEventListener('click', cancelHandler);
        }

        // 游戏初始化
        loadSave();
        // 延迟执行离线跑商（此时 runTradingOfflineIfNeeded 已定义），避免仅依赖 onload 导致不执行
        setTimeout(function() {
            if (typeof runTradingOfflineIfNeeded === 'function') runTradingOfflineIfNeeded();
        }, 800);
        if (!versionErrorBlocked) {
            if (player.name === "勇者") {
                setTimeout(function() {
                    document.getElementById("renameDialog").style.display = "block";
                    document.getElementById("renameOverlay").style.display = "block";
                    document.getElementById("renameDialogTitle").textContent = "请为你的角色起一个名字吧（1-10个字符）：";
                    document.getElementById("newNameInput").value = player.name;
                    document.getElementById("newNameInput").focus();
                }, 500);
            }
        }
        registerInterval(() => {
    if (checkVersionBlocked()) return;
    let gpsPerSecond = getTotalGPS();
    // 如果在线且开启了加速，应用100倍加成
    if (document.visibilityState === 'visible' && player.onlineBoostEnabled) {
        gpsPerSecond *= 100;
    }
    player.gold += gpsPerSecond; // 每秒增加GPS
    autoConvertCurrency(); 
  gainCultivationExp();
 calculateNightClubIncome(); // 已在主循环每秒执行，勿在此处再开 setInterval 否则会定时器泄漏
 updateLiveStreamUI();
  initAutoDecomposeUI();
    checkAutoBuy(); 
 checkAutoDecompose();
    updateStockPrices(); 
    calculateBankInterest(); 
  calculateOfflineExpeditionRewards();
   updateFundValues(); // 添加这一行 
 checkAutoReincarnation(); // 检查自动转生
 updateCompanionDisplay();
 updateLotteryCountdown();
 updateDisplay();
   if (player.battle.maxStage > 10500) {
        localStorage.removeItem('goldGameSave');
        player = {
                        gold: 0,
                        diamond: 0,
                        titanium: 0,
                        starstone: 0,
                        cosmicstone: 0,
                        superstone: 0,
                        otherworldstone: 0, 
                        xingjiestone: 0, 
                        hundunstone: 0,  
                        lingtone: 0,
                        huangtone: 0,
                        mingtone: 0,
                        xutong: 0,
                        shitone: 0,
                        weitone: 0,
                        reincarnationCoin: 0,
                        reincarnationCount: 0,
                        equipment: [],
                        vip: {
        level: 1,
        power: 0, // 累计VIP能力值数量
    },
                        items: {
                            primaryGem: 0,
                            advancedGem: 0,
                            superiorGem: 0,
                            divineGem: 0,
                            vipPower: 0,
                            refineStone: 0 // 新增洗炼石
                        },
                        collections: {
                            lightSpeedHand: 0,
                            empHand: 0,
                            godlyHand: 0,
                            quickHand: 0,
                            shadowHand: 0,
                            quantumHand: 0,
                            lightningHand: 0,
                            divineHand: 0
                        },
                        pets: {
                             thunderKirin: { level: 0, cost: 1, multiplier: 0.10 },
                             chaosTaotie: { level: 0, cost: 1, multiplier: 0.30 },
                             netherQiongqi: { level: 0, cost: 1, multiplier: 0.90 },
                             abyssKun: { level: 0, cost: 1, multiplier: 2.70 },
                             primordialZhuLong: { level: 0, cost: 1, multiplier: 8.10 },
                            wanJunSuanNi: { level: 0, cost: 1, multiplier: 24.30 },
                            yanYuBiAn: { level: 0, cost: 1, multiplier: 72.90 },
                            yuyu1: { level: 0, cost: 1, multiplier: 218.70 },
                              yuyu2: { level: 0, cost: 1, multiplier: 656.10 },
                            yuyu3: { level: 0, cost: 1, multiplier: 1968.30 },
                              yuyu4: { level: 0, cost: 1, multiplier: 5904.90 },
                            yuyu5: { level: 0, cost: 1, multiplier: 17714.70 },
                            yuyu6: { level: 0, cost: 1, multiplier: 53144.10 },
                              yuyu7: { level: 0, cost: 1, multiplier: 159432.30 },
                            yuyu8: { level: 0, cost: 1, multiplier: 478296.90 }
                        },
                        dungeonEquipment: [], // 新增副本装备
                        soulRings: [], // 新增魂环系统
                        techniques: {},
                        attributes: {
                         totalPoints: 0,
                        remainingPoints: 0,
                        health: 0,
                        attack: 0,
                        critRate: 0,
                         critDamage: 0,
                       multiAttack: 0,
                         block: 0
                        },
                        lastUpdate: Date.now(),
                        achievements: {
        first_equipment: false,
        first_rare: false,
        first_epic: false,
        first_legendary: false,
        first_ancient: false,
        first_divine: false,
        first_arcane: false,
        first_celestial: false,
        first_infernal: false,
        first_astral: false,
        first_primeval: false,
        first_transcendental: false,
        first_quantum: false,
        first_ultimate: false,
        first_chaos: false,
        first_eternal: false,
        first_void: false,
        first_genesis: false,
        first_divineRealm: false,
        first_apocalypse: false,
        first_yeyu1: false,
        first_yeyu2: false,
        first_yeyu3: false,
        first_yeyu4: false,
        first_yeyu5: false,
        first_yeyu6: false,
        first_yeyu7: false,
        first_yeyu8: false,
        first_yeyu9: false,
        first_yeyu10: false,
        first_yeyu11: false,
        first_yeyu12: false,
        first_yeyu13: false,
        first_yeyu14: false,
        first_yeyu15: false,
        first_yeyu16: false,
        first_yeyu17: false,
        first_yeyu18: false,
        first_yeyu19: false,
        first_yeyu20: false,
        first_yeyu21: false,
        first_yeyu22: false,
        first_yeyu23: false,
        first_yeyu24: false,
        // 宝箱成就
        common_chest_100: false,
        common_chest_10000: false,
        common_chest_1000000: false,
        common_chest_10000000: false,
        common_chest_100000000: false,
        advanced_chest_100: false,
        advanced_chest_10000: false,
        advanced_chest_1000000: false,
        advanced_chest_10000000: false,
        advanced_chest_100000000: false,
        rare_chest_100: false,
        rare_chest_10000: false,
        rare_chest_1000000: false,
        rare_chest_10000000: false,
        rare_chest_100000000: false,
        epic_chest_100: false,
        epic_chest_10000: false,
        epic_chest_1000000: false,
        epic_chest_10000000: false,
        epic_chest_100000000: false,
        legendary_chest_100: false,
        legendary_chest_10000: false,
        legendary_chest_1000000: false,
        legendary_chest_10000000: false,
        legendary_chest_100000000: false,
        chaos_chest_100: false,
        chaos_chest_10000: false,
        chaos_chest_1000000: false,
        chaos_chest_10000000: false,
        chaos_chest_100000000: false,
        apocalypse_chest_100: false,
        apocalypse_chest_10000: false,
        apocalypse_chest_1000000: false,
        apocalypse_chest_10000000: false,
        apocalypse_chest_100000000: false,
        yeyu1_chest_100: false,
        yeyu1_chest_10000: false,
        yeyu1_chest_1000000: false,
        yeyu1_chest_10000000: false,
        yeyu1_chest_100000000: false,
        yeyu2_chest_100: false,
        yeyu2_chest_10000: false,
        yeyu2_chest_1000000: false,
        yeyu2_chest_10000000: false,
        yeyu2_chest_100000000: false,
        yeyu3_chest_100: false,
        yeyu3_chest_10000: false,
        yeyu3_chest_1000000: false,
        yeyu3_chest_10000000: false,
        yeyu3_chest_100000000: false,
        yeyu4_chest_100: false,
        yeyu4_chest_10000: false,
        yeyu4_chest_1000000: false,
        yeyu4_chest_10000000: false,
        yeyu4_chest_100000000: false,
        yeyu5_chest_100: false,
        yeyu5_chest_10000: false,
        yeyu5_chest_1000000: false,
        yeyu5_chest_10000000: false,
        yeyu5_chest_100000000: false,
        yeyu6_chest_100: false,
        yeyu6_chest_10000: false,
        yeyu6_chest_1000000: false,
        yeyu6_chest_10000000: false,
        yeyu6_chest_100000000: false,
        yeyu7_chest_100: false,
        yeyu7_chest_10000: false,
        yeyu7_chest_1000000: false,
        yeyu7_chest_10000000: false,
        yeyu7_chest_100000000: false,
        yeyu8_chest_100: false,
        yeyu8_chest_10000: false,
        yeyu8_chest_1000000: false,
        yeyu8_chest_10000000: false,
        yeyu8_chest_100000000: false,
        "max_stage_10": false,
    "max_stage_30": false,
    "max_stage_60": false,
    "max_stage_90": false,
    "max_stage_120": false,
    "max_stage_200": false,
    "max_stage_300": false,
    "max_stage_400": false,
    "max_stage_500": false,
    "max_stage_600": false,
    "max_stage_700": false,
    "max_stage_800": false,
    "max_stage_900": false,
    "max_stage_1000": false,

    // 新增宠物成就状态
    "thunderKirin_10": false,
    "thunderKirin_50": false,
    "thunderKirin_100": false,
    "chaosTaotie_10": false,
    "chaosTaotie_50": false,
    "chaosTaotie_100": false,
    "netherQiongqi_10": false,
    "netherQiongqi_50": false,
    "netherQiongqi_100": false,
    "abyssKun_10": false,
    "abyssKun_50": false,
    "abyssKun_100": false,
    "primordialZhuLong_10": false,
    "primordialZhuLong_50": false,
    "primordialZhuLong_100": false,
    "wanJunSuanNi_10": false,
    "wanJunSuanNi_50": false,
    "wanJunSuanNi_100": false,
    "yanYuBiAn_10": false,
    "yanYuBiAn_50": false,
    "yanYuBiAn_100": false,
    "yuyu1_10": false,
    "yuyu1_50": false,
    "yuyu1_100": false,
    "yuyu2_10": false,
    "yuyu2_50": false,
    "yuyu2_100": false,
    "yuyu3_10": false,
    "yuyu3_50": false,
    "yuyu3_100": false,
    "yuyu4_10": false,
    "yuyu4_50": false,
    "yuyu4_100": false,
    "yuyu5_10": false,
    "yuyu5_50": false,
    "yuyu5_100": false,
    "yuyu6_10": false,
    "yuyu6_50": false,
    "yuyu6_100": false,
    "yuyu7_10": false,
    "yuyu7_50": false,
    "yuyu7_100": false,
    "yuyu8_10": false,
    "yuyu8_50": false,
    "yuyu8_100": false,
    // 新增魂环成就状态
    "year1_10": false,
    "year10_10": false,
    "year100_10": false,
    "year1000_10": false,
    "year10000_10": false,
    "year100000_10": false,
    "year1000000_10": false,
    "year10000000_10": false,
    "year100000000_10": false,
    "year1_100": false,
    "year10_100": false,
    "year100_100": false,
    "year1000_100": false,
    "year10000_100": false,
    "year100000_100": false,
    "year1000000_100": false,
    "year10000000_100": false,
    "year100000000_100": false,
    "year1_1000": false,
    "year10_1000": false,
    "year100_1000": false,
    "year1000_1000": false,
    "year10000_1000": false,
    "year100000_1000": false,
    "year1000000_1000": false,
    "year10000000_1000": false,
    "year100000000_1000": false,
    "year1_10000": false,
    "year10_10000": false,
    "year100_10000": false,
    "year1000_10000": false,
    "year10000_10000": false,
    "year100000_10000": false,
    "year1000000_10000": false,
    "year10000000_10000": false,
    "year100000000_10000": false,
    "year2_10": false,
    "year2_100": false,
    "year2_1000": false,
    "year2_10000": false,
    "year3_10": false,
    "year3_100": false,
    "year3_1000": false,
    "year3_10000": false,
    "year4_10": false,
    "year4_100": false,
    "year4_1000": false,
    "year4_10000": false,
    "year5_10": false,
    "year5_100": false,
    "year5_1000": false,
    "year5_10000": false,
    "year6_10": false,
    "year6_100": false,
    "year6_1000": false,
    "year6_10000": false,
    "year7_10": false,
    "year7_100": false,
    "year7_1000": false,
    "year7_10000": false,
    "year8_10": false,
    "year8_100": false,
    "year8_1000": false,
    "year8_10000": false,
    "year9_10": false,
    "year9_100": false,
    "year9_1000": false,
    "year9_10000": false,
    "year11_10": false,
    "year11_100": false,
    "year11_1000": false,
    "year11_10000": false,
    "year12_10": false,
    "year12_100": false,
    "year12_1000": false,
    "year12_10000": false,
    "year13_10": false,
    "year13_100": false,
    "year13_1000": false,
    "year13_10000": false,
    "year14_10": false,
    "year14_100": false,
    "year14_1000": false,
    "year14_10000": false,
    "year15_10": false,
    "year15_100": false,
    "year15_1000": false,
    "year15_10000": false,
    "year16_10": false,
    "year16_100": false,
    "year16_1000": false,
    "year16_10000": false,
    "year17_10": false,
    "year17_100": false,
    "year17_1000": false,
    "year17_10000": false,
    "year18_10": false,
    "year18_100": false,
    "year18_1000": false,
    "year18_10000": false,
    "year19_10": false,
    "year19_100": false,
    "year19_1000": false,
    "year19_10000": false,
    "year20_10": false,
    "year20_100": false,
    "year20_1000": false,
    "year20_10000": false,
    "year21_10": false,
    "year21_100": false,
    "year21_1000": false,
    "year21_10000": false,
    "year22_10": false,
    "year22_100": false,
    "year22_1000": false,
    "year22_10000": false,
    "year23_10": false,
    "year23_100": false,
    "year23_1000": false,
    "year23_10000": false,
    "year24_10": false,
    "year24_100": false,
    "year24_1000": false,
    "year24_10000": false,
    "year25_10": false,
    "year25_100": false,
    "year25_1000": false,
    "year25_10000": false,
    "year26_10": false,
    "year26_100": false,
    "year26_1000": false,
    "year26_10000": false,
    "year27_10": false,
    "year27_100": false,
    "year27_1000": false,
    "year27_10000": false,
    "year28_10": false,
    "year28_100": false,
    "year28_1000": false,
    "year28_10000": false,
    "year29_10": false,
    "year29_100": false,
    "year29_1000": false,
    "year29_10000": false,
    "year30_10": false,
    "year30_100": false,
    "year30_1000": false,
    "year30_10000": false,
    "year31_10": false,
    "year31_100": false,
    "year31_1000": false,
    "year31_10000": false,
    "year32_10": false,
    "year32_100": false,
    "year32_1000": false,
    "year32_10000": false,
    "year33_10": false,
    "year33_100": false,
    "year33_1000": false,
    "year33_10000": false,
    "year34_10": false,
    "year34_100": false,
    "year34_1000": false,
    "year34_10000": false,
    "year35_10": false,
    "year35_100": false,
    "year35_1000": false,
    "year35_10000": false,
    "year36_10": false,
    "year36_100": false,
    "year36_1000": false,
    "year36_10000": false,
    "year37_10": false,
    "year37_100": false,
    "year37_1000": false,
    "year37_10000": false,
    "world_boss_1st": false,
    "world_boss_top5": false,
    "world_boss_top10": false,
    "world_boss_participant": false,
    
        // 转生成就
        reincarnation_10: false,
        reincarnation_100: false,
        reincarnation_1000: false,
        reincarnation_10000: false
                        },
                        actionLogs: [], // 新增：统一存储所有操作日志
                        goldLogs: [], // 保留原有金币日志（如果仍需单独使用）
                        autoBuy: [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], // 对应 7 种宝箱的自动购买状态
                        autoBuyMaterialChest: false, // 新增：自动购买材料宝箱的状态
                      autoBuyTechniqueChest: false,
                      autoBuyTechniqueMaxCost: 0.1,
                        gpsMultiplier: 1,
                        clickMultiplier: 1,
                        autoConvert: false,
                        autoConvertCurrency: { gold: false, diamond: false, titanium: false, starstone: false }, // 新增：自动兑换货币状态
                        clickTimestamps: [],
                        chestCounts: { common: 0, advanced: 0, rare: 0, epic: 0, legendary: 0 },
                        reincarnationStats: {
                            gpsBonus: { level: 0, cost: 1 },
                            equipmentLevelBonus: { level: 0, cost: 1 },
                            clickLimitBonus: { level: 0, cost: 1 }
                        },
                        materialChestCost: 1,
                        stockData: { // 新增股票数据
                            stocks: [
                                { name: '青龙至尊股', basePrice: 1, currentPrice: 1, lastPrice: 1, shares: 0, avgCost: 0 },
                                { name: '白虎至尊股', basePrice: 10, currentPrice: 10, lastPrice: 10, shares: 0, avgCost: 0 },
                                { name: '朱雀至尊股', basePrice: 100, currentPrice: 100, lastPrice: 100, shares: 0, avgCost: 0 },
                                { name: '玄武至尊股', basePrice: 1000, currentPrice: 1000, lastPrice: 1000, shares: 0, avgCost: 0 },
                                { name: '瑞兽白泽股', basePrice: 10000, currentPrice: 10000, lastPrice: 10000, shares: 0, avgCost: 0 }
                            ],
                            lastStockUpdate: Date.now()
                        },
                        lotteryResults: [], // 新增：彩票开奖结果
                        traditionalLotteryNumbers: [], // 新增：传统数字彩票号码
                        lastLotteryDraw: Date.now(), // 新增：上次开奖时间
                        bank: { // 新增银行系统
                            deposit: 0, // 存款金额
                            lastInterestUpdate: Date.now() // 上次利息计算时间
                        }
        };
        updateDisplay();
        logAction('游戏已自动重置', 'success');
    }
}, 1000);
        updateDisplay();

        // 页面可见性监听
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible') {
                window._tradingOfflineRunThisSession = false; // 切回标签允许本次离线结算
                loadSave();
                if (typeof runTradingOfflineIfNeeded === 'function') runTradingOfflineIfNeeded();
                updateDisplay();
                // 自动钓鱼防卡：切回页面后若已挂机超过约25秒仍显示在钓，视为被卡住，强制重置并续钓
                if (player.fishing && player.fishing.autoFishingEnabled && player.fishing.isFishing && player.fishing.fishingStartTime && (Date.now() - player.fishing.fishingStartTime > 25000)) {
                    try { resetFishing(); } catch (e) {}
                    if (player.fishing.autoFishingEnabled) setTimeout(function() { startFishing(); }, 500);
                }
            }
        });

        // 新增：切换游戏日志分页
        function switchLogTab(page) {
            document.getElementById('gameLogPage1').classList.remove('active');
            document.getElementById('gameLogPage2').classList.remove('active');
            document.getElementById('gameLogPage3').classList.remove('active');
            document.getElementById('gameLogPage4').classList.remove('active');
            document.getElementById(`gameLogPage${page}`).classList.add('active');
            document.querySelectorAll('.log-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.log-tab[onclick="switchLogTab(${page})"]`).classList.add('active');
        }
   function toggleAutoConvertUI() {
    const ui = document.getElementById('autoConvertUI');
    const overlay = document.getElementById('autoConvertOverlay');
    
    if (ui.style.display === 'none') {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        if (typeof updateAutoConvertDisplay === 'function') updateAutoConvertDisplay();
    } else {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    }
}
function toggleAutoBuyShopa() {
      if (player.level.ascentionCounta < 1) {
        alert("需要达到轮回1转才能开启轮回副本！");
        return;
    }
    const shop = document.getElementById('autoBuyShopa');
    shop.style.display = shop.style.display === 'none' ? 'block' : 'none';
}
function toggleAutoBuyShopb() {
      if (player.cultivation.stage < 2) {
        alert("需要达到修仙2级才能开启修仙副本！");
        return;
    }
    const shop = document.getElementById('autoBuyShopb');
    shop.style.display = shop.style.display === 'none' ? 'block' : 'none';
}
function toggleAutoBuyShop() {
    const shop = document.getElementById('autoBuyShop');
    if (shop.style.display === 'none') {
        shop.style.display = 'block';
        if (typeof syncAutoBuyPanelDisplay === 'function') syncAutoBuyPanelDisplay();
    } else {
        shop.style.display = 'none';
    }
}
function toggleShopUI() {
    const shopUI = document.getElementById('shopUI');
    const overlay = document.getElementById('shopOverlay');
    
    if (shopUI.style.display === 'none') {
        shopUI.style.display = 'block';
        overlay.style.display = 'block';
    } else {
        shopUI.style.display = 'none';
        overlay.style.display = 'none';
    }
}
function toggleSettingsUI() {
    const dialog = document.getElementById('settingsDialog');
    const overlay = document.getElementById('settingsOverlay');
    
    if (dialog.style.display === 'none') {
        dialog.style.display = 'block';
        overlay.style.display = 'block';
    } else {
        dialog.style.display = 'none';
        overlay.style.display = 'none';
    }
}

        // 新增：打怪模式逻辑
        function toggleMonsterUI() {
    if (player.reincarnationCount < 1) {
        alert("需要达到1转才能开启打怪模式！");
        return;
    }
    const monsterUI = document.getElementById('monsterUI');
    monsterUI.style.display = monsterUI.style.display === 'none' ? 'block' : 'none';
    if (monsterUI.style.display === 'block') {
        // 重新生成玩家属性，但不重新生成怪物
        player.battle.playerHealth = player.reincarnationCount;
        player.battle.playerAttack = getTotalClickValue();
      updateOfficialSystemDisplay();
        updateMonsterUI(); // 更新UI显示
      updatePlayerBattleStats();
      
    }
}

        function startBattle() {
    player.battle.playerHealth = 1 + player.reincarnationCount;
    player.battle.playerAttack = 1 + getTotalClickValue();
    player.battle.playerCritRate = 0.1 + player.attributes.critRate * 0.0005; // 初始暴击率 + 属性加成
    player.battle.playerCritDamage = 1.5 + player.attributes.critDamage * 0.005; // 初始爆伤 + 属性加成
    player.battle.currentStage = player.battle.currentStage || 0;
    player.battle.maxStage = Math.max(player.battle.maxStage, player.battle.currentStage);
   updateOfficialSystemDisplay();
    updateMonsterUI(); // 更新UI显示
}

        const monsterModifiers = {
    // 防御类词条
    "硬化": { damageReduction: 0.9 }, // 受到伤害减少10%
    "钢铁": { damageReduction: 0.99 }, // 受到伤害减少20%
    "金身": { damageReduction: 0.999 }, // 受到伤害减少50%
    "不败": { damageReduction: 0.9999 }, // 受到伤害减少70%
    "圣体": { damageReduction: 0.99999 }, // 受到伤害减少80%
    "不死": { damageReduction: 0.999999 }, // 受到伤害减少99%

    // 攻击类词条
    "强击": { attackMultiplier: 2.10 }, 
    "突击": { attackMultiplier: 3.20 }, 
    "嗜血": { attackMultiplier: 4.30 }, 
    "炼狱": { attackMultiplier: 5.40 }, 
    "修罗": { attackMultiplier: 6.50 }, 
    "死神": { attackMultiplier: 10.00 }, 

    // 闪避类词条
    "初级闪避": { dodgeChance: 0.5 },
    "中级闪避": { dodgeChance: 0.6 }, 
    "高级闪避": { dodgeChance: 0.7 }, 
    "终极闪避": { dodgeChance: 0.8 }, 
    "神级闪避": { dodgeChance: 0.9 }, 

    // 特殊效果类词条
    "抵消": { blockCount: 2 }, // 可以抵消玩家2次攻击
    "金光": { blockCount: 3 }, // 可以抵消玩家3次攻击
    "神盾": { blockCount: 5 }, // 可以抵消玩家5次攻击

    // 特殊攻击类词条
    "连击": { attackCount: 3 }, // 攻击5次
    "虚弱": { damageTakenMultiplier: 1.50 } // 受到玩家伤害增加50%
};
 
const monsterRankModifiers = {
    "普通": { pool: ["硬化", "强击", "初级闪避", "虚弱"], selectCount: 2 },
    "精英": { pool: ["连击", "硬化", "强击", "初级闪避"], selectCount: 2 },
    "普通BOSS": { pool: ["虚弱", "连击", "钢铁", "突击", "初级闪避"], selectCount: 3 },
    "特殊BOSS": { pool: ["连击",  "钢铁", "突击", "中级闪避"], selectCount: 3 },
    "领主BOSS": { pool: ["连击", "钢铁", "突击", "嗜血", "中级闪避", "抵消"], selectCount: 4 },
    "霸主级BOSS": { pool: ["金身", "连击", "嗜血", "突击", "中级闪避", "抵消"], selectCount: 4 },
    "王级BOSS": { pool: ["连击", "金身", "炼狱", "嗜血", "高级闪避", "抵消"], selectCount: 4 },
    "皇级BOSS": { pool: ["连击", "不败", "炼狱", "高级闪避", "抵消"], selectCount: 4 },
    "帝级BOSS": { pool: ["连击", "不败", "炼狱", "修罗", "高级闪避", "金光"], selectCount: 4 },
    "神级BOSS": { pool: ["连击", "圣体", "修罗", "终极闪避", "金光", "死神"], selectCount: 5 },
    "圣级BOSS": { pool: ["连击", "不死", "死神", "神级闪避", "神盾"], selectCount: 5 }
};
 const monsterNames = [
    "夜叉丸", "玄天青龙帝", "九幽冥凤尊", "太虚剑仙·凌霄", "紫微星君·太华",
    "黄泉引渡使", "焚天炎龙圣主", "噬魂夜叉皇", "青丘九尾天狐", "白骨夫人·夜魅",
    "天河银蛟龙王", "幽冥骑士·龙煞", "永恒梦魇·修普诺斯", "幽冥鬼判·玄煞", "金翅大鹏明王",
    "天启四骑士·天罚", "混沌主宰", "哥布林", "太虚剑灵", "月宫蟾仙",
    "九幽煞魔", "幽冥鬼王", "幽狱魔尊", "混元道傀", "八荒龙神",
    "炎阳帝君", "星垣神王", "黄金狮心王·理查德", "幽冥鬼判·玄煞", "金翅大鹏明王",
    "玉虚雷神将", "鸿蒙祖神", "玄天帝君", "风暴之眼", "暗月武士·凯恩",
    "黑丝女神·闫闫", "萝莉·茶茶", "修罗刀魔·无间", "机械降神·欧米茄", "光年守望者·天狼",
    "寒冰之魂", "血月狼王·芬里尔", "永恒黑暗·厄瑞玻斯", "虚数之龙·阿莱夫", "数据化身·尼奥"
];

function getRandomMonsterName() {
    return monsterNames[Math.floor(Math.random() * monsterNames.length)];
}

function generateMonster() {
    const stage = player.battle.currentStage;
    const monsterRanks = ['普通', '精英', '普通BOSS', '特殊BOSS', '领主BOSS', '霸主级BOSS', '王级BOSS', '皇级BOSS', '帝级BOSS', '神级BOSS', '圣级BOSS'];
    const rankProbabilities = [0.45, 0.20, 0.10, 0.06, 0.05, 0.04, 0.03, 0.03, 0.02, 0.015, 0.005];

    // 随机生成怪物品阶
    let rankIndex = 0;
    let rand = Math.random();
    for (let i = 0; i < rankProbabilities.length; i++) {
        rand -= rankProbabilities[i];
        if (rand < 0) {
            rankIndex = i;
            break;
        }
    }
    const rank = monsterRanks[rankIndex];

    // 根据品阶选择词条
    const modifierPool = monsterRankModifiers[rank].pool;
    const selectCount = monsterRankModifiers[rank].selectCount;
    const selectedModifiers = [];
    const usedModifiers = new Set(); // 用于记录已经使用的词条

    for (let i = 0; i < selectCount; i++) {
        let modifier;
        do {
            modifier = modifierPool[Math.floor(Math.random() * modifierPool.length)];
        } while (usedModifiers.has(modifier)); // 确保词条不重复
        usedModifiers.add(modifier); // 记录已使用的词条
        selectedModifiers.push(modifier);
    }

    // 计算怪物属性
    const healthMultiplier = Math.pow(1.148698355, stage);
    let attackMultiplier;
    if (stage <= 5) {
        attackMultiplier = Math.floor(Math.random() * 3) + 10;
    } else if (stage <= 15) {
        attackMultiplier = 35 + (stage - 4) * 100;
    } else if (stage <= 100) {
        attackMultiplier = 50 + (stage - 14) * 1000;
    } else if (stage <= 300) {
        attackMultiplier = 100 + (stage - 99) * 10000;
    } else if (stage <= 500) {
        attackMultiplier = 350 + (stage - 299) * 100000;
    } else if (stage <= 750) {
        attackMultiplier = 3500 + (stage - 499) * 1e9;
    } else if (stage <= 1000) {
        attackMultiplier = 35000 + (stage - 749) * 1e12;
    } else if (stage <= 1250) {
        attackMultiplier = 350000 + (stage - 999) * 1e15;
    } else if (stage <= 1500) {
        attackMultiplier = 3500000 + (stage - 1249) * 1e20;
    } else if (stage <= 1750) {
        attackMultiplier = 450000000 + (stage - 1499) * 1e25;
    } else if (stage <= 2000) {
        attackMultiplier = 5500009000 + (stage - 1749) * 1e30;
    } else if (stage <= 2250) {
        attackMultiplier = 650000000900 + (stage - 1999) * 1e60;
    } else if (stage <= 2500) {
        attackMultiplier = 6500000000900 + (stage - 2249) * 1e90;
     } else if (stage <= 2750) {
        attackMultiplier = 6500000000000900 + (stage - 2449) * 1e120;
     } else if (stage <= 3000) {
        attackMultiplier = 6500000000000000900 + (stage - 2749) * 1e150;
    } else if (stage <= 3250) {
        attackMultiplier = 65000000000000000000900 + (stage - 2999) * 1e180;
    } else if (stage <= 3500) {
        attackMultiplier = 6500000000000000000000000900 + (stage - 3249) * 1e210;
    } else if (stage <= 4000) {
        attackMultiplier = 10000000000000000000000000000000 + (stage - 3499) * 1e230;
    } else if (stage <= 4500) {
        attackMultiplier = 100000000000000000000000000000000000 + (stage - 3999) * 1e250;
    } else {
        attackMultiplier = 1000000000000000000000000000000000000000 + (stage - 4000) * 1e270;
    }

    // 应用词条效果
    let attack = attackMultiplier;
    let damageReduction = 0;
    let dodgeChance = 0;
    let blockCount = 0;
    let attackCount = 1;
    let damageTakenMultiplier = 1;

    selectedModifiers.forEach(modifier => {
        const effect = monsterModifiers[modifier];
        if (effect.attackMultiplier) attack *= effect.attackMultiplier;
        if (effect.damageReduction) damageReduction += effect.damageReduction;
        if (effect.dodgeChance) dodgeChance += effect.dodgeChance;
        if (effect.blockCount) blockCount += effect.blockCount;
        if (effect.attackCount) attackCount = effect.attackCount;
        if (effect.damageTakenMultiplier) damageTakenMultiplier *= effect.damageTakenMultiplier;
    });

    // 生成怪物
    player.battle.monster = {
        name: `${getRandomMonsterName()}             等级${stage  * 2 + 7}`, // 随机生成怪物名字
        rank: rank,
        health: 10000 * healthMultiplier,
        attack: attack,
        modifiers: selectedModifiers,
        damageReduction: damageReduction,
        dodgeChance: dodgeChance,
        blockCount: blockCount,
        attackCount: attackCount,
        damageTakenMultiplier: damageTakenMultiplier
    };
}

       function updateMonsterUI() {
    document.getElementById('playerHealth').textContent = player.battle.playerHealth.toExponential(3);
    document.getElementById('playerAttack').textContent = player.battle.playerAttack.toExponential(3);
    document.getElementById('playerCritRate').textContent = `${((player.battle.playerCritRate + player.attributes.critRate * 0.0005) * 100).toFixed(1)}%`; // 更新暴击率显示
    document.getElementById('playerCritDamage').textContent = `${((player.battle.playerCritDamage + player.attributes.critDamage * 0.005) * 100).toFixed(1)}%`; // 更新爆伤显示
    document.getElementById('playerAccuracy').textContent = `${(player.battle.playerAccuracy * 100).toFixed(1)}%`;
    document.getElementById('playerDodge').textContent = `${(player.battle.playerDodge * 100).toFixed(1)}%`;

    document.getElementById('currentStage').textContent = player.battle.currentStage + 1;
    document.getElementById('monsterName').textContent = player.battle.monster.name;
    document.getElementById('monsterRank').textContent = player.battle.monster.rank;
    document.getElementById('monsterHealth').textContent = player.battle.monster.health.toExponential(3);
    document.getElementById('monsterAttack').textContent = player.battle.monster.attack.toExponential(3);

    // 显示怪物词条
    const modifiers = player.battle.monster.modifiers.join(', ');
    document.getElementById('monsterModifiers').textContent = ` ${modifiers}`;
     
}
       function attackMonster() {
const now = Date.now();
            // 移除超过1秒的点击记录
            player.clickTimestamps = player.clickTimestamps.filter(timestamp => now - timestamp < 1000);

            const clickLimit = 10 + player.reincarnationStats.clickLimitBonus.level; // 每级增加1次点击上限
            if (player.clickTimestamps.length >= clickLimit) {
                logAction("点击速度过快，请稍后再试！", "error");
                return;
            }

            player.clickTimestamps.push(now);
    const monster = player.battle.monster;
    
    // 应用属性加成
    const playerAttack = player.battle.playerAttack;
    const playerCritRate = player.battle.playerCritRate;
    const playerCritDamage = player.battle.playerCritDamage;
    const playerMultiAttack = player.battle.playerMultiAttack;
    const playerBlock = Math.floor(player.attributes.block / 5000000); // 每5000000点抵消属性点抵消1次攻击

    // 新增：统计变量
    let totalDamage = 0;           // 总伤害
    let dodgeCount = 0;            // 闪避次数
    let critCount = 0;             // 暴击次数
    let normalDamage = 0;          // 普通伤害总和
    const totalAttacks = playerMultiAttack + 1; // 总连击次数

    // 连击次数
    for (let i = 0; i < totalAttacks; i++) {
        // 计算命中
        if (Math.random() < monster.dodgeChance) {
            dodgeCount++; // 记录闪避次数
            continue;
        }

        // 计算伤害
        let damage = playerAttack * monster.damageTakenMultiplier;
        damage *= (1 - monster.damageReduction); // 应用伤害减免

        // 抵消效果
        if (monster.blockCount > 0) {
            monster.blockCount--;
            logBattleAction(`你的攻击被抵消了！怪物剩余抵消次数：${monster.blockCount}`);
            continue;
        }

        // 暴击计算
        if (Math.random() < playerCritRate) {
            damage *= playerCritDamage; // 应用爆伤加成
            critCount++;
            totalDamage += damage;
        } else {
            normalDamage += damage;
            totalDamage += damage;
        }

        // 应用伤害
        monster.health -= damage;

        if (monster.health <= 0) {
            break; // 如果怪物被击败，跳出连击循环
        }
    }

    // 新增：输出综合攻击日志
    logBattleAction(`你造成了${totalDamage.toFixed(0)}点伤害 (${totalAttacks}连击) - 普通伤害: ${normalDamage.toFixed(0)}, 闪避x${dodgeCount} 暴击x${critCount}`);

    // 检查怪物是否被击败
    if (monster.health <= 0) {
        logBattleAction(`你击败了${monster.name}，通关第${player.battle.currentStage + 1}关！`);
        player.battle.currentStage++;
        player.battle.maxStage = Math.max(player.battle.maxStage, player.battle.currentStage);
        
        updatePlayerBattleStats();
        // 更新总属性点
        player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10;
        // 检查最大关卡成就
        checkMaxStageAchievements();
        // 新增：检查称号解锁
        checkTitleUnlocks();
        updateOfficialSystemDisplay();
        // 掉落副本装备
        dropDungeonEquipment(player.battle.currentStage);

        // 掉落魂环
        dropSoulRing(player.battle.currentStage);
       
        // 掉落道具
        dropItemsAfterBattle();
                 
        generateMonster();
    }

    updateMonsterUI();

    function checkMaxStageAchievements() {
    const maxStage = player.battle.maxStage;
    const achievements = [
        { stage: 10, key: 'max_stage_10' },
        { stage: 30, key: 'max_stage_30' },
        { stage: 60, key: 'max_stage_60' },
        { stage: 90, key: 'max_stage_90' },
        { stage: 120, key: 'max_stage_120' },
        { stage: 200, key: 'max_stage_200' },
        { stage: 300, key: 'max_stage_300' },
        { stage: 400, key: 'max_stage_400' },
        { stage: 500, key: 'max_stage_500' },
        { stage: 600, key: 'max_stage_600' },
        { stage: 700, key: 'max_stage_700' },
        { stage: 800, key: 'max_stage_800' },
        { stage: 900, key: 'max_stage_900' },
        { stage: 1000, key: 'max_stage_1000' },
    ];

    achievements.forEach(({ stage, key }) => {
        if (maxStage >= stage && !player.achievements[key]) {
            player.achievements[key] = true;
            const reward = achievementRewards[key];
            if (reward) {
                player.gpsMultiplier += reward.gpsMultiplier;
                logAction(`成就达成：${reward.description}，GPS奖励 +${reward.gpsMultiplier * 100}%`, 'success');
                updatePlayerBattleStats();
            }
        }
    });
}
    // 怪物反击逻辑
    if (monster.health > 0) {
        for (let i = 0; i < monster.attackCount; i++) {
            if (Math.random() > player.battle.playerDodge) {
                if (playerBlock > 0) {
                    playerBlock--; // 消耗一次抵消次数
                    logBattleAction(`你抵消了怪物的攻击！剩余抵消次数：${playerBlock}`);
                } else {
                    player.battle.playerHealth -= monster.attack; // 如果没有抵消次数，玩家受到伤害
                    logBattleAction(`${monster.name}对你造成了${monster.attack.toFixed(0)}点伤害`);
                }
            } else {
                logBattleAction('你闪避了怪物的攻击！');
            }
        }
    // 检查玩家是否被击败
        if (player.battle.playerHealth <= 0) {
            logBattleAction('你被怪物击败了！');
            monster.health = 10000 * Math.pow(1.148698355, player.battle.currentStage); // 重置怪物生命
          updatePlayerBattleStats();
       updateOfficialSystemDisplay();
        }
    }

    updateMonsterUI();
}
   // 掉落道具函数
function dropItemsAfterBattle() {
    const stage = player.battle.currentStage;

    // 洗炼石掉落（30关以上0.1%概率）
    if (stage >= 30 && Math.random() < 0.0005) {
        player.items.refineStone++;
        logBattleAction('获得了洗炼石！');
    }
     if (stage >= 1 && Math.random() < 0.0001) {
        player.items.vipPower++;
        logBattleAction('获得了VIP能力值！');
    }
   if (stage >= 50 && Math.random() < 0.0005) {
        player.items.primaryGem++;
        logBattleAction('获得了初级宝石！');
    }
     if (stage >= 100 && Math.random() < 0.0005) {
        player.items.advancedGem++;
        logBattleAction('获得了高级宝石！');
    }
     if (stage >= 150 && Math.random() < 0.0005) {
        player.items.superiorGem++;
        logBattleAction('获得了极品宝石！');
    }

     if (stage >= 1 && Math.random() < 0.001) {
        player.items.rose++;
        logBattleAction('获得了玫瑰花！');
    }

     if (stage >= 200 && Math.random() < 0.0001) {
        player.items.rebornDan++;
        logBattleAction('获得了洗髓丹！');
    }

     if (stage >= 1 && Math.random() < 0.0003) {
        player.items.companionKey++;
        logBattleAction('获得了伴侣钥匙！');
    }
    // 其他道具掉落逻辑可以在这里添加
}

// 更新道具显示
function updateItemDisplay() {
    const container = document.getElementById('itemContainer');
    container.innerHTML = Object.entries(player.items)
        .map(([key, value]) => {
            const item = itemEffects[key];
            return `<div>${item.name}: ${value} - ${item.description}</div>`;
        })
        .join('');
}
        function dropDungeonEquipment(stage) {
            const dropRates = getDropRatesByStage(stage);
            const drops = [];
            for (let i = 0; i < 3; i++) {
                const rand = Math.random();
                let cumulativeProb = 0;
                for (const [rarity, prob] of Object.entries(dropRates)) {
                    cumulativeProb += prob;
                    if (rand < cumulativeProb) {
                        drops.push(rarity);
                        break;
                    }
                }
            }

            drops.forEach(rarity => {
                addDungeonEquipment(rarity);
                logBattleAction(`获得了副本装备：${dungeonEquipmentTypes[rarity].name}`);
          // 新增：检查称号解锁
            checkTitleUnlocks();
            });
        }

        function dropSoulRing(stage) {
    const soulRingDrops = [
        { minStage: 1, type: 'year1', chance: 0.02 },
        { minStage: 105, type: 'year10', chance: 0.02 },
        { minStage: 205, type: 'year100', chance: 0.02 },
        { minStage: 305, type: 'year1000', chance: 0.02 },
        { minStage: 405, type: 'year10000', chance: 0.01 },
        { minStage: 505, type: 'year10000', chance: 0.01 },
        { minStage: 605, type: 'year100000', chance: 0.01 },
        { minStage: 705, type: 'year1000000', chance: 0.01 },
        { minStage: 890, type: 'year10000000', chance: 0.01 },
        { minStage: 920, type: 'year100000000', chance: 0.01 },
        { minStage: 1040, type: 'year2', chance: 0.01 },
        { minStage: 1160, type: 'year3', chance: 0.01 },
        { minStage: 1280, type: 'year4', chance: 0.01 },
        { minStage: 1300, type: 'year5', chance: 0.01 },
        { minStage: 1420, type: 'year6', chance: 0.01 },
        { minStage: 1540, type: 'year7', chance: 0.01 },
        { minStage: 1660, type: 'year8', chance: 0.01 },
        { minStage: 1780, type: 'year9', chance: 0.01 },
        { minStage: 1800, type: 'year11', chance: 0.01 },
        { minStage: 1920, type: 'year12', chance: 0.01 },
        { minStage: 2040, type: 'year13', chance: 0.01 },
        { minStage: 2160, type: 'year14', chance: 0.01 },
        { minStage: 2280, type: 'year15', chance: 0.01 },
        { minStage: 2300, type: 'year16', chance: 0.01 },
        { minStage: 2420, type: 'year17', chance: 0.01 },
        { minStage: 2540, type: 'year18', chance: 0.01 },
        { minStage: 2660, type: 'year19', chance: 0.01 },
        { minStage: 2780, type: 'year20', chance: 0.01 },
        { minStage: 2800, type: 'year21', chance: 0.01 },
        { minStage: 2920, type: 'year22', chance: 0.01 },
        { minStage: 3040, type: 'year23', chance: 0.01 },
        { minStage: 3100, type: 'year24', chance: 0.01 },
        { minStage: 3280, type: 'year25', chance: 0.01 },
        { minStage: 3300, type: 'year26', chance: 0.01 },
        { minStage: 3420, type: 'year27', chance: 0.01 },
        { minStage: 3540, type: 'year28', chance: 0.01 },
        { minStage: 3660, type: 'year29', chance: 0.01 },
        { minStage: 3780, type: 'year30', chance: 0.01 },
        { minStage: 3800, type: 'year31', chance: 0.01 },
        { minStage: 4020, type: 'year32', chance: 0.01 },
        { minStage: 4140, type: 'year33', chance: 0.01 },
        { minStage: 4280, type: 'year34', chance: 0.01 },
        { minStage: 4300, type: 'year35', chance: 0.01 },
        { minStage: 4420, type: 'year36', chance: 0.01 },
        { minStage: 4550, type: 'year37', chance: 0.01 }
    ];

    soulRingDrops.forEach(drop => {
        if (stage >= drop.minStage && Math.random() < drop.chance) {
            addSoulRing(drop.type);
            logBattleAction(`获得了${soulRingTypes[drop.type].name}`);
          // 新增：检查称号解锁
                checkTitleUnlocks();
            // 检查成就
            const ring = player.soulRings.find(r => r.type === drop.type);
            if (ring) {
                checkSoulRingAchievements(drop.type, ring.level);
            }
        }
    });
}

       function getDropRatesByStage(stage) {
            if (stage <= 5) {
                return { common: 0.9, rare: 0.1 };
            } else if (stage <= 20) {
                return { common: 0.9, rare: 0.04, epic: 0.05, legendary: 0.01  };
            } else if (stage <= 150) {
                return { common: 0.9, rare: 0.02, epic: 0.04, legendary: 0.03, ancient: 0.01 };
            } else if (stage <= 300) {
                return { common: 0.8, epic: 0.11, legendary: 0.03, ancient: 0.03, divine: 0.02, arcane: 0.01 };
            } else if (stage <= 450) {
                return { common: 0.8, legendary: 0.05, ancient: 0.06, divine: 0.04, arcane: 0.02, celestial: 0.02, infernal: 0.01 };
            } else if (stage <= 600) {
                return { common: 0.8, ancient: 0.04, divine: 0.06, arcane: 0.04, celestial: 0.02, infernal: 0.02, astral: 0.01, primeval: 0.01 };
            } else if (stage <= 750) {
                return { common: 0.8, divine: 0.03, arcane: 0.06, celestial: 0.04, infernal: 0.02, astral: 0.02, primeval: 0.01, transcendental: 0.01, quantum: 0.01 };
            } else if (stage <= 900) {
                return { common: 0.8, celestial: 0.03, infernal: 0.06, astral: 0.04, primeval: 0.02, transcendental: 0.02, quantum: 0.01, ultimate: 0.01, ultimate1: 0.01 };
            } else if (stage <= 1050) {
                return { common: 0.8, infernal: 0.03, astral: 0.06, primeval: 0.04, transcendental: 0.02, quantum: 0.02, ultimate: 0.01, ultimate2: 0.01, ultimate3: 0.01 };
            } else if (stage <= 1200) {
                return { common: 0.8, primeval: 0.03, transcendental: 0.06, quantum: 0.04, ultimate: 0.02, ultimate1: 0.02, ultimate2: 0.01, ultimate3: 0.01, ultimate4: 0.01 };
            } else if (stage <= 1350) {
                return { common: 0.8, quantum: 0.03, ultimate: 0.06, ultimate1: 0.04, ultimate2: 0.02, ultimate3: 0.02, ultimate4: 0.01, ultimate5: 0.01, ultimate6: 0.01 };
            } else if (stage <= 1500) {
                return { common: 0.8, ultimate1: 0.03, ultimate2: 0.06, ultimate3: 0.04, ultimate4: 0.02, ultimate5: 0.02, ultimate6: 0.01, ultimate7: 0.01, ultimate8: 0.01 };
            } else if (stage <= 1650) {
                return { common: 0.8, ultimate3: 0.03, ultimate4: 0.06, ultimate5: 0.04, ultimate6: 0.02, ultimate7: 0.02, ultimate8: 0.01, ultimate9: 0.01, ultimate10: 0.01 };
            } else if (stage <= 1800) {
                return { common: 0.8, ultimate5: 0.03, ultimate6: 0.06, ultimate7: 0.04, ultimate8: 0.02, ultimate9: 0.02, ultimate10: 0.01, ultimate11: 0.01, ultimate12: 0.01 };
            } else if (stage <= 1950) {
                return { common: 0.8, ultimate7: 0.03, ultimate8: 0.06, ultimate9: 0.04, ultimate10: 0.02, ultimate11: 0.02, ultimate12: 0.01, ultimate13: 0.01, ultimate14: 0.01 };
            } else if (stage <= 2100) {
                return { common: 0.8, ultimate9: 0.03, ultimate10: 0.06, ultimate11: 0.04, ultimate12: 0.02, ultimate13: 0.02, ultimate14: 0.01, ultimate15: 0.01, ultimate16: 0.01 };
            } else if (stage <= 2250) {
                return { common: 0.8, ultimate11: 0.03, ultimate12: 0.06, ultimate13: 0.04, ultimate14: 0.02, ultimate15: 0.02, ultimate16: 0.01, ultimate17: 0.01, ultimate18: 0.011 };
            } else if (stage <= 2400) {
                return { common: 0.8, ultimate13: 0.03, ultimate14: 0.06, ultimate15: 0.04, ultimate16: 0.02, ultimate17: 0.02, ultimate18: 0.01, ultimate19: 0.01, ultimate20: 0.01 };
            } else if (stage <= 2550) {
                return { common: 0.8, ultimate15: 0.03, ultimate16: 0.06, ultimate17: 0.04, ultimate18: 0.02, ultimate19: 0.02, ultimate20: 0.01, ultimate21: 0.01, ultimate22: 0.01 };
            } else if (stage <= 2700) {
                return { common: 0.8, ultimate17: 0.03, ultimate18: 0.06, ultimate19: 0.04, ultimate20: 0.02, ultimate21: 0.02, ultimate22: 0.01, ultimate23: 0.01, ultimate24: 0.01 };
            } else if (stage <= 2850) {
                return { common: 0.8, ultimate19: 0.03, ultimate20: 0.06, ultimate21: 0.04, ultimate22: 0.02, ultimate23: 0.02, ultimate24: 0.01, ultimate25: 0.01, ultimate26: 0.01 };
            } else if (stage <= 3000) {
                return { common: 0.8, ultimate21: 0.03, ultimate22: 0.06, ultimate23: 0.04, ultimate24: 0.02, ultimate25: 0.02, ultimate26: 0.01, ultimate27: 0.01, ultimate28: 0.01 };
            } else if (stage <= 3150) {
                return { common: 0.8, ultimate23: 0.03, ultimate24: 0.06, ultimate25: 0.04, ultimate26: 0.02, ultimate27: 0.02, ultimate28: 0.01, ultimate29: 0.01, ultimate30: 0.01 };
            } else if  (stage <= 3300) {
                return { common: 0.8, ultimate25: 0.03, ultimate26: 0.06, ultimate27: 0.04, ultimate28: 0.02, ultimate29: 0.02, ultimate30: 0.01, ultimate31: 0.01, ultimate32: 0.01 };
            } else if (stage <= 3450) {
                return { common: 0.8, ultimate27: 0.03, ultimate28: 0.06, ultimate29: 0.04, ultimate30: 0.02, ultimate31: 0.02, ultimate32: 0.01, ultimate33: 0.01, ultimate34: 0.01 };
            } else if (stage <= 3600) {
                return { common: 0.8, ultimate29: 0.03, ultimate30: 0.06, ultimate31: 0.04, ultimate32: 0.02, ultimate33: 0.02, ultimate34: 0.01, ultimate35: 0.01, ultimate36: 0.01 };
            } else if (stage <= 3750) {
                return { common: 0.8, ultimate31: 0.03, ultimate32: 0.06, ultimate33: 0.04, ultimate34: 0.02, ultimate35: 0.02, ultimate36: 0.01, ultimate37: 0.01, ultimate38: 0.01 };
            } else if (stage <= 3900) {
                return { common: 0.8, ultimate33: 0.03, ultimate34: 0.06, ultimate35: 0.04, ultimate36: 0.02, ultimate37: 0.02, ultimate38: 0.01, ultimate39: 0.01, ultimate40: 0.01 };
            } else if (stage <= 4050) {
                return { common: 0.8, ultimate35: 0.03, ultimate36: 0.06, ultimate37: 0.04, ultimate38: 0.02, ultimate39: 0.02, ultimate40: 0.01, ultimate41: 0.01, ultimate42: 0.01 };
            } else if (stage <= 4200) {
                return { common: 0.8, ultimate37: 0.03, ultimate38: 0.06, ultimate39: 0.04, ultimate40: 0.02, ultimate41: 0.02, ultimate42: 0.01, ultimate43: 0.01, ultimate44: 0.01 };
            } else if (stage <= 4350) {
                return { common: 0.8, ultimate39: 0.03, ultimate40: 0.06, ultimate41: 0.04, ultimate42: 0.02, ultimate43: 0.02, ultimate44: 0.01, ultimate45: 0.01, ultimate46: 0.01 };
            } else if (stage <= 4500) {
                return { common: 0.8, ultimate41: 0.03, ultimate42: 0.06, ultimate43: 0.04, ultimate44: 0.02, ultimate45: 0.02, ultimate46: 0.01, ultimate47: 0.01, ultimate48: 0.01 };
            } else {
                return { common: 0.8, ultimate43: 0.03, ultimate44: 0.06, ultimate45: 0.04, ultimate46: 0.02, ultimate47: 0.02, ultimate48: 0.01, ultimate49: 0.01, ultimate50: 0.01 };
            }
        }


        function fleeFromBattle() {
            const cost = player.battle.maxStage * 10;
            if (player.reincarnationCoin >= cost) {
                player.reincarnationCoin -= cost;
                player.battle.currentStage = 0;
                generateMonster();
               updateOfficialSystemDisplay();
                updateMonsterUI();
                logBattleAction(`你重置了关卡，消耗了${cost}转生币`);
            } else {
                logBattleAction('转生币不足，无法重置关卡！');
            }
        }
      
        function sweepStages() {
    const currentStage = player.battle.currentStage;
    const maxStage = player.battle.maxStage;
    const targetStage = Math.max(1, maxStage - 6); // 扫荡到最大关卡-5
    
    if (currentStage >= targetStage) {
        logBattleAction("没有可扫荡的关卡！");
        return;
    }
    
    // 计算消耗的转生币
    const cost = (targetStage - currentStage) * 2;
    
    if (player.reincarnationCoin < cost) {
        logBattleAction(`扫荡需要 ${cost} 转生币，当前不足！`);
        return;
    }
    
    // 确认对话框
    showCustomConfirm(`确定要扫荡从第${currentStage + 1}关到第${targetStage}关吗？消耗 ${cost} 转生币`, (confirmed) => {
        if (confirmed) {
            player.reincarnationCoin -= cost;
            
            // 记录扫荡前的状态
            const originalStage = player.battle.currentStage;
            let totalDrops = 0;
            let dungeonEquipmentDrops = 0;
            let soulRingDrops = 0;
            let itemDrops = 0;
            
            // 模拟扫荡过程
            for (let stage = currentStage; stage < targetStage; stage++) {
                player.battle.currentStage = stage;
                
                // 固定掉落3个副本装备
                for (let i = 0; i < 3; i++) {
                    const dungeonDrops = getDropRatesByStage(stage);
                    const rand = Math.random();
                    let cumulativeProb = 0;
                    
                    for (const [rarity, prob] of Object.entries(dungeonDrops)) {
                        cumulativeProb += prob;
                        if (rand < cumulativeProb) {
                            addDungeonEquipment(rarity);
                            dungeonEquipmentDrops++;
                            break;
                        }
                    }
                }
                
                // 魂环掉落（保持原逻辑）
                const soulRingResult = simulateSoulRingDrop(stage);
                if (soulRingResult) {
                    soulRingDrops++;
                }
                
                // 道具掉落（保持原逻辑）
                const itemResult = simulateItemDrop(stage);
                if (itemResult) {
                    itemDrops++;
                }
                
                // 更新显示（每10关更新一次）
                if (stage % 10 === 0) {
                    updateMonsterUI();
                }
            }
            
            // 扫荡完成后停留在目标关卡
            player.battle.currentStage = targetStage;
            generateMonster();
            
            logBattleAction(`扫荡完成！从第${originalStage + 1}关到第${targetStage}关`);
            logBattleAction(`获得副本装备: ${dungeonEquipmentDrops}件`);
            logBattleAction(`获得魂环: ${soulRingDrops}件`);
            logBattleAction(`获得道具: ${itemDrops}件`);
            updateMonsterUI();
           updateOfficialSystemDisplay();
        }
    });
}

// 单独提取魂环掉落逻辑
function simulateSoulRingDrop(stage) {
    const soulRingDrops = [
       { minStage: 1, type: 'year1', chance: 0.02 },
        { minStage: 105, type: 'year10', chance: 0.02 },
        { minStage: 205, type: 'year100', chance: 0.02 },
        { minStage: 305, type: 'year1000', chance: 0.02 },
        { minStage: 405, type: 'year10000', chance: 0.01 },
        { minStage: 505, type: 'year10000', chance: 0.01 },
        { minStage: 605, type: 'year100000', chance: 0.01 },
        { minStage: 705, type: 'year1000000', chance: 0.01 },
        { minStage: 890, type: 'year10000000', chance: 0.01 },
        { minStage: 920, type: 'year100000000', chance: 0.01 },
        { minStage: 1040, type: 'year2', chance: 0.01 },
        { minStage: 1160, type: 'year3', chance: 0.01 },
        { minStage: 1280, type: 'year4', chance: 0.01 },
        { minStage: 1300, type: 'year5', chance: 0.01 },
        { minStage: 1420, type: 'year6', chance: 0.01 },
        { minStage: 1540, type: 'year7', chance: 0.01 },
        { minStage: 1660, type: 'year8', chance: 0.01 },
        { minStage: 1780, type: 'year9', chance: 0.01 },
        { minStage: 1800, type: 'year11', chance: 0.01 },
        { minStage: 1920, type: 'year12', chance: 0.01 },
        { minStage: 2040, type: 'year13', chance: 0.01 },
        { minStage: 2160, type: 'year14', chance: 0.01 },
        { minStage: 2280, type: 'year15', chance: 0.01 },
        { minStage: 2300, type: 'year16', chance: 0.01 },
        { minStage: 2420, type: 'year17', chance: 0.01 },
        { minStage: 2540, type: 'year18', chance: 0.01 },
        { minStage: 2660, type: 'year19', chance: 0.01 },
        { minStage: 2780, type: 'year20', chance: 0.01 },
        { minStage: 2800, type: 'year21', chance: 0.01 },
        { minStage: 2920, type: 'year22', chance: 0.01 },
        { minStage: 3040, type: 'year23', chance: 0.01 },
        { minStage: 3100, type: 'year24', chance: 0.01 },
        { minStage: 3280, type: 'year25', chance: 0.01 },
        { minStage: 3300, type: 'year26', chance: 0.01 },
        { minStage: 3420, type: 'year27', chance: 0.01 },
        { minStage: 3540, type: 'year28', chance: 0.01 },
        { minStage: 3660, type: 'year29', chance: 0.01 },
        { minStage: 3780, type: 'year30', chance: 0.01 },
        { minStage: 3800, type: 'year31', chance: 0.01 },
        { minStage: 4020, type: 'year32', chance: 0.01 },
        { minStage: 4140, type: 'year33', chance: 0.01 },
        { minStage: 4280, type: 'year34', chance: 0.01 },
        { minStage: 4300, type: 'year35', chance: 0.01 },
        { minStage: 4420, type: 'year36', chance: 0.01 },
        { minStage: 4550, type: 'year37', chance: 0.01 }
    ];
    
    for (const drop of soulRingDrops) {
        if (stage >= drop.minStage && Math.random() < drop.chance) {
            addSoulRing(drop.type);
            return true;
        }
    }
    return false;
}

// 单独提取道具掉落逻辑
function simulateItemDrop(stage) {
    let hasDropped = false;
    
    // 洗炼石掉落（1000关以上0.05%概率）
    if (stage >= 1000 && Math.random() < 0.0001) {
        player.items.refineStone++;
        hasDropped = true;
    }
    
    // VIP能力值掉落（全关卡0.1%概率）
    if (stage >= 1 && Math.random() < 0.0002) {
        player.items.vipPower++;
        hasDropped = true;
    }
    
    // 初级宝石掉落（500关以上0.04%概率）
    if (stage >= 500 && Math.random() < 0.0003) {
        player.items.primaryGem++;
        hasDropped = true;
    }
    
    // 高级宝石掉落（1000关以上0.03%概率）
    if (stage >= 1000 && Math.random() < 0.0002) {
        player.items.advancedGem++;
        hasDropped = true;
    }
    
    // 极品宝石掉落（1500关以上0.01%概率）
    if (stage >= 1500 && Math.random() < 0.0001) {
        player.items.superiorGem++;
        hasDropped = true;
    }
    
    // 玫瑰花掉落（1关以上0.05%概率）
    if (stage >= 1 && Math.random() < 0.001) {
        player.items.rose++;
        hasDropped = true;
    }
    // 洗髓丹匙掉落（2000关以上0.001%概率）
    if (stage >= 2000 && Math.random() < 0.0001) {
        player.items.rebornDan++;
        hasDropped = true;
    }
    // 洗髓丹匙掉落（1000关以上0.001%概率）
    if (stage >= 1000 && Math.random() < 0.0001) {
        player.items.baitCount++;
        hasDropped = true;
    }
    // 伴侣钥匙掉落（1关以上0.001%概率）
    if (stage >= 1 && Math.random() < 0.0001) {
        player.items.companionKey++;
        hasDropped = true;
    }
    
    return hasDropped;
}
        function jumpToStage() {
            const stage = parseInt(document.getElementById('jumpStage').value) || 0;
            if (stage > player.battle.currentStage && stage <= player.battle.maxStage && player.reincarnationCoin >= stage) {
                player.reincarnationCoin -= stage;
                player.battle.currentStage = stage;
                generateMonster();
                updateMonsterUI();
                logBattleAction(`你跳到了第${stage + 1}关`);
            } else {
                logBattleAction('无法跳到该关卡！');
            }
        }
     function formatNumber(value) {
    if (value >= 1e8) { // 当数值大于等于 100,000,000 时使用科学计数法
        return value.toExponential(3); // 保留两位小数
    } else {
        return value.toLocaleString(); // 否则使用常规的数值显示
    }
}
        function logBattleAction(message) {
    const formattedMessage = message.replace(/\d+(\.\d+)?/g, num => 
        formatSci(parseFloat(num))
    );
    
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `<div class="battle-log-entry">[${timestamp}] ${formattedMessage}</div>`;
    
    const logContainer = document.getElementById("battleLogContent");
    logContainer.insertAdjacentHTML("afterbegin", logEntry);
    
    // 保持最多20条日志
    if (logContainer.children.length > 20) {
        logContainer.removeChild(logContainer.lastChild);
    }
}
 let autoSweepInterval = null;
let isAutoSweeping = false;

// 添加自动扫荡控制函数
function toggleAutoSweep() {
    player.battle.autoSweepEnabled = !player.battle.autoSweepEnabled;
    
    // 更新UI显示
    document.getElementById('autoSweepStatus').textContent = 
        player.battle.autoSweepEnabled ? '开' : '关';
    
    // 如果开启自动扫荡，启动定时器
    if (player.battle.autoSweepEnabled) {
        startAutoSweep();
    } else {
        stopAutoSweep();
    }
    
    logAction(`自动扫荡已${player.battle.autoSweepEnabled ? '开启' : '关闭'}`, 'info');
    saveGame();
 
}

// 启动自动扫荡
function startAutoSweep() {
    // 清除现有定时器（如果有）
    stopAutoSweep();
    // 每4秒执行一次自动扫荡
    player.battle.autoSweepInterval = registerInterval(autoSweepProcess, 4000);
}

// 停止自动扫荡
function stopAutoSweep() {
    if (player.battle.autoSweepInterval) {
        clearInterval(player.battle.autoSweepInterval);
        player.battle.autoSweepInterval = null;
    }
}

// 自动扫荡处理流程
function autoSweepProcess() {
    // 检查是否需要重置关卡
    if (player.battle.currentStage >= Math.max(1, player.battle.maxStage - 1)) {
        // 重置关卡到0
        player.battle.currentStage = 0;
        logBattleAction("已自动重置关卡到初始位置");
    }
    
    // 执行扫荡
    const currentStage = player.battle.currentStage;
    const maxStage = player.battle.maxStage;
    const targetStage = Math.max(1, maxStage - 1);
    
    if (currentStage >= targetStage) {
        logBattleAction("自动扫荡：没有可扫荡的关卡，将重置关卡");
        return;
    }
    
    const cost = (targetStage - currentStage) * 12;
    if (player.reincarnationCoin < cost) {
        logBattleAction(`自动扫荡：转生币不足（需要${cost}），已停止`);
        toggleAutoSweep(); // 停止自动扫荡
        return;
    }
    
    // 自动执行扫荡（无需确认）
    player.reincarnationCoin -= cost;
    
    const originalStage = player.battle.currentStage;
    let totalDrops = 0;
    let dungeonEquipmentDrops = 0;
    let soulRingDrops = 0;
    let itemDrops = 0;
    
     for (let stage = currentStage; stage < targetStage; stage++) {
        player.battle.currentStage = stage;
        
        // 固定掉落3个副本装备 - 使用静默方式添加
        for (let i = 0; i < 3; i++) {
            const dungeonDrops = getDropRatesByStage(stage);
            const rand = Math.random();
            let cumulativeProb = 0;
            
            for (const [rarity, prob] of Object.entries(dungeonDrops)) {
                cumulativeProb += prob;
                if (rand < cumulativeProb) {
                    addDungeonEquipmentSilent(rarity); // 使用静默版本
                    dungeonEquipmentDrops++;
                    break;
                }
            }
        }
        
        // 魂环掉落 - 使用静默方式
        const soulRingResult = simulateSoulRingDropSilent(stage);
        if (soulRingResult) {
            soulRingDrops++;
        }
        
      // 道具掉落 - 保持原样（如果需要也可以静默）
        const itemResult = simulateItemDrop(stage);
        if (itemResult) {
            itemDrops++;
        }
    }

    // 扫荡完成后停留在目标关卡
    player.battle.currentStage = targetStage;
    generateMonster();
    
    logBattleAction(`自动扫荡完成！从第${originalStage + 1}关到第${targetStage}关`);
    logBattleAction(`获得副本装备: ${dungeonEquipmentDrops}件，魂环: ${soulRingDrops}个，道具: ${itemDrops}个`);
      updateOfficialSystemDisplay();
        updateMonsterUI(); 
}
// 静默添加副本装备（不显示提示）
function addDungeonEquipmentSilent(rarity) {
    const config = dungeonEquipmentTypes[rarity];
    const growthRate = Math.random() * (config.growthRange[1] - config.growthRange[0]) + config.growthRange[0];

    const existingEq = player.dungeonEquipment.find(eq => eq.rarity === rarity);
    if (existingEq) {
        existingEq.quantity = (existingEq.quantity || 1) + 1;
        if (existingEq.quantity >= 3) {
            existingEq.level++;
            existingEq.quantity = 0;
        }
    } else {
        const newEq = {
            name: config.name,
            rarity: rarity,
            level: 1,
            growthRate: growthRate,
            quantity: 1
        };
        player.dungeonEquipment.push(newEq);
    }
}

// 静默添加魂环（不显示提示）
function simulateSoulRingDropSilent(stage) {
    const soulRingDrops = [
        { minStage: 1, type: 'year1', chance: 0.02 },
        { minStage: 105, type: 'year10', chance: 0.02 },
        { minStage: 205, type: 'year100', chance: 0.02 },
        { minStage: 305, type: 'year1000', chance: 0.02 },
        { minStage: 405, type: 'year10000', chance: 0.01 },
        { minStage: 505, type: 'year10000', chance: 0.01 },
        { minStage: 605, type: 'year100000', chance: 0.01 },
        { minStage: 705, type: 'year1000000', chance: 0.01 },
        { minStage: 890, type: 'year10000000', chance: 0.01 },
        { minStage: 920, type: 'year100000000', chance: 0.01 },
        { minStage: 1040, type: 'year2', chance: 0.01 },
        { minStage: 1160, type: 'year3', chance: 0.01 },
        { minStage: 1280, type: 'year4', chance: 0.01 },
        { minStage: 1300, type: 'year5', chance: 0.01 },
        { minStage: 1420, type: 'year6', chance: 0.01 },
        { minStage: 1540, type: 'year7', chance: 0.01 },
        { minStage: 1660, type: 'year8', chance: 0.01 },
        { minStage: 1780, type: 'year9', chance: 0.01 },
        { minStage: 1800, type: 'year11', chance: 0.01 },
        { minStage: 1920, type: 'year12', chance: 0.01 },
        { minStage: 2040, type: 'year13', chance: 0.01 },
        { minStage: 2160, type: 'year14', chance: 0.01 },
        { minStage: 2280, type: 'year15', chance: 0.01 },
        { minStage: 2300, type: 'year16', chance: 0.01 },
        { minStage: 2420, type: 'year17', chance: 0.01 },
        { minStage: 2540, type: 'year18', chance: 0.01 },
        { minStage: 2660, type: 'year19', chance: 0.01 },
        { minStage: 2780, type: 'year20', chance: 0.01 },
        { minStage: 2800, type: 'year21', chance: 0.01 },
        { minStage: 2920, type: 'year22', chance: 0.01 },
        { minStage: 3040, type: 'year23', chance: 0.01 },
        { minStage: 3100, type: 'year24', chance: 0.01 },
        { minStage: 3280, type: 'year25', chance: 0.01 },
        { minStage: 3300, type: 'year26', chance: 0.01 },
        { minStage: 3420, type: 'year27', chance: 0.01 },
        { minStage: 3540, type: 'year28', chance: 0.01 },
        { minStage: 3660, type: 'year29', chance: 0.01 },
        { minStage: 3780, type: 'year30', chance: 0.01 },
        { minStage: 3800, type: 'year31', chance: 0.01 },
        { minStage: 4020, type: 'year32', chance: 0.01 },
        { minStage: 4140, type: 'year33', chance: 0.01 },
        { minStage: 4280, type: 'year34', chance: 0.01 },
        { minStage: 4300, type: 'year35', chance: 0.01 },
        { minStage: 4420, type: 'year36', chance: 0.01 },
        { minStage: 4550, type: 'year37', chance: 0.01 }
    ];
    
    for (const drop of soulRingDrops) {
        if (stage >= drop.minStage && Math.random() < drop.chance) {
            addSoulRingSilent(drop.type); // 使用静默版本
            return true;
        }
    }
    return false;
}

function addSoulRingSilent(type) {
    const existing = player.soulRings.find(r => r.type === type);
    if(existing) {
        existing.level++;
    } else {
        player.soulRings.push({
            type: type,
            level: 1,
            multiplier: soulRingTypes[type].baseMult
        });
    }
}
  function addAttributePoint(attribute, amount) {
    // 计算实际要加的点数
    let pointsToAdd = 0;
    if (amount === 'all') {
        pointsToAdd = player.attributes.remainingPoints; // 全部剩余属性点
    } else {
        pointsToAdd = Math.min(amount, player.attributes.remainingPoints); // 不能超过剩余属性点
    }

    if (pointsToAdd <= 0) {
        logAction("剩余属性点不足！", "error");
        return;
    }

    // 根据属性类型加点
    switch (attribute) {
        case 'health':
            player.attributes.health += pointsToAdd;
            break;
        case 'attack':
            player.attributes.attack += pointsToAdd;
            break;
        case 'critRate':
            player.attributes.critRate += pointsToAdd;
            break;
        case 'critDamage':
            player.attributes.critDamage += pointsToAdd;
            break;
        case 'multiAttack':
            player.attributes.multiAttack += pointsToAdd;
            break;
        case 'block':
            player.attributes.block += pointsToAdd;
            break;
        default:
            logAction("无效的属性类型！", "error");
            return;
    }

    // 扣除剩余属性点
    player.attributes.remainingPoints -= pointsToAdd;

    // 更新显示
    updatePlayerAttributesDisplay();
    logAction(`成功为${attribute}属性增加${pointsToAdd}点`, 'success');
}

function resetAttributes() {
    if (player.reincarnationCoin >= 1) {
        player.reincarnationCoin -= 1;
        // 重置所有属性点
        player.attributes.health = 0;
        player.attributes.attack = 0;
        player.attributes.critRate = 0;
        player.attributes.critDamage = 0;
        player.attributes.multiAttack = 0;
        player.attributes.block = 0;
        // 重置剩余属性点 = 总属性点
        player.attributes.remainingPoints = player.attributes.totalPoints;
        updatePlayerAttributesDisplay(); // 更新显示
        logAction("属性点已重置", "success");
    } else {
        logAction("转生币不足！", "error");
    }
}

 function handleBattleResult(isVictory) {
    // 保存当前的功法加成
    const techniqueBonuses = {
        health: player.attributes.healthBonus,
        attack: player.attributes.attackBonus,
        critRate: player.attributes.critRateBonus,
        critDamage: player.attributes.critDamageBonus,
        multiAttack: player.attributes.multiAttackBonus
    };
    
    if (isVictory) {
        // 胜利逻辑...
        player.battle.currentStage++;
        player.battle.maxStage = Math.max(player.battle.maxStage, player.battle.currentStage);
    } else {
        // 失败逻辑...
        player.battle.playerHealth = player.reincarnationCount;
    }
    
    // 恢复功法加成
    player.attributes.healthBonus = techniqueBonuses.health;
    player.attributes.attackBonus = techniqueBonuses.attack;
    player.attributes.critRateBonus = techniqueBonuses.critRate;
    player.attributes.critDamageBonus = techniqueBonuses.critDamage;
    player.attributes.multiAttackBonus = techniqueBonuses.multiAttack;
    
    // 更新玩家战斗属性
    updatePlayerBattleStats();
    
}
function updatePlayerAttributesDisplay() {
    // 计算总属性点
    const totalAttributePoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
    player.attributes.totalPoints = totalAttributePoints;

    // 更新总属性点和剩余属性点
    document.getElementById("totalAttributePoints").textContent = player.attributes.totalPoints;
    document.getElementById("remainingAttributePoints").textContent = player.attributes.remainingPoints;

    // 更新各属性加成显示和已投入点数
    document.getElementById("healthBonus").textContent = 
        (player.attributes.health * 1 + player.attributes.healthBonus * 100).toFixed(2) + "%";
    document.getElementById("healthPoints").textContent = player.attributes.health;
    
    document.getElementById("attackBonus").textContent = 
        (player.attributes.attack * 1 + player.attributes.attackBonus * 100).toFixed(2) + "%";
    document.getElementById("attackPoints").textContent = player.attributes.attack;
    
    document.getElementById("critRateBonus").textContent = 
        (player.attributes.critRate * 0.05 + player.attributes.critRateBonus * 100).toFixed(3) + "%";
    document.getElementById("critRatePoints").textContent = player.attributes.critRate;
    
    document.getElementById("critDamageBonus").textContent = 
        (player.attributes.critDamage * 0.50 + player.attributes.critDamageBonus * 100).toFixed(2) + "%";
    document.getElementById("critDamagePoints").textContent = player.attributes.critDamage;
    
    document.getElementById("multiAttackBonus").textContent = 
        Math.floor(player.attributes.multiAttack / 300) + player.attributes.multiAttackBonus;
    document.getElementById("multiAttackPoints").textContent = player.attributes.multiAttack;
}
function updateTechniqueBonuses() {
    // 重置所有加成
    player.attributes.healthBonus = 0;
    player.attributes.attackBonus = 0;
    player.attributes.critRateBonus = 0;
    player.attributes.critDamageBonus = 0;
    player.attributes.multiAttackBonus = 0;
    
    // 计算所有功法提供的加成
    Object.entries(player.techniques).forEach(([type, level]) => {
        const tech = techniqueConfig[type];
        if(tech) {
            switch(tech.type) {
                case 'health':
                    player.attributes.healthBonus += level * tech.effect;
                    break;
                case 'attack':
                    player.attributes.attackBonus += level * tech.effect;
                    break;
                case 'critRate':
                    player.attributes.critRateBonus += level * tech.effect;
                    break;
                case 'critDamage':
                    player.attributes.critDamageBonus += level * tech.effect;
                    break;
                case 'multiAttack':
                    player.attributes.multiAttackBonus += Math.floor(level * tech.effect);
                    break;
            }
        }
    });
    
    // 更新玩家战斗属性
    updatePlayerBattleStats();
     updateOfficialSystemDisplay();
    updatePlayerAttributesDisplay();
}
function updatePlayerBattleStats() {
 let mountHealthBonus = 0;
    let mountAttackBonus = 0;
    let mountCritDamageBonus = 0;  
    if (player.mounts.equipped) {
        const equippedMount = player.mounts.inventory.find(m => m.id === player.mounts.equipped);
        if (equippedMount) {
            // 坐骑等级加成（每级增加100%）
            const mountLevelMultiplier = player.mounts.level;
            
            // 计算各项属性加成
            if (equippedMount.stats.health) {
                mountHealthBonus = equippedMount.stats.health * mountLevelMultiplier;
            }
            if (equippedMount.stats.attack) {
                mountAttackBonus = equippedMount.stats.attack * mountLevelMultiplier;
            }
            if (equippedMount.stats.critDamage) {
                mountCritDamageBonus = equippedMount.stats.critDamage * mountLevelMultiplier;
            }
        }
    }

let wingHealthBonus = 0;
    if (player.wings.equipped) {
        const equippedWing = player.wings.inventory.find(w => w.id === player.wings.equipped);
        if (equippedWing) {
            wingHealthBonus = equippedWing.healthBonus * player.wings.level * 1; // 翅膀等级每级提供100%加成
        }
    }
     const runeBonuses = calculateRuneBonuses();
    // 1. 获取各类加成
    const classBonuses = calculateClassBonuses();
    const titleBonuses = calculateTotalBonuses(); // 重命名变量避免混淆
    const officialBonus = getOfficialBonus();
    const companionBonuses = getCompanionBonuses(); // 获取伴侣天赋加成
   const artifactBonuses = calculateArtifactBonuses();
    // 保存职业加成到player对象
    player.classBonuses = classBonuses;
    const bonuses = calculateGemBonuses(); 
    const techBonuses = calculateTechniqueBonuses();
   const equipmentStats = calculateTotalEquipmentStats();
   const beastBonus = calculateEquippedBeastBonus();
   const pixelBonus = getPixelPlayerBonus ? getPixelPlayerBonus() : { health: 0, attack: 0, critRate: 0, critDamage: 0 };
    // 2. 计算玩家生命（应用伴侣生命加成）
    player.battle.playerHealth = Math.floor(
        player.reincarnationCount * 
        (1 + player.attributes.healthBonus + player.attributes.health * 0.01) *
        classBonuses.healthMultiplier * titleBonuses.healthMultiplier *
        companionBonuses.healthMultiplier * (1 + artifactBonuses.health) * (1 + bonuses.health / 100) *  (1 + techBonuses.health) *  (1 + wingHealthBonus)  *  (1 + mountHealthBonus) *
        (1 + runeBonuses.health) * (1 + (player.mining.gems.emerald*0.05))  * (1+player.marriage.marriageBonuses.critRateBonus)  * (1+player.children.childBonuses.critRateBonus) * (1 + equipmentStats.health) * (1 +beastBonus.health) * (1 + pixelBonus.health) * (1+player.fiveElements.fire.level * 3.00)
    );

    // 3. 计算玩家攻击（应用伴侣攻击加成）
    player.battle.playerAttack = Math.floor(
        getTotalClickValue() * 
        (1 + player.attributes.attackBonus + player.attributes.attack * 0.01) *
        classBonuses.attackMultiplier * titleBonuses.attackMultiplier *
        officialBonus * companionBonuses.attackMultiplier * (1 + artifactBonuses.attack) * (1 + bonuses.attack / 100) *  (1 + techBonuses.attack* 10)  *  (1 + mountAttackBonus) *
        (1 + runeBonuses.attack) * (1 + (player.mining.gems.sapphire*0.05)) * (1+player.children.childBonuses.goldMultiplier)  *
        (1 + equipmentStats.attack) * (1 +beastBonus.attack) * (1 + pixelBonus.attack)
    );

    // 4. 计算暴击率（应用伴侣暴击率加成）
    const baseCritRate = 0.1 + player.attributes.critRateBonus + player.attributes.critRate * 0.00025 +
        classBonuses.critChance;
    player.battle.playerCritRate = Math.min(
        0.9,
        baseCritRate * companionBonuses.critRateMultiplier +  (1 + techBonuses.critRate) + (0.001+
        runeBonuses.critRate) +
        equipmentStats.critRate + pixelBonus.critRate
    );

    // 5. 计算爆伤（应用伴侣爆伤加成和全属性加成）
    player.battle.playerCritDamage = (1.5 + 
        player.attributes.critDamageBonus + 
        player.attributes.critDamage * 0.0025) *
        classBonuses.critMultiplier * titleBonuses.critMultiplier *
        companionBonuses.critDamageMultiplier * (1 + artifactBonuses.critDamage) * (1 + bonuses.critDamage / 100) *  (1 + techBonuses.critDamage* 10)  *  (1 + mountCritDamageBonus) *
        (1 + runeBonuses.critDamage)* (1 + (player.mining.gems.amethyst*0.05)) * (1+player.marriage.marriageBonuses.critDamageBonus) *
       (1 +equipmentStats.critDamage) * (1 +beastBonus.critDamage) * (1 + pixelBonus.critDamage) * (1+player.fiveElements.water.level * 3.00); // 应用伴侣爆伤加成

    // 6. 计算连击次数（应用伴侣连击加成）
    player.battle.playerMultiAttack = Math.max(1,
        Math.floor(player.attributes.multiAttack / 300) + 
        player.attributes.multiAttackBonus +
        companionBonuses.combo+ (1+techBonuses.multiAttack* 0.02) +
        (1+runeBonuses.combo))  // 应用伴侣连击加成
    ;

    // 更新UI显示
    updateMonsterUI();
}
function checkTimeValidity() {
    const now = Date.now();
    const storedTime = localStorage.getItem('lastValidTime');
    
    if (!storedTime) {
        localStorage.setItem('lastValidTime', now);
        return true;
    }
    
    const timeDiff = now - storedTime;
    if (timeDiff < 0 || timeDiff > 30 * 60 * 1000) { // 允许30分钟内偏差
        return false;
    }
    
    localStorage.setItem('lastValidTime', now);
    return true;
}

// 计算离线经验
// 新增：计算离线奥秘经验
function calculateOfflineMysteryExp() {
    if (!player.mystery || !player.mystery.lastUpdateTime) return;
    
    const now = Date.now();
    const timeDiff = now - player.mystery.lastUpdateTime;
   // 时间回退检测
    if (timeDiff < 0) {
        console.warn("检测到时间回退，重置奥秘经验");
        player.mystery.exp = 0;
        player.mystery.lastUpdateTime = now;
        return;
    }
    const minutesPassed = Math.floor(timeDiff / (1000 * 60));
    
    if (minutesPassed > 0) {
        const towerFloor = player.tower.currentFloor || 0;
        const vipLevel = player.vip.level || 1;
        const expGained = minutesPassed * towerFloor * vipLevel;
        
        if (expGained > 0) {
          const classBonuses = calculateClassBonuses();
            const mysteryExpMultiplier = classBonuses.mysteryExpMultiplier || 1;
            player.mystery.exp += expGained * mysteryExpMultiplier;
            logAction(`离线获得 ${expGained} 奥秘经验`, 'success');
        }
    }
    
    // 更新最后更新时间
    player.mystery.lastUpdateTime = now;
}
// 定时增加经验
registerInterval(() => {
    if (player.mystery) {
        const towerFloor = parseInt(document.getElementById('towerFloor').textContent) || 0;
        const vipLevel = parseInt(document.getElementById('vipLevel').textContent) || 1;
        let expPerMinute = towerFloor * vipLevel;
        
        if (expPerMinute > 0) {
            // 获取探险家职业的奥秘经验加成
            const classBonuses = calculateClassBonuses();
            const mysteryExpMultiplier = classBonuses.mysteryExpMultiplier || 1;
            
            // 应用加成
            expPerMinute = expPerMinute * mysteryExpMultiplier;
            
            // 奥秘每分钟增加一次，这里按秒计算
            player.mystery.exp += expPerMinute / 60;
            player.mystery.lastUpdateTime = new Date().getTime();
            updateMysterySystemDisplay();
        }
    }
}, 1000);

// 切换奥秘系统界面
function toggleMysterySystem() {
   if (player.reincarnationCount < 100) {
        alert("需要达到100转才能开启奥秘系统！");
        return;
    }
  calculateOfflineMysteryExp();
    const ui = document.getElementById('mysterySystemUI');
    const overlay = document.getElementById('mysterySystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateMysterySystemDisplay();
    }
}

// 更新奥秘系统显示
function updateMysterySystemDisplay() {
    const currentStage = player.mystery.stage;
    const currentLevel = player.mystery.level;
    const currentConfig = mysteryConfig.find(c => c.stage === currentStage);
    const nextLevel = currentLevel < 10 ? currentLevel + 1 : 1;
    const nextStage = currentLevel < 10 ? currentStage : currentStage + 1;
    const nextConfig = mysteryConfig.find(c => c.stage === nextStage);
    
    // 更新当前奥秘信息
    const title = `${currentConfig.name} ${currentStage}阶${currentLevel}级`;
    document.getElementById('mysteryTitleDisplay').textContent = title;
    document.getElementById('currentMysteryTitle').textContent = title;
    
    // 更新加成显示
    const maxStageReached = Math.min(currentStage, mysteryConfig.length);
    const maxConfig = mysteryConfig.find(c => c.stage === maxStageReached);
    document.getElementById('mysteryBonusDisplay').textContent = maxConfig ? maxConfig.totalBonus : 1;
    
    // 更新经验显示
    document.getElementById('currentMysteryExp').textContent = Math.floor(player.mystery.exp);
    document.getElementById('nextMysteryExp').textContent = currentConfig.levelCost;
     const classBonuses = calculateClassBonuses();
     const mysteryExpMultiplier = classBonuses.mysteryExpMultiplier || 1;
    // 更新每分钟经验
    const towerFloor = parseInt(document.getElementById('towerFloor').textContent) || 0;
    const vipLevel = parseInt(document.getElementById('vipLevel').textContent) || 1;
    document.getElementById('expPerMinute').textContent = (towerFloor * vipLevel * mysteryExpMultiplier).toFixed(0) ;
    


    // 更新下一等级信息
    const nextMysteryInfo = document.getElementById('nextMysteryInfo');
    if (nextConfig && currentStage < mysteryConfig.length) {
        nextMysteryInfo.innerHTML = `${nextConfig.name} ${nextStage}阶${nextLevel}级 - 消耗: ${nextConfig.levelCost}经验`;
    } else {
        nextMysteryInfo.textContent = '已达到最高奥秘等级';
      document.getElementById('mysteryBonusDisplay').textContent = player.mystery.bonus;
 const offlineExpElement = document.createElement('div');
    offlineExpElement.textContent = `离线经验: ${player.mystery.exp}`;
    container.appendChild(offlineExpElement);
    }
}

// 升级一次奥秘
function upgradeMystery() {
    const currentStage = player.mystery.stage;
    const currentLevel = player.mystery.level;
    const currentConfig = mysteryConfig.find(c => c.stage === currentStage);
    
    // 检查是否已达最高等级
    if (currentStage >= mysteryConfig.length && currentLevel >= 10) {
        logAction("已达到最高奥秘等级！", "error");
        return false;
    }
    
    // 检查经验是否足够
    if (player.mystery.exp < currentConfig.levelCost) {
        logAction("奥秘经验不足，无法升级！", "error");
        return false;
    }
    
    // 消耗经验
    player.mystery.exp -= currentConfig.levelCost;
    
    // 升级处理
    if (currentLevel < 10) {
        player.mystery.level += 1;
    } else {
        player.mystery.level = 1;
        player.mystery.stage += 1;
    }
    updateDisplay();
    return true;
}

// 按指定次数升级奥秘
function upgradeMysteryByAmount() {
    calculateOfflineMysteryExp();
    const amount = parseInt(document.getElementById('mysteryUpgradeAmount').value) || 1;
    let upgraded = 0;
    
    for (let i = 0; i < amount; i++) {
        if (!upgradeMystery()) {
            break;
        }
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级奥秘！`, 'success');
        updateMysterySystemDisplay();
        updateDisplay();
    }
}
 // 升级后更新加成
    const config = mysteryConfig.find(c => c.stage === player.mystery.stage);
    if (config) {
        player.mystery.bonus = config.totalBonus;
    }
  updateDisplay();

// 一键升级奥秘到最大可能
function upgradeMysteryMaxPossible() {
    calculateOfflineMysteryExp();
    let upgraded = 0;
    
    while (upgradeMystery()) {
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级奥秘！`, 'success');
        updateMysterySystemDisplay();
        updateDisplay();
    }
}
function resetFundData() {
    showCustomConfirm('确定要重置所有基金数据吗？这将清空所有投资和收益！', (confirmed) => {
        if (confirmed) {
            player.fundData = {
                funds: [
                    { name: "稳健型基金", netValue: 1.00, maxInvestment: 100000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "平衡型基金", netValue: 1.00, maxInvestment: 1000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "成长型基金", netValue: 1.00, maxInvestment: 100000000, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "进取型基金", netValue: 1.00, maxInvestment: 1e15, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "激进型基金", netValue: 1.00, maxInvestment: 1e30, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 },
                    { name: "风险型基金", netValue: 1.00, maxInvestment: 1e50, investment: 0, lastUpdate: Date.now(), redemptionTime: 0, returnRate: 0 }
                ],
                lastFundUpdate: Date.now()
            };
            
            logAction("基金数据已重置到初始状态", "success");
            updateFundDisplay();
        }
    });
}
// 切换基金系统显示状态
function toggleFundSystem() {
    const fundSystem = document.getElementById('fundSystem');
    const overlay = document.getElementById('fundOverlay');
    const isVisible = fundSystem.style.display !== 'none';
    
    fundSystem.style.display = isVisible ? 'none' : 'block';
    overlay.style.display = isVisible ? 'none' : 'block';
    
    if (!isVisible) {
        updateFundDisplay();
    }
}

// 更新基金显示
function updateFundDisplay() {
    const container = document.getElementById('fundsContainer');
    container.innerHTML = player.fundData.funds.map((fund, index) => {
        const currentValue = fund.investment * fund.netValue;
        const changeRate = ((fund.netValue - 1) * 100).toFixed(2);
        const isPositive = changeRate >= 0;
        const canRedeem = Date.now() >= fund.redemptionTime;
        const redemptionLeft = canRedeem ? 0 : Math.ceil((fund.redemptionTime - Date.now()) / 1000);
        
        return `
            <div style="border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 5px;">
                <h3>${fund.name}</h3>
                <p>当前净值: ${fund.netValue.toFixed(4)}</p>
                <p>收益率: <span style="color: ${fund.returnRate >= 0 ? 'green' : 'red'}">${fund.returnRate >= 0 ? '+' : ''}${fund.returnRate}%</span></p>
                <p>最大投资: ${formatNumber(fund.maxInvestment)} 转生币</p>
                <p>你的投资: ${formatNumber(fund.investment)} 转生币</p>
                <p>当前价值: ${formatNumber(currentValue)} 转生币</p>
                <p>涨幅度: <span style="color: ${isPositive ? 'green' : 'red'}">${isPositive ? '+' : ''}${changeRate}%</span></p>
                
                ${!canRedeem ? `<p>赎回倒计时: ${Math.floor(redemptionLeft / 60)}分${redemptionLeft % 60}秒</p>` : ''}
                
                <div style="margin-top: 10px;">
                    <input type="number" id="fundAmount${index}" placeholder="投资金额" min="1" style="width: 120px; margin-right: 10px;">
                    <button onclick="investFund(${index})" ${fund.investment >= fund.maxInvestment ? 'disabled' : ''}>投资</button>
                    <button onclick="investAllFund(${index})" ${fund.investment >= fund.maxInvestment ? 'disabled' : ''}>一键投资</button>
                    <button onclick="redeemAllFund(${index})" ${fund.investment <= 0 || !canRedeem ? 'disabled' : ''}>一键赎回</button>
                </div>
            </div>
        `;
    }).join('');
}
// 投资基金
function investFund(index) {
   const fund = player.fundData.funds[index];
// 检查是否在赎回前5分钟内
    const now = Date.now();
    const redemptionTime = fund.redemptionTime;
    if (redemptionTime && now > redemptionTime - 5 * 60 * 1000 && now < redemptionTime) {
        logAction("赎回前最后5分钟内禁止投资！", "error");
        return;
    }
    
    const amount = parseInt(document.getElementById(`fundAmount${index}`).value) || 0;
    
    if (amount <= 0) {
        logAction("请输入有效的投资金额", "error");
        return;
    }
    
    if (fund.investment + amount > fund.maxInvestment) {
        logAction(`投资金额超过基金上限${formatNumber(fund.maxInvestment)}`, "error");
        return;
    }
    
    if (player.reincarnationCoin < amount) {
        logAction("转生币不足！", "error");
        return;
    }
    // 检查赎回倒计时状态
    if (fund.redemptionTime <= 0) {
        // 如果没有赎回倒计时，重置净值为1
        fund.netValue = 1.00;
        logAction(`重置基金净值至1.00`, "info");
    }
    player.reincarnationCoin -= amount;
    fund.investment += amount;
    
    // 设置赎回时间为10分钟后
    if (fund.redemptionTime < Date.now()) {
        fund.redemptionTime = Date.now() + 10 * 60 * 1000;
    }
    
    logAction(`成功投资${fund.name} ${amount}转生币`, "success");
    updateFundDisplay();
}

// 赎回基金
function redeemFund(index) {
    const fund = player.fundData.funds[index];
    const amount = parseInt(document.getElementById(`fundAmount${index}`).value) || 0;
    
    if (amount <= 0) {
        logAction("请输入有效的赎回金额", "error");
        return;
    }
    
    if (fund.investment < amount) {
        logAction("投资金额不足！", "error");
        return;
    }
    
    const redeemValue = amount * fund.netValue;
    player.reincarnationCoin += redeemValue;
    fund.investment -= amount;
    
    logAction(`成功赎回${fund.name} ${amount}转生币，获得${redeemValue.toFixed(2)}转生币`, "success");
    
    if (fund.investment === 0) {
        fund.redemptionTime = 0;
    }
    
    updateFundDisplay();
}

// 一键投资
function investAllFund(index) {
    const fund = player.fundData.funds[index];
    const redeemedTime = Date.now() - fund.redemptionStart;
// 检查是否在赎回前5分钟内
    const now = Date.now();
    const redemptionTime = fund.redemptionTime;
    if (redemptionTime && now > redemptionTime - 5 * 60 * 1000 && now < redemptionTime) {
        logAction("赎回前最后5分钟内禁止投资！", "error");
        return;
    }
    const maxCanInvest = fund.maxInvestment - fund.investment;
    const amount = Math.min(player.reincarnationCoin, maxCanInvest);
    
    if (amount <= 0) {
        logAction("没有可投资的转生币或已达投资上限", "error");
        return;
    }
    // 检查赎回倒计时状态
    if (fund.redemptionTime <= 0) {
        // 如果没有赎回倒计时，重置净值为1
        fund.netValue = 1.00;
        logAction(`重置基金净值至1.00`, "info");
    }
    player.reincarnationCoin -= amount;
    fund.investment += amount;
    
    // 设置赎回时间为10分钟后
    if (fund.redemptionTime < Date.now()) {
        fund.redemptionTime = Date.now() + 10 * 60 * 1000;
    }
    
    logAction(`成功全额投资${fund.name} ${amount}转生币`, "success");
    updateFundDisplay();
}

// 一键赎回
function redeemAllFund(index) {
    const fund = player.fundData.funds[index];
    
    if (fund.investment <= 0) {
        logAction("没有可赎回的投资", "error");
        return;
    }
    
    if (Date.now() < fund.redemptionTime) {
        logAction("未到赎回时间", "error");
        return;
    }
    
    const redeemValue = fund.investment * fund.netValue;
    player.reincarnationCoin += redeemValue;
    
    logAction(`成功全额赎回${fund.name}，获得${redeemValue.toFixed(2)}转生币`, "success");
    
    fund.investment = 0;
    fund.redemptionTime = 0;
    
    updateFundDisplay();
}

// 更新基金净值
function updateFundValues() {
    const now = Date.now();
    const elapsed = now - player.fundData.lastFundUpdate;
    const intervals = Math.floor(elapsed / (60 * 1000)); // 每分钟更新一次
    
    if (intervals > 0) {
        player.fundData.funds.forEach(fund => {
           
            let riseProbability;
            if (fund.netValue < 1.0) {
                riseProbability = 0.45; 
            } else if (fund.netValue < 1.5) {
                riseProbability = 0.40; 
            } else if (fund.netValue < 2.0) {
                riseProbability = 0.35; 
            } else if (fund.netValue < 2.5) {
                riseProbability = 0.25; 
            } else {
                riseProbability = 0.10; 
            }

            // 计算投资比例（0-1）
            const investmentRatio = fund.maxInvestment > 0 ? Math.min(fund.investment / fund.maxInvestment, 1) : 0;
            
            // 根据投资比例计算波动幅度（10%-50%）
            const baseVolatility = 0.10 + (0.4 * investmentRatio);
            
           
            
            let newNetValue = fund.netValue;
            for (let i = 0; i < intervals; i++) {
                const willRise = Math.random() < riseProbability;
                const volatility = willRise ? 
                    Math.random() * baseVolatility : 
                    -Math.random() * baseVolatility;
                
                newNetValue *= (1 + volatility);
                
                // 检查是否跌到20%以下，若是则清零
                if (newNetValue <= 0.2) {
                    logAction(`${fund.name}已退市，投资已清零`, "error");
                    fund.investment = 0;
                    newNetValue = 1.00;
                    fund.redemptionTime = 0;
                    break;
                }
            }
            
            // 计算收益率（新增）
            const returnRate = ((newNetValue / fund.netValue - 1) * 100).toFixed(2);
            fund.returnRate = parseFloat(returnRate);
            
            // 更新净值
            fund.netValue = newNetValue;
        });
        
        player.fundData.lastFundUpdate = now - (elapsed % (60 * 1000));
        
        // 如果基金面板打开则更新显示
        if (document.getElementById('fundSystem').style.display !== 'none') {
            updateFundDisplay();
        }
    }
}


// 添加格式化大数字的辅助函数
function formatNumber(num) {
    if (num >= 1e30) return (num / 1e30).toFixed(2) + 'e30';
    if (num >= 1e15) return (num / 1e15).toFixed(2) + 'e15';
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
    return num.toFixed(2);
}

// 钓鱼系统配置
const fishQualities = [
    { name: "普通", color: "#000", exp: 1, rarity: 80 },
    { name: "稀有", color: "#008000", exp: 2, rarity: 12 },
    { name: "珍贵", color: "#0000CD", exp: 5, rarity: 5 },
    { name: "传说", color: "#8B4513", exp: 10, rarity: 2 },
    { name: "神话", color: "#FFD700", exp: 20, rarity: 1 }
];

const junkItems = [
    "破旧的鞋子", "生锈的铁片", "塑料瓶", "烂木头", "破布", "闫闫的黑丝", "比基尼", "杜蕾斯",
    "空罐头", "旧轮胎", "玻璃瓶", "渔网碎片", "朽木"
];

const fishNames = [
    "鲫鱼", "鲤鱼", "草鱼", "闫闫鱼", "黑鱼",
    "鲶鱼", "鳊鱼", "鳙鱼", "鲢鱼", "青鱼",
    "黄鱼", "鳕鳕鱼", "金枪鱼", "三文鱼", "鲨鱼",
    "鳗鱼", "带鱼", "比目鱼", "鲳鱼", "鲈鱼",
    "虹鳟鱼", "罗非鱼", "鲷鱼", "鲅鱼", "鲮鱼", "巨龙", "龙王", "金龙鱼",
    "泥鳅", "黄鳝", "河虾", "对虾", "龙虾", "鳄鱼", "石斑鱼", "秋刀鱼", "河豚",
    "螃蟹", "扇贝", "牡蛎", "蛤蜊", "叶鱼", "墨鱼", "黄花鱼", "中华鲟", "马口鱼",
    "章鱼", "墨鱼", "虾蛄", "海马", "海龙", "美人鱼",
    "河豚", "石斑鱼", "金鱼", "锦鲤", "斗鱼",
    "龙鱼", "天使鱼", "孔雀鱼", "罗汉鱼", "鹦鹉鱼"
];

const decompositionRewards = [
    "vip能力值", "洗髓丹", "洗练石", "玫瑰花"
];
const levelConfig = [
    { level: 1, requiredExp: 0, bonus: 1 },
    { level: 2, requiredExp: 100, bonus: 1 },
    { level: 3, requiredExp: 500, bonus: 1 },
    { level: 4, requiredExp: 1000, bonus: 1 },
    { level: 5, requiredExp: 2500, bonus: 1 },
    { level: 6, requiredExp: 5000, bonus: 1 },
    { level: 7, requiredExp: 10000, bonus: 1 },
    { level: 8, requiredExp: 25000, bonus: 1 },
    { level: 9, requiredExp: 50000, bonus: 1 },
    { level: 10, requiredExp: 100000, bonus: 1 },
    { level: 11, requiredExp: 500000, bonus: 1 },
    { level: 12, requiredExp: 1000000, bonus: 1 },
    { level: 13, requiredExp: 5000000, bonus: 1 },
    { level: 14, requiredExp: 10000000, bonus: 1 },
    { level: 15, requiredExp: 50000000, bonus: 1 }
];

// 钓鱼系统函数
function toggleFishingSystem() {
 if (player.reincarnationCount < 20) {
        alert("需要达到20转才能开启钓鱼系统！");
        return;
    }
    const ui = document.getElementById('fishingSystemUI');
    const overlay = document.getElementById('fishingSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateFishingUI();
    }
}
// 切换自动钓鱼状态
function toggleAutoFishing() {
    player.fishing.autoFishingEnabled = !player.fishing.autoFishingEnabled;
    const btn = document.getElementById('autoFishingBtn');
    btn.textContent = `自动钓鱼: ${player.fishing.autoFishingEnabled ? '开启' : '关闭'}`;
    btn.style.background = player.fishing.autoFishingEnabled ? '#4CAF50' : '#f44336';
    
    logAction(`自动钓鱼${player.fishing.autoFishingEnabled ? '开启' : '关闭'}`, 'info');
    
    // 如果开启自动钓鱼且当前没有在钓鱼，则开始钓鱼
    if (player.fishing.autoFishingEnabled && !player.fishing.isFishing) {
        startFishing();
    }
}

// 切换自动分解状态
function toggleAutoDecomposeFish() {
    player.fishing.autoDecomposeFishEnabled = !player.fishing.autoDecomposeFishEnabled;
    const btn = document.getElementById('autoDecomposeFishBtn');
    btn.textContent = `自动分解: ${player.fishing.autoDecomposeFishEnabled ? '开启' : '关闭'}`;
    btn.style.background = player.fishing.autoDecomposeFishEnabled ? '#2196F3' : '#f44336';
    
    logAction(`自动分解${player.fishing.autoDecomposeFishEnabled ? '开启' : '关闭'}`, 'info');
}

function updateFishingUI() {
    if (!player.fishing) return;
    
   document.getElementById('fishingLevel').textContent = player.fishing.level;
    document.getElementById('currentFishingExp').textContent = player.fishing.currentExp;
    
    // 使用玩家道具中的鱼饵数量
    document.getElementById('baitCount').textContent = player.items.baitCount || 0;
    
    document.getElementById('cageCount').textContent = player.fishing.fishCage.length;
    
    // 计算下一级所需经验
    const nextLevel = Math.min(player.fishing.level, levelConfig.length - 1);
     document.getElementById('nextFishingExp').textContent = levelConfig[player.fishing.level].requiredExp;
    
    document.getElementById('fishingBonus').textContent = player.fishing.bonus.toFixed(2) + '倍';
    
    // 同步自动钓鱼/自动分解按钮与存档一致，重新进游戏后显示正确
    var autoFishBtn = document.getElementById('autoFishingBtn');
    if (autoFishBtn) {
        autoFishBtn.textContent = '自动钓鱼: ' + (player.fishing.autoFishingEnabled ? '开启' : '关闭');
        autoFishBtn.style.background = player.fishing.autoFishingEnabled ? '#4CAF50' : '#f44336';
    }
    var autoDecomposeBtn = document.getElementById('autoDecomposeFishBtn');
    if (autoDecomposeBtn) {
        autoDecomposeBtn.textContent = '自动分解: ' + (player.fishing.autoDecomposeFishEnabled ? '开启' : '关闭');
        autoDecomposeBtn.style.background = player.fishing.autoDecomposeFishEnabled ? '#2196F3' : '#f44336';
    }
    
    updateFishCageDisplay();
}

function startFishing() {
    if (!player.fishing) return;
    try {
    // 检查是否有鱼饵（使用玩家道具中的鱼饵）
    if (!player.items.baitCount || player.items.baitCount <= 0) {
        var st = document.getElementById('fishingStatus'); if (st) st.textContent = "没有鱼饵了，无法钓鱼！";
        if (player.fishing.autoFishingEnabled) {
            player.fishing.autoFishingEnabled = false;
            var btn = document.getElementById('autoFishingBtn'); if (btn) { btn.textContent = "自动钓鱼: 关闭"; btn.style.background = '#f44336'; }
        }
        return;
    }
    
    // 检查鱼笼是否已满
    if (player.fishing.fishCage.length >= 20) {
        var st2 = document.getElementById('fishingStatus'); if (st2) st2.textContent = "鱼笼已满，请先分解一些鱼获！";
        return;
    }
    } catch (e) { console.warn('startFishing check', e); return; }
    
    try {
    // 消耗一个鱼饵（从玩家道具中扣除）
    player.items.baitCount--;
    updateFishingUI();
    
    // 更新状态（记录开始时间，供卡住检测用）
    player.fishing.isFishing = true;
    player.fishing.fishingStartTime = Date.now();
    var startBtn = document.getElementById('startFishingBtn'); if (startBtn) startBtn.style.display = 'none';
    var statusEl = document.getElementById('fishingStatus'); if (statusEl) statusEl.textContent = "正在下竿...等待鱼上钩...";
    var rod = document.getElementById('fishingRod'); if (rod) rod.style.display = 'block';
    var bob = document.getElementById('fishingBobber'); if (bob) bob.style.display = 'block';
    
    var biteDelay = 3000 + Math.random() * 7000; // 3-10秒
    player.fishing.biteTime = Date.now() + biteDelay;
    
    player.fishing.biteTimer = setTimeout(function() {
        try { fishBite(); } catch (e) { console.warn('fishBite', e); try { resetFishing(); } catch (e2) {} if (player.fishing && player.fishing.autoFishingEnabled) setTimeout(function() { startFishing(); }, 500); }
    }, biteDelay);
    } catch (e) {
        console.warn('startFishing', e);
        try { resetFishing(); } catch (e2) {}
        if (player.fishing && player.fishing.autoFishingEnabled) setTimeout(function() { startFishing(); }, 500);
    }
}

function fishBite() {
    if (!player.fishing) return;
    player.fishing.isBiting = true;
    try {
        var st = document.getElementById('fishingStatus'); if (st) st.textContent = "注意！有鱼对鱼饵感兴趣...";
        var bob = document.getElementById('fishingBobber'); if (bob) bob.style.animation = 'bobberMove 0.5s infinite alternate';
        var ind = document.getElementById('biteIndicator'); if (ind) ind.style.display = 'block';
        var reelBtn = document.getElementById('reelInBtn'); if (reelBtn) reelBtn.style.display = 'block';
    } catch (e) { console.warn('fishBite DOM', e); }
    
    // 如果开启了自动钓鱼，自动拉钩
    if (player.fishing.autoFishingEnabled) {
        var reelDelay = 500 + Math.random() * 1000;
        setTimeout(function() {
            try { reelInFish(); } catch (e) { console.warn('reelInFish auto', e); try { resetFishing(); } catch (e2) {} if (player.fishing.autoFishingEnabled) setTimeout(function() { startFishing(); }, 500); }
        }, reelDelay);
    }
    
    // 咬钩窗口期为2秒
    if (player.fishing.biteWindowTimer) {
        clearTimeout(player.fishing.biteWindowTimer);
    }
    
    player.fishing.biteWindowTimer = setTimeout(function() {
        try {
            if (player.fishing.isBiting) {
                var el = document.getElementById('fishingStatus');
                if (el) el.textContent = "鱼跑掉了！";
                resetFishing();
                if (player.fishing.autoFishingEnabled) setTimeout(function() { startFishing(); }, 300);
            }
        } catch (e) {
            console.warn('biteWindowTimer', e);
            try { resetFishing(); } catch (e2) {}
            if (player.fishing.autoFishingEnabled) setTimeout(function() { startFishing(); }, 500);
        }
    }, 2000);
}

function reelInFish() {
    // 若已不在咬钩状态（如窗口期已过或被其他逻辑清掉），仍要重置并续钓，避免自动钓鱼卡死
    if (!player.fishing.isBiting) {
        try { resetFishing(); } catch (e) { console.warn('resetFishing in reelInFish', e); }
        if (player.fishing.autoFishingEnabled) setTimeout(function() { startFishing(); }, 300);
        return;
    }
    
    // 清除定时器
    clearTimeout(player.fishing.biteWindowTimer);
    
    // 计算是否成功钓到鱼（基于时机）
    const currentTime = Date.now();
    const timeSinceBite = currentTime - player.fishing.biteTime;
    let success = timeSinceBite >= 0 && timeSinceBite <= 2000;
    
    if (success) {
        // 70%概率钓到鱼，30%概率钓到破烂
        if (Math.random() < 0.7) {
            catchFish();
        } else {
            catchJunk();
        }
    } else {
        document.getElementById('fishingStatus').textContent = "时机不对，鱼跑掉了！";
    }
    
    try { resetFishing(); } catch (e) { console.warn('resetFishing after reel', e); }
    if (player.fishing.autoFishingEnabled) setTimeout(function() { startFishing(); }, 300);
}

function catchFish() {
    // 随机选择鱼的品质
    let quality = determineQuality();
    
    // 随机选择鱼的名称
    let name = fishNames[Math.floor(Math.random() * fishNames.length)];
    
    // 随机长度和重量
    let length = (2 + Math.random() * 98).toFixed(1); // 2-100厘米
    let weight = (0.1 + Math.random() * 9.9).toFixed(1); // 0.1-10公斤
    
    // 创建鱼对象
    let fish = {
        type: 'fish',
        name: name,
        quality: quality,
        length: length,
        weight: weight,
        selected: false
    };
    // 如果开启了自动分解，立即分解这条鱼
    if (player.fishing.autoDecomposeFishEnabled) {
        decomposeSingleFish(fish);
        document.getElementById('fishingStatus').textContent = `钓到${fish.quality.name}的${fish.name}并自动分解！`;
    } else {
        // 否则放入鱼笼
        player.fishing.fishCage.push(fish);
        document.getElementById('fishingStatus').textContent = `成功钓到${fish.quality.name}的${fish.name}！`;
    }
    
  // 添加经验
    addExperience(quality.exp);
    
}

function catchJunk() {
    // 随机选择破烂
    let junkName = junkItems[Math.floor(Math.random() * junkItems.length)];
    
    // 创建破烂对象
    let junk = {
        type: 'junk',
        name: junkName,
        selected: false
    };
    
   // 如果开启了自动分解，立即分解这个破烂
    if (player.fishing.autoDecomposeFishEnabled) {
        decomposeSingleJunk(junk);
        document.getElementById('fishingStatus').textContent = `钓到${junk.name}并自动分解！`;
    } else {
        // 否则放入鱼笼
        player.fishing.fishCage.push(junk);
        document.getElementById('fishingStatus').textContent = `钓到了${junk.name}！`;
    }
}

function resetFishing() {
    if (!player.fishing) return;
    player.fishing.isFishing = false;
    player.fishing.isBiting = false;
    if (player.fishing.biteTimer != null) { clearTimeout(player.fishing.biteTimer); player.fishing.biteTimer = null; }
    if (player.fishing.biteWindowTimer != null) { clearTimeout(player.fishing.biteWindowTimer); player.fishing.biteWindowTimer = null; }
    try {
        var rod = document.getElementById('fishingRod');
        if (rod) rod.style.display = 'none';
        var bobber = document.getElementById('fishingBobber');
        if (bobber) { bobber.style.display = 'none'; bobber.style.animation = ''; }
        var ind = document.getElementById('biteIndicator');
        if (ind) ind.style.display = 'none';
        var reelBtn = document.getElementById('reelInBtn');
        if (reelBtn) reelBtn.style.display = 'none';
        var startBtn = document.getElementById('startFishingBtn');
        if (startBtn) startBtn.style.display = 'block';
        updateFishingUI();
    } catch (e) { console.warn('resetFishing DOM', e); }
}
function decomposeSingleFish(fish) {
    const qualityFactor = fishQualities.findIndex(q => q.name === fish.quality.name) + 2;
    const lengthFactor = parseFloat(fish.length) / 100;
    const weightFactor = parseFloat(fish.weight) / 10;
    
    // 计算基础数量
    let baseQuantity = Math.floor(1 + qualityFactor * (lengthFactor + weightFactor));
    // 应用收益加成
    baseQuantity = Math.floor(baseQuantity * getCurrentBonus());
    
    // 随机选择一种奖励
    const rewardType = decompositionRewards[Math.floor(Math.random() * decompositionRewards.length)];
    
    // 添加到玩家物品
    switch(rewardType) {
        case 'vip能力值':
            player.items.vipPower = (player.items.vipPower || 0) + baseQuantity;
            break;
        case '洗髓丹':
            player.items.rebornDan = (player.items.rebornDan || 0) + baseQuantity;
            break;
        case '洗练石':
            player.items.refineStone = (player.items.refineStone || 0) + baseQuantity;
            break;
        case '玫瑰花':
            player.items.rose = (player.items.rose || 0) + baseQuantity;
            break;
    }
    
    // 添加种子掉落
    if (Math.random() < 0.15) { // 15%概率获得种子
        dropSeedAfterDecompose();
    }
    
    // 更新显示
    updateFishingUI();
    updateItemDisplay();
   checkTitleUnlocks();
}

// 新增：分解单个破烂
function decomposeSingleJunk(junk) {
    // 破烂分解固定获得1朵玫瑰花
    player.items.rose = (player.items.rose || 0) + 1;
    
    // 更新显示
    updateFishingUI();
    updateItemDisplay();
  checkTitleUnlocks();
}
function addExperience(amount) {
    // 应用收益加成
    const bonus = getCurrentBonus();
    const actualAmount = amount * bonus;
    
    player.fishing.currentExp += actualAmount;
    checkLevelUp();
}

function checkLevelUp() {
    // 从当前等级开始检查是否可以升级
    let currentLevelIndex = levelConfig.findIndex(conf => conf.level === player.fishing.level);
    
    // 检查是否可以升级到下一级
    while (currentLevelIndex + 1 < levelConfig.length && 
           player.fishing.currentExp >= levelConfig[currentLevelIndex + 1].requiredExp) {
        player.fishing.level++;
        currentLevelIndex++;
        document.getElementById('fishingStatus').textContent += `恭喜！钓鱼等级提升到${player.fishing.level}级！`;
    }
    const fishingBonuses = [1, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000, 50000000];
     player.fishing.bonus = fishingBonuses[player.fishing.level - 1] || 50000000;   // 每级增加50倍（10%）
    updateFishingUI();
}

function updateFishCageDisplay() {
    const cageContainer = document.getElementById('fishCage');
    cageContainer.innerHTML = '';
    
    if (!player.fishing.fishCage || player.fishing.fishCage.length === 0) {
        cageContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #666;">鱼笼是空的，快去钓鱼吧！</div>';
        return;
    }
    
    player.fishing.fishCage.forEach((item, index) => {
        let itemElement = document.createElement('div');
        itemElement.style.padding = '5px';
        itemElement.style.borderRadius = '4px';
        itemElement.style.cursor = 'pointer';
        itemElement.style.transition = 'all 0.2s';
        
        // 设置选中状态样式
        if (item.selected) {
            itemElement.style.backgroundColor = '#e6f7ff';
            itemElement.style.border = '1px solid #91d5ff';
        } else {
            itemElement.style.backgroundColor = '#f9f9f9';
            itemElement.style.border = '1px solid transparent';
        }
        
        // 设置内容
        if (item.type === 'fish') {
            itemElement.innerHTML = `
                <span style="color: ${item.quality.color}; font-weight: bold;">${item.quality.name}</span>
                ${item.name} (${item.length}cm, ${item.weight}kg)
            `;
        } else {
            itemElement.textContent = item.name;
        }
        
        // 添加点击选中事件
        itemElement.addEventListener('click', () => {
            item.selected = !item.selected;
            updateFishCageDisplay();
        });
        
        cageContainer.appendChild(itemElement);
    });
}

function decomposeSelectedFish() {
    if (!player.fishing.fishCage || player.fishing.fishCage.length === 0) {
        alert('鱼笼是空的！');
        return;
    }
    
    const selectedItems = player.fishing.fishCage.filter(item => item.selected);
    
    if (selectedItems.length === 0) {
        alert('请先选择要分解的鱼获！');
        return;
    }
    
    let rewards = [];
    
    // 处理每种选中的物品
    selectedItems.forEach(item => {
        // 添加种子掉落
    if (Math.random() < 0.15) { // 15%概率获得种子
        dropSeedAfterDecompose();
    }
       
        if (item.type === 'junk') {
            // 破烂分解固定获得1朵玫瑰花
            player.items.rose = (player.items.rose || 0) + 1; // 添加到玩家物品
            rewards.push({type: '玫瑰花', quantity: 1});
        } else if (item.type === 'fish') {
            // 鱼分解根据品质、长度和重量获得奖励
            const qualityFactor = fishQualities.findIndex(q => q.name === item.quality.name) + 2;
            const lengthFactor = parseFloat(item.length) / 100;
            const weightFactor = parseFloat(item.weight) / 10;
            
            // 计算基础数量
            let baseQuantity = Math.floor(1 + qualityFactor * (lengthFactor + weightFactor));
            // 应用收益加成
            baseQuantity = Math.floor(baseQuantity * getCurrentBonus());
            
            // 随机选择一种奖励
            const rewardType = decompositionRewards[Math.floor(Math.random() * decompositionRewards.length)];
            
            // 添加到玩家物品
            switch(rewardType) {
                case 'vip能力值':
                    player.items.vipPower = (player.items.vipPower || 0) + baseQuantity;
                    break;
                case '洗髓丹':
                    player.items.rebornDan = (player.items.rebornDan || 0) + baseQuantity;
                    break;
                case '洗练石':
                    player.items.refineStone = (player.items.refineStone || 0) + baseQuantity;
                    break;
                case '玫瑰花':
                    player.items.rose = (player.items.rose || 0) + baseQuantity;
                    break;
            }
            
            rewards.push({type: rewardType, quantity: baseQuantity});
        }
        
        // 从鱼笼中移除
        const index = player.fishing.fishCage.indexOf(item);
        if (index > -1) {
            player.fishing.fishCage.splice(index, 1);
        }
    });
    
    // 显示奖励
    let rewardMessage = '分解获得：\n';
    rewards.forEach(reward => {
        rewardMessage += `- ${reward.type} x ${reward.quantity}\n`;
    });
    alert(rewardMessage);
    
    // 更新显示
    updateFishingUI();
    updateItemDisplay(); // 更新物品显示
}

function determineQuality() {
    let rand = Math.random() * 100;
    let cumulative = 0;


    for (let quality of fishQualities) {
        cumulative += quality.rarity;

        if (rand <= cumulative) {
            return quality;
        }
    }
    
    return fishQualities[0]; // 默认普通品质
}

function getCurrentBonus() {
    if (!player.fishing.level) return 1;
    const currentLevelConfig = levelConfig.find(conf => conf.level === player.fishing.level);
    return currentLevelConfig ? currentLevelConfig.bonus : 1;
}

// 添加CSS动画
const style = document.createElement('style');
style.textContent = `
    @keyframes bobberMove {
        from { transform: translateY(0); }
        to { transform: translateY(-10px); }
    }
`;
document.head.appendChild(style);

// 种子配置
const seedConfig = [
    { id: "seed1", name: "小麦种子", growthTime: 300, exp: 3, value: 2, rarity: 30 },
    { id: "seed2", name: "水稻种子", growthTime: 600, exp: 5, value: 4, rarity: 25 },
    { id: "seed3", name: "玉米种子", growthTime: 900, exp: 10, value: 10, rarity: 20 },
    { id: "seed4", name: "土豆种子", growthTime: 1200, exp: 15, value: 15, rarity: 18 },
    { id: "seed5", name: "胡萝卜种子", growthTime: 1500, exp: 20, value: 20, rarity: 15 },
    { id: "seed6", name: "番茄种子", growthTime: 1800, exp: 30, value: 25, rarity: 12 },
    { id: "seed7", name: "草莓种子", growthTime: 2100, exp: 40, value: 35, rarity: 10 },
    { id: "seed8", name: "蓝莓种子", growthTime: 2400, exp: 50, value: 40, rarity: 8 },
    { id: "seed9", name: "葡萄种子", growthTime: 2700, exp: 60, value: 50, rarity: 6 },
    { id: "seed10", name: "西瓜种子", growthTime: 3000, exp: 70, value: 60, rarity: 5 },
    { id: "seed11", name: "南瓜种子", growthTime: 3300, exp: 80, value: 70, rarity: 4 },
    { id: "seed12", name: "向日葵种子", growthTime: 3600, exp: 100, value: 80, rarity: 3 },
    { id: "seed13", name: "咖啡豆种子", growthTime: 7200, exp: 200, value: 160, rarity: 2 },
    { id: "seed14", name: "茶树种子", growthTime: 10800, exp: 500, value: 250, rarity: 1 },
    { id: "seed15", name: "金苹果种子", growthTime: 21600, exp: 1200, value: 500, rarity: 0.5 }
];

// 切换农场系统界面
function toggleFarmSystem() {
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启农场系统！");
        return;
    }
    const ui = document.getElementById('farmSystemUI');
    const overlay = document.getElementById('farmSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        
        // 关闭界面时清除自动化检查
        if (window.farmAutoCheckInterval) {
            clearInterval(window.farmAutoCheckInterval);
            window.farmAutoCheckInterval = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateFarmDisplay();
        
        // 开启界面时启动自动化检查（每10秒检查一次）
        if (!window.farmAutoCheckInterval) {
            window.farmAutoCheckInterval = registerInterval(() => {
                if (player.farm.autoHarvest) autoHarvest();
                if (player.farm.autoPlant) autoPlant();
            }, 1000); // 1秒检查一次
        }
    }
}

function closeFarmSystem() {
    document.getElementById('farmSystemUI').style.display = 'none';
    document.getElementById('farmSystemOverlay').style.display = 'none';
}

// 更新农场显示
function updateFarmDisplay() {
    // 更新基本信息
    document.getElementById('farmLevel').textContent = player.farm.level;
    document.getElementById('farmExp').textContent = player.farm.exp;
    document.getElementById('farmExpNext').textContent = player.farm.expToNextLevel;
    document.getElementById('farmFieldCount').textContent = player.farm.fields.filter(f => f.planted).length;
    document.getElementById('farmMaxFields').textContent = player.farm.maxFields;
    document.getElementById('waterCount').textContent = player.items.vipPower;
     document.getElementById('autoPlantBtn').textContent = `自动种植: ${player.farm.autoPlant ? '开启' : '关闭'}`;
    document.getElementById('autoPlantBtn').style.background = player.farm.autoPlant ? '#4CAF50' : '#FF9800';
    document.getElementById('autoHarvestBtn').textContent = `自动收获: ${player.farm.autoHarvest ? '开启' : '关闭'}`;
    document.getElementById('autoHarvestBtn').style.background = player.farm.autoHarvest ? '#4CAF50' : '#9C27B0';
    // 更新农田显示
    const fieldsContainer = document.getElementById('farmFields');
    fieldsContainer.innerHTML = '';
    
    for (let i = 0; i < player.farm.maxFields; i++) {
        const field = player.farm.fields[i] || { planted: false };
        const fieldDiv = document.createElement('div');
        fieldDiv.className = 'farm-field';
        fieldDiv.style.border = '1px solid #555';
        fieldDiv.style.borderRadius = '5px';
        fieldDiv.style.padding = '10px';
        fieldDiv.style.textAlign = 'center';
        fieldDiv.style.cursor = 'pointer';
        fieldDiv.style.position = 'relative';
        fieldDiv.style.height = '100px';
        
        if (i >= player.farm.maxFields) {
            fieldDiv.style.backgroundColor = '#333';
            fieldDiv.innerHTML = '<div style="color: #777;">未解锁</div>';
            fieldsContainer.appendChild(fieldDiv);
            continue;
        }
        
        if (!field.planted) {
            fieldDiv.innerHTML = '<div>空闲农田</div><button onclick="openSeedSelection(' + i + ')" style="margin-top: 10px;">种植</button>';
            fieldDiv.style.backgroundColor = '#2a2a2a';
        } else {
            const seed = seedConfig.find(s => s.id === field.seedId);
            const now = Date.now();
            const elapsed = now - field.plantTime;
            const progress = Math.min(100, (elapsed / (seed.growthTime * 1000)) * 100);
            
            // 显示作物状态
            let statusText = '';
            if (progress < 100) {
                statusText = '生长中: ' + Math.floor(progress) + '%';
                
                // 检查是否需要浇水
                if (field.wateredAt && (now - field.wateredAt) > 1800000000) { // 半小时需要浇水
                    statusText = '<span style="color: #ff5555;">需要浇水!</span>';
                }
            } else {
                statusText = '<span style="color: #55ff55;">可收获!</span>';
            }
            
            fieldDiv.innerHTML = `
                <div><strong>${seed.name}</strong></div>
                <div>${statusText}</div>
                <div style="height: 10px; background: #555; margin-top: 10px; border-radius: 5px;">
                    <div style="height: 100%; background: #4CAF50; width: ${progress}%; border-radius: 5px;"></div>
                </div>
            `;
            
            // 添加操作按钮
            const buttonContainer = document.createElement('div');
            buttonContainer.style.marginTop = '0px';
            
            if (progress < 100) {
                const waterBtn = document.createElement('button');
                waterBtn.textContent = '浇水';
                waterBtn.onclick = () => waterCrop(i);
                waterBtn.style.marginRight = '5px';
                buttonContainer.appendChild(waterBtn);
            } else {
                const harvestBtn = document.createElement('button');
                harvestBtn.textContent = '收获';
                harvestBtn.onclick = () => harvestCrop(i);
                harvestBtn.style.backgroundColor = '#4CAF50';
                buttonContainer.appendChild(harvestBtn);
            }
            
            fieldDiv.appendChild(buttonContainer);
            
            if (progress < 100) {
                fieldDiv.style.backgroundColor = '#2a2a2a';
            } else {
                fieldDiv.style.backgroundColor = '#334433';
            }
        }
        
        fieldsContainer.appendChild(fieldDiv);
    }
    
    // 更新种子仓库
    const seedContainer = document.getElementById('seedInventory');
    seedContainer.innerHTML = '';
    
    seedConfig.forEach(seed => {
        const count = player.farm.seeds[seed.id] || 0;
        if (count > 0) {
            const seedDiv = document.createElement('div');
            seedDiv.className = 'seed-item';
            seedDiv.style.border = '1px solid #555';
            seedDiv.style.borderRadius = '5px';
            seedDiv.style.padding = '10px';
            seedDiv.style.textAlign = 'center';
            seedDiv.style.backgroundColor = '#2a2a2a';
            
            seedDiv.innerHTML = `
                <div><strong>${seed.name}</strong></div>
                <div>数量: ${count}</div>
                <div>时间: ${formatTimeq(seed.growthTime)}</div>
            `;
            
            seedContainer.appendChild(seedDiv);
        }
    });
}

// 打开种子选择界面
function openSeedSelection(fieldIndex) {
    const seedContainer = document.getElementById('seedInventory');
    seedContainer.innerHTML = '';
    
    seedConfig.forEach(seed => {
        const count = player.farm.seeds[seed.id] || 0;
        if (count > 0) {
            const seedDiv = document.createElement('div');
            seedDiv.className = 'seed-item';
            seedDiv.style.border = '1px solid #555';
            seedDiv.style.borderRadius = '5px';
            seedDiv.style.padding = '10px';
            seedDiv.style.textAlign = 'center';
            seedDiv.style.backgroundColor = '#2a2a2a';
            seedDiv.style.cursor = 'pointer';
            
            seedDiv.innerHTML = `
                <div><strong>${seed.name}</strong></div>
                <div>数量: ${count}</div>
                <div>时间: ${formatTimeq(seed.growthTime)}</div>
            `;
            
            seedDiv.onclick = () => plantSeed(fieldIndex, seed.id);
            
            seedContainer.appendChild(seedDiv);
        }
    });
    
    // 添加取消按钮
    const cancelDiv = document.createElement('div');
    cancelDiv.className = 'seed-item';
    cancelDiv.style.border = '1px solid #555';
    cancelDiv.style.borderRadius = '5px';
    cancelDiv.style.padding = '10px';
    cancelDiv.style.textAlign = 'center';
    cancelDiv.style.backgroundColor = '#442222';
    cancelDiv.style.cursor = 'pointer';
    cancelDiv.innerHTML = '<div><strong>取消</strong></div>';
    cancelDiv.onclick = updateFarmDisplay;
    seedContainer.appendChild(cancelDiv);
}

// 种植种子
function plantSeed(fieldIndex, seedId) {
    if (player.farm.seeds[seedId] <= 0) return;
    
    // 初始化农田数组
    while (player.farm.fields.length <= fieldIndex) {
        player.farm.fields.push({ planted: false });
    }
    
    player.farm.fields[fieldIndex] = {
        planted: true,
        seedId: seedId,
        plantTime: Date.now(),
        wateredAt: Date.now()
    };
    
    player.farm.seeds[seedId]--;
    
    updateFarmDisplay();
    logAction(`在农田${fieldIndex + 1}种植了种子`, 'success');
}

// 浇水
function waterCrop(fieldIndex) {
    if (player.items.vipPower <= 30) {
        logAction("水滴不足！", "error");
        return;
    }
    
    const field = player.farm.fields[fieldIndex];
    if (!field || !field.planted) return;
    
    // 减少3分钟成熟时间（180000毫秒）
    field.plantTime -= 180000;
    
    field.wateredAt = Date.now();
    player.items.vipPower-=30;
    
    updateFarmDisplay();
    logAction(`为农田${fieldIndex + 1}浇水，成熟时间减少3分钟`, 'info');
}

// 收获作物
function harvestCrop(fieldIndex) {
    const field = player.farm.fields[fieldIndex];
    if (!field || !field.planted) return;
    
    const seed = seedConfig.find(s => s.id === field.seedId);
    const now = Date.now();
    const elapsed = now - field.plantTime;
    
    if (elapsed < seed.growthTime * 1000) {
        logAction("作物还未成熟！", "error");
        return;
    }
    
    // 获得经验和转生币
    player.farm.exp += seed.exp;
    player.items.vipPower += seed.value;
    
    // 检查升级
    checkFarmLevelUp();
    
    // 重置农田
    player.farm.fields[fieldIndex] = { planted: false };
    onFarmHarvest();
    updateFarmDisplay();
    updateDisplay(); // 更新主界面显示
   checkTitleUnlocks();
    logAction(`收获${seed.name}，获得${seed.exp}农场经验和${seed.value}VIP能力值`, 'success');
}

// 一键浇水
function waterAllCrops() {
    if (player.items.vipPower <= 0) {
        logAction("水滴不足！", "error");
        return;
    }
    
    let watered = 0;
    player.farm.fields.forEach((field, index) => {
        if (field.planted) {
            const now = Date.now();
            if (field.wateredAt && (now - field.wateredAt) > 1800000) {
                if (player.items.vipPower > 0) {
                    field.wateredAt = now;
                    playe.items.vipPower--;
                    watered++;
                }
            }
        }
    });
    
    if (watered > 0) {
        updateFarmDisplay();
        logAction(`一键浇水完成，浇灌了${watered}块农田`, 'success');
    } else {
        logAction("没有需要浇水的农田", "info");
    }
}

// 一键收获
function harvestAllCrops() {
    let harvested = 0;
    let totalExp = 0;
    let totalCoins = 0;
    
    player.farm.fields.forEach((field, index) => {
        if (field.planted) {
            const seed = seedConfig.find(s => s.id === field.seedId);
            const now = Date.now();
            const elapsed = now - field.plantTime;
            
            if (elapsed >= seed.growthTime * 1000) {
                // 收获作物
                player.farm.exp += seed.exp;
                player.items.vipPower += seed.value;
                totalExp += seed.exp;
                totalCoins += seed.value;
                
                // 重置农田
                player.farm.fields[index] = { planted: false };
               onFarmHarvest();
                harvested++;
            }
        }
    });
    
    if (harvested > 0) {
        // 检查升级
        checkFarmLevelUp();
        updateFarmDisplay();
        updateDisplay(); // 更新主界面显示
        logAction(`一键收获完成，收获${harvested}块农田，获得${totalExp}农场经验和${totalCoins}VIP能力值`, 'success');
    } else {
        logAction("没有可收获的农田", "info");
    }
}

// 检查农场升级
function checkFarmLevelUp() {
    while (player.farm.exp >= player.farm.expToNextLevel) {
        player.farm.exp -= player.farm.expToNextLevel;
        player.farm.level++;
        
        // 每级增加最大农田数量
        if (player.farm.level % 3 === 0) {
            player.farm.maxFields++;
        }
        
        // 更新下一级所需经验
        player.farm.expToNextLevel = Math.floor(player.farm.expToNextLevel * 1.5);
        
        logAction(`农场升级到${player.farm.level}级！解锁新农田`, 'success');
    }
}
function dropSeedAfterDecompose() {
    const totalRarity = seedConfig.reduce((sum, seed) => sum + seed.rarity, 0);
    const rand = Math.random() * totalRarity;
    
    let cumulative = 0;
    for (const seed of seedConfig) {
        cumulative += seed.rarity;
        if (rand <= cumulative) {
            // 添加种子到仓库
            player.farm.seeds[seed.id] = (player.farm.seeds[seed.id] || 0) + 1;
            logAction(`分解获得${seed.name}`, 'success');
            break;
        }
    }
}
// 时间格式化辅助函数
function formatTimeq(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    return `${hours > 0 ? hours + '小时' : ''}${minutes > 0 ? minutes + '分' : ''}${secs}秒`;
}
// 离线时更新农场
function updateFarmOffline() {
    const now = Date.now();
    const elapsed = (now - player.farm.lastUpdate) / 1000; // 转换为秒
    
    player.farm.fields.forEach(field => {
        if (field.planted) {
            const seed = seedConfig.find(s => s.id === field.seedId);
            // 更新生长进度（但不自动收获）
            // 实际收获需要玩家手动操作
        }
    });
    
    player.farm.lastUpdate = now;
}
function initFarmData() {
    if (!player.farm) {
        player.farm = {
            level: 1,
            exp: 0,
            expToNextLevel: 150,
            fields: Array(2).fill().map(() => ({ planted: false })),
            maxFields: 2,
            seeds: {},
            water: 10,
            lastUpdate: Date.now(),
          autoPlant: false,    // 新增自动种植设置
            autoHarvest: false 
        };
    }
    
    // 确保农田数组大小正确
    while (player.farm.fields.length < player.farm.maxFields) {
        player.farm.fields.push({ planted: false });
    }
}
// 切换自动种植功能
function toggleAutoPlant() {
    player.farm.autoPlant = !player.farm.autoPlant;
    const btn = document.getElementById('autoPlantBtn');
    btn.textContent = `自动种植: ${player.farm.autoPlant ? '开启' : '关闭'}`;
    btn.style.background = player.farm.autoPlant ? '#4CAF50' : '#FF9800';
    
    logAction(`自动种植${player.farm.autoPlant ? '开启' : '关闭'}`, 'info');
    
    // 如果开启自动种植，立即执行一次
    if (player.farm.autoPlant) {
        autoPlant();
    }
}

// 切换自动收获功能
function toggleAutoHarvest() {
    player.farm.autoHarvest = !player.farm.autoHarvest;
    const btn = document.getElementById('autoHarvestBtn');
    btn.textContent = `自动收获: ${player.farm.autoHarvest ? '开启' : '关闭'}`;
    btn.style.background = player.farm.autoHarvest ? '#4CAF50' : '#9C27B0';
    
    logAction(`自动收获${player.farm.autoHarvest ? '开启' : '关闭'}`, 'info');
    
    // 如果开启自动收获，立即执行一次
    if (player.farm.autoHarvest) {
        autoHarvest();
    }
}

// 自动种植逻辑
function autoPlant() {
    if (!player.farm.autoPlant) return;
    
    let planted = false;
    
    // 检查是否有空闲农田
    for (let i = 0; i < player.farm.fields.length; i++) {
        const field = player.farm.fields[i];
        
        // 如果农田空闲且有种子可用
        if (!field.planted && Object.keys(player.farm.seeds).length > 0) {
            // 选择第一个有库存的种子
            for (const seedId in player.farm.seeds) {
                if (player.farm.seeds[seedId] > 0) {
                    plantSeed(i, seedId);
                    planted = true;
                    break;
                }
            }
        }
    }
    
    if (planted) {
        logAction("自动种植执行完成", 'success');
    }
}

// 自动收获逻辑
function autoHarvest() {
    if (!player.farm.autoHarvest) return;
    
    let harvested = false;
    
    // 检查所有农田
    for (let i = 0; i < player.farm.fields.length; i++) {
        const field = player.farm.fields[i];
        
        if (field.planted) {
            const seed = seedConfig.find(s => s.id === field.seedId);
            const now = Date.now();
            const elapsed = now - field.plantTime;
            
            // 如果作物已成熟
            if (elapsed >= seed.growthTime * 1000) {
                harvestCrop(i);
                harvested = true;
            }
        }
    }
    
    if (harvested) {
        logAction("自动收获执行完成", 'success');
    }
}

const liveStreamSystem = {
    level: 1,
    exp: 0,
    expToNextLevel: [1000, 5000, 7500, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 55000, 60000, 65000, 70000, 75000, 80000, 85000, 90000, 95000, 100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000, 2500000, 5000000, 7500000, 10000000, 25000000, 50000000, 75000000, 100000000, 10000000000],
    isLive: false,
    viewers: [],
    viewerCount: 0,
    maxViewers: 10,
    totalEarnings: 1000,
    expMultiplier: 1,
    lastUpdate: Date.now(),
   danmakuGeneratorActive: false,
    aiMessages: [
        "主播今天玩什么？",
        "加油！支持主播！",
        "这个游戏看起来好有趣",
        "刚刚的打斗太精彩了！",
        "主播技术真好",
        "求教学怎么快速转生",
        "关注了，下次还来",
        "礼物已送上，继续加油",
        "今天运气不错啊",
        "这个装备怎么获得的？",
        "6666666",
        "我喜欢你主播",
        "太强了",
         "主播嫁给我",
        "哈哈哈，这个操作笑死我了",
        "主播多大了？",
        "什么时候下次直播？",
        "求背景音乐名字",
        "画质好清晰啊",
        "卡了吗？怎么不动了",
        "第一次来看，感觉不错！",
        "求问主播用的什么鼠标？",
        "支持支持！打赏走一波",
        "这个角色怎么加点？",
        "新来的，关注了",
        "背景音乐好好听！",
        "刚刚那下没看清，能回放吗？",
        "主播吃饭了吗",
        "这游戏需要氪金吗？",
        "太厉害了吧，学到了",
        "卡了卡了，主播那边还好吗？",
        "下次能玩无限升级吗？",
        "礼物收到了吗？主播",
        "666，必须录屏了",
        "今天直播到几点呀？",
        "新手能玩这个游戏吗？",
        "主播加油，别慌！",
        "求组队一起玩！",
        "这个地图怎么解锁？",
        "哈哈哈，主播被坑了",
        "关注了，主播多更新",
        "主播今天状态不错啊",
        "网络有点卡，刷新试试",
        "这个技能怎么放的？",
        "刚刚那波失误有点可惜",
        "求主播带飞！",
        "这个游戏什么时候上线的？",
        "主播累不累？歇会儿吧",
        "新来的，求问这是什么游戏？",
        "太精彩了，全程没快进",
        "主播用的什么显卡？画质这么好",
        "下次直播能提前说一声吗？",
        "什么时候下次直播？",
        "刚刚那下反应好快！",
        "卡退了，重新进来了",
        "求问这个游戏怎么下载？",
        "主播技术比我朋友好多了",
        "哈哈哈，主播的表情太逗了",
        "这个游戏有手游吗？",
        "主播快回复一下我的问题呀",
        "网络怎么回事，老是卡顿",
        "主播明天几点直播？",
        "求教学怎么躲这个技能",
        "这个游戏画质真不错",
        "支持主播，会一直关注",
        "主播用的什么耳机？",
        "这个角色哪个职业最强？",
        "新来的，求主播带一下",
        "这个游戏需要什么配置？",
        "背景音乐是什么歌？好熟悉",
        "卡了，主播能等一下吗？",
        "主播今天直播内容好丰富",
        "求问怎么快速升级？",
        "礼物已刷，主播看得到吗？",
        "主播技术真的没话说，太强了",
        "新来的，觉得主播很有趣",
        "主播什么时候换游戏玩？",
        "关注了，下次开播提醒我",
        "支持主播，打赏不能少",
        "网络恢复了吗？刚才好卡",
        "求问这个游戏有攻略吗？",
        "这个游戏多人玩吗？",
        "关注了，主播要常开播哦",
        "主播今天心情不错呀",
        "新来的，求问主播常玩什么游戏？",
        "主播技术比我想象中好太多",
        "礼物送上，祝主播越来越好",
        "卡了卡了，大家都卡吗？",
        "主播明天还播这个游戏吗？",
        "支持主播，会推荐朋友来看",
        "关注了，主播多玩点新游戏",
        "主播今天直播时长多久呀？",
        "礼物已送，主播辛苦了",
        "主播什么时候开粉丝群？",
        "求问怎么获得金币快？",
        "刚刚的打斗太精彩了！",
        "支持主播，每天都来看",
        "关注了，主播记得回关哦",
        "关注了，下次还来",
        "网络终于不卡了",
        "今天运气不错啊",
        "这个装备怎么获得的？",
        "主播技术真的很专业",
        "这个游戏有等级上限吗？",
        "哈哈哈，这个操作笑死我了",
        "支持主播，打赏走起",
        "新来的，觉得直播很精彩",
        "背景音乐是谁唱的",
        "关注了，主播多搞点福利活动",
        "主播今天吃的什么呀？",
        "新来的，关注了不后悔",
        "主播技术越来越好的",
        "这个游戏看起来好有趣",
        "刚刚的打斗太精彩了！",
        "主播技术真好",
        "求教学怎么快速转生",
        "关注了，下次还来",
        "礼物已送上，继续加油",
        "今天运气不错啊",
        "美女",
        "支持主播，永远是粉丝",
        "这个游戏怎么创建角色？",
        "这个游戏有公会系统吗？",
        "关注了，下次开播不见不散",
        "求教学怎么放风筝",
         "老公吃饭了吗",
        "老婆吃饭了吗",
        "牛逼",
        "好厉害",
       "CPDD",
        "画质好清晰啊",
        "主播我喜欢你！",
        "你好菜啊",
        "加油！支持主播！",
        "这个游戏看起来好有趣",
        "刚刚的打斗太精彩了！",
        "网络又卡了，服了",
        "支持主播，会一直陪伴",
        "关注了，下次还来",
        "礼物已送上，继续加油",
        "这个游戏画面风格我喜欢",
        "这个游戏怎么举报外挂？",
        "主播下次能早点直播吗？",
        "这个游戏有师徒系统吗？",
        "哈哈哈，这个操作笑死我了",
        "主播有女朋友吗？",
        "什么时候下次直播？",
        "求背景音乐名字",
        "画质好清晰啊",
        "卡了吗？怎么不动了",
        "礼物送上，主播越来越火",
        "加油！支持主播！",
        "这个装备怎么镶嵌宝石？",
        "新来的，关注了，主播多播哦",  
        "晚安，先睡了",
        "明天还直播吗？"
    ],
    aiNames: [
        "闫闫", "花花", "茶茶", "鱼鱼", "通元","叶子", "沉鱼", "探探", "凡", "尝试", "胖大仙", "水芙蓉", "亲情相爱一家人", "伍思凯", "吖晴儿", 
        "苏菲", "王荣", "瑶瑶", "悸声", "反骨仔", "冰糖红茶", "蝴蝶效应,", "悦悦", "老倪", "慕白", "轩辕", "阿孝", "yuan", "王北的北,", "我已经在拉扯了", "林贝", "慕白", "阿迪", "微软是你", "王汝刚", "刘禹锡", "艾夫华", "渥太华", "阿杰", "阿道夫", "豆腐花茜茜", "阿法和阿伟","峰", "好人", "奥格威", "阿睿", "星嗄","阿华田", "子女不能", "开膛手杰华", "埃弗阿福", "黑丝姐姐", "黑菲","爱喝牛奶", "骚粉", "王如玉", "血红女爵", "水果",
        "萩", "我不高兴", "山麒麟", "管者", "阿斯巴甜","圣光", "征服他哥", "字画大师", "诗人睡睡", "孙国辉",
        "君子不气", "空白", "香香", "浪荡丶", "啦喇菈辣","十分", "神烦狗", "张枫五", "偶见", "孙国伟","时迁", "Plan B", "冥王", "阿顺帆",
        "Tung", "迷雾", "源", "泯潮猫", "寻良","冰箭", "赵哥", "张德荣", "三国英", "清茶", 
        "有意思", "非酋本酋", "肝双", "氪金佬", "舍尔", "赵哥帅", "张宝华", "祝福鱼", "珍贵仁",
         "Cardiac", "战无极", "凹凸曼", "白饭鱼", "独钓寒江雪",
        "锅巴", "花海", "怀安", "金刚骷髅娃", "锦瑟笙箫落",
        "旧", "举着戒指对你笑i", "磊哥", "凛", "六号线",
        "Numb", "柠檬妖精", "PoRo", "随风", "墨清",
        "桃子姐姐", "温存i", "我叫MMT", "我呀我", "小末影", "风影", "笑气气", "炫月", "燁燁",
        "一梦千年", "佳音如期", "功不唐捐", "卡子哥", "晨曦",
        "帅到分手", "午夜飞升", "星君", "预言", "成",
        "红尘", "幻月", "幻雪", "山与海", "虾仁哥哥",
        "风之奇影", "爱上风", "Dddddddd", "珊迪", "木子升", "建议击毙", "潮起潮落", "风云祭", "100分",
        "谷丶然", "无敌的话", "勿忘", "Rayn", "哈哈哈哈哈",
        "钵钵鸡", "笑气气", "花海", "Æternø", "天赋与努力",
        "晨落", "徒手", "柠檬", "余晖", "隐",
        "D", "三都", "大白菜帮子", "佳南",  "休闲玩家"
    ],
    donationMessages: [
        "送上小心心！",
        "给你点鼓励！",
        "支持主播！",
        "继续加油！",
        "小小礼物不成敬意",
        "今天的表现太棒了！",
        "值得鼓励！",
        "希望主播越来越好",
        "这是你应得的！",
        "打赏一波，主播辛苦了！",
        "希望越来越好，礼物支持",
        "一点心意，买杯奶茶喝~！",
        "看得尽兴，打赏表示",
        "关注很久了，今天送个礼物",
        "今天的直播超赞，打赏！",
        "主播加油，礼物来了哦",
        "小小礼物，不成敬意，继续加油",
        "每天必看，今天打赏一下",
        "这波太秀了，送礼物！",
        "希望你一直播下去，礼物支持",
        "主播辛苦了，送个小礼物",
        "支持你到底，打赏一波",
        "感谢带来欢乐，礼物请查收",
        "主播越来越好了，送个礼物",
        "今天看得过瘾，必须打赏",
        "喜欢你的直播，送点心意",
        "感谢分享，礼物送上！",
        "这波操作值个礼物！",
        "主播真棒，必须鼓励！",
        "感谢你的直播陪伴"
    ]
};
const danmakuSystem = {
    active: true,
    speed: 5, // 1-10
    density: 3, // 1-10
    container: null,
    colors: {
        system: '#ff00ff',
        viewer: '#ffffff',
        player: '#4CAF50',
        donation: '#FFD700'
    },
    tracks: [], // 弹幕轨道
    trackHeight: 30, // 每条轨道的高度
    maxTracks: 10, // 最大轨道数
    fontSizes: [14, 16, 18, 20],
    styles: ['normal', 'bold', 'italic']
};
// 初始化弹幕系统
function initDanmakuSystem() {
    danmakuSystem.container = document.getElementById('danmakuContainer');
    
    // 初始化轨道
    const containerHeight = danmakuSystem.container.clientHeight;
    danmakuSystem.maxTracks = Math.floor(containerHeight / danmakuSystem.trackHeight);
    danmakuSystem.tracks = [];
    
    for (let i = 0; i < danmakuSystem.maxTracks; i++) {
        danmakuSystem.tracks.push({
            occupied: false,
            lastUsed: 0
        });
    }
    
    // 设置弹幕控制事件
    document.getElementById('danmakuToggle').addEventListener('change', function() {
        danmakuSystem.active = this.checked;
        if (!this.checked) {
            clearDanmaku();
        }
    });
    
    document.getElementById('danmakuSpeed').addEventListener('input', function() {
        danmakuSystem.speed = parseInt(this.value);
    });
    
    document.getElementById('danmakuDensity').addEventListener('input', function() {
        danmakuSystem.density = parseInt(this.value);
    });
}

// 清除弹幕函数（修复）
function clearDanmaku() {
    if (!danmakuSystem.container) return;
    
    // 获取所有弹幕元素
    const danmakuElements = danmakuSystem.container.querySelectorAll('.danmaku');
    
    // 遍历所有弹幕元素
    danmakuElements.forEach(danmaku => {
        // 获取所有正在运行的动画
        const animations = danmaku.getAnimations();
        
        // 取消所有动画
        animations.forEach(animation => {
            animation.cancel();
        });
        
        // 移除元素
        danmaku.remove();
    });
    
    // 重置所有轨道状态
    if (danmakuSystem.tracks) {
        for (let i = 0; i < danmakuSystem.tracks.length; i++) {
            danmakuSystem.tracks[i].occupied = false;
            danmakuSystem.tracks[i].lastUsed = Date.now();
        }
    }
}

// 添加弹幕到直播画面
function addDanmakuToScreen(sender, message, type) {
    if (!danmakuSystem.active || !player.liveStream.isLive || !danmakuSystem.container) return;
    
    // 找到可用的轨道
    const availableTrack = findAvailableTrack();
    if (availableTrack === -1) return;
    
    // 创建弹幕元素
    const danmaku = document.createElement('div');
    danmaku.className = 'danmaku';
    danmaku.style.position = 'absolute';
    danmaku.style.top = `${availableTrack * danmakuSystem.trackHeight}px`;
    danmaku.style.right = '0';
    danmaku.style.color = danmakuSystem.colors[type] || '#ffffff';
    danmaku.style.fontSize = `${danmakuSystem.fontSizes[Math.floor(Math.random() * danmakuSystem.fontSizes.length)]}px`;
    danmaku.style.fontWeight = Math.random() > 0.7 ? 'bold' : 'normal';
    danmaku.style.fontStyle = Math.random() > 0.8 ? 'italic' : 'normal';
    danmaku.style.textShadow = '1px 1px 2px rgba(0,0,0,0.7)';
    danmaku.style.whiteSpace = 'nowrap';
    danmaku.style.zIndex = '2';
    danmaku.style.opacity = '0.9';
    danmaku.style.transform = 'translateX(100%)';
    danmaku.innerHTML = `<span style="color: #aaa;">${sender}:</span> ${message}`;
    
    // 添加到容器
    danmakuSystem.container.appendChild(danmaku);
    
    // 标记轨道占用
    danmakuSystem.tracks[availableTrack].occupied = true;
    
    // 计算动画时间
    const containerWidth = danmakuSystem.container.clientWidth;
    const danmakuWidth = danmaku.offsetWidth;
    const distance = containerWidth + danmakuWidth;
    const duration = distance / (danmakuSystem.speed * 50);
    
    // 应用动画
    const animation = danmaku.animate(
        [
            { transform: 'translateX(100%)' },
            { transform: `translateX(-${danmakuWidth}px)` }
        ],
        {
            duration: duration * 1000,
            easing: 'linear'
        }
    );
    
    animation.onfinish = () => {
        // 动画完成后移除元素并释放轨道
        if (danmaku.parentNode === danmakuSystem.container) {
            danmaku.remove();
        }
        if (availableTrack < danmakuSystem.tracks.length) {
            danmakuSystem.tracks[availableTrack].occupied = false;
            danmakuSystem.tracks[availableTrack].lastUsed = Date.now();
        }
    };
}

// 查找可用轨道
function findAvailableTrack() {
    if (!danmakuSystem.tracks || danmakuSystem.tracks.length === 0) return -1;
    
    // 按最后使用时间排序
    const sortedTracks = [...danmakuSystem.tracks]
        .map((track, index) => ({ ...track, index }))
        .sort((a, b) => a.lastUsed - b.lastUsed);
    
    for (let i = 0; i < sortedTracks.length; i++) {
        if (!sortedTracks[i].occupied) {
            return sortedTracks[i].index;
        }
    }
    
    // 如果没有空闲轨道，尝试使用最久未使用的轨道
    const oldestTrack = sortedTracks[0];
    if (Date.now() - oldestTrack.lastUsed > 5000) {
        return oldestTrack.index;
    }
    
    return -1;
}


// 初始化直播系统
function initLiveStreamSystem() {
    if (!player.liveStream) {
        player.liveStream = {
            level: 1,
            exp: 0,
            totalEarnings: 1000,
            isLive: false,
            lastLiveStart: 0,
            totalLiveTime: 0,
            expMultiplier: 1,
            viewers: [],
            donationHistory: [],
            lastDanmaku: null
        };
    }
}

// 切换直播系统界面
function toggleLiveStreamSystem() {
    if (player.reincarnationCount < 500) {
        alert("需要达到500转才能开启直播系统！");
        return;
    }
    const overlay = document.getElementById('liveStreamSystemOverlay');
    const ui = document.getElementById('liveStreamSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initLiveStreamSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateLiveStreamUI();
    }
}

// 更新直播系统UI
function updateLiveStreamUI() {
    document.getElementById('liveStreamLevel').textContent = player.liveStream.level;
    document.getElementById('liveStreamExp').textContent = Math.floor(player.liveStream.exp);
    document.getElementById('liveStreamNextExp').textContent = liveStreamSystem.expToNextLevel[player.liveStream.level - 1] || 10000000000;
    document.getElementById('totalLiveEarnings').textContent = (player.liveStream.totalEarnings/10).toFixed(0);
    document.getElementById('liveViewerCount').textContent = player.liveStream.viewers.length;
    
    // 更新经验条
    const expPercent = Math.min(100, (player.liveStream.exp / (liveStreamSystem.expToNextLevel[player.liveStream.level - 1] || 10000000000)) * 100);
    document.getElementById('liveExpProgress').style.width = `${expPercent}%`;
    
    // 更新观众列表
    const viewerList = document.getElementById('viewerList');
    viewerList.innerHTML = '';
    
    if (player.liveStream.viewers.length === 0) {
        viewerList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px 0;">暂无观众</div>';
    } else {
        player.liveStream.viewers.forEach(viewer => {
            const viewerElement = document.createElement('div');
            viewerElement.style.marginBottom = '5px';
            viewerElement.style.padding = '5px';
            viewerElement.style.background = '#0a0a1a';
            viewerElement.style.borderRadius = '3px';
            viewerElement.innerHTML = `👤 ${viewer.name}`;
            viewerList.appendChild(viewerElement);
        });
    }
    
    // 更新打赏记录
    const donationHistory = document.getElementById('donationHistory');
    donationHistory.innerHTML = '';
    
    if (player.liveStream.donationHistory.length === 0) {
        donationHistory.innerHTML = '<div style="text-align: center; color: #666; padding: 20px 0;">暂无打赏记录</div>';
    } else {
        // 只显示最近10条记录
        const recentDonations = player.liveStream.donationHistory.slice(-10);
        recentDonations.forEach(donation => {
            const donationElement = document.createElement('div');
            donationElement.style.marginBottom = '5px';
            donationElement.style.padding = '5px';
            donationElement.style.background = '#0a0a1a';
            donationElement.style.borderRadius = '3px';
            donationElement.innerHTML = `🎁 ${donation.viewer} 打赏了 ${donation.amount} 朵玫瑰花 - ${donation.message}`;
            donationHistory.appendChild(donationElement);
        });
    }
    
    // 更新直播状态
    const liveStatus = document.getElementById('liveStatus');
    const startLiveBtn = document.getElementById('startLiveBtn');
    
    if (player.liveStream.isLive) {
        liveStatus.innerHTML = `<div style="font-size: 24px; color: #ff00ff;">直播中</div><div>已直播: ${formatTimew(Date.now() - player.liveStream.lastLiveStart)}</div>`;
        startLiveBtn.textContent = '结束直播';
        startLiveBtn.style.background = '#f44336';
    } else {
        liveStatus.textContent = '直播未开始';
        startLiveBtn.textContent = '开始直播';
        startLiveBtn.style.background = '#ff00ff';
    }
}
function generateAIDanmaku() {
    if (!player.liveStream.isLive || !danmakuSystem.active) {
        liveStreamSystem.danmakuGeneratorActive = false;
        return;
    }
    
const minInterval = 10000 - (danmakuSystem.density * 800);
    const maxInterval = 20000 - (danmakuSystem.density * 1500);
    const interval = Math.random() * (maxInterval - minInterval) + minInterval;
    
    liveStreamSystem.danmakuGeneratorTimer = setTimeout(() => {
        if (player.liveStream.isLive && player.liveStream.viewers.length > 0) {
            const viewerIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
            const viewer = player.liveStream.viewers[viewerIndex];
            const message = liveStreamSystem.aiMessages[Math.floor(Math.random() * liveStreamSystem.aiMessages.length)];
            addDanmakuMessageq(viewer.name, message, "viewer");
            
            // 有小概率打赏
            if (Math.random() < 0.05) {
                generateDonation(viewer);
            }
        }
        
        // 递归调用前检查直播状态
        if (player.liveStream.isLive) {
            generateAIDanmaku();
        } else {
            liveStreamSystem.danmakuGeneratorActive = false;
        }
    }, interval);
}

// 开始直播
function startLiveStream() {
    if (player.liveStream.isLive) {
        stopLiveStream();
        return;
    }
     // 清除可能存在的弹幕生成器
    if (liveStreamSystem.danmakuGeneratorActive) {
        clearDanmakuGenerator();
    }
    player.liveStream.isLive = true;
    player.liveStream.lastLiveStart = Date.now();
    player.liveStream.viewers = [];
     liveStreamSystem.maxViewers = 10 + Math.floor(player.liveStream.level * 5);
    // 添加初始观众
    addViewers(liveStreamSystem.maxViewers*0.86);
     
    // 开始观众和互动定时器
    player.liveStream.viewerInterval = registerInterval(updateViewers, 10000); // 每10秒更新观众
    player.liveStream.interactionInterval = registerInterval(generateInteractions, 10000); // 每10秒生成互动
   initDanmakuSystem();
 // 启动弹幕生成器（确保只启动一次）
    if (!liveStreamSystem.danmakuGeneratorActive) {
        generateAIDanmaku();
        liveStreamSystem.danmakuGeneratorActive = true;
    }
    updateLiveStreamUI();
    addDanmakuMessageq("系统", "直播开始了！欢迎大家来到直播间！", "system");
    logAction("开始直播", "success");
}

// 停止直播
function stopLiveStream() {
    if (!player.liveStream.isLive) return;
    
    player.liveStream.isLive = false;
    const liveTime = Date.now() - player.liveStream.lastLiveStart;
    player.liveStream.totalLiveTime += liveTime;
    
    // 计算经验
    const expGain = Math.floor(liveTime / 1000) * player.liveStream.expMultiplier;
    player.liveStream.exp += expGain;
     liveStreamSystem.maxViewers = 10 + Math.floor(player.liveStream.level * 5);
    // 检查升级
    checkLiveLevelUp();
    
    // 清除定时器
    clearInterval(player.liveStream.viewerInterval);
    clearInterval(player.liveStream.interactionInterval);
    clearDanmakuGenerator();
    // 清空观众
    player.liveStream.viewers = [];
    clearDanmaku();
    
    updateLiveStreamUI();
    addDanmakuMessageq("系统", "直播已结束，感谢观看！", "system");
    
    logAction(`结束直播，获得 ${expGain} 直播经验`, "success");
    
}
function clearDanmakuGenerator() {
    if (liveStreamSystem.danmakuGeneratorTimer) {
        clearTimeout(liveStreamSystem.danmakuGeneratorTimer);
        liveStreamSystem.danmakuGeneratorTimer = null;
    }
    liveStreamSystem.danmakuGeneratorActive = false;
}


// 推广流量
function boostLiveStream() {
    if (player.nightClub.starCoins < 1000) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 1000;
    player.liveStream.expMultiplier = 2;
    
    // 设置1小时的加速效果
    player.liveStream.boostEndTime = Date.now() + 1 * 60 * 60 * 1000;
    
    // 添加更多观众
    addViewers(liveStreamSystem.maxViewers*0.4);
    
    updateLiveStreamUI();
    addDanmakuMessageq("系统", "主播使用了流量推广，直播间人气上升！", "system");
    
    logAction("使用流量推广，直播经验获取速度提升2倍，持续1小时", "success");
}

// 添加观众
function addViewers(count) {
    if (!player.liveStream.isLive) return;
    
    for (let i = 0; i < count; i++) {
        if (player.liveStream.viewers.length >= liveStreamSystem.maxViewers) break;
        
        const viewerName = liveStreamSystem.aiNames[Math.floor(Math.random() * liveStreamSystem.aiNames.length)];
        player.liveStream.viewers.push({
            id: Date.now() + Math.random(),
            name: viewerName,
            joinTime: Date.now(),
            activity: Math.random() // 活跃度
        });
    }
    
    updateLiveStreamUI();
}

// 更新观众
function updateViewers() {
    if (!player.liveStream.isLive) return;
    
    // 随机有观众离开
    if (player.liveStream.viewers.length > 0 && Math.random() < 0.3) {
        const leaveIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
        const leaveViewer = player.liveStream.viewers[leaveIndex];
        player.liveStream.viewers.splice(leaveIndex, 1);
        
        addDanmakuMessageq("系统", `${leaveViewer.name} 离开了直播间`, "system");
    }
    
    // 随机有新观众加入
    if (player.liveStream.viewers.length < liveStreamSystem.maxViewers && Math.random() < 0.7) {
        addViewers(1);
        const newViewer = player.liveStream.viewers[player.liveStream.viewers.length - 1];
        addDanmakuMessageq("系统", `${newViewer.name} 进入了直播间`, "system");
    }
    
    updateLiveStreamUI();
}

// 生成互动消息
function generateInteractions() {
    if (!player.liveStream.isLive || player.liveStream.viewers.length === 0) return;
    
    // 随机生成1-8条互动消息
    const messageCount = Math.floor(Math.random() * 7) + 1;
    
    for (let i = 0; i < messageCount; i++) {
        const viewerIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
        const viewer = player.liveStream.viewers[viewerIndex];
        
        const message = liveStreamSystem.aiMessages[Math.floor(Math.random() * liveStreamSystem.aiMessages.length)];
        addDanmakuMessageq(viewer.name, message, "viewer");
        
        // 有小概率打赏
        if (Math.random() < 0.05) {
            generateDonation(viewer);
        }
    }
}

// 生成打赏
function generateDonation(viewer) {
    // 打赏金额基于直播等级
    const baseAmount = player.liveStream.level * 1;
    const amount = Math.floor(baseAmount * (1 + Math.random() * 50));
    
    player.items.rose += amount;
    player.liveStream.totalEarnings += amount;
    
    const message = liveStreamSystem.donationMessages[Math.floor(Math.random() * liveStreamSystem.donationMessages.length)];
    
    // 记录打赏（限制长度防止长时间直播内存增长）
    player.liveStream.donationHistory.push({
        viewer: viewer.name,
        amount: amount,
        message: message,
        time: Date.now()
    });
    if (player.liveStream.donationHistory.length > 100) {
        player.liveStream.donationHistory = player.liveStream.donationHistory.slice(-100);
    }
    
    addDanmakuMessageq("系统", `🎉 ${viewer.name} 打赏了 ${amount} 朵玫瑰花！${message}`, "donation");
    updateLiveStreamUI();
    updateDisplay();
}

// 发送弹幕
function sendDanmaku() {
    const input = document.getElementById('danmakuInput');
    const message = input.value.trim();
    
    if (message === '') return;
    
    addDanmakuMessageq(player.name, message, "player");
    input.value = '';
    
    // 玩家发送消息后，AI观众有概率回应
    if (player.liveStream.viewers.length > 0 && Math.random() < 0.5) {
        setTimeout(() => {
            const viewerIndex = Math.floor(Math.random() * player.liveStream.viewers.length);
            const viewer = player.liveStream.viewers[viewerIndex];
            
            let response;
            if (message.includes('?')) {
                response = "这个问题问得好！";
            } else if (message.includes('谢谢') || message.includes('感谢')) {
                response = "不客气~";
            } else {
                response = "同意主播！" ;
            }
            
            addDanmakuMessageq(viewer.name, response, "viewer");
        }, 1000 + Math.random() * 2000);
    }
}

// 添加弹幕消息
function addDanmakuMessageq(sender, message, type) {
    const container = document.getElementById('danmakuContainerq');
    const messageElement = document.createElement('div');
    messageElement.className = 'danmaku-message';
    
    // 根据消息类型设置样式
    switch(type) {
        case "system":
            messageElement.style.color = '#ff00ff';
            break;
        case "donation":
            messageElement.style.color = '#FFD700';
            messageElement.style.fontWeight = 'bold';
            break;
        case "player":
            messageElement.style.color = '#4CAF50';
            break;
        default:
            messageElement.style.color = '#ccc';
    }
    
    messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
    container.appendChild(messageElement);
      if (player.liveStream.isLive) {
        addDanmakuToScreen(sender, message, type);}
    // 自动滚动到底部
    container.scrollTop = container.scrollHeight;
   
    // 限制消息数量
    if (container.children.length > 30) {
        container.removeChild(container.children[0]);
    }
}

// 检查直播等级提升
function checkLiveLevelUp() {
    const nextLevelExp = liveStreamSystem.expToNextLevel[player.liveStream.level - 1] || 10000000000;
    
    if (player.liveStream.exp >= nextLevelExp) {
        player.liveStream.level++;
        player.liveStream.exp -= nextLevelExp;
        
        // 增加最大观众数
         liveStreamSystem.maxViewers = 10 + Math.floor(player.liveStream.level * 5);
        
        addDanmakuMessageq("系统", `恭喜！直播等级提升到 ${player.liveStream.level} 级！`, "system");
        logAction(`直播等级提升到 ${player.liveStream.level} 级！`, "success");
        
        // 递归检查是否还能升级
        checkLiveLevelUp();
    }
    
    updateLiveStreamUI();
}

// 格式化时间
function formatTimew(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    return `${hours.toString().padStart(2, '0')}:${(minutes % 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
}

// 在游戏主循环中更新直播经验
function updateLiveStreamExperience() {
    if (player.liveStream && player.liveStream.isLive) {
        const now = Date.now();
        const elapsed = now - player.liveStream.lastUpdate;
        player.liveStream.lastUpdate = now;
        
        // 检查加速是否结束
        if (player.liveStream.boostEndTime && now > player.liveStream.boostEndTime) {
            player.liveStream.expMultiplier = 1;
            player.liveStream.boostEndTime = null;
            addDanmakuMessageq("系统", "流量推广效果已结束", "system");
        }
        
        // 每秒获得1点经验乘以倍率
        const expGain = (elapsed / 1000) * player.liveStream.expMultiplier;
        player.liveStream.exp += expGain;
        
        // 检查升级
        checkLiveLevelUp();
        
        // 更新UI
        updateLiveStreamUI();
    }
}

// 礼物数据
const giftBoxSystem = {
    gifts: [
        { name: "鲜花", value: 10000, probability: 70, icon: "💐", color: "#4CAF50" },
        { name: "墨镜", value: 25000, probability: 19.889, icon: "🕶️", color: "#2196F3" },
        { name: "礼花筒", value: 50000, probability: 7, icon: "🎆", color: "#FFC107" },
        { name: "比心兔兔", value: 100000, probability: 3, icon: "🐰💖", color: "#E91E63" },
        { name: "热气球", value: 520000, probability: 0.1, icon: "🎈", color: "#9C27B0" },
        { name: "跑车", value: 1200000, probability: 0.01, icon: "🏎️", color: "#FF5722" },
        { name: "嘉年华", value: 2800000, probability: 0.001, icon: "🎪", color: "#00BCD4" }
    ],
    drawCost: 50
};

// 打开盲盒宝箱界面
function openGiftBox() {
    document.getElementById('giftBoxModal').style.display = 'flex';
    resetGiftBox();
}

// 关闭盲盒宝箱界面
function closeGiftBox() {
    document.getElementById('giftBoxModal').style.display = 'none';
}

// 重置盲盒显示
function resetGiftBox() {
    const boxInner = document.getElementById('boxInner');
    boxInner.style.transform = 'rotateY(0deg)';
    
    document.getElementById('giftIcon').textContent = '🎁';
    document.getElementById('giftName').textContent = '未知礼物';
    document.getElementById('giftValue').textContent = '价值: 0 玫瑰花';
}

// 抽取礼物
function drawGift() {
    if (player.nightClub.starCoins < 500) {
        logAction("星币不足！", "error");
        return;
    }
    
    // 扣除星币
    player.nightClub.starCoins -= 500;
   
    
    // 计算总概率
    const totalProbability = giftBoxSystem.gifts.reduce((sum, gift) => sum + gift.probability, 0);
    
    // 生成随机数
    const random = Math.random() * totalProbability;
    
    // 确定获得的礼物
    let cumulative = 0;
    let selectedGift = null;
    
    for (const gift of giftBoxSystem.gifts) {
        cumulative += gift.probability;
        if (random <= cumulative) {
            selectedGift = gift;
            break;
        }
    }
    
    // 如果没有选中礼物（理论上不会发生），默认给鲜花
    if (!selectedGift) {
        selectedGift = giftBoxSystem.gifts[0];
    }
    
    // 更新直播总收益
    player.liveStream.totalEarnings += selectedGift.value;
    
    // 记录打赏（限制长度防止内存增长）
    player.liveStream.donationHistory.push({
        viewer: "主播自己",
        amount: selectedGift.value,
        message: `获得${selectedGift.name}`,
        time: Date.now()
    });
    if (player.liveStream.donationHistory.length > 100) {
        player.liveStream.donationHistory = player.liveStream.donationHistory.slice(-100);
    }
    
    // 显示礼物结果
    showGiftResult(selectedGift);
    
    // 添加弹幕消息
    addDanmakuMessageq("系统", `恭喜主播从盲盒中，抽到了${selectedGift.name}`, "system");
    
    // 更新UI
    updateLiveStreamUI();
    updateDisplay();
    
    logAction(`开启盲盒获得${selectedGift.name}，价值${selectedGift.value}朵玫瑰花`, "success");
}

// 显示礼物结果
function showGiftResult(gift) {
    const boxInner = document.getElementById('boxInner');
    const giftIcon = document.getElementById('giftIcon');
    const giftName = document.getElementById('giftName');
    const giftValue = document.getElementById('giftValue');
    
    // 更新礼物信息
    giftIcon.textContent = gift.icon;
    giftName.textContent = gift.name;
    giftName.style.color = gift.color;
    giftValue.textContent = `价值: ${gift.value.toLocaleString()} 玫瑰花`;
    
    // 添加动画效果
    boxInner.style.transform = 'rotateY(180deg)';
    
    // 添加粒子效果
    createParticles();
}

// 创建粒子效果
function createParticles() {
    const giftBox = document.getElementById('giftBox');
    const colors = ['#ff9966', '#ff5e62', '#ffcc00', '#4CAF50', '#2196F3'];
    
    for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = '8px';
        particle.style.height = '8px';
        particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        particle.style.borderRadius = '50%';
        particle.style.zIndex = '10';
        
        // 随机位置
        const posX = Math.random() * 200;
        const posY = Math.random() * 200;
        particle.style.left = `${posX}px`;
        particle.style.top = `${posY}px`;
        
        giftBox.appendChild(particle);
        
        // 动画效果
        const angle = Math.random() * Math.PI * 2;
        const distance = 100 + Math.random() * 100;
        const duration = 1000 + Math.random() * 500;
        
        particle.animate(
            [
                { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                { transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`, opacity: 0 }
            ],
            {
                duration: duration,
                easing: 'ease-out'
            }
        ).onfinish = () => {
            particle.remove();
        };
    }
}



const worldZones = [
    {
        id: 'beginner',
        name: '新手村',
        minLevel: 1,
        maxLevel: 49,
        expRange: [1, 10],
        monsterNames: ['小妖', '小怪', '小兽', '小魔', '小精', '小灵', '小魂', '小魄'],
        modifiers: [
            { name: '普通', health: 1.0, attack: 2.0 },
            { name: '强壮', health: 1.5, attack: 3.2 },
            { name: '野蛮', health: 2.2, attack: 2.5 },
            { name: '弱小', health: 0.5, attack: 0.2 },
            { name: '强大', health: 5.2, attack: 5.5 },
            { name: '影子', health: 3.5, attack: 2.2 },
            { name: '敏捷', health: 2.2, attack: 10.5 },
            { name: '狂暴', health: 1.3, attack: 11.8 }
        ]
    },
    {
        id: 'forest',
        name: '落木林',
        minLevel: 50,
        maxLevel: 99,
        expRange: [10, 25],
        monsterNames: ['树妖', '木精', '叶魔', '根魂', '枝魄', '森灵', '林怪', '藤妖'],
        modifiers: [
            { name: '剧毒', health: 3.2, attack: 1.8 },
            { name: '缠绕', health: 5.8, attack: 31.2 },
            { name: '吸血', health: 7.5, attack: 5.5 },
            { name: '邪恶', health: 23.8, attack: 3.2 },
            { name: '幽魂', health: 6.5, attack: 7.5 },
            { name: '火焰', health: 7.8, attack: 8.2 },
            { name: '冰霜', health: 9.5, attack: 13.5 },   
            { name: '雷霆', health: 10.8, attack: 23.2 },
            { name: '闪电', health: 5.5, attack: 5.5 },
            { name: '再生', health: 7.0, attack: 1.0 }
            
        ]
    },
    {
        id: 'plains',
        name: '青风平原',
        minLevel: 100,
        maxLevel: 149,
        expRange: [25, 50],
        monsterNames: ['风灵', '草妖', '石魔', '土魂', '沙魄', '云精', '雾怪', '雨灵'],
        modifiers: [
            { name: '疾风', health: 21.0, attack: 12.0 },
            { name: '厚土', health: 12.0, attack: 13.0 },
            { name: '飞沙', health: 11.5, attack: 15.8 },
            { name: '风暴', health: 21.0, attack: 18.0 },
            { name: '流沙', health: 12.0, attack: 11.0 },
            { name: '魅影', health: 21.5, attack: 21.8 },
            { name: '龙卷风', health: 21.0, attack: 32.0 },
            { name: '法师', health: 12.0, attack: 41.0 },
            { name: '刺客', health: 12.5, attack: 51.8 },
            { name: '迷雾', health: 15.8, attack: 21.5 }

        ]
    },
    {
        id: 'swamp',
        name: '迷雾沼泽',
        minLevel: 150,
        maxLevel: 199,
        expRange: [50, 100],
        monsterNames: ['沼魔', '泥妖', '水精', '雾魂', '毒魄', '瘴灵', '腐怪', '湿妖'],
        modifiers: [
            { name: '剧毒', health: 10.5, attack: 20.0 },
            { name: '腐蚀', health: 20.0, attack: 10.8 },
            { name: '减速', health: 104.8, attack: 10.5 },
            { name: '灼烧', health: 10.5, attack: 70.0 },
            { name: '冰冻', health: 20.0, attack: 80.8 },
            { name: '野蛮', health: 100.8, attack: 380.5 },
            { name: '毒粉', health: 10.5, attack: 250.0 },
            { name: '妖化', health: 20.0, attack: 140.8 },
            { name: '电王', health: 140.8, attack: 130.5 },
            { name: '致盲', health: 100.5, attack: 200.2 }
        ]
    },
    {
        id: 'nest',
        name: '剧毒巢穴',
        minLevel: 200,
        maxLevel: 249,
        expRange: [100, 250],
        monsterNames: ['毒蛛', '蝎魔', '蛇妖', '蜈蚣精', '蟾蜍怪', '蜂后', '蚁王', '蝇魔'],
        modifiers: [
            { name: '致命毒液', health: 10.8, attack: 52.5 },
            { name: '麻痹毒素', health: 280.0, attack: 172.0 },
            { name: '神经毒素', health: 180.5, attack: 113.0 },
            { name: '灵魂毒液', health: 30.8, attack: 412.5 },
            { name: '肉体毒素', health: 280.0, attack: 221.0 },
            { name: '轻微毒素', health: 20.5, attack: 433.0 },
            { name: '智障毒液', health: 10.8, attack: 302.5 },
            { name: '雷雨毒素', health: 23.0, attack: 602.0 },
            { name: '闪电毒素', health: 101.5, attack: 333.0 },
            { name: '腐蚀酸液', health: 87.5, attack: 702.2 }
        ]
    },
    {
        id: 'wetland',
        name: '浅滩湿地',
        minLevel: 250,
        maxLevel: 299,
        expRange: [250, 500],
        monsterNames: ['水妖', '泽魔', '滩魂', '湿魄', '藻精', '贝怪', '蟹灵', '虾妖'],
        modifiers: [
            { name: '水之护盾', health: 32.0, attack: 12.5 },
            { name: '潮汐之力', health: 11.8, attack: 52.8 },
            { name: '深海恐惧', health: 21.5, attack: 23.5 },
            { name: '水之战舰', health: 341.0, attack: 123.5 },
            { name: '潮汐冰箭', health: 11.8, attack: 312.8 },
            { name: '深海咆哮', health: 21.5, attack: 232.5 },
            { name: '水王', health: 53.0, attack: 791.5 },
            { name: '水皇', health: 551.8, attack: 552.8 },
            { name: '水尊', health: 288.5, attack: 882.5 },
            { name: '漩涡牵引', health: 26.0, attack: 356.0 }
        ]
    },
    {
        id: 'canyon',
        name: '黑风峡谷',
        minLevel: 300,
        maxLevel: 349,
        expRange: [500, 1000],
        monsterNames: ['岩魔', '石怪', '山精', '谷魂', '崖魄', '壁妖', '穴灵', '洞魔'],
        modifiers: [
            { name: '岩甲', health: 40.0, attack: 100.8 },
            { name: '落石', health: 20.5, attack: 300.0 },
            { name: '地震', health: 30.5, attack: 200.8 },
            { name: '石小妖', health: 2.0, attack: 10.8 },
            { name: '石头怪', health: 20.5, attack: 30.0 },
            { name: '石帝', health: 30.5, attack: 310.8 },
            { name: '石妖', health: 100.0, attack: 120.8 },
            { name: '石王', health: 20.5, attack: 300.0 },
            { name: '石皇', health: 200.5, attack: 200.8 },
            { name: '山崩', health: 200.0, attack: 300.5 }
        ]
    },
    {
        id: 'swamp2',
        name: '迷雾沼泽深处',
        minLevel: 350,
        maxLevel: 399,
        expRange: [1000, 2500],
        monsterNames: ['沼王', '泥后', '水帝', '雾皇', '毒尊', '瘴圣', '腐神', '湿魔'],
        modifiers: [
            { name: '剧毒领域', health: 100.0, attack: 400.0 },
            { name: '腐蚀领域', health: 20.0, attack: 300.5 },
            { name: '迷雾领域', health: 30.5, attack: 200.5 },
            { name: '氧化领域', health: 30.0, attack: 400.0 },
            { name: '腐闪领域', health: 40.0, attack: 300.5 },
            { name: '蜂石领域', health: 30.5, attack: 800.5 },
            { name: '恶徒领域', health: 30.0, attack: 400.0 },
            { name: '螣神领域', health: 40.0, attack: 100.5 },
            { name: '山峰领域', health: 30.5, attack: 300.5 },
            { name: '死亡领域', health: 100.0, attack: 500.0 }
        ]
    },
    {
        id: 'abyss',
        name: '暗影深渊',
        minLevel: 400,
        maxLevel: 449,
        expRange: [2500, 5000],
        monsterNames: ['影魔', '暗妖', '渊魂', '冥魄', '夜精', '幽怪', '鬼灵', '魅魔'],
        modifiers: [
            { name: '暗影突袭', health: 30.5, attack: 700.0 },
            { name: '深渊凝视', health: 150.0, attack: 310.0 },
            { name: '虚空吞噬', health: 140.5, attack: 450.8 },
            { name: '时间回溯', health: 230.5, attack: 500.0 },
            { name: '精神屏障', health: 50.0, attack: 300.0 },
            { name: '晶体穿刺', health: 210.5, attack: 100.8 },
            { name: '空间封锁', health: 100.5, attack: 200.0 },
            { name: '声波共振', health: 50.0, attack: 200.0 },
            { name: '精神链接', health: 30.5, attack: 400.8 },
            { name: '永夜降临', health: 200.0, attack: 600.0 }
        ]
    },
    {
        id: 'rift',
        name: '混沌之隙',
        minLevel: 450,
        maxLevel: 499,
        expRange: [5000, 10000],
        monsterNames: ['混沌兽', '无序魔', '混乱妖', '虚空精', '扭曲魂', '裂痕魄', '次元怪', '位面灵'],
        modifiers: [
            { name: '混沌护盾', health: 80.0, attack: 500.0 },
            { name: '空间撕裂', health: 50.5, attack: 800.0 },
            { name: '时间扭曲', health: 70.0, attack: 700.0 },
            { name: '时间停滞', health: 200.0, attack: 500.0 },
            { name: '空间暗影', health: 100.5, attack: 100.0 },
            { name: '时间风暴', health: 70.0, attack: 200.0 },
            { name: '维度停滞', health: 20.0, attack: 500.0 },
            { name: '暗影风暴', health: 200.5, attack: 200.0 },
            { name: '混沌风暴', health: 70.0, attack: 700.0 },
            { name: '位面崩塌', health: 100.0, attack: 100.0 }
        ]
    },
    {
        id: 'battlefield',
        name: '血狱战场',
        minLevel: 500,
        maxLevel: 549,
        expRange: [10000, 15000],
        monsterNames: ['血魔', '狱妖', '战魂', '争魄', '杀精', '戮怪', '伐灵', '征魔'],
        modifiers: [
            { name: '嗜血', health: 400.0, attack: 10000.0 },
            { name: '狂战', health: 80.0, attack: 8000.0 },
            { name: '不屈', health: 10.0, attack: 5000.0 },
            { name: '血族', health: 300.0, attack: 10000.0 },
            { name: '狂战族', health: 50.0, attack: 3000.0 },
            { name: '不屈族', health: 150.0, attack: 2000.0 },
            { name: '嗜血族', health: 600.0, attack: 10000.0 },
            { name: '狂战血脉', health: 500.0, attack: 1800.0 },
            { name: '不屈血脉', health: 150.0, attack: 1500.0 },
            { name: '死战', health: 530.0, attack: 15000.0 }
        ]
    },
    {
        id: 'lair',
        name: '恶魔巢穴',
        minLevel: 550,
        maxLevel: 599,
        expRange: [15000, 25000],
        monsterNames: ['恶魔领主', '深渊魔王', '地狱公爵', '炼狱侯爵', '邪能伯爵', '堕落子爵', '腐化男爵', '扭曲骑士'],
        modifiers: [
            { name: '恶魔之怒', health: 100.0, attack: 3500.0 },
            { name: '深渊之力', health: 20.0, attack: 8200.0 },
            { name: '炼狱之力', health: 120.0, attack: 18000.0 },
            { name: '恶魔之力', health: 130.0, attack: 1500.0 },
            { name: '夜魔之力', health: 30.0, attack: 1200.0 },
            { name: '地狱之力', health: 120.0, attack: 18000.0 },
            { name: '魔神之力', health: 10.0, attack: 15000.0 },
            { name: '深渊核心', health: 110.0, attack: 12000.0 },
            { name: '地火核心', health: 120.0, attack: 1800.0 },
            { name: '邪能腐蚀', health: 480.0, attack: 38000.0 }
        ]
    },
    {
        id: 'throne',
        name: '冰封王座',
        minLevel: 600,
        maxLevel: 649,
        expRange: [25000, 50000],
        monsterNames: ['冰霜巨龙', '寒冰巫妖', '极地巨人', '雪域女王', '冰川领主', '冻土之王', '永冬守卫', '霜寒使者'],
        modifiers: [
            { name: '绝对零度', health: 20.0, attack: 1200.0 },
            { name: '冰封领域', health: 100.0, attack: 7000.0 },
            { name: '霜冻新星', health: 20.0, attack: 1300.0 },
            { name: '零度之力', health: 20.0, attack: 4800.0 },
            { name: '封神领域', health: 320.0, attack: 10000.0 },
            { name: '霜冻之力', health: 10.0, attack: 800.0 },
            { name: '霜寒死神', health: 200.0, attack: 3200.0 },
            { name: '冰封之力', health: 30.0, attack: 2200.0 },
            { name: '灵魂深王', health: 250.0, attack: 13020.0 },
            { name: '寒冰牢笼', health: 550.0, attack: 45000.0 }
        ]
    },
    {
        id: 'wasteland',
        name: '血月荒原',
        minLevel: 650,
        maxLevel: 699,
        expRange: [50000, 100000],
        monsterNames: ['血月狼王', '赤红巨蝎', '绯色狮鹫', '猩红飞龙', '朱红泰坦', '深红梦魇', '鲜红收割者', '暗红破坏神'],
        modifiers: [
            { name: '血月之力', health: 400.0, attack: 5000.0 },
            { name: '猩红狂暴', health: 90.0, attack: 7200.0 },
            { name: '赤红领域', health: 300.0, attack: 4400.0 },
            { name: '血月暗魔', health: 400.0, attack: 2000.0 },
            { name: '猩红之力', health: 70.0, attack: 31000.0 },
            { name: '血族领域', health: 61.0, attack: 14000.0 },
            { name: '血月战刃', health: 30.0, attack: 25000.0 },
            { name: '收割者领域', health: 40.0, attack: 5000.0 },
            { name: '梦魇领域', health: 69.0, attack: 41000.0 },
            { name: '深红诅咒', health: 390.0, attack: 60000.0 }
        ]
    },
    {
        id: 'ruins',
        name: '时空废墟',
        minLevel: 700,
        maxLevel: 749,
        expRange: [100000, 500000],
        monsterNames: ['时空守护者', '裂隙观察者', '维度旅行者', '位面穿梭者', '虚空漫步者', '次元监察者', '宇宙编织者', '现实扭曲者'],
        modifiers: [
            { name: '时间加速', health: 20.0, attack: 8000.0 },
            { name: '空间折叠', health: 280.0, attack: 7000.0 },
            { name: '维度撕裂', health: 190.0, attack: 4000.0 },
            { name: '量子隐身', health: 70.0, attack: 81000.0 },
            { name: '时间碎片', health: 380.0, attack: 23000.0 },
            { name: '维度错位', health: 90.0, attack: 18000.0 },
            { name: '中子星脉冲', health: 70.0, attack: 20000.0 },
            { name: '时间分流', health: 80.0, attack: 30000.0 },
            { name: '超声波攻击', health: 400.0, attack: 50000.0 },
            { name: '现实重构', health: 600.0, attack: 100000.0 }
        ]
    },
    {
        id: 'land',
        name: '星陨之地',
        minLevel: 750,
        maxLevel: 799,
        expRange: [500000, 1000000],
        monsterNames: ['星陨巨兽', '陨石领主', '彗星使者', '流星猎人', '行星吞噬者', '恒星毁灭者', '星系守护者', '宇宙创造者'],
        modifiers: [
            { name: '星辰坠落', health: 150.0, attack: 5800.0 },
            { name: '黑洞吞噬', health: 20.0, attack: 25000.0 },
            { name: '超新星爆发', health: 180.0, attack: 53000.0 },
            { name: '星辰碰撞', health: 150.0, attack: 70100.0 },
            { name: '流星吞噬', health: 200.0, attack: 15000.0 },
            { name: '毁灭爆发', health: 18.0, attack: 30000.0 },
            { name: '星辰爆炸', health: 150.0, attack: 80000.0 },
            { name: '银河吞噬', health: 200.0, attack: 45000.0 },
            { name: '超新爆风', health: 180.0, attack: 220000.0 },
            { name: '宇宙大爆炸', health: 700.0, attack: 300000.0 }
        ]
    },
    {
        id: 'temple',
        name: '永恒圣殿',
        minLevel: 800,
        maxLevel: 849,
        expRange: [1000000, 5000000],
        monsterNames: ['圣殿守卫', '永恒骑士', '不朽祭司', '神圣主教', '天界大天使', '神域审判者', '至高仲裁者', '创世神使'],
        modifiers: [
            { name: '神圣庇护', health: 50.0, attack: 10000.0 },
            { name: '永恒之光', health: 140.0, attack: 30100.0 },
            { name: '神之裁决', health: 310.0, attack: 151000.0 },
            { name: '神圣打击', health: 520.0, attack: 301020.0 },
            { name: '神圣之光', health: 240.0, attack: 60200.0 },
            { name: '神之神剑', health: 600.0, attack: 51000.0 },
            { name: '神圣护盾', health: 450.0, attack: 440000.0 },
            { name: '神王护体', health: 240.0, attack: 360000.0 },
            { name: '神尊破灭', health: 160.0, attack: 252000.0 },
            { name: '创世之力', health: 1000.0, attack: 800000.0 }
        ]
    },
    {
        id: 'realm',
        name: '万象界域',
        minLevel: 850,
        maxLevel: 899,
        expRange: [5000000, 10000000],
        monsterNames: ['万象之主', '元素皇帝', '法则掌控者', '秩序守护神', '混沌化身', '虚空君主', '位面主宰', '多元宇宙观察者'],
        modifiers: [
            { name: '元素风暴', health: 130.0, attack: 42000.0 },
            { name: '法则扭曲', health: 750.0, attack: 80000.0 },
            { name: '秩序崩坏', health: 420.0, attack: 65000.0 },
            { name: '元素至尊', health: 300.0, attack: 92000.0 },
            { name: '法则至尊', health: 280.0, attack: 100000.0 },
            { name: '秩序至尊', health: 240.0, attack: 250000.0 },
            { name: '万象至尊', health: 400.0, attack: 320000.0 },
            { name: '混沌至尊', health: 430.0, attack: 400000.0 },
            { name: '位面至尊', health: 320.0, attack: 750000.0 },
            { name: '混沌初开', health: 1000.0, attack: 1000000.0 }
        ]
    },
    {
        id: 'realm2',
        name: '鸿蒙秘境',
        minLevel: 900,
        maxLevel: 949,
        expRange: [10000000, 50000000],
        monsterNames: ['鸿蒙巨兽', '太初古神', '元始天尊', '造化之主', '命运编织者', '因果律者', '真理守护者', '终极观察者'],
        modifiers: [
            { name: '鸿蒙初开', health: 500.0, attack: 1100000.0 },
            { name: '太初之力', health: 700.0, attack: 2400000.0 },
            { name: '造化神功', health: 200.0, attack: 1100000.0 },
            { name: '鸿蒙尊者', health: 100.0, attack: 2050000.0 },
            { name: '太初尊者', health: 700.0, attack: 3020000.0 },
            { name: '未来尊者', health: 80.0, attack: 4001000.0 },
            { name: '命运尊者', health: 200.0, attack: 6000000.0 },
            { name: '太古尊者', health: 70.0, attack: 3000000.0 },
            { name: '九亥古神', health: 200.0, attack: 7000000.0 },
            { name: '终极真理', health: 1000.0, attack: 10000000.0 }
        ]
    },
    {
        id: 'domain',
        name: '终焉神域',
        minLevel: 950,
        maxLevel: 1000,
        expRange: [50000000, 100000000],
        monsterNames: ['终焉之主', '灭世魔神', '创世之神', '永恒终结者', '无限吞噬者', '绝对虚无', '最终答案', '一切之终'],
        modifiers: [
            { name: '终焉降临', health: 20.0, attack: 5000000.0 },
            { name: '灭世之力', health: 80.0, attack: 12000000.0 },
            { name: '创世之力', health: 20.0, attack: 8000000.0 },
            { name: '终焉之力', health: 240.0, attack: 27000000.0 },
            { name: '永恒之力', health: 310.0, attack: 12000000.0 },
            { name: '无限之力', health: 120.0, attack: 6000000.0 },
            { name: '绝对之力', health: 300.0, attack: 24000000.0 },
            { name: '灭世之力', health: 700.0, attack: 4200000.0 },
            { name: '灰烬之力', health: 550.0, attack: 20100000.0 },
            { name: '绝对虚无', health: 1000.0, attack: 50000000.0 }
        ]
    }
];
const dimensionConfig = {
    1: { cost: 1, expMultiplier: 1, attackMultiplier: 1, name: "次元1", ascentionRequired: 0 },
    2: { cost: 3, expMultiplier: 5, attackMultiplier: 100000, name: "次元2", ascentionRequired: 1 },
    3: { cost: 5, expMultiplier: 10, attackMultiplier: 1e10, name: "次元3", ascentionRequired: 2 },
    4: { cost: 25, expMultiplier: 50, attackMultiplier: 1e20, name: "次元4", ascentionRequired: 3 },
    5: { cost: 50, expMultiplier: 100, attackMultiplier: 1e30, name: "次元5", ascentionRequired: 4 },
    6: { cost: 100, expMultiplier: 200, attackMultiplier: 1e40, name: "次元6", ascentionRequired: 6 },
    7: { cost: 250, expMultiplier: 500, attackMultiplier: 1e50, name: "次元7", ascentionRequired: 8 },
    8: { cost: 500, expMultiplier: 1000, attackMultiplier: 1e60, name: "次元8", ascentionRequired: 10 }
};

        // 切换次元难度
      function changeDimension(level) {
    const config = dimensionConfig[level];
    
    // 检查轮回转生次数要求
    if (player.level.ascentionCounta < config.ascentionRequired) {
        logAction(`进入${config.name}需要轮回${config.ascentionRequired}转！当前轮回${player.level.ascentionCounta}转`, "error");
        return;
    }
    
    player.dimensionLevel = level;
    updateDimensionUI();
    saveGame();
    logAction(`已切换到${config.name}`, "success");
}

// 修改更新次元难度UI显示函数
function updateDimensionUI() {
    // 更新按钮激活状态和可用性
    document.querySelectorAll('.dimension-btn').forEach((btn, index) => {
        const level = index + 1;
        const config = dimensionConfig[level];
        const canAccess = player.level.ascentionCounta >= config.ascentionRequired;
        
        if (level === player.dimensionLevel) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
        
        // 根据是否可访问设置按钮样式
        if (!canAccess) {
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
            btn.title = `需要轮回${config.ascentionRequired}转`;
        } else {
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
            btn.title = '';
        }
    });
    
    // 更新难度信息
    const config = dimensionConfig[player.dimensionLevel];
    document.getElementById('currentDimension').textContent = config.name;
    document.getElementById('dimensionCost').textContent = config.cost;
    document.getElementById('dimensionExpMultiplier').textContent = config.expMultiplier;
    document.getElementById('dimensionAttackMultiplier').textContent = config.attackMultiplier.toExponential(1);
    
    // 显示轮回转生要求
    document.querySelector('.dimension-info').innerHTML = `
        当前难度: <span id="currentDimension">${config.name}</span><br>
        轮回要求: ${config.ascentionRequired}转<br>
        星币消耗: <span id="dimensionCost">${config.cost}</span><br>
        经验倍数: <span id="dimensionExpMultiplier">${config.expMultiplier}</span>倍<br>
        怪物攻击: <span id="dimensionAttackMultiplier">${config.attackMultiplier.toExponential(1)}</span>倍
    `;
}
// 切换世界地图界面
function toggleWorldMap() {
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启世界地图！");
        return;
    }
    
    // 关闭所有自动攻击（包括后台）
    stopAllWorldMapBattles();
    
    const overlay = document.getElementById('worldMapOverlay');
    const ui = document.getElementById('worldMapUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateWorldMapUI();
    }
}
function stopAllWorldMapBattles() {
    // 停止前台自动战斗
    if (player.worldMapBattle.autoBattleInterval) {
        clearInterval(player.worldMapBattle.autoBattleInterval);
        player.worldMapBattle.autoBattleInterval = null;
    }
    
    // 停止后台自动战斗
    stopBackgroundBattle();
    
    // 重置战斗状态
    player.backgroundBattle.active = false;
}
// 更新世界地图界面
function updateWorldMapUI() {
    const container = document.getElementById('zoneList');
    container.innerHTML = '';
    
    worldZones.forEach(zone => {
        const zoneElement = document.createElement('div');
        zoneElement.style.background = '#333';
        zoneElement.style.padding = '15px';
        zoneElement.style.borderRadius = '8px';
        zoneElement.style.textAlign = 'center';
        zoneElement.style.cursor = 'pointer';
        
        zoneElement.innerHTML = `
            <h3>${zone.name}</h3>
            <div>等级: ${zone.minLevel}-${zone.maxLevel}</div>
            <div>经验: ${zone.expRange[0]}-${zone.expRange[1]}*(VIP*10)</div>
        `;
        
        zoneElement.onclick = () => startBattleInZone(zone);
        container.appendChild(zoneElement);
    });
}

// 在指定区域开始战斗
function startBattleInZone(zone) {
    const dimension = dimensionConfig[player.dimensionLevel];
    
    // 检查轮回转生要求
    if (player.level.ascentionCounta < dimension.ascentionRequired) {
        logAction(`进入${dimension.name}需要轮回${dimension.ascentionRequired}转！当前轮回${player.level.ascentionCounta}转`, "error");
        toggleWorldMap();
        return;
    }
    
    if (player.nightClub.starCoins < dimension.cost) {
        logAction(`星币不足！需要${dimension.cost}个星币`, "error");
        toggleWorldMap();
        return;
    }
    
    player.nightClub.starCoins -= dimension.cost;
    logAction(`消耗${dimension.cost}个星币生成怪物（${dimension.name}）`, "info");
    player.battle.currentZone = zone;
    
    // 生成怪物（考虑次元难度）
    generateMonsterForZone(zone, dimension);
    
    // 初始化战斗状态
    player.battle.monsterResurrections = 0;
    
    // 显示战斗界面
    document.getElementById('worldMapUI').style.display = 'none';
    document.getElementById('worldMapOverlay').style.display = 'none';
    
    document.getElementById('battleUI').style.display = 'block';
    document.getElementById('battleOverlay').style.display = 'block';
    
    updateBattleUI();
}
// 为区域生成怪物
function generateMonsterForZone(zone, dimension) {
            // 随机选择怪物名字
            const name = zone.monsterNames[Math.floor(Math.random() * zone.monsterNames.length)];
            
            // 随机选择词条
            const modifier = zone.modifiers[Math.floor(Math.random() * zone.modifiers.length)];
            
            // 计算基础属性
            const stage = Math.floor((zone.minLevel + zone.maxLevel) / 2);
            const healthMultiplier = Math.pow(2, stage);
            const attackMultiplier = calculateAttackMultiplier(stage);
            
            // 应用词条加成和次元难度加成
            const health = 10000 * healthMultiplier * modifier.health;
            const attack = attackMultiplier * modifier.attack * dimension.attackMultiplier;
            
            player.battle.currentMonster = {
                name: `${name}`,
                rank: modifier.name,
                health: health,
                maxHealth: health,
                attack: attack,
                resurrections: 0,
                modifier: modifier
            };
        }

// 计算攻击乘数
function calculateAttackMultiplier(stage) {
    if (stage <= 5) return Math.floor(Math.random() * 3) + 1;
    if (stage <= 25) return 100 + (stage - 4) * 10;
    if (stage <= 50) return 1000 + (stage - 24) * 100;
    if (stage <= 100) return 5000 + (stage - 49) * 500;
    if (stage <= 150) return 50000 + (stage - 99) * 1000;
    if (stage <= 200) return 10000 + (stage - 149) * 10000;
    if (stage <= 250) return 500000 + (stage - 199) * 100000;
    if (stage <= 300) return 5000000 + (stage - 249) * 1000000;
    if (stage <= 350) return 10000000 + (stage - 299) * 100000000;
    if (stage <= 400) return 100000000 + (stage - 349) * 1000000000;
    if (stage <= 450) return 1000000000 + (stage - 399) * 100000000000;
    if (stage <= 500) return 10000000000 + (stage - 349) * 100000000000000;
    if (stage <= 550) return 100000000000 + (stage - 499) * 10000000000000000;
    if (stage <= 600) return 1000000000000 + (stage - 549) * 1000000000000000000;
    if (stage <= 650) return 10000000000000 + (stage - 599) * 1000000000000000000000;
    if (stage <= 700) return 100000000000000 + (stage - 649) * 1000000000000000000000000;
    if (stage <= 750) return 1000009000000000 + (stage - 699) * 10000000000000000000000000000;
    if (stage <= 800) return 10000000000000900 + (stage - 749) * 1000000000000000000000000000000000;
    if (stage <= 850) return 100000000000000900 + (stage - 799) * 10000000000000000000000000000000000000000;
    if (stage <= 900) return 10000000000000000900 + (stage - 849) * 10000000000000000000000000000000000000000000000;
    if (stage <= 950) return 6500000000000000000900 + (stage - 899) * 1000000000000000000000000000000000000000000000000000000;    
    return 650000000000000000000000000000000900 + (stage - 949) * 100000000000000000000000000000000000000000000000000000000000000;
}

// 更新战斗界面
function updateBattleUI() {
    // 玩家属性
    document.getElementById('battlePlayerHealth').textContent = player.battle.playerHealth.toExponential(3);
    document.getElementById('battlePlayerAttack').textContent = player.battle.playerAttack.toExponential(3);
    document.getElementById('battlePlayerCritRate').textContent = (player.battle.playerCritRate * 100).toFixed(2) + '%';
    document.getElementById('battlePlayerCritDamage').textContent = (player.battle.playerCritDamage * 100).toExponential(3) + '%';
    document.getElementById('battleRebornDanCount').textContent = (player.nightClub.starCoins || 0).toFixed(1);

    
    // 怪物属性
    const monster = player.battle.currentMonster;
    document.getElementById('battleMonsterName').textContent = monster.name;
    document.getElementById('battleMonsterHealth').textContent = formatNumber(monster.health);
    document.getElementById('battleMonsterMaxHealth').textContent = formatNumber(monster.maxHealth);
    document.getElementById('battleMonsterAttack').textContent = formatNumber(monster.attack);
    document.getElementById('battleMonsterModifier').textContent = ` ${monster.rank}`;
   document.getElementById('battleMonsterResurrections').textContent = player.battle.monsterResurrections;
}

// 切换自动战斗
function toggleWorldMapAutoBattle() {
    player.worldMapBattle.autoBattle = !player.worldMapBattle.autoBattle;
    document.getElementById('worldMapAutoBattleStatus').textContent = 
        player.worldMapBattle.autoBattle ? '开启' : '关闭';
    
    if (player.worldMapBattle.autoBattle) {
        // 如果战斗界面是打开的，则启动前台计时器
        if (document.getElementById('battleUI').style.display === 'block') {
            player.worldMapBattle.autoBattleInterval = registerInterval(worldMapAttackMonster, 500);
        } else {
            // 否则，启动后台战斗
            player.backgroundBattle.active = true;
            startBackgroundBattle();
        }
    } else {
        // 停止所有战斗
        stopAllWorldMapBattles();
    }
    
    logAction(`世界地图自动战斗${player.worldMapBattle.autoBattle ? '开启' : '关闭'}`, "info");
}

// 攻击怪物
function worldMapAttackMonster() {
    const playerAttack = player.battle.playerAttack;
    const monster = player.battle.currentMonster;
    
    // 计算伤害（考虑暴击）
    let isCrit = Math.random() < player.battle.playerCritRate;
    let damage = isCrit ? playerAttack * player.battle.playerCritDamage : playerAttack;
    
    // 应用伤害
    monster.health -= damage;
    
    // 记录战斗日志
    addBattleLog(`你对${monster.name}造成了${damage.toExponential(2)}点${isCrit ? '暴击 ' : ''}伤害`);
    
    // 检查怪物是否死亡
    if (monster.health <= 0) {
        handleMonsterDefeated();
    } else {
        // 怪物反击
        monsterCounterAttack();
    }
    
    updateBattleUI();
}

// 怪物反击
function monsterCounterAttack() {
    const monster = player.battle.currentMonster;
    const damage = monster.attack;
    
    // 应用伤害
    player.battle.playerHealth -= damage;
    
    // 记录战斗日志
    addBattleLog(`${monster.name}对你造成了${damage.toExponential(2)}点伤害`);
    
    // 检查玩家是否死亡
    if (player.battle.playerHealth <= 0) {
        addBattleLog('你被怪物击败了！');
        closeBattle();
     updatePlayerBattleStats();
    }
    
    updateBattleUI();
}
let cachedClassBonuses = null;
let lastClassUpdate = 0;

function getCachedClassBonuses() {
    // 每秒钟重新计算一次，或者当职业相关数据变化时更新
    const now = Date.now();
    if (!cachedClassBonuses || now - lastClassUpdate > 1000) {
        cachedClassBonuses = calculateClassBonuses();
        lastClassUpdate = now;
    }
    return cachedClassBonuses;
}
// 处理怪物被击败
function handleMonsterDefeated() {
            const monster = player.battle.currentMonster;
            const zone = player.battle.currentZone;
            const dimension = dimensionConfig[player.dimensionLevel];
            
            // 增加复活次数
            player.battle.monsterResurrections++;
            
            if (player.battle.monsterResurrections < 3) {
                // 怪物复活（属性增强）
                monster.health = monster.maxHealth * Math.pow(2, player.battle.monsterResurrections);
                monster.attack *= 2;
                
                addBattleLog(`${monster.name}复活了！(第${player.battle.monsterResurrections}次)`);
                monsterCounterAttack();
            } else {
                // 怪物真正死亡
                addBattleLog(`你击败了${monster.name}！`);
                
                // 计算经验奖励（应用次元难度倍数）               
                const expMin = zone.expRange[0];
const expMax = zone.expRange[1];
const exp = Math.floor(Math.random() * (expMax - expMin + 1)) + expMin;
const runeBonuses = calculateRuneBonuses();
const worldExpBonus = 1 + runeBonuses.worldExp;

// 使用缓存的职业加成
const classBonuses = getCachedClassBonuses();
const explorerWorldExpBonus = classBonuses.worldExpMultiplier || 1; // 添加默认值1，避免undefined

const finalExp = (exp + (1 + player.mining.gems.ruby * 0.2)) * 
                 (player.vip.level * 10) * 
                 dimension.expMultiplier * 
                 worldExpBonus * 
                 (1 + player.fiveElements.earth.level * 0.2) *
                 (1 + player.abyssTower.bestFloor * 0.01) *
                 explorerWorldExpBonus;  // 添加探险家职业加成

// 添加经验
addPlayerExp(finalExp);
addBattleLog(`获得${finalExp.toLocaleString()}经验！`);
              
               dropRuneMaterials();
               dropMount();
                dropWing();
                if (Math.random() < 0.01) { // 1%掉落率
            dropItemsByDimension();          
            }
           dropReincarnationEquipment();
           tryDropBeastAfterBattle();
           tryDropPixelSkinAfterBattle();
                if (player.nightClub.starCoins < dimension.cost) {
                    addBattleLog("星币不足，无法生成新怪物！");
                    closeBattle();
                    return;
                }
                
                player.nightClub.starCoins -= dimension.cost;
                addBattleLog(`消耗${dimension.cost}个星币生成新怪物`);
                updateItemDisplay();
                
                // 生成新怪物
                generateMonsterForZone(zone, dimension);
                player.battle.monsterResurrections = 0;
                updatePlayerBattleStats();
            }
            
            updateBattleUI();
            updateLevelUI();
            updateDisplay();
        }
function dropItemsByDimension() {
    const dimension = player.dimensionLevel;
    let droppedItems = [];
    
    switch(dimension) {
        case 1:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            break;
        case 2:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou1');
            break;
        case 3:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou2');
            break;
        case 4:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou2');
            if (Math.random() < 0.2) droppedItems.push('yuzhou3');
            break;
        case 5:
            if (Math.random() < 0.5) droppedItems.push('vipPower');
            if (Math.random() < 0.2) droppedItems.push('banlv1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou1');
            if (Math.random() < 0.2) droppedItems.push('yuzhou2');
            if (Math.random() < 0.2) droppedItems.push('yuzhou3');
            if (Math.random() < 0.1) droppedItems.push('yuzhou4');
            break;
    }
    
    // 处理掉落物品
    if (droppedItems.length > 0) {
        let dropMessage = "怪物掉落: ";
        droppedItems.forEach(item => {
            player.items[item] = (player.items[item] || 0) + 1;
            dropMessage += `${itemEffects[item].name} `;
        });
        
        addBattleLog(dropMessage);
        logAction(dropMessage, 'success');
        updateItemDisplay();
    }
}

// 添加战斗日志（同时写入 player.battleLog 以便关闭再打开界面仍能看到，并限制长度防泄漏）
function addBattleLog(message) {
    if (!player.battleLog || !Array.isArray(player.battleLog)) player.battleLog = [];
    var logLine = '[' + new Date().toLocaleTimeString() + '] ' + message;
    player.battleLog.push(logLine);
    if (player.battleLog.length > 100) player.battleLog = player.battleLog.slice(-100);

    const logContainer = document.getElementById('addbattleLog');
    if (!logContainer) return;
    const logElement = document.createElement('div');
    logElement.textContent = logLine;

    logContainer.appendChild(logElement);
    if (logContainer.children.length > 10) logContainer.removeChild(logContainer.firstChild);
    logContainer.scrollTop = logContainer.scrollHeight;
}

// 关闭战斗
function closeBattle() {
    // 停止前台自动战斗（界面上的战斗）
    if (player.worldMapBattle.autoBattle) {
        clearInterval(player.worldMapBattle.autoBattleInterval);
        // 不改变autoBattle的状态，因为我们要保持自动战斗的开启状态，以便在后台继续
    }
    
    // 关闭界面
    document.getElementById('battleUI').style.display = 'none';
    document.getElementById('battleOverlay').style.display = 'none';
    
    // 如果自动战斗是开启的，则启动后台战斗
    if (player.worldMapBattle.autoBattle) {
        player.backgroundBattle.active = true;
        startBackgroundBattle();
        logAction("已切换到后台自动战斗", "info");
    }
}
function startBackgroundBattle() {
    // 清除之前的后台战斗
    if (player.backgroundBattle.interval) {
        clearInterval(player.backgroundBattle.interval);
    }
    
    // 检查是否有足够的星币
    const dimension = dimensionConfig[player.dimensionLevel];
    if (player.nightClub.starCoins < dimension.cost) {
        logAction("星币不足，无法启动后台自动战斗", "warning");
        player.backgroundBattle.active = false;
        return;
    }
    
    // 每秒钟执行一次后台战斗
    player.backgroundBattle.interval = registerInterval(() => {
        if (!player.backgroundBattle.active) {
            clearInterval(player.backgroundBattle.interval);
            return;
        }
        
        if (player.nightClub.starCoins < dimension.cost) {
            stopBackgroundBattle();
            logAction("星币不足，后台自动战斗已停止", "warning");
            return;
        }
        
        // 执行一次攻击
        backgroundWorldMapAttackMonster();
    }, 500);
    
    logAction("后台自动战斗已启动", "info");
}
function backgroundWorldMapAttackMonster() {
    const playerAttack = player.battle.playerAttack;
    const monster = player.battle.currentMonster;
    
    // 计算伤害（考虑暴击）
    let isCrit = Math.random() < player.battle.playerCritRate;
    let damage = isCrit ? playerAttack * player.battle.playerCritDamage : playerAttack;
    
    // 应用伤害
    monster.health -= damage;
    
    // 检查怪物是否死亡
    if (monster.health <= 0) {
        backgroundHandleMonsterDefeated();
    } else {
        // 怪物反击
        backgroundMonsterCounterAttack();
    }
}

// 后台怪物反击
function backgroundMonsterCounterAttack() {
    const monster = player.battle.currentMonster;
    const damage = monster.attack;
    
    // 应用伤害
    player.battle.playerHealth -= damage;
    
    // 检查玩家是否死亡
    if (player.battle.playerHealth <= 0) {
        stopBackgroundBattle();
        logAction("你在后台战斗中被怪物击败！", "error");
        updatePlayerBattleStats();
    }
}

// 后台处理怪物被击败
function backgroundHandleMonsterDefeated() {
    const monster = player.battle.currentMonster;
    const zone = player.battle.currentZone;
    const dimension = dimensionConfig[player.dimensionLevel]; // 获取当前次元配置
    
    // 增加复活次数
    player.battle.monsterResurrections++;
    
    if (player.battle.monsterResurrections < 3) {
        // 怪物复活（属性增强）
        monster.health = monster.maxHealth * Math.pow(2, player.battle.monsterResurrections);
        monster.attack *= 2;
        
        
        
        backgroundMonsterCounterAttack();
    } else {
        // 怪物真正死亡
        // 计算经验奖励（应用次元难度倍数）        
const expMin = zone.expRange[0];
const expMax = zone.expRange[1];
const exp = Math.floor(Math.random() * (expMax - expMin + 1)) + expMin;
const runeBonuses = calculateRuneBonuses();
const worldExpBonus = 1 + runeBonuses.worldExp;

// 使用缓存的职业加成
const classBonuses = getCachedClassBonuses();
const explorerWorldExpBonus = classBonuses.worldExpMultiplier || 1; // 添加默认值1，避免undefined

const finalExp = (exp + (1 + player.mining.gems.ruby * 0.2)) * 
                 (player.vip.level * 10) * 
                 dimension.expMultiplier * 
                 worldExpBonus * 
                 (1 + player.fiveElements.earth.level * 0.2) * 
                  (1 + player.abyssTower.bestFloor * 0.01) *
                 explorerWorldExpBonus;  // 添加探险家职业加成

// 添加经验
addPlayerExp(finalExp);

       dropMagicMaterial();
        dropRuneMaterials();
        dropMount();
        dropWing();
        // 1%概率掉落物品
        if (Math.random() < 0.01) {
            dropItemsByDimension();
        }
        dropReincarnationEquipment();
       tryDropBeastAfterBattle();
       tryDropPixelSkinAfterBattle();
        if (player.nightClub.starCoins < dimension.cost) {
            stopBackgroundBattle();
            logAction("星币不足，后台自动战斗已停止", "warning");
            return;
        }
        
         player.nightClub.starCoins -= dimension.cost;
        
        // 生成新怪物（应用次元难度）
        generateMonsterForZone(zone, dimension);
        player.battle.monsterResurrections = 0;
        updatePlayerBattleStats();
    }
}

// 停止后台战斗
function stopBackgroundBattle() {
    if (player.backgroundBattle.interval) {
        clearInterval(player.backgroundBattle.interval);
        player.backgroundBattle.interval = null;
    }
    player.backgroundBattle.active = false;
}

function openBattleUI() {
    document.getElementById('battleUI').style.display = 'block';
    document.getElementById('battleOverlay').style.display = 'block';
    
    // 如果自动战斗是开启的，则停止后台战斗，启动前台计时器
    if (player.worldMapBattle.autoBattle) {
        stopBackgroundBattle();
        if (player.worldMapBattle.autoBattleInterval) {
            clearInterval(player.worldMapBattle.autoBattleInterval);
            player.worldMapBattle.autoBattleInterval = null;
        }
        player.worldMapBattle.autoBattleInterval = registerInterval(worldMapAttackMonster, 500);
    }

    // 更新界面显示
    updateBattleUI();
    
    // 显示后台战斗日志（先清空再追加；限制条数避免存档异常时 DOM 过多导致卡顿）
    const logContainer = document.getElementById('addbattleLog');
    logContainer.innerHTML = '';
    const logsToShow = (player.battleLog && Array.isArray(player.battleLog) ? player.battleLog : []).slice(0, 100);
    logsToShow.forEach(log => {
        const logElement = document.createElement('div');
        logElement.textContent = typeof log === 'string' ? log : (log && log.message) || String(log);
        logContainer.appendChild(logElement);
    });
    
    // 滚动到底部
    logContainer.scrollTop = logContainer.scrollHeight;
}
// 车辆品牌配置
const vehicleBrands = [
    { id: 1, name: "大众", models: ["Polo", "Golf", "Passat"], rarity: 1 },
    { id: 2, name: "丰田", models: ["卡罗拉", "凯美瑞", "RAV4"], rarity: 2 },
    { id: 3, name: "本田", models: ["思域", "雅阁", "CR-V"], rarity: 3 },
    { id: 4, name: "福特", models: ["福克斯", "蒙迪欧", "探险者"], rarity: 4 },
    { id: 5, name: "日产", models: ["轩逸", "天籁", "奇骏"], rarity: 5 },
    { id: 6, name: "现代", models: ["伊兰特", "索纳塔", "途胜"], rarity: 6 },
    { id: 7, name: "宝马", models: ["3系", "5系", "X5"], rarity: 7 },
    { id: 8, name: "奔驰", models: ["C级", "E级", "GLC"], rarity: 8 },
    { id: 9, name: "奥迪", models: ["A4", "A6", "Q5"], rarity: 9 },
    { id: 10, name: "雷克萨斯", models: ["ES", "RX", "NX"], rarity: 10 },
    { id: 11, name: "沃尔沃", models: ["S60", "S90", "XC60"], rarity: 11 },
    { id: 12, name: "凯迪拉克", models: ["CT5", "XT5", "Escalade"], rarity: 12 },
    { id: 13, name: "保时捷", models: ["911", "Cayenne", "Panamera"], rarity: 13 },
    { id: 14, name: "玛莎拉蒂", models: ["Ghibli", "Levante", "Quattroporte"], rarity: 14 },
    { id: 15, name: "法拉利", models: ["Portofino", "Roma", "SF90"], rarity: 15 },
    { id: 16, name: "兰博基尼", models: ["Huracan", "Aventador", "Urus"], rarity: 16 },
    { id: 17, name: "宾利", models: ["飞驰", "添越", "欧陆"], rarity: 17 },
    { id: 18, name: "劳斯莱斯", models: ["古斯特", "幻影", "库里南"], rarity: 18 },
    { id: 19, name: "迈凯伦", models: ["GT", "720S", "Artura"], rarity: 19 },
    { id: 20, name: "阿斯顿马丁", models: ["DB11", "Vantage", "DBS"], rarity: 20 },
    { id: 21, name: "布加迪", models: ["Chiron", "Divo", "Centodieci"], rarity: 21 },
    { id: 22, name: "柯尼塞格", models: ["Jesko", "Gemera", "Regera"], rarity: 22 },
    { id: 23, name: "帕加尼", models: ["Huayra", "Zonda", "Utopia"], rarity: 23 },
    { id: 24, name: "世爵", models: ["C8", "D12", "B6"], rarity: 24 },
    { id: 25, name: "威兹曼", models: ["GT", "Roadster", "MF5"], rarity: 25 },
    { id: 26, name: "西尔贝", models: ["Tuatara", "Aero", "Ultimate"], rarity: 26 },
    { id: 27, name: "轩尼诗", models: ["Venom F5", "Venom GT", "Exorcist"], rarity: 27 },
    { id: 28, name: "里马克", models: ["C_Two", "Concept_One", "Nevera"], rarity: 28 },
    { id: 29, name: "阿波罗", models: ["IE", "Intensa", "Project Evo"], rarity: 29 },
    { id: 30, name: "Zenvo", models: ["TSR-S", "ST1", "TS1"], rarity: 30 },
    { id: 31, name: "锐马克", models: ["Nevera", "C_Two", "Concept Two"], rarity: 31 },
    { id: 32, name: "宾尼法利纳", models: ["Battista", "PF0", "PF1"], rarity: 32 },
    { id: 33, name: "克钦格", models: ["21C", "22C", "23C"], rarity: 33 },
    { id: 34, name: "SCG", models: ["007 LMH", "008 Stradale", "009 Hypercar"], rarity: 34 },
    { id: 35, name: "唐克沃特", models: ["D8 GTO", "D8 GT", "D8 Spider"], rarity: 35 },
    { id: 36, name: "凡克", models: ["Shield", "P60", "S1"], rarity: 36 },
    { id: 37, name: "梅尔库斯", models: ["RS2000", "RS3000", "RS4000"], rarity: 37 },
    { id: 38, name: "德托马索", models: ["P72", "Valerio", "Mangusta"], rarity: 38 },
    { id: 39, name: "向量", models: ["WX-8", "WX-12", "V12 Supercharged"], rarity: 39 },
    { id: 40, name: "帕诺兹", models: ["Evviva", "Abruzzi", "Roadster"], rarity: 40 },
    { id: 41, name: "阿尔派", models: ["A110 Stradale", "A110 GT", "A110 S"], rarity: 41 },
    { id: 42, name: "路特斯", models: ["Evija", "Emira", "Elise"], rarity: 42 },
    { id: 43, name: "赫尔姆", models: ["Fury", "GT", "Spider"], rarity: 43 },
    { id: 44, name: "泰格鲁斯·腾风", models: ["GT96 T Revival", "AT96 T", "GT96 T Electric"], rarity: 44 },
    { id: 45, name: "Vencer", models: ["Shield", "P60", "S1"], rarity: 45 },
    { id: 46, name: "比扎里尼", models: ["5000 GT", "Strada", "P538"], rarity: 46 },
    { id: 47, name: "BAC Mono", models: ["Mono", "Mono R", "Mono X"], rarity: 47 },
    { id: 48, name: "Panoz", models: ["Evviva", "Abruzzi", "Roadster"], rarity: 48 },
    { id: 49, name: "Fisker", models: ["Pearl", "Ronin", "Force E"], rarity: 49 },
    { id: 50, name: "Koenigsegg", models: ["Jesko Absolut", "Gemera", "Regera"], rarity: 50 }
];

// 初始化玩家停车位数据
function initParkingData() {
    if (!player.parking) {
        player.parking = {
            level: 1,
            exp: 0,
            maxSpots: 1,
            vehicles: [],
            parkedVehicles: [],
            lastUpdate: Date.now(),
            totalIncome: 0
        };
    }
}

// 切换停车位系统界面
function toggleParkingSystem() {
   if (player.reincarnationCount < 200) {
        alert("需要达到200转才能开启停车场系统！");
        return;
    }
    const ui = document.getElementById('parkingSystemUI');
    const overlay = document.getElementById('parkingSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initParkingData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateParkingUI();
    }
}

function closeParkingSystem() {
    document.getElementById('parkingSystemUI').style.display = 'none';
    document.getElementById('parkingSystemOverlay').style.display = 'none';
}

// 更新停车位界面
function updateParkingUI() {
    // 更新基本信息
    document.getElementById('parkingLevel').textContent = player.parking.level;
    document.getElementById('parkingSpotCount').textContent = player.parking.parkedVehicles.length;
    document.getElementById('maxParkingSpots').textContent = player.parking.maxSpots;
    document.getElementById('parkingExp').textContent = player.parking.exp.toFixed(1);
    document.getElementById('nextLevelExp').textContent = getNextLevelExpq();
    document.getElementById('totalParkingIncome').textContent = player.parking.totalIncome.toExponential(1);
    
    // 更新车辆列表
    updateVehicleList();
    
    // 更新停车位显示
    updateParkingSpots();
    
    // 更新分解界面
    updateDecomposeUI();
}

// 获取下一级所需经验
function getNextLevelExpq() {
    const expRequirements = [100, 200, 300, 400, 600, 800, 1000, 1300, 1700, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 15000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000, 125000, 150000, 200000, 400000, 600000, 800000, 1000000, 2500000, 5000000, 10000000, 100000000];
    const currentLevel = Math.min(player.parking.level, expRequirements.length);
    return expRequirements[currentLevel - 1];
}

// 更新车辆列表
function updateVehicleList() {
    const container = document.getElementById('vehicleList');
    container.innerHTML = '';
    
    player.parking.vehicles.forEach((vehicle, index) => {
        const vehicleCard = document.createElement('div');
        vehicleCard.className = 'vehicle-card';
        vehicleCard.style.background = '#444';
        vehicleCard.style.padding = '10px';
        vehicleCard.style.borderRadius = '5px';
        vehicleCard.style.textAlign = 'center';
        vehicleCard.style.cursor = 'pointer';
        vehicleCard.dataset.index = index;
        
        // 根据稀有度设置边框颜色
        const rarityColor = getRarityColorq(vehicle.rarity);
        vehicleCard.style.border = `2px solid ${rarityColor}`;
        
        vehicleCard.innerHTML = `
            <div style="font-weight: bold; color: ${rarityColor}">${vehicle.brand}</div>
            <div>${vehicle.model}</div>
            <div style="font-size: 0.8em; margin-top: 5px;">稀有度: ${vehicle.rarity}</div>
        `;
        
        // 点击车辆进行停车操作
        vehicleCard.onclick = function() {
            parkVehicle(index);
        };
        
        container.appendChild(vehicleCard);
    });
}

// 根据稀有度获取颜色
function getRarityColorq(rarity) {
    if (rarity <= 5) return '#1E90FF'; // 普通 - 蓝色
    if (rarity <= 10) return '#32CD32'; // 稀有 - 绿色
    if (rarity <= 15) return '#FFD700'; // 史诗 - 金色
    if (rarity <= 20) return '#9370DB'; // 传说 - 紫色
    if (rarity <= 25) return '#013220'; // 传说 - 紫色
    if (rarity <= 30) return '#8a2be2'; // 传说 - 紫色
    if (rarity <= 35) return '#FF1493'; // 传说 - 紫色
    if (rarity <= 45) return '#FF4500'; // 神话 - 橙色
    return '#f44336'; // 至尊 - 粉色
}

// 更新停车位显示
function updateParkingSpots() {
    const container = document.getElementById('parkingSpotsContainer');
    container.innerHTML = '';
    
    // 创建停车位卡片
    for (let i = 0; i < player.parking.maxSpots; i++) {
        const spotCard = document.createElement('div');
        spotCard.className = 'parking-spot';
        spotCard.style.border = '1px solid #ddd';
        spotCard.style.padding = '10px';
        spotCard.style.borderRadius = '5px';
        spotCard.style.textAlign = 'center';
        
        if (i < player.parking.parkedVehicles.length) {
            const vehicle = player.parking.parkedVehicles[i];
         const rarityColor = getRarityColorq(vehicle.rarity);
            spotCard.innerHTML = `
               <div style="font-weight: bold; color: ${rarityColor}">${vehicle.brand}</div>
                <div>${vehicle.model}</div>
                <div>收益: ${calculateParkingIncome(vehicle)} 转生币</div>
                <div>经验: ${calculateParkingIncome(vehicle) / 10000} 经验值</div>
                <button onclick="unparkVehicle(${i})" style="margin-top: 10px; background: #ff9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">卸下</button>
            `;
        } else {
            spotCard.innerHTML = '<div>空闲车位</div>';
        }
        
        container.appendChild(spotCard);
    }
}
function unparkVehicle(spotIndex) {
    if (spotIndex >= player.parking.parkedVehicles.length) return;
    
    // 获取车辆信息
    const vehicle = player.parking.parkedVehicles[spotIndex];
    
    // 将车辆移回车辆列表
    player.parking.vehicles.push(vehicle);
    
    // 从停车位移除
    player.parking.parkedVehicles.splice(spotIndex, 1);
    
    // 计算并收取收益
    const income = calculateParkingIncome(vehicle);
    player.reincarnationCoin += income;
    player.parking.totalIncome += income;
    player.parking.exp += income / 10000;
    logAction(`卸下车辆: ${vehicle.brand} ${vehicle.model}, 获得收益 ${income} 转生币`, 'success');
    updateParkingUI();
    
    // 更新显示
    updateParkingDisplay();
    updateDisplay();
    checkTitleUnlocks();
    saveGame();
}

// 计算停车收益
function calculateParkingIncome(vehicle) {
    // 收益 = 车辆稀有度 * 停车时间(小时)
    const hoursParked = (Date.now() - vehicle.parkTime) / (100 * 60 * 60);
    return Math.floor(vehicle.rarity * hoursParked) * 1000;
}

// 停车操作
function parkVehicle(vehicleIndex) {
    // 检查是否有空闲车位
    if (player.parking.parkedVehicles.length >= player.parking.maxSpots) {
        logAction("没有空闲车位了！", "error");
        return;
    }
    
    const vehicle = player.parking.vehicles[vehicleIndex];
    
    // 将车辆移动到停车位
    player.parking.parkedVehicles.push({
        ...vehicle,
        parkTime: Date.now()
    });
    
    // 从车辆列表中移除
    player.parking.vehicles.splice(vehicleIndex, 1);
    
    logAction(`已将 ${vehicle.brand} ${vehicle.model} 停入车位`, "success");
    updateParkingUI();
    saveGame();
}

// 一键停车
function parkAllVehicles() {
    // 计算可停车数量
    const availableSpots = player.parking.maxSpots - player.parking.parkedVehicles.length;
    const vehiclesToPark = Math.min(availableSpots, player.parking.vehicles.length);
    
    if (vehiclesToPark === 0) {
        logAction("没有可停车的车辆或没有空闲车位", "info");
        return;
    }
    
    // 停车操作
    for (let i = 0; i < vehiclesToPark; i++) {
        const vehicle = player.parking.vehicles[0];
        player.parking.parkedVehicles.push({
            ...vehicle,
            parkTime: Date.now()
        });
        player.parking.vehicles.shift();
    }
    
    logAction(`已自动停放 ${vehiclesToPark} 辆车辆`, "success");
    updateParkingUI();
    saveGame();
}

// 收取单个车位收益
function collectParkingIncome(spotIndex) {
    const vehicle = player.parking.parkedVehicles[spotIndex];
    const income = calculateParkingIncome(vehicle);
    
    // 添加收益
    player.reincarnationCoin += income;
    player.parking.totalIncome += income;
    
    // 添加停车经验
    player.parking.exp += income / 10000;
    
    // 重置停车时间
    vehicle.parkTime = Date.now();
    
    logAction(`收取了 ${vehicle.brand} ${vehicle.model} 的停车收益: ${income} 转生币`, "success");
    updateParkingUI();
    updateDisplay();
    saveGame();
}

// 收取所有收益
function collectAllParkingIncome() {
    let totalIncome = 0;
    
    player.parking.parkedVehicles.forEach(vehicle => {
        const income = calculateParkingIncome(vehicle);
        totalIncome += income;
        
        // 添加停车经验
        player.parking.exp += income / 10000;
        
        // 重置停车时间
        vehicle.parkTime = Date.now();
    });
    
    // 添加收益
    player.reincarnationCoin += totalIncome;
    player.parking.totalIncome += totalIncome;
    
    logAction(`收取了所有停车收益: ${totalIncome} 转生币`, "success");
    updateParkingUI();
    updateDisplay();
   checkTitleUnlocks();
    saveGame();
}

// 按稀有度批量选择车辆
function selectByRarity(maxRarity) {
    player.parking.vehicles.forEach((vehicle, index) => {
        const checkbox = document.getElementById(`vehicleCheckbox${index}`);
        if (checkbox) {
            checkbox.checked = vehicle.rarity <= maxRarity;
        }
    });
    logAction(`已选择稀有度${maxRarity}及以下的车辆`, "info");
}

// 全选车辆
function selectAllVehicles() {
    player.parking.vehicles.forEach((vehicle, index) => {
        const checkbox = document.getElementById(`vehicleCheckbox${index}`);
        if (checkbox) {
            checkbox.checked = true;
        }
    });
    logAction("已选择所有车辆", "info");
}

// 取消全选
function deselectAllVehicles() {
    player.parking.vehicles.forEach((vehicle, index) => {
        const checkbox = document.getElementById(`vehicleCheckbox${index}`);
        if (checkbox) {
            checkbox.checked = false;
        }
    });
    logAction("已取消选择所有车辆", "info");
}

// 修改更新分解界面的函数，确保每个车辆都有唯一的checkbox ID
function updateDecomposeUI() {
    const container = document.getElementById('decomposeVehicleContainer');
    container.innerHTML = '';
    
    if (player.parking.vehicles.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">车库中没有可分解的车辆</div>';
        return;
    }
    
    // 添加车库中的车辆
    player.parking.vehicles.forEach((vehicle, index) => {
        const vehicleDiv = document.createElement('div');
        vehicleDiv.className = 'decompose-vehicle-item';
        vehicleDiv.style.display = 'flex';
        vehicleDiv.style.alignItems = 'center';
        vehicleDiv.style.justifyContent = 'space-between';
        vehicleDiv.style.marginBottom = '10px';
        vehicleDiv.style.padding = '10px';
        vehicleDiv.style.background = '#444';
        vehicleDiv.style.borderRadius = '5px';
        vehicleDiv.style.border = `2px solid ${getRarityColorq(vehicle.rarity)}`;
        
        const rarityColor = getRarityColorq(vehicle.rarity);
        const decomposeValue = vehicle.rarity * 10000;
        
        vehicleDiv.innerHTML = `
            <div style="display: flex; align-items: center; flex: 1;">
                <input type="checkbox" id="vehicleCheckbox${index}" 
                       style="margin-right: 10px; width: 16px; height: 16px;">
                <div style="flex: 1;">
                    <div style="font-weight: bold; color: ${rarityColor}; font-size: 14px;">
                        ${vehicle.brand} ${vehicle.model}
                    </div>
                    <div style="font-size: 12px; color: #ccc;">
                        稀有度: <span style="color: ${rarityColor};">${vehicle.rarity}</span>
                    </div>
                </div>
            </div>
            <div style="text-align: right;">
                <div style="font-size: 12px; color: #FFD700;">
                    价值: ${decomposeValue.toLocaleString()}
                </div>
                <div style="font-size: 10px; color: #888;">
                    转生币
                </div>
            </div>
        `;
        
        container.appendChild(vehicleDiv);
    });
}

// 修改分解选中车辆函数，增加确认对话框
function decomposeSelectedVehicle() {
    const vehiclesToDecompose = [];
    
    // 收集选中的车辆
    player.parking.vehicles.forEach((vehicle, index) => {
        const checkbox = document.getElementById(`vehicleCheckbox${index}`);
        if (checkbox && checkbox.checked) {
            vehiclesToDecompose.push({
                index,
                vehicle
            });
        }
    });
    
    if (vehiclesToDecompose.length === 0) {
        logAction("请选择要分解的车辆", "error");
        return;
    }
    
    // 计算总收益和显示信息
    let totalValue = 0;
    let vehicleList = "";
    
    vehiclesToDecompose.forEach(item => {
        totalValue += item.vehicle.rarity * 10000;
        vehicleList += `\n${item.vehicle.brand} ${item.vehicle.model} (稀有度${item.vehicle.rarity})`;
    });
    
    // 显示确认对话框
    showCustomConfirm(
        `确定要分解以下 ${vehiclesToDecompose.length} 辆车辆吗？${vehicleList}\n\n总计可获得: ${totalValue.toLocaleString()} 转生币`,
        (confirmed) => {
            if (confirmed) {
                // 从高索引到低索引删除，避免索引变化问题
                vehiclesToDecompose.sort((a, b) => b.index - a.index);
                vehiclesToDecompose.forEach(item => {
                    player.parking.vehicles.splice(item.index, 1);
                });
                
                // 添加收益
                player.reincarnationCoin += totalValue;
                
                logAction(`分解了 ${vehiclesToDecompose.length} 辆车辆，获得 ${totalValue.toLocaleString()} 转生币`, "success");
                updateParkingUI();
                updateDisplay();
                saveGame();
            }
        }
    );
}

// 升级停车位
function upgradeParking() {
    const requiredExp = getNextLevelExpq();
    
    if (player.parking.exp < requiredExp) {
        logAction(`经验不足！需要 ${requiredExp} 经验`, "error");
        return;
    }
    
    // 扣除经验
    player.parking.exp -= requiredExp;
    
    // 升级
    player.parking.level++;
    player.parking.maxSpots++;
    
    logAction(`停车位升级到 ${player.parking.level} 级！最大车位增加到 ${player.parking.maxSpots}`, "success");
    updateParkingUI();
    saveGame();
}
// 在农场收获时获得车辆
function onFarmHarvest() {
 if (Math.random() < 0.2) {
        // 根据品阶设置掉落概率
        const rand = Math.random();
        let rarityRange;
        
        if (rand < 0.70) {
            rarityRange = [1, 7];
        } else if (rand < 0.88) {
            rarityRange = [8, 14];
        } else if (rand < 0.96) {
           rarityRange = [15, 22];
            } else if (rand < 0.99) {
           rarityRange = [23, 30];
        } else if (rand < 0.998) {
            rarityRange = [31, 38];
        } else if (rand < 0.9999) {
            rarityRange = [39, 44];
        } else {
            rarityRange = [45, 50];
        }
        
        // 在指定品阶范围内筛选符合条件的车辆
        const eligibleBrands = vehicleBrands.filter(brand => 
            brand.rarity >= rarityRange[0] && brand.rarity <= rarityRange[1]
        );
        
        if (eligibleBrands.length > 0) {
            // 随机选择一个品牌
            const brand = eligibleBrands[Math.floor(Math.random() * eligibleBrands.length)];
            
            // 随机选择型号
            const model = brand.models[Math.floor(Math.random() * brand.models.length)];
            
            // 创建车辆对象
            const newVehicle = {
                id: 'vehicle_' + Date.now(),
                brand: brand.name,
                model: model,
                rarity: brand.rarity,
                parkTime: 0,
                income: 0
            };
            
            // 添加到车辆列表
            player.parking.vehicles.push(newVehicle);
            
            // 记录日志
            logAction(`收获时获得了一辆${brand.name} ${model}（品阶${brand.rarity}）！`, "success");
        }
    }
}
function calculateOfflineParkingIncome() {
    const now = Date.now();
    const elapsed = now - player.parking.lastUpdate;
    
    player.parking.parkedVehicles.forEach(vehicle => {
        const income = vehicle.rarity * (elapsed / (100 * 60 * 60)); // 每小时收益
        player.parking.totalIncome += income;
        player.parking.exp += income / 10000;
    });
    
    player.parking.lastUpdate = now;
}
// 星域探索系统数据
const explorationData = {
    speed: { level: 1, cost: 100 },
    capacity: { level: 1, cost: 100 },
    durability: { level: 1, cost: 100 },
    resources: {
        stardust: 0,
        darkMatter: 0,
        cosmicCrystal: 0,
        artifactFragment: 0
    },
    activeMission: null,
    missionEndTime: 0,
    logs: []
};

/** 从存档对象恢复星域探索数据到全局 explorationData（用于加载/导入后避免舰队属性变1级）；loadSave 可能早于 explorationData 定义执行，用 try-catch 避免 TDZ 报错 */
function restoreExplorationDataFromSave(save) {
    try {
        var exp = (save && save.exploration) ? save.exploration : save;
        if (!exp || typeof exp !== 'object') return;
        if (exp.speed && typeof exp.speed.level === 'number') {
            explorationData.speed.level = exp.speed.level;
            if (typeof exp.speed.cost === 'number') explorationData.speed.cost = exp.speed.cost;
        }
        if (exp.capacity && typeof exp.capacity.level === 'number') {
            explorationData.capacity.level = exp.capacity.level;
            if (typeof exp.capacity.cost === 'number') explorationData.capacity.cost = exp.capacity.cost;
        }
        if (exp.durability && typeof exp.durability.level === 'number') {
            explorationData.durability.level = exp.durability.level;
            if (typeof exp.durability.cost === 'number') explorationData.durability.cost = exp.durability.cost;
        }
        if (exp.resources && typeof exp.resources === 'object') {
            if (typeof exp.resources.stardust === 'number') explorationData.resources.stardust = exp.resources.stardust;
            if (typeof exp.resources.darkMatter === 'number') explorationData.resources.darkMatter = exp.resources.darkMatter;
            if (typeof exp.resources.cosmicCrystal === 'number') explorationData.resources.cosmicCrystal = exp.resources.cosmicCrystal;
            if (typeof exp.resources.artifactFragment === 'number') explorationData.resources.artifactFragment = exp.resources.artifactFragment;
        }
        explorationData.activeMission = exp.activeMission ?? null;
        explorationData.missionEndTime = exp.missionEndTime ?? 0;
        if (Array.isArray(exp.logs)) explorationData.logs = exp.logs;
    } catch (e) {
        /* explorationData 尚未初始化时跳过恢复，避免存档加载失败 */
    }
}

// 任务配置
const missions = {
    easy: {
        name: "近地星域",
        time: 120, // 分钟
        rewards: {
            stardust: { min: 1, max: 15 },
            darkMatter: { min: 1, max: 15 }
        },
        damageRisk: 50
    },
    medium: {
        name: "深空星域",
        time: 180,
        rewards: { 
            stardust: { min: 1, max: 25 },
            darkMatter: { min: 1, max: 30 },
             cosmicCrystal: { min: 1, max: 20 }
        },
        damageRisk: 60
    },
    hard: {
        name: "黑洞边缘",
        time: 240,
        rewards: {
            stardust: { min: 1, max: 50 },
            darkMatter: { min: 1, max: 50 },
            cosmicCrystal: { min: 1, max: 50 }
        },
        damageRisk: 70
    },
    extreme: {
        name: "宇宙边缘",
        time: 360,
        rewards: {
            cosmicCrystal: { min: 1, max: 50 },
            artifactFragment: { min: 1, max: 50 }
        },
        damageRisk: 80
    }
};

// 切换探索系统界面
function toggleExplorationSystem() {
    if (player.reincarnationCount < 300) {
        alert("需要达到300转才能开启星域探索！");
        return;
    }
    const ui = document.getElementById('explorationSystemUI');
    const overlay = document.getElementById('explorationSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateExplorationUI();
    }
}

// 更新探索系统界面
function updateExplorationUI() {
    // 更新资源仓库显示
    document.getElementById('speedLevel').textContent = explorationData.speed.level;
    document.getElementById('capacityLevel').textContent = explorationData.capacity.level;
    document.getElementById('durabilityLevel').textContent = explorationData.durability.level;
    
    // 计算属性效果
    const speedEffect = 60 - (explorationData.speed.level - 1) * 5;
    const capacityEffect = 100 + (explorationData.capacity.level - 1) * 20;
    const durabilityEffect = 5 + (explorationData.durability.level - 1) * 2;
    const damageReduction = 10 - (explorationData.durability.level - 1) * 1;
    
    document.getElementById('explorationTime').textContent = Math.max(10, speedEffect);
    document.getElementById('resourceGain').textContent = capacityEffect + '%';
    document.getElementById('rareRate').textContent = durabilityEffect + '%';
    document.getElementById('damageRate').textContent = Math.max(1, damageReduction) + '%';
    
    // 更新资源显示
    document.getElementById('stardustCount').textContent = explorationData.resources.stardust || 0;
    document.getElementById('darkMatterCount').textContent = explorationData.resources.darkMatter || 0;
    document.getElementById('cosmicCrystalCount').textContent = explorationData.resources.cosmicCrystal || 0;
    document.getElementById('artifactFragmentCount').textContent = explorationData.resources.artifactFragment || 0;
    
    // 更新任务按钮状态
    const missionButtons = document.querySelectorAll('.start-mission-btn');
    missionButtons.forEach(button => {
        if (explorationData.activeMission) {
            button.disabled = true;
            button.textContent = "任务进行中";
        } else {
            button.disabled = false;
            button.textContent = "开始探索";
        }
    });
    
    // 更新任务时间显示（应用速度加成）- 修复部分
    const missionCards = document.querySelectorAll('.mission-card');
    missionCards.forEach(card => {
        const difficulty = card.getAttribute('data-difficulty');
         // 添加安全检查
        if (!missions[difficulty]) {
            console.error("未找到任务配置:", difficulty);
            return; // 跳过这个卡片
        }
   
        
        const mission = missions[difficulty];
        const baseTime = mission.time;
        const actualTime = Math.max(10, baseTime - (explorationData.speed.level - 1) * 5);
        card.querySelector('.mission-time').textContent = actualTime + "分钟";
        
        // 应用耐久加成后的损坏率
        const baseRisk = mission.damageRisk;
        const actualRisk = Math.max(1, baseRisk - (explorationData.durability.level - 1));
        card.querySelector('.damage-risk').textContent = actualRisk + "%";
    });
    
    // 更新属性升级按钮的显示
    const attributes = ['speed', 'capacity', 'durability'];
    attributes.forEach(attr => {
        const btn = document.querySelector(`.upgrade-btn[data-attr="${attr}"]`);
        if (btn) {
            const cost = explorationData[attr].cost;
            btn.textContent = `升级 (${formatNumber(cost)}转生币)`;
            btn.disabled = player.reincarnationCoin < cost;
        }
    });

    // 更新日志
    updateExplorationLog();
    
    // 如果有进行中的任务，显示倒计时
    if (explorationData.activeMission) {
        const remaining = Math.max(0, explorationData.missionEndTime - Date.now());
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        
        addLog(`任务进行中: ${missions[explorationData.activeMission]?.name || '未知任务'} - 剩余: ${minutes}分${seconds}秒`);
        
        if (remaining <= 0) {
            completeMission();
        }
    }
}

// 升级属性
function upgradeAttribute(attribute) {
    const cost = explorationData[attribute].cost;
    
    if (player.reincarnationCoin >= cost) {
        player.reincarnationCoin -= cost;
        explorationData[attribute].level++;
        explorationData[attribute].cost = Math.floor(cost * 10);
        
        addLog(`${attribute === 'speed' ? '速度' : attribute === 'capacity' ? '容量' : '耐久'}升级到 ${explorationData[attribute].level}级`);
        updateExplorationUI();
        logAction(`星域探索: ${attribute}升级成功`, 'success');
    } else {
        logAction(`转生币不足！需要${formatNumber(cost)}转生币`, "error");
    }
}

// 一键升级全部属性
function upgradeAllAttributes() {
    const attributes = ['speed', 'capacity', 'durability'];
    let upgraded = false;
    
    attributes.forEach(attr => {
        while (player.reincarnationCoin >= explorationData[attr].cost) {
            const cost = explorationData[attr].cost;
            player.reincarnationCoin -= cost;
            explorationData[attr].level++;
            explorationData[attr].cost = Math.floor(cost * 10);
            upgraded = true;
        }
    });
    
    if (upgraded) {
        addLog("一键升级全部属性成功");
        updateExplorationUI();
        logAction("星域探索: 一键升级成功", 'success');
    } else {
        // 显示具体缺少的转生币数量
        const costs = attributes.map(attr => explorationData[attr].cost);
        const minCost = Math.min(...costs);
        logAction(`转生币不足，至少需要${formatNumber(minCost)}转生币才能升级任一属性`, "error");
    }
}

// 开始任务
function startMission(difficulty) {
    if (explorationData.activeMission) {
        logAction("已有任务进行中", "error");
        return;
    }
    
    // 计算实际任务时间（应用速度加成）
    const baseTime = missions[difficulty].time;
    const actualTime = Math.max(10, baseTime - (explorationData.speed.level - 1) * 5) * 60000;
    
    explorationData.activeMission = difficulty;
    explorationData.missionEndTime = Date.now() + actualTime;
    
    addLog(`开始探索: ${missions[difficulty].name} - 预计完成时间: ${new Date(explorationData.missionEndTime).toLocaleTimeString()}`);
    updateExplorationUI();
    
    // 设置任务完成检查
    setTimeout(completeMission, actualTime);
    
    // 立即保存游戏
    saveGame();
}

// 完成任务
function completeMission() {
    if (!explorationData.activeMission) return;
    
    const mission = missions[explorationData.activeMission];
    const difficulty = explorationData.activeMission;
    
    // 计算实际损坏率（应用耐久加成）
    const baseRisk = mission.damageRisk;
    const actualRisk = Math.max(1, baseRisk - (explorationData.durability.level - 1));
    
    // 检查是否发生损坏
    let damaged = false;
    if (Math.random() * 100 < actualRisk) {
        damaged = true;
        addLog(`任务完成，但舰队受到损坏！`);
    } else {
        addLog(`任务成功完成: ${mission.name}`);
    }
    
    // 计算资源获取（应用容量加成）
    const capacityMultiplier = 1 + (explorationData.capacity.level - 1) * 0.2;
    
    // 发放发票奖励（不再是直接发放资源）
    let rewards = "";
    for (const resource in mission.rewards) {
        const min = mission.rewards[resource].min;
        const max = mission.rewards[resource].max;
        let amount = Math.floor((Math.random() * (max - min + 1) + min) * capacityMultiplier);
    
        if (damaged) {
            amount = Math.floor(amount * 0.2); // 损坏时奖励减半
        }
        
        // 根据资源类型确定对应的发票类型
        let ticketType;
        switch(resource) {
            case 'stardust':
                ticketType = 'yuzhou1';
                break;
            case 'darkMatter':
                ticketType = 'yuzhou2';
                break;
            case 'cosmicCrystal':
                ticketType = 'yuzhou3';
                break;
            case 'artifactFragment':
                ticketType = 'yuzhou4';
                break;
            default:
                ticketType = null;
        }
        
        if (ticketType) {
            // 将发票数量加到player.items中
            player.items[ticketType] = (player.items[ticketType] || 0) + amount;
            rewards += `${getTicketName(ticketType)}: ${amount} `;
        }
    }
    
    addLog(`获得奖励: ${rewards}`);
    
    // 重置任务状态
    explorationData.activeMission = null;
    explorationData.missionEndTime = 0;
    
    updateExplorationUI();
    saveGame();
}

// 获取发票名称
function getTicketName(ticketType) {
    const names = {
        'yuzhou1': '星尘发票',
        'yuzhou2': '暗物质发票',
        'yuzhou3': '宇宙晶体发票',
        'yuzhou4': '神器碎片发票'
    };
    return names[ticketType] || ticketType;
}

// 添加日志
function addLog(message) {
    const timestamp = new Date().toLocaleTimeString();
    explorationData.logs.unshift(`[${timestamp}] ${message}`);
    
    if (explorationData.logs.length > 20) {
        explorationData.logs.pop();
    }
    
    updateExplorationLog();
}

// 更新日志显示
function updateExplorationLog() {
    const logContainer = document.getElementById('explorationLog');
    logContainer.innerHTML = explorationData.logs.map(log => 
        `<div class="log-entry">${log}</div>`
    ).join('');
}

/** loadSave 可能早于 explorationData 定义执行，用 try-catch 避免 TDZ 报错 */
function initExplorationSystem() {
    try {
        explorationData.speed = explorationData.speed || { level: 1, cost: 100 };
        explorationData.capacity = explorationData.capacity || { level: 1, cost: 100 };
        explorationData.durability = explorationData.durability || { level: 1, cost: 100 };
        explorationData.resources = explorationData.resources || {
            stardust: 0,
            darkMatter: 0,
            cosmicCrystal: 0,
            artifactFragment: 0
        };
        explorationData.activeMission = explorationData.activeMission || null;
        explorationData.missionEndTime = explorationData.missionEndTime || 0;
        explorationData.logs = explorationData.logs || [];
        
        if (explorationData.activeMission && explorationData.missionEndTime > Date.now()) {
            var remaining = explorationData.missionEndTime - Date.now();
            setTimeout(completeMission, remaining);
            if (typeof addLog === 'function') addLog('恢复进行中的探索任务: ' + (missions[explorationData.activeMission] && missions[explorationData.activeMission].name) + ' - 剩余时间: ' + Math.floor(remaining/60000) + '分钟');
        } else if (explorationData.activeMission && explorationData.missionEndTime <= Date.now()) {
            completeMission();
        }
    } catch (e) {
        /* explorationData 尚未初始化时跳过，避免存档加载失败 */
    }
}
// 切换兑换商店显示
function toggleExchangeShop() {
    if (player.reincarnationCount < 300) {

        alert("需要达到300转才能开启星域探索！");

        return;

    }
    const overlay = document.getElementById('exchangeShopOverlay');
    const ui = document.getElementById('exchangeShopUI');
    
    if (ui.style.display === 'none') {
        // 打开商店时更新显示
        updateExchangeDisplay();
        overlay.style.display = 'block';
        ui.style.display = 'block';
    } else {
        overlay.style.display = 'none';
        ui.style.display = 'none';
    }
}

// 更新兑换商店显示
function updateExchangeDisplay() {
    // 更新资源数量
    document.getElementById('currentStardustExchange').textContent = player.exploration.resources.stardust;
    document.getElementById('currentDarkMatterExchange').textContent = player.exploration.resources.darkMatter;
    document.getElementById('currentCosmicCrystalExchange').textContent = player.exploration.resources.cosmicCrystal;
    document.getElementById('currentArtifactFragmentExchange').textContent = player.exploration.resources.artifactFragment;
    
    // 更新发票数量
    document.getElementById('currentStardustTicket').textContent = player.items.yuzhou1 || 0;
    document.getElementById('currentDarkMatterTicket').textContent = player.items.yuzhou2 || 0;
    document.getElementById('currentCosmicCrystalTicket').textContent = player.items.yuzhou3 || 0;
    document.getElementById('currentArtifactFragmentTicket').textContent = player.items.yuzhou4 || 0;
}

// 资源兑换函数
function exchangeResource(resourceType, direction) {
    // 确定兑换数量和输入框
    let amountInput, amount;
    let ticketType;
    
    switch(resourceType) {
        case 'stardust':
            amountInput = document.getElementById('stardustAmount');
            ticketType = 'yuzhou1';
            break;
        case 'darkMatter':
            amountInput = document.getElementById('darkMatterAmount');
            ticketType = 'yuzhou2';
            break;
        case 'cosmicCrystal':
            amountInput = document.getElementById('cosmicCrystalAmount');
            ticketType = 'yuzhou3';
            break;
        case 'artifactFragment':
            amountInput = document.getElementById('artifactFragmentAmount');
            ticketType = 'yuzhou4';
            break;
    }
    
    amount = parseInt(amountInput.value);
    if (isNaN(amount) || amount < 1) {
        logAction("请输入有效的兑换数量", "error");
        return;
    }
    
    if (direction === 'toTicket') {
        // 资源兑换发票
        if (player.exploration.resources[resourceType] < amount) {
            logAction(`${getResourceName(resourceType)}不足`, "error");
            return;
        }
        
        player.exploration.resources[resourceType] -= amount;
        player.items[ticketType] = (player.items[ticketType] || 0) + amount;
        
        logAction(`成功将${amount}个${getResourceName(resourceType)}兑换为${amount}张${getTicketName(ticketType)}`, "success");
    } else {
        // 发票兑换资源
        if ((player.items[ticketType] || 0) < amount) {
            logAction(`${getTicketName(ticketType)}不足`, "error");
            return;
        }
        
        player.items[ticketType] -= amount;
        player.exploration.resources[resourceType] += amount;
        
        logAction(`成功将${amount}张${getTicketName(ticketType)}兑换为${amount}个${getResourceName(resourceType)}`, "success");
    }
    
    // 更新显示
    updateExchangeDisplay();
    saveGame();
}

// 获取资源名称
function getResourceName(type) {
    const names = {
        'stardust': '星尘',
        'darkMatter': '暗物质',
        'cosmicCrystal': '宇宙晶体',
        'artifactFragment': '神器碎片'
    };
    return names[type] || type;
}

// 获取发票名称
function getTicketName(type) {
    const names = {
        'yuzhou1': '星尘发票',
        'yuzhou2': '暗物质发票',
        'yuzhou3': '宇宙晶体发票',
        'yuzhou4': '神器碎片发票'
    };
    return names[type] || type;
}
// 神器部位配置
const artifactParts = [
    { id: "helmet", name: "头盔" },
    { id: "clothes", name: "衣服" },
    { id: "pants", name: "裤子" },
    { id: "shoes", name: "鞋子" },
    { id: "necklace", name: "项链" },
    { id: "weapon", name: "武器" }
];

// 神器品质配置
const artifactQualities = [
    { id: "common", name: "普通", color: "#FFFFFF", minBonus: 0.1, maxBonus: 1 },
    { id: "uncommon", name: "精良", color: "#1E90FF", minBonus: 0.5, maxBonus: 5 },
    { id: "rare", name: "稀有", color: "#9B30FF", minBonus: 1, maxBonus: 10 },
    { id: "epic", name: "史诗", color: "#FF4500", minBonus: 2, maxBonus: 20 },
    { id: "legendary", name: "传说", color: "#FFD700", minBonus: 5, maxBonus: 50 },
    { id: "mythic", name: "神话", color: "#FF1493", minBonus: 10, maxBonus: 100 }
];

// 神器套装配置
const artifactSets = [
    {
        name: "青龙套装",
        bonuses: {
            2: { health: 30, description: "生命加成+3000%" },
            4: { attack: 200, description: "攻击加成+20000%" },
            6: { critDamage: 1500, description: "爆伤加成+150000%" }
        }
    },
 {
        name: "新手套装",
        bonuses: {
            2: { health: 2, description: "生命加成+200%" },
            4: { attack: 20, description: "攻击加成+2000%" },
            6: { critDamage: 150, description: "爆伤加成+15000%" }
        }
    },
 {
        name: "废品套装",
        bonuses: {
            2: { health: 1, description: "生命加成+100%" },
            4: { attack: 1, description: "攻击加成+100%" },
            6: { critDamage: 1, description: "爆伤加成+100%" }
        }
},
 {
        name: "闫闫套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { health: 10, description: "生命加成+1000%" },
            6: { health: 10, description: "生命加成+1000%" }
        }
},
 {
        name: "茶茶套装",
        bonuses: {
            2: { attack: 20, description: "攻击加成+2000%" },
            4: { attack: 20, description: "攻击加成+2000%" },
            6: { attack: 20, description: "攻击加成+2000%" }
        }
    },
 {
        name: "幼儿园套装",
        bonuses: {
            2: { health: 2, description: "生命加成+200%" },
            4: { attack: 2, description: "攻击加成+200%" },
            6: { critDamage: 2, description: "爆伤加成+200%" }
        }
    },
 {
        name: "梦想套装",
        bonuses: {
            2: { health: 1, description: "生命加成+100%" },
            4: { attack: 10, description: "攻击加成+1000%" },
            6: { critDamage: 100, description: "爆伤加成+10000%" }
        }
    },
 {
        name: "堕入套装",
        bonuses: {
            2: { attack: 3, description: "攻击加成+300%" },
            4: { attack: 5, description: "攻击加成+500%" },
            6: { critDamage: 80, description: "爆伤加成+8000%" }
        }
    },
 {
        name: "邪恶套装",
        bonuses: {
            2: { critDamage: 2, description: "爆伤加成+200%" },
            4: { critDamage: 10, description: "爆伤加成+1000%" },
            6: { critDamage: 170, description: "爆伤加成+17000%" }
        }
    },
 {
        name: "猎人套装",
        bonuses: {
            2: { health: 2, description: "生命加成+200%" },
            4: { attack: 30, description: "攻击加成+3000%" },
            6: { critDamage: 150, description: "爆伤加成+15000%" }
        }
    },
 {
        name: "死神套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { attack: 500, description: "攻击加成+50000%" },
            6: { attack: 4000, description: "攻击加成+400000%" }
        }
    },
 {
        name: "冥王套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { attack: 300, description: "攻击加成+30000%" },
            6: { critDamage: 3000, description: "爆伤加成+300000%" }
        }
    },
 {
        name: "至尊套装",
        bonuses: {
            2: { attack: 30, description: "攻击加成+3000%" },
            4: { health: 500, description: "生命加成+50000%" },
            6: { critDamage: 1700, description: "爆伤加成+170000%" }
        }
    },
 {
        name: "雷霆套装",
        bonuses: {
            2: { attack: 100, description: "攻击加成+10000%" },
            4: { attack: 550, description: "攻击加成+55000%" },
            6: { critDamage: 1300, description: "爆伤加成+130000%" }
        }
    },
 {
        name: "堕落套装",
        bonuses: {
            2: { health: 5, description: "生命加成+500%" },
            4: { attack: 10, description: "攻击加成+1000%" },
            6: { critDamage: 53, description: "爆伤加成+5300%" }
        }
    },
 {
        name: "神话套装",
        bonuses: {
            2: { health: 22, description: "生命加成+2200%" },
            4: { critDamage: 400, description: "攻击加成+40000%" },
            6: { critDamage: 2000, description: "爆伤加成+200000%" }
        }
    },
 {
        name: "圣光套装",
        bonuses: {
            2: { health: 15, description: "生命加成+1500%" },
            4: { attack: 100, description: "攻击加成+10000%" },
            6: { critDamage: 1300, description: "爆伤加成+130000%" }
        }
    },
 {
        name: "混沌套装",
        bonuses: {
            2: { health: 10, description: "生命加成+1000%" },
            4: { attack: 300, description: "攻击加成+30000%" },
            6: { health: 1500, description: "生命加成+150000%" }
        }
    },
    {
        name: "白虎套装",
        bonuses: {
            2: { attack: 15, description: "攻击加成+1500%" },
            4: { attack: 400, description: "攻击加成+40000%" },
            6: { attack: 1850, description: "攻击加成+185000%" }
        }
    },
    {
        name: "朱雀套装",
        bonuses: {
            2: { critDamage: 20, description: "爆伤加成+2000%" },
            4: { critDamage: 250, description: "爆伤加成+25000%" },
            6: { attack: 1650, description: "攻击加成+165000%" }
        }
    },
    {
        name: "玄武套装",
        bonuses: {
            2: { health: 50, description: "生命加成+5000%" },
            4: { health: 500, description: "生命加成+50000%" },
            6: { health: 1800, description: "生命加成+180000%" }
        }
    },
    {
        name: "麒麟套装",
        bonuses: {
            2: { attack: 50, description: "攻击加成+5000%" },
            4: { attack: 550, description: "攻击加成+55000%" },
            6: { health: 1000, description: "生命加成+100000%" }
        }
    }
];

// 神器名字库
const artifactNames = {
    helmet: ["玄铁战盔", "流光宝冠", "暗影头盔", "烈焰头环", "凤羽冠", "圣光战盔", "疾风头盔", "雷霆战盔", "雷霆战盔", "守护者头盔", "幽魂头罩", "精灵之冠", "矮人战盔", "毒藤头环", "寒冰面甲", "荣耀战盔", "耻辱面甲", "刹那冠冕", "雨龙盔", "龟甲盔", "云龙盔", "饕餮头盔", "虬龙头盔", "青鸾头盔", "火凤头盔", "蛟龙头盔", "龙鳞头盔", "苍龙头盔", "虚无头盔"],
    clothes: ["龙鳞甲", "玄冰法袍", "暗影披风", "圣光铠甲", "大地之袍", "疾风劲装", "藤蔓风衣", "王者披风", "毁灭者战衣", "混沌战甲", "黎明法衣", "黄昏披风", "幽魂长衫", "泰坦铠甲", "矮人战甲", "恶魔披风", "磐石铠甲", "熔岩铠甲", "寒冰法袍", "静谧长衫", "狂怒战甲", "意志披风", "龙纹战甲", "流光战衣", "深渊战甲", "永恒战甲", "信仰战甲", "狂怒长衫", "闫闫内衣"],
    pants: ["星空护腿", "玄铁战裤", "暗影皮裤", "冰晶长裤", "圣光战裤", "幽冥长裤", "疾风短裤", "大地之裤", "藤蔓短裤", "混沌护腿", "雷霆战裤", "藤蔓护腿", "幻影护腿", "守护者护腿", "黎明护腿", "幽魂护腿", "恶魔护腿", "天使护腿", "毒藤护腿", "磐石护腿", "狂怒护腿", "勇气护腿", "雷神护腿", "火神护腿", "暗夜护腿", "星光护腿", "死神护腿", "闫闫黑丝"],
    shoes: ["流光战靴", "烈焰履", "黑麒麟战靴", "神玄武战靴", "邪白虎战靴", "圣朱雀羽靴", "灭世青龙战靴", "赫光圣靴", "疾风战靴", "混沌战靴", "死神战靴", "雷神战靴", "至尊战靴", "剑圣战靴", "剑神战靴", "灭神战靴", "永恒战靴", "火迷战靴", "镭射战靴", "冥王战靴", "仙人神靴", "风暴战靴", "荣耀圣靴", "暗夜神靴", "圣飒战靴", "强韧战靴", "傲世神靴"],
    necklace: ["星空项链", "烈焰项链", "王者项链", "玄德项链", "迪虎项链", "黎明项链", "幽魂项链", "黄昏圣链", "泰坦项链", "恶魔项链", "熔岩吊坠", "寒冰吊坠", "风暴吊坠", "狂怒吊坠", "力量吊坠", "勇气项链", "至尊项链", "荣耀项链", "凤羽项链", "流光项链", "顺神项链", "风日项链", "邪神吊坠", "睡神项链", "水神项链", "敖包吊坠", "死亡项链"],
    weapon: ["万古绝尘剑", "撼天动地斧", "焚天怒焰刀", "惊鸿掠影剑", "血狱幽冥枪", "破界陨星锤", "冰封千里杖", "地狱修罗刀", "九霄龙吟剑", "噬魂夺魄刃", "乾坤逆转戟", "裂地崩山斧", "焚天炽羽弓", "玄冰锁魂镰", "紫电灭魔剑", "血饮狂刀", "雷霆碎岳锤", "万劫不灭矛", "破空穿云箭", "寒霜冻世剑", "炎狱修罗枪", "星河碎影剑", "混沌开天斧", "白虎裂山刃", "炼狱修罗爪", "破天裂穹剑", "轩辕剑", "湛泸剑", "赤霄剑", "泰阿剑", "承影剑", "干将", "莫邪", "鱼肠剑", "无影剑艾雷诺", "破碎之命运", "光炎剑", "泰拉石手枪", "永恒之枪", "潘多拉魔盒", "三叉戟", "方天画戟", "草薙剑", "圣剑格拉墨", "命运之矛", "埃癸斯之盾", "杜蕾斯", "闫闫爱心锤", "茶茶小奶瓶"]
};
const advanceCosts = [5, 10, 20, 40, 80, 160, 320]; // 进阶1-7级所需神石
const advancePrefixes = [
    "", 
    "高·", 
    "超·", 
    "圣·", 
    "仙·", 
    "神·", 
    "荒·", 
    "帝·"
];
// 初始化神器系统
function initArtifactSystem() {
    if (!player.artifacts) {
        player.artifacts = {
            fragments: 0,
            crystals: 0,
            inventory: [],
            equipped: {
                helmet: null,
                clothes: null,
                pants: null,
                shoes: null,
                necklace: null,
                weapon: null
            },
            advanceLevels: {}, // 神器ID -> 进阶等级 (0-7)
            lockedArtifacts: []
        };
    }
    if (!player.artifacts.batchSelection) {
    player.artifacts.batchSelection = {
        selectedIds: [],
        filters: {
            quality: 'all',
            set: 'all',
            part: 'all'
        }
    };
}
    // 修复旧装备初始化问题
    if (!player.artifacts.advanceLevels) {
        player.artifacts.advanceLevels = {};
    }
     player.artifacts.inventory.forEach(artifact => {
        if (artifact.locked === undefined) {
            artifact.locked = false;
        }
    });
    
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact && artifact.locked === undefined) {
            artifact.locked = false;
        }
    });
    // 确保所有神器都有进阶等级
    player.artifacts.inventory.forEach(artifact => {
        if (!player.artifacts.advanceLevels[artifact.id]) {
            player.artifacts.advanceLevels[artifact.id] = 0;
        }
    });
    
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact && !player.artifacts.advanceLevels[artifact.id]) {
            player.artifacts.advanceLevels[artifact.id] = 0;
        }
    });
 player.artifacts.inventory.forEach(artifact => {
        if (!artifact.baseName) {
            artifact.baseName = artifact.name;
        }
    });
    
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact && !artifact.baseName) {
            artifact.baseName = artifact.name;
        }
    });
}
// 切换神器查看标签
function switchArtifactTab(tab) {
    const allTab = document.querySelector('.artifact-tab[onclick="switchArtifactTab(\'all\')"]');
    const setsTab = document.querySelector('.artifact-tab[onclick="switchArtifactTab(\'sets\')"]');
    
    if (tab === 'all') {
        document.getElementById('artifactInventory').style.display = 'grid';
        document.getElementById('artifactSetsView').style.display = 'none';
        allTab.classList.add('active');
        setsTab.classList.remove('active');
    } else {
        document.getElementById('artifactInventory').style.display = 'none';
        document.getElementById('artifactSetsView').style.display = 'block';
        allTab.classList.remove('active');
        setsTab.classList.add('active');
        updateArtifactSetsView();
    }
}

// 更新套装视图
function updateArtifactSetsView() {
    const container = document.getElementById('artifactSetsContainer');
    container.innerHTML = '';
    
    // 按套装分组
    const sets = {};
    player.artifacts.inventory.forEach(artifact => {
        const setName = artifact.set || '无套装';
        if (!sets[setName]) {
            sets[setName] = [];
        }
        sets[setName].push(artifact);
    });
    
    // 创建套装组
    Object.keys(sets).sort().forEach(setName => {
        const artifacts = sets[setName];
        const setGroup = document.createElement('div');
        setGroup.className = 'set-group set-collapsed';
        setGroup.id = `set-group-${setName.replace(/\s+/g, '-')}`;
        
        setGroup.innerHTML = `
            <div class="set-header" onclick="toggleSetGroup('${setName.replace(/\s+/g, '-')}')">
                <div class="set-name">${setName}</div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="set-count">${artifacts.length}件</span>
                    <span class="folder-arrow">▼</span>
                </div>
            </div>
            <div class="set-content">
                ${artifacts.map(artifact => createArtifactCardHTML(artifact)).join('')}
            </div>
        `;
        
        container.appendChild(setGroup);
    });
}

// 切换套装组展开/收起
function toggleSetGroup(setName) {
    const group = document.getElementById(`set-group-${setName}`);
    group.classList.toggle('set-collapsed');
}

// 创建神器卡片HTML（复用原有函数或创建新函数）
function createArtifactCardHTML(artifact) {
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const part = artifactParts.find(p => p.id === artifact.part);
    
    return `
        <div class="artifact-card" style="border: 2px solid ${quality.color};">
            <div style="color: ${quality.color}; font-weight: bold;">${artifact.name}</div>
            <div>${part.name}</div>
            <div style="font-size: 0.8em;">
                <div>等级: ${artifact.upgradeLevel}</div>
                <div>生命: +${(artifact.bonuses.health * 100).toFixed(1)}%</div>
                <div>攻击: +${(artifact.bonuses.attack * 100).toFixed(1)}%</div>
                <div>爆伤: +${(artifact.bonuses.critDamage * 100).toFixed(1)}%</div>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="equipArtifact('${artifact.id}')" style="background: #4CAF50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em; margin-right: 5px;">装备</button>
                <button onclick="showArtifactDetails('${artifact.id}')" style="background: #2196F3; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">详情</button>
               <button onclick="decomposeArtifactItem('${artifact.id}')" style="background: #f44336; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">分解</button>

            </div>
        </div>
    `;
}
// 切换神器系统界面
function toggleArtifactSystem() {
    if (player.reincarnationCount < 500) {
        alert("需要达到500转才能开启神器系统！");
        return;
    }
    const overlay = document.getElementById('artifactSystemOverlay');
    const ui = document.getElementById('artifactSystemUI');


    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initArtifactSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateArtifactUI();
    }
}

// 更新神器系统界面
   function updateArtifactUI() {
   

    
    // 更新装备部位
    updateArtifactSlots();
    
    // 更新神器仓库
    updateArtifactInventory();
    updateFilteredCount(); 
    // 更新套装效果
    updateSetBonuses();
}
function cleanupArtifactAdvanceLevels() {
    if (!player.artifacts || !player.artifacts.advanceLevels) return;
    
    // 获取所有有效的神器ID（仓库中的和装备中的）
    const validArtifactIds = new Set();
    
    // 添加仓库中的神器ID
    player.artifacts.inventory.forEach(artifact => {
        validArtifactIds.add(artifact.id);
    });
    
    // 添加装备中的神器ID
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            validArtifactIds.add(artifact.id);
        }
    });
    
    // 清理无效的进阶等级数据
    const oldCount = Object.keys(player.artifacts.advanceLevels).length;
    
    Object.keys(player.artifacts.advanceLevels).forEach(artifactId => {
        if (!validArtifactIds.has(artifactId)) {
            delete player.artifacts.advanceLevels[artifactId];
        }
    });
    
    const newCount = Object.keys(player.artifacts.advanceLevels).length;
    const removedCount = oldCount - newCount;
    
    if (removedCount > 0) {
        console.log(`清理了 ${removedCount} 个无效的进阶等级记录`);
    }
}
// 更新装备部位显示
function updateArtifactSlots() {
    const slotsContainer = document.getElementById('artifactSlots');
    slotsContainer.innerHTML = '';
    
    artifactParts.forEach(part => {
        const slot = document.createElement('div');
        slot.className = 'artifact-slot';
        slot.style.border = '1px solid #d4af37';
        slot.style.padding = '10px';
        slot.style.borderRadius = '5px';
        slot.style.textAlign = 'center';
        slot.style.backgroundColor = '#222';
        
        const equippedArtifact = player.artifacts.equipped[part.id];
        
        if (equippedArtifact) {
            const quality = artifactQualities.find(q => q.id === equippedArtifact.quality);
            const set = artifactSets.find(s => s.name === equippedArtifact.set);
            
            slot.innerHTML = `
                <div style="color: ${quality.color}; font-weight: bold;">${equippedArtifact.name}</div>
                <div>${part.name}</div>
                <div style="font-size: 0.8em; margin-top: 5px;">
                    <div>等级: ${equippedArtifact.upgradeLevel}</div>
                    <div>套装: <span style="color: #d4af37;">${equippedArtifact.set}</span></div>
                    <div>生命: +${(equippedArtifact.bonuses.health * 100).toFixed(1)}%</div>
                    <div>攻击: +${(equippedArtifact.bonuses.attack * 100).toFixed(1)}%</div>
                    <div>爆伤: +${(equippedArtifact.bonuses.critDamage * 100).toFixed(1)}%</div>
                </div>
                <button onclick="unequipArtifact('${part.id}')" style="margin-top: 10px; background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">卸下</button>
            `;
        } else {
            slot.innerHTML = `
                <div>${part.name}</div>
                <div style="color: #888; font-size: 0.9em; margin-top: 5px;">未装备</div>
            `;
        }
        
        slotsContainer.appendChild(slot);
    });
}

// 更新神器仓库显示
function updateArtifactInventory() {

    const inventoryContainer = document.getElementById('artifactInventory');
    const filterContainer = document.getElementById('artifactFilterUI');
    
    // 先创建筛选界面
    if (!filterContainer) {
        createFilterUI();
    }
    
    // 获取筛选后的神器列表
    const filteredArtifacts = getFilteredArtifacts();
    
    inventoryContainer.innerHTML = '';
    
    if (filteredArtifacts.length === 0) {
        inventoryContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">没有符合条件的神器</div>';
        return;
    }
    
    // 显示批量操作按钮
    inventoryContainer.innerHTML = `
     <div style="grid-column: 1 / -1; margin-bottom: 15px; padding: 10px; background: #333; border-radius: 5px;">
            <strong style="color: #d4af37;">批量操作</strong>
            <button onclick="selectAllArtifacts()" style="margin: 0 5px; padding: 5px 10px;">全选</button>
            <button onclick="deselectAllArtifacts()" style="margin: 0 5px; padding: 5px 10px;">取消全选</button>
            <button onclick="batchLockArtifacts()" style="margin: 0 5px; padding: 5px 10px; background: #FF9800; color: white;">批量锁定选中神器</button>
            <button onclick="batchUnlockArtifacts()" style="margin: 0 5px; padding: 5px 10px; background: #666; color: white;">批量解锁选中神器</button>
            <button onclick="batchDecomposeArtifacts()" style="margin: 0 5px; padding: 5px 10px; background: #f44336; color: white;">批量分解选中神器 (${player.artifacts.batchSelection.selectedIds.length})</button>
            <span style="margin-left: 10px; color: #4CAF50;">选中: ${player.artifacts.batchSelection.selectedIds.length}/${filteredArtifacts.length}</span>
        </div>
    `;
    
    
    // 显示神器卡片
     filteredArtifacts.forEach(artifact => {
        const quality = artifactQualities.find(q => q.id === artifact.quality);
        const part = artifactParts.find(p => p.id === artifact.part);
        const isSelected = player.artifacts.batchSelection.selectedIds.includes(artifact.id);
        const isLocked = artifact.locked;
        
        const artifactCard = document.createElement('div');
        artifactCard.className = 'artifact-card';
        artifactCard.style.border = `2px solid ${isSelected ? '#4CAF50' : (isLocked ? '#FFD700' : quality.color)}`;
        artifactCard.style.padding = '10px';
        artifactCard.style.borderRadius = '5px';
        artifactCard.style.cursor = 'pointer';
        artifactCard.style.backgroundColor = isSelected ? '#2a2a2a' : '#1a1a1a';
        artifactCard.style.position = 'relative';
        artifactCard.onclick = (e) => {
            if (!e.target.closest('button')) {
                toggleArtifactSelection(artifact.id);
            }
        };
        
        // 添加锁定图标
        const lockIcon = isLocked ? '🔒' : '🔓';
        
        artifactCard.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <input type="checkbox" ${isSelected ? 'checked' : ''} 
                       onchange="toggleArtifactSelection('${artifact.id}')"
                       style="margin-right: 10px; transform: scale(1.2);">
                <div style="color: ${isLocked ? '#FFD700' : quality.color}; font-weight: bold; flex-grow: 1;">
                    ${artifact.name} ${lockIcon}
                </div>
            </div>
            <div>${part.name} | ${quality.name}</div>
            <div style="font-size: 0.8em; margin-top: 5px;">
                <div>等级: ${artifact.upgradeLevel}</div>
                <div>套装: <span style="color: #d4af37;">${artifact.set}</span></div>
                <div>生命: +${(artifact.bonuses.health * 100).toFixed(1)}%</div>
                <div>攻击: +${(artifact.bonuses.attack * 100).toFixed(1)}%</div>
                <div>爆伤: +${(artifact.bonuses.critDamage * 100).toFixed(1)}%</div>
            </div>
            <div style="margin-top: 10px; display: flex; gap: 5px; flex-wrap: wrap;">
                <button onclick="event.stopPropagation(); toggleArtifactLock('${artifact.id}')" 
                        style="background: ${isLocked ? '#FF9800' : '#666'}; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">
                    ${isLocked ? '解锁' : '锁定'}
                </button>
                <button onclick="event.stopPropagation(); showArtifactDetails('${artifact.id}')" 
                        style="background: #2196F3; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">详情</button>
                <button onclick="event.stopPropagation(); equipArtifact('${artifact.id}')" 
                        style="background: #4CAF50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">装备</button>
                <button onclick="event.stopPropagation(); upgradeArtifact('${artifact.id}')" 
                        style="background: #FF9800; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">升级</button>
                <button onclick="event.stopPropagation(); decomposeArtifactItem('${artifact.id}')" 
                        style="background: #f44336; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;"
                        ${isLocked ? 'disabled' : ''}>分解</button>
            </div>
        `;
        
        inventoryContainer.appendChild(artifactCard);
    });
}

 function createFilterUI() {
    const artifactSystemUI = document.getElementById('artifactSystemUI');
    
    // 在神器仓库标题前插入筛选界面
    const filterHTML = `
        <div id="artifactFilterUI" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 8px;">
            <h4 style="color: #d4af37; margin-top: 0;">筛选条件</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                <div>
                    <label>品质筛选:</label>
                    <select id="qualityFilter" onchange="updateArtifactFilter('quality', this.value)" style="width: 100%; padding: 5px;">
                        <option value="all">全部品质</option>
                        ${artifactQualities.map(q => `<option value="${q.id}">${q.name}</option>`).join('')}
                    </select>
                </div>
                <div>
                    <label>套装筛选:</label>
                    <select id="setFilter" onchange="updateArtifactFilter('set', this.value)" style="width: 100%; padding: 5px;">
                        <option value="all">全部套装</option>
                        ${[...new Set(artifactSets.map(s => s.name))].map(set => `<option value="${set}">${set}</option>`).join('')}
                    </select>
                </div>
                <div>
                    <label>部位筛选:</label>
                    <select id="partFilter" onchange="updateArtifactFilter('part', this.value)" style="width: 100%; padding: 5px;">
                        <option value="all">全部部位</option>
                        ${artifactParts.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                    </select>
                </div>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="clearArtifactFilters()" style="background: #666; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 10px;">清除筛选</button>
                <span style="color: #888;">当前显示: <span id="filteredCount">0</span> 个神器</span>
            </div>
        </div>
    `;
    
    const inventoryTitle = artifactSystemUI.querySelector('h7');
    inventoryTitle.insertAdjacentHTML('afterend', filterHTML);
}

// 获取筛选后的神器列表
function getFilteredArtifacts() {
    const filters = player.artifacts.batchSelection.filters;
    
    return player.artifacts.inventory.filter(artifact => {
        // 品质筛选
        if (filters.quality !== 'all' && artifact.quality !== filters.quality) {
            return false;
        }
        
        // 套装筛选
        if (filters.set !== 'all' && artifact.set !== filters.set) {
            return false;
        }
        
        // 部位筛选
        if (filters.part !== 'all' && artifact.part !== filters.part) {
            return false;
        }
        
        return true;
    });
}

// 更新筛选条件
function updateArtifactFilter(type, value) {
    player.artifacts.batchSelection.filters[type] = value;
    
    // 清空选择（因为列表改变了）
    player.artifacts.batchSelection.selectedIds = [];
    
    updateArtifactInventory();
    updateFilteredCount();
}

// 清除所有筛选条件
function clearArtifactFilters() {
    player.artifacts.batchSelection.filters = {
        quality: 'all',
        set: 'all',
        part: 'all'
    };
    
    // 重置下拉菜单
    document.getElementById('qualityFilter').value = 'all';
    document.getElementById('setFilter').value = 'all';
    document.getElementById('partFilter').value = 'all';
    
    player.artifacts.batchSelection.selectedIds = [];
    updateArtifactInventory();
    updateFilteredCount();
}

// 更新筛选计数显示
function updateFilteredCount() {
    const filteredArtifacts = getFilteredArtifacts();
    document.getElementById('filteredCount').textContent = filteredArtifacts.length;
}
function batchLockArtifacts() {
    const selectedIds = player.artifacts.batchSelection.selectedIds;
    
    if (selectedIds.length === 0) {
        logAction("请先选择要锁定的神器", "error");
        return;
    }
    
    let lockedCount = 0;
    selectedIds.forEach(artifactId => {
        const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
        if (artifact && !artifact.locked) {
            artifact.locked = true;
            lockedCount++;
        }
    });
    
    if (lockedCount > 0) {
        logAction(`成功锁定 ${lockedCount} 个神器`, "success");
        updateArtifactUI();
    } else {
        logAction("选中的神器已经全部被锁定", "info");
    }
}

// 批量解锁函数
function batchUnlockArtifacts() {
    const selectedIds = player.artifacts.batchSelection.selectedIds;
    
    if (selectedIds.length === 0) {
        logAction("请先选择要解锁的神器", "error");
        return;
    }
    
    let unlockedCount = 0;
    selectedIds.forEach(artifactId => {
        const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
        if (artifact && artifact.locked) {
            artifact.locked = false;
            unlockedCount++;
        }
    });
    
    if (unlockedCount > 0) {
        logAction(`成功解锁 ${unlockedCount} 个神器`, "success");
        updateArtifactUI();
    } else {
        logAction("选中的神器已经全部未锁定", "info");
    }
}

// 新增锁定/解锁函数
function toggleArtifactLock(artifactId) {
    // 在仓库中查找神器
    let artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    
    // 如果在仓库中没找到，可能在装备中
    if (!artifact) {
        artifact = Object.values(player.artifacts.equipped).find(a => a && a.id === artifactId);
    }
    
    if (!artifact) return;
    
    artifact.locked = !artifact.locked;
    
    if (artifact.locked) {
        logAction(`已锁定神器：${artifact.name}`, 'success');
    } else {
        logAction(`已解锁神器：${artifact.name}`, 'success');
    }
    
    updateArtifactUI();
}
// 切换神器选择状态
function toggleArtifactSelection(artifactId) {
    const index = player.artifacts.batchSelection.selectedIds.indexOf(artifactId);
    
    if (index > -1) {
        // 如果已选中，则取消选择
        player.artifacts.batchSelection.selectedIds.splice(index, 1);
    } else {
        // 如果未选中，则选择
        player.artifacts.batchSelection.selectedIds.push(artifactId);
    }
    
    updateArtifactInventory();
}

// 全选当前筛选结果
function selectAllArtifacts() {
    const filteredArtifacts = getFilteredArtifacts();
    player.artifacts.batchSelection.selectedIds = filteredArtifacts.map(artifact => artifact.id);
    updateArtifactInventory();
}

// 取消全选
function deselectAllArtifacts() {
    player.artifacts.batchSelection.selectedIds = [];
    updateArtifactInventory();
}

// 批量分解选中的神器
function batchDecomposeArtifacts() {
    const selectedIds = player.artifacts.batchSelection.selectedIds;
    
    if (selectedIds.length === 0) {
        logAction("请先选择要分解的神器", "error");
        return;
    }
    
    // 过滤掉被锁定的神器
    const decomposableIds = selectedIds.filter(id => {
        const artifact = player.artifacts.inventory.find(a => a.id === id);
        return artifact && !artifact.locked;
    });
    
    const lockedCount = selectedIds.length - decomposableIds.length;
    
    if (lockedCount > 0) {
        logAction(`跳过 ${lockedCount} 个被锁定的神器`, "info");
    }
    
    if (decomposableIds.length === 0) {
        logAction("没有可分解的神器（所有选中的神器都被锁定）", "error");
        return;
    }
    
    showCustomConfirm(`确定要批量分解 ${decomposableIds.length} 个神器吗？${lockedCount > 0 ? `（跳过 ${lockedCount} 个被锁定的神器）` : ''}此操作不可撤销！`, (confirmed) => {
        if (confirmed) {
            let totalFragments = 0;
            let totalCrystals = 0;
            let decomposedCount = 0;
            
            // 分解选中的神器（只分解未锁定的）
            decomposableIds.forEach(artifactId => {
                const artifactIndex = player.artifacts.inventory.findIndex(a => a.id === artifactId);
                if (artifactIndex > -1) {
                    const artifact = player.artifacts.inventory[artifactIndex];
                    const rewards = calculateDecompositionReward(artifact);
                    
                    totalFragments += rewards.fragments;
                    totalCrystals += rewards.crystals;
                    decomposedCount++;
                    
                    // 从仓库中移除
                    player.artifacts.inventory.splice(artifactIndex, 1);
                }
            });
            
            // 添加资源
            player.exploration.resources.artifactFragment += totalFragments;
            player.exploration.resources.cosmicCrystal += totalCrystals;
            
            // 清空选择
            player.artifacts.batchSelection.selectedIds = [];
            
            // 更新显示
            updateArtifactUI();
            updateExplorationUI();
            
            // 显示分解结果
            showBatchDecompositionResult(decomposedCount, totalFragments, totalCrystals);
        }
    });
}

// 显示批量分解结果
function showBatchDecompositionResult(count, fragments, crystals) {
    const resultOverlay = document.createElement('div');
    resultOverlay.id = 'batchDecompositionResultOverlay';
    resultOverlay.style.position = 'fixed';
    resultOverlay.style.top = '0';
    resultOverlay.style.left = '0';
    resultOverlay.style.width = '100%';
    resultOverlay.style.height = '100%';
    resultOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    resultOverlay.style.zIndex = '2000';
    resultOverlay.style.display = 'flex';
    resultOverlay.style.justifyContent = 'center';
    resultOverlay.style.alignItems = 'center';
    
    const resultCard = document.createElement('div');
    resultCard.style.backgroundColor = '#1a1a1a';
    resultCard.style.padding = '30px';
    resultCard.style.borderRadius = '10px';
    resultCard.style.border = '3px solid #4CAF50';
    resultCard.style.width = '450px';
    resultCard.style.maxWidth = '90%';
    resultCard.style.textAlign = 'center';
    
    resultCard.innerHTML = `
        <h2 style="color: #4CAF50; margin-top: 0;">批量分解完成</h2>
        <div style="margin-bottom: 20px;">
            <div style="font-size: 1.2em; margin-bottom: 10px;">成功分解了 <span style="color: #4CAF50;">${count}</span> 个神器</div>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #d4af37;">获得资源</div>
            <div style="display: flex; justify-content: space-around; margin-top: 15px;">
                <div>
                    <div style="font-size: 1.2em; color: #FF9800;">${fragments}</div>
                    <div>神器碎片</div>
                </div>
                <div>
                    <div style="font-size: 1.2em; color: #2196F3;">${crystals}</div>
                    <div>宇宙晶体</div>
                </div>
            </div>
        </div>
        <button onclick="document.body.removeChild(document.getElementById('batchDecompositionResultOverlay'))" 
                style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 1.1em;">
            确认
        </button>
    `;
    
    resultOverlay.appendChild(resultCard);
    document.body.appendChild(resultOverlay);
    
    logAction(`批量分解了 ${count} 个神器，获得 ${fragments} 碎片和 ${crystals} 晶体`, "success");
}
// 更新套装效果显示
function updateSetBonuses() {
    const setContainer = document.getElementById('setBonuses');
    setContainer.innerHTML = '';
    
    // 计算当前装备的套装数量
    const setCounts = {};
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            if (!setCounts[artifact.set]) {
                setCounts[artifact.set] = 0;
            }
            setCounts[artifact.set]++;
        }
    });
    
    // 显示激活的套装效果
    Object.entries(setCounts).forEach(([setName, count]) => {
        const set = artifactSets.find(s => s.name === setName);
        if (!set) return;
        
        const setDiv = document.createElement('div');
        setDiv.style.marginBottom = '15px';
        setDiv.style.padding = '15px';
        setDiv.style.border = '1px solid #d4af37';
        setDiv.style.borderRadius = '5px';
        setDiv.style.backgroundColor = '#1a1a1a';
        
        let bonusesHtml = `<div style="font-weight: bold; color: #d4af37; font-size: 1.1em; margin-bottom: 10px;">${setName} (${count}/6)</div>`;
        
        // 显示已激活的效果
        Object.entries(set.bonuses).forEach(([pieceCount, bonus]) => {
            const pieceNum = parseInt(pieceCount);
            const isActive = count >= pieceNum;
            
            bonusesHtml += `
                <div style="margin-top: 8px; ${isActive ? 'color: #4CAF50;' : 'color: #888;'}">
                    ${isActive ? '✓ ' : ''}${pieceCount}件: ${bonus.description}
                </div>
            `;
        });
        
        setDiv.innerHTML = bonusesHtml;
        setContainer.appendChild(setDiv);
    });
    
    if (Object.keys(setCounts).length === 0) {
        setContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">未装备任何套装神器</div>';
    }
}
function showArtifactDetails(artifactId) {
   // 先移除可能已存在的详情弹窗
    const existingOverlay = document.getElementById('artifactDetailOverlay');
    if (existingOverlay) {
        document.body.removeChild(existingOverlay);
    }
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const part = artifactParts.find(p => p.id === artifact.part);
    
    // 创建详情弹窗
    const detailOverlay = document.createElement('div');
    detailOverlay.id = 'artifactDetailOverlay';
    detailOverlay.style.position = 'fixed';
    detailOverlay.style.top = '0';
    detailOverlay.style.left = '0';
    detailOverlay.style.width = '100%';
    detailOverlay.style.height = '100%';
    detailOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    detailOverlay.style.zIndex = '2000';
    detailOverlay.style.display = 'flex';
    detailOverlay.style.justifyContent = 'center';
    detailOverlay.style.alignItems = 'center';
    
    const detailCard = document.createElement('div');
    detailCard.style.backgroundColor = '#1a1a1a';
    detailCard.style.padding = '20px';
    detailCard.style.borderRadius = '10px';
    detailCard.style.border = `3px solid ${quality.color}`;
    detailCard.style.width = '400px';
    detailCard.style.maxWidth = '90%';
    

     // 在详情页面添加锁定按钮
    const isLocked = artifact.locked;
    
    detailCard.innerHTML = `
        <div style="text-align: right;">
            <button onclick="document.body.removeChild(document.getElementById('artifactDetailOverlay'))" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        <div style="text-align: center; margin-bottom: 15px;">
            <div style="color: ${quality.color}; font-size: 1.2em; font-weight: bold;">${artifact.name} ${isLocked ? '🔒' : '🔓'}</div>
            <div> ${part.name}</div>
            <div style="margin-top: 10px; font-size: 1.1em; color: #d4af37;">${artifact.set}套装</div>
        </div>
        <div style="margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>品质:</span>
                <span style="color: ${quality.color};">${quality.name}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>升级等级:</span>
                <span>${artifact.upgradeLevel}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>锁定状态:</span>
                <span style="color: ${isLocked ? '#FFD700' : '#666'};">${isLocked ? '已锁定' : '未锁定'}</span>
            </div>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #d4af37;">属性加成</div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>生命加成:</span>
                <span>+${(artifact.bonuses.health * 100).toFixed(1)}%</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>攻击加成:</span>
                <span>+${(artifact.bonuses.attack * 100).toFixed(1)}%</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>爆伤加成:</span>
                <span>+${(artifact.bonuses.critDamage * 100).toFixed(1)}%</span>
            </div>
        </div>
        <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
            <button onclick="toggleArtifactLock('${artifact.id}'); showArtifactDetails('${artifact.id}')" 
                    style="background: ${isLocked ? '#FF9800' : '#666'}; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                ${isLocked ? '解锁神器' : '锁定神器'}
            </button>
            <button onclick="equipArtifact('${artifact.id}')" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">装备</button>
            <button onclick="upgradeArtifact('${artifact.id}')" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;">升级</button>
            <button onclick="decomposeArtifactItem('${artifact.id}')" 
                    style="background: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;"
                    ${isLocked ? 'disabled' : ''}>分解</button>
        </div>
    `;
     // 获取进阶等级
     const baseName = artifact.baseName || artifact.name;
    const advanceLevel = player.artifacts.advanceLevels[artifactId] || 0;
    
    // 更新进阶信息显示
    const advanceInfo = document.getElementById('artifactAdvanceInfo');
    const advanceBtn = document.getElementById('advanceArtifactBtn');
    advanceBtn.onclick = function() {
        advanceArtifact(artifactId);
    };
    
    if (advanceLevel < 7) {
        const cost = advanceCosts[advanceLevel];
        advanceInfo.innerHTML = `
            <div>当前进阶: ${advanceLevel}级 (${advancePrefixes[advanceLevel]}${baseName})</div>
            <div>下一进阶: ${advanceLevel + 1}级 (${advancePrefixes[advanceLevel + 1]}${baseName})</div>
            <div>消耗: ${cost} 进阶神石</div>
            <div>属性提升: ${Math.pow(2, advanceLevel + 1).toFixed(1)}倍</div>
        `;
        
        // 检查是否有足够进阶神石
        if (player.items.advanceStone >= cost) {
            advanceBtn.disabled = false;
            advanceBtn.textContent = "进阶神器";
        } else {
            advanceBtn.disabled = true;
            advanceBtn.textContent = "进阶神石不足";
        }
    } else {
        advanceInfo.innerHTML = `
            <div>当前进阶: 7级 (${advancePrefixes[7]}${baseName})</div>
            <div>已达最高进阶等级</div>
            <div>属性加成: ${Math.pow(2, 7).toFixed(1)}倍</div>
        `;
        advanceBtn.disabled = true;
        advanceBtn.textContent = "已达最高进阶";
    }

    detailOverlay.appendChild(detailCard);
    document.body.appendChild(detailOverlay);
}
function advanceArtifact(artifactId) {
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    const advanceLevel = player.artifacts.advanceLevels[artifactId] || 0;
    if (advanceLevel >= 7) return;
    
    const cost = advanceCosts[advanceLevel];
    if (player.items.advanceStone < cost) {
        logAction("进阶神石不足！", "error");
        return;
    }
    
    // 扣除进阶神石
    player.items.advanceStone -= cost;
    
    // 提升进阶等级
    player.artifacts.advanceLevels[artifactId] = advanceLevel + 1;
    
    // 更新名字前缀
    artifact.name = advancePrefixes[advanceLevel + 1] + artifact.baseName;
    
    logAction(`成功将${artifact.baseName}进阶到${advanceLevel + 1}级！`, "success");
    
    // 更新显示
    updateArtifactUI();
    showArtifactDetails(artifactId); // 重新加载详情页面
}

function decomposeArtifactItem(artifactId) {  
    // 检查是否被锁定
    if (artifact.locked) {
        logAction(`无法分解被锁定的神器：${artifact.name}`, "error");
        return;
    }
   
    const artifactIndex = player.artifacts.inventory.findIndex(a => a.id === artifactId);
    if (artifactIndex === -1) return;
    
    const artifact = player.artifacts.inventory[artifactIndex];
    
    // 计算分解收益
    const decompositionRewards = calculateDecompositionReward(artifact);
    
    // 添加资源
    player.exploration.resources.artifactFragment += decompositionRewards.fragments;
    player.exploration.resources.cosmicCrystal += decompositionRewards.crystals;
    
    // 从仓库中移除神器
    player.artifacts.inventory.splice(artifactIndex, 1);
    
    // 更新UI
    updateArtifactUI();
    updateExplorationUI();
    updateArtifactSetsView();
    // 显示分解结果
    showDecompositionResult(artifact, decompositionRewards);
}

// 计算分解收益
function calculateDecompositionReward(artifact) {
    // 基础收益基于品质
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const baseRewards = {
        common: { fragments: 1, crystals: 1 },
        uncommon: { fragments: 3, crystals: 2 },
        rare: { fragments: 5, crystals: 5 },
        epic: { fragments: 8, crystals: 8 },
        legendary: { fragments: 20, crystals: 10 },
        mythic: { fragments: 50, crystals: 20 }
    };
    
    // 获取基础收益
    const base = baseRewards[artifact.quality] || baseRewards.common;
    
    // 升级加成：每级增加20%收益
    const upgradeMultiplier = 1 + (artifact.upgradeLevel * 0.2);
    
    // 套装加成：套装神器额外增加50%收益
    const setMultiplier = artifact.set ? 1.5 : 1;
    
    // 计算最终收益
    const fragments = Math.floor(base.fragments * upgradeMultiplier * setMultiplier);
    const crystals = Math.floor(base.crystals * upgradeMultiplier * setMultiplier);
    
    return { fragments, crystals };
}

// 显示分解结果
function showDecompositionResult(artifact, rewards) {
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const part = artifactParts.find(p => p.id === artifact.part);
    
    // 创建结果弹窗
    const resultOverlay = document.createElement('div');
    resultOverlay.id = 'decompositionResultOverlay';
    resultOverlay.style.position = 'fixed';
    resultOverlay.style.top = '0';
    resultOverlay.style.left = '0';
    resultOverlay.style.width = '100%';
    resultOverlay.style.height = '100%';
    resultOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    resultOverlay.style.zIndex = '2000';
    resultOverlay.style.display = 'flex';
    resultOverlay.style.justifyContent = 'center';
    resultOverlay.style.alignItems = 'center';
    
    const resultCard = document.createElement('div');
    resultCard.style.backgroundColor = '#1a1a1a';
    resultCard.style.padding = '30px';
    resultCard.style.borderRadius = '10px';
    resultCard.style.border = `3px solid ${quality.color}`;
    resultCard.style.width = '450px';
    resultCard.style.maxWidth = '90%';
    resultCard.style.textAlign = 'center';
    
    resultCard.innerHTML = `
        <h2 style="color: ${quality.color}; margin-top: 0;">分解成功</h2>
        <div style="margin-bottom: 20px;">
            <div style="font-size: 1.1em; margin-bottom: 10px;">${artifact.name} (${part.name})</div>
            <div style="color: #d4af37; margin-bottom: 10px;">${artifact.set}套装</div>
            <div>品质: <span style="color: ${quality.color};">${quality.name}</span></div>
            <div>升级等级: ${artifact.upgradeLevel}</div>
        </div>
        <div style="background: #333; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #d4af37;">获得资源</div>
            <div style="display: flex; justify-content: space-around; margin-top: 15px;">
                <div>
                    <div style="font-size: 1.2em; color: #FF9800;">${rewards.fragments}</div>
                    <div>神器碎片</div>
                </div>
                <div>
                    <div style="font-size: 1.2em; color: #2196F3;">${rewards.crystals}</div>
                    <div>宇宙晶体</div>
                </div>
            </div>
        </div>
        <button onclick="document.body.removeChild(document.getElementById('decompositionResultOverlay'))" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 1.1em;">确认</button>
    `;
    
    resultOverlay.appendChild(resultCard);
    document.body.appendChild(resultOverlay);
}


// 锻造神器
function forgeArtifact(batchCount = 1) {
    const costPerForge = 10;
    const totalCost = costPerForge * batchCount;
    
    if (player.exploration.resources.artifactFragment < totalCost) {
        logAction(`神器碎片不足！需要 ${totalCost}，当前只有 ${player.exploration.resources.artifactFragment}`, "error");
        return;
    }
    
    player.exploration.resources.artifactFragment -= totalCost;
    
    // 记录获得的各品质神器数量
    const qualityCounts = {};
    artifactQualities.forEach(q => {
        qualityCounts[q.id] = 0;
    });
    
    // 批量锻造
    for (let i = 0; i < batchCount; i++) {
        // 随机选择部位
        const part = artifactParts[Math.floor(Math.random() * artifactParts.length)];
    // 随机选择品质（概率不同）
    const qualityRoll = Math.random();
    let quality;
    if (qualityRoll < 0.7) quality = artifactQualities[0]; 
    else if (qualityRoll < 0.95) quality = artifactQualities[1]; 
    else if (qualityRoll < 0.995) quality = artifactQualities[2]; 
    else if (qualityRoll < 0.9995) quality = artifactQualities[3]; 
    else if (qualityRoll < 0.99999) quality = artifactQualities[4]; 
    else quality = artifactQualities[5]; 
      // 记录品质数量
        qualityCounts[quality.id]++;
    // 随机选择名字
    const name = artifactNames[part.id][Math.floor(Math.random() * artifactNames[part.id].length)];
    
    // 随机选择套装
    const set = artifactSets[Math.floor(Math.random() * artifactSets.length)];
    
    // 生成随机属性（在品质范围内）
    const bonuses = {
        health: (Math.random() * (quality.maxBonus - quality.minBonus) + quality.minBonus).toFixed(3),
        attack: (Math.random() * (quality.maxBonus - quality.minBonus) + quality.minBonus).toFixed(3),
        critDamage: (Math.random() * (quality.maxBonus - quality.minBonus) + quality.minBonus).toFixed(3)
    };
    
    // 创建神器
    const artifact = {
        id: 'artifact_' + Date.now() + Math.random(),
        name: name,
        baseName: name,
        part: part.id,
        quality: quality.id,
        set: set.name,
        bonuses: bonuses,
        upgradeLevel: 0,
        advanceLevel: 0
    };
    
     player.artifacts.inventory.push(artifact);
        
        // 单次锻造时显示消息
        if (batchCount === 1) {
            logAction(`成功锻造 ${quality.name}品质${part.name}：${name}`, 'success');
        }
    }
    
    // 批量锻造时显示汇总消息
    if (batchCount > 1) {
        let summaryMessage = `批量锻造 ${batchCount} 次，消耗 ${totalCost} 神器碎片，获得：`;
        
        // 添加各品质数量
        artifactQualities.forEach(q => {
            if (qualityCounts[q.id] > 0) {
                summaryMessage += `${q.name}x${qualityCounts[q.id]} `;
            }
        });
        
        logAction(summaryMessage, 'success');
    }
    
    // 更新UI
    updateArtifactUI();
   updateArtifactSetsView();
}

// 装备神器
function equipArtifact(artifactId) {
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    // 检查该部位是否已装备
    if (player.artifacts.equipped[artifact.part]) {
        // 卸下当前装备
        const currentArtifact = player.artifacts.equipped[artifact.part];
        player.artifacts.inventory.push(currentArtifact);
    }
    
    // 装备新神器
    player.artifacts.equipped[artifact.part] = artifact;
    
    // 从仓库移除
    player.artifacts.inventory = player.artifacts.inventory.filter(a => a.id !== artifactId);
    
    logAction(`装备了神器：${artifact.name}`, 'success');
   updateExplorationUI();
  updateArtifactUI();
    updatePlayerBattleStats(); // 更新玩家战斗属性
}

// 卸下神器
function unequipArtifact(part) {
    const artifact = player.artifacts.equipped[part];
    if (!artifact) return;
    
    player.artifacts.inventory.push(artifact);
    player.artifacts.equipped[part] = null;
    
    logAction(`卸下了神器：${artifact.name}`, 'success');
    updateArtifactUI();
    updatePlayerBattleStats(); // 更新玩家战斗属性
}

// 升级神器
function upgradeArtifact(artifactId) {
    const artifact = player.artifacts.inventory.find(a => a.id === artifactId);
    if (!artifact) return;
    
    const upgradeCost = 10 * (artifact.upgradeLevel + 1);
    if (player.exploration.resources.cosmicCrystal < upgradeCost) {
        logAction(`宇宙晶体不足！需要${upgradeCost}`, "error");
        return;
    }
    
    player.exploration.resources.cosmicCrystal -= upgradeCost;
    artifact.upgradeLevel++;
    
    // 提升属性（最多提升50%）
    const quality = artifactQualities.find(q => q.id === artifact.quality);
    const maxBonus = quality.maxBonus * 10000000; // 最大提升100%
    
    Object.keys(artifact.bonuses).forEach(key => {
        const currentBonus = parseFloat(artifact.bonuses[key]);
        const upgradeAmount = Math.min(
            maxBonus - currentBonus,
            quality.maxBonus * 0.1 // 每次升级提升10%的品质上限
        );
        
        if (upgradeAmount > 0) {
            artifact.bonuses[key] = (currentBonus + upgradeAmount).toFixed(3);
        }
    });
     // 在升级成功后，检查是否有打开的详情弹窗，如果有则刷新它
    const detailOverlay = document.getElementById('artifactDetailOverlay');
    if (detailOverlay) {
        // 先关闭现有弹窗
        document.body.removeChild(detailOverlay);
        // 重新打开详情弹窗显示最新数据
        showArtifactDetails(artifactId);
    }
    logAction(`成功升级 ${artifact.name} 到 Lv.${artifact.upgradeLevel}`, 'success');
updateArtifactUI();
  updateArtifactSetsView();
}

// 计算神器总加成
function calculateArtifactBonuses() {
    const bonuses = {
        health: 0,
        attack: 0,
        critDamage: 0
    };
    
    // 累加所有装备神器的加成
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            const advanceLevel = player.artifacts.advanceLevels[artifact.id] || 0;
            const advanceMultiplier = Math.pow(2, advanceLevel);
            bonuses.health += parseFloat(artifact.bonuses.health) * advanceMultiplier;
            bonuses.attack += parseFloat(artifact.bonuses.attack) * advanceMultiplier;
            bonuses.critDamage += parseFloat(artifact.bonuses.critDamage) * advanceMultiplier;
        }
    });
    
    // 应用套装效果
    const setCounts = {};
    Object.values(player.artifacts.equipped).forEach(artifact => {
        if (artifact) {
            if (!setCounts[artifact.set]) {
                setCounts[artifact.set] = 0;
            }
            setCounts[artifact.set]++;
        }
    });
    
    Object.entries(setCounts).forEach(([setName, count]) => {
        const set = artifactSets.find(s => s.name === setName);
        if (!set) return;
        
        Object.entries(set.bonuses).forEach(([pieceCount, bonus]) => {
            if (count >= parseInt(pieceCount)) {
                bonuses.health += bonus.health || 0;
                bonuses.attack += bonus.attack || 0;
                bonuses.critDamage += bonus.critDamage || 0;
            }
        });
    });
    
    return bonuses;
}
function initSectData() {
    if (!player.sect) {
        player.sect = {
            created: false,
            name: "",
            level: 0,
            exp: 0,
            spiritStones: 0,
            members: [],
            missions: [],
            techniques: {},
            creationTime: 0,
            maxMembers: 5,
            tributeTotal: 0,
            trialAuto: false,
            trialLastTime: 0,
            libraryInherit: {},
            elders: [],
            libraryLevels: {}
        };
    }
    if (!player.sect.tributeTotal) player.sect.tributeTotal = 0;
    if (player.sect.trialAuto === undefined) player.sect.trialAuto = false;
    if (!player.sect.trialLastTime) player.sect.trialLastTime = 0;
    if (!player.sect.libraryInherit) player.sect.libraryInherit = {};
    if (!player.sect.elders) player.sect.elders = [];
    if (!player.sect.libraryLevels) {
        const oldLv = player.sect.libraryLevel;
        const oldInherit = player.sect.libraryInherit || {};
        const oldCount = Object.keys(oldInherit).filter(k => oldInherit[k]).length;
        let migratedLv = oldLv || (oldCount > 0 ? Math.min(SECT_LIBRARY_MAX_LEVEL, oldCount * 2) : 0);
        player.sect.libraryLevels = {};
        if (migratedLv > 0 && sectLibraryItems) {
            sectLibraryItems.forEach(item => { player.sect.libraryLevels[item.id] = Math.min(migratedLv, SECT_LIBRARY_MAX_LEVEL); });
        }
    }
    if (!player.sect.transmitLastTime) player.sect.transmitLastTime = {};
    if (!player.sect.spiritPoolLastTime) player.sect.spiritPoolLastTime = 0;
    if (!player.sect.enlightenmentStart) player.sect.enlightenmentStart = 0;
}

// 切换宗门系统界面
function toggleSectSystem() {
    if (player.reincarnationCount < 1000) {
        alert("需要达到1000转才能开启宗门系统！");
        return;
    }
    
    const ui = document.getElementById('sectSystemUI');
    const overlay = document.getElementById('sectSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initSectData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateSectUI();
    }
}

// 创建宗门
function createSect() {
    if (player.sect.created) {
        logAction("你已经创建过宗门了！", "error");
        return;
    }
    
    if (player.items.zongmen < 1) {
        logAction("宗门令牌不足，无法创建宗门！", "error");
        return;
    }
    
    // 消耗宗门令牌
    player.items.zongmen--;
    
    // 初始化宗门数据
    player.sect = {
        created: true,
        name: "无名宗门",
        level: 1,
        exp: 0,
        spiritStones: 1000,
        members: [],
        missions: [],
        techniques: {},
        creationTime: Date.now(),
        maxMembers: 5,
        tributeTotal: 0,
        trialAuto: false,
        trialLastTime: 0,
        libraryInherit: {},
        elders: [],
        libraryLevels: {},
        grotto: { spiritArrayLevel: 0, spiritFields: [] },
        transmitLastTime: {},
        spiritPoolLastTime: 0,
        enlightenmentStart: 0
    };
    
    // 自动添加掌门（玩家自己）
    player.sect.members.push({
    id: "leader",
    name: player.name,
    aptitude: "SS",  // 可以设置玩家资质，比如SS
    loyalty: 100,
    status: "idle",
    joinTime: Date.now(),
    isPlayer: true  // 添加标记，表示这是玩家
});
    
    logAction("成功创建宗门！", "success");
    updateSectUI();
   updateSectNameDisplay();
}
function getIdleMembers(includePlayer = true) {
    return player.sect.members.filter(member => {
        if (member.status !== 'idle') return false;
        if (member.id === 'leader' && !includePlayer) return false;
        return true;
    });
}
// 更新宗门界面
function updateSectUI() {
    if (!player.sect.created) {
        document.getElementById('sectInfoContainer').innerHTML = `
            <div style="text-align: center; padding: 20px;">
                <h3 style="color: #8B4513;">尚未创建宗门</h3>
                <p>创建宗门需要消耗1个宗门令牌</p>
                <button onclick="createSect()" style="background: #8B4513; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">创建宗门</button>
            </div>
        `;
        return;
    }
    
    // 更新宗门信息
    document.getElementById('sectInfoContainer').innerHTML = `
        <div style="display: flex; justify-content: space-between;">
            <div>
                <h3 style="color: #8B4513; margin: 0;">${player.sect.name}</h3>
                <div>等级: ${player.sect.level} | 声望: ${player.sect.exp.toFixed(0)}/${getNextLevelExp().toFixed(0)}</div>
                <div>成员: ${player.sect.members.length}/${player.sect.maxMembers}</div>
            </div>
            <div style="text-align: right;">
                <div>灵石: <span style="color: #FFD700;">${player.sect.spiritStones.toFixed(0)}</span></div>
                <div>功法数量: ${Object.keys(player.sect.techniques).length}</div>
            </div>
        </div>
    `;
     // 更新招募消耗显示
    document.getElementById('recruitCost').textContent = calculateRecruitCost().toFixed(0);
    // 更新成员列表
    updateMemberList();
    
    // 更新任务列表
    updateMissionList();
    
    // 更新功法列表
    updateTechniqueList();
    
    // 更新设置页面
    document.getElementById('sectNameInput').value = player.sect.name;
    document.getElementById('sectCreationDate').textContent = new Date(player.sect.creationTime).toLocaleDateString();
    
    // 更新新功能界面
    updateSectTributeUI();
    updateSectTrialUI();
    updateSectLibraryUI();
    updateSectShopUI();
    if (typeof updateSectGrottoUI === 'function') updateSectGrottoUI();
    if (typeof updateSectTransmitUI === 'function') updateSectTransmitUI();
    if (typeof updateSectSpiritpoolUI === 'function') updateSectSpiritpoolUI();
    if (typeof updateSectEnlightenmentUI === 'function') updateSectEnlightenmentUI();
}

// 更新成员列表
function updateMemberList() {
    const container = document.getElementById('memberList');
    container.innerHTML = '';
    
    player.sect.members.forEach(member => {
        const memberCard = document.createElement('div');
        memberCard.className = 'member-card';
        memberCard.style.background = '#444';
        memberCard.style.padding = '10px';
        memberCard.style.borderRadius = '5px';
        
        // 根据资质设置颜色
        let aptitudeColor = '#ccc';
        if (member.aptitude === 'SSS') aptitudeColor = '#FFD700';
        else if (member.aptitude === 'SS') aptitudeColor = '#FF6B6B';
        else if (member.aptitude === 'S') aptitudeColor = '#4ECDC4';
        else if (member.aptitude === 'A') aptitudeColor = '#FF9FF3';
        else if (member.aptitude === 'B') aptitudeColor = '#FECA57';
        else if (member.aptitude === 'C') aptitudeColor = '#54A0FF';
        
        // 检查成员是否在任务中
        const isOnMission = member.status === 'onMission';
        
        // 判断是否为玩家
        const isPlayer = member.id === 'leader';
        const isElder = (player.sect.elders || []).includes(member.id);
        const canBeElder = !isPlayer && (member.aptitude === 'S' || member.aptitude === 'SS' || member.aptitude === 'SSS');
        
        memberCard.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
                <div style="font-weight: bold; ${isPlayer ? 'color: #FFD700;' : ''}">
                    ${member.name} ${isPlayer ? '👑' : ''} ${isElder ? '⚜️' : ''}
                </div>
                <div style="color: ${aptitudeColor};">${member.aptitude}${isElder ? ' 长老' : ''}</div>
            </div>
            <div>忠诚度: ${member.loyalty}</div>
            <div>状态: ${isOnMission ? '<span style="color: #FF9800;">任务中</span>' : '空闲'}</div>
            ${!isPlayer && !isOnMission ? `
            <div style="display: flex; gap: 5px; margin-top: 10px; flex-wrap: wrap;">
                <button onclick="expelMember('${member.id}')" style="flex: 1; min-width: 45px; background: #f44336; color: white; border: none; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 12px;">驱逐</button>
                <button onclick="giftMember('${member.id}')" style="flex: 1; min-width: 45px; background: #4CAF50; color: white; border: none; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 12px;">赠礼</button>
                ${canBeElder ? `<button onclick="toggleElder('${member.id}')" style="flex: 1; min-width: 60px; background: ${isElder ? '#666' : '#FF9800'}; color: white; border: none; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 12px;">${isElder ? '罢免' : '任命长老'}</button>` : ''}
            </div>
            ` : ''}
        `;
        
        container.appendChild(memberCard);
    });
}
function updateSectNameDisplay() {
    const sectNameDisplay = document.getElementById('sectNameDisplay');
    
    if (player.sect && player.sect.created) {
        sectNameDisplay.textContent = `宗门: ${player.sect.name}`;
        sectNameDisplay.style.display = 'block';
    } else {
        sectNameDisplay.style.display = 'none';
    }
}
function giftMember(memberId) {
    const member = player.sect.members.find(m => m.id === memberId);
    if (!member) return;
    
    // 检查玫瑰花数量
    if (player.items.roseq < 1) {
        logAction("香囊不足！", "error");
        return;
    }
    
    // 检查忠诚度是否已达上限
    if (member.loyalty >= 100) {
        logAction(`${member.name}的忠诚度已达上限！`, "info");
        return;
    }
    
    // 消耗香囊
    player.items.roseq--;
    
    // 增加忠诚度
    member.loyalty += 5;
    if (member.loyalty > 100) member.loyalty = 100;
    
    logAction(`赠送给${member.name}一个香囊，忠诚度提升5点！`, "success");
    updateSectUI();
    updateDisplay();
}
// 招募弟子
function recruitMember() {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    if (player.sect.members.length >= player.sect.maxMembers) {
        logAction("宗门成员已满！", "error");
        return;
    }
    
    const cost = calculateRecruitCost();
    if (player.sect.spiritStones < cost) {
        logAction(`灵石不足！需要 ${cost} 灵石`, "error");
        return;
    }
    
    // 消耗灵石
    player.sect.spiritStones -= cost;
    
    // 随机生成弟子属性
    const aptitudes = ['C', 'B', 'A', 'S', 'SS', 'SSS'];
    const weights = [0.60, 0.25, 0.10, 0.039, 0.01, 0.001]; 
    
    let rand = Math.random();
    let aptitude = 'C';
    for (let i = 0; i < weights.length; i++) {
        rand -= weights[i];
        if (rand <= 0) {
            aptitude = aptitudes[i];
            break;
        }
    }
    
    // 生成随机名字
    const familyNames = ['赵', '钱', '孙', '李', '周', '吴', '郑', '王', '冯', '陈', '褚', '卫'];
    const givenNames = ['明', '华', '强', '伟', '芳', '娜', '秀英', '勇', '军', '杰', '磊', '超', '鹏', '婷'];
    const name = familyNames[Math.floor(Math.random() * familyNames.length)] + 
                 givenNames[Math.floor(Math.random() * givenNames.length)];
    
    // 添加新成员
    const newMember = {
        id: 'member_' + Date.now(),
        name: name,
        aptitude: aptitude,
        loyalty: 70 + Math.floor(Math.random() * 20), // 70-89的忠诚度
        status: 'idle',
        joinTime: Date.now()
    };
    
    player.sect.members.push(newMember);
    
    logAction(`成功招募弟子: ${name} (${aptitude}资质)`, "success");
    document.getElementById('recruitCost').textContent = calculateRecruitCost().toFixed(0);
    updateSectUI();
}

// 计算招募成本
function calculateRecruitCost() {
    let cost = 100 * Math.pow(1.15, player.sect.members.length);
    const elderBonus = getSectElderBonus();
    if (elderBonus && elderBonus.recruitCost < 0) cost *= (1 + elderBonus.recruitCost);
    return Math.floor(cost);
}
function startAllAvailableMissions() {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    // 获取所有任务
    const missions = initSectMissions();
    const aptitudesOrder = { 'C': 1, 'B': 2, 'A': 3, 'S': 4, 'SS': 5, 'SSS': 6 };
    
    // 获取所有空闲成员（包括玩家）
    const idleMembers = player.sect.members
        .filter(member => member.status === 'idle')
        .sort((a, b) => {
            // 玩家优先
            if (a.id === 'leader' && b.id !== 'leader') return -1;
            if (b.id === 'leader' && a.id !== 'leader') return 1;
            
            // 按资质等级降序排序
            const aLevel = aptitudesOrder[a.aptitude] || 0;
            const bLevel = aptitudesOrder[b.aptitude] || 0;
            if (bLevel !== aLevel) return bLevel - aLevel;
            
            // 同资质按忠诚度降序排序
            return b.loyalty - a.loyalty;
        });
    
    if (idleMembers.length === 0) {
        logAction("没有空闲的成员可以派遣！", "error");
        return;
    }
    
    let missionsAssigned = 0;
    let membersAssigned = 0;
    
    // 为每个空闲成员寻找能执行的任务
    idleMembers.forEach(member => {
        const memberLevel = aptitudesOrder[member.aptitude] || 0;
        
        // 寻找该成员能执行的所有任务
        const availableMissions = missions.filter(mission => {
            const requiredLevel = aptitudesOrder[mission.requiredAptitude];
            return memberLevel >= requiredLevel;
        });
        
        if (availableMissions.length > 0) {
            // 选择最适合的任务（按难度排序，先做高难度）
            availableMissions.sort((a, b) => b.difficulty - a.difficulty);
            const selectedMission = availableMissions[0];
            
            // 为这个任务创建一个新的任务实例
            const missionInstanceId = `${selectedMission.id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // 更新成员状态
            member.status = 'onMission';
            
            // 添加任务实例
            player.sect.missions.push({
                id: missionInstanceId,
                baseMissionId: selectedMission.id,
                name: selectedMission.name,
                memberId: member.id,
                memberName: member.name,
                memberAptitude: member.aptitude,
                isPlayer: member.id === 'leader',  // 标记是否为玩家
                startTime: Date.now(),
                duration: selectedMission.duration,
                reward: selectedMission.reward,
                difficulty: selectedMission.difficulty
            });
            
            // 计算忠诚度加成（玩家忠诚度固定100）
            const loyaltyBonus = calculateLoyaltyBonus(member.loyalty);
            const bonusPercent = (loyaltyBonus * 100 - 100).toFixed(1);
            
            // 如果是玩家，显示特殊信息
            if (member.id === 'leader') {
                logAction(`🗡️ 掌门 ${member.name} 亲自出马执行任务: ${selectedMission.name}`, "success");
            } else {
                logAction(`派遣 ${member.name}(${member.aptitude}) 执行任务: ${selectedMission.name}`, "success");
            }
            
            missionsAssigned++;
            membersAssigned++;
        }
    });
    
    if (membersAssigned > 0) {
        const playerCount = idleMembers.filter(m => m.id === 'leader' && m.status === 'onMission').length;
        const discipleCount = membersAssigned - playerCount;
        
        let message = `成功派遣 ${membersAssigned} 名成员执行任务！`;
        if (playerCount > 0) {
            message += `（其中掌门亲自执行 ${playerCount} 个任务）`;
        }
        logAction(message, "success");
    } else {
        logAction("没有可以执行的任务", "warning");
    }
    
    updateSectUI();
}
function recallAllMissions() {
    if (!player.sect.created || player.sect.missions.length === 0) {
        logAction("当前没有进行中的任务", "info");
        return;
    }
    
    if (!confirm("确定要召回所有弟子吗？召回后不会获得任何任务奖励！")) {
        return;
    }
    
    const missionCount = player.sect.missions.length;
    
    // 召回所有任务中的弟子
    player.sect.missions.forEach(mission => {
        const member = player.sect.members.find(m => m.id === mission.memberId);
        if (member) {
            member.status = 'idle';
        }
    });
    
    // 清空任务列表
    player.sect.missions = [];
    
    logAction(`已召回所有${missionCount}个任务中的弟子`, "info");
    updateSectUI();
}

// 驱逐弟子
function expelMember(memberId) {
    const memberIndex = player.sect.members.findIndex(m => m.id === memberId);
    if (memberIndex === -1) return;
    
    const member = player.sect.members[memberIndex];
    
    // 移除该成员正在执行的任务，避免任务列表泄漏
    player.sect.missions = player.sect.missions.filter(m => m.memberId !== memberId);
    if (player.sect.elders) player.sect.elders = player.sect.elders.filter(id => id !== memberId);
    
    // 移除成员
    player.sect.members.splice(memberIndex, 1);
    
    // 降低其他成员忠诚度（1-5点）
    player.sect.members.forEach(m => {
        if (m.id !== 'leader') {
            m.loyalty -= 1 + Math.floor(Math.random() * 4);
            if (m.loyalty < 0) m.loyalty = 0;
        }
    });
    
    logAction(`已驱逐弟子: ${member.name}`, "info");
    updateSectUI();
}

// 切换宗门标签页
function openSectTab(tabName, evt) {
    // 隐藏所有标签内容
    document.querySelectorAll('.sect-tabcontent').forEach(tab => {
        tab.style.display = 'none';
    });
    
    // 移除所有标签的active类
    document.querySelectorAll('.sect-tablink').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // 显示选中的标签内容并添加active类
    document.getElementById('sect' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).style.display = 'block';
    const e = evt || (typeof event !== 'undefined' ? event : null);
    if (e && e.currentTarget) e.currentTarget.classList.add('active');
}

// 初始化宗门任务
function initSectMissions() {
    return [
        {
            id: "gather_stones",
            name: "采集灵石",
            description: "派遣弟子前往灵脉采集灵石",
            requiredAptitude: "C",
            duration: 21600000, // 6小时
            reward: { stones: 600, exp: 300, cultivationExp: 10000 },
            difficulty: 1
        },
        {
            id: "hunt_demon",
            name: "剿灭妖兽",
            description: "清除宗门附近的低阶妖兽",
            requiredAptitude: "B",
            duration: 21600000, // 6小时
            reward: { stones: 800, exp: 400, cultivationExp: 50000 },
            difficulty: 2
        },
        {
            id: "explore_ruins",
            name: "探索遗迹",
            description: "探索古代修士遗留的洞府遗迹",
            requiredAptitude: "A",
            duration: 21600000, // 6小时
            reward: { stones: 1200, exp: 500, itemChance: 0.3, cultivationExp: 100000 },
            difficulty: 3
        },
        {
            id: "guard_caravan",
            name: "护送商队",
            description: "护送商队通过危险区域",
            requiredAptitude: "S",
            duration: 21600000, // 6小时
            reward: { stones: 1700, exp: 750, itemChance: 0.5, cultivationExp: 500000 },
            difficulty: 4
        },
        {
            id: "compete_tournament",
            name: "参加论道大会",
            description: "代表宗门参加修仙界论道大会",
            requiredAptitude: "SS",
            duration: 21600000, // 6小时
            reward: { stones: 2500, exp: 1000, itemChance: 0.7, cultivationExp: 1000000 },
            difficulty: 5
        },
        {
            id: "slay_ancient_demon",
            name: "讨伐上古魔头",
            description: "讨伐苏醒的上古魔头，维护修仙界和平",
            requiredAptitude: "SSS",
            duration: 21600000, // 6小时
            reward: { stones: 6000, exp: 2000, itemChance: 0.9, cultivationExp: 5000000 },
            difficulty: 6
        }
    ];
}

// 更新任务列表
function updateMissionList() {
    const missionContainer = document.getElementById('missionList');
    const activeMissionContainer = document.getElementById('activeMissionList');
    
    missionContainer.innerHTML = '';
    activeMissionContainer.innerHTML = '';
    
    // 获取所有基础任务
    const missions = initSectMissions();
    
    // 计算每个基础任务有多少个实例在执行
    const missionStats = {};
    player.sect.missions.forEach(mission => {
        if (mission.baseMissionId) {
            missionStats[mission.baseMissionId] = (missionStats[mission.baseMissionId] || 0) + 1;
        }
    });
    
    // 显示任务卡片
    missions.forEach(mission => {
        const missionCard = document.createElement('div');
        missionCard.className = 'mission-card';
        missionCard.style.background = '#444';
        missionCard.style.padding = '10px';
        missionCard.style.borderRadius = '5px';
        
        // 计算该任务有多少人在执行
        const activeCount = missionStats[mission.id] || 0;
        const maxActiveCount = 99; // 可设置最大同时执行人数
        
        missionCard.innerHTML = `
            <h4 style="margin: 0 0 10px 0; color: #8B4513;">${mission.name}</h4>
            <p style="margin: 0 0 10px 0; font-size: 0.9em;">${mission.description}</p>
            <div style="font-size: 0.9em; margin-bottom: 10px;">
                <div>要求资质: ${mission.requiredAptitude}</div>
                <div>耗时: ${formatTimes(mission.duration)}</div>
                <div>奖励: ${mission.reward.stones}灵石/人, ${mission.reward.exp}声望/人${mission.reward.cultivationExp ? ', ' + mission.reward.cultivationExp + '修仙经验/人' : ''}</div>
                ${mission.reward.itemChance ? `<div>物品掉落几率: ${(mission.reward.itemChance * 100).toFixed(0)}%</div>` : ''}
                <div style="color: ${activeCount > 0 ? '#4CAF50' : '#FF9800'}; margin-top: 5px;">
                    🚀 执行中: ${activeCount}人
                </div>
            </div>
            <button onclick="startMissionq('${mission.id}')" 
                style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; width: 100%;">
                🚀 派遣符合条件的弟子
            </button>
            <div style="font-size: 0.8em; color: #999; text-align: center; margin-top: 5px;">
                可多人同时执行
            </div>
        `;
        
        missionContainer.appendChild(missionCard);
    });
    
    // 显示进行中的任务实例
    if (player.sect.missions.length === 0) {
        activeMissionContainer.innerHTML = '<p style="text-align: center; color: #999;">当前没有进行中的任务</p>';
    } else {
        // 按任务类型分组显示
        const missionsByType = {};
        
        player.sect.missions.forEach(mission => {
            if (!missionsByType[mission.name]) {
                missionsByType[mission.name] = [];
            }
            missionsByType[mission.name].push(mission);
        });
        
        Object.entries(missionsByType).forEach(([missionName, missionInstances]) => {
            const missionGroup = document.createElement('div');
            missionGroup.style.marginBottom = '15px';
            missionGroup.style.padding = '10px';
            missionGroup.style.background = '#555';
            missionGroup.style.borderRadius = '8px';
            
            let groupContent = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h4 style="margin: 0; color: #8B4513;">${missionName}</h4>
                    <span style="color: #FFD700;">${missionInstances.length}人执行中</span>
                </div>
            `;
            
            missionInstances.forEach(mission => {
                const remaining = mission.startTime + mission.duration - Date.now();
                const progress = remaining > 0 ? 100 - (remaining / mission.duration * 100) : 100;
                const member = player.sect.members.find(m => m.id === mission.memberId);
                const memberName = member ? member.name : "未知弟子";
                
                groupContent += `
                    <div style="margin-bottom: 8px; padding: 8px; background: #444; border-radius: 5px;">
                        <div style="display: flex; justify-content: space-between; font-size: 0.9em;">
                            <span>${memberName}(${mission.memberAptitude || member?.aptitude || '?'})</span>
                            <span style="color: ${remaining > 0 ? '#FFD700' : '#4CAF50'}">
                                ${remaining > 0 ? formatTimes(remaining) : '已完成'}
                            </span>
                        </div>
                        <div style="height: 4px; background: #333; border-radius: 2px; margin-top: 5px;">
                            <div style="height: 100%; background: #8B4513; border-radius: 2px; width: ${progress}%;"></div>
                        </div>
                    </div>
                `;
            });
            
            missionGroup.innerHTML = groupContent;
            activeMissionContainer.appendChild(missionGroup);
        });
    }
}


// 开始任务
function startMissionq(missionId) {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    // 获取任务详情
    const missions = initSectMissions();
    const baseMission = missions.find(m => m.id === missionId);
    if (!baseMission) return;
    
    // 查找所有符合条件的空闲成员（包括玩家）
    const aptitudesOrder = { 'C': 1, 'B': 2, 'A': 3, 'S': 4, 'SS': 5, 'SSS': 6 };
    const requiredLevel = aptitudesOrder[baseMission.requiredAptitude];
    
    const availableMembers = player.sect.members.filter(member => 
        member.status === 'idle' && aptitudesOrder[member.aptitude] >= requiredLevel
    );
    
    if (availableMembers.length === 0) {
        logAction("没有符合条件的空闲成员！", "error");
        return;
    }
    
    let membersAssigned = 0;
    let playerAssigned = false;
    
    // 为所有符合条件的成员创建任务实例
    availableMembers.forEach(member => {
        const missionInstanceId = `${missionId}_${Date.now()}_${member.id}_${Math.random().toString(36).substr(2, 9)}`;
        
        // 更新成员状态
        member.status = 'onMission';
        
        // 添加任务实例
        player.sect.missions.push({
            id: missionInstanceId,
            baseMissionId: missionId,
            name: baseMission.name,
            memberId: member.id,
            memberName: member.name,
            memberAptitude: member.aptitude,
            isPlayer: member.id === 'leader',
            startTime: Date.now(),
            duration: baseMission.duration,
            reward: baseMission.reward,
            difficulty: baseMission.difficulty
        });
        
        // 计算忠诚度加成
        const loyaltyBonus = calculateLoyaltyBonus(member.loyalty);
        
        // 如果是玩家，显示特殊信息
        if (member.id === 'leader') {
            logAction(`🗡️ 掌门 ${member.name} 亲自出马执行任务: ${baseMission.name}`, "success");
            playerAssigned = true;
        } else {
            const bonusPercent = (loyaltyBonus * 100 - 100).toFixed(1);
            logAction(`派遣 ${member.name}(${member.aptitude}) 执行任务: ${baseMission.name}`, "success");
        }
        
        membersAssigned++;
    });
    
    if (membersAssigned > 0) {
        let message = `成功派遣 ${membersAssigned} 名成员执行 ${baseMission.name} 任务！`;
        if (playerAssigned) {
            message += `（掌门亲自参与）`;
        }
        logAction(message, "success");
    }
    
    updateSectUI();
}

// 修改任务完成函数，为玩家添加特殊奖励
function completeMissionq(missionInstanceId) {
    const missionIndex = player.sect.missions.findIndex(m => m.id === missionInstanceId);
    if (missionIndex === -1) return;
    
    const mission = player.sect.missions[missionIndex];
    const member = player.sect.members.find(m => m.id === mission.memberId);
    
    // 成员已被驱逐等情况：只移除任务实例，避免任务列表泄漏
    if (!member) {
        player.sect.missions.splice(missionIndex, 1);
        return;
    }
    
    if (member) {
        // 检查任务是否已经完成
        if (member.status !== 'onMission') {
            player.sect.missions.splice(missionIndex, 1);
            updateSectUI();
            return;
        }
        
        // 恢复成员状态
        member.status = 'idle';
        
        // 计算忠诚度加成（玩家忠诚度固定100）
        const loyaltyBonus = calculateLoyaltyBonus(member.loyalty);
        const elderBonus = getSectElderBonus();
        const elderTaskMult = 1 + (elderBonus && elderBonus.taskReward ? elderBonus.taskReward : 0);
        const libraryBonus = getSectLibraryBonus();
        const libraryMissionMult = 1 + (libraryBonus && libraryBonus.missionReward ? libraryBonus.missionReward : 0);
        
        // 发放奖励（应用忠诚度、长老、藏经阁加成）
        let stonesReward = Math.floor(mission.reward.stones * loyaltyBonus * elderTaskMult * libraryMissionMult);
        let expReward = Math.floor(mission.reward.exp * loyaltyBonus * elderTaskMult * libraryMissionMult);
        let cultivationExpReward = 0;
        if (mission.reward.cultivationExp && player.cultivation) {
            cultivationExpReward = Math.floor(mission.reward.cultivationExp * loyaltyBonus * elderTaskMult * libraryMissionMult);
            if (member.id === 'leader') cultivationExpReward = Math.floor(cultivationExpReward * 1.2);
        }
        
        // 如果是玩家，可以给予额外奖励
        if (member.id === 'leader') {
            // 掌门执行任务获得额外20%奖励
            stonesReward = Math.floor(stonesReward * 1.2);
            expReward = Math.floor(expReward * 1.2);
        }
        
        player.sect.spiritStones += stonesReward;
        player.sect.exp += expReward;
        if (cultivationExpReward > 0 && player.cultivation) {
            player.cultivation.exp += cultivationExpReward;
        }
        
        // 物品掉落
        if (mission.reward.itemChance && Math.random() < mission.reward.itemChance) {
            const items = ['primaryGem', 'advancedGem', 'rebornDan', 'cultivationPill'];
            const randomItem = items[Math.floor(Math.random() * items.length)];
            player.items[randomItem] = (player.items[randomItem] || 0) + 1;
            
            // 如果是玩家，可能有更高几率获得稀有物品
            if (member.id === 'leader' && Math.random() < 0.3) {
                // 掌门有30%几率额外获得一个物品
                const additionalItem = items[Math.floor(Math.random() * items.length)];
                player.items[additionalItem] = (player.items[additionalItem] || 0) + 1;
                logAction(`🗡️ 掌门 ${member.name} 完成${mission.name}，带回${getItemName(randomItem)}和${getItemName(additionalItem)}！获得${stonesReward}灵石、${expReward}声望${cultivationExpReward > 0 ? '、' + cultivationExpReward + '修仙经验' : ''}！`, "success");
            } else {
                logAction(`${member.name}完成${mission.name}带回${getItemName(randomItem)}！获得${stonesReward}灵石、${expReward}声望${cultivationExpReward > 0 ? '、' + cultivationExpReward + '修仙经验' : ''}！`, "success");
            }
        } else {
            if (member.id === 'leader') {
                logAction(`🗡️ 掌门 ${member.name} 完成${mission.name}，获得${stonesReward}灵石、${expReward}声望${cultivationExpReward > 0 ? '、' + cultivationExpReward + '修仙经验' : ''}！（额外20%奖励）`, "success");
            } else {
                logAction(`${member.name}完成${mission.name}，获得${stonesReward}灵石、${expReward}声望${cultivationExpReward > 0 ? '、' + cultivationExpReward + '修仙经验' : ''}！`, "success");
            }
        }
        
        // 根据忠诚度变化调整忠诚度（玩家的忠诚度不变）
        if (member.id !== 'leader') {
            const loyaltyChange = Math.floor((loyaltyBonus - 1) * 5);
            member.loyalty += loyaltyChange;
            
            // 确保忠诚度在合理范围内
            if (member.loyalty < 0) member.loyalty = 0;
            if (member.loyalty > 100) member.loyalty = 100;
            
            if (loyaltyChange > 0) {
                logAction(`${member.name}的忠诚度提升了${loyaltyChange}点！`, "info");
            } else if (loyaltyChange < 0) {
                logAction(`${member.name}的忠诚度降低了${Math.abs(loyaltyChange)}点！`, "warning");
            }
        }
        
        // 检查升级
        checkSectLevelUp();
        
        // 移除任务实例
        player.sect.missions.splice(missionIndex, 1);
        
        setTimeout(() => {
            updateSectUI();
        }, 100);
    }
}
let isCheckingMissions = false;

registerInterval(() => {
    if (player.sect && player.sect.created && !isCheckingMissions) {
        isCheckingMissions = true;
        
        // 复制任务列表，避免在遍历时修改数组
        const missionsToCheck = [...player.sect.missions];
        
        missionsToCheck.forEach(mission => {
            if (Date.now() - mission.startTime >= mission.duration) {
                // 只处理尚未完成的任务
                const missionInProgress = player.sect.missions.find(m => m.id === mission.id);
                if (missionInProgress) {
                    completeMissionq(mission.id);
                }
            }
        });
        
        isCheckingMissions = false;
    }
    if (player.sect && player.sect.created && player.sect.trialAuto && typeof checkSectTrialAuto === 'function') {
        checkSectTrialAuto();
    }
}, 1000);

function calculateLoyaltyBonus(loyalty) {
    if (loyalty >= 50) {
        // 高于50忠诚度，每点增加1.5%奖励
        return 1 + (loyalty - 50) * 0.015;
    } else {
        // 低于50忠诚度，每点减少1.5%奖励
        return 1 - (50 - loyalty) * 0.015;
    }
}
// 检查宗门升级
function checkSectLevelUp() {
    const nextLevelExp = getNextLevelExp();
    if (player.sect.exp >= nextLevelExp) {
        player.sect.level++;
        player.sect.exp -= nextLevelExp;
        
        // 升级奖励
        player.sect.maxMembers += 2;
        player.sect.spiritStones += 500 * player.sect.level;
        
        logAction(`宗门升级至${player.sect.level}级！成员上限增加至${player.sect.maxMembers}`, "success");
    }
}

// 获取下一级所需经验
function getNextLevelExp() {
    return 1000 * Math.pow(1.5, player.sect.level - 1);
}

// 更新功法列表
function updateTechniqueList() {
    const container = document.getElementById('techniqueList');
    container.innerHTML = '';
    
    // 获取玩家所有功法
    const techniques = Object.keys(player.techniques).filter(t => t !== 'none');
    
    if (techniques.length === 0) {
        container.innerHTML = '<p>尚未习得任何功法</p>';
        return;
    }
    
    techniques.forEach(techId => {
        const techLevel = player.techniques[techId] || 1;
        const sectTechLevel = player.sect.techniques[techId] || 1;
        
        // 获取功法配置
        const techConfig = techniqueConfig[techId];
        const techName = techConfig ? techConfig.name : techId;
        
        // 计算当前加成效果
        const baseEffect = techConfig ? techConfig.effect : 0;
        const sectMultiplier = 1 + (sectTechLevel * 2); // 每级增加2倍效果
        const totalEffect = techLevel * baseEffect * sectMultiplier;
        
        // 格式化效果显示
        let effectDisplay = '';
        if (techConfig && techConfig.type) {
            switch (techConfig.type) {
                case 'health':
                    effectDisplay = `生命加成: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'attack':
                    effectDisplay = `攻击加成: +${(totalEffect * 100 * 10) .toFixed(1)}%`;
                    break;
                case 'critRate':
                    effectDisplay = `暴击率: +${(totalEffect * 100).toFixed(1)}%`;
                    break;
                case 'critDamage':
                    effectDisplay = `爆伤加成: +${(totalEffect * 100 * 10).toFixed(1)}%`;
                    break;
                case 'multiAttack':
                    effectDisplay = `连击次数: +${(totalEffect * 0.02).toFixed(4)}`;
                    break;
                default:
                    effectDisplay = `效果: +${(totalEffect * 100).toFixed(1)}%`;
            }
        }
        
        const techCard = document.createElement('div');
        techCard.className = 'tech-card';
        techCard.style.background = '#444';
        techCard.style.padding = '10px';
        techCard.style.borderRadius = '5px';
        
        techCard.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h4 style="margin: 0; color: #8B4513;">${techName}</h4>
                <div style="font-size: 0.9em;">宗门等级: ${sectTechLevel}</div>
            </div>
            <div style="margin: 10px 0; font-size: 0.9em;">
                <div>个人等级: ${techLevel}</div>
                <div>${effectDisplay}</div>
                <div>升级消耗: ${calculateUpgradeCost(techId).toFixed(0)}灵石</div>
            </div>
            <button onclick="upgradeTechnique('${techId}')" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; width: 100%;">升级功法</button>
        `;
        
        container.appendChild(techCard);
    });
    

    
    // 更新一键升级成本
    document.getElementById('upgradeAllCost').textContent = calculateUpgradeAllCost().toFixed(0);
}

// 升级功法
function upgradeTechnique(techName) {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    const cost = calculateUpgradeCost(techName);
    if (player.sect.spiritStones < cost) {
        logAction(`灵石不足！需要 ${cost} 灵石`, "error");
        return;
    }
    
    // 消耗灵石
    player.sect.spiritStones -= cost;
    
    // 升级功法
    if (!player.sect.techniques[techName]) {
        player.sect.techniques[techName] = 1;
    } else {
        player.sect.techniques[techName]++;
    }
     
       

    logAction(`成功升级功法: ${techName} (当前宗门等级: ${player.sect.techniques[techName]})`, "success");
   updatePlayerBattleStats();
    updateSectUI();
}

// 计算功法升级成本
function calculateUpgradeCost(techName) {
    const currentLevel = player.sect.techniques[techName] || 0;
    return 100 * Math.pow(1.2, currentLevel);
}

// 一键升级所有功法
function upgradeAllTechniques() {
    if (!player.sect.created) {
        logAction("请先创建宗门！", "error");
        return;
    }
    
    const totalCost = calculateUpgradeAllCost();
    if (player.sect.spiritStones < totalCost) {
        logAction(`灵石不足！需要 ${totalCost} 灵石`, "error");
        return;
    }
    
    // 消耗灵石
    player.sect.spiritStones -= totalCost;
    
    // 升级所有功法
    Object.keys(player.techniques).forEach(techName => {
        if (techName !== 'none') {
            if (!player.sect.techniques[techName]) {
                player.sect.techniques[techName] = 1;
            } else {
                player.sect.techniques[techName]++;
            }
        }
    });
    
    logAction("成功一键升级所有功法！", "success");
   updatePlayerBattleStats();
    updateSectUI();
}

// 计算一键升级总成本
function calculateUpgradeAllCost() {
    let totalCost = 0;
    Object.keys(player.techniques).forEach(techName => {
        if (techName !== 'none') {
            totalCost += calculateUpgradeCost(techName);
        }
    });
    return totalCost;
}

// 修改宗门名称
function changeSectName() {
    const newName = document.getElementById('sectNameInput').value.trim();
    
    if (!newName) {
        logAction("宗门名称不能为空！", "error");
        return;
    }
    
    if (newName.length > 20) {
        logAction("宗门名称过长（最多20字符）！", "error");
        return;
    }
    
    player.sect.name = newName;
    logAction(`宗门名称已修改为: ${newName}`, "success");
    updateSectUI();
  updateSectNameDisplay();
}

// 解散宗门
function disbandSect() {
    if (!confirm("确定要解散宗门吗？将会失去所有宗门成员和等级！")) {
        return;
    }
    
    // 返还部分资源
    const refund = Math.floor(player.sect.spiritStones * 0.5);
    player.spiritStones += refund;
    
    // 重置宗门数据
    player.sect = {
        created: false,
        name: "",
        level: 0,
        exp: 0,
        spiritStones: 0,
        members: [],
        missions: [],
        techniques: {},
        creationTime: 0,
        maxMembers: 5,
        tributeTotal: 0,
        trialAuto: false,
        trialLastTime: 0,
        libraryInherit: {},
        elders: [],
        libraryLevels: {}
    };
    
    logAction(`宗门已解散，返还${refund}灵石`, "info");
    updateSectUI();
   updateSectNameDisplay();
}

// 辅助函数：格式化时间
function formatTimes(ms) {
    if (ms <= 0) return "已完成";
    
    const hours = Math.floor(ms / 3600000);
    const minutes = Math.floor((ms % 3600000) / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    
    return `${hours}小时 ${minutes}分钟 ${seconds}秒`;
}

// 辅助函数：获取物品名称
function getItemName(itemKey) {
    const names = {
        'superiorGem': '极品宝石',
        'baitCount': '鱼饵',
        'rebornDan': '洗髓丹',
        'companionKey': '伴侣钥匙',
        'primaryGem': '初级宝石',
        'advancedGem': '高级宝石',
        'cultivationPill': '修炼丹',
        'roseq': '香囊',
        'zongmen': '宗门令牌',
        'danyao1': '蕴灵筑基丹', 'danyao2': '凝元固窍丹', 'danyao3': '渡厄金还丹', 'danyao4': '九转轮回丹', 'danyao5': '混元道果丹'
    };
    return names[itemKey] || itemKey;
}

// ========== 供奉殿功能 ==========
function updateSectTributeUI() {
    const container = document.getElementById('sectTribute');
    if (!container || !player.sect.created) return;
    const fmt = (n) => (n >= 1e8 ? n.toExponential(2) : (n||0).toLocaleString());
    const playerStones = player.spiritStones || 0;
    document.getElementById('tributePlayerStones').textContent = fmt(playerStones);
    document.getElementById('tributeSectStones').textContent = fmt(player.sect.spiritStones);
    document.getElementById('tributeTotal').textContent = fmt(player.sect.tributeTotal || 0);
    const bonusPercent = Math.floor((player.sect.tributeTotal || 0) / 10000);
    document.getElementById('tributeBonusPercent').textContent = bonusPercent;
}
function tributeToSect() {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    const amount = parseInt(document.getElementById('tributeAmount').value) || 0;
    if (amount <= 0) { logAction("请输入有效数量！", "error"); return; }
    if ((player.spiritStones || 0) < amount) { logAction("玩家灵石不足！", "error"); return; }
    player.spiritStones -= amount;
    player.sect.spiritStones += amount;
    player.sect.tributeTotal = (player.sect.tributeTotal || 0) + amount;
    logAction(`供奉 ${amount} 灵石入宗门！`, "success");
    updateSectUI(); updateDisplay();
}
function withdrawFromSect() {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    const amount = parseInt(document.getElementById('tributeAmount').value) || 0;
    if (amount <= 0) { logAction("请输入有效数量！", "error"); return; }
    if (player.sect.spiritStones < amount) { logAction("宗门灵石不足！", "error"); return; }
    player.sect.spiritStones -= amount;
    player.spiritStones = (player.spiritStones || 0) + amount;
    logAction(`从宗门提取 ${amount} 灵石！`, "success");
    updateSectUI(); updateDisplay();
}
function getSectTributeGPSBonus() {
    if (!player.sect || !player.sect.created) return 1;
    const bonusPercent = Math.floor((player.sect.tributeTotal || 0) / 10000);
    return 1 + bonusPercent * 0.01;
}

// ========== 试炼塔功能 ==========
const SECT_TRIAL_INTERVAL = 6 * 60 * 60 * 1000;
function updateSectTrialUI() {
    const container = document.getElementById('sectTrial');
    if (!container || !player.sect.created) return;
    const checkbox = document.getElementById('trialAutoToggle');
    if (checkbox) checkbox.checked = player.sect.trialAuto || false;
    const lastTime = player.sect.trialLastTime || 0;
    const remaining = lastTime > 0 ? Math.max(0, lastTime + SECT_TRIAL_INTERVAL - Date.now()) : 0;
    const nextEl = document.getElementById('trialNextTime');
    const btnEl = document.getElementById('trialRunBtn');
    const hintEl = document.getElementById('trialCooldownHint');
    if (nextEl) nextEl.textContent = lastTime > 0 ? formatTimes(remaining) : '随时可试炼';
    if (btnEl) {
        const onCooldown = remaining > 0;
        btnEl.disabled = onCooldown;
        btnEl.style.opacity = onCooldown ? '0.6' : '1';
    }
    if (hintEl) hintEl.textContent = remaining > 0 ? '试炼冷却中，每6小时可试炼一次' : '';
}
function toggleSectTrialAuto() {
    if (!player.sect.created) return;
    player.sect.trialAuto = document.getElementById('trialAutoToggle').checked;
    logAction(player.sect.trialAuto ? "已开启自动试炼" : "已关闭自动试炼", "info");
    updateSectUI();
}
function runSectTrial() {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    const now = Date.now();
    const lastTime = player.sect.trialLastTime || 0;
    if (lastTime > 0 && (now - lastTime) < SECT_TRIAL_INTERVAL) {
        const remaining = SECT_TRIAL_INTERVAL - (now - lastTime);
        logAction("试炼冷却中，请等待 " + formatTimes(remaining), "warning");
        return;
    }
    const idleCount = player.sect.members.filter(m => m.status === 'idle').length;
    if (idleCount === 0) { logAction("没有空闲弟子可参与试炼！", "warning"); return; }
    const expReward = idleCount * 1000;
    const stonesReward = idleCount * (player.sect.level || 1) * 5000;
    player.sect.exp += expReward;
    player.sect.spiritStones += stonesReward;
    player.sect.trialLastTime = Date.now();
    logAction(`试炼完成！${idleCount}名弟子获得 ${expReward} 声望、${stonesReward} 灵石（下次试炼需等待6小时）`, "success");
    updateSectUI();
}
function checkSectTrialAuto() {
    if (!player.sect || !player.sect.created || !player.sect.trialAuto) return;
    const lastTime = player.sect.trialLastTime || 0;
    if (Date.now() - lastTime >= SECT_TRIAL_INTERVAL) runSectTrial();
}

// ========== 藏经阁传承功法（分开展示，每项10级，消耗=100万×目标等级） ==========
const SECT_LIBRARY_MAX_LEVEL = 10;
const SECT_LIBRARY_BASE_COST = 1000000;
const sectLibraryItems = [
    { id: 'inherit_attack', name: '破军传承', desc: '修仙副本攻击+20%/级', key: 'dungeonAttack', perLevel: 0.2 },
    { id: 'inherit_health', name: '护体传承', desc: '修仙副本生命+50%/级', key: 'dungeonHealth', perLevel: 0.5 },
    { id: 'inherit_crit', name: '必杀传承', desc: '修仙副本暴击率+2%/级', key: 'dungeonCritRate', perLevel: 0.02 },
    { id: 'inherit_critDmg', name: '爆裂传承', desc: '修仙副本爆伤+20%/级', key: 'dungeonCritDamage', perLevel: 0.2 },
    { id: 'inherit_mission', name: '勤修传承', desc: '宗门任务奖励+5%/级', key: 'missionReward', perLevel: 0.05 }
];
function getSectLibraryUpgradeCost(inheritId) {
    const levels = player.sect.libraryLevels || {};
    const lv = levels[inheritId] || 0;
    return Math.floor(SECT_LIBRARY_BASE_COST * (lv + 1));
}
function updateSectLibraryUI() {
    const container = document.getElementById('libraryList');
    const bonusEl = document.getElementById('libraryActiveBonus');
    if (!player.sect.created) return;
    const levels = player.sect.libraryLevels || {};
    const bonus = getSectLibraryBonus();
    const parts = [];
    if (bonus.dungeonAttack) parts.push('攻击+' + (bonus.dungeonAttack * 100).toFixed(0) + '%');
    if (bonus.dungeonHealth) parts.push('生命+' + (bonus.dungeonHealth * 100).toFixed(0) + '%');
    if (bonus.dungeonCritRate) parts.push('暴击+' + (bonus.dungeonCritRate * 100).toFixed(0) + '%');
    if (bonus.dungeonCritDamage) parts.push('爆伤+' + (bonus.dungeonCritDamage * 100).toFixed(0) + '%');
    if (bonus.missionReward) parts.push('任务+' + (bonus.missionReward * 100).toFixed(0) + '%');
    if (bonusEl) bonusEl.innerHTML = parts.length > 0 ? '当前生效: ' + parts.join(' | ') : '暂无传承加成';
    if (!container) return;
    const fmt = (n) => (n >= 1e6 ? (n/1e6).toFixed(1) + 'M' : n.toLocaleString());
    container.innerHTML = sectLibraryItems.map(item => {
        const lv = levels[item.id] || 0;
        const cost = getSectLibraryUpgradeCost(item.id);
        const canUpgrade = lv < SECT_LIBRARY_MAX_LEVEL && player.sect.spiritStones >= cost;
        return `
            <div style="background: #444; padding: 12px; border-radius: 5px; ${lv > 0 ? 'border: 2px solid #4CAF50;' : ''}">
                <h4 style="margin: 0 0 8px 0; color: #8B4513;">${item.name} Lv.${lv}/${SECT_LIBRARY_MAX_LEVEL}</h4>
                <p style="margin: 0 0 8px 0; font-size: 0.9em;">${item.desc}</p>
                ${lv < SECT_LIBRARY_MAX_LEVEL ? `
                <div style="font-size: 0.85em; margin-bottom: 8px;">升级消耗: ${fmt(cost)} 灵石</div>
                <button onclick="upgradeSectLibrary('${item.id}')" ${!canUpgrade ? 'disabled' : ''} style="background: #2196F3; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; width: 100%; font-size: 13px; ${!canUpgrade ? 'opacity:0.6;cursor:not-allowed;' : ''}">升级</button>
                ` : '<div style="color: #4CAF50;">已满级</div>'}
            </div>
        `;
    }).join('');
}
function upgradeSectLibrary(inheritId) {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    const item = sectLibraryItems.find(i => i.id === inheritId);
    if (!item) return;
    const levels = player.sect.libraryLevels || {};
    const lv = levels[inheritId] || 0;
    if (lv >= SECT_LIBRARY_MAX_LEVEL) { logAction(`${item.name}已满级！`, "info"); return; }
    const cost = getSectLibraryUpgradeCost(inheritId);
    if (player.sect.spiritStones < cost) { logAction(`宗门灵石不足！需要 ${cost.toLocaleString()}`, "error"); return; }
    player.sect.spiritStones -= cost;
    if (!player.sect.libraryLevels) player.sect.libraryLevels = {};
    player.sect.libraryLevels[inheritId] = lv + 1;
    logAction(`${item.name} 升级至 Lv.${player.sect.libraryLevels[inheritId]}！`, "success");
    updatePlayerBattleStats();
    updateSectUI();
}
function getSectLibraryBonus() {
    if (!player || !player.sect || !player.sect.created) return {};
    const levels = player.sect.libraryLevels || {};
    const bonus = { dungeonAttack: 0, dungeonHealth: 0, dungeonCritRate: 0, dungeonCritDamage: 0, missionReward: 0 };
    sectLibraryItems.forEach(item => {
        const lv = levels[item.id] || 0;
        if (lv > 0 && bonus[item.key] !== undefined) bonus[item.key] += lv * item.perLevel;
    });
    return bonus;
}

// ========== 声望商店 ==========
const sectShopItems = [
    { id: 'shop_rootDetector', name: '灵根检测器', desc: '用于开启灵根宝箱', cost: 3000, item: 'rootDetector', amount: 1 },
    { id: 'shop_bloodlineDetector', name: '血脉检测剂', desc: '用于开启血脉宝箱', cost: 3000, item: 'bloodlineDetector', amount: 1 },
    { id: 'shop_roseq', name: '香囊', desc: '赠送宗门成员增加忠诚度', cost: 800, item: 'roseq', amount: 1 },
    { id: 'shop_fubeng1', name: '深渊令牌', desc: '用于挑战无限深渊', cost: 2000, item: 'fubeng1', amount: 1 },
    { id: 'shop_fuben1', name: '副本令牌', desc: '用于挑战副本', cost: 5000, item: 'fuben1', amount: 1 },
    { id: 'shop_fuben2', name: '秘境钥匙', desc: '用于开启秘境', cost: 5000, item: 'fuben2', amount: 1 },
    { id: 'shop_zhiye1', name: '职业转换书', desc: '用于更换职业', cost: 10000, item: 'zhiye1', amount: 1 },
    { id: 'shop_seed_herb1', name: '蕴灵草药种子', desc: '洞府灵田种植，10分钟收获蕴灵筑基丹1-100个', cost: 100, item: 'seed_herb1', amount: 1 },
    { id: 'shop_seed_herb2', name: '凝元草药种子', desc: '洞府灵田种植，30分钟收获凝元固窍丹1-70个', cost: 600, item: 'seed_herb2', amount: 1 },
    { id: 'shop_seed_herb3', name: '渡厄草药种子', desc: '洞府灵田种植，60分钟收获渡厄金还丹1-50个', cost: 3600, item: 'seed_herb3', amount: 1 },
    { id: 'shop_seed_herb4', name: '九转草药种子', desc: '洞府灵田种植，300分钟收获九转轮回丹1-40个', cost: 22000, item: 'seed_herb4', amount: 1 },
    { id: 'shop_seed_herb5', name: '混元草药种子', desc: '洞府灵田种植，1200分钟收获混元道果丹1-25个', cost: 132000, item: 'seed_herb5', amount: 1 }
];
function updateSectShopUI() {
    const container = document.getElementById('sectShopList');
    const expEl = document.getElementById('shopSectExp');
    if (!container || !player.sect.created) return;
    if (expEl) expEl.textContent = Math.floor(player.sect.exp).toLocaleString();
    container.innerHTML = sectShopItems.map(item => `
        <div style="background: #444; padding: 12px; border-radius: 5px;">
            <h4 style="margin: 0 0 8px 0; color: #8B4513;">${item.name}</h4>
            <p style="margin: 0 0 10px 0; font-size: 0.9em;">${item.desc}</p>
            <div style="margin-bottom: 8px;">消耗: ${item.cost} 声望</div>
            <button onclick="buySectShopItem('${item.id}')" style="background: #FF9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; width: 100%;">兑换</button>
        </div>
    `).join('');
}
function buySectShopItem(itemId) {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    const item = sectShopItems.find(i => i.id === itemId);
    if (!item) return;
    if (player.sect.exp < item.cost) { logAction(`声望不足！需要${item.cost}`, "error"); return; }
    player.sect.exp -= item.cost;
    if (item.item) { player.items[item.item] = (player.items[item.item] || 0) + (item.amount || 1); }
    if (item.gives === 'sectStones') player.sect.spiritStones += item.amount || 0;
    logAction(`兑换成功：${item.name}`, "success");
    updateSectUI(); updateDisplay();
}

// ========== 洞府系统 ==========
const grottoHerbConfig = {
    herb1: { name: '蕴灵草药', seedKey: 'seed_herb1', growMin: 10, itemKey: 'danyao1', minReward: 1, maxReward: 100, color: '#4CAF50' },
    herb2: { name: '凝元草药', seedKey: 'seed_herb2', growMin: 30, itemKey: 'danyao2', minReward: 1, maxReward: 70, color: '#2196F3' },
    herb3: { name: '渡厄草药', seedKey: 'seed_herb3', growMin: 60, itemKey: 'danyao3', minReward: 1, maxReward: 50, color: '#FF5722' },
    herb4: { name: '九转草药', seedKey: 'seed_herb4', growMin: 300, itemKey: 'danyao4', minReward: 1, maxReward: 40, color: '#9C27B0' },
    herb5: { name: '混元草药', seedKey: 'seed_herb5', growMin: 1200, itemKey: 'danyao5', minReward: 1, maxReward: 25, color: '#E91E63' }
};
function getGrottoMaxFields() {
    if (!player.sect || !player.sect.grotto) return 3;
    const lv = player.sect.grotto.spiritArrayLevel || 0;
    return 3 + Math.floor(lv / 5);
}
function getGrottoCultivationExpBonus() {
    if (!player.sect || !player.sect.created || !player.sect.grotto) return 1;
    const lv = player.sect.grotto.spiritArrayLevel || 0;
    return 1 + lv * 0.1;
}
function ensureGrottoData() {
    if (!player.sect || !player.sect.created) return;
    if (!player.sect.grotto) player.sect.grotto = { spiritArrayLevel: 0, spiritFields: [] };
    const max = getGrottoMaxFields();
    while ((player.sect.grotto.spiritFields || []).length < max) {
        if (!player.sect.grotto.spiritFields) player.sect.grotto.spiritFields = [];
        player.sect.grotto.spiritFields.push(null);
    }
}
function upgradeGrottoSpiritArray() {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    ensureGrottoData();
    const grotto = player.sect.grotto;
    const nextLv = grotto.spiritArrayLevel + 1;
    if (nextLv > 100) { logAction("聚灵阵已达最高等级！", "error"); return; }
    const cost = nextLv * 1000000;
    if (player.sect.spiritStones < cost) { logAction(`灵石不足！需要${cost.toLocaleString()}`, "error"); return; }
    player.sect.spiritStones -= cost;
    grotto.spiritArrayLevel = nextLv;
    const newMax = getGrottoMaxFields();
    while (grotto.spiritFields.length < newMax) grotto.spiritFields.push(null);
    logAction(`聚灵阵升级至${nextLv}级！修仙经验+10%`, "success");
    updateSectUI();
    if (typeof saveGame === 'function') saveGame();
}
function plantGrottoHerb(fieldIndex, herbType) {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    ensureGrottoData();
    const cfg = grottoHerbConfig[herbType];
    if (!cfg) return;
    const seedCount = player.items[cfg.seedKey] || 0;
    if (seedCount < 1) { logAction(`${cfg.name}种子不足！`, "error"); return; }
    const fields = player.sect.grotto.spiritFields;
    if (fieldIndex >= fields.length || fields[fieldIndex]) { logAction("该位置不可种植！", "error"); return; }
    player.items[cfg.seedKey]--;
    fields[fieldIndex] = { type: herbType, plantedAt: Date.now(), growMin: cfg.growMin };
    logAction(`种植${cfg.name}成功！${cfg.growMin}分钟后可收获`, "success");
    updateSectUI();
    if (typeof saveGame === 'function') saveGame();
}
function harvestGrottoHerb(fieldIndex) {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    ensureGrottoData();
    const plant = player.sect.grotto.spiritFields[fieldIndex];
    if (!plant) { logAction("该位置为空！", "error"); return; }
    const cfg = grottoHerbConfig[plant.type];
    if (!cfg) return;
    const elapsedMin = (Date.now() - plant.plantedAt) / 60000;
    if (elapsedMin < plant.growMin) {
        const remain = Math.ceil(plant.growMin - elapsedMin);
        logAction(`尚未成熟！还需${remain}分钟`, "error");
        return;
    }
    const amount = cfg.minReward + Math.floor(Math.random() * (cfg.maxReward - cfg.minReward + 1));
    player.items[cfg.itemKey] = (player.items[cfg.itemKey] || 0) + amount;
    player.sect.grotto.spiritFields[fieldIndex] = null;
    logAction(`收获${cfg.name}，获得${getItemName(cfg.name)}×${amount}！`, "success");
    updateSectUI();
    updateDisplay();
    if (typeof saveGame === 'function') saveGame();
}
function updateSectGrottoUI() {
    const levEl = document.getElementById('grottoSpiritArrayLevel');
    const bonusEl = document.getElementById('grottoExpBonus');
    const costEl = document.getElementById('grottoUpgradeCost');
    const btnEl = document.getElementById('grottoUpgradeBtn');
    const maxEl = document.getElementById('grottoMaxFields');
    const fieldsEl = document.getElementById('grottoSpiritFields');
    const fieldCountEl = document.getElementById('grottoFieldCount');
    if (!player.sect.created || !levEl) return;
    ensureGrottoData();
    const grotto = player.sect.grotto;
    const lv = grotto.spiritArrayLevel || 0;
    const maxFields = getGrottoMaxFields();
    const nextCost = (lv < 100) ? (lv + 1) * 1000000 : 0;
    const canUpgrade = player.sect.spiritStones >= nextCost && lv < 100;
    levEl.textContent = lv;
    bonusEl.textContent = (lv * 10) + '%';
    costEl.textContent = nextCost > 0 ? (nextCost / 10000) + '万' : '已满级';
    if (btnEl) { btnEl.disabled = !canUpgrade; btnEl.textContent = lv >= 100 ? '已满级' : '升级聚灵阵'; }
    if (maxEl) maxEl.textContent = maxFields;
    const usedCount = (grotto.spiritFields || []).filter(Boolean).length;
    if (fieldCountEl) fieldCountEl.textContent = usedCount;
    if (fieldsEl) {
        fieldsEl.style.gridTemplateColumns = 'repeat(' + Math.min(5, maxFields) + ', 1fr)';
        fieldsEl.innerHTML = '';
        for (let i = 0; i < maxFields; i++) {
            const plant = grotto.spiritFields[i];
            const div = document.createElement('div');
            div.style.background = '#444';
            div.style.padding = '12px';
            div.style.borderRadius = '8px';
            div.style.border = '1px solid #555';
            if (!plant) {
                let seedOptions = '';
                for (const [k, cfg] of Object.entries(grottoHerbConfig)) {
                    const cnt = player.items[cfg.seedKey] || 0;
                    if (cnt > 0) seedOptions += `<button onclick="plantGrottoHerb(${i},'${k}')" style="background:${cfg.color};color:#fff;border:none;padding:4px 8px;border-radius:4px;margin:2px;cursor:pointer;font-size:12px;">${cfg.name}(${cnt})</button>`;
                }
                div.innerHTML = `<div style="font-size:12px;color:#999;">灵田 ${i+1}</div><div style="margin-top:8px;">${seedOptions || '<span style="color:#666;">无种子</span>'}</div>`;
            } else {
                const cfg = grottoHerbConfig[plant.type];
                const elapsed = (Date.now() - plant.plantedAt) / 60000;
                const ready = elapsed >= plant.growMin;
                const remain = ready ? 0 : Math.ceil(plant.growMin - elapsed);
                div.innerHTML = `<div style="color:${cfg ? cfg.color : '#fff'};">${cfg ? cfg.name : plant.type}</div>` +
                    (ready ? `<button onclick="harvestGrottoHerb(${i})" style="background:#FF9800;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;margin-top:8px;">收获</button>` : `<div style="font-size:11px;color:#aaa;">成熟还需${remain}分钟</div>`);
            }
            fieldsEl.appendChild(div);
        }
    }
}

// ========== 长老任命 ==========
function toggleElder(memberId) {
    if (!player.sect.created) return;
    if (!player.sect.elders) player.sect.elders = [];
    const idx = player.sect.elders.indexOf(memberId);
    const member = player.sect.members.find(m => m.id === memberId);
    if (!member || member.id === 'leader') return;
    const maxElders = Math.min(3, Math.floor((player.sect.members.length - 1) / 2));
    if (idx >= 0) {
        player.sect.elders.splice(idx, 1);
        logAction(`已罢免 ${member.name} 的长老之位`, "info");
    } else {
        if (player.sect.elders.length >= maxElders) { logAction(`长老席位已满（最多${maxElders}位）`, "error"); return; }
        if (!['S','SS','SSS'].includes(member.aptitude)) { logAction("仅S及以上资质可任命长老", "error"); return; }
        player.sect.elders.push(memberId);
        logAction(`任命 ${member.name} 为长老！`, "success");
    }
    updateSectUI();
}
function getSectElderBonus() {
    if (!player.sect || !player.sect.created || !player.sect.elders) return { taskReward: 0, recruitCost: 0 };
    const count = player.sect.elders.length;
    return { taskReward: count * 0.05, recruitCost: -count * 0.05 };
}

// ========== 传功殿：弟子传功给掌门修仙经验 ==========
const SECT_TRANSMIT_COST = 5000;
const SECT_TRANSMIT_COOLDOWN = 6 * 60 * 60 * 1000; // 6小时
const APTITUDE_TRANSMIT_EXP = { 'C': 10000, 'B': 50000, 'A': 100000, 'S': 500000, 'SS': 1000000, 'SSS': 10000000 };
function getTransmitExp(member) {
    return APTITUDE_TRANSMIT_EXP[member.aptitude] || 10000;
}
function transmitToLeader(memberId) {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    if (!player.cultivation) { logAction("请先开启修仙系统！", "error"); return; }
    const member = player.sect.members.find(m => m.id === memberId);
    if (!member || member.id === 'leader') { logAction("掌门不能给自己传功！", "error"); return; }
    if (member.status !== 'idle') { logAction("该弟子正在执行任务！", "error"); return; }
    if (player.sect.spiritStones < SECT_TRANSMIT_COST) { logAction(`宗门灵石不足！需要${SECT_TRANSMIT_COST}`, "error"); return; }
    const lastTime = (player.sect.transmitLastTime || {})[memberId] || 0;
    if (Date.now() - lastTime < SECT_TRANSMIT_COOLDOWN) {
        const remain = Math.ceil((SECT_TRANSMIT_COOLDOWN - (Date.now() - lastTime)) / 60000);
        logAction(`${member.name}传功冷却中，还需${remain}分钟`, "warning");
        return;
    }
    player.sect.spiritStones -= SECT_TRANSMIT_COST;
    if (!player.sect.transmitLastTime) player.sect.transmitLastTime = {};
    player.sect.transmitLastTime[memberId] = Date.now();
    const expGain = getTransmitExp(member);
    const grottoBonus = typeof getGrottoCultivationExpBonus === 'function' ? getGrottoCultivationExpBonus() : 1;
    const finalExp = Math.floor(expGain * grottoBonus);
    player.cultivation.exp += finalExp;
    logAction(`${member.name}(${member.aptitude})传功成功！掌门获得${finalExp}修仙经验`, "success");
    updateSectUI();
    if (typeof updateCultivationUI === 'function') updateCultivationUI();
}
function updateSectTransmitUI() {
    const stonesEl = document.getElementById('transmitSectStones');
    const expEl = document.getElementById('transmitCultivationExp');
    const listEl = document.getElementById('transmitMemberList');
    if (!player.sect.created || !listEl) return;
    if (stonesEl) stonesEl.textContent = Math.floor(player.sect.spiritStones).toLocaleString();
    if (expEl) expEl.textContent = (player.cultivation ? Math.floor(player.cultivation.exp).toLocaleString() : '0');
    const idleMembers = player.sect.members.filter(m => m.id !== 'leader' && m.status === 'idle');
    const lastMap = player.sect.transmitLastTime || {};
    listEl.innerHTML = idleMembers.length === 0 ? '<div style="grid-column:1/-1;color:#999;">暂无空闲弟子可传功</div>' : idleMembers.map(m => {
        const cd = lastMap[m.id] || 0;
        const canTransmit = Date.now() - cd >= SECT_TRANSMIT_COOLDOWN && player.sect.spiritStones >= SECT_TRANSMIT_COST;
        const exp = getTransmitExp(m);
        const remainMin = cd > 0 ? Math.ceil((SECT_TRANSMIT_COOLDOWN - (Date.now() - cd)) / 60000) : 0;
        return `<div style="background:#444;padding:12px;border-radius:8px;">
            <div style="font-weight:bold;color:#8B4513;">${m.name} (${m.aptitude})</div>
            <div style="font-size:0.9em;">传功消耗: ${SECT_TRANSMIT_COST} 灵石 | 可获得: ${exp} 修仙经验</div>
            <div style="font-size:0.85em;color:#999;">${remainMin > 0 ? '冷却: ' + remainMin + '分钟' : '可传功'}</div>
            <button onclick="transmitToLeader('${m.id}')" ${!canTransmit ? 'disabled' : ''} style="background:#4CAF50;color:white;border:none;padding:6px 12px;border-radius:5px;cursor:pointer;margin-top:8px;width:100%;${!canTransmit?'opacity:0.6;':''}">传功</button>
        </div>`;
    }).join('');
}

// ========== 灵泉池：消耗灵石浸泡获得修仙经验 ==========
const SECT_SPIRIT_POOL_COST = 500000;
const SECT_SPIRIT_POOL_COOLDOWN = 12 * 60 * 60 * 1000; // 12小时
function getSpiritPoolReward() {
    // 当前等级升级所需经验的10%
    if (!player.cultivation || !cultivationStages) return 0;
    const nextStage = cultivationStages[player.cultivation.stage + 1];
    if (!nextStage) return 0; // 已达最高境界
    const maxExp = nextStage.expRequired;
    return Math.floor(maxExp * 0.1);
}
function useSpiritPool() {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    if (!player.cultivation) { logAction("请先开启修仙系统！", "error"); return; }
    const reward = getSpiritPoolReward();
    if (reward <= 0) { logAction("已达最高境界，灵泉池无法再提供经验！", "warning"); return; }
    if (player.sect.spiritStones < SECT_SPIRIT_POOL_COST) { logAction(`宗门灵石不足！需要${(SECT_SPIRIT_POOL_COST/10000)}万`, "error"); return; }
    const lastTime = player.sect.spiritPoolLastTime || 0;
    if (Date.now() - lastTime < SECT_SPIRIT_POOL_COOLDOWN) {
        logAction("灵泉池浸泡冷却中，请稍后再试", "warning");
        return;
    }
    player.sect.spiritStones -= SECT_SPIRIT_POOL_COST;
    player.sect.spiritPoolLastTime = Date.now();
    const expGain = getSpiritPoolReward();
    player.cultivation.exp += expGain;
    logAction(`灵泉池浸泡成功！获得${expGain}修仙经验`, "success");
    updateSectUI();
    if (typeof updateCultivationUI === 'function') updateCultivationUI();
}
function updateSectSpiritpoolUI() {
    const costEl = document.getElementById('spiritPoolCost');
    const rewardEl = document.getElementById('spiritPoolReward');
    const nextEl = document.getElementById('spiritPoolNext');
    const btnEl = document.getElementById('spiritPoolBtn');
    if (!player.sect.created || !costEl) return;
    const lastTime = player.sect.spiritPoolLastTime || 0;
    const reward = getSpiritPoolReward();
    const canUse = reward > 0 && Date.now() - lastTime >= SECT_SPIRIT_POOL_COOLDOWN && player.sect.spiritStones >= SECT_SPIRIT_POOL_COST;
    costEl.textContent = (SECT_SPIRIT_POOL_COST / 10000) + '万';
    rewardEl.textContent = reward > 0 ? reward.toLocaleString() : '已达最高境界';
    if (nextEl) nextEl.textContent = lastTime > 0 ? formatTimes(Math.max(0, SECT_SPIRIT_POOL_COOLDOWN - (Date.now() - lastTime))) : '--';
    if (btnEl) { btnEl.disabled = !canUse || !player.cultivation; btnEl.textContent = reward > 0 ? (canUse ? '浸泡灵泉' : '冷却中') : '已达最高境界'; }
}

// ========== 悟道台：挂机悟道获得修仙经验 ==========
const SECT_ENLIGHTENMENT_COST = 200000;
const SECT_ENLIGHTENMENT_DURATION = 2 * 60 * 60 * 1000; // 2小时
function getCultivationExpPerMinute() {
    if (!player.cultivation || !player.cultivation.root || !player.cultivation.bloodline) return 0;
    const rootBonus = player.cultivation.root.bonus;
    const bloodlineBonus = player.cultivation.bloodline.bonus;
    let toolBonus = 1;
    if (player.magicTools && player.magicTools.equipped) {
        const tool = magicToolConfig.tools.find(t => t.id === player.magicTools.equipped);
        if (tool) toolBonus = tool.bonus;
    }
    let collectionBonus = 1;
    if (player.magicTools && player.magicTools.inventory) {
        collectionBonus = 1 + (player.magicTools.inventory.length * 0.01);
    }
    const classBonuses = typeof calculateClassBonuses === 'function' ? calculateClassBonuses() : {};
    const cultivationExpMultiplier = classBonuses.cultivationExpMultiplier || 1;
    const grottoBonus = typeof getGrottoCultivationExpBonus === 'function' ? getGrottoCultivationExpBonus() : 1;
    return (rootBonus * bloodlineBonus * toolBonus * collectionBonus * cultivationExpMultiplier * grottoBonus) * (player.reincarnationCount || 0);
}
function getEnlightenmentExpPerSecond() {
    // 每秒经验 = (当前每分钟经验 / 60) × 2 = 正常每秒经验的2倍
    const expPerMinute = getCultivationExpPerMinute();
    return (expPerMinute / 60) * 2;
}
function startEnlightenment() {
    if (!player.sect.created) { logAction("请先创建宗门！", "error"); return; }
    if (!player.cultivation) { logAction("请先开启修仙系统！", "error"); return; }
    if (player.sect.enlightenmentStart > 0) { logAction("已在悟道中！", "warning"); return; }
    if (player.sect.spiritStones < SECT_ENLIGHTENMENT_COST) { logAction(`宗门灵石不足！需要${(SECT_ENLIGHTENMENT_COST/10000)}万`, "error"); return; }
    player.sect.spiritStones -= SECT_ENLIGHTENMENT_COST;
    player.sect.enlightenmentStart = Date.now();
    logAction("开始悟道！2小时内持续获得修仙经验", "success");
    updateSectUI();
}
function processEnlightenmentTick() {
    if (!player.sect || !player.sect.created || !player.cultivation) return;
    const start = player.sect.enlightenmentStart || 0;
    if (start <= 0) return;
    const elapsed = Date.now() - start;
    if (elapsed >= SECT_ENLIGHTENMENT_DURATION) {
        player.sect.enlightenmentStart = 0;
        logAction("悟道结束", "info");
        return;
    }
    const expPerSec = getEnlightenmentExpPerSecond();
    player.cultivation.exp += expPerSec; // 每秒增加（由 gainCultivationExp 每秒调用）
}
function updateSectEnlightenmentUI() {
    const statusEl = document.getElementById('enlightenmentStatus');
    const costEl = document.getElementById('enlightenmentCost');
    const btnEl = document.getElementById('enlightenmentBtn');
    if (!player.sect.created || !statusEl) return;
    const start = player.sect.enlightenmentStart || 0;
    const isActive = start > 0;
    const elapsed = isActive ? Date.now() - start : 0;
    const remain = Math.max(0, SECT_ENLIGHTENMENT_DURATION - elapsed);
    const canStart = !isActive && player.sect.spiritStones >= SECT_ENLIGHTENMENT_COST;
    costEl.textContent = (SECT_ENLIGHTENMENT_COST / 10000) + '万';
    if (isActive) {
        statusEl.innerHTML = `<span style="color:#4CAF50;">悟道中...</span> 剩余: ${formatTimes(remain)} | 每秒+${getEnlightenmentExpPerSecond().toFixed(1)} 修仙经验`;
    } else {
        statusEl.innerHTML = '未悟道';
    }
    if (btnEl) { btnEl.disabled = !canStart || !player.cultivation; btnEl.textContent = isActive ? '悟道中' : '开始悟道'; }
}

// 宗门任务完成检查已由上方 setInterval（isCheckingMissions 防护）统一处理，此处删除重复定时器避免双倍执行与资源浪费
// 夜店系统数据结构
const nightClubConfig = {
    staffTypes: [
        { id: 'waiter', name: '服务员', baseExp: 0.5, baseCoins: 0.2, expPerLevel: 0.1, coinsPerLevel: 0.05, baseCost: 10 },
        { id: 'guard', name: '保安', baseExp: 0.3, baseCoins: 0.1, expPerLevel: 0.05, coinsPerLevel: 0.03, baseCost: 8 },
        { id: 'dj', name: 'DJ师', baseExp: 1.0, baseCoins: 0.5, expPerLevel: 0.2, coinsPerLevel: 0.1, baseCost: 20 },
        { id: 'chef', name: '厨师', baseExp: 0.4, baseCoins: 0.3, expPerLevel: 0.08, coinsPerLevel: 0.07, baseCost: 15 },
        { id: 'hostess', name: '小妹', baseExp: 0.7, baseCoins: 0.4, expPerLevel: 0.15, coinsPerLevel: 0.08, baseCost: 18 }
    ],
    equipmentTypes: [
        { id: 'sound', name: '音响系统', baseBonus: 1.05, bonusPerLevel: 0.05, baseCost: 50 },
        { id: 'light', name: '灯光系统', baseBonus: 1.03, bonusPerLevel: 0.03, baseCost: 40 },
        { id: 'bar', name: '吧台', baseBonus: 1.02, bonusPerLevel: 0.02, baseCost: 30 },
        { id: 'dancefloor', name: '舞池', baseBonus: 1.04, bonusPerLevel: 0.04, baseCost: 45 }
    ],
    vipConfig: {
        baseInterval: 30, // 分钟
        baseExp: 50,
        baseCoins: 25,
        levelMultiplier: 1.1
    },
    events: [
        { 
            name: "周末狂欢夜", 
            description: "激情音乐、炫酷灯光，打造周末不眠之夜！吸引大量年轻顾客涌入，现场气氛火爆。收益：经验获取速度3倍！", 
            effect: { expMultiplier: 3.0, duration: 60 },
            cost: 100 
        },
        { 
            name: "啤酒狂欢节", 
            description: "精选全球特色啤酒买一送一，搭配德式香肠拼盘，带来纯正欧陆风情体验。收益：金币收益提升50%！", 
            effect: { coinsMultiplier: 1.5, duration: 45 },
            cost: 75 
        },
     { 
            name: "闫闫魅惑之夜", 
            description: "国际超模闫闫领衔内衣大秀，水晶舞台搭配梦幻泡泡机，打造视觉盛宴。收益：金币收益暴涨400%！", 
            effect: { coinsMultiplier: 5.0, duration: 30 },
            cost: 100 
        },
      { 
            name: "茶茶烈焰舞台", 
            description: "亚洲舞后茶茶带来全新编舞，钢管舞与灯光艺术完美融合，限定特调鸡尾酒同步上市。收益：金币收益提升150%！", 
            effect: { coinsMultiplier: 2.5, duration: 30 },
            cost: 50 
        },
    { 
            name: "午夜折扣狂欢", 
            description: "零点后所有酒水买二送一，深夜食堂特色小食买一送一，打造深夜聚会圣地。收益：金币收益提升80%！", 
            effect: { coinsMultiplier: 1.8, duration: 40 },
            cost: 70 
        },
    { 
            name: "电音风暴派对", 
            description: "国际知名DJ现场打碟，激光矩阵与干冰特效，配备专业舞池震动装置。收益：经验获取7.5倍！", 
            effect: { expMultiplier: 7.5, duration: 30 },
            cost: 100 
        },
   { 
            name: "威士忌品鉴会", 
            description: "精选单一麦芽威士忌五折畅饮，配雪茄套餐，专业品酒师现场讲解。收益：金币收益提升120%！", 
            effect: { coinsMultiplier: 2.2, duration: 35 },
            cost: 50 
        },
      { 
            name: "泳池派对季", 
            description: "屋顶泳池派对限时开放，比基尼时装秀、水上飞人表演，特调热带鸡尾酒无限供应。收益：金币收益提升200%！", 
            effect: { coinsMultiplier: 3.0, duration: 40 },
            cost: 100 
        },
      { 
            name: "精英商务酒会", 
            description: "高端雪茄吧限时开放，陈年干邑买一送一，配备私人管家服务。收益：金币收益提升180%！", 
            effect: { coinsMultiplier: 2.8, duration: 35 },
            cost: 50 
        },
      { 
            name: "校园青春派对", 
            description: "学生证专属优惠，廉价啤酒畅饮套餐，街机游戏区免费开放。收益：经验获取3.2倍！", 
            effect: { expMultiplier: 3.2, duration: 55 },
            cost: 50 
        },
     { 
            name: "极光梦幻之夜", 
            description: "全息极光投影覆盖整个场馆，搭配空灵电子音乐，打造迷幻视觉盛宴。收益：经验获取7.2倍+金币收益2.8倍！", 
            effect: { expMultiplier: 7.2, coinsMultiplier: 2.8, duration: 35 },
            cost: 150 
        },
     { 
            name: "拳王争霸观赛", 
            description: "大型投影直播拳击赛事，拳击台造型卡座，能量饮料无限供应。收益：经验获取3.3倍！", 
            effect: { expMultiplier: 3.3, duration: 45 },
            cost: 60 
        },
     { 
            name: "黑色礼服之夜", 
            description: "正式着装限定派对， 茶茶在喷泉里洗澡，交响乐团现场演奏。收益：金币收益提升220%！", 
            effect: { coinsMultiplier: 3.2, duration: 40 },
            cost: 100 
        },
     { 
            name: "热带雨林探险", 
            description: "真实植物墙与人工瀑布，丛林动物音效，特色热带鸡尾酒。收益：经验获取5.7倍+金币收益1.9倍！", 
            effect: { expMultiplier: 5.7, coinsMultiplier: 1.9, duration: 55 },
            cost: 100 
        },
      { 
            name: "魔术大师秀", 
            description: "国际魔术冠军近距离表演，神秘道具展示，魔术主题特饮。收益：金币收益提升190%！", 
            effect: { coinsMultiplier: 2.9, duration: 35 },
            cost: 100 
        },
      { 
            name: "啤酒花园节", 
            description: "露天花园派对，30种精酿啤酒品尝，德式烤肠与pretzel。收益：经验获取5.0倍！", 
            effect: { expMultiplier: 5.0, duration: 60 },
            cost: 50 
        },
      { 
            name: "1920黄金时代", 
            description: "盖茨比风格派对，女郎表演，古董车展示。收益：金币收益提升240%！", 
            effect: { coinsMultiplier: 3.4, duration: 30 },
            cost: 60 
        },
       { 
            name: "高空露台电影", 
            description: "屋顶露天电影院，经典电影放映，懒人沙发与毛毯服务。收益：经验获取2.5倍！", 
            effect: { expMultiplier: 2.5, duration: 60 },
            cost: 40 
        },
       { 
            name: "龙舌兰日出", 
            description: "墨西哥主题派对，龙舌兰shot免费续杯，墨西哥卷饼自助。收益：金币收益提升170%！", 
            effect: { coinsMultiplier: 2.7, duration: 45 },
            cost: 100 
        },
      { 
            name: "科幻赛博朋克夜", 
            description: "赛博朋克未来风装饰，VR游戏体验，发光鸡尾酒。收益：经验获取6.8倍+金币收益2.5倍！", 
            effect: { expMultiplier: 6.8, coinsMultiplier: 2.5, duration: 40 },
            cost: 150 
        },
      { 
            name: "葡萄酒庄之旅", 
            description: "纳帕谷葡萄酒品尝，奶酪拼盘无限续，品酒师讲座。收益：金币收益提升210%！", 
            effect: { coinsMultiplier: 3.1, duration: 40 },
            cost: 50 
        },
      { 
            name: "卡拉OK冠军赛", 
            description: "专业级KTV设备，歌唱比赛有奖竞猜，气泡酒免费续杯。收益：经验获取3.9倍！", 
            effect: { expMultiplier: 3.9, duration: 60 },
            cost: 60 
        },
      { 
            name: "白色派对庆典", 
            description: "全白着装主题派对，泡沫机与雪花特效，冰雕vodka吧台。收益：金币收益提升190%！", 
            effect: { coinsMultiplier: 2.9, duration: 45 },
            cost: 100 
        },
      { 
            name: "密室逃脱之夜", 
            description: "真人密室游戏联动，线索收集换优惠，神秘特调隐藏菜单。收益：经验获取4.3倍！", 
            effect: { expMultiplier: 4.3, duration: 60 },
            cost: 70 
        },
       { 
            name: "生蚝生鲜吧", 
            description: "空运新鲜生蚝半价，专业开蚝师表演，白葡萄酒搭配。收益：金币收益提升130%！", 
            effect: { coinsMultiplier: 2.3, duration: 30 },
            cost: 60 
        },
      { 
            name: "哈利波特魔法夜", 
            description: "分院帽体验，黄油啤酒特供，魔杖决斗大赛。收益：经验获取6.0倍！", 
            effect: { expMultiplier: 6.0, duration: 30 },
            cost: 200 
        },
        { 
            name: "夏日冲浪派对", 
            description: "人工波浪机体验，比基尼时装秀，热带水果鸡尾酒。收益：金币收益提升180%！", 
            effect: { coinsMultiplier: 2.8, duration: 30 },
            cost: 70 
        },
     { 
            name: "爵士灵魂之夜", 
            description: "蓝调爵士乐队演出，复古唱片点播，经典马提尼。收益：经验获取4.8倍+金币收益2.1倍！", 
            effect: { expMultiplier: 4.8, coinsMultiplier: 2.1, duration: 50 },
            cost: 200 
        },
     { 
            name: "万圣惊魂夜", 
            description: "恐怖主题装饰，化妆比赛，限量血袋鸡尾酒。收益：金币收益提升140%！", 
            effect: { coinsMultiplier: 2.4, duration: 50 },
            cost: 80 
        },
       { 
            name: "威士忌收藏家", 
            description: "稀有威士忌品尝，雪茄套餐买一送一，专家讲解。收益：金币收益提升250%！", 
            effect: { coinsMultiplier: 3.5, duration: 30 },
            cost: 120 
        },
      { 
            name: "电子竞技联赛", 
            description: "大型赛事直播，电竞椅专属区，游戏主题特饮。收益：经验获取4.4倍！", 
            effect: { expMultiplier: 4.4, duration: 50 },
            cost: 150 
        },
     { 
            name: "极限运动嘉年华", 
            description: "室内滑板表演区，攀岩墙挑战，能量饮料赞助与运动明星见面会。收益：经验获取5.9倍+金币收益2.4倍！", 
            effect: { expMultiplier: 5.9, coinsMultiplier: 2.4, duration: 45 },
            cost: 200 
        },
     { 
            name: "白色情人节", 
            description: "浪漫装饰，情侣套餐买一送一，玫瑰花瓣雨。收益：金币收益提升230%！", 
            effect: { coinsMultiplier: 3.3, duration: 30 },
            cost: 70 
        },
       { 
            name: "睡衣派对", 
            description: "舒适睡衣主题，床头鸡尾酒，枕头大战区。收益：经验获取3.3倍！", 
            effect: { expMultiplier: 3.3, duration: 40 },
            cost: 50 
        },
        { 
            name: "黑金会员专属", 
            description: "会员专属通道，稀有威士忌品尝，手工雪茄免费派送。收益：金币收益提升260%！", 
            effect: { coinsMultiplier: 3.6, duration: 30 },
            cost: 100 
        },
       { 
            name: "夏威夷草裙舞", 
            description: "草裙舞表演教学，鲜花项链迎宾，热带水果鸡尾酒。收益：金币收益提升70%！", 
            effect: { coinsMultiplier: 1.7, duration: 30 },
            cost: 60 
        },
        { 
            name: "午夜拉面食堂", 
            description: "日式拉面宵夜，清酒买一送一，午夜限定菜单。收益：金币收益提升110%！", 
            effect: { coinsMultiplier: 2.1, duration: 30 },
            cost: 70 
        },
      { 
            name: "终极单身派对", 
            description: "速配游戏活动，爱情灵药特调，约会基金抽奖。收益：金币收益提升350%！", 
            effect: { coinsMultiplier: 4.5, duration: 30 },
            cost: 100 
        },
       { 
            name: "复古迪斯科之夜", 
            description: "70年代复古装扮派对，disco球与霓虹灯装饰，经典老歌串烧狂欢。收益：经验1.8倍+金币1.6倍！", 
            effect: { expMultiplier: 1.8, coinsMultiplier: 1.6, duration: 45 },
            cost: 150 
        },
        { 
            name: "巨星闪耀夜", 
            description: "特邀顶流明星驻场表演，红毯入场仪式+签名合影环节，钻石香槟塔无限供应。收益：经验获取4倍+金币收益2倍！", 
            effect: { expMultiplier: 4.0, coinsMultiplier: 2.0, duration: 30 },
            cost: 200 
        }
    ],
    levelExpRequirements: [200, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000, 50000000, 100000000]
};

// 初始化夜店系统
function initNightClubSystem() {
    if (!player.nightClub) {
        player.nightClub = {
            level: 1,
            exp: 0,
            starCoins: 0,
            staff: nightClubConfig.staffTypes.map(type => ({
                type: type.id,
                level: 1,
                expOutput: type.baseExp,
                coinsOutput: type.baseCoins
            })),
            equipment: nightClubConfig.equipmentTypes.map(type => ({
                type: type.id,
                level: 1,
                bonus: type.baseBonus
            })),
            vip: {
                lastVisit: 0,
                nextVisit: 0
            },
            activeEvent: null,
            lastUpdate: Date.now()
        };
    }
}

// 切换夜店系统界面
function toggleNightClubSystem() {
      if (player.reincarnationCount < 600) {
        alert("需要达到600转才能开启夜店系统！");
        return;
    }
    const overlay = document.getElementById('nightClubOverlay');
    const ui = document.getElementById('nightClubUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initNightClubSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        openNightClubTab('staff');
        updateNightClubUI();
    }
}

// 切换标签页
function openNightClubTab(tabName) {
    // 隐藏所有标签内容
    const tabcontents = document.getElementsByClassName('nightclub-tabcontent');
    for (let i = 0; i < tabcontents.length; i++) {
        tabcontents[i].style.display = 'none';
    }
    
    // 移除所有标签的活动状态
    const tablinks = document.getElementsByClassName('tablink');
    for (let i = 0; i < tablinks.length; i++) {
        tablinks[i].classList.remove('active');
    }
    
    // 显示当前标签内容并添加活动类
    document.getElementById('nightClub' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).style.display = 'block';
    event.currentTarget.classList.add('active');
    
    // 更新标签内容
    if (tabName === 'staff') {
        updateStaffTab();
    } else if (tabName === 'equipment') {
        updateEquipmentTab();
    } else if (tabName === 'special') {
        updateSpecialTab();
    } else if (tabName === 'events') {
        updateEventsTab();
    }
}

// 更新夜店系统UI
function updateNightClubUI() {
    // 更新店铺信息
    document.getElementById('nightClubLevel').textContent = player.nightClub.level;
    document.getElementById('nightClubExp').textContent = player.nightClub.exp.toFixed(1);
    
    const nextLevelExp = nightClubConfig.levelExpRequirements[player.nightClub.level - 1] || 
                         nightClubConfig.levelExpRequirements[nightClubConfig.levelExpRequirements.length - 1];
    document.getElementById('nightClubExpNext').textContent = nextLevelExp;
    
    const expPercent = Math.min(100, (player.nightClub.exp / nextLevelExp) * 100);
    document.getElementById('nightClubExpBar').style.width = expPercent + '%';
    
    document.getElementById('starCoinCount').textContent = player.nightClub.starCoins.toFixed(1);
    

    // 计算每分钟收益
    let totalExpPerMin = 0;
    let totalCoinsPerMin = 0;
    
    // 店员收益
    player.nightClub.staff.forEach(staff => {
        totalExpPerMin += staff.expOutput;
        totalCoinsPerMin += staff.coinsOutput;
    });
    
    // 设备加成
    let bonusMultiplier = 1;
    player.nightClub.equipment.forEach(eq => {
        bonusMultiplier *= eq.bonus;
    });
    
    // 活动加成
    if (player.nightClub.activeEvent) {
        if (player.nightClub.activeEvent.effect.expMultiplier) {
            totalExpPerMin *= player.nightClub.activeEvent.effect.expMultiplier;
        }
        if (player.nightClub.activeEvent.effect.coinsMultiplier) {
            totalCoinsPerMin *= player.nightClub.activeEvent.effect.coinsMultiplier;
        }
    }
    
    totalExpPerMin *= bonusMultiplier;
    totalCoinsPerMin *= bonusMultiplier;
    
    document.getElementById('expPerMinuteq').textContent = totalExpPerMin.toFixed(2);
    document.getElementById('coinsPerMinute').textContent = totalCoinsPerMin.toFixed(2);
}

// 更新店员标签页
function updateStaffTab() {
    const container = document.getElementById('nightClubStaff');
    container.innerHTML = '';
    
    player.nightClub.staff.forEach(staff => {
        const config = nightClubConfig.staffTypes.find(t => t.id === staff.type);
        const cost = calculateStaffUpgradeCost(staff.type);
        
        container.innerHTML += `
            <div class="staff-card" style="background: #222; border-radius: 8px; padding: 15px; border: 1px solid #444;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 style="margin: 0; color: #9C27B0;">${config.name}</h3>
                    <span>Lv.${staff.level}</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <div>经验产出: ${staff.expOutput.toFixed(3)}/分钟</div>
                    <div>星币产出: ${staff.coinsOutput.toFixed(3)}/分钟</div>
                </div>
                <button onclick="upgradeStaff('${staff.type}')" 
                        style="width: 100%; background: ${player.nightClub.starCoins >= cost ? '#4CAF50' : '#f44336'}; 
                               color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;"
                        ${player.nightClub.starCoins < cost ? 'disabled' : ''}>
                    升级 (${cost}星币)
                </button>
            </div>
        `;
    });
}

// 计算店员升级成本
function calculateStaffUpgradeCost(staffType) {
    const staff = player.nightClub.staff.find(s => s.type === staffType);
    const config = nightClubConfig.staffTypes.find(t => t.id === staffType);
    return Math.floor(config.baseCost * Math.pow(1.5, staff.level - 1));
}

// 升级店员
function upgradeStaff(staffType) {
    const staff = player.nightClub.staff.find(s => s.type === staffType);
    const config = nightClubConfig.staffTypes.find(t => t.id === staffType);
    const cost = calculateStaffUpgradeCost(staffType);
    
    if (player.nightClub.starCoins < cost) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= cost;
    staff.level++;
    staff.expOutput = config.baseExp + (config.expPerLevel * (staff.level - 1));
    staff.coinsOutput = config.baseCoins + (config.coinsPerLevel * (staff.level - 1));
    
    logAction(`${config.name}升级到Lv.${staff.level}！`, "success");
    updateNightClubUI();
    updateStaffTab();
}

// 更新设备标签页
function updateEquipmentTab() {
    const container = document.getElementById('nightClubEquipment');
    container.innerHTML = '';
    
    player.nightClub.equipment.forEach(eq => {
        const config = nightClubConfig.equipmentTypes.find(t => t.id === eq.type);
        const cost = calculateEquipmentUpgradeCost(eq.type);
        
        container.innerHTML += `
            <div class="equipment-card" style="background: #222; border-radius: 8px; padding: 15px; border: 1px solid #444;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 style="margin: 0; color: #9C27B0;">${config.name}</h3>
                    <span>Lv.${eq.level}</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <div>全局加成: ${(eq.bonus * 100 - 100).toFixed(1)}%</div>
                </div>
                <button onclick="upgradeEquipment('${eq.type}')" 
                        style="width: 100%; background: ${player.nightClub.starCoins >= cost ? '#4CAF50' : '#f44336'}; 
                               color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;"
                        ${player.nightClub.starCoins < cost ? 'disabled' : ''}>
                    升级 (${cost}星币)
                </button>
            </div>
        `;
    });
}

// 计算设备升级成本
function calculateEquipmentUpgradeCost(eqType) {
    const eq = player.nightClub.equipment.find(e => e.type === eqType);
    const config = nightClubConfig.equipmentTypes.find(t => t.id === eqType);
    return Math.floor(config.baseCost * Math.pow(1.8, eq.level - 1));
}

// 升级设备
function upgradeEquipment(eqType) {
    const eq = player.nightClub.equipment.find(e => e.type === eqType);
    const config = nightClubConfig.equipmentTypes.find(t => t.id === eqType);
    const cost = calculateEquipmentUpgradeCost(eqType);
    
    if (player.nightClub.starCoins < cost) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= cost;
    eq.level++;
    eq.bonus = config.baseBonus + (config.bonusPerLevel * (eq.level - 1));
    
    logAction(`${config.name}升级到Lv.${eq.level}！`, "success");
    updateNightClubUI();
    updateEquipmentTab();
}

// 更新特殊人群标签页
function updateSpecialTab() {
    const container = document.getElementById('nightClubSpecial');
    const vipInfo = document.getElementById('vipInfo');
    
    // 计算VIP下次到访时间
    const now = Date.now();
    const timeSinceLastVisit = (now - player.nightClub.vip.lastVisit) / (1000 * 60); // 分钟
    const timeUntilNextVisit = Math.max(0, player.nightClub.vip.nextVisit - now);
    
    vipInfo.innerHTML = `
        <div style="margin-bottom: 10px;">
            <strong>下次VIP到访:</strong> 
            ${timeUntilNextVisit > 0 ? 
                `<span id="vipTimer">${formatTime(timeUntilNextVisit)}</span>` : 
                "VIP随时可能光临！"}
        </div>
    `;
    
    // 如果VIP即将到来，启动计时器
    if (timeUntilNextVisit > 0) {
        startVipTimer();
    }
}

// 格式化时间
function formatTime(ms) {
    const minutes = Math.floor(ms / (1000 * 60));
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    return `${minutes}分${seconds}秒`;
}

// 启动VIP计时器
function startVipTimer() {
    if (window.vipTimer) clearInterval(window.vipTimer);
    
    window.vipTimer = registerInterval(() => {
        const now = Date.now();
        const timeUntilNextVisit = Math.max(0, player.nightClub.vip.nextVisit - now);
        
        if (timeUntilNextVisit <= 0) {
            clearInterval(window.vipTimer);
            document.getElementById('vipTimer').textContent = "VIP已到达！";
            triggerVipVisit();
        } else {
            document.getElementById('vipTimer').textContent = formatTime(timeUntilNextVisit);
        }
    }, 1000);
}

// 触发VIP访问
function triggerVipVisit() {
    const baseExp = nightClubConfig.vipConfig.baseExp;
    const baseCoins = nightClubConfig.vipConfig.baseCoins;
    const multiplier = Math.pow(nightClubConfig.vipConfig.levelMultiplier, player.nightClub.level - 1);
    
    const expGain = Math.floor(baseExp * multiplier);
    const coinsGain = Math.floor(baseCoins * multiplier);
    
    player.nightClub.exp += expGain;
    player.nightClub.starCoins += coinsGain;
    
    // 设置下次访问时间
    const now = Date.now();
    player.nightClub.vip.lastVisit = now;
    player.nightClub.vip.nextVisit = now + (nightClubConfig.vipConfig.baseInterval * 60 * 1000);
    
    logAction(`VIP光临！获得${expGain}经验和${coinsGain}星币！`, "success");
    updateNightClubUI();
    updateSpecialTab();
    checkNightClubLevelUp();
}

// 更新事件标签页
function updateEventsTab() {
    const container = document.getElementById('nightClubEvents');
    const currentEventDiv = document.getElementById('currentEvent');
    
    if (player.nightClub.activeEvent) {
        const timeLeft = Math.max(0, player.nightClub.activeEvent.endTime - Date.now());
        currentEventDiv.innerHTML = `
            <div style="background: #333; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <h4 style="margin-top: 0; color: #FFD700;">${player.nightClub.activeEvent.name}</h4>
                <p>${player.nightClub.activeEvent.description}</p>
                <div>剩余时间: ${formatTime(timeLeft)}</div>
            </div>
        `;
    } else {
        currentEventDiv.innerHTML = "<p>当前没有活跃事件</p>";
    }
}

// 触发随机事件
function triggerRandomEventa() {
    if (player.nightClub.activeEvent) {
        logAction("当前已有活跃事件！", "error");
        return;
    }
    
    const randomEvent = nightClubConfig.events[Math.floor(Math.random() * nightClubConfig.events.length)];
    
    if (player.nightClub.starCoins < randomEvent.cost) {
        logAction(`星币不足！需要${randomEvent.cost}星币`, "error");
        return;
    }
    
    player.nightClub.starCoins -= randomEvent.cost;
    player.nightClub.activeEvent = {
        name: randomEvent.name,
        description: randomEvent.description,
        effect: randomEvent.effect,
        startTime: Date.now(),
        endTime: Date.now() + (randomEvent.effect.duration * 60 * 1000)
    };
    
    logAction(`已启动事件: ${randomEvent.name}！`, "success");
    updateNightClubUI();
    updateEventsTab();
}

// 检查店铺升级
function checkNightClubLevelUp() {
    const nextLevelExp = nightClubConfig.levelExpRequirements[player.nightClub.level - 1];
    
    if (player.nightClub.exp >= nextLevelExp && player.nightClub.level < nightClubConfig.levelExpRequirements.length) {
        player.nightClub.level++;
        player.nightClub.exp -= nextLevelExp;
        logAction(`店铺升级到Lv.${player.nightClub.level}！`, "success");
        updateNightClubUI();
    }
}

// 每分钟计算夜店收益
function calculateNightClubIncome() {
    if (!player.nightClub) return;
    
    const now = Date.now();
    const elapsedMinutes = (now - player.nightClub.lastUpdate) / (1000 * 60);
    
    if (elapsedMinutes < 1) return;
    
    let totalExp = 0;
    let totalCoins = 0;
    
    // 计算店员收益
    player.nightClub.staff.forEach(staff => {
        totalExp += staff.expOutput * elapsedMinutes;
        totalCoins += staff.coinsOutput * elapsedMinutes;
    });
    
    // 应用设备加成
    let bonusMultiplier = 1;
    player.nightClub.equipment.forEach(eq => {
        bonusMultiplier *= eq.bonus;
    });
    
    // 应用活动加成
    if (player.nightClub.activeEvent) {
        if (player.nightClub.activeEvent.effect.expMultiplier) {
            totalExp *= player.nightClub.activeEvent.effect.expMultiplier;
        }
        if (player.nightClub.activeEvent.effect.coinsMultiplier) {
            totalCoins *= player.nightClub.activeEvent.effect.coinsMultiplier;
        }
        
        // 检查事件是否结束
        if (now > player.nightClub.activeEvent.endTime) {
            logAction(`事件"${player.nightClub.activeEvent.name}"已结束`, "info");
            player.nightClub.activeEvent = null;
        }
    }
    
    totalExp *= bonusMultiplier;
    totalCoins *= bonusMultiplier;
    
    player.nightClub.exp += totalExp;
    player.nightClub.starCoins += totalCoins;
    player.nightClub.lastUpdate = now;
    
    // 检查VIP访问
    if (now > player.nightClub.vip.nextVisit) {
        triggerVipVisit();
    }
    
    // 检查店铺升级
    checkNightClubLevelUp();
    
    // 更新UI（如果界面打开）
    if (document.getElementById('nightClubUI').style.display === 'block') {
        updateNightClubUI();
    }
}

// 杂货铺功能
function toggleGroceriesUI() {
if (player.reincarnationCount < 400) {
        alert("需要达到400转才能开启杂货铺！");
        return;
    }
    const ui = document.getElementById('groceriesUI');
    const overlay = document.getElementById('groceriesOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateGroceriesUI();
    }
}

function updateGroceriesUI() {
    // 更新星尘数量显示
    document.getElementById('currentStardust').textContent = player.exploration.resources.stardust;
}

function exchangeStardust(type) {
    const exchangeRates = {
        bait: { cost: 100, item: 'baitCount', amount: parseInt(document.getElementById('baitAmount').value), coinRate: 2 },
        key: { cost: 200, item: 'companionKey', amount: parseInt(document.getElementById('keyAmount').value) },
        rose: { cost: 100, item: 'rose', amount: parseInt(document.getElementById('roseAmount').value), coinRate: 20 },
        vip: { cost: 100, item: 'vipPower', amount: parseInt(document.getElementById('vipAmount').value), coinRate: 10 },
        gem: { cost: 5000, item: 'divineGem', amount: parseInt(document.getElementById('gemAmount').value) },
        root: { cost: 500, item: 'rootDetector', amount: parseInt(document.getElementById('rootAmount').value) },
        blood: { cost: 500, item: 'bloodlineDetector', amount: parseInt(document.getElementById('bloodAmount').value) },
        coin: { cost: 100, item: 'reincarnationCoin', amount: parseInt(document.getElementById('coinAmount').value), coinRate: 1000000 }
    };
    
    const config = exchangeRates[type];
    if (!config) return;
    
    // 输入验证
    if (isNaN(config.amount) || config.amount <= 0) {
        logAction("请输入有效的兑换数量！", "error");
        return;
    }
    
    const totalCost = config.cost * config.amount;
    const stardust = player.exploration.resources.stardust;
    
    if (stardust < totalCost) {
        logAction("星尘不足！", "error");
        return;
    }
    
    player.exploration.resources.stardust -= totalCost;
    
    // 修复点：所有带coinRate的物品都应用倍数
    const multiplier = config.coinRate || 1;
    const actualAmount = config.amount * multiplier;
    
    if (type === 'coin') {
        player[config.item] += actualAmount;
    } else {
        player.items[config.item] = (player.items[config.item] || 0) + actualAmount;
    }
    
    logAction(`成功兑换: ${actualAmount}${getItemName(type)}`, "success");
    updateGroceriesUI();
    updateDisplay();
    saveGame();
}

function getItemName(type) {
    const names = {
        bait: "鱼饵",
        key: "伴侣钥匙",
        rose: "玫瑰花",
        vip: "VIP能力值",
        gem: "神级宝石",
       root: "灵根检测器",
       blood: "血脉检测剂",
        coin: "转生币"
    };
    return names[type] || "物品";
}
// 切换等级系统界面
function toggleLevelSystem() {
   if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启玩家等级！");
        return;
    }
    const overlay = document.getElementById('levelSystemOverlay');
    const ui = document.getElementById('levelSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateLevelUI();
        updateDisplay();
    }
}
function ascendPlayer() {
    // 计算下次飞升所需等级
    const nextAscentionLevel = (player.level.ascentionCount + 1) * 100;
    
    // 检查是否满足飞升条件
    if (player.level.current < nextAscentionLevel) {
        logAction(`飞升需要等级${nextAscentionLevel}！当前等级${player.level.current}。`, "error");
        return;
    }
    
    // 执行飞升
    player.level.ascentionCount++;
    player.level.ascentionMultiplier =player.level.ascentionCount+1; // 属性加成
    player.level.current = 1; // 等级重置为1
    player.level.exp = 0;
    player.level.nextLevelExp = 10000;
    
    // 更新加成
    player.level.clickBonus = 1 * player.level.ascentionMultiplier* player.level.ascentionMultipliera;
    player.level.gpsBonus = 1 * player.level.ascentionMultiplier* player.level.ascentionMultipliera;
    
    logAction(`飞升成功！当前飞升次数：${player.level.ascentionCount}，加成倍数：${player.level.ascentionMultiplier}`, "success");
    updateLevelUI();
    updateDisplay();
}
function ascendPlayera() {
    // 计算下次轮回所需等级
    const nextAscentionLevela = (player.level.ascentionCounta + 1) * 10;
    
    // 检查是否满足轮回条件
    if (player.level.ascentionCount < nextAscentionLevela) {
        logAction(`轮回需要飞升次数${nextAscentionLevela}！当前飞升次数${player.level.ascentionCounta}。`, "error");
        return;
    }
    
    // 执行飞升
    player.level.ascentionCounta++;
    player.level.ascentionMultipliera =player.level.ascentionCounta*2; // 属性加成
    player.level.current = 1; // 等级重置为1
    player.level.ascentionCount= 0;
    player.level.ascentionMultiplier= 1;
    player.level.exp = 0;
    player.level.nextLevelExp = 10000;
    
    // 更新加成
    player.level.clickBonus = 1 * player.level.ascentionMultiplier* player.level.ascentionMultipliera;
    player.level.gpsBonus = 1 * player.level.ascentionMultiplier* player.level.ascentionMultipliera;
    
    logAction(`飞升成功！当前轮回次数：${player.level.ascentionCounta}，加成倍数：${player.level.ascentionMultipliera}`, "success");
    updateLevelUI();
    updateDisplay();
}
// 更新等级界面
function updateLevelUI() {
    document.getElementById('currentPlayerLevel').textContent = player.level.current;
    document.getElementById('currentPlayerExp').textContent = player.level.exp.toFixed(0);
    document.getElementById('nextLevelExpq').textContent = player.level.nextLevelExp.toFixed(0);
    document.getElementById('clickBonus').textContent = player.level.clickBonus.toFixed(0) + '倍';
    document.getElementById('gpsBonus').textContent =  player.level.gpsBonus.toFixed(0) + '倍';
     document.getElementById("ascentionCount").textContent = player.level.ascentionCount;
    document.getElementById("ascentionMultiplier").textContent = player.level.ascentionMultiplier + "倍";
    document.getElementById("nextAscentionRequirement").textContent = (player.level.ascentionCount + 1) * 100;
     document.getElementById("ascentionCounta").textContent = player.level.ascentionCounta;
    document.getElementById("ascentionMultipliera").textContent = player.level.ascentionMultipliera + "倍";
    document.getElementById("nextAscentionRequirementa").textContent = (player.level.ascentionCounta + 1) * 10;
    const progress = (player.level.exp / player.level.nextLevelExp) * 100;
    document.getElementById('playerExpProgress').style.width = progress + '%';
}

// 升级玩家等级
function upgradePlayerLevel(amount) {
    for (let i = 0; i < amount; i++) {
        if (player.level.exp >= player.level.nextLevelExp) {
            player.level.exp -= player.level.nextLevelExp;
            player.level.current++;
            
            // 计算下一级所需经验
            player.level.nextLevelExp = (10000 * player.level.current) * (1+player.level.ascentionCounta*2) ;
            
            // 计算加成，考虑飞升倍数
            player.level.clickBonus = player.level.current * 1 * player.level.ascentionMultiplier * player.level.ascentionMultipliera;
            player.level.gpsBonus = player.level.current * 1 * player.level.ascentionMultiplier * player.level.ascentionMultipliera;
            
            logAction(`玩家等级提升至 ${player.level.current}级！`, 'success');
             // 检查轮回条件
            const nextAscentionLevela = (player.level.ascentionCounta + 1) * 10;
            if (player.level.ascentionCounta === nextAscentionLevela) {
                logAction(`已达到第${player.level.ascentionCounta + 1}次轮回条件，可进行轮回！`, 'info');
            }
            // 检查飞升条件
            const nextAscentionLevel = (player.level.ascentionCount + 1) * 100;
            if (player.level.current === nextAscentionLevel) {
                logAction(`已达到第${player.level.ascentionCount + 1}次飞升条件，可进行飞升！`, 'info');
            }
        } else {
            logAction("经验不足，无法升级！", "error");
            break;
        }
    }
    updateLevelUI();
    updateDisplay();
}

// 添加经验
function addPlayerExp(amount) {
    player.level.exp += amount;
    
    // 检查是否可以升级
    while (player.level.exp >= player.level.nextLevelExp) {
        upgradePlayerLevel(1);
    }
    
    updateLevelUI();
}
// 翅膀品阶配置
const wingRarities = {
    "劣质级": { healthRange: [0.01, 0.20], color: "gray", namePrefix: "破损的" },
    "普通级": { healthRange: [0.10, 0.50], color: "white", namePrefix: "普通的" },
    "优秀级": { healthRange: [0.15, 1.00], color: "green", namePrefix: "优秀的" },
    "精良级": { healthRange: [0.20, 2.00], color: "blue", namePrefix: "精良的" },
    "卓越级": { healthRange: [0.30, 3.00], color: "purple", namePrefix: "卓越的" },
    "史诗级": { healthRange: [0.50, 4.00], color: "gold", namePrefix: "史诗的" },
    "传说级": { healthRange: [1.00, 5.00], color: "orange", namePrefix: "传说的" },
    "神圣级": { healthRange: [1.00, 7.00], color: "pink", namePrefix: "神圣的" },
    "不朽级": { healthRange: [2.00, 10.00], color: "red", namePrefix: "不朽的" }
};

// 翅膀名字词库
const wingNameParts = {
    prefixes: ["暗影", "光明", "烈焰", "冰霜", "雷霆", "风暴", "星辰", "月光", "太阳", "虚空", "黑暗", "邪恶", "未来", "米白色"],
    suffixes: ["之翼", "翅膀", "羽翼", "飞翼", "光翼", "暗翼", "龙翼", "凤翼", "天使翼", "恶魔翼", "神翼", "魔翼", "背包", "飞艇"]
};

// 次元掉落概率配置
const wingDropRates = {
    2: { // 次元2
        "劣质级": 0.9,
        "普通级": 0.09,
        "优秀级": 0.01
    },
    3: { // 次元3
        "劣质级": 0.6,
        "普通级": 0.3,
        "优秀级": 0.07,
        "精良级": 0.02,
        "卓越级": 0.01
    },
    4: { // 次元4
        "优秀级": 0.56,
        "精良级": 0.3,
        "卓越级": 0.1,
        "史诗级": 0.03,
        "传说级": 0.01
    },
    5: { // 次元5
        "精良级": 0.5,
        "卓越级": 0.3,
        "史诗级": 0.14,
        "传说级": 0.05,
        "神圣级": 0.009,
        "不朽级": 0.001
    },
  6: { // 次元5
        "卓越级": 0.60,
        "史诗级": 0.20,
        "传说级": 0.10,
        "神圣级": 0.09,
        "不朽级": 0.01
    },
  7: { // 次元5
        "史诗级": 0.70,
        "传说级": 0.20,
        "神圣级": 0.09,
        "不朽级": 0.01
    },
  8: { // 次元5
        "传说级": 0.90,
        "神圣级": 0.09,
        "不朽级": 0.01
    }
};
// 切换翅膀系统界面
function toggleWingSystem() {
    if (player.level.ascentionCounta < 1) {
        alert("需要达到轮回1转才能开启翅膀系统！");
        return;
    }
    const overlay = document.getElementById('wingSystemOverlay');
    const ui = document.getElementById('wingSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateWingUI();
    }
}

// 生成随机翅膀名字
function generateWingName(rarity) {
    const prefix = wingNameParts.prefixes[Math.floor(Math.random() * wingNameParts.prefixes.length)];
    const suffix = wingNameParts.suffixes[Math.floor(Math.random() * wingNameParts.suffixes.length)];
    return wingRarities[rarity].namePrefix + prefix + suffix;
}

// 生成随机翅膀
function generateRandomWing(dimensionLevel) {
    if (dimensionLevel === 1) return null; // 次元1不掉落翅膀
    
    const dropRates = wingDropRates[dimensionLevel];
    if (!dropRates) return null;
    
    // 根据概率随机选择品阶
    let rand = Math.random();
    let cumulativeProb = 0;
    
    for (const [rarity, prob] of Object.entries(dropRates)) {
        cumulativeProb += prob;
        if (rand < cumulativeProb) {
            const rarityConfig = wingRarities[rarity];
            const healthBonus = Math.random() * (rarityConfig.healthRange[1] - rarityConfig.healthRange[0]) + rarityConfig.healthRange[0];
            
            return {
                id: 'wing_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                name: generateWingName(rarity),
                rarity: rarity,
                healthBonus: healthBonus,
                color: rarityConfig.color,
               locked: false
            };
        }
    }
    
    return null;
}
function toggleWingLock(wingId) {
    const wing = player.wings.inventory.find(w => w.id === wingId);
    if (wing) {
        wing.locked = !wing.locked;
        const action = wing.locked ? "锁定" : "解锁";
        logAction(`${action}了翅膀：${wing.name}`, 'success');
        updateWingUI();
    }
}
// 掉落翅膀（在世界地图怪物死亡时调用）
function dropWing() {
    const dimensionLevel = player.dimensionLevel;
    if (dimensionLevel === 1) return; // 次元1不掉落
    
    if (Math.random() < 0.001) { // 1%掉落几率
        const newWing = generateRandomWing(dimensionLevel);
        if (newWing) {
            player.wings.inventory.push(newWing);
            logAction(`获得翅膀：${newWing.name}（${newWing.rarity}）`, 'success');
            updateWingUI();
        }
    }
}
// 装备翅膀
function equipWing(wingId) {
    const wing = player.wings.inventory.find(w => w.id === wingId);
    if (wing) {
        player.wings.equipped = wingId;
        logAction(`装备了翅膀：${wing.name}`, 'success');
        updateWingUI();
        updatePlayerBattleStats(); // 更新玩家属性
    }
}

// 卸下翅膀
function unequipWing() {
    player.wings.equipped = null;
    logAction("已卸下翅膀", 'info');
    updateWingUI();
    updatePlayerBattleStats();
}
// 当前筛选条件
let currentWingFilter = 'all';

// 筛选翅膀
function filterWings() {
    currentWingFilter = document.getElementById('wingRarityFilter').value;
    updateWingUI();
}

// 一键分解当前筛选条件下的所有翅膀（不包括已装备的）
function decomposeAllFilteredWings() {
    // 获取当前筛选条件下的翅膀
    let wingsToDecompose = [];
    if (currentWingFilter === 'all') {
        wingsToDecompose = player.wings.inventory.filter(wing => 
            wing.id !== player.wings.equipped && !wing.locked
        );
    } else {
        wingsToDecompose = player.wings.inventory.filter(wing => 
            wing.rarity === currentWingFilter && wing.id !== player.wings.equipped && !wing.locked
        );
    }
    
    if (wingsToDecompose.length === 0) {
        logAction("没有可分解的翅膀", "info");
        return;
    }
    
    // 计算总奖励
    let totalRebornDan = 0;
    wingsToDecompose.forEach(wing => {
        totalRebornDan += getRebornDanByRarity(wing.rarity);
    });
    
    // 显示确认对话框
    showCustomConfirm(`确定要分解${wingsToDecompose.length}个${currentWingFilter === 'all' ? '' : currentWingFilter}翅膀吗？将获得${totalRebornDan}个洗髓丹`, (confirmed) => {
        if (confirmed) {
            // 执行分解
            wingsToDecompose.forEach(wing => {
                const wingIndex = player.wings.inventory.findIndex(w => w.id === wing.id);
                if (wingIndex !== -1) {
                    player.wings.inventory.splice(wingIndex, 1);
                }
            });
            
            // 添加奖励
            player.items.rebornDan = (player.items.rebornDan || 0) + totalRebornDan;
            
            logAction(`一键分解了${wingsToDecompose.length}个翅膀，获得${totalRebornDan}个洗髓丹`, 'success');
            updateWingUI();
            updateItemDisplay();
        }
    });
}

// 根据翅膀品质获取洗髓丹数量
function getRebornDanByRarity(rarity) {
    switch(rarity) {
        case '劣质级': return 1;
        case '普通级': return 1;
        case '优秀级': return 2;
        case '精良级': return 3;
        case '卓越级': return 5;
        case '史诗级': return 10;
        case '传说级': return 20;
        case '神圣级': return 50;
        case '不朽级': return 100;
        default: return 1;
    }
}
// 分解翅膀
function decomposeWing(wingId) {
    const wingIndex = player.wings.inventory.findIndex(w => w.id === wingId);
    if (wingIndex === -1) return;
    
    const wing = player.wings.inventory[wingIndex];
    
    if (wing.locked) {
        logAction("翅膀已锁定，无法分解", "error");
        return;
    }
        
        // 根据品阶获得不同数量的洗髓丹
        let rebornDanReward = 1;
        switch(wing.rarity) {
            case '普通级': rebornDanReward = 1; break;
            case '优秀级': rebornDanReward = 2; break;
            case '精良级': rebornDanReward = 3; break;
            case '卓越级': rebornDanReward = 5; break;
            case '史诗级': rebornDanReward = 10; break;
            case '传说级': rebornDanReward = 20; break;
            case '神圣级': rebornDanReward = 50; break;
            case '不朽级': rebornDanReward = 100; break;
        }
        
        player.items.rebornDan = (player.items.rebornDan || 0) + rebornDanReward;
        
        // 如果分解的是当前装备的翅膀，先卸下
        if (player.wings.equipped === wingId) {
            player.wings.equipped = null;
        }
        
        player.wings.inventory.splice(wingIndex, 1);
        
        logAction(`分解了翅膀：${wing.name}，获得${rebornDanReward}个洗髓丹`, 'success');
        updateWingUI();
        updatePlayerBattleStats();
        updateItemDisplay();
    }


// 升级翅膀等级
function upgradeWing() {
    const cost = player.wings.upgradeCost;
    
    if ((player.items.chiban1 || 0) >= cost) {
        player.items.chiban1 -= cost;
        player.wings.level++;
        player.wings.upgradeCost += 5; // 每次升级增加5个消耗
        
        logAction(`翅膀等级提升至 ${player.wings.level}级，属性加成提升至 ${player.wings.level * 100}%`, 'success');
        updateWingUI();
        updatePlayerBattleStats();
        updateItemDisplay();
    } else {
        logAction(`黑龙王翅膀不足！需要${cost}个`, 'error');
    }
}

// 更新翅膀界面显示
function updateWingUI() {
    // 更新当前装备的翅膀信息
    const currentWingInfo = document.getElementById('currentWingInfo');
    if (player.wings.equipped) {
        const equippedWing = player.wings.inventory.find(w => w.id === player.wings.equipped);
        if (equippedWing) {
            currentWingInfo.innerHTML = `
                <div style="color: ${equippedWing.color}">
                    ${equippedWing.name}（${equippedWing.rarity}）
                </div>
                <div>生命加成: +${(equippedWing.healthBonus * 100).toFixed(1)}%</div>
                <div>总加成: +${(equippedWing.healthBonus * player.wings.level * 100).toFixed(1)}%</div>
                <button onclick="unequipWing()" style="margin-top: 5px;">卸下</button>
            `;
        }
    } else {
        currentWingInfo.innerHTML = '无装备的翅膀';
    }
    
    // 更新翅膀等级信息
    document.getElementById('wingLevel').textContent = player.wings.level;
    document.getElementById('wingBonus').textContent = (player.wings.level * 100) + '%';
    document.getElementById('wingUpgradeCost').textContent = player.wings.upgradeCost;
    
    // 更新翅膀仓库（根据筛选条件）
    const wingInventory = document.getElementById('wingInventory');
    wingInventory.innerHTML = '';
    
    let filteredWings = player.wings.inventory;
    if (currentWingFilter !== 'all') {
        filteredWings = player.wings.inventory.filter(wing => wing.rarity === currentWingFilter);
    }
    
    if (filteredWings.length === 0) {
        wingInventory.innerHTML = '<div style="text-align: center; color: #888;">暂无翅膀</div>';
    } else {
         filteredWings.forEach(wing => {
        const isEquipped = player.wings.equipped === wing.id;
        const wingElement = document.createElement('div');
        wingElement.style.cssText = `
            padding: 10px;
            margin: 5px 0;
            background: #444;
            border-radius: 5px;
            border-left: 4px solid ${wing.color};
            ${isEquipped ? 'border: 2px solid gold;' : ''}
            ${wing.locked ? 'border-right: 4px solid red;' : ''}
        `;
        
        wingElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="color: ${wing.color}; font-weight: bold;">
                    ${wing.name}（${wing.rarity}）
                </div>
                <div>
                    <button onclick="toggleWingLock('${wing.id}')" style="background: ${wing.locked ? '#f44336' : '#4CAF50'}; color: white; border: none; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                        ${wing.locked ? '已锁定' : '未锁定'}
                    </button>
                </div>
            </div>
            <div>生命加成: +${(wing.healthBonus * 100).toFixed(1)}%</div>
            <div>总加成: +${(wing.healthBonus * player.wings.level * 100).toFixed(1)}%</div>
            <div style="margin-top: 5px;">
                ${!isEquipped ? `<button onclick="equipWing('${wing.id}')">装备</button>` : '<span style="color: gold;">已装备</span>'}
                <button onclick="decomposeWing('${wing.id}')" style="margin-left: 5px; background: #f44336;" ${wing.locked ? 'disabled' : ''}>分解</button>
            </div>
        `;
        
        wingInventory.appendChild(wingElement);
    });
    }
}
// 坐骑配置
const mountRarities = {
    "劣质级": { 
        name: "劣质", 
        color: "gray", 
        statRange: { health: [0.01, 0.10], attack: [0.01, 0.10], critDamage: [0.01, 0.10] },
        statChance: 0.2 // 20%几率获得额外词条
    },
    "普通级": { 
        name: "普通", 
        color: "white", 
        statRange: { health: [0.05, 0.20], attack: [0.05, 0.20], critDamage: [0.05, 0.20] },
        statChance: 0.3
    },
    "优秀级": { 
        name: "优秀", 
        color: "green", 
        statRange: { health: [0.10, 0.30], attack: [0.10, 0.30], critDamage: [0.10, 0.30] },
        statChance: 0.4
    },
    "精良级": { 
        name: "精良", 
        color: "blue", 
        statRange: { health: [0.20, 0.40], attack: [0.20, 0.40], critDamage: [0.20, 0.40] },
        statChance: 0.5
    },
    "卓越级": { 
        name: "卓越", 
        color: "purple", 
        statRange: { health: [0.30, 0.50], attack: [0.30, 0.50], critDamage: [0.30, 0.50] },
        statChance: 0.6
    },
    "史诗级": { 
        name: "史诗", 
        color: "gold", 
        statRange: { health: [0.40, 0.80], attack: [0.40, 0.80], critDamage: [0.40, 0.80] },
        statChance: 0.7
    },
    "传说级": { 
        name: "传说", 
        color: "orange", 
        statRange: { health: [0.50, 1.00], attack: [0.50, 1.00], critDamage: [0.50, 1.00] },
        statChance: 0.8
    },
    "神圣级": { 
        name: "神圣", 
        color: "pink", 
        statRange: { health: [1.00, 2.00], attack: [1.00, 2.00], critDamage: [1.00, 2.00] },
        statChance: 0.9
    },
    "不朽级": { 
        name: "不朽", 
        color: "red", 
        statRange: { health: [2.00, 3.00], attack: [2.00, 3.00], critDamage: [2.00, 3.00] },
        statChance: 1.0
    }
};

// 坐骑名字部件
const mountNameParts = {
    prefixes: ["暗影", "光明", "烈焰", "冰霜", "雷霆", "风暴", "星辰", "月光", "太阳", "虚空", "黑暗", "邪恶", "未来", "米白色"],
    types: ["战马", "龙驹", "麒麟", "狮鹫", "猛虎", "巨狼", "神鹰", "灵狐", "玄龟", "凤凰", "独角兽", "梦魇", "地狱", "天界"],
    suffixes: ["之王", "之后", "之魂", "之灵", "之怒", "之翼", "之爪", "之牙", "之心", "之眼"]
};

// 坐骑掉落概率配置
const mountDropRates = {
    3: { // 次元3
        "劣质级": 0.6,
        "普通级": 0.3,
        "优秀级": 0.07,
        "精良级": 0.02,
        "卓越级": 0.01
    },
    4: { // 次元4
        "优秀级": 0.56,
        "精良级": 0.3,
        "卓越级": 0.1,
        "史诗级": 0.03,
        "传说级": 0.01
    },
    5: { // 次元5
        "精良级": 0.5,
        "卓越级": 0.3,
        "史诗级": 0.14,
        "传说级": 0.05,
        "神圣级": 0.009,
        "不朽级": 0.001
    },
  6: { // 次元6
        "卓越级": 0.40,
        "史诗级": 0.30,
        "传说级": 0.20,
        "神圣级": 0.09,
        "不朽级": 0.01
    },
  7: { // 次元7
        "史诗级": 0.70,
        "传说级": 0.20,
        "神圣级": 0.09,
        "不朽级": 0.01
    },
  8: { // 次元8
        "传说级": 0.90,
        "神圣级": 0.09,
        "不朽级": 0.01
    }
};

// 初始化玩家坐骑数据
function initMountData() {
    if (!player.mounts) {
        player.mounts = {
            inventory: [], // 拥有的坐骑列表
            equipped: null, // 当前装备的坐骑ID
            level: 1, // 坐骑等级
            upgradeCost: 5 // 升级所需远古圣兽精魄数量
        };
    }
   
    // 确保items中有远古圣兽精魄
    if (player.items.zuoqi1 === undefined) {
        player.items.zuoqi1 = 0;
    }
}

// 切换坐骑系统界面
function toggleMountSystem() {
   if (player.level.ascentionCounta < 2) {
        alert("需要达到轮回2转才能开启坐骑系统！");
        return;
    }
    const overlay = document.getElementById("mountSystemOverlay");
    const ui = document.getElementById("mountSystemUI");
    
    if (ui.style.display === "block") {
        ui.style.display = "none";
        overlay.style.display = "none";
    } else {
        ui.style.display = "block";
        overlay.style.display = "block";
        updateMountUI();
    }
}

// 生成随机坐骑名字
function generateMountName() {
    const prefix = mountNameParts.prefixes[Math.floor(Math.random() * mountNameParts.prefixes.length)];
    const type = mountNameParts.types[Math.floor(Math.random() * mountNameParts.types.length)];
    const suffix = mountNameParts.suffixes[Math.floor(Math.random() * mountNameParts.suffixes.length)];
    return prefix + type + suffix;
}

// 生成随机坐骑
function generateRandomMount(dimensionLevel) {
    if (dimensionLevel < 3) return null; // 次元3以下不掉落坐骑
    
    const dropRates = mountDropRates[dimensionLevel];
    if (!dropRates) return null;
    
    // 根据概率随机选择品阶
    let rand = Math.random();
    let cumulativeProb = 0;
    let selectedRarity = null;
    
    for (const [rarity, prob] of Object.entries(dropRates)) {
        cumulativeProb += prob;
        if (rand < cumulativeProb) {
            selectedRarity = rarity;
            break;
        }
    }
    
    if (!selectedRarity) return null;
    
    const rarityConfig = mountRarities[selectedRarity];
    const stats = {};
    let statCount = 1; // 至少1个词条
    
    // 随机决定词条数量(1-5)
    for (let i = 0; i < 4; i++) {
        if (Math.random() < rarityConfig.statChance) {
            statCount++;
        }
    }
    
    // 随机选择词条类型
    const statTypes = ["health", "attack", "critDamage"];
    const selectedStats = [];
    
    for (let i = 0; i < statCount; i++) {
        const statType = statTypes[Math.floor(Math.random() * statTypes.length)];
        if (!selectedStats.includes(statType)) {
            selectedStats.push(statType);
            
            // 生成随机属性值
            const range = rarityConfig.statRange[statType];
            stats[statType] = Math.random() * (range[1] - range[0]) + range[0];
        }
    }
    
    return {
        id: 'mount_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: generateMountName(),
        rarity: selectedRarity,
        stats: stats,
        color: rarityConfig.color,
       locked: false
    };
}
function toggleMountLock(mountId) {
    const mount = player.mounts.inventory.find(m => m.id === mountId);
    if (mount) {
        mount.locked = !mount.locked;
        const action = mount.locked ? "锁定" : "解锁";
        logAction(`${action}了坐骑：${mount.name}`, 'success');
        updateMountUI();
    }
}
// 掉落坐骑（在怪物死亡时调用）
function dropMount() {
    const dimensionLevel = player.dimensionLevel;
    if (dimensionLevel < 3) return; // 次元3以下不掉落
    
    if (Math.random() < 0.001) { // 0.1%掉落几率
        const newMount = generateRandomMount(dimensionLevel);
        if (newMount) {
            player.mounts.inventory.push(newMount);
            logAction(`获得坐骑：${newMount.name}（${newMount.rarity}）`, 'success');
            updateMountUI();
        }
    }
}

// 装备坐骑
function equipMount(mountId) {
    const mount = player.mounts.inventory.find(m => m.id === mountId);
    if (mount) {
        player.mounts.equipped = mountId;
        logAction(`装备了坐骑：${mount.name}`, 'success');
        updateMountUI();
        updatePlayerBattleStats(); // 更新玩家属性
    }
}

// 卸下坐骑
function unequipMount() {
    player.mounts.equipped = null;
    logAction("已卸下坐骑", 'info');
    updateMountUI();
    updatePlayerBattleStats();
}

// 分解坐骑
function decomposeMount(mountId) {
   const mount = player.mounts.inventory.find(m => m.id === mountId);
    if (!mount) return;
    
    if (mount.locked) {
        logAction("坐骑已锁定，无法分解", "error");
        return;
    }

    const mountIndex = player.mounts.inventory.findIndex(m => m.id === mountId);
    if (mountIndex !== -1) {
        const mount = player.mounts.inventory[mountIndex];
        
        // 根据品阶获得不同数量的星币
        let starCoinsReward = 1;
        switch(mount.rarity) {
             case "劣质级": starCoinsReward = 10; break;
            case "普通级": starCoinsReward = 20; break;
            case "优秀级": starCoinsReward = 30; break;
            case "精良级": starCoinsReward = 50; break;
            case "卓越级": starCoinsReward = 100; break;
            case "史诗级": starCoinsReward = 250; break;
            case "传说级": starCoinsReward = 500; break;
            case "神圣级": starCoinsReward = 1000; break;
            case "不朽级": starCoinsReward = 2000; break;
        }
        
        player.nightClub.starCoins += starCoinsReward;
        
        // 如果分解的是当前装备的坐骑，先卸下
        if (player.mounts.equipped === mountId) {
            player.mounts.equipped = null;
        }
        
        player.mounts.inventory.splice(mountIndex, 1);
        
        logAction(`分解了坐骑：${mount.name}，获得${starCoinsReward}星币`, 'success');
        updateMountUI();
        updatePlayerBattleStats();
        updateDisplay();
    }
}

// 升级坐骑等级
function upgradeMount() {
    const cost = player.mounts.upgradeCost;
    
    if (player.items.zuoqi1 >= cost) {
        player.items.zuoqi1 -= cost;
        player.mounts.level++;
        player.mounts.upgradeCost += 5; // 每次升级增加5个消耗
        
        logAction(`坐骑等级提升至 ${player.mounts.level}级，属性加成提升至 ${player.mounts.level * 100}%`, 'success');
        updateMountUI();
        updatePlayerBattleStats();
        updateItemDisplay();
    } else {
        logAction(`远古圣兽精魄不足！需要${cost}个`, 'error');
    }
}

// 更新坐骑界面显示
function updateMountUI() {
    // 更新当前装备的坐骑信息
    const currentMountInfo = document.getElementById("currentMountInfo");
    if (player.mounts.equipped) {
        const equippedMount = player.mounts.inventory.find(m => m.id === player.mounts.equipped);
        if (equippedMount) {
            let statsHTML = "";
            for (const [stat, value] of Object.entries(equippedMount.stats)) {
                const statName = {
                    "health": "生命",
                    "attack": "攻击",
                    "critDamage": "爆伤"
                }[stat];
                statsHTML += `<div>${statName}加成: +${(value * 100).toFixed(1)}%</div>`;
            }
            
            currentMountInfo.innerHTML = `
                <div style="color: ${equippedMount.color}">
                    ${equippedMount.name}（${equippedMount.rarity}）
                </div>
                ${statsHTML}
                <div>总加成: +${(calculateMountBonus(equippedMount) * 100).toFixed(1)}%</div>
                <button onclick="unequipMount()" style="margin-top: 5px;">卸下</button>
            `;
        }
    } else {
        currentMountInfo.innerHTML = '无装备的坐骑';
    }
    
    // 更新坐骑等级信息
    document.getElementById("mountLevel").textContent = player.mounts.level;
    document.getElementById("mountBonus").textContent = (player.mounts.level * 100) + '%';
    document.getElementById("mountUpgradeCost").textContent = player.mounts.upgradeCost;
    
    // 更新坐骑仓库
    const mountInventory = document.getElementById("mountInventory");
    mountInventory.innerHTML = '';
    
    // 获取当前筛选条件
    const filter = document.getElementById("mountRarityFilter").value;
    let filteredMounts = player.mounts.inventory;
    if (filter !== "all") {
        filteredMounts = player.mounts.inventory.filter(mount => mount.rarity === filter);
    }
    
    if (filteredMounts.length === 0) {
        mountInventory.innerHTML = '<div style="text-align: center; color: #888;">暂无坐骑</div>';
    } else {
        filteredMounts.forEach(mount => {
        const isEquipped = player.mounts.equipped === mount.id;
        const mountElement = document.createElement("div");
        mountElement.style.cssText = `
            padding: 10px;
            margin: 5px 0;
            background: #444;
            border-radius: 5px;
            border-left: 4px solid ${mount.color};
            ${isEquipped ? 'border: 2px solid gold;' : ''}
            ${mount.locked ? 'border-right: 4px solid red;' : ''}
        `;
        
        let statsHTML = "";
        for (const [stat, value] of Object.entries(mount.stats)) {
            const statName = {
                "health": "生命",
                "attack": "攻击",
                "critDamage": "爆伤"
            }[stat];
            statsHTML += `<div>${statName}: +${(value * 100).toFixed(1)}%</div>`;
        }
        
        mountElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="color: ${mount.color}; font-weight: bold;">
                    ${mount.name}（${mount.rarity}）
                </div>
                <div>
                    <button onclick="toggleMountLock('${mount.id}')" style="background: ${mount.locked ? '#f44336' : '#4CAF50'}; color: white; border: none; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">
                        ${mount.locked ? '已锁定' : '未锁定'}
                    </button>
                </div>
            </div>
            ${statsHTML}
            <div>总加成: +${(calculateMountBonus(mount) * 100).toFixed(1)}%</div>
            <div style="margin-top: 5px;">
                ${!isEquipped ? `<button onclick="equipMount('${mount.id}')">装备</button>` : '<span style="color: gold;">已装备</span>'}
                <button onclick="decomposeMount('${mount.id}')" style="margin-left: 5px; background: #f44336;" ${mount.locked ? 'disabled' : ''}>分解</button>
            </div>
        `;
        
        mountInventory.appendChild(mountElement);
    });
    }
}

// 计算坐骑总加成
function calculateMountBonus(mount) {
    let totalBonus = 0;
    for (const value of Object.values(mount.stats)) {
        totalBonus += value;
    }
    return totalBonus * player.mounts.level;
}

// 筛选坐骑
function filterMounts() {
    updateMountUI();
}

// 一键分解当前筛选条件下的所有坐骑（不包括已装备的）
function decomposeAllFilteredMounts() {
    // 获取当前筛选条件下的坐骑
    const filter = document.getElementById("mountRarityFilter").value;
    let mountsToDecompose = [];
    
    if (filter === "all") {
        mountsToDecompose = player.mounts.inventory.filter(mount => 
            mount.id !== player.mounts.equipped && !mount.locked
        );
    } else {
        mountsToDecompose = player.mounts.inventory.filter(mount => 
            mount.rarity === filter && mount.id !== player.mounts.equipped && !mount.locked
        );
    }
    
    if (mountsToDecompose.length === 0) {
        logAction("没有可分解的坐骑", "info");
        return;
    }
    
    // 计算总奖励
    let totalStarCoins = 0;
    mountsToDecompose.forEach(mount => {
        let reward = 0;
        switch(mount.rarity) {
           case "劣质级": reward = 10; break;
            case "普通级": reward = 20; break;
            case "优秀级": reward = 30; break;
            case "精良级": reward = 50; break;
            case "卓越级": reward = 100; break;
            case "史诗级": reward = 250; break;
            case "传说级": reward = 500; break;
            case "神圣级": reward = 1000; break;
            case "不朽级": reward = 2000; break;
        }
        totalStarCoins += reward;
    });
    
    // 显示确认对话框
    showCustomConfirm(`确定要分解${mountsToDecompose.length}个${filter === "all" ? "" : filter}坐骑吗？将获得${totalStarCoins}星币`, (confirmed) => {
        if (confirmed) {
            // 执行分解
            mountsToDecompose.forEach(mount => {
                const mountIndex = player.mounts.inventory.findIndex(m => m.id === mount.id);
                if (mountIndex !== -1) {
                    player.mounts.inventory.splice(mountIndex, 1);
                }
            });
            
            // 添加奖励
            player.nightClub.starCoins += totalStarCoins;
            
            logAction(`一键分解了${mountsToDecompose.length}个坐骑，获得${totalStarCoins}星币`, 'success');
            updateMountUI();
            updateDisplay();
        }
    });
}

// 宝石系统初始化
function initGemSystem() {
    if (!player.gems) {
        player.gems = {
            red: {1: 0},   // 初始化为0个1级红宝石
            blue: {1: 0},   // 初始化为0个1级蓝宝石
            black: {1: 0}  // 初始化为0个1级黑宝石

        };
    }
}

// 切换宝石系统界面
function toggleGemSystem() {
   if (player.reincarnationCount < 800) {
        alert("需要达到800转才能开启宝石系统！");
        return;
    }
    const overlay = document.getElementById('gemSystemOverlay');
    const ui = document.getElementById('gemSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initGemSystem();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateGemUI();
    }
}

// 更新宝石界面
function updateGemUI() {
    updateGemInventory();
    updateGemBonuses();
}

// 更新宝石仓库显示
function updateGemInventory() {
    const container = document.getElementById('gemInventory');
    container.innerHTML = '';
    
    // 红宝石
    addGemTypeToUI('red', '红宝石 (攻击加成)', container);
    // 蓝宝石
    addGemTypeToUI('blue', '蓝宝石 (生命加成)', container);
    // 黑宝石
    addGemTypeToUI('black', '黑宝石 (爆伤加成)', container);

}

// 添加宝石类型到UI
function addGemTypeToUI(type, name, container) {
    const gemTypeDiv = document.createElement('div');
    gemTypeDiv.className = 'gem-type-section';
    gemTypeDiv.innerHTML = `<h4>${name}</h4>`;
    
    const gemsContainer = document.createElement('div');
    gemsContainer.style.display = 'grid';
    gemsContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
    gemsContainer.style.gap = '10px';
    gemsContainer.style.marginTop = '10px';
    
    // 显示该类型的所有宝石
    let hasGems = false;
    for (const level in player.gems[type]) {
        const count = player.gems[type][level];
        if (count > 0) {
            hasGems = true;
            const gemDiv = document.createElement('div');
            gemDiv.className = 'gem-item';
            gemDiv.innerHTML = `
                <div class="gem-icon ${type}">${type.charAt(0).toUpperCase()}</div>
                <div class="gem-level">${level}</div>
                <div>数量: ${count}</div>
                <button onclick="upgradeGem('${type}', ${level})" ${count < 3 ? 'disabled' : ''}>合成</button>
            `;
            gemsContainer.appendChild(gemDiv);
        }
    }
    
    // 如果没有宝石，显示提示
    if (!hasGems) {
        gemsContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888;">暂无宝石</div>';
    }
    
    gemTypeDiv.appendChild(gemsContainer);
    container.appendChild(gemTypeDiv);
}

// 更新宝石加成显示
function updateGemBonuses() {
    const bonuses = calculateGemBonuses();
    
    document.getElementById('attackBonus').textContent = `${bonuses.attack.toFixed(1)}%`;
    document.getElementById('healthBonus').textContent = `${bonuses.health.toFixed(1)}%`;
    document.getElementById('critDamageBonus').textContent = `${bonuses.critDamage.toFixed(1)}%`;

}


// 计算宝石总加成
function calculateGemBonuses() {
    return {
        attack: calculateGemBonus('red'),
        health: calculateGemBonus('blue'),
        critDamage: calculateGemBonus('black')


    };
}
// 计算单个宝石类型的加成
function calculateGemBonus(type) {
    let totalBonus = 0;
    
    for (const level in player.gems[type]) {
        const count = player.gems[type][level];
        const levelInt = parseInt(level);
        
        // 不同宝石类型有不同的加成计算方式
        switch (type) {
            case 'red': // 攻击加成: 100% * 2^(等级-1)
                totalBonus += count * 100 * (Math.pow(3, levelInt) - 1) / 2;
                break;
            case 'blue': // 生命加成: 5% * 2^(等级-1)
                totalBonus += count * 5 * (Math.pow(3, levelInt) - 1) / 2;
                break;
            case 'black': // 爆伤加成: 100% * 2^(等级-1)
                totalBonus += count * 100 * (Math.pow(3, levelInt) - 1) / 2;
                break;

        }
    }
    
    return totalBonus;
}

// 购买宝石
function buyGem(type, level) {
    if (player.exploration.resources.darkMatter >= 100) {
        player.exploration.resources.darkMatter -= 100;
        
        // 确保宝石类型存在
        if (!player.gems[type]) {
            player.gems[type] = {};
        }
        
        // 确保宝石等级存在
        if (!player.gems[type][level]) {
            player.gems[type][level] = 0;
        }
        
        player.gems[type][level]++;
        logAction(`购买了1个${getGemName(type)}宝石`, 'success');
        updateGemUI();
        updateDisplay();
    } else {
        logAction("暗物质不足！", "error");
    }
}

// 添加宝石
function addGem(type, level) {
    if (!player.gems[type][level]) {
        player.gems[type][level] = 0;
    }
    player.gems[type][level]++;
}

// 获取宝石名称
function getGemName(type) {
    const names = {
        red: "红",
        blue: "蓝",
        black: "黑"

    };
    return names[type] || "未知";
}

// 宝石合成
function upgradeGem(type, level) {
    const currentLevel = parseInt(level);
    const nextLevel = currentLevel + 1;
    
    // 检查是否有足够的宝石合成
    if (player.gems[type][currentLevel] >= 3) {
        player.gems[type][currentLevel] -= 3;
        
        // 如果数量为0，删除该等级
        if (player.gems[type][currentLevel] === 0) {
            delete player.gems[type][currentLevel];
        }
        
        // 添加高一级宝石
        if (!player.gems[type][nextLevel]) {
            player.gems[type][nextLevel] = 0;
        }
        player.gems[type][nextLevel]++;
        
        logAction(`成功合成${getGemName(type)}宝石 Lv.${nextLevel}`, 'success');
        updateGemUI();
    } else {
        logAction("宝石数量不足，无法合成！", "error");
    }
}
// 打开藏宝图商店
    function openTreasureShop() {
        if (player.reincarnationCount < 600) {
        alert("需要达到600转才能开启藏宝图商店！");
        return;
    }
        document.getElementById('treasureShopOverlay').style.display = 'block';
        document.getElementById('treasureShopUI').style.display = 'block';
        updateGemDisplay();
    }
    
    // 关闭藏宝图商店
    function closeTreasureShop() {
        document.getElementById('treasureShopOverlay').style.display = 'none';
        document.getElementById('treasureShopUI').style.display = 'none';
    }
    
    // 更新宝石数量显示
    function updateGemDisplay() {
        document.getElementById('currentPrimaryGemqCount').textContent = player.items.primaryGemq || 0;
    }
    
    // 兑换物品函数
    function exchangeItem(type) {
        let cost, item, amount;
        
        switch(type) {
            case 1: // 玫瑰花
                cost = 1;
                item = 'rose';
                amount = 50;
                break;
            case 2: // VIP能力值
                cost = 1;
                item = 'vipPower';
                amount = 10;
                break;
            case 3: // 鱼饵
                cost = 1;
                item = 'baitCount';
                amount = 1;
                break;
            case 4: // 伴侣钥匙
                cost = 2;
                item = 'companionKey';
                amount = 1;
                break;
            case 5: // 灵根检测器
                cost = 5;
                item = 'rootDetector';
                amount = 1;
                break;
            case 6: // 血脉检测剂
                cost = 5;
                item = 'bloodlineDetector';
                amount = 1;
                break;
            case 7: // 进阶神石
                cost = 20;
                item = 'advanceStone';
                amount = 1;
                break;
           case 8: // 宗门令牌
                cost = 50;
                item = 'zongmen';
                amount = 1;
                break;
            case 9: // 副本令牌
                cost = 10;
                item = 'fuben1';
                amount = 1;
                break;
             case 10: // 职业转换书
                cost = 10;
                item = 'zhiye1';
                amount = 1;
                break;
             case 11: 
                cost = 1;
                item = 'fubeng1';
                amount = 3;
                break;
            default:
                return;
        }
        
        // 检查金币数量
        if (player.items.primaryGemq >= cost) {
            // 扣除金币
            player.items.primaryGemq -= cost;
            
            // 添加物品
            if (!player.items[item]) player.items[item] = 0;
            player.items[item] += amount;
            
            // 更新显示
            updateGemDisplay();
            updateDisplay();
            
            // 显示成功消息
            let itemName = '';
            switch(item) {
                case 'rose': itemName = '玫瑰花'; break;
                case 'vipPower': itemName = 'VIP能力值'; break;
                case 'baitCount': itemName = '鱼饵'; break;
                case 'companionKey': itemName = '伴侣钥匙'; break;
                case 'rootDetector': itemName = '灵根检测器'; break;
                case 'bloodlineDetector': itemName = '血脉检测剂'; break;
                case 'advanceStone': itemName = '进阶神石'; break;
               case 'zongmen': itemName = '宗门令牌'; break;
               case 'zhiye1': itemName = '职业转换书'; break;
               case 'fuben1': itemName = '副本令牌'; break;
              case 'fubeng1': itemName = '深渊令牌'; break;
            }
            
            logAction(`宝藏金币成功兑换: ${amount}${itemName}`, 'success');
        } else {
            logAction('宝藏金币不足！', 'error');
        }
    }




// 藏宝图等级配置
const treasureMapLevels = [
    { level: 1, name: "一级藏宝图", monsterMinStage: 50, monsterMaxStage: 200, expReward: 10000, rewards: [
        { type: "baitCount", amount: 1 },
        { type: "companionKey", amount: 1 },
        { type: "vipPower", amount: 2 },
        { type: "rose", amount: 20 },
        { type: "primaryGem", amount: 1 },
        { type: "advancedGem", amount: 1 },
        { type: "yuzhou1", amount: 3 },
        { type: "yuzhou2", amount: 3 },
         { type: "banlv1", amount: 1 },
        { type: "banlv2", amount: 1 }
    ]},
    { level: 2, name: "二级藏宝图", monsterMinStage: 200, monsterMaxStage: 400, expReward: 50000, rewards: [
        { type: "baitCount", amount: 2 },
        { type: "companionKey", amount: 2 },
        { type: "vipPower", amount: 5 },
        { type: "rose", amount: 50 },
        { type: "advancedGem", amount: 2 },
        { type: "primaryGem", amount: 2 },
        { type: "rebornDan", amount: 3 },
        { type: "advanceStone", amount: 1 },
        { type: "yuzhou1", amount: 5 },
        { type: "yuzhou2", amount: 5 },
        { type: "banlv1", amount: 2 },
        { type: "banlv2", amount: 2 }
    ]},
    { level: 3, name: "三级藏宝图", monsterMinStage: 400, monsterMaxStage: 600, expReward: 100000, rewards: [
        { type: "baitCount", amount: 5 },
        { type: "companionKey", amount: 3 },
        { type: "vipPower", amount: 10 },
        { type: "rose", amount: 100 },
        { type: "advancedGem", amount: 3 },
        { type: "superiorGem", amount: 3 },
        { type: "rebornDan", amount: 5 },
        { type: "rootDetector", amount: 1 },
        { type: "bloodlineDetector", amount: 1 },
        { type: "advanceStone", amount: 1 },
              { type: "yuzhou1", amount: 10 },
        { type: "yuzhou2", amount: 5 },
        { type: "yuzhou3", amount: 5 },
         { type: "yuzhou4", amount: 5 },
        { type: "banlv1", amount: 5 },
        { type: "banlv2", amount: 5 },  
        { type: "banlv7", amount: 1 },
       { type: "banlv8", amount: 1 },      
      { type: "banlv9", amount: 1 }       
    ]},
    { level: 4, name: "四级藏宝图", monsterMinStage: 600, monsterMaxStage: 800, expReward: 500000, rewards: [
        { type: "baitCount", amount: 5 },
        { type: "companionKey", amount: 5 },
        { type: "vipPower", amount: 20 },
        { type: "rose", amount: 200 },
        { type: "superiorGem", amount: 3 },
        { type: "divineGem", amount: 3 },
        { type: "rebornDan", amount: 10 },
        { type: "rootDetector", amount: 1 },
        { type: "bloodlineDetector", amount: 1 },
        { type: "advanceStone", amount: 2 },
        { type: "yuzhou1", amount: 10 },
        { type: "yuzhou2", amount: 10 },
        { type: "yuzhou3", amount: 10 },
        { type: "yuzhou4", amount: 10 },
        { type: "banlv1", amount: 10 },
        { type: "banlv2", amount: 10 }, 
        { type: "banlv7", amount: 1 },
       { type: "banlv8", amount: 1 },  
       { type: "fuben1", amount: 1 },      
      { type: "banlv9", amount: 1 }  
    ]},
    { level: 5, name: "五级藏宝图", monsterMinStage: 800, monsterMaxStage: 1000, expReward: 1000000, rewards: [
        { type: "baitCount", amount: 10 },
        { type: "companionKey", amount: 10 },
        { type: "vipPower", amount: 50 },
        { type: "rose", amount: 500 },
        { type: "superiorGem", amount: 5 },
        { type: "divineGem", amount: 5 },
        { type: "rebornDan", amount: 20 },
        { type: "rootDetector", amount: 2 },
        { type: "bloodlineDetector", amount: 2 },
       { type: "advanceStone", amount: 3 },
       { type: "yuzhou1", amount: 30 },
       { type: "yuzhou2", amount: 30 },
       { type: "yuzhou3", amount: 30 },
       { type: "yuzhou4", amount: 30 },
       { type: "banlv1", amount: 20 },
       { type: "banlv2", amount: 20 },  
         { type: "banlv7", amount: 2 },
       { type: "banlv8", amount: 1 },
       { type: "fuben1", amount: 1 },      
      { type: "banlv9", amount: 1 }  
    ]}
];

// 藏宝图品质配置
const treasureMapQualities = [
    { quality: 1, name: "普通", multiplier: 1.0 },
    { quality: 2, name: "精良", multiplier: 2.0 },
    { quality: 3, name: "稀有", multiplier: 3.0 },
    { quality: 4, name: "史诗", multiplier: 5.0 },
    { quality: 5, name: "传说", multiplier: 10.0 },
    { quality: 6, name: "神话", multiplier: 20.0 }
];

// 切换藏宝图系统显示
function toggleTreasureMapSystem() {
    if (player.reincarnationCount < 600) {
        alert("需要达到600转才能开启宝图系统！");
        return;
    }
    const ui = document.getElementById('treasureMapSystemUI');
    const overlay = document.getElementById('treasureMapSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateTreasureMapDisplay();
        // 初始化合成界面
    updateCraftingDisplay();
    
    // 添加选择框变化监听
    document.getElementById('craftLevel').addEventListener('change', updateCraftingDisplay);
    document.getElementById('craftQuality').addEventListener('change', updateCraftingDisplay);
    }
}

// 更新藏宝图系统显示
function updateTreasureMapDisplay() {
     // 更新钥匙数量
    document.getElementById('treasureKeyCount').textContent = player.treasure.keys;
    const container = document.getElementById('treasureMapList');
    container.innerHTML = '';
    
    if (player.treasure.maps.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888;">暂无藏宝图</div>';
        return;
    }
    
    // 按等级和品质排序
    player.treasure.maps.sort((a, b) => {
        if (a.level !== b.level) return b.level - a.level;
        return b.quality - a.quality;
    });
    
    player.treasure.maps.forEach((map, index) => {
        const levelConfig = treasureMapLevels.find(l => l.level === map.level);
        const qualityConfig = treasureMapQualities.find(q => q.quality === map.quality);
        
        const card = document.createElement('div');
        card.style.background = '#444';
        card.style.padding = '10px';
        card.style.borderRadius = '5px';
        card.style.border = `2px solid ${map.quality >= 4 ? '#d4af37' : '#4CAF50'}`;
        
        card.innerHTML = `
            <div style="font-weight: bold; color: ${map.quality >= 4 ? '#d4af37' : '#4CAF50'};">${levelConfig.name}</div>
            <div>品质: ${qualityConfig.name} (x${qualityConfig.multiplier})</div>
            <div>获得时间: ${new Date(map.obtainedAt).toLocaleDateString()}</div>
            <button onclick="useTreasureMap(${index})" style="margin-top: 10px; width: 100%; background: #2196F3; color: white; border: none; padding: 5px; border-radius: 3px; cursor: pointer;">使用</button>
        `;
        
        container.appendChild(card);
    });
    
    // 更新合成界面
    updateCraftingDisplay();
}

// 兑换藏宝图钥匙
function buyTreasureKey() {
    if (player.exploration.resources.stardust < 100) {
        logAction("星尘不足！", "error");
        return;
    }
    
    player.exploration.resources.stardust -= 100;
    player.treasure.keys++;
    updateTreasureMapDisplay();
    logAction("成功兑换1个藏宝图钥匙", "success");
}
function buyTreasureKey1() {
    if (player.nightClub.starCoins < 100) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 100;
    player.treasure.keys++;
    updateTreasureMapDisplay();
    logAction("成功兑换1个藏宝图钥匙", "success");
}
function buyTreasureKey2() {
    if (player.nightClub.starCoins < 1000) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 1000;
    player.treasure.keys+=10;
    updateTreasureMapDisplay();
    logAction("成功兑换10个藏宝图钥匙", "success");
}
function buyTreasureKey3() {
    if (player.nightClub.starCoins < 5000) {
        logAction("星币不足！", "error");
        return;
    }
    
    player.nightClub.starCoins -= 5000;
    player.treasure.keys+=50;
    updateTreasureMapDisplay();
    logAction("成功兑换50个藏宝图钥匙", "success");
}
function openTreasureChestBatch(count) {
    if (player.treasure.keys < count) {
        logAction(`藏宝图钥匙不足！需要${count}个钥匙`, "error");
        return;
    }
    
    player.treasure.keys -= count;
    
    // 统计获得的藏宝图
    const results = {
        total: 0,
        byLevel: {},
        byQuality: {}
    };
    
    for (let i = 0; i < count; i++) {
        // 随机生成藏宝图等级
        const levelRand = Math.random();
        let level;
        if (levelRand < 0.8) level = 1;
        else if (levelRand < 0.95) level = 2;
        else if (levelRand < 0.98) level = 3;
        else if (levelRand < 0.995) level = 4;
        else level = 5;
        
        // 随机生成藏宝图品质
        const qualityRand = Math.random();
        let quality;
        if (qualityRand < 0.7) quality = 1;
        else if (qualityRand < 0.95) quality = 2;
        else if (qualityRand < 0.99889) quality = 3;
        else if (qualityRand < 0.99989) quality = 4;
        else if (qualityRand < 0.99999) quality = 5;
        else quality = 6;
        
        // 创建藏宝图
        const newMap = {
            level: level,
            quality: quality,
            obtainedAt: Date.now()
        };
        
        player.treasure.maps.push(newMap);
        
        // 统计结果
        results.total++;
        results.byLevel[level] = (results.byLevel[level] || 0) + 1;
        results.byQuality[quality] = (results.byQuality[quality] || 0) + 1;
    }
    
    // 更新显示
    updateTreasureMapDisplay();
    
    // 生成汇总消息
    let message = `批量开启了${count}个宝箱，获得${results.total}张藏宝图：`;
    
    // 按等级统计
    message += " 等级分布:";
    for (let lvl = 1; lvl <= 5; lvl++) {
        if (results.byLevel[lvl]) {
            const levelName = treasureMapLevels.find(l => l.level === lvl).name;
            message += ` ${levelName}×${results.byLevel[lvl]}`;
        }
    }
    
    // 按品质统计
    message += " 品质分布:";
    for (let q = 1; q <= 6; q++) {
        if (results.byQuality[q]) {
            const qualityName = treasureMapQualities.find(qual => qual.quality === q).name;
            message += ` ${qualityName}×${results.byQuality[q]}`;
        }
    }
    
    logAction(message, 'success');
}




// 开启藏宝图宝箱
function openTreasureChest() {
    if (player.treasure.keys < 1) {
        logAction("藏宝图钥匙不足！", "error");
        return;
    }
    
    player.treasure.keys--;
    
    // 随机生成藏宝图等级
    const levelRand = Math.random();
    let level;
    if (levelRand < 0.7) level = 1;
    else if (levelRand < 0.92) level = 2;
    else if (levelRand < 0.98) level = 3;
    else if (levelRand < 0.995) level = 4;
    else level = 5;
    
    // 随机生成藏宝图品质
    const qualityRand = Math.random();
    let quality;
    if (qualityRand < 0.7) quality = 1;
    else if (qualityRand < 0.95) quality = 2;
    else if (qualityRand < 0.99889) quality = 3;
    else if (qualityRand < 0.99989) quality = 4;
    else if (qualityRand < 0.99999) quality = 5;
    else quality = 6;
    
    // 创建藏宝图
    const newMap = {
        level: level,
        quality: quality,
        obtainedAt: Date.now()
    };
    
    player.treasure.maps.push(newMap);
    updateTreasureMapDisplay();
    
    const levelName = treasureMapLevels.find(l => l.level === level).name;
    const qualityName = treasureMapQualities.find(q => q.quality === quality).name;
    logAction(`获得${levelName}（${qualityName}品质）`, "success");
}
function updateCraftingDisplay() {
    const levelSelect = document.getElementById('craftLevel');
    const qualitySelect = document.getElementById('craftQuality');
    const countDisplay = document.getElementById('craftCount');
    
    if (!levelSelect || !qualitySelect || !countDisplay) return;
    
    // 获取当前选择的等级和品质
    const selectedLevel = parseInt(levelSelect.value);
    const selectedQuality = parseInt(qualitySelect.value);
    
    // 计算当前拥有的符合条件的藏宝图数量
    const count = player.treasure.maps.filter(map => 
        map.level === selectedLevel && map.quality === selectedQuality
    ).length;
    
    countDisplay.textContent = count;
    
    // 更新品质选择框，隐藏无法合成的选项（神话品质）
    while (qualitySelect.options.length > 0) {
        qualitySelect.remove(0);
    }
    
    const maxQuality = 5; // 最高可合成到传说品质
    for (let q = 1; q <= maxQuality; q++) {
        const option = document.createElement('option');
        option.value = q;
        option.textContent = treasureMapQualities.find(qual => qual.quality === q).name;
        qualitySelect.appendChild(option);
    }
    
    // 恢复之前的选择
    qualitySelect.value = Math.min(selectedQuality, maxQuality);
}

// 合成藏宝图
function craftTreasureMap() {
    const level = parseInt(document.getElementById('craftLevel').value);
    const quality = parseInt(document.getElementById('craftQuality').value);
    
    // 检查是否可以合成（神话品质无法继续合成）
    if (quality >= 6) {
        logAction("神话品质无法继续合成！", "error");
        return;
    }
    
    // 获取符合条件的藏宝图
    const matchingMaps = player.treasure.maps.filter(map => 
        map.level === level && map.quality === quality
    );
    
    // 检查数量是否足够
    if (matchingMaps.length < 2) {
        logAction(`需要2张${treasureMapLevels.find(l => l.level === level).name}（${treasureMapQualities.find(q => q.quality === quality).name}品质）才能合成！`, "error");
        return;
    }
    
    // 移除2张原材料
    for (let i = 0; i < 2; i++) {
        const index = player.treasure.maps.findIndex(map => 
            map.level === level && map.quality === quality
        );
        if (index !== -1) {
            player.treasure.maps.splice(index, 1);
        }
    }
    
    // 添加1张更高品质的同等级藏宝图
    const newMap = {
        level: level,
        quality: quality + 1,
        obtainedAt: Date.now()
    };
    
    player.treasure.maps.push(newMap);
    
    // 更新显示
    updateTreasureMapDisplay();
    updateCraftingDisplay();
    
    const levelName = treasureMapLevels.find(l => l.level === level).name;
    const oldQualityName = treasureMapQualities.find(q => q.quality === quality).name;
    const newQualityName = treasureMapQualities.find(q => q.quality === quality + 1).name;
    
    logAction(`成功将2张${levelName}（${oldQualityName}品质）合成为1张${levelName}（${newQualityName}品质）`, "success");
}

// 一键合成全部可合成的藏宝图
function craftAllTreasureMaps() {
    let craftedCount = 0;
    
    // 遍历所有等级和品质（除了神话品质）
    for (let level = 1; level <= 5; level++) {
        for (let quality = 1; quality <= 5; quality++) { // 最高合成到传说品质
            let craftedInThisCategory = 0;
            
            // 获取符合条件的藏宝图
            const matchingMaps = player.treasure.maps.filter(map => 
                map.level === level && map.quality === quality
            );
            
            // 计算可合成的次数
            const craftTimes = Math.floor(matchingMaps.length / 2);
            
            if (craftTimes > 0) {
                // 移除原材料
                for (let i = 0; i < craftTimes * 2; i++) {
                    const index = player.treasure.maps.findIndex(map => 
                        map.level === level && map.quality === quality
                    );
                    if (index !== -1) {
                        player.treasure.maps.splice(index, 1);
                    }
                }
                
                // 添加合成后的藏宝图
                for (let i = 0; i < craftTimes; i++) {
                    const newMap = {
                        level: level,
                        quality: quality + 1,
                        obtainedAt: Date.now()
                    };
                    player.treasure.maps.push(newMap);
                    craftedCount++;
                }
                
                craftedInThisCategory += craftTimes;
            }
            
            if (craftedInThisCategory > 0) {
                const levelName = treasureMapLevels.find(l => l.level === level).name;
                const oldQualityName = treasureMapQualities.find(q => q.quality === quality).name;
                const newQualityName = treasureMapQualities.find(q => q.quality === quality + 1).name;
                
                logAction(`一键合成了${craftedInThisCategory}组${levelName}（${oldQualityName}品质）→ ${levelName}（${newQualityName}品质）`, "info");
            }
        }
    }
    
    if (craftedCount > 0) {
        logAction(`一键合成完成，共合成${craftedCount}张藏宝图`, "success");
    } else {
        logAction("没有可合成的藏宝图", "info");
    }
    
    // 更新显示
    updateTreasureMapDisplay();
    updateCraftingDisplay();
}




// 使用藏宝图
function useTreasureMap(index) {
    if (index < 0 || index >= player.treasure.maps.length) return;
    
    const map = player.treasure.maps[index];
    const levelConfig = treasureMapLevels.find(l => l.level === map.level);
    const qualityConfig = treasureMapQualities.find(q => q.quality === map.quality);
    
    // 移除藏宝图
    player.treasure.maps.splice(index, 1);
    updateTreasureMapDisplay();
    
    // 随机决定事件类型
    const eventRand = Math.random();
    
    if (eventRand < 0.6) {
        // 60% 遇到怪物
        startTreasureBattle(map);
    } else if (eventRand < 0.8) {
        // 20% 直接获得奖励
        giveTreasureRewards(map, false);
    } else {
        // 20% 没有奖励
        showTreasureReward("没有获得任何奖励");
    }
}

function generateTreasureMonster(minStage, maxStage) {
    // 随机选择关卡
    const stage = Math.floor(Math.random() * (maxStage - minStage + 1)) + minStage;
    
    // 复制打怪模式的属性生成逻辑
    const monsterRanks = ['普通', '精英', '普通BOSS', '特殊BOSS', '领主BOSS', '霸主级BOSS', '王级BOSS', '皇级BOSS', '帝级BOSS', '神级BOSS', '圣级BOSS'];
    const rankProbabilities = [0.45, 0.20, 0.10, 0.06, 0.05, 0.04, 0.03, 0.03, 0.02, 0.015, 0.005];
    
    // 随机生成怪物品阶
    let rankIndex = 0;
    let rand = Math.random();
    for (let i = 0; i < rankProbabilities.length; i++) {
        rand -= rankProbabilities[i];
        if (rand < 0) {
            rankIndex = i;
            break;
        }
    }
    const rank = monsterRanks[rankIndex];
    
    // 根据品阶选择词条
    const modifierPool = monsterRankModifiers[rank].pool;
    const selectCount = monsterRankModifiers[rank].selectCount;
    const selectedModifiers = [];
    const usedModifiers = new Set();
    
    for (let i = 0; i < selectCount; i++) {
        let modifier;
        do {
            modifier = modifierPool[Math.floor(Math.random() * modifierPool.length)];
        } while (usedModifiers.has(modifier));
        usedModifiers.add(modifier);
        selectedModifiers.push(modifier);
    }
    
    // 计算怪物属性
    const healthMultiplier = Math.pow(2, stage);
    let attackMultiplier;
  
    if (stage <= 5) {
        attackMultiplier = Math.floor(Math.random() * 3) + 1;
    } else if (stage <= 15) {
        attackMultiplier = 35 + (stage - 10) * 1000;
    } else if (stage <= 25) {
        attackMultiplier = 50 + (stage - 10) * 100000;
    } else if (stage <= 40) {
        attackMultiplier = 100 + (stage - 10) * 1e70;
    } else if (stage <= 65) {
        attackMultiplier = 1000 + (stage - 9) * 1e80;
    } else if (stage <= 90) {
        attackMultiplier = 3500 + (stage - 64) * 1e90;
    } else if (stage <= 120) {
        attackMultiplier = 35000 + (stage - 89) * 1e100;
    } else if (stage <= 250) {
        attackMultiplier = 350000 + (stage - 119) * 1e110;
    } else if (stage <= 350) {
        attackMultiplier = 3500000 + (stage - 249) * 1e120;
    } else if (stage <= 450) {
        attackMultiplier = 450000000 + (stage - 349) * 1e130;
    } else if (stage <= 550) {
        attackMultiplier = 5500009000 + (stage - 449) * 1e140;
    } else if (stage <= 650) {
        attackMultiplier = 650000000900 + (stage - 549) * 1e150;
    } else if (stage <= 700) {
        attackMultiplier = 6500000000900 + (stage - 649) * 1e160;
    } else if (stage <= 750) {
        attackMultiplier = 6500000000000900 + (stage - 699) * 1e170;
    } else if (stage <= 790) {
        attackMultiplier = 6500000000000000900 + (stage - 549) * 1e180;
    } else if (stage <= 820) {
        attackMultiplier = 65000000000000000000900 + (stage - 549) * 1e190;
    } else if (stage <= 840) {
        attackMultiplier = 6500000000000000000000000900 + (stage - 549) * 1e200;
    } else if (stage <= 860) {
        attackMultiplier = 10000000000000000000000000000000 + (stage - 649) * 1e210;
    } else if (stage <= 900) {
        attackMultiplier = 100000000000000000000000000000000000 + (stage - 749) * 1e230;
    } else {
        attackMultiplier = 1000000000000000000000000000000000000000 + (stage - 849) * 1e250;
    }
    
    // 应用词条效果
    let attack = attackMultiplier;
    let damageReduction = 0;
    let dodgeChance = 0;
    let blockCount = 0;
    let attackCount = 1;
    let damageTakenMultiplier = 1;
    
    selectedModifiers.forEach(modifier => {
        const effect = monsterModifiers[modifier];
        if (effect.attackMultiplier) attack *= effect.attackMultiplier;
        if (effect.damageReduction) damageReduction += effect.damageReduction;
        if (effect.dodgeChance) dodgeChance += effect.dodgeChance;
        if (effect.blockCount) blockCount += effect.blockCount;
        if (effect.attackCount) attackCount = effect.attackCount;
        if (effect.damageTakenMultiplier) damageTakenMultiplier *= effect.damageTakenMultiplier;
    });
    
    // 生成怪物
    return {
        name: "宝藏守卫者",
        rank: rank,
        health: 10000 * healthMultiplier,
        attack: attack,
        modifiers: selectedModifiers,
        damageReduction: damageReduction,
        dodgeChance: dodgeChance,
        blockCount: blockCount,
        attackCount: attackCount,
        damageTakenMultiplier: damageTakenMultiplier
    };
}

// 在宝藏守卫者战斗中使用独立的属性生成
function startTreasureBattle(map) {
    const levelConfig = treasureMapLevels.find(l => l.level === map.level);
    
    // 使用独立的属性生成函数
    const monster = generateTreasureMonster(levelConfig.monsterMinStage, levelConfig.monsterMaxStage);
    
    // 保存战斗信息
    player.treasure.currentBattle = {
        map: map,
        monster: monster,
        playerHealth: player.battle.playerHealth,
        playerAttack: player.battle.playerAttack,
        playerCritRate: player.battle.playerCritRate,
        playerCritDamage: player.battle.playerCritDamage,
        battleEnded: false
    };
    
    // 更新战斗界面
    document.getElementById('treasurePlayerHealth').textContent = player.battle.playerHealth.toExponential(3);
    document.getElementById('treasurePlayerAttack').textContent = player.battle.playerAttack.toExponential(3);
    document.getElementById('treasurePlayerCritRate').textContent = (player.battle.playerCritRate * 100).toFixed(1) + "%";
    document.getElementById('treasurePlayerCritDamage').textContent = (player.battle.playerCritDamage * 100).toFixed(1) + "%";
    
    document.getElementById('treasureMonsterName').textContent = monster.name;
    document.getElementById('treasureMonsterRank').textContent = monster.rank;
    document.getElementById('treasureMonsterHealth').textContent = monster.health.toExponential(3);
    document.getElementById('treasureMonsterAttack').textContent = monster.attack.toExponential(3);
    document.getElementById('treasureMonsterModifiers').textContent = monster.modifiers.join(', ') || '无';
    
    document.getElementById('treasureBattleLog').innerHTML = "";
    
    // 显示战斗界面
    document.getElementById('treasureBattleOverlay').style.display = 'block';
    document.getElementById('treasureBattleUI').style.display = 'block';
}

// 攻击宝藏守卫者
function attackTreasureMonster() {
    if (!player.treasure.currentBattle) return;
    
    const battle = player.treasure.currentBattle;
   if (!battle || battle.battleEnded) return; // 检查战斗是否结束
    const logContainer = document.getElementById('treasureBattleLog');
    
    // 玩家攻击
    let playerDamage = battle.playerAttack;
    
    // 暴击判断
    if (Math.random() < battle.playerCritRate) {
        playerDamage *= battle.playerCritDamage;
        logContainer.innerHTML += `<div>你发动暴击，造成${Math.floor(playerDamage)}点伤害！</div>`;
    } else {
        logContainer.innerHTML += `<div>你造成${Math.floor(playerDamage)}点伤害</div>`;
    }
    
    battle.monster.health -= playerDamage;
    document.getElementById('treasureMonsterHealth').textContent = Math.max(0, battle.monster.health);
    
    // 检查怪物是否被击败
    if (battle.monster.health <= 0) {
        logContainer.innerHTML += `<div style="color: #4CAF50;">你击败了宝藏守卫者！</div>`;
        battle.battleEnded = true; // 标记战斗结束
        
        // 禁用攻击按钮
        const attackBtn = document.querySelector('#treasureBattleUI button');
        if (attackBtn) {
            attackBtn.disabled = true;
            attackBtn.style.background = '#999';
        }
        setTimeout(() => {
            giveTreasureRewards(battle.map, true);
            closeTreasureBattle();
           updateTreasureBattleStatus();
        }, 1000);
        return;
    }
    
    // 怪物反击
    let monsterDamage = battle.monster.attack;
    battle.playerHealth -= monsterDamage;
    document.getElementById('treasurePlayerHealth').textContent = Math.max(0, battle.playerHealth);
    logContainer.innerHTML += `<div>宝藏守卫者对你造成${Math.floor(monsterDamage)}点伤害</div>`;
    
    // 滚动到底部
    logContainer.scrollTop = logContainer.scrollHeight;
    
    // 检查玩家是否被击败
    if (battle.playerHealth <= 0) {
        logContainer.innerHTML += `<div style="color: #f44336;">你被宝藏守卫者击败了！</div>`;
          battle.battleEnded = true; // 标记战斗结束
        
        // 禁用攻击按钮
        const attackBtn = document.querySelector('#treasureBattleUI button');
        if (attackBtn) {
            attackBtn.disabled = true;
            attackBtn.style.background = '#999';
        }
        setTimeout(() => {
            showTreasureReward("战斗失败，没有获得任何奖励");
            closeTreasureBattle();     
        }, 1000);
    }
}

// 关闭宝藏战斗界面
function closeTreasureBattle() {
    document.getElementById('treasureBattleOverlay').style.display = 'none';
    document.getElementById('treasureBattleUI').style.display = 'none';
    player.treasure.currentBattle = null;
  const attackBtn = document.querySelector('#treasureBattleUI button');
        if (attackBtn) {
            attackBtn.disabled = false;
            attackBtn.style.background = '#999';
        }
}

// 给予藏宝图奖励
function giveTreasureRewards(map, isBattleWin) {
    const levelConfig = treasureMapLevels.find(l => l.level === map.level);
    const qualityConfig = treasureMapQualities.find(q => q.quality === map.quality);
    
    let rewardText = "";
    
    if (isBattleWin) {
        // 战斗胜利奖励：修仙经验（洞府聚灵阵加成）
        const exp = levelConfig.expReward * qualityConfig.multiplier * (typeof getGrottoCultivationExpBonus === 'function' ? getGrottoCultivationExpBonus() : 1);
        player.cultivation.exp += exp;
      
        rewardText = `战斗胜利！获得${exp}点修仙经验`;
    if (Math.random() < 0.1) {
            player.items.roseq = (player.items.roseq || 0) + 1;
            rewardText += "<br>获得香囊x1！";
        }
    if (Math.random() < 0.01) {
            player.items.fuben1 = (player.items.fuben1 || 0) + 1;
            rewardText += "<br>获得副本令牌x1！";
        }
      if (Math.random() < 0.01) {
            player.items.fuben2 = (player.items.fuben2 || 0) + 1;
            rewardText += "<br>获得秘境钥匙x1！";
        }
      if (Math.random() < 0.01) {
            player.items.zhiye1 = (player.items.zhiye1 || 0) + 1;
            rewardText += "<br>获得职业转换书x1！";
        }
    if (Math.random() < 0.1) {
            player.items.primaryGemq = (player.items.primaryGemq || 0) + 1;
            rewardText += "<br>获得宝藏金币x1！";
        }
    } else {
        // 直接获得奖励：随机选择2个奖励
        const rewards = [];
        const rewardCount = 2;
        
        for (let i = 0; i < rewardCount; i++) {
            const rewardIndex = Math.floor(Math.random() * levelConfig.rewards.length);
            const reward = levelConfig.rewards[rewardIndex];
            const amount = Math.ceil(reward.amount * qualityConfig.multiplier);
            
            // 添加奖励到玩家物品
            player.items[reward.type] = (player.items[reward.type] || 0) + amount;
            
            // 获取奖励名称
            let rewardName = "";
            switch (reward.type) {
                case "baitCount": rewardName = "鱼饵"; break;
                case "companionKey": rewardName = "伴侣钥匙"; break;
                case "vipPower": rewardName = "VIP能力值"; break;
                case "rose": rewardName = "玫瑰花"; break;
                case "primaryGem": rewardName = "初级宝石"; break;
                case "advancedGem": rewardName = "高级宝石"; break;
                case "superiorGem": rewardName = "极品宝石"; break;
                case "divineGem": rewardName = "神级宝石"; break;
                case "rebornDan": rewardName = "洗髓丹"; break;
                case "rootDetector": rewardName = "灵根检测器"; break;
                case "bloodlineDetector": rewardName = "血脉检测剂"; break;
              case "advanceStone": rewardName = "进阶神石"; break;
             case "yuzhou1": rewardName = "星尘发票"; break;
                case "yuzhou2": rewardName = "暗物质发票"; break;
                case "yuzhou3": rewardName = "宇宙晶体发票"; break;
              case "yuzhou4": rewardName = "神器碎片发票"; break;
            case "banlv1": rewardName = "普通伴侣灵魂"; break;
             case "banlv2": rewardName = "稀有伴侣灵魂"; break;
             case "banlv7": rewardName = "天使伴侣灵魂"; break;
          case "banlv8": rewardName = "恶魔伴侣灵魂"; break;
          case "fuben1": rewardName = "副本令牌"; break;
         case "zhiye1": rewardName = "职业转换书"; break;
              case "banlv9": rewardName = "精灵伴侣灵魂"; break;       
            }
            
            rewards.push(`${rewardName} x${amount}`);
        }
        
        rewardText = `获得奖励：${rewards.join("，")}`;
    }
    
    showTreasureReward(rewardText);
}

// 显示藏宝图奖励
function showTreasureReward(message) {
    document.getElementById('treasureRewardContent').innerHTML = message;
    document.getElementById('treasureRewardOverlay').style.display = 'block';
    document.getElementById('treasureRewardUI').style.display = 'block';
}

// 关闭藏宝图奖励界面
function closeTreasureReward() {
    document.getElementById('treasureRewardOverlay').style.display = 'none';
    document.getElementById('treasureRewardUI').style.display = 'none';
}

// 在游戏加载时初始化藏宝图系统
function initTreasureMapSystem() {
    if (!player.treasure) {
        player.treasure = {
            keys: 0,
            maps: [],
            currentBattle: null
        };
    }
}
// 在战斗状态变化时更新状态提示
function updateTreasureBattleStatus() {
    const statusElement = document.getElementById('treasureBattleStatus');
    if (!statusElement) return;
    
    const battle = player.treasure.currentBattle;
    if (!battle) return;
    
    if (battle.battleEnded) {
        if (battle.monster.health <= 0) {
            statusElement.textContent = "战斗胜利";
            statusElement.style.color = "#4CAF50";
        } else if (battle.playerHealth <= 0) {
            statusElement.textContent = "战斗失败";
            statusElement.style.color = "#f44336";
        }
    } else {
        statusElement.textContent = "战斗中...";
        statusElement.style.color = "#FFC107";
    }
}
// 灵根配置
const rootConfig = {
    // 110%品阶
    tier1: [
        { name: "金灵根", bonus: 1.2 },
        { name: "木灵根", bonus: 1.2 },
        { name: "水灵根", bonus: 1.2 },
        { name: "火灵根", bonus: 1.25 },
        { name: "土灵根", bonus: 1.25 },
        { name: "雷灵根", bonus: 1.25 },
        { name: "杂灵根", bonus: 1.25 },
        { name: "钝金根", bonus: 1.2 },
        { name: "弱木根", bonus: 1.3 },
        { name: "浅水灵根", bonus: 1.3 },
        { name: "微火灵根", bonus: 1.3 },
        { name: "散土灵根", bonus: 1.4 },
        { name: "青禾根", bonus: 1.4 },
        { name: "溪水灵根", bonus: 1.4 },
        { name: "岩土根", bonus: 1.2 },
        { name: "铜铁根", bonus: 1.2 },
        { name: "三杂灵根", bonus: 1.2 },
        { name: "脆金根", bonus: 1.2 }
    ],
    // 200%品阶
    tier2: [
        { name: "深水灵根", bonus: 2.0 },
        { name: "炽火根", bonus: 2.0 },
        { name: "雷灵根", bonus: 2.0 },
        { name: "风灵根", bonus: 2.0 },
        { name: "冰灵根", bonus: 2.1 },
        { name: "沙灵根", bonus: 2.0 },
        { name: "雾灵根", bonus: 2.0 },
        { name: "藤木根", bonus: 2.0 },
        { name: "熔岩根", bonus: 2.0 },
        { name: "霜水灵根", bonus: 2.0 },
        { name: "晶金根", bonus: 2.0 },
        { name: "腐木根", bonus: 2.0 },
        { name: "冥水灵根", bonus: 2.1 },
        { name: "焦土根", bonus: 2.1 },
        { name: "双灵根", bonus: 2.1 },
        { name: "云灵根", bonus: 2.1 },
        { name: "毒木根", bonus: 2.1 },
        { name: "罡风根", bonus: 2.1 },
        { name: "寒铁根", bonus: 2.0 },
        { name: "焰木根", bonus: 2.1 },
        { name: "磁金根", bonus: 2.1 },
        { name: "酸水灵根", bonus: 2.0 }
    ],
    // 250%品阶
    tier3: [
        { name: "天灵根光", bonus: 2.5 },
        { name: "暗灵根", bonus: 2.5 },
        { name: "音灵根", bonus: 2.5 },
        { name: "影灵根", bonus: 2.5 },
        { name: "星辰灵根", bonus: 2.5 },
        { name: "月华灵根", bonus: 2.5 },
        { name: "日曦灵根", bonus: 2.5 },
        { name: "虚空灵根", bonus: 2.5 },
        { name: "时间灵根", bonus: 2.5 },
        { name: "圣灵根", bonus: 2.5 },
        { name: "魔灵根", bonus: 2.5 },
        { name: "晶玉灵根", bonus: 2.5 },
        { name: "云雾灵根", bonus: 2.5 },
        { name: "生死灵根", bonus: 2.5 },
        { name: "风火灵根", bonus: 2.5 },
        { name: "光暗灵根", bonus: 2.5 },
        { name: "山海灵根", bonus: 2.5 },
        { name: "混元灵根", bonus: 2.5 },
        { name: "灵植根", bonus: 2.5 },
        { name: "魂灵根", bonus: 2.5 }
    ],
    // 300%品阶
    tier4: [
        { name: "混沌灵根", bonus: 3.0 },
        { name: "鸿蒙灵根", bonus: 3.0 },
        { name: "先天灵根", bonus: 3.0 },
        { name: "虚无灵根", bonus: 3.0 },
        { name: "永恒灵根", bonus: 3.0 },
        { name: "本源灵根", bonus: 3.0 },
        { name: "万物灵根", bonus: 3.0 },
        { name: "太初灵根", bonus: 3.0 },
        { name: "轮回灵根", bonus: 3.0 }
    ],
    // 400%品阶
    tier5: [
        { name: "天道灵根", bonus: 4.0 },
        { name: "星辰本源根", bonus: 4.0 },
        { name: "混沌雷灵根", bonus: 4.0 },
        { name: "寂灭灵根", bonus: 4.0 },
        { name: "太极灵根", bonus: 4.0 }
    ],
    // 500%品阶
    tier6: [
        { name: "大道灵根", bonus: 5.0 },
        { name: "虚空混沌根", bonus: 5.0 },
        { name: "万化灵根", bonus: 5.0 },
        { name: "创世灵根", bonus: 5.0 }
    ],
    // 1000%品阶
    tier7: [
        { name: "无垢灵根", bonus: 10.0 }
    ]
};
const bloodlineConfig = {
    tier1: [
        { name: "凡骨血脉", bonus: 1.0 },
        { name: "麻瓜血脉", bonus: 1.0 },
        { name: "健魄血脉", bonus: 1.0 },
        { name: "灵慧血脉", bonus: 1.0 },
        { name: "野猪血脉", bonus: 1.0 },
        { name: "捷足血脉", bonus: 1.2 },
        { name: "锐目血脉", bonus: 1.2 },
        { name: "佩奇血脉", bonus: 1.2 },
        { name: "稳心血脉", bonus: 1.2 },
        { name: "厚土血脉", bonus: 1.2 }
    ],
    tier2: [
        { name: "天雷血脉", bonus: 1.3 },
        { name: "雷霆血脉", bonus: 1.3 },
        { name: "妖皇血脉", bonus: 1.3 },
        { name: "格斗神血脉", bonus: 1.3 },
        { name: "法神血脉", bonus: 1.3 },
        { name: "拳神血脉", bonus: 1.3 },
        { name: "命运血脉", bonus: 1.3 },
        { name: "太古大妖血脉", bonus: 1.3 },
        { name: "龙族血脉", bonus: 1.4 },
        { name: "邪神血脉", bonus: 1.4 },
        { name: "金龙王血脉", bonus: 1.4 },
        { name: "吞天血脉", bonus: 1.4 },
        { name: "鲲鹏血脉", bonus: 1.4 },
        { name: "穷奇血脉", bonus: 1.4 },
        { name: "灵狐血脉", bonus: 1.4 },
        { name: "烛龙血脉", bonus: 1.4 },
        { name: "神羽血脉", bonus: 1.4 }
    ],
    tier3: [
        { name: "瑞兽血脉", bonus: 1.5 },
        { name: "涅槃血脉", bonus: 1.5 },
        { name: "混沌神魔血脉", bonus: 1.5 },
        { name: "万界诸神血脉", bonus: 1.5 },
        { name: "剑神血脉", bonus: 1.5 },
        { name: "冥魂血脉", bonus: 1.5 },
        { name: "御世血脉", bonus: 1.6 },
        { name: "陆吾血脉", bonus: 1.6 },
        { name: "破邪血脉", bonus: 1.6 },
        { name: "蛟龙血脉", bonus: 1.6 },
        { name: "太阳之子血脉", bonus: 1.6 },
        { name: "大帝血脉", bonus: 1.6 }
    ],
    tier4: [
        { name: "麒麟血脉", bonus: 1.8 },
        { name: "玄武血脉", bonus: 1.8 },
        { name: "白虎血脉", bonus: 1.8 },
        { name: "齐天大圣血脉", bonus: 1.8 },
        { name: "黑山老妖血脉", bonus: 1.8 },
        { name: "神鸡血脉", bonus: 1.8 },
        { name: "宇智波血脉", bonus: 1.8 },
        { name: "漩涡血脉", bonus: 1.8 },
        { name: "疾风迅雷血脉", bonus: 1.8 }
    ],
    tier5: [
        { name: "朱雀血脉", bonus: 2.1 },
        { name: "青龙血脉", bonus: 2.1 },
        { name: "金刚不坏血脉", bonus: 2.5 },
        { name: "万钧巨力血脉", bonus: 2.1 },
        { name: "瞬影血脉", bonus: 2.5 },
        { name: "破妄真瞳血脉", bonus: 2.0 }
    ],
    tier6: [
        { name: "吞天噬地血脉", bonus: 2.5 },
        { name: "星辰之力血脉", bonus: 3.0 },
        { name: "大地脉动血脉", bonus: 3.0 },
        { name: "九天罡风血脉", bonus: 3.0 },
        { name: "幽冥暗影血脉", bonus: 3.0 }
    ],
    tier7: [
        { name: "鸿蒙紫气血脉", bonus: 4.0 },
        { name: "混沌本源血脉", bonus: 4.0 },
        { name: "万象森罗血脉", bonus: 4.0 },
        { name: "诸天法则血脉", bonus: 4.0 }
    ],
    tier8: [
        { name: "永恒不朽血脉", bonus: 5.0 },
        { name: "创世之光血脉", bonus: 5.0 },
        { name: "灭世之影血脉", bonus: 5.0 }
    ],
    tier9: [
        { name: "至高无上血脉", bonus: 10.0 }
    ]
};
// 修仙阶段配置
const cultivationStages = [
    { name: "凡人", expRequired: 0, multiplier: 1 },
    { name: "练气", expRequired: 10000, multiplier: 2 },
    { name: "筑基", expRequired: 20000, multiplier: 3 },
    { name: "灵动", expRequired: 40000, multiplier: 4 },
    { name: "灵虚", expRequired: 60000, multiplier: 5 },
    { name: "灵寂", expRequired: 80000, multiplier: 6 },
    { name: "开光", expRequired: 100000, multiplier: 7 },
    { name: "融合", expRequired: 200000, multiplier: 8 },
    { name: "聚丹", expRequired: 300000, multiplier: 9 },
    { name: "凝丹", expRequired: 400000, multiplier: 10 },
    { name: "韵丹", expRequired: 500000, multiplier: 15 },
    { name: "结丹", expRequired: 600000, multiplier: 20 },
    { name: "金丹", expRequired: 700000, multiplier: 25 },
    { name: "聚婴", expRequired: 800000, multiplier: 30 },
    { name: "凝婴", expRequired: 900000, multiplier: 35 },
    { name: "结婴", expRequired: 1000000, multiplier: 40 },
    { name: "元婴", expRequired: 1250000, multiplier: 45 },
    { name: "婴变", expRequired: 1500000, multiplier: 50 },
    { name: "出窍", expRequired: 1750000, multiplier: 55 },
    { name: "元神", expRequired: 2000000, multiplier: 60 },
    { name: "分神", expRequired: 2250000, multiplier: 65 },
    { name: "化神", expRequired: 2500000, multiplier: 70 },
    { name: "洞虚", expRequired: 2750000, multiplier: 75 },
    { name: "化虚", expRequired: 3000000, multiplier: 80 },
    { name: "返虚", expRequired: 3250000, multiplier: 85 },
    { name: "合体", expRequired: 3500000, multiplier: 90 },
    { name: "合灵", expRequired: 4000000, multiplier: 95 },
    { name: "合魂", expRequired: 4500000, multiplier: 100 },
    { name: "空冥", expRequired: 5000000, multiplier: 150 },
    { name: "寂灭", expRequired: 5250000, multiplier: 200 },
    { name: "问鼎", expRequired: 5500000, multiplier: 250 },
    { name: "问道", expRequired: 5750000, multiplier: 300 },
    { name: "合道", expRequired: 6000000, multiplier: 350 },
    { name: "大帝", expRequired: 6250000, multiplier: 400 },
    { name: "半仙", expRequired: 6500000, multiplier: 450 },
    { name: "渡劫", expRequired: 6750000, multiplier: 500 },
    { name: "人仙", expRequired: 7000000, multiplier: 550 },
    { name: "真仙", expRequired: 7250000, multiplier: 600 },
    { name: "上仙", expRequired: 7500000, multiplier: 650 },
    { name: "地仙", expRequired: 7750000, multiplier: 700 },
    { name: "天仙", expRequired: 8000000, multiplier: 750 },
    { name: "玄仙", expRequired: 8250000, multiplier: 800 },
    { name: "太乙", expRequired: 8500000, multiplier: 850 },
    { name: "九天", expRequired: 8750000, multiplier: 900 },
    { name: "金仙", expRequired: 9000000, multiplier: 950 },
    { name: "仙将", expRequired: 9250000, multiplier: 1000 },
    { name: "仙君", expRequired: 9500000, multiplier: 1500 },
    { name: "仙王", expRequired: 9750000, multiplier: 2000 },
    { name: "仙皇", expRequired: 10000000, multiplier: 2500 },
    { name: "仙尊", expRequired: 15000000, multiplier: 3000 },
    { name: "仙帝", expRequired: 20000000, multiplier: 3500 },
    { name: "半圣", expRequired: 25000000, multiplier: 4000 },
    { name: "真圣", expRequired: 30000000, multiplier: 4500 },
    { name: "人圣", expRequired: 35000000, multiplier: 5000 },
    { name: "地圣", expRequired: 40000000, multiplier: 5500 },
    { name: "天圣", expRequired: 45000000, multiplier: 6000 },
    { name: "玄圣", expRequired: 50000000, multiplier: 6500 },
    { name: "大圣", expRequired: 55000000, multiplier: 7000 },
    { name: "金圣", expRequired: 60000000, multiplier: 7500 },
    { name: "圣将", expRequired: 65000000, multiplier: 8000 },
    { name: "圣君", expRequired: 70000000, multiplier: 8500 },
    { name: "圣王", expRequired: 75000000, multiplier: 9000 },
    { name: "圣皇", expRequired: 80000000, multiplier: 9500 },
    { name: "圣尊", expRequired: 85000000, multiplier: 10000 },
    { name: "圣帝", expRequired: 90000000, multiplier: 12000 },
    { name: "半神", expRequired: 95000000, multiplier: 14000 },
    { name: "真神", expRequired: 100000000, multiplier: 16000 },
    { name: "人神", expRequired: 150000000, multiplier: 18000 },
    { name: "地神", expRequired: 200000000, multiplier: 20000 },
    { name: "天神", expRequired: 250000000, multiplier: 22000 },
    { name: "玄神", expRequired: 300000000, multiplier: 24000 },
    { name: "金神", expRequired: 350000000, multiplier: 26000 },
    { name: "神将", expRequired: 400000000, multiplier: 28000 },
    { name: "神灵", expRequired: 450000000, multiplier: 30000 },
    { name: "神王", expRequired: 500000000, multiplier: 32000 },
    { name: "神皇", expRequired: 550000000, multiplier: 34000 },
    { name: "神宗", expRequired: 600000000, multiplier: 36000 },
    { name: "神尊", expRequired: 650000000, multiplier: 38000 },
    { name: "神帝", expRequired: 700000000, multiplier: 40000 },
    { name: "荒帝", expRequired: 750000000, multiplier: 42000 },
    { name: "太荒", expRequired: 800000000, multiplier: 44000 },
    { name: "仙荒", expRequired: 850000000, multiplier: 46000 },
    { name: "神荒", expRequired: 900000000, multiplier: 48000 },
    { name: "荒古", expRequired: 1000000000, multiplier: 50000 },
    { name: "荒祖", expRequired: 1050000000, multiplier: 52000 },
    { name: "始荒", expRequired: 1100000000, multiplier: 54000 },
    { name: "人道", expRequired: 1150000000, multiplier: 56000 },
    { name: "天道", expRequired: 1200000000, multiplier: 58000 },
    { name: "仙道", expRequired: 1250000000, multiplier: 60000 },
    { name: "神道", expRequired: 1300000000, multiplier: 62000 },
    { name: "帝道", expRequired: 1350000000, multiplier: 64000 },
    { name: "轮回", expRequired: 1400000000, multiplier: 66000 },
    { name: "时空", expRequired: 1450000000, multiplier: 68000 },
    { name: "乾坤", expRequired: 1500000000, multiplier: 70000 },
    { name: "规则", expRequired: 1550000000, multiplier: 72000 },
    { name: "始祖", expRequired: 1600000000, multiplier: 74000 },
    { name: "元神", expRequired: 1650000000, multiplier: 76000 },
    { name: "人神", expRequired: 1700000000, multiplier: 78000 },
    { name: "仙神", expRequired: 1750000000, multiplier: 80000 },
    { name: "帝神", expRequired: 1800000000, multiplier: 82000 },
    { name: "主宰", expRequired: 1850000000, multiplier: 84000 },
    { name: "重生", expRequired: 1900000000, multiplier: 86000 },
    { name: "凡人★", expRequired: 1950000000, multiplier: 88000 },
    { name: "练气★", expRequired: 2000000000, multiplier: 90000 },
    { name: "筑基★", expRequired: 2050000000, multiplier: 92000 },
    { name: "灵动★", expRequired: 2100000000, multiplier: 94000 },
    { name: "灵虚★", expRequired: 2150000000, multiplier: 96000 },
    { name: "灵寂★", expRequired: 2200000000, multiplier: 98000 },
    { name: "开光★", expRequired: 2250000000, multiplier: 100000 },
    { name: "融合★", expRequired: 2300000000, multiplier: 102500 },
    { name: "聚丹★", expRequired: 2350000000, multiplier: 105000 },
    { name: "凝丹★", expRequired: 2400000000, multiplier: 107500 },
    { name: "韵丹★", expRequired: 2450000000, multiplier: 110000 },
    { name: "结丹★", expRequired: 2500000000, multiplier: 112500 },
    { name: "金丹★", expRequired: 2550000000, multiplier: 115000 },
    { name: "聚婴★", expRequired: 2600000000, multiplier: 117500 },
    { name: "凝婴★", expRequired: 2650000000, multiplier: 120000 },
    { name: "结婴★", expRequired: 2700000000, multiplier: 122500 },
    { name: "元婴★", expRequired: 2750000000, multiplier: 125000 },
    { name: "婴变★", expRequired: 2800000000, multiplier: 127500 },
    { name: "出窍★", expRequired: 2850000000, multiplier: 130000 },
    { name: "元神★", expRequired: 2900000000, multiplier: 132500 },
    { name: "分神★", expRequired: 2950000000, multiplier: 135000 },
    { name: "化神★", expRequired: 3000000000, multiplier: 137500 },
    { name: "洞虚★", expRequired: 3050000000, multiplier: 140000 },
    { name: "化虚★", expRequired: 3100000000, multiplier: 142500 },
    { name: "返虚★", expRequired: 3150000000, multiplier: 145000 },
    { name: "合体★", expRequired: 3200000000, multiplier: 147500 },
    { name: "合灵★", expRequired: 3250000000, multiplier: 150000 },
    { name: "合魂★", expRequired: 3300000000, multiplier: 152500 },
    { name: "空冥★", expRequired: 3350000000, multiplier: 155000 },
    { name: "寂灭★", expRequired: 3400000000, multiplier: 157500 },
    { name: "问鼎★", expRequired: 3450000000, multiplier: 160000 },
    { name: "问道★", expRequired: 3500000000, multiplier: 162500 },
    { name: "合道★", expRequired: 3550000000, multiplier: 165000 },
    { name: "大帝★", expRequired: 3600000000, multiplier: 167500 },
    { name: "半仙★", expRequired: 3650000000, multiplier: 170000 },
    { name: "渡劫★", expRequired: 3750000000, multiplier: 172500 },
    { name: "人仙★", expRequired: 3800000000, multiplier: 175000 },
    { name: "真仙★", expRequired: 3850000000, multiplier: 177500 },
    { name: "上仙★", expRequired: 3900000000, multiplier: 180000 },
    { name: "地仙★", expRequired: 3950000000, multiplier: 182500 },
    { name: "天仙★", expRequired: 4000000000, multiplier: 185000 },
    { name: "玄仙★", expRequired: 4050000000, multiplier: 187500 },
    { name: "太乙★", expRequired: 4100000000, multiplier: 190000 },
    { name: "九天★", expRequired: 4150000000, multiplier: 192500 },
    { name: "金仙★", expRequired: 4200000000, multiplier: 195000 },
    { name: "仙将★", expRequired: 4250000000, multiplier: 197500 },
    { name: "仙君★", expRequired: 4300000000, multiplier: 202500 },
    { name: "仙王★", expRequired: 4350000000, multiplier: 205000 },
    { name: "仙皇★", expRequired: 4400000000, multiplier: 207500 },
    { name: "仙尊★", expRequired: 4450000000, multiplier: 210000 },
    { name: "仙帝★", expRequired: 4500000000, multiplier: 212500 },
    { name: "半圣★", expRequired: 4550000000, multiplier: 215000 },
    { name: "真圣★", expRequired: 4600000000, multiplier: 217500 },
    { name: "人圣★", expRequired: 4650000000, multiplier: 220000 },
    { name: "地圣★", expRequired: 4700000000, multiplier: 222500 },
    { name: "天圣★", expRequired: 4750000000, multiplier: 225000 },
    { name: "玄圣★", expRequired: 4800000000, multiplier: 227500 },
    { name: "大圣★", expRequired: 4850000000, multiplier: 230000 },
    { name: "金圣★", expRequired: 4900000000, multiplier: 232500 },
    { name: "圣将★", expRequired: 4950000000, multiplier: 235000 },
    { name: "圣君★", expRequired: 5050000000, multiplier: 237500 },
    { name: "圣王★", expRequired: 5100000000, multiplier: 240000 },
    { name: "圣皇★", expRequired: 5150000000, multiplier: 242500 },
    { name: "圣尊★", expRequired: 5200000000, multiplier: 245000 },
    { name: "圣帝★", expRequired: 5250000000, multiplier: 247500 },
    { name: "半神★", expRequired: 5300000000, multiplier: 250000 },
    { name: "真神★", expRequired: 5350000000, multiplier: 252500 },
    { name: "人神★", expRequired: 5400000000, multiplier: 255000 },
    { name: "地神★", expRequired: 5450000000, multiplier: 257500 },
    { name: "天神★", expRequired: 5500000000, multiplier: 260000 },
    { name: "玄神★", expRequired: 5550000000, multiplier: 262500 },
    { name: "金神★", expRequired: 5600000000, multiplier: 265000 },
    { name: "神将★", expRequired: 5650000000, multiplier: 267500 },
    { name: "神灵★", expRequired: 5700000000, multiplier: 270000 },
    { name: "神王★", expRequired: 5750000000, multiplier: 272500 },
    { name: "神皇★", expRequired: 5800000000, multiplier: 275000 },
    { name: "神宗★", expRequired: 5850000000, multiplier: 277500 },
    { name: "神尊★", expRequired: 5900000000, multiplier: 280000 },
    { name: "神帝★", expRequired: 5950000000, multiplier: 282500 },
    { name: "荒帝★", expRequired: 6050000000, multiplier: 285000 },
    { name: "太荒★", expRequired: 6100000000, multiplier: 287500 },
    { name: "仙荒★", expRequired: 6150000000, multiplier: 290000 },
    { name: "神荒★", expRequired: 6200000000, multiplier: 292500 },
    { name: "荒古★", expRequired: 6250000000, multiplier: 295000 },
    { name: "荒祖★", expRequired: 6300000000, multiplier: 297500 },
    { name: "始荒★", expRequired: 6350000000, multiplier: 302500 },
    { name: "人道★", expRequired: 6400000000, multiplier: 305000 },
    { name: "天道★", expRequired: 6450000000, multiplier: 307500 },
    { name: "仙道★", expRequired: 6500000000, multiplier: 310000 },
    { name: "神道★", expRequired: 6550000000, multiplier: 312500 },
    { name: "帝道★", expRequired: 6600000000, multiplier: 315000 },
    { name: "轮回★", expRequired: 6650000000, multiplier: 317500 },
    { name: "时空★", expRequired: 6700000000, multiplier: 320000 },
    { name: "乾坤★", expRequired: 6750000000, multiplier: 322500 },
    { name: "规则★", expRequired: 6800000000, multiplier: 325000 },
    { name: "始祖★", expRequired: 6850000000, multiplier: 327500 },
    { name: "元神★", expRequired: 6900000000, multiplier: 330000 },
    { name: "人神★", expRequired: 6950000000, multiplier: 332500 },
    { name: "仙神★", expRequired: 7000000000, multiplier: 335000 },
    { name: "帝神★", expRequired: 7050000000, multiplier: 337500 },
    { name: "主宰★", expRequired: 10000000000, multiplier: 340000 }
];

// 初始化修仙系统
function initCultivationSystem() {
    if (!player.cultivation) {
        player.cultivation = {
            stage: 0, // 当前阶段索引
            exp: 0,   // 当前经验值
            root: null, // 当前灵根
            bloodline: null,
           bonus: 1 
        };
    }
}

// 切换修仙系统界面
function toggleCultivationSystem() {
    if (player.reincarnationCount < 500) {
        alert("需要达到500转才能开启修仙系统！");
        return;
    }
    initCultivationSystem();
    
    const ui = document.getElementById('cultivationSystemUI');
    const overlay = document.getElementById('cultivationSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateCultivationUI();
       updateMagicToolUI();
    }
}


function updateCultivationUI() {
    // 获取当前阶段信息
    const stageIndex = player.cultivation.stage;
    const stage = cultivationStages[stageIndex];
    
    // 确保阶段信息存在
    if (!stage) {
        console.error("无效的修仙阶段索引:", stageIndex);
        return;
    }
    
    // 更新当前阶段显示
    document.getElementById('currentStageq').textContent = stage.name;
      document.getElementById('currentStageqa').textContent = stage.name;
    // 其他更新逻辑保持不变...
    const nextStage = cultivationStages[stageIndex + 1];
    
    // 更新灵根信息
    const rootInfo = document.getElementById('currentRootInfo');
    if (player.cultivation.root) {
        rootInfo.innerHTML = `
            <div style="font-size: 18px; font-weight: bold; color: #FFD700;">${player.cultivation.root.name}</div>
            <div>加成: ${player.cultivation.root.bonus * 100}%</div>
        `;
    } else {
        rootInfo.textContent = "尚未检测灵根";
    }
     const bloodlineInfo = document.getElementById('currentBloodlineInfo');
    if (player.cultivation.bloodline) {
        bloodlineInfo.innerHTML = `
            <div style="font-size: 18px; font-weight: bold; color: #d4af37;">${player.cultivation.bloodline.name}</div>
            <div>加成: ${player.cultivation.bloodline.bonus * 100}%</div>
        `;
    } else {
        bloodlineInfo.textContent = "尚未检测血脉";
    }
    // 更新阶段信息
    document.getElementById('stageLevel').textContent = stageIndex;
    document.getElementById('currentExp').textContent = player.cultivation.exp.toFixed(0);
    
    if (nextStage) {
        document.getElementById('nextExp').textContent = nextStage.expRequired;
        
        // 计算经验进度
        const progress = Math.min(100, (player.cultivation.exp / nextStage.expRequired) * 100);
        document.getElementById('expProgress').style.width = `${progress}%`;
    } else {
        document.getElementById('nextExp').textContent = "已达最高境界";
        document.getElementById('expProgress').style.width = '100%';
    }
    
    // 更新加成信息
    document.getElementById('gpsMultiplier').textContent = stage.multiplier;
   // 计算法宝总加成
    let toolBonus = 1;
    let toolName = '无';
    if (player.magicTools && player.magicTools.equipped) {
        const tool = magicToolConfig.tools.find(t => t.id === player.magicTools.equipped);
        if (tool) {
            toolBonus = tool.bonus;
            toolName = tool.name;
        }
    }
    
    // 计算法宝收集加成
    let collectionBonus = 1;
    let ownedToolsCount = 0;
    if (player.magicTools && player.magicTools.inventory) {
        ownedToolsCount = player.magicTools.inventory.length;
        collectionBonus = 1 + (ownedToolsCount * 0.01);
    }
    
    // 总法宝加成 = 装备法宝加成 × 收集加成
    const totalToolBonus = toolBonus * collectionBonus;
    
    // 更新法宝加成显示
    const magicToolMultiplier = document.getElementById('magicToolMultiplier');
    if (magicToolMultiplier) {
        magicToolMultiplier.textContent = totalToolBonus.toFixed(2);
    }
}
// 打开灵根宝箱界面
function openRootBox() {
    if (player.items.rootDetector < 1) {
        logAction("灵根检测器不足！", "error");
        return;
    }
    
    document.getElementById('rootBoxUI').style.display = 'block';
    document.getElementById('rootBoxOverlay').style.display = 'block';
    document.getElementById('rootResult').textContent = "点击开启获取灵根";
}

// 关闭灵根宝箱界面
function closeRootBox() {
    document.getElementById('rootBoxUI').style.display = 'none';
    document.getElementById('rootBoxOverlay').style.display = 'none';
}

// 抽取灵根
function drawRoot() {
    if (player.items.rootDetector < 1) {
        logAction("灵根检测器不足！", "error");
        return;
    }
    
    player.items.rootDetector--;
    
    // 根据概率抽取灵根品阶
    const rand = Math.random();
    let tier;
    
    if (rand < 0.85) {
        tier = "tier1"; // 85%
    } else if (rand < 0.97) {
        tier = "tier2"; // 12%
    } else if (rand < 0.998) {
        tier = "tier3"; // 2.8%
    } else if (rand < 0.9998) {
        tier = "tier4"; // 0.18%
    } else if (rand < 0.99998) {
        tier = "tier5"; // 0.018%
    } else if (rand < 0.999998) {
        tier = "tier6"; // 0.0018%
    } else {
        tier = "tier7"; // 0.0002%
    }
    
    // 随机选择该品阶中的一个灵根
    const roots = rootConfig[tier];
    const root = roots[Math.floor(Math.random() * roots.length)];
    
    // 保存当前抽取的灵根到全局变量
    window.tempNewRoot = root;
    if (root.bonus >= 2.05) {
        // 保存当前抽取的灵根到全局变量
        window.tempRoot = root;
        // 显示自定义弹窗
        closeRootReplaceDialog();
        showRootRefreshDialog();
        
    } 
    // 检查是否有现有灵根
    if (player.cultivation.root) {
        // 有现有灵根，显示替换确认弹窗
        showRootReplaceDialog();
    } else {
        // 没有现有灵根，直接使用
        player.cultivation.root = root;
        
        // 显示结果
        document.getElementById('rootResult').innerHTML = `
            <div style="font-size: 20px; font-weight: bold; color: #FFD700;">获得${root.name}!</div>
            <div>加成: ${(root.bonus * 100).toFixed(1)}%</div>
        `;
        
        logAction(`获得灵根: ${root.name} (加成${(root.bonus * 100).toFixed(1)}%)`, "success");
        updateCultivationUI();
        updateDisplay();
    }
}
function showRootReplaceDialog() {
    if (!window.tempNewRoot) return;
    
    const oldRoot = player.cultivation.root;
    const newRoot = window.tempNewRoot;
    
    // 创建遮罩层
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.background = 'rgba(0,0,0,0.8)';
    overlay.style.zIndex = '10000';
    overlay.id = 'rootReplaceOverlay';
    overlay.onclick = function(e) {
        if (e.target === this) closeRootReplaceDialog();
    };
    document.body.appendChild(overlay);
    
    // 创建弹窗
    const dialog = document.createElement('div');
    dialog.style.position = 'fixed';
    dialog.style.top = '50%';
    dialog.style.left = '50%';
    dialog.style.transform = 'translate(-50%, -50%)';
    dialog.style.background = 'linear-gradient(145deg, #2c2c54, #40407a)';
    dialog.style.color = 'white';
    dialog.style.padding = '30px';
    dialog.style.border = '3px solid #FFD700';
    dialog.style.borderRadius = '20px';
    dialog.style.zIndex = '10001';
    dialog.style.width = '550px';
    dialog.style.textAlign = 'center';
    dialog.style.boxShadow = '0 10px 40px rgba(255,215,0,0.3)';
    dialog.style.animation = 'pop-up 0.3s';
    dialog.id = 'rootReplaceDialog';
    
    // 判断新旧灵根哪个更好
    const isNewBetter = newRoot.bonus > oldRoot.bonus;
    const compareColor = isNewBetter ? '#4CAF50' : '#f44336';
    const compareText = isNewBetter ? '✨ 新灵根更好！' : '⚠️ 旧灵根更好';
    
    dialog.innerHTML = `
        <div style="position: absolute; top: -15px; left: -15px; font-size: 30px;">✨</div>
        <div style="position: absolute; top: -15px; right: -15px; font-size: 30px;">⚡</div>
        
        <h3 style="color: #FFD700; margin-top: 0; margin-bottom: 20px; font-size: 28px;">🌿 灵根选择</h3>
        
        <div style="display: flex; gap: 20px; margin-bottom: 25px;">
            <!-- 旧灵根 -->
            <div style="flex: 1; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px; border: 2px solid #666;">
                <div style="font-size: 24px; margin-bottom: 10px;">🔮</div>
                <div style="font-size: 18px; font-weight: bold; color: #aaa; margin-bottom: 5px;">当前灵根</div>
                <div style="font-size: 16px; color: #FFD700; margin-bottom: 10px;">${oldRoot.name}</div>
                <div style="font-size: 20px; color: #4CAF50; font-weight: bold;">${(oldRoot.bonus * 100).toFixed(1)}%</div>
            </div>
            
            <div style="display: flex; align-items: center; font-size: 24px; color: #FFD700;">VS</div>
            
            <!-- 新灵根 -->
            <div style="flex: 1; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px; border: 2px solid ${isNewBetter ? '#4CAF50' : '#FFD700'};">
                <div style="font-size: 24px; margin-bottom: 10px;">✨</div>
                <div style="font-size: 18px; font-weight: bold; color: #FFD700; margin-bottom: 5px;">新灵根</div>
                <div style="font-size: 16px; color: #FFD700; margin-bottom: 10px;">${newRoot.name}</div>
                <div style="font-size: 20px; color: ${isNewBetter ? '#4CAF50' : '#FFD700'}; font-weight: bold;">${(newRoot.bonus * 100).toFixed(1)}%</div>
            </div>
        </div>
        
        <div style="margin-bottom: 25px; padding: 10px; background: rgba(255,215,0,0.1); border-radius: 10px;">
            <span style="color: ${compareColor};">${compareText}</span>
        </div>
        
        <div style="display: flex; gap: 15px; justify-content: center;">
            <button onclick="replaceRoot()" style="background: linear-gradient(45deg, #4CAF50, #2E7D32); color: white; border: none; padding: 15px 25px; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 16px; flex: 1;">
                ✨ 替换为新灵根
            </button>
            <button onclick="keepOldRoot()" style="background: linear-gradient(45deg, #f44336, #c62828); color: white; border: none; padding: 15px 25px; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 16px; flex: 1;">
                ❌ 保留旧灵根
            </button>
        </div>
        
        <button onclick="closeRootReplaceDialog()" style="background: rgba(255,255,255,0.1); color: #aaa; border: 2px solid #666; padding: 10px 25px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 14px; margin-top: 20px;">
            取消 (不替换也不保留新灵根)
        </button>
    `;
    
    document.body.appendChild(dialog);
}
function replaceRoot() {
    if (window.tempNewRoot) {
        const newRoot = window.tempNewRoot;
        player.cultivation.root = newRoot;
        
        // 关闭弹窗
        closeRootReplaceDialog();
        
        // 显示结果
        document.getElementById('rootResult').innerHTML = `
            <div style="font-size: 20px; font-weight: bold; color: #FFD700;">替换为${newRoot.name}!</div>
            <div>加成: ${(newRoot.bonus * 100).toFixed(1)}%</div>
        `;
        
        logAction(`替换灵根为: ${newRoot.name} (加成${(newRoot.bonus * 100).toFixed(1)}%)`, "success");
        updateCultivationUI();
        updateDisplay();
        
        // 清除临时变量
        window.tempNewRoot = null;
    }
}
function keepOldRoot() {
    const oldRoot = player.cultivation.root;
    
    // 关闭弹窗
    closeRootReplaceDialog();
    
    // 显示结果（保留旧灵根）
    document.getElementById('rootResult').innerHTML = `
        <div style="font-size: 20px; font-weight: bold; color: #FFD700;">保留当前灵根</div>
        <div style="font-size: 16px; color: #aaa; margin-top: 5px;">${oldRoot.name} (${(oldRoot.bonus * 100).toFixed(1)}%)</div>
    `;
    
    logAction(`保留当前灵根: ${oldRoot.name}`, "info");
    
    // 清除临时变量
    window.tempNewRoot = null;
}

// 关闭灵根替换弹窗
function closeRootReplaceDialog() {
    const overlay = document.getElementById('rootReplaceOverlay');
    if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
    }
    
    const dialog = document.getElementById('rootReplaceDialog');
    if (dialog && dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
    }
    
    // 清除临时变量
    window.tempNewRoot = null;
}

function showRootRefreshDialog() {
    // 检查是否有临时灵根
    if (!window.tempRoot) return;
    
    const root = window.tempRoot;
    
    // 创建遮罩层
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.background = 'rgba(0,0,0,0.8)';
    overlay.style.zIndex = '10000';
    overlay.id = 'rootRefreshOverlay';
    overlay.onclick = function(e) {
        if (e.target === this) closeRootRefreshDialog();
    };
    document.body.appendChild(overlay);
    
    // 创建弹窗
    const dialog = document.createElement('div');
    dialog.style.position = 'fixed';
    dialog.style.top = '50%';
    dialog.style.left = '50%';
    dialog.style.transform = 'translate(-50%, -50%)';
    dialog.style.background = 'linear-gradient(145deg, #2c2c54, #40407a)';
    dialog.style.color = 'white';
    dialog.style.padding = '30px';
    dialog.style.border = '3px solid #FFD700';
    dialog.style.borderRadius = '20px';
    dialog.style.zIndex = '1000111';
    dialog.style.width = '450px';
    dialog.style.textAlign = 'center';
    dialog.style.boxShadow = '0 10px 40px rgba(255,215,0,0.3)';
    dialog.style.animation = 'pop-up 0.3s';
    dialog.id = 'rootRefreshDialog';
    
    // 根据加成确定颜色
    let color = '#FFD700';
    if (root.bonus >= 3.9) color = '#FF4500';
    else if (root.bonus >= 2.9) color = '#FF69B4';
    else if (root.bonus >= 2.05) color = '#9C27B0';
    
    dialog.innerHTML = `
        <div style="position: absolute; top: -15px; left: -15px; font-size: 30px;">✨</div>
        <div style="position: absolute; top: -15px; right: -15px; font-size: 30px;">⚡</div>
        
        <h3 style="color: ${color}; margin-top: 0; margin-bottom: 20px; font-size: 28px; text-shadow: 0 0 10px ${color};">🎉 极品灵根出现！</h3>
        
        <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px; margin-bottom: 25px; border: 2px solid ${color};">
            <div style="font-size: 48px; margin-bottom: 10px;">✨</div>
            <div style="font-size: 26px; font-weight: bold; color: ${color}; margin-bottom: 10px;">${root.name}</div>
            <div style="font-size: 18px; color: #FFD700; margin-bottom: 5px;">加成: ${(root.bonus * 100).toFixed(1)}%</div>
            <div style="font-size: 14px; color: #aaa; margin-top: 10px;">品阶: ${getTierNameFromBonus(root.bonus)}</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <div style="color: #FFD700; font-size: 16px; margin-bottom: 10px;">是否保留这个灵根？</div>
            <div style="color: #aaa; font-size: 14px;">如果选择刷新，将重新抽取一个新灵根</div>
        </div>
        
        <div style="display: flex; gap: 15px; justify-content: center;">
            <button onclick="confirmKeepRoot()" style="background: linear-gradient(45deg, #4CAF50, #2E7D32); color: white; border: none; padding: 15px 30px; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 16px; flex: 1;">
                ✨ 保留
            </button>
        </div>
        
        <button onclick="closeRootRefreshDialog()" style="background: rgba(244,67,54,0.2); color: #f44336; border: 2px solid #f44336; padding: 10px 25px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 14px; margin-top: 20px;">
            取消 (不保留)
        </button>
    `;
    
    document.body.appendChild(dialog);
}

// 获取品阶名称
function getTierNameFromBonus(bonus) {
    if (bonus >= 9.0) return '传说级';
    if (bonus >= 4.9) return '史诗级';
    if (bonus >= 3.9) return '神话级';
    if (bonus >= 2.9) return '极品';
    if (bonus >= 2.4) return '稀有';
    if (bonus >= 2.05) return '珍贵';
    return '普通';
}
function confirmKeepRoot() {
    if (window.tempRoot) {
        const root = window.tempRoot;
        player.cultivation.root = root;
        
        // 关闭弹窗
        closeRootRefreshDialog();
        
        // 显示结果
        const resultDiv = document.getElementById('rootResult');
        if (resultDiv) {
            resultDiv.innerHTML = `
                <div style="font-size: 20px; font-weight: bold; color: #FFD700;">获得${root.name}!</div>
                <div>加成: ${(root.bonus * 100).toFixed(1)}%</div>
            `;
        }
        
        logAction(`获得极品灵根: ${root.name} (加成${(root.bonus * 100).toFixed(1)}%)`, "success");
        updateCultivationUI();
        updateDisplay();
        
        // 清除临时变量
        window.tempRoot = null;
    } else {
        closeRootRefreshDialog();
    }
}
function refreshRoot() {
    // 关闭当前弹窗
    closeRootRefreshDialog();
    
    // 重新抽取
    const rand = Math.random();
    let tier;
    
    if (rand < 0.85) {
        tier = "tier1";
    } else if (rand < 0.97) {
        tier = "tier2";
    } else if (rand < 0.998) {
        tier = "tier3";
    } else if (rand < 0.9998) {
        tier = "tier4";
    } else if (rand < 0.99998) {
        tier = "tier5";
    } else if (rand < 0.999998) {
        tier = "tier6";
    } else {
        tier = "tier7";
    }
    
    const roots = rootConfig[tier];
    const newRoot = roots[Math.floor(Math.random() * roots.length)];
    
    // 检查新抽取的是否也达到205%以上
    if (newRoot.bonus >= 2.05) {
        window.tempRoot = newRoot;
        showRootRefreshDialog();
    } else {
        // 直接更新玩家灵根
        player.cultivation.root = newRoot;
        
        // 显示结果
        const resultDiv = document.getElementById('rootResult');
        if (resultDiv) {
            resultDiv.innerHTML = `
                <div style="font-size: 20px; font-weight: bold; color: #FFD700;">刷新获得${newRoot.name}!</div>
                <div>加成: ${(newRoot.bonus * 100).toFixed(1)}%</div>
            `;
        }
        
        logAction(`刷新获得灵根: ${newRoot.name} (加成${(newRoot.bonus * 100).toFixed(1)}%)`, "success");
        updateCultivationUI();
        updateDisplay();
        
        // 清除临时变量
        window.tempRoot = null;
    }
}

// 关闭灵根刷新弹窗（不保留也不刷新）
function closeRootRefreshDialog() {
    const overlay = document.getElementById('rootRefreshOverlay');
    if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
    }
    
    const dialog = document.getElementById('rootRefreshDialog');
    if (dialog && dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
    }
    
    // 清除临时变量（如果用户取消，不保留灵根）
    window.tempRoot = null;
}
// 打开血脉宝箱
function openBloodlineBox() {
    if (player.items.bloodlineDetector < 1) {
        logAction("血脉检测剂不足！", "error");
        return;
    }
    
    document.getElementById('bloodlineBoxUI').style.display = 'block';
    document.getElementById('bloodlineBoxOverlay').style.display = 'block';
    document.getElementById('bloodlineResult').textContent = "点击开启获取血脉";
}

// 关闭血脉宝箱
function closeBloodlineBox() {
    document.getElementById('bloodlineBoxUI').style.display = 'none';
    document.getElementById('bloodlineBoxOverlay').style.display = 'none';
}

// 抽取血脉
function drawBloodline() {
    if (player.items.bloodlineDetector < 1) {
        logAction("血脉检测剂不足！", "error");
        return;
    }
    
    player.items.bloodlineDetector--;
    
    // 根据概率抽取血脉品阶
    const rand = Math.random();
    let tier;
    
    if (rand < 0.8) {
        tier = "tier1"; // 80%
    } else if (rand < 0.96) {
        tier = "tier2"; // 16%
    } else if (rand < 0.992) {
        tier = "tier3"; // 3.2%
    } else if (rand < 0.9984) {
        tier = "tier4"; // 0.64%
    } else if (rand < 0.99968) {
        tier = "tier5"; // 0.128%
    } else if (rand < 0.999936) {
        tier = "tier6"; // 0.0256%
    } else if (rand < 0.9999872) {
        tier = "tier7"; // 0.00512%
    } else if (rand < 0.99999744) {
        tier = "tier8"; // 0.001024%
    } else {
        tier = "tier9"; // 0.000256%
    }
    
    // 随机选择该品阶中的一个血脉
    const bloodlines = bloodlineConfig[tier];
    const bloodline = bloodlines[Math.floor(Math.random() * bloodlines.length)];
    
    // 保存当前抽取的血脉到全局变量
    window.tempNewBloodline = bloodline;
      if (bloodline.bonus >= 1.55) {
        // 保存当前抽取的血脉到全局变量
        window.tempBloodline = bloodline;
        // 显示自定义弹窗
        closeBloodlineReplaceDialog();
        showBloodlineContinueDialog();
      
    }
    // 检查是否有现有血脉
    if (player.cultivation.bloodline) {
        // 有现有血脉，显示替换确认弹窗
        showBloodlineReplaceDialog();
    } else {
        // 没有现有血脉，直接使用
        player.cultivation.bloodline = bloodline;
        
        // 显示结果
        document.getElementById('bloodlineResult').innerHTML = `
            <div style="font-size: 20px; font-weight: bold; color: #FFD700;">获得${bloodline.name}!</div>
            <div>加成: ${(bloodline.bonus * 100).toFixed(1)}%</div>
        `;
        
        logAction(`获得血脉: ${bloodline.name} (加成${(bloodline.bonus * 100).toFixed(1)}%)`, "success");
        updateCultivationUI();
        updateDisplay();
    }
}
function showBloodlineReplaceDialog() {
    if (!window.tempNewBloodline) return;
    
    const oldBloodline = player.cultivation.bloodline;
    const newBloodline = window.tempNewBloodline;
    
    // 创建遮罩层
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.background = 'rgba(0,0,0,0.8)';
    overlay.style.zIndex = '10000';
    overlay.id = 'bloodlineReplaceOverlay';
    overlay.onclick = function(e) {
        if (e.target === this) closeBloodlineReplaceDialog();
    };
    document.body.appendChild(overlay);
    
    // 创建弹窗
    const dialog = document.createElement('div');
    dialog.style.position = 'fixed';
    dialog.style.top = '50%';
    dialog.style.left = '50%';
    dialog.style.transform = 'translate(-50%, -50%)';
    dialog.style.background = 'linear-gradient(145deg, #2c2c54, #40407a)';
    dialog.style.color = 'white';
    dialog.style.padding = '30px';
    dialog.style.border = '3px solid #d4af37';
    dialog.style.borderRadius = '20px';
    dialog.style.zIndex = '10001';
    dialog.style.width = '550px';
    dialog.style.textAlign = 'center';
    dialog.style.boxShadow = '0 10px 40px rgba(212,175,55,0.3)';
    dialog.style.animation = 'pop-up 0.3s';
    dialog.id = 'bloodlineReplaceDialog';
    
    // 判断新旧血脉哪个更好
    const isNewBetter = newBloodline.bonus > oldBloodline.bonus;
    const compareColor = isNewBetter ? '#4CAF50' : '#f44336';
    const compareText = isNewBetter ? '✨ 新血脉更好！' : '⚠️ 旧血脉更好';
    
    // 检查是否达到170%以上（可以继续开启）
    const canContinue = newBloodline.bonus >= 1.7;
    
    dialog.innerHTML = `
        <div style="position: absolute; top: -15px; left: -15px; font-size: 30px;">💉</div>
        <div style="position: absolute; top: -15px; right: -15px; font-size: 30px;">⚡</div>
        
        <h3 style="color: #d4af37; margin-top: 0; margin-bottom: 20px; font-size: 28px;">💫 血脉选择</h3>
        
        <div style="display: flex; gap: 20px; margin-bottom: 25px;">
            <!-- 旧血脉 -->
            <div style="flex: 1; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px; border: 2px solid #666;">
                <div style="font-size: 24px; margin-bottom: 10px;">🔮</div>
                <div style="font-size: 18px; font-weight: bold; color: #aaa; margin-bottom: 5px;">当前血脉</div>
                <div style="font-size: 14px; color: #FFD700; margin-bottom: 10px;">${oldBloodline.name}</div>
                <div style="font-size: 20px; color: #4CAF50; font-weight: bold;">${(oldBloodline.bonus * 100).toFixed(1)}%</div>
            </div>
            
            <div style="display: flex; align-items: center; font-size: 24px; color: #FFD700;">VS</div>
            
            <!-- 新血脉 -->
            <div style="flex: 1; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px; border: 2px solid ${isNewBetter ? '#4CAF50' : '#d4af37'};">
                <div style="font-size: 24px; margin-bottom: 10px;">✨</div>
                <div style="font-size: 18px; font-weight: bold; color: #d4af37; margin-bottom: 5px;">新血脉</div>
                <div style="font-size: 14px; color: #FFD700; margin-bottom: 10px;">${newBloodline.name}</div>
                <div style="font-size: 20px; color: ${isNewBetter ? '#4CAF50' : '#d4af37'}; font-weight: bold;">${(newBloodline.bonus * 100).toFixed(1)}%</div>
            </div>
        </div>
        
        <div style="margin-bottom: 25px; padding: 10px; background: rgba(255,215,0,0.1); border-radius: 10px;">
            <span style="color: ${compareColor};">${compareText}</span>
        </div>
        
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="replaceBloodline()" style="background: linear-gradient(45deg, #4CAF50, #2E7D32); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 15px; flex: 1;">
                ✨ 替换为新血脉
            </button>
            <button onclick="keepOldBloodline()" style="background: linear-gradient(45deg, #f44336, #c62828); color: white; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 15px; flex: 1;">
                ❌ 保留旧血脉
            </button>
        </div>
        
        ${canContinue ? `
            <div style="margin-top: 15px;">
                <button onclick="continueBloodlineFromDialog()" style="background: linear-gradient(45deg, #d4af37, #b8941f); color: black; border: none; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 15px; width: 100%;">
                    🔄 继续开启 (消耗1个检测剂)
                </button>
            </div>
        ` : ''}
        
        <button onclick="closeBloodlineReplaceDialog()" style="background: rgba(255,255,255,0.1); color: #aaa; border: 2px solid #666; padding: 10px 25px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 14px; margin-top: 20px;">
            取消
        </button>
    `;
    
    document.body.appendChild(dialog);
}
function replaceBloodline() {
    if (window.tempNewBloodline) {
        const newBloodline = window.tempNewBloodline;
        player.cultivation.bloodline = newBloodline;
        
        // 关闭弹窗
        closeBloodlineReplaceDialog();
        
        // 显示结果
        document.getElementById('bloodlineResult').innerHTML = `
            <div style="font-size: 20px; font-weight: bold; color: #FFD700;">替换为${newBloodline.name}!</div>
            <div>加成: ${(newBloodline.bonus * 100).toFixed(1)}%</div>
        `;
        
        logAction(`替换血脉为: ${newBloodline.name} (加成${(newBloodline.bonus * 100).toFixed(1)}%)`, "success");
        updateCultivationUI();
        updateDisplay();
        
        // 清除临时变量
        window.tempNewBloodline = null;
    }
}

// 保留旧血脉
function keepOldBloodline() {
    const oldBloodline = player.cultivation.bloodline;
    
    // 关闭弹窗
    closeBloodlineReplaceDialog();
    
    // 显示结果
    document.getElementById('bloodlineResult').innerHTML = `
        <div style="font-size: 20px; font-weight: bold; color: #FFD700;">保留当前血脉</div>
        <div style="font-size: 16px; color: #aaa; margin-top: 5px;">${oldBloodline.name} (${(oldBloodline.bonus * 100).toFixed(1)}%)</div>
    `;
    
    logAction(`保留当前血脉: ${oldBloodline.name}`, "info");
    
    // 清除临时变量
    window.tempNewBloodline = null;
}
function continueBloodlineFromDialog() {
    if (!window.tempNewBloodline) return;
    
    // 关闭当前弹窗
    closeBloodlineReplaceDialog();
    
    // 检查是否有检测剂
    if (player.items.bloodlineDetector < 1) {
        logAction("血脉检测剂不足，无法继续开启！", "error");
        
        // 如果没有检测剂，询问是否保留当前新血脉
        if (confirm('检测剂不足！是否保留刚才抽到的血脉？')) {
            replaceBloodline();
        }
        return;
    }
    
    // 消耗检测剂
    player.items.bloodlineDetector--;
    
    // 重新抽取
    const rand = Math.random();
    let tier;
    
    if (rand < 0.8) {
        tier = "tier1";
    } else if (rand < 0.96) {
        tier = "tier2";
    } else if (rand < 0.992) {
        tier = "tier3";
    } else if (rand < 0.9984) {
        tier = "tier4";
    } else if (rand < 0.99968) {
        tier = "tier5";
    } else if (rand < 0.999936) {
        tier = "tier6";
    } else if (rand < 0.9999872) {
        tier = "tier7";
    } else if (rand < 0.99999744) {
        tier = "tier8";
    } else {
        tier = "tier9";
    }
    
    const bloodlines = bloodlineConfig[tier];
    const newBloodline = bloodlines[Math.floor(Math.random() * bloodlines.length)];
    
    // 保存新抽取的血脉
    window.tempNewBloodline = newBloodline;
    
    // 再次显示替换弹窗
    showBloodlineReplaceDialog();
}
function closeBloodlineReplaceDialog() {
    const overlay = document.getElementById('bloodlineReplaceOverlay');
    if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
    }
    
    const dialog = document.getElementById('bloodlineReplaceDialog');
    if (dialog && dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
    }
    
    // 清除临时变量
    window.tempNewBloodline = null;
}
function showBloodlineContinueDialog() {
    // 检查是否有临时血脉
    if (!window.tempBloodline) return;
    
    const bloodline = window.tempBloodline;
    
    // 创建遮罩层
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.background = 'rgba(0,0,0,0.8)';
    overlay.style.zIndex = '10000';
    overlay.id = 'bloodlineContinueOverlay';
    overlay.onclick = function(e) {
        if (e.target === this) closeBloodlineContinueDialog();
    };
    document.body.appendChild(overlay);
    
    // 创建弹窗
    const dialog = document.createElement('div');
    dialog.style.position = 'fixed';
    dialog.style.top = '50%';
    dialog.style.left = '50%';
    dialog.style.transform = 'translate(-50%, -50%)';
    dialog.style.background = 'linear-gradient(145deg, #2c2c54, #40407a)';
    dialog.style.color = 'white';
    dialog.style.padding = '30px';
    dialog.style.border = '3px solid #d4af37';
    dialog.style.borderRadius = '20px';
    dialog.style.zIndex = '1000111';
    dialog.style.width = '450px';
    dialog.style.textAlign = 'center';
    dialog.style.boxShadow = '0 10px 40px rgba(212,175,55,0.3)';
    dialog.style.animation = 'pop-up 0.3s';
    dialog.id = 'bloodlineContinueDialog';
    
    // 根据加成确定颜色
    let color = '#d4af37';
    if (bloodline.bonus >= 3.9) color = '#FF4500';
    else if (bloodline.bonus >= 2.9) color = '#FF69B4';
    else if (bloodline.bonus >= 1.9) color = '#9C27B0';
    else if (bloodline.bonus >= 1.55) color = '#2196F3';
    
    dialog.innerHTML = `
        <div style="position: absolute; top: -15px; left: -15px; font-size: 30px;">💉</div>
        <div style="position: absolute; top: -15px; right: -15px; font-size: 30px;">⚡</div>
        
        <h3 style="color: ${color}; margin-top: 0; margin-bottom: 20px; font-size: 28px; text-shadow: 0 0 10px ${color};">💫 稀有血脉出现！</h3>
        
        <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px; margin-bottom: 25px; border: 2px solid ${color};">
            <div style="font-size: 48px; margin-bottom: 10px;">💉</div>
            <div style="font-size: 26px; font-weight: bold; color: ${color}; margin-bottom: 10px;">${bloodline.name}</div>
            <div style="font-size: 18px; color: #FFD700; margin-bottom: 5px;">加成: ${(bloodline.bonus * 100).toFixed(1)}%</div>
            <div style="font-size: 14px; color: #aaa; margin-top: 10px;">品阶: ${getBloodlineTierName(bloodline.bonus)}</div>
        </div>
        
        <div style="margin-bottom: 25px;">
            <div style="color: #FFD700; font-size: 16px; margin-bottom: 10px;">是否继续开启宝箱？</div>
            <div style="color: #aaa; font-size: 14px;">如果选择继续，将消耗1个检测剂再次抽取</div>
        </div>
        
        <div style="display: flex; gap: 15px; justify-content: center;">
            <button onclick="keepBloodlineAndStop()" style="background: linear-gradient(45deg, #4CAF50, #2E7D32); color: white; border: none; padding: 15px 20px; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 16px; flex: 1;">
                ✨ 保留
            </button>
        </div>
        
        <button onclick="closeBloodlineContinueDialog()" style="background: rgba(244,67,54,0.2); color: #f44336; border: 2px solid #f44336; padding: 10px 25px; border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 14px; margin-top: 20px;">
            取消 (不保留)
        </button>
    `;
    
    document.body.appendChild(dialog);
}

// 获取血脉品阶名称
function getBloodlineTierName(bonus) {
    if (bonus >= 9.9) return '神话级';
    if (bonus >= 4.9) return '传说级';
    if (bonus >= 3.9) return '史诗级';
    if (bonus >= 2.9) return '极品';
    if (bonus >= 1.9) return '稀有';
    if (bonus >= 1.55) return '珍贵';
    return '普通';
}

// 保留血脉并停止
function keepBloodlineAndStop() {
    if (window.tempBloodline) {
        const bloodline = window.tempBloodline;
        player.cultivation.bloodline = bloodline;
        
        // 关闭弹窗
        closeBloodlineContinueDialog();
        
        // 显示结果
        const resultDiv = document.getElementById('bloodlineResult');
        if (resultDiv) {
            resultDiv.innerHTML = `
                <div style="font-size: 20px; font-weight: bold; color: #FFD700;">获得${bloodline.name}!</div>
                <div>加成: ${(bloodline.bonus * 100).toFixed(1)}%</div>
            `;
        }
        
        logAction(`获得稀有血脉: ${bloodline.name} (加成${(bloodline.bonus * 100).toFixed(1)}%)`, "success");
        updateCultivationUI();
        updateDisplay();
        
        // 清除临时变量
        window.tempBloodline = null;
    } else {
        closeBloodlineContinueDialog();
    }
}

// 继续开启血脉宝箱
function continueBloodline() {
    // 关闭当前弹窗
    closeBloodlineContinueDialog();
    
    // 检查是否有检测剂
    if (player.items.bloodlineDetector < 1) {
        logAction("血脉检测剂不足，无法继续开启！", "error");
        
        // 如果没有检测剂，可以保留当前血脉
        if (window.tempBloodline) {
            if (confirm('检测剂不足！是否保留当前血脉？')) {
                keepBloodlineAndStop();
            }
        }
        return;
    }
    
    // 消耗检测剂
    player.items.bloodlineDetector--;
    
    // 重新抽取
    const rand = Math.random();
    let tier;
    
    if (rand < 0.8) {
        tier = "tier1";
    } else if (rand < 0.96) {
        tier = "tier2";
    } else if (rand < 0.992) {
        tier = "tier3";
    } else if (rand < 0.9984) {
        tier = "tier4";
    } else if (rand < 0.99968) {
        tier = "tier5";
    } else if (rand < 0.999936) {
        tier = "tier6";
    } else if (rand < 0.9999872) {
        tier = "tier7";
    } else if (rand < 0.99999744) {
        tier = "tier8";
    } else {
        tier = "tier9";
    }
    
    const bloodlines = bloodlineConfig[tier];
    const newBloodline = bloodlines[Math.floor(Math.random() * bloodlines.length)];
    
    // 检查新抽取的血脉是否达到155%以上
    if (newBloodline.bonus >= 1.55) {
        window.tempBloodline = newBloodline;
        showBloodlineContinueDialog();
    } else {
        // 直接更新玩家血脉
        player.cultivation.bloodline = newBloodline;
        
        // 显示结果
        const resultDiv = document.getElementById('bloodlineResult');
        if (resultDiv) {
            resultDiv.innerHTML = `
                <div style="font-size: 20px; font-weight: bold; color: #FFD700;">继续获得${newBloodline.name}!</div>
                <div>加成: ${(newBloodline.bonus * 100).toFixed(1)}%</div>
            `;
        }
        
        logAction(`继续获得血脉: ${newBloodline.name} (加成${(newBloodline.bonus * 100).toFixed(1)}%)`, "success");
        updateCultivationUI();
        updateDisplay();
    }
    
    // 清除临时变量
    window.tempBloodline = null;
}

// 关闭血脉继续弹窗（不保留也不继续）
function closeBloodlineContinueDialog() {
    const overlay = document.getElementById('bloodlineContinueOverlay');
    if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
    }
    
    const dialog = document.getElementById('bloodlineContinueDialog');
    if (dialog && dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
    }
    
    // 清除临时变量（如果用户取消，不保留血脉）
    window.tempBloodline = null;
}
// 升级修仙阶段
function upgradeCultivation() {
    console.log("升级前阶段:", player.cultivation.stage);
    
    const nextStageIndex = player.cultivation.stage + 1;
    
    // 检查是否有下一阶段
    if (nextStageIndex >= cultivationStages.length) {
        logAction("已达最高境界，无法继续升级", "info");
        return;
    }
    
    const nextStage = cultivationStages[nextStageIndex];
    
    // 检查经验是否足够
    if (player.cultivation.exp < nextStage.expRequired) {
        logAction("经验不足，无法升级", "error");
        return;
    }
    
    // 扣除经验并升级
    player.cultivation.exp -= nextStage.expRequired;
    player.cultivation.stage = nextStageIndex;
    
    console.log("升级后阶段:", player.cultivation.stage);
    logAction(`成功晋升${nextStage.name}境界！`, "success");
    
    // 更新显示
    updateDisplay();
    updateCultivationUI(); // 如果修仙界面打开，也需要更新
}
// 更新修仙经验UI显示
function updateCultivationExpUI(expGain, equippedBonus, collectionBonus) {
    const expPerMinuteElement = document.getElementById('currentExpPerMinute');
    const collectionInfoElement = document.getElementById('magicToolCollectionInfo');
    
    if (expPerMinuteElement) {
        expPerMinuteElement.textContent = expGain.toFixed(2);
    }
    
    // 更新法宝收集加成显示
    if (collectionInfoElement) {
        const ownedCount = player.magicTools?.inventory?.length || 0;
        collectionInfoElement.innerHTML = `
            <div style="color: #4CAF50; font-size: 14px;">
                法宝收集加成: ${ownedCount}个法宝 × 1% = <span style="color: #FFD700; font-weight: bold;">${((collectionBonus - 1) * 100).toFixed(1)}%</span>
            </div>
            <div style="color: #aaa; font-size: 12px; margin-top: 5px;">
                装备加成: ${equippedBonus.toFixed(1)}倍，总加成: ${(equippedBonus * collectionBonus).toFixed(2)}倍
            </div>
        `;
    }
    
    // 更新法宝加成显示
    const magicToolBonusElement = document.getElementById('magicToolMultiplier');
    if (magicToolBonusElement) {
        const totalBonus = equippedBonus * collectionBonus;
        magicToolBonusElement.textContent = totalBonus.toFixed(2);
    }
}
// 每分钟获取经验
function gainCultivationExp() {
    if (!player.cultivation) {
        console.log("玩家没有修仙系统");
        return;
    }
    
    if (!player.cultivation.root || !player.cultivation.bloodline) {
        console.log("玩家没有灵根或血脉");
        document.getElementById('currentExpPerMinute').textContent = "0 (需要灵根和血脉)";
        return;
    }
    
    // 计算基础加成
    const rootBonus = player.cultivation.root.bonus;
    const bloodlineBonus = player.cultivation.bloodline.bonus;
    
    // 计算法宝加成（如果有装备法宝）
    let toolBonus = 1;
    if (player.magicTools && player.magicTools.equipped) {
        const tool = magicToolConfig.tools.find(t => t.id === player.magicTools.equipped);
        if (tool) {
            toolBonus = tool.bonus;
        }
    }
    
    // 计算法宝收集加成：每拥有一个法宝额外提升1%
    let collectionBonus = 1;
    if (player.magicTools && player.magicTools.inventory) {
        const ownedToolsCount = player.magicTools.inventory.length;
        collectionBonus = 1 + (ownedToolsCount * 0.01);
    }
     // 获取探险家职业的修仙经验加成
    const classBonuses = calculateClassBonuses();
    const cultivationExpMultiplier = classBonuses.cultivationExpMultiplier || 1;
    // 每分钟经验 = 转生次数 × 灵根加成 × 血脉加成 × 装备法宝加成 × 收集加成 × 洞府聚灵阵加成
    const grottoBonus = typeof getGrottoCultivationExpBonus === 'function' ? getGrottoCultivationExpBonus() : 1;
    const expPerMinute = (rootBonus * bloodlineBonus * toolBonus * collectionBonus * cultivationExpMultiplier * grottoBonus) * player.reincarnationCount;
    
    // 每秒增加经验（除以60得到每秒经验）
    const expPerSecond = expPerMinute / 60;
    player.cultivation.exp += expPerSecond;
    
    // 悟道台挂机修仙经验
    if (typeof processEnlightenmentTick === 'function') processEnlightenmentTick();
    
    // 更新阶段加成
    const stage = cultivationStages[player.cultivation.stage];
    if (stage) {
        player.cultivation.bonus = stage.multiplier;
    }
    
    // 更新UI显示
    document.getElementById('currentExpPerMinute').textContent = formatNumber(expPerMinute);
    
    // 更新显示
    updateDisplay();
    if (typeof updateCultivationUI === 'function') {
        updateCultivationUI();
    }
}
let lastOnlineTime = Date.now();
function checkOfflineTime() {
    const now = Date.now();
    const offlineMinutes = Math.floor((now - lastOnlineTime) / 60000); // 转换为分钟
    
    console.log(`上次在线: ${new Date(lastOnlineTime).toLocaleString()}`);
    console.log(`当前时间: ${new Date(now).toLocaleString()}`);
    console.log(`离线分钟: ${offlineMinutes}`);
    
    if (offlineMinutes > 0) {
        
        const maxOfflineMinutes = 3 * 24 * 60; // 3天
        const actualOfflineMinutes = Math.min(offlineMinutes, maxOfflineMinutes);
        
        if (actualOfflineMinutes > 0) {
            calculateOfflineCultivationExp(actualOfflineMinutes);
        }
    }
    
    // 更新最后在线时间
    lastOnlineTime = now;
}
window.addEventListener('load', function() {
    // 从localStorage读取上次在线时间（与主存档一致：优先关页时间，否则用主存档 lastUpdate）
    const savedLastOnline = localStorage.getItem('lastOnlineTime');
    if (savedLastOnline) {
        lastOnlineTime = parseInt(savedLastOnline);
    } else {
        try {
            var save = JSON.parse(localStorage.getItem('goldGameSave'));
            if (save && save.lastUpdate != null) lastOnlineTime = save.lastUpdate;
        } catch (e) {}
    }
    
    // 检查离线时间
    checkOfflineTime();
    
    // 开始定时更新
    registerInterval(function() {
        // 每分钟更新一次最后在线时间
        lastOnlineTime = Date.now();
        localStorage.setItem('lastOnlineTime', lastOnlineTime.toString());
    }, 60000);
});

// 在页面关闭前保存最后在线时间
window.addEventListener('beforeunload', function() {
    localStorage.setItem('lastOnlineTime', Date.now().toString());
});
// 计算离线经验
function calculateOfflineCultivationExp(offlineMinutes) {
    console.log("计算离线经验，离线分钟数:", offlineMinutes);
    
    // 检查玩家是否有修仙系统
    if (!player.cultivation) {
        console.log("玩家没有修仙系统");
        return;
    }
    
    // 检查是否有灵根和血脉
    if (!player.cultivation.root || !player.cultivation.bloodline) {
        console.log("玩家没有灵根或血脉，无法获得修仙经验");
        logAction("需要先获取灵根和血脉才能获得离线修仙经验", "info");
        return;
    }
    
    // 计算基础加成
    const rootBonus = player.cultivation.root.bonus;
    const bloodlineBonus = player.cultivation.bloodline.bonus;
    
    // 计算法宝加成（如果有装备法宝）；loadSave 可能早于 magicToolConfig 定义执行，用 try-catch 避免 TDZ 报错
    var toolBonus = 1;
    try {
        if (player.magicTools && player.magicTools.equipped) {
            var tool = magicToolConfig.tools.find(function(t) { return t.id === player.magicTools.equipped; });
            if (tool) toolBonus = tool.bonus;
        }
    } catch (e) {
        toolBonus = 1;
    }
    
    // 计算法宝收集加成：每拥有一个法宝额外提升1%
    let collectionBonus = 1;
    if (player.magicTools && player.magicTools.inventory) {
        const ownedToolsCount = player.magicTools.inventory.length;
        collectionBonus = 1 + (ownedToolsCount * 0.01);
    }
    // 获取探险家职业的修仙经验加成；loadSave 可能早于 classConfig 定义，用 try-catch 避免 TDZ 报错
    var cultivationExpMultiplier = 1;
    try {
        var classBonuses = calculateClassBonuses();
        cultivationExpMultiplier = classBonuses.cultivationExpMultiplier || 1;
    } catch (e) {
        cultivationExpMultiplier = 1;
    }
    // 洞府聚灵阵加成
    const grottoBonus = typeof getGrottoCultivationExpBonus === 'function' ? getGrottoCultivationExpBonus() : 1;
    // 每分钟经验 = 转生次数 × 灵根加成 × 血脉加成 × 装备法宝加成 × 收集加成 × 洞府聚灵阵加成
    const expPerMinute = (rootBonus * bloodlineBonus * toolBonus * collectionBonus * cultivationExpMultiplier * grottoBonus) * player.reincarnationCount;
    
    // 计算总离线经验
    const totalExpGain = expPerMinute * offlineMinutes;
    
    console.log(`每分钟经验: ${expPerMinute}, 离线分钟: ${offlineMinutes}, 总经验: ${totalExpGain}`);
    
    if (totalExpGain > 0) {
        // 增加修仙经验
        player.cultivation.exp += totalExpGain;
        
        // 记录日志
        logAction(`离线获得 ${formatNumber(totalExpGain)} 点修仙经验 (${offlineMinutes}分钟 × ${formatNumber(expPerMinute)}/分钟)`, "success");
        
        // 检查是否有境界突破；loadSave 可能早于 cultivationStages 定义，用 try-catch 避免 TDZ 报错
        try { checkCultivationBreakthrough(); } catch (e) { }
        
        // 更新显示
        updateDisplay();
        if (typeof updateCultivationUI === 'function') {
            try { updateCultivationUI(); } catch (e) { /* cultivationStages 可能尚未定义 */ }
        }
    } else {
        console.log("离线经验为0，可能是转生次数为0或加成倍率为0");
        if (player.reincarnationCount === 0) {
            logAction("转生次数为0，无法获得修仙经验", "info");
        }
    }
}
function checkCultivationBreakthrough() {
    if (!player.cultivation) return;
    
    let breakthrough = false;
    let currentStage = player.cultivation.stage;
    
    // 检查是否可以连续突破
    while (true) {
        const nextStageIndex = player.cultivation.stage + 1;
        if (nextStageIndex >= cultivationStages.length) break;
        
        const nextStage = cultivationStages[nextStageIndex];
        if (player.cultivation.exp >= nextStage.expRequired) {
            // 突破境界
            player.cultivation.exp -= nextStage.expRequired;
            player.cultivation.stage = nextStageIndex;
            breakthrough = true;
            
            logAction(`离线突破至 ${nextStage.name} 境界！`, "success");
        } else {
            break;
        }
    }
    
    return breakthrough;
}
// 称号配置（按分支分组）
const titleConfig = {
     towerBranyy: [
    { name: "钓竿初握", condition: (p) => p.fishing.level > 2, bonus: { attackMultiplier: 1.1 } },
    { name: "河塘渔夫", condition: (p) => p.fishing.level > 5, bonus: { attackMultiplier: 1.1 } },
    { name: "渔获大师", condition: (p) => p.fishing.level > 7, bonus: { attackMultiplier: 1.1 } },
    { name: "万鱼臣服", condition: (p) => p.fishing.level > 10, bonus: { attackMultiplier: 1.2 } },
    { name: "钓尽乾坤", condition: (p) => p.fishing.level > 14, bonus: { attackMultiplier: 1.2 } },
    { name: "小农夫", condition: (p) => p.farm.level > 2, bonus: { attackMultiplier: 1.1 } },
    { name: "田园熟手", condition: (p) => p.farm.level > 5, bonus: { attackMultiplier: 1.1 } },
    { name: "农耕大师", condition: (p) => p.farm.level > 15, bonus: { attackMultiplier: 1.1 } },
    { name: "庄园尊主", condition: (p) => p.farm.level > 25, bonus: { attackMultiplier: 1.2 } },
    { name: "大地主宰", condition: (p) => p.farm.level > 35, bonus: { attackMultiplier: 1.2 } },
    { name: "车途学徒", condition: (p) => p.parking.level > 2, bonus: { attackMultiplier: 1.1 } },
    { name: "赛道枭雄", condition: (p) => p.parking.level > 7, bonus: { attackMultiplier: 1.1 } },
    { name: "车坛至尊", condition: (p) => p.parking.level > 14, bonus: { attackMultiplier: 1.1 } },
    { name: "巅峰车皇", condition: (p) => p.parking.level > 24, bonus: { attackMultiplier: 1.2 } },
    { name: "寰宇车神", condition: (p) => p.parking.level > 34, bonus: { attackMultiplier: 1.2 } },
    { name: "创世车帝", condition: (p) => p.parking.level > 39, bonus: { attackMultiplier: 1.2 } },
    { name: "百万元户", condition: (p) => p.landlord.stats.totalCoinsEarned > 1000000, bonus: { healthMultiplier: 1.1 } },
    { name: "千万富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 10000000, bonus: { healthMultiplier: 1.1 } },
    { name: "亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 100000000, bonus: { healthMultiplier: 1.1 } },
    { name: "十亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 1000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "百亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 10000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "千亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 100000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "万亿富翁", condition: (p) => p.landlord.stats.totalCoinsEarned > 1000000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "高富帅", condition: (p) => p.landlord.stats.totalCoinsEarned > 10000000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "股侠", condition: (p) => p.investmentGame.userData.availableFunds > 100000, bonus: { healthMultiplier: 1.1 } },
    { name: "股霸", condition: (p) => p.investmentGame.userData.availableFunds > 10000000, bonus: { healthMultiplier: 1.1 } },
    { name: "股王", condition: (p) => p.investmentGame.userData.availableFunds > 1000000000, bonus: { healthMultiplier: 1.1 } },
    { name: "股圣", condition: (p) => p.investmentGame.userData.availableFunds > 100000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "股神", condition: (p) => p.investmentGame.userData.availableFunds > 10000000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "股仙", condition: (p) => p.investmentGame.userData.availableFunds > 1000000000000000, bonus: { healthMultiplier: 1.2 } },
    { name: "萌新矿工", condition: (p) => p.mining.depth > 1000, bonus: { attackMultiplier: 1.1 } },
    { name: "勤奋矿工", condition: (p) => p.mining.depth > 10000, bonus: { attackMultiplier: 1.1 } },
    { name: "黄金矿工", condition: (p) => p.mining.depth > 100000, bonus: { attackMultiplier: 1.1 } },
    { name: "钻石矿工", condition: (p) => p.mining.depth > 1000000, bonus: { attackMultiplier: 1.2 } },
    { name: "星辰矿工", condition: (p) => p.mining.depth > 10000000, bonus: { attackMultiplier: 1.2 } },
    { name: "创世矿工神", condition: (p) => p.mining.depth > 100000000, bonus: { attackMultiplier: 1.2 } }
   ], 
     towerBranch: [
    { name: "关破厉鬼", condition: (p) => p.tower.maxFloor > 10, bonus: { healthMultiplier: 1.1 } },
    { name: "阶碎无常", condition: (p) => p.tower.maxFloor > 500, bonus: { healthMultiplier: 1.1 } },
    { name: "踏塔马面", condition: (p) => p.tower.maxFloor > 1000, bonus: { healthMultiplier: 1.1 } },
    { name: "魔修夜叉", condition: (p) => p.tower.maxFloor > 5000, bonus: { healthMultiplier: 1.1 } },
    { name: "破阶修罗", condition: (p) => p.tower.maxFloor > 7500, bonus: { healthMultiplier: 1.1 } },
    { name: "千层煞主", condition: (p) => p.tower.maxFloor > 10000, bonus: { healthMultiplier: 1.1 } },
    { name: "踏关煞神", condition: (p) => p.tower.maxFloor > 25000, bonus: { healthMultiplier: 1.1 } },
    { name: "关前冥王", condition: (p) => p.tower.maxFloor > 50000, bonus: { healthMultiplier: 1.1 } },
    { name: "踏塔狂魔", condition: (p) => p.tower.maxFloor > 75000, bonus: { healthMultiplier: 1.1 } },
    { name: "混世魔王", condition: (p) => p.tower.maxFloor > 100000, bonus: { healthMultiplier: 1.1 } },
    { name: "屠戮之主", condition: (p) => p.tower.maxFloor > 150000, bonus: { healthMultiplier: 1.2 } },
    { name: "杀戮之神", condition: (p) => p.tower.maxFloor > 200000, bonus: { healthMultiplier: 1.2 } },
    { name: "十殿阎罗", condition: (p) => p.tower.maxFloor > 250000, bonus: { healthMultiplier: 1.2 } },
    { name: "弑神修罗", condition: (p) => p.tower.maxFloor > 300000, bonus: { healthMultiplier: 1.2 } },
    { name: "九幽魔尊", condition: (p) => p.tower.maxFloor > 350000, bonus: { healthMultiplier: 1.2 } },
    { name: "永夜君主", condition: (p) => p.tower.maxFloor > 400000, bonus: { healthMultiplier: 1.2 } },
    { name: "深渊主宰", condition: (p) => p.tower.maxFloor > 450000, bonus: { healthMultiplier: 1.2 } }
],
    // 关卡分支
    stageBranch: [
        { name: "探险者", condition: (p) => p.battle.maxStage > 10, bonus: { attackMultiplier: 1.1 } },
        { name: "银翼斥候", condition: (p) => p.battle.maxStage > 100, bonus: { attackMultiplier: 1.1 } },
        { name: "圣域行者", condition: (p) => p.battle.maxStage > 250, bonus: { attackMultiplier: 1.1 } },
        { name: "苍穹之主", condition: (p) => p.battle.maxStage > 500, bonus: { attackMultiplier: 1.1 } },
        { name: "九天至尊", condition: (p) => p.battle.maxStage > 1000, bonus: { attackMultiplier: 1.2 } },
        { name: "万域之主", condition: (p) => p.battle.maxStage > 1500, bonus: { attackMultiplier: 1.2 } },
        { name: "寰宇独尊", condition: (p) => p.battle.maxStage > 2000, bonus: { attackMultiplier: 1.2 } },
        { name: "万界臣服", condition: (p) => p.battle.maxStage > 2500, bonus: { attackMultiplier: 1.3 } },
        { name: "天地共主", condition: (p) => p.battle.maxStage > 3000, bonus: { attackMultiplier: 1.4 } },
        { name: "星河主宰", condition: (p) => p.battle.maxStage > 3500, bonus: { attackMultiplier: 1.4 } },
        { name: "太虚之皇", condition: (p) => p.battle.maxStage > 4000, bonus: { attackMultiplier: 1.5 } },
        { name: "六道归一", condition: (p) => p.battle.maxStage > 4500, bonus: { attackMultiplier: 1.5 } }
    ],
    // 转生分支
    reincarnationBranch: [
        { name: "初涉江湖", condition: (p) => p.reincarnationCount > 5, bonus: { healthMultiplier: 1.2 } },
        { name: "俗世门徒", condition: (p) => p.reincarnationCount > 10, bonus: { healthMultiplier: 1.2 } },
        { name: "人中龙凤", condition: (p) => p.reincarnationCount > 50, bonus: { healthMultiplier: 1.2 } },
        { name: "一方翘楚", condition: (p) => p.reincarnationCount > 100, bonus: { healthMultiplier: 1.2 } },
        { name: "超凡入圣", condition: (p) => p.reincarnationCount > 250, bonus: { healthMultiplier: 1.2 } },
        { name: "一代宗师", condition: (p) => p.reincarnationCount > 500, bonus: { healthMultiplier: 1.2 } },
        { name: "盖世之才", condition: (p) => p.reincarnationCount > 1000, bonus: { healthMultiplier: 1.2 } },
        { name: "众仙之师", condition: (p) => p.reincarnationCount > 2000, bonus: { healthMultiplier: 1.2 } },
        { name: "创世之灵", condition: (p) => p.reincarnationCount > 3000, bonus: { healthMultiplier: 1.2 } },
        { name: "万神之主", condition: (p) => p.reincarnationCount > 5000, bonus: { healthMultiplier: 1.2 } },
        { name: "无上真神", condition: (p) => p.reincarnationCount > 10000, bonus: { healthMultiplier: 1.2 } },
        { name: "寰宇神尊", condition: (p) => p.reincarnationCount > 50000, bonus: { healthMultiplier: 1.2 } },
        { name: "创世神帝", condition: (p) => p.reincarnationCount > 100000, bonus: { healthMultiplier: 1.2 } }
    ],
    // 驯兽师分支
    tamerBranch: [
        { name: "初级驯兽师", condition: (p) => p.pets?.thunderKirin?.level > 50, bonus: { critMultiplier: 1.1 } },
        { name: "中级驯兽师", condition: (p) => p.pets?.netherQiongqi?.level > 30, bonus: { critMultiplier: 1.1 } },
        { name: "高级驯兽师", condition: (p) => p.pets?.primordialZhuLong?.level > 10, bonus: { critMultiplier: 1.2 } },
        { name: "圣级驯兽师", condition: (p) => p.pets?.yanYuBiAn?.level > 10, bonus: { critMultiplier: 1.2 } },
        { name: "神级驯兽师", condition: (p) => p.pets?.yuyu2?.level > 10, bonus: { critMultiplier: 1.3 } },
        { name: "人级驯兽师", condition: (p) => p.pets?.yuyu3?.level > 10, bonus: { critMultiplier: 1.3 } },
        { name: "地级驯兽师", condition: (p) => p.pets?.yuyu4?.level > 10, bonus: { critMultiplier: 1.4 } },
        { name: "天级驯兽师", condition: (p) => p.pets?.yuyu5?.level > 10, bonus: { critMultiplier: 1.4 } },
        { name: "帝级驯兽师", condition: (p) => p.pets?.yuyu6?.level > 10, bonus: { critMultiplier: 1.4 } },
        { name: "仙级驯兽师", condition: (p) => p.pets?.yuyu7?.level > 10, bonus: { critMultiplier: 1.5 } },
        { name: "创世级驯兽师", condition: (p) => p.pets?.yuyu8?.level > 10, bonus: { critMultiplier: 1.5 } }
    ],
    // 魂环分支
    soulRingBranch: [
        { name: "魂士", condition: (p) => hasSoulRing(p, "year1"), bonus: { attackMultiplier: 1.1 } },
        { name: "魂师", condition: (p) => hasSoulRing(p, "year100"), bonus: { attackMultiplier: 1.1 } },
        { name: "大魂师", condition: (p) => hasSoulRing(p, "year10000"), bonus: { attackMultiplier: 1.2 } },
        { name: "魂尊", condition: (p) => hasSoulRing(p, "year1000000"), bonus: { attackMultiplier: 1.2 } },
        { name: "魂宗", condition: (p) => hasSoulRing(p, "year3"), bonus: { attackMultiplier: 1.3 } },
        { name: "魂王", condition: (p) => hasSoulRing(p, "year7"), bonus: { attackMultiplier: 1.3 } },
        { name: "魂帝", condition: (p) => hasSoulRing(p, "year13"), bonus: { attackMultiplier: 1.3 } },
        { name: "魂圣", condition: (p) => hasSoulRing(p, "year18"), bonus: { attackMultiplier: 1.4 } },
        { name: "魂斗罗", condition: (p) => hasSoulRing(p, "year23"), bonus: { attackMultiplier: 1.4 } },
        { name: "普通封号斗罗", condition: (p) => hasSoulRing(p, "year28"), bonus: { attackMultiplier: 1.5 } },
        { name: "巅峰斗罗", condition: (p) => hasSoulRing(p, "year33"), bonus: { attackMultiplier: 1.5 } },
        { name: "绝世斗罗", condition: (p) => hasSoulRing(p, "year37"), bonus: { attackMultiplier: 1.5 } }
    ],
    // 特殊分支
    specialBranch: [
        { name: "萌新", condition: (p) => p.gold > 100000000000000, bonus: { attackMultiplier: 1.1 } },
        { name: "公测玩家", condition: (p) => p.usedActivationCodes.includes("VIP666777"), bonus: { attackMultiplier: 1.2 } },
        { name: "持剑学徒", condition: (p) => getEquipLevel(p, "废品") > 1, bonus: { attackMultiplier: 1.1 } },
        { name: "疾风剑者", condition: (p) => getEquipLevel(p, "废品") > 1000, bonus: { attackMultiplier: 1.1 } },
        { name: "断水剑师", condition: (p) => getEquipLevel(p, "废品") > 10000, bonus: { attackMultiplier: 1.1 } },
        { name: "九霄剑王", condition: (p) => getEquipLevel(p, "废品") > 100000, bonus: { attackMultiplier: 1.1 } },
        { name: "独孤剑皇", condition: (p) => getEquipLevel(p, "废品") > 500000, bonus: { attackMultiplier: 1.1 } },
        { name: "剑域之主", condition: (p) => getEquipLevel(p, "废品") > 1000000, bonus: { attackMultiplier: 1.2 } },
        { name: "万剑之神", condition: (p) => getEquipLevel(p, "废品") > 5000000, bonus: { attackMultiplier: 1.2 } },
        { name: "鸿蒙剑祖", condition: (p) => getEquipLevel(p, "废品") > 10000000, bonus: { attackMultiplier: 1.2 } },
        { name: "万劫剑神", condition: (p) => getEquipLevel(p, "废品") > 50000000, bonus: { attackMultiplier: 1.3 } },
        { name: "无上剑神", condition: (p) => getEquipLevel(p, "废品") > 100000000, bonus: { attackMultiplier: 1.3 } },
        { name: "剑狱之尊", condition: (p) => getEquipLevel(p, "废品") > 200000000, bonus: { attackMultiplier: 1.3 } },
        { name: "剑主洪荒", condition: (p) => getEquipLevel(p, "废品") > 300000000, bonus: { attackMultiplier: 1.3 } },
        { name: "御诸剑神", condition: (p) => getEquipLevel(p, "废品") > 400000000, bonus: { attackMultiplier: 1.4 } },
        { name: "创造剑神", condition: (p) => getEquipLevel(p, "废品") > 1000000000, bonus: { attackMultiplier: 1.4 } },
        { name: "位面剑荒", condition: (p) => getEquipLevel(p, "废品") > 5000000000, bonus: { attackMultiplier: 1.5 } },
        { name: "八荒之剑我为尊", condition: (p) => getEquipLevel(p, "废品") > 10000000000, bonus: { attackMultiplier: 1.5 } }
    ]
};
// 辅助函数：检查是否拥有指定魂环
function hasSoulRing(player, typeName) {
return player.soulRings.some(ring => ring.type === typeName);
}

// 辅助函数：获取指定类型装备的最高等级
function getEquipLevel(player, equipName) {
return player.dungeonEquipment
.filter(eq => eq.name === equipName)
.reduce((max, eq) => Math.max(max, eq.level || 0), 0);
}

// 显示称号界面
function showTitleDialog() {
   if (player.reincarnationCount < 10) {
        alert("需要达到10转才能开启称号系统！");
        return;
    }
    checkTitleUnlocks(); // 先检查解锁状态
    renderTitleBranches(); // 渲染称号
    document.getElementById("titleDialog").style.display = "block";
    document.getElementById("titleOverlay").style.display = "block";
}

// 关闭称号界面
function closeTitleDialog() {
    document.getElementById("titleDialog").style.display = "none";
    document.getElementById("titleOverlay").style.display = "none";
}

// 检查并解锁称号
function checkTitleUnlocks() {
    let newlyUnlocked = false;
    // 遍历所有分支的称号
    Object.values(titleConfig).forEach(branch => {
        branch.forEach(title => {
            if (!player.titles.unlocked.includes(title.name) && title.condition(player)) {
                player.titles.unlocked.push(title.name);
                newlyUnlocked = true;
                
                // 应用称号加成
                if (title.bonus) {
                    applyTitleBonus(title.bonus);
                }
                
                logAction(`解锁新称号：${title.name}`, 'success');
            }
        });
    });
    if (newlyUnlocked) {
        saveGame();
    }
}

// 应用称号加成
function applyTitleBonus(bonus) {
    // 直接修改玩家属性
    if (bonus.attackMultiplier) {
        player.battle.playerAttack *= bonus.attackMultiplier;
    }
    if (bonus.healthMultiplier) {
        player.battle.playerHealth *= bonus.healthMultiplier;
    }
    if (bonus.critMultiplier) {
        player.battle.playerCritDamage *= bonus.critMultiplier;
    }
    // 其他属性...
    
    logAction(`称号加成生效: ${JSON.stringify(bonus)}`, 'success');
    updatePlayerBattleStats();
}

// 渲染称号分支
function renderTitleBranches() {
    // 遍历每个分支并渲染
    Object.entries(titleConfig).forEach(([branchKey, titles]) => {
        const container = document.getElementById(`${branchKey}Container`);
        if (!container) return;
        
        container.innerHTML = "";
        titles.forEach(title => {
            // 只显示已解锁的称号
            if (player.titles.unlocked.includes(title.name)) {
                const isSelected = player.titles.current === title.name;
                const titleEl = document.createElement("div");
                titleEl.className = `titleItem unlocked ${isSelected ? 'selected' : ''}`;
                titleEl.textContent = title.name;
                titleEl.onclick = () => selectTitle(title.name);
                container.appendChild(titleEl);
            }
        });
    });
}

// 选择称号
function selectTitle(titleName) {
    if (player.titles.unlocked.includes(titleName)) {
        player.titles.current = titleName;
        logAction(`已选择称号：${titleName}`, 'info');
        renderTitleBranches(); // 更新选中状态
        updateDisplay(); // 更新玩家名字旁的称号显示
        saveGame();
    }
}
// 计算称号总加成（在属性计算处调用）
function calculateTotalBonuses() {
    const bonuses = {
        attackMultiplier: 1,
        healthMultiplier: 1,
        critMultiplier: 1
    };
    
    // 累加所有已解锁称号的加成
    player.titles.unlocked.forEach(titleName => {
        // 查找对应的称号配置
        for (const branch of Object.values(titleConfig)) {
            for (const title of branch) {
                if (title.name === titleName && title.bonus) {
                    // 累乘加成
                    if (title.bonus.attackMultiplier) {
                        bonuses.attackMultiplier *= title.bonus.attackMultiplier;
                    }
                    if (title.bonus.healthMultiplier) {
                        bonuses.healthMultiplier *= title.bonus.healthMultiplier;
                    }
                    if (title.bonus.critMultiplier) {
                        bonuses.critMultiplier *= title.bonus.critMultiplier;
                    }
                    break;
                }
            }
        }
    });
    
    return bonuses;
}


// 伴侣品阶配置
const companionRarities = {
    white: { 
        name: "普通", 
        color: "#FFFFFF", 
        baseScore: 100,
        upgradeMultiplier: 1,
        talentCount: 4,
        talentRange: [0, 3], // 初级到终极
        decomposeRose: 5,
         soulItem: "banlv1"
    },
    blue: { 
        name: "稀有", 
        color: "#0000FF", 
        baseScore: 500,
        upgradeMultiplier: 3,
        talentCount: 5,
        talentRange: [0, 4], // 初级到圣级
        decomposeRose: 20,
         soulItem: "banlv2"
    },
    epic: { 
        name: "史诗", 
        color: "#800080", 
        baseScore: 1000,
        upgradeMultiplier: 10,
        talentCount: 6,
        talentRange: [0, 5], // 初级到神级
        decomposeRose: 50,
         soulItem: "banlv3"
    },
    pink: { 
        name: "卓越", 
        color: "#FF69B4", 
        baseScore: 3000,
        upgradeMultiplier: 20,
        talentCount: 7,
        talentRange: [0, 6], // 初级到远古
        decomposeRose: 100,
         soulItem: "banlv4"
    },
    orange: { 
        name: "完美", 
        color: "#FFA500", 
        baseScore: 5000,
        upgradeMultiplier: 50,
        talentCount: 8,
        talentRange: [0, 15], // 初级到太古
        decomposeRose: 200,
         soulItem: "banlv5"
    },
    red: { 
        name: "神赐", 
        color: "#FF0000", 
        baseScore: 8000,
        upgradeMultiplier: 100,
        talentCount: 10,
        talentRange: [0, 15], // 初级到洪荒
        decomposeRose: 1000,
         soulItem: "banlv6"
    },
   angel: { 
        name: '天使', 
        color: '#87CEEB',
        baseScore: 1000,
        upgradeMultiplier: 30,
        talentCount: 0, // 动态计算
        talentRange: [0, 15], // 可达到洪荒级别
        decomposeRose: 100,
         soulItem: "banlv7"
    },
  emyyyy: { 
        name: '恶魔', 
        color: '#E63946',
        baseScore: 1000,
        upgradeMultiplier: 25,
        talentCount: 0, // 动态计算
        talentRange: [0, 15], // 可达到洪荒级别
        decomposeRose: 100,
         soulItem: "banlv8"
    },
  jlyyyy: { 
        name: '妖精', 
        color: '#7CFC00',
        baseScore: 1000,
        upgradeMultiplier: 20,
        talentCount: 0, // 动态计算
        talentRange: [0, 15], // 可达到洪荒级别
        decomposeRose: 100,
         soulItem: "banlv9"
    }
};

// 天赋类型配置
const talentTypes = [
    {
        name: "攻击",
        base: 1,
        perLevel: 5,
        description: (level) => `玩家总和攻击+${(1 + 5 * level).toFixed(1)}倍`
    },
    {
        name: "爆伤",
        base: 1,
        perLevel: 5,
        description: (level) => `玩家总和爆伤+${(1 + 5 * level).toFixed(1)}倍`
    },
    {
        name: "生命",
        base: 0.001,
        perLevel: 0.001,
        description: (level) => `玩家总和生命+${(0.001 + 0.001 * level).toFixed(3)}倍`
    },
    {
        name: "全属性",
        base: 0.5,
        perLevel: 2.5,
        description: (level) => `玩家总和全属性+${(0.5 + 2.5 * level).toFixed(2)}倍`
    },
    {
        name: "连击",
        base: 1,
        perLevel: 5,
        description: (level) => `玩家连击+${1 + 5 * level}`
    },
    {
        name: "暴击率",
        base: 0.001,
        perLevel: 0.001,
        description: (level) => `玩家暴击率+${(0.001 + 0.001 * level).toFixed(3)}倍`
    }
];

// 天赋品阶名称
const talentRanks = ["初级", "中级", "高级", "终极", "圣级", "神级", "远古", "太古", "洪荒", "无上", "太初", "混沌", "虚数", "永恒", "归墟", "炁叕"];

// 伴侣名字库
const companionNames = ["闫闫", "茶茶", "沈砚山", "苏绾月", "林清瑶", "楚棠溪", "慕玄尘", "许清尘", "温玉珞", "林灵枢", "叶棠音", "陆剑尘", "楚絮晚", "陆星辞", "王富贵", "洛千尘", "白小纯", "白芷晴", "顾长歌", "沈青岚", "慕雨柔", "陆天行", "乔曦", "柳如烟", "香香", "尝试", "小萝莉", "通元", "鱼鱼", "花花"];

// 抽奖概率
const drawProbabilities = [
    {rarity: "white", prob: 0.8},
    {rarity: "blue", prob: 0.15},
    {rarity: "epic", prob: 0.01889},
    {rarity: "pink", prob: 0.001},
    {rarity: "orange", prob: 0.0001},
    {rarity: "red", prob: 0.00001}
];
const guaranteeThresholds = {
    epic: 100,   // 100次保底史诗
    pink: 500,   // 500次保底卓越
    orange: 1000, // 1000次保底完美
    red: 5000    // 5000次保底神赐
};

// 打开伴侣系统
function openCompanionSystem() {
 if (player.reincarnationCount < 30) {
        alert("需要达到30转才能开启伴侣系统！");
        return;
    }
    document.getElementById('companionSystem').style.display = 'block';
    document.getElementById('companionOverlay').style.display = 'block';
    updateCompanionDisplay();
   calculateOfflineExpeditionRewards();
    updateExpeditionUI();
}

// 关闭伴侣系统
function closeCompanionSystem() {
    document.getElementById('companionSystem').style.display = 'none';
    document.getElementById('companionOverlay').style.display = 'none';
}

// 更新伴侣系统显示
function updateCompanionDisplay() {
    // 更新等级和消耗
    document.getElementById('companionLevel').textContent = player.companionLevel;
    document.getElementById('upgradeCost').textContent = 10 * player.companionLevel;
    document.getElementById('companionKeyCount').textContent = player.items.companionKey;
    // 更新保底计数器显示
    document.getElementById('epicGuarantee').textContent = player.companionChestGuarantee.epic;
    document.getElementById('pinkGuarantee').textContent = player.companionChestGuarantee.pink;
    document.getElementById('orangeGuarantee').textContent = player.companionChestGuarantee.orange;
    document.getElementById('redGuarantee').textContent = player.companionChestGuarantee.red;
    // 更新伴侣列表
    const listContainer = document.getElementById('companionList');
    listContainer.innerHTML = '';
    const companion = player.companions.find(c => c.id === player.equippedCompanionId);
    if (companion) {
        const rarityConfig = companionRarities[companion.rarity] || {};
        const bonuses = getCompanionBonuses();
        
        // 更新显示
        document.getElementById('qualityMultiplier').textContent = 
    `${(Math.floor(companion.score / 100) + companionRarities[companion.rarity].upgradeMultiplier).toFixed(2)}x`;
        document.getElementById('attackTotalBonus').textContent = `${bonuses.attackMultiplier.toFixed(3)}倍`;
        document.getElementById('healthTotalBonus').textContent = `${bonuses.healthMultiplier.toFixed(3)}倍`;
        document.getElementById('critRateTotalBonus').textContent = `${bonuses.critRateMultiplier.toFixed(3)}倍`;
        document.getElementById('critDamageTotalBonus').textContent = `${bonuses.critDamageMultiplier.toFixed(3)}倍`;
        document.getElementById('comboTotalBonus').textContent = bonuses.combo;
        document.getElementById('allStatsTotalBonus').textContent = `${bonuses.allStatsMultiplier.toFixed(3)}倍`;
    } else {
        // 未装备伴侣时显示默认值
        const defaultText = '未装备';
        document.getElementById('qualityMultiplier').textContent = defaultText;
        document.getElementById('attackTotalBonus').textContent = defaultText;
        document.getElementById('healthTotalBonus').textContent = defaultText;
        document.getElementById('critRateTotalBonus').textContent = defaultText;
        document.getElementById('critDamageTotalBonus').textContent = defaultText;
        document.getElementById('comboTotalBonus').textContent = defaultText;
        document.getElementById('allStatsTotalBonus').textContent = defaultText;
    }

    player.companions.forEach(companion => {
        const isEquipped = player.equippedCompanionId === companion.id;
const rarityConfig = companionRarities[companion.rarity] || {};
        const rarityName = rarityConfig.name || "未知";
        const rarityColor = rarityConfig.color || "#CCCCCC";
        
        // 特殊处理天使品质的显示
        let displayName = companion.name;
        if (companion.rarity === 'angel') {
            displayName = `天使·${companion.name}`;
        }
        const capScore = Math.min(companion.score, 50000);
        let filled, emptyChar, filledChar;
        if (capScore <= 10000) {
            filled = Math.min(10, Math.floor(capScore / 1000));
            filledChar = '★'; emptyChar = '☆';
        } else if (capScore <= 20000) {
            filled = Math.min(10, Math.floor((capScore - 10000) / 1000));
            filledChar = '●'; emptyChar = '○';
        } else if (capScore <= 30000) {
            filled = Math.min(10, Math.floor((capScore - 20000) / 1000));
            filledChar = '◆'; emptyChar = '◇';
        } else if (capScore <= 40000) {
            filled = Math.min(10, Math.floor((capScore - 30000) / 1000));
            filledChar = '■'; emptyChar = '□';
        } else {
            filled = Math.min(10, Math.floor((capScore - 40000) / 1000));
            filledChar = '▲'; emptyChar = '△';
        }
        const scoreIcons = filledChar.repeat(filled) + emptyChar.repeat(10 - filled);
        
        const card = document.createElement('div');
        card.style = `background: #222; border: 2px solid ${companionRarities[companion.rarity].color}; border-radius: 5px; padding: 10px; position: relative;`;
        card.innerHTML = `
            <div style="position: absolute; top: 5px; right: 5px; color: ${companionRarities[companion.rarity].color};">
                ${companionRarities[companion.rarity].name}
            </div>
            <h4 style="color: ${companionRarities[companion.rarity].color}; margin-top: 0;">
                ${companion.name}
                <span style="margin-left: 5px; color: #FFD700;">+${companion.advanceLevel || 0}</span>
                ${companion.locked ? '🔒' : ''}
            </h4>
            </div>
    <div>${scoreIcons} (${companion.score}/50000)</div>
            <div style="margin: 5px -2; font-size: 0.8em; max-height: 190px; overflow-y: auto;">
                ${companion.talents.map(t => `${talentRanks[t.rank]}${talentTypes[t.type].name}: ${talentTypes[t.type].description(t.rank)}`).join('<br>')}
            </div>
            <div style="margin-top: 10px; display: flex; gap: 5px;">
                <button onclick="equipCompanion('${companion.id}')" style="flex: 1; background: ${isEquipped ? '#4CAF50' : '#555'}; color: white; border: none; padding: 3px; border-radius: 2px; font-size: 0.8em;">
                    ${isEquipped ? '已装备' : '装备'}
                </button>
                <button onclick="toggleCompanionLock('${companion.id}')" style="width: 30px; background: ${companion.locked ? '#f44336' : '#555'}; color: white; border: none; padding: 3px; border-radius: 2px;">
                    ${companion.locked ? '已锁' : '开锁'}
                </button>
                <button onclick="decomposeCompanion('${companion.id}')" style="width: 30px; background: #f44336; color: white; border: none; padding: 3px; border-radius: 2px;" ${companion.locked ? 'disabled' : ''}>
                    分解
                </button>
       <button onclick="advanceCompanion('${companion.id}')" style="width: 30px; background: #FFD700; color: black; border: none; padding: 3px; border-radius: 2px; margin-left: 2px;" 
    ${companion.locked || !['white','blue','epic','pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity) ? 'disabled' : ''}>
    进阶
</button>
 <button onclick="openWashPanel('${companion.id}')" style="width: 30px; background: #2196F3; color: white; border: none; padding: 3px; border-radius: 2px; margin-left: 2px;"
    ${companion.locked || !['epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity) ? 'disabled' : ''}>
    洗练
</button>
   <button onclick="openCombinePanel('${companion.id}')" style="width: 30px; background: #9C27B0; color: white; border: none; padding: 3px; border-radius: 2px; margin-left: 2px;"
    ${companion.locked || !['epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity) ? 'disabled' : ''}>
    合成
</button>
            </div>
        `;
        listContainer.appendChild(card);
    });
}
const expeditionConfig = {
    tasks: [
        {
            id: "forest",
            name: "迷雾森林",
            difficulty: "简单",
            duration: 30, // 分钟
            baseReward: {
                rose: 30,
                vipPower: 1,
                bait: 1
            },
            description: "探索神秘的迷雾森林，寻找稀有资源",
            companionRequirement: 3000 
        },
        {
            id: "mountain",
            name: "远古山脉",
            difficulty: "中等",
            duration: 60,
            baseReward: {
                rose: 80,
                vipPower: 3,
                bait: 3
            },
            description: "攀登危险的远古山脉，挑战极限",
            companionRequirement: 5000
        },
        {
            id: "ocean",
            name: "深渊海洋",
            difficulty: "困难",
            duration: 120,
            baseReward: {
                rose: 200,
                vipPower: 10,
                bait: 10
            },
            description: "潜入神秘的深渊海洋，探索未知领域",
            companionRequirement: 10000
        },
       {
            id: "volcano",
            name: "熔岩火山",
            difficulty: "极难",
            duration: 240,
            baseReward: {
                rose: 500,
                vipPower: 35,
                bait: 35
            },
            description: "穿越危险的熔岩火山，寻找传说宝藏",
            companionRequirement: 15000
        },
        {
            id: "emshen",
            name: "虚空裂缝",
            difficulty: "噩梦",
            duration: 480,
            baseReward: {
                rose: 1200,
                vipPower: 120,
                bait: 120
            },
            description: "穿越不稳定的虚空裂缝，直面维度之外的恐怖",
            companionRequirement: 20000
        },
        {
            id: "emyuan",
            name: "星际深渊",
            difficulty: "地狱",
            duration: 960,
            baseReward: {
                rose: 3000,
                vipPower: 480,
                bait: 480
            },
            description: "勇闯无尽的星际深渊，挑战宇宙终极奥秘",
            companionRequirement: 25000
        }
    ]
};

// 初始化伴侣探险数据
function initExpeditionData() {
    if (!player.companionExpedition) {
        player.companionExpedition = {
            currentExpedition: null,
            history: [],
            lastUpdate: Date.now()
        };
    }
}

// 切换探险系统显示
function toggleExpeditionSystem() {
     if (player.reincarnationCount < 30) {

        alert("需要达到30转才能开启伴侣系统！");

        return;

    }
    const ui = document.getElementById('expeditionSystemUI');
    const overlay = document.getElementById('expeditionSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initExpeditionData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateExpeditionUI();
    }
}

// 更新探险系统UI
function updateExpeditionUI() {
    // 更新任务列表
    const tasksContainer = document.getElementById('expeditionTasks');
    tasksContainer.innerHTML = '';
    
    expeditionConfig.tasks.forEach(task => {
        const taskElement = document.createElement('div');
        taskElement.style.background = '#333';
        taskElement.style.padding = '15px';
        taskElement.style.borderRadius = '8px';
        taskElement.innerHTML = `
            <h4>${task.name} (${task.difficulty})</h4>
            <p>${task.description}</p>
            <div style="margin: 10px 0;">
                <div>所需时间: ${task.duration}分钟</div>
                <div>最低伴侣评分: ${task.companionRequirement}</div>
            </div>
            <div style="margin: 10px 0;">
                <strong>基础奖励:</strong>
                <div>玫瑰花: ${task.baseReward.rose}</div>
                <div>VIP能力值: ${task.baseReward.vipPower}</div>
                <div>鱼饵: ${task.baseReward.bait}</div>
            </div>
            <button onclick="startExpedition('${task.id}')" 
                    style="background: #9C27B0; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;"
                    ${player.companionExpedition.currentExpedition ? 'disabled' : ''}>
                开始探险
            </button>
        `;
        tasksContainer.appendChild(taskElement);
    });
    
    // 更新当前探险状态
    const currentContainer = document.getElementById('currentExpedition');
    if (player.companionExpedition.currentExpedition) {
        const task = expeditionConfig.tasks.find(t => t.id === player.companionExpedition.currentExpedition.taskId);
        const startTime = player.companionExpedition.currentExpedition.startTime;
        const duration = task.duration * 60 * 1000; // 转换为毫秒
        const endTime = startTime + duration;
        const remainingTime = Math.max(0, endTime - Date.now());
        const remainingMinutes = Math.ceil(remainingTime / (60 * 1000));
        
        currentContainer.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h4>${task.name} (${task.difficulty})</h4>
                    <div>伴侣: ${player.companionExpedition.currentExpedition.companionName}</div>
                    <div>伴侣评分: ${player.companionExpedition.currentExpedition.companionScore}</div>
                </div>
                <div>
                    <div>剩余时间: ${remainingMinutes}分钟</div>
                </div>
            </div>
        `;
    } else {
        currentContainer.innerHTML = '<p>没有进行中的探险</p>';
    }
    
    // 更新探险历史
    const historyContainer = document.getElementById('expeditionHistory');
    historyContainer.innerHTML = '';
    
    if (player.companionExpedition.history.length === 0) {
        historyContainer.innerHTML = '<p>暂无探险记录</p>';
    } else {
        player.companionExpedition.history.slice(0, 5).forEach(record => {
            const task = expeditionConfig.tasks.find(t => t.id === record.taskId);
            const recordElement = document.createElement('div');
            recordElement.style.marginBottom = '10px';
            recordElement.style.paddingBottom = '10px';
            recordElement.style.borderBottom = '1px solid #444';
            recordElement.innerHTML = `
                <div><strong>${task.name}</strong> (${record.companionName})</div>
                <div>评分: ${record.companionScore} | 奖励倍数: ${record.rewardMultiplier.toFixed(2)}x</div>
                <div>获得: 玫瑰花 x${record.rewards.rose}, VIP能力值 x${record.rewards.vipPower}, 鱼饵 x${record.rewards.bait}</div>
                <div style="color: #aaa; font-size: 0.9em;">${new Date(record.endTime).toLocaleString()}</div>
            `;
            historyContainer.appendChild(recordElement);
        });
    }
}

// 开始探险
// 伴侣数据结构增强
class Companion {
    constructor(id, name, rarity, score, talents) {
        this.id = id;
        this.name = name;
        this.rarity = rarity;
        this.score = score;
        this.talents = talents;
        this.locked = false; // 用户设置的锁定状态
        this.onExpedition = false; // 是否在探险中
        this.originalLockedState = false; // 原始锁定状态（用于恢复）
    }
}

// 开始探险
function startExpedition(taskId) {
    if (player.companionExpedition.currentExpedition) {
        logAction("已有进行中的探险", "error");
        return;
    }
    
    const task = expeditionConfig.tasks.find(t => t.id === taskId);
    if (!task) return;
    
    // 检查是否有符合条件的伴侣
    const eligibleCompanions = player.companions.filter(c => 
        c.score >= task.companionRequirement && !c.onExpedition
    );
    
    if (eligibleCompanions.length === 0) {
        logAction("没有符合条件的伴侣", "error");
        return;
    }
    
    // 选择评分最高的伴侣
    const companion = eligibleCompanions.reduce((max, c) => 
        c.score > max.score ? c : max, eligibleCompanions[0]
    );
    
    // 保存原始锁定状态
    companion.originalLockedState = companion.locked;
    
    // 强制锁定伴侣
    companion.locked = true;
    
    // 标记伴侣为探险中
    companion.onExpedition = true;
    
    // 开始探险
    player.companionExpedition.currentExpedition = {
        taskId: task.id,
        companionId: companion.id,
        companionName: companion.name,
        companionScore: companion.score,
        startTime: Date.now()
    };
    
    player.companionExpedition.lastUpdate = Date.now();
    
    logAction(`派遣${companion.name}进行${task.name}探险，伴侣已自动锁定`, "success");
    updateExpeditionUI();
    updateCompanionDisplay();
}

// 完成探险
function completeExpedition(forceComplete = false) {
    if (!player.companionExpedition.currentExpedition) return;
    
    const expedition = player.companionExpedition.currentExpedition;
    const task = expeditionConfig.tasks.find(t => t.id === expedition.taskId);
    const companion = player.companions.find(c => c.id === expedition.companionId);
    
    if (!task || !companion) return;
    
    // 计算实际探险时间
    const startTime = expedition.startTime;
    const duration = task.duration * 60 * 1000; // 转换为毫秒
    const endTime = startTime + duration;
    const currentTime = Date.now();
    
    // 如果强制提前结束，计算实际探险时间比例
    const timeRatio = forceComplete ? 
        Math.min(1, (currentTime - startTime) / duration) : 1;
    
    // 计算奖励倍数（基于伴侣评分）
    const scoreRatio = expedition.companionScore / task.companionRequirement;
    const rewardMultiplier = Math.min(5, Math.max(1, scoreRatio * timeRatio));
    
    // 计算实际奖励
    const rewards = {
        rose: Math.floor(task.baseReward.rose * rewardMultiplier),
        vipPower: Math.floor(task.baseReward.vipPower * rewardMultiplier),
        bait: Math.floor(task.baseReward.bait * rewardMultiplier)
    };
    
    // 发放奖励
    player.items.rose += rewards.rose;
    player.items.vipPower += rewards.vipPower;
    player.items.baitCount += rewards.bait;
    
    // 添加历史记录
    player.companionExpedition.history.unshift({
        taskId: task.id,
        companionId: companion.id,
        companionName: companion.name,
        companionScore: companion.score,
        rewardMultiplier: rewardMultiplier,
        rewards: rewards,
        startTime: startTime,
        endTime: currentTime,
        duration: (currentTime - startTime) / (60 * 1000) // 分钟
    });
    
    // 限制历史记录数量
    if (player.companionExpedition.history.length > 10) {
        player.companionExpedition.history.pop();
    }
    
    // 清除当前探险
    player.companionExpedition.currentExpedition = null;
    
    // 解除伴侣的探险状态
    companion.onExpedition = false;
    
    // 恢复原始锁定状态
    companion.locked = companion.originalLockedState;
    
    logAction(
        `${companion.name}完成${task.name}探险，获得奖励: 玫瑰花x${rewards.rose}, VIP能力值x${rewards.vipPower}, 鱼饵x${rewards.bait}`,
        "success"
    );
    
    logAction(
        `${companion.name}已恢复${companion.locked ? "锁定" : "解锁"}状态`,
        "info"
    );
    
    updateExpeditionUI();
    updateCompanionDisplay();
    updateItemDisplay();
}

// 计算离线探险奖励
function calculateOfflineExpeditionRewards() {
    if (!player.companionExpedition || !player.companionExpedition.currentExpedition) return;
    
    const expedition = player.companionExpedition.currentExpedition;
    const task = expeditionConfig.tasks.find(t => t.id === expedition.taskId);
    const companion = player.companions.find(c => c.id === expedition.companionId);
    
    if (!task || !companion) return;
    
    const startTime = expedition.startTime;
    const duration = task.duration * 60 * 1000; // 转换为毫秒
    const endTime = startTime + duration;
    const currentTime = Date.now();
    
    // 如果探险已经完成
    if (currentTime >= endTime) {
        completeExpedition();
    }
}
// 伴侣商店相关函数
function toggleCompanionShop() {
    const shopUI = document.getElementById('companionShopUI');
    const overlay = document.getElementById('companionShopOverlay');
    
    if (shopUI.style.display === 'block') {
        shopUI.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        shopUI.style.display = 'block';
        overlay.style.display = 'block';
        updateSoulCounts();
    }
}

// 更新灵魂道具数量显示
function updateSoulCounts() {
    document.getElementById('soulCount1').textContent = player.items.banlv1 || 0;
    document.getElementById('soulCount2').textContent = player.items.banlv2 || 0;
    document.getElementById('soulCount3').textContent = player.items.banlv3 || 0;
    document.getElementById('soulCount4').textContent = player.items.banlv4 || 0;
    document.getElementById('soulCount5').textContent = player.items.banlv5 || 0;
    document.getElementById('soulCount6').textContent = player.items.banlv6 || 0;
    document.getElementById('soulCount7').textContent = player.items.banlv7 || 0;
    document.getElementById('soulCount8').textContent = player.items.banlv8 || 0;
    document.getElementById('soulCount9').textContent = player.items.banlv9 || 0;
}

// 灵魂道具兑换函数
function exchangeSoul(fromSoul, toSoul, fromAmount, toAmount) {
    // 确保灵魂道具字段存在
    if (player.items[fromSoul] === undefined) {
        player.items[fromSoul] = 0;
    }
    if (player.items[toSoul] === undefined) {
        player.items[toSoul] = 0;
    }
    
    // 检查是否有足够的灵魂道具
    if (player.items[fromSoul] < fromAmount) {
        const fromName = itemEffects[fromSoul]?.name || fromSoul;
        logAction(`${fromName}不足，需要${fromAmount}个`, "error");
        return;
    }
    
    // 执行兑换
    player.items[fromSoul] -= fromAmount;
    player.items[toSoul] += toAmount;
    
    // 获取道具名称
    const fromName = itemEffects[fromSoul]?.name || fromSoul;
    const toName = itemEffects[toSoul]?.name || toSoul;
    
    // 记录日志
    logAction(`成功兑换：${fromAmount}个${fromName} → ${toAmount}个${toName}`, "success");
    
    // 更新显示
    updateSoulCounts();
    updateItemDisplay();
    saveGame();
}
// 批量开启伴侣宝箱
function drawCompanionMultiple(count) {
    if (player.items.companionKey < count) {
        logAction("伴侣钥匙不足！", "error");
        return;
    }
    player.items.companionKey -= count;
    updateItemDisplay();
    // 用于统计各品质获得数量
    const rarityCount = {
        white: 0,
        blue: 0,
        epic: 0,
        pink: 0,
        orange: 0,
        red: 0,
        angel: 0,
        emyyyy: 0,
        jlyyyy: 0
    };
    
    // 保存获得的伴侣，用于最后显示
    const companionsObtained = [];
    
    // 执行多次开启
    for (let i = 0; i < count; i++) {
        const result = drawOneCompanion();
        if (result) {
            rarityCount[result.rarity]++;
            companionsObtained.push(result);
        }
    }
    
   
    
    // 生成汇总消息
    let message = `开启${count}次伴侣宝箱，获得：`;
    let hasCompanion = false;
    
    for (const rarity in rarityCount) {
        if (rarityCount[rarity] > 0) {
            const rarityName = companionRarities[rarity].name;
            message += `${rarityName}x${rarityCount[rarity]} `;
            hasCompanion = true;
        }
    }
    
    if (!hasCompanion) {
        message += "未获得任何伴侣";
    }
    
    logAction(message, 'success');
    
    // 更新显示
    updateCompanionDisplay();
}
// 提取单次开启逻辑到独立函数
function drawOneCompanion() {
    // 更新所有保底计数器
    player.companionChestGuarantee.epic++;
    player.companionChestGuarantee.pink++;
    player.companionChestGuarantee.orange++;
    player.companionChestGuarantee.red++;
    
    let selectedRarity;
    let isGuaranteed = false;
    
    // 检查保底机制（优先级从高到低）
    if (player.companionChestGuarantee.red >= guaranteeThresholds.red) {
        selectedRarity = "red";
        isGuaranteed = true;
        player.companionChestGuarantee.red = 0;
    } else if (player.companionChestGuarantee.orange >= guaranteeThresholds.orange) {
        selectedRarity = "orange";
        isGuaranteed = true;
        player.companionChestGuarantee.orange = 0;
    } else if (player.companionChestGuarantee.pink >= guaranteeThresholds.pink) {
        selectedRarity = "pink";
        isGuaranteed = true;
        player.companionChestGuarantee.pink = 0;
    } else if (player.companionChestGuarantee.epic >= guaranteeThresholds.epic) {
        selectedRarity = "epic";
        isGuaranteed = true;
        player.companionChestGuarantee.epic = 0;
    } else {
        // 没有触发保底，按原概率抽取
        let rand = Math.random();
        let cumulativeProb = 0;
        for (const { rarity, prob } of drawProbabilities) {
            cumulativeProb += prob;
            if (rand < cumulativeProb) {
                selectedRarity = rarity;
                break;
            }
        }
    }
    
    // 生成天赋
    const config = companionRarities[selectedRarity];
    const talentCount = config.talentCount;
    const [minRank, maxRank] = config.talentRange;
    const talents = [];
    
    while (talents.length < talentCount) {
        const type = Math.floor(Math.random() * talentTypes.length);
        const rank = Math.floor(Math.random() * (maxRank - minRank + 1)) + minRank;
        talents.push({ type, rank });
    }
    
    // 计算评分
    const baseScore = config.baseScore;
    const talentScore = talents.reduce((sum, t) => sum + (t.rank + 1) * 50, 0);
    const totalScore = Math.min(10000, baseScore + talentScore);
    
    // 生成伴侣
    const companion = {
        id: 'comp_' + Date.now() + Math.floor(Math.random() * 1000),
        name: companionNames[Math.floor(Math.random() * companionNames.length)],
        rarity: selectedRarity,
        talents,
        score: totalScore,
        locked: false,
        advanceLevel: 0,
        qualityMultiplier: 1.0
    };
    
    player.companions.push(companion);
    
    // 返回获得的伴侣信息
    return {
        rarity: selectedRarity,
        name: companion.name,
        isGuaranteed: isGuaranteed
    };
}

// 抽取伴侣
function drawCompanion() {
    if (player.items.companionKey < 1) {
        logAction("伴侣钥匙不足！", "error");
        return;
    }
    
     player.items.companionKey--;
    updateItemDisplay();
    
    const result = drawOneCompanion();
    if (result) {
        const rarityName = companionRarities[result.rarity].name;
        logAction(`获得了${rarityName}品质伴侣：${result.name}${result.isGuaranteed ? " (保底)" : ""}`, 'success');
        
        updateCompanionDisplay();
        
    }
}
// 添加伴侣进阶函数
function advanceCompanion(id) {
     const companion = player.companions.find(c => c.id === id);
    if (!companion) return;
    
    // 检查伴侣是否在探险中
    if (companion && companion.onExpedition) {
        logAction(`${companion.name}正在探险中，无法进阶！`, "error");
        return;
    }

    // 检查是否为可进阶品质
    if (!['white','blue','epic','pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(companion.rarity)) {
        logAction("品质的伴侣可以进阶！", "error");
        return;
    }

     // 获取对应的灵魂道具配置
    const rarityConfig = companionRarities[companion.rarity];
    if (!rarityConfig || !rarityConfig.soulItem) {
        logAction("未找到该品质的进阶配置！", "error");
        return;
    }
    
    // 计算当前进阶等级和所需消耗
    const currentLevel = companion.advanceLevel || 0;
    const requiredCount = Math.pow(2, currentLevel); // 1, 2, 4, 8...
    
    // 检查是否有足够的灵魂道具
    const soulItemKey = rarityConfig.soulItem;
    if (!player.items[soulItemKey] || player.items[soulItemKey] < requiredCount) {
        const itemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
        logAction(`需要${requiredCount}个${itemName}才能进阶！`, "error");
        return;
    }
    
    // 消耗灵魂道具
    player.items[soulItemKey] -= requiredCount;
    
    // 提升进阶等级
    companion.advanceLevel = (companion.advanceLevel || 0) + 1;
    companion.score += Math.floor(companion.score * 0.1) + 100;
    
    // 提示信息
    const rarityName = companionRarities[companion.rarity].name;
    const itemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
    logAction(`${companion.name}使用${requiredCount}个${itemName}进阶成功！当前进阶等级+${companion.advanceLevel}`, "success");
    
    updateCompanionDisplay();
}
// 升级伴侣等级
function upgradeCompanion() {
    const cost = 10 * player.companionLevel;
    if (player.items.rose < cost) {
        logAction("玫瑰花不足！", "error");
        return;
    }
    
    player.items.rose -= cost;
    player.companionLevel++;
    logAction(`伴侣等级提升至Lv.${player.companionLevel}`, 'success');
    updateCompanionDisplay();
}

// 装备伴侣
function equipCompanion(id) {
    player.equippedCompanionId = id;
    logAction(`已装备伴侣：${player.companions.find(c => c.id === id).name}`, 'success');
    updateCompanionDisplay();
}
// 新增洗练面板相关函数
let currentWashCompanionId = null;

function openWashPanel(companionId) {
    const companion = player.companions.find(c => c.id === companionId);
    if (!companion) return;
    
    currentWashCompanionId = companionId;
    document.getElementById('washPanel').style.display = 'block';
    document.getElementById('settingsOverlay').style.display = 'block';
    document.getElementById('rebornDanCount').textContent = player.items.rebornDan || 0;
    
    // 显示当前伴侣信息
    const infoElement = document.getElementById('washCompanionInfo');
    infoElement.innerHTML = `
        <p>名称: ${companion.name}</p>
        <p>品阶: <span style="color: ${companionRarities[companion.rarity].color}">${companionRarities[companion.rarity].name}</span></p>
        <p>天赋数量: ${companion.talents.length}</p>
    `;
    
    // 生成天赋列表和锁定选项
    updateTalentList(companion);
    
    // 隐藏之前的洗练结果
    document.getElementById('washResult').style.display = 'none';
    
    // 更新洗练消耗显示
    updateWashCost(companion);
}
// 更新天赋列表和锁定选项
function updateTalentList(companion) {
    const talentListElement = document.getElementById('talentList');
    talentListElement.innerHTML = '';
    
    companion.talents.forEach((talent, index) => {
        const talentElement = document.createElement('div');
        talentElement.style.marginBottom = '10px';
        talentElement.style.padding = '5px';
        talentElement.style.borderBottom = '1px solid #555';
        talentElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span>${index + 1}. ${talentRanks[talent.rank]}${talentTypes[talent.type].name}: ${talentTypes[talent.type].description(talent.rank)}</span>
                <label>
                    <input type="checkbox" ${talent.locked ? 'checked' : ''} 
                           onchange="toggleTalentLock(${index}, this.checked)">
                    锁定
                </label>
            </div>
        `;
        talentListElement.appendChild(talentElement);
    });
}

// 切换天赋锁定状态
function toggleTalentLock(talentIndex, isLocked) {
    const companion = player.companions.find(c => c.id === currentWashCompanionId);
    if (companion && companion.talents[talentIndex]) {
        companion.talents[talentIndex].locked = isLocked;
        updateWashCost(companion);
        // 可选：立即更新界面显示
        updateTalentList(companion);
    }
}

// 更新洗练消耗显示
function updateWashCost(companion) {
    const lockedCount = companion.talents.filter(t => t.locked).length;
    const totalCost = 1 + lockedCount * 2;
    
    document.getElementById('totalWashCost').textContent = 
        `本次洗练总消耗：${totalCost} 洗髓丹 (基础1 + 锁定${lockedCount}×2)`;
}

function closeWashPanel() {
    document.getElementById('washPanel').style.display = 'none';
    document.getElementById('settingsOverlay').style.display = 'none';
    currentWashCompanionId = null;
}

function washCompanion() {
    if (!currentWashCompanionId) return;
    
    const companion = player.companions.find(c => c.id === currentWashCompanionId);
    if (!companion) {
        closeWashPanel();
        return;
    }
    
    // 检查伴侣是否在探险中
    if (companion.onExpedition) {
        logAction(`${companion.name}正在探险中，无法洗练！`, "error");
        return;
    }
    
    // 计算消耗
    const lockedCount = companion.talents.filter(t => t.locked).length;
    const totalCost = 1 + lockedCount * 2;
    
    // 检查洗髓丹数量
    if ((player.items.rebornDan || 0) < totalCost) {
        logAction(`洗髓丹不足！需要${totalCost}个`, "error");
        return;
    }
    
    // 消耗洗髓丹
    player.items.rebornDan -= totalCost;
    document.getElementById('rebornDanCount').textContent = player.items.rebornDan;
    
    // 洗练逻辑：只重新生成未锁定的天赋
    let resultText = '洗练结果：<br>';
    
    companion.talents.forEach((talent, index) => {
        if (!talent.locked) {
            const oldType = talent.type;
            const oldRank = talent.rank;
            const oldTalentText = `${talentRanks[oldRank]}${talentTypes[oldType].name}`;
            
            // 生成新天赋 - 但保留锁定状态
            const newType = Math.floor(Math.random() * talentTypes.length);
            const newRank = Math.floor(Math.random() * 16); // 0-8级
            talent.type = newType;
            talent.rank = newRank;
            // 注意：这里不修改 talent.locked 状态，保持原样
            
            const newTalentText = `${talentRanks[newRank]}${talentTypes[newType].name}`;
            resultText += `天赋#${index + 1}: ${oldTalentText} → ${newTalentText}<br>`;
        } else {
            resultText += `天赋#${index + 1}: [已锁定] ${talentRanks[talent.rank]}${talentTypes[talent.type].name}<br>`;
        }
    });
    updateTalentList(companion);
   
    
    // 显示洗练结果
    const resultElement = document.getElementById('washResult');
    resultElement.innerHTML = resultText;
    resultElement.style.display = 'block';
    
   
    
    
    // 更新洗练消耗显示
    updateWashCost(companion);
    
    logAction(`伴侣${companion.name}洗练完成，消耗${totalCost}洗髓丹`, 'success');
}
// 切换锁定状态
function toggleCompanionLock(id) {
    const companion = player.companions.find(c => c.id === id);
     if (companion.onExpedition) {
        logAction("伴侣在探险中，无法更改锁定状态", "error");
        return;
    }
    if (companion) {
        companion.locked = !companion.locked;
        logAction(`${companion.name}已${companion.locked ? '锁定' : '解锁'}`, 'success');
        updateCompanionDisplay();
    }
}
// 切换自动分解状态
function toggleAutoDecompose() {
    player.autoDecompose.enabled = !player.autoDecompose.enabled;
    const btn = document.getElementById('toggleAutoDecompose');
    btn.textContent = `自动分解：${player.autoDecompose.enabled ? '开启' : '关闭'}`;
    btn.style.background = player.autoDecompose.enabled ? '#4CAF50' : '#ff9800';
    logAction(`${player.autoDecompose.enabled ? '开启' : '关闭'}自动分解低于${getRarityName(player.autoDecompose.belowRarity)}的伴侣`, 'info');
    
    // 如果开启则立即检查一次
    if (player.autoDecompose.enabled) {
        checkAutoDecompose();
    }
}

// 设置自动分解的品阶阈值
function setAutoDecomposeRarity() {
    const rarity = document.getElementById('autoDecomposeBelowRarity').value;
    player.autoDecompose.belowRarity = rarity;
    logAction(`设置自动分解低于${getRarityName(rarity)}的伴侣`, 'info');
}

// 获取品阶名称
function getRarityName(rarity) {
    const names = {
        'white': '普通(白色)',
        'blue': '稀有(蓝色)',
        'epic': '史诗(紫色)',
        'pink': '卓越(粉色)',
        'orange': '完美(橙色)',
        'red': '神赐(红色)',
        'angel': '天使(彩色)',
        'emyyyy': '恶魔(深红色)',
        'jlyyyy': '精灵(绿色)'
    };
    return names[rarity] || '普通(白色)';
}

// 自动分解检查逻辑
function checkAutoDecompose() {
    if (!player.autoDecompose.enabled) return;
    
    const rarityOrder = ['white', 'blue', 'epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'];
    const targetIndex = rarityOrder.indexOf(player.autoDecompose.belowRarity);
    if (targetIndex === -1) return;
    
    // 找出所有低于等于目标品阶且未锁定的伴侣
    const toDecompose = player.companions.filter(c => 
        rarityOrder.indexOf(c.rarity) <= targetIndex && !c.locked
    );
     
    if (toDecompose.length > 0) {
        // 按品质分组统计
        const decomposeByRarity = {};
        toDecompose.forEach(companion => {
            const rarity = companion.rarity;
            if (!decomposeByRarity[rarity]) {
                decomposeByRarity[rarity] = [];
            }
            decomposeByRarity[rarity].push(companion);
        });
        
        // 计算总玫瑰花奖励
        const totalRoses = toDecompose.reduce((sum, c) => sum + companionRarities[c.rarity].decomposeRose, 0);
        player.items.rose += totalRoses;
        
        // 计算并添加灵魂道具
        for (const rarity in decomposeByRarity) {
            const companionsOfRarity = decomposeByRarity[rarity];
            const soulItemKey = companionRarities[rarity]?.soulItem;
            
            if (soulItemKey) {
                // 初始化灵魂道具数量（如果不存在）
                if (player.items[soulItemKey] === undefined) {
                    player.items[soulItemKey] = 0;
                }
                // 添加灵魂道具
                player.items[soulItemKey] += companionsOfRarity.length;
                
                const soulItemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
                logAction(`自动分解获得${companionsOfRarity.length}个${soulItemName}`, 'info');
            }
        }
        
        // 过滤掉分解的伴侣
        player.companions = player.companions.filter(c => 
            !(rarityOrder.indexOf(c.rarity) <= targetIndex && !c.locked)
        );
      
        // 如果装备的伴侣被分解，取消装备
        if (toDecompose.some(c => c.id === player.equippedCompanionId)) {
            player.equippedCompanionId = null;
        }
        
        logAction(`自动分解${toDecompose.length}个低于${getRarityName(player.autoDecompose.belowRarity)}的伴侣，获得${totalRoses}玫瑰花`, 'success');
        updateCompanionDisplay();
        updateItemDisplay();
        saveGame(); // 保存游戏
    }
}

// 添加到页面初始化函数中
function initAutoDecomposeUI() {
    const raritySelect = document.getElementById('autoDecomposeBelowRarity');
    raritySelect.value = player.autoDecompose.belowRarity;
    raritySelect.onchange = setAutoDecomposeRarity;
    
    const btn = document.getElementById('toggleAutoDecompose');
    btn.textContent = `自动分解：${player.autoDecompose.enabled ? '开启' : '关闭'}`;
    btn.style.background = player.autoDecompose.enabled ? '#4CAF50' : '#ff9800';
}



// 添加定时检查（每5秒一次）
registerInterval(checkAutoDecompose, 5000);
// 分解单个伴侣
function decomposeCompanion(id) {
    const companion = player.companions.find(c => c.id === id);
    if (!companion) return;
    
    if (companion.locked) {
        logAction("伴侣已锁定，无法分解！", "error");
        return;
    }
    
    // 获取分解奖励
    const rarityConfig = companionRarities[companion.rarity];
    const roses = rarityConfig ? rarityConfig.decomposeRose : 5; // 默认5朵玫瑰
    
    // 获取对应的灵魂道具
    const soulItemKey = rarityConfig.soulItem;
    const soulItemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
    
    // 移除伴侣
    player.companions = player.companions.filter(c => c.id !== id);
    
    // 如果分解的是装备的伴侣，取消装备
    if (player.equippedCompanionId === id) {
        player.equippedCompanionId = null;
    }
    
    // 添加奖励
    player.items.rose += roses;
    
    // 确保灵魂道具字段存在，然后增加1
    if (soulItemKey) {
        // 初始化灵魂道具数量（如果不存在）
        if (player.items[soulItemKey] === undefined) {
            player.items[soulItemKey] = 0;
        }
        player.items[soulItemKey] += 1;
    }
    
    logAction(`分解${companion.name}获得${roses}朵玫瑰花和1个${soulItemName}`, "success");
    updateCompanionDisplay();
    updateItemDisplay();
}

// 批量分解
function batchDecompose() {
    const rarity = document.getElementById('decomposeRarity').value;
    const toDecompose = player.companions.filter(c => c.rarity === rarity && !c.locked);
   
    if (toDecompose.length === 0) {
        logAction("没有可分解的伴侣", "error");
        return;
    }
    
    const totalRoses = toDecompose.reduce((sum, c) => sum + companionRarities[c.rarity].decomposeRose, 0);
    player.items.rose += totalRoses;
    
    // 获取对应的灵魂道具
    const soulItemKey = companionRarities[rarity].soulItem;
    const soulItemName = itemEffects[soulItemKey]?.name || "伴侣灵魂";
    
    // 添加灵魂道具
    if (soulItemKey) {
        // 初始化灵魂道具数量（如果不存在）
        if (player.items[soulItemKey] === undefined) {
            player.items[soulItemKey] = 0;
        }
        player.items[soulItemKey] += toDecompose.length;
    }
    
    // 过滤掉分解的伴侣
    player.companions = player.companions.filter(c => !(c.rarity === rarity && !c.locked));
    
    // 如果装备的伴侣被分解，取消装备
    if (toDecompose.some(c => c.id === player.equippedCompanionId)) {
        player.equippedCompanionId = null;
    }
    
    logAction(`批量分解${toDecompose.length}个${companionRarities[rarity].name}伴侣，获得${totalRoses}玫瑰花和${toDecompose.length}个${soulItemName}`, 'success');
    updateCompanionDisplay();
    updateItemDisplay();
}
// 打开合成面板
function openCombinePanel(mainId = null) {
    // 显示面板
    document.getElementById('combinePanel').style.display = 'block';
    
    // 填充可选伴侣列表
    const mainSelect = document.getElementById('mainCompanionSelect');
    const secondarySelect = document.getElementById('secondaryCompanionSelect');
    
    // 清空现有选项
    mainSelect.innerHTML = '';
    secondarySelect.innerHTML = '';
    
    // 只显示可合成的伴侣（史诗及以上且未锁定）
    const eligibleCompanions = player.companions.filter(c => 
        ['epic', 'pink', 'orange', 'red', 'angel', 'emyyyy', 'jlyyyy'].includes(c.rarity) && !c.locked
    );
    
    eligibleCompanions.forEach(companion => {
        const option = document.createElement('option');
        option.value = companion.id;
        option.textContent = `${companion.name} (${companionRarities[companion.rarity].name} +${companion.advanceLevel || 0})`;
        mainSelect.appendChild(option.cloneNode(true));
        secondarySelect.appendChild(option);
    });
    
    // 如果有传入主伴侣ID，设置为主选
    if (mainId && eligibleCompanions.some(c => c.id === mainId)) {
        mainSelect.value = mainId;
    }
    
    // 添加选择事件监听
    mainSelect.onchange = updateCombinePreview;
    secondarySelect.onchange = updateCombinePreview;
    
    // 初始更新预览
    updateCombinePreview();
}

// 关闭合成面板
function closeCombinePanel() {
    document.getElementById('combinePanel').style.display = 'none';
}

// 更新合成预览
function updateCombinePreview() {
    const mainId = document.getElementById('mainCompanionSelect').value;
    const secondaryId = document.getElementById('secondaryCompanionSelect').value;
    
    // 清除相同选择
    if (mainId && secondaryId && mainId === secondaryId) {
        document.getElementById('secondaryCompanionSelect').value = '';
    }
    
    const mainCompanion = player.companions.find(c => c.id === mainId);
   // 显示随机品质加成预览
    document.getElementById('previewQualityMultiplier').textContent = 
        `${(Math.random() * 0.6 + 0.7).toFixed(2)}x`;
    const secondaryCompanion = player.companions.find(c => c.id === secondaryId);
    
    // 更新伴侣信息显示
    updateCompanionInfo('mainCompanionInfo', mainCompanion);
    updateCompanionInfo('secondaryCompanionInfo', secondaryCompanion);
    
    // 更新预览信息
    const previewGeneration = document.getElementById('previewGeneration');
    const previewTalentCount = document.getElementById('previewTalentCount');
    const previewScoreRange = document.getElementById('previewScoreRange');
    
    if (mainCompanion && secondaryCompanion) {
        // 计算可能的代数
        const mainGen = getCompanionGeneration(mainCompanion);
        const secondaryGen = getCompanionGeneration(secondaryCompanion);
        const newGen = Math.max(mainGen, secondaryGen) + 1;
        previewGeneration.textContent = `${newGen}代`;
        
        // 计算可能的天赋数量范围
        const totalTalents = mainCompanion.talents.length + secondaryCompanion.talents.length;
        const minT1 = Math.floor(totalTalents * 0.01);
        const maxT1 = Math.floor(totalTalents * 0.5);
        const minT2 = Math.floor(maxT1 + 1);
        const maxT2 = Math.floor(totalTalents * 0.75);
        const minT3 = maxT2 + 1;
        const maxT3 = Math.floor(totalTalents * 1.0);
        previewTalentCount.textContent = `${minT1}-${maxT3} (80%概率 ${minT1}-${maxT1}, 18%概率 ${minT2}-${maxT2}, 2%概率 ${minT3}-${maxT3})`;
        
        // 计算可能的评分范围
        const minScore = Math.min(mainCompanion.score, secondaryCompanion.score);
        const maxScore = Math.max(mainCompanion.score, secondaryCompanion.score);
        const finalMin = Math.floor(minScore * 0.7); // 最低70%
        const finalMax = Math.ceil(maxScore * 1.3); // 最高130%
        previewScoreRange.textContent = `${finalMin}-${finalMax}`;
    } else {
        previewGeneration.textContent = '--';
        previewTalentCount.textContent = '--';
        previewScoreRange.textContent = '--';
    }
}

// 获取伴侣代数
function getCompanionGeneration(companion) {
    // 检查名字中是否包含代数信息
    const match = companion.name.match(/(\d+)代/);
    if (match) {
        return parseInt(match[1]);
    }
    return 1; // 默认1代
}

// 更新伴侣信息显示
function updateCompanionInfo(elementId, companion) {
    const element = document.getElementById(elementId);
    if (!companion) {
        element.innerHTML = '<p>未选择</p>';
        return;
    }
    
    element.innerHTML = `
        <p>名称: ${companion.name}</p>
        <p>品阶: <span style="color: ${companionRarities[companion.rarity].color}">${companionRarities[companion.rarity].name}</span></p>
        <p>评分: ${companion.score}</p>
        <p>天赋数量: ${companion.talents.length}</p>
        <p>进阶等级: +${companion.advanceLevel || 0}</p>
    `;
}

// 合成伴侣
function combineCompanions() {
    const mainId = document.getElementById('mainCompanionSelect').value;
    const secondaryId = document.getElementById('secondaryCompanionSelect').value;
    
    if (!mainId || !secondaryId || mainId === secondaryId) {
        logAction('请选择不同的主副伴侣', 'error');
        return;
    }
    
    const mainCompanion = player.companions.find(c => c.id === mainId);
    const secondaryCompanion = player.companions.find(c => c.id === secondaryId);
     // 检查伴侣是否在探险中
    if (mainCompanion && mainCompanion.onExpedition) {
        logAction(`${mainCompanion.name}正在探险中，无法合成！`, "error");
        return;
    }
    
    if (secondaryCompanion && secondaryCompanion.onExpedition) {
        logAction(`${secondaryCompanion.name}正在探险中，无法合成！`, "error");
        return;
    }
    if (!mainCompanion || !secondaryCompanion) {
        logAction('选择的伴侣不存在', 'error');
        return;
    }


    // 计算新一代数
    const mainGen = getCompanionGeneration(mainCompanion);
    const secondaryGen = getCompanionGeneration(secondaryCompanion);
    const newGen = Math.max(mainGen, secondaryGen) + 1;
    
    // 随机选择新名字（主或副的名字 + 代数）
    const newName = Math.random() > 0.5 ? 
        `${mainCompanion.name.replace(/ \d+代$/, '')} ${newGen}代` : 
        `${secondaryCompanion.name.replace(/ \d+代$/, '')} ${newGen}代`;
    
    // 计算天赋数量
    const totalTalents = mainCompanion.talents.length + secondaryCompanion.talents.length;
    let newTalentCount;
    const rand = Math.random();
    
    if (rand < 0.80) {
        // 80% 概率：1-50%
        newTalentCount = Math.floor(Math.random() * (totalTalents * 0.5) + totalTalents * 0.2);
    } else if (rand < 0.97) {
        // 18% 概率：50-75%
        newTalentCount = Math.floor(Math.random() * (totalTalents * 0.25) + totalTalents * 0.5);
    } else {
        // 2% 概率：75-100%
        newTalentCount = Math.floor(Math.random() * (totalTalents * 0.25) + totalTalents * 0.75);
    }
    newTalentCount = Math.max(1, newTalentCount); // 至少1个天赋
    
    // 计算新评分（基于主副评分范围，上下浮动30%）
    const minScore = Math.min(mainCompanion.score, secondaryCompanion.score);
    const maxScore = Math.max(mainCompanion.score, secondaryCompanion.score);
    const scoreRange = maxScore * 1.3 - minScore * 0.7;
    const newScore = Math.floor(Math.random() * scoreRange + minScore * 0.7);
    
    // 生成新天赋（结合主副天赋的类型，有几率生成新类型）
    const allTalentTypes = [...mainCompanion.talents.map(t => t.type), ...secondaryCompanion.talents.map(t => t.type), ...Array.from({length: 3}, () => Math.floor(Math.random() * talentTypes.length))];
    const newTalents = [];
    
    for (let i = 0; i < newTalentCount; i++) {
        // 随机选择天赋类型（优先从主副天赋中选择）
        const type = allTalentTypes[Math.floor(Math.random() * allTalentTypes.length)];
        
        // 天赋天赋等级（基于主副天赋等级范围）
        const mainRanks = mainCompanion.talents.filter(t => t.type === type).map(t => t.rank);
        const secondaryRanks = secondaryCompanion.talents.filter(t => t.type === type).map(t => t.rank);
        const allRanks = [...mainRanks, ...secondaryRanks];
        
        let rank;
        if (allRanks.length > 0) {
            const minRank = Math.min(...allRanks);
            const maxRank = Math.max(...allRanks);
            // 上下浮动30%
            const newMin = Math.max(0, Math.floor(minRank * 0.7));
            const newMax = Math.min(8, Math.ceil(maxRank * 1.3));
            rank = Math.floor(Math.random() * (newMax - newMin + 1)) + newMin;
        } else {
            // 如果没有相同类型的天赋，随机生成
            rank = Math.floor(Math.random() * 8); // 0-8级
        }
        
        newTalents.push({ type, rank });
    }
   const newAdvanceLevel = Math.max(
        mainCompanion.advanceLevel || 0,
        secondaryCompanion.advanceLevel || 0
    );
  
    const rarities = ['angel', 'emyyyy', 'jlyyyy'];
    const randomIndex = Math.floor(Math.random() * rarities.length);
    const selectedRarity = rarities[randomIndex];
    // 创建新伴侣
    const newCompanion = {
        id: 'comp_' + Date.now() + Math.floor(Math.random() * 1000),
        name: newName,
        rarity: selectedRarity,// 合成后为天使品质
        talents: newTalents,
        score: Math.min(50000, newScore), // 天使品质上限更高
        locked: false,
        advanceLevel: newAdvanceLevel,
       qualityMultiplier: qualityMultiplier // 添加品质加成
    };
    
    // 移除主副伴侣
    player.companions = player.companions.filter(c => c.id !== mainId && c.id !== secondaryId);
    
    // 如果装备的是被合成的伴侣，取消装备
    if (player.equippedCompanionId === mainId || player.equippedCompanionId === secondaryId) {
        player.equippedCompanionId = null;
    }
    
    // 添加新伴侣
    player.companions.push(newCompanion);
    
    // 提示信息
   logAction(`成功合成${newGen}代特殊伴侣：${newName}（保留最高进阶等级${newAdvanceLevel}）`, 'success');
    
    // 更新显示
    updateCompanionDisplay();
    closeCombinePanel();
}
// 计算伴侣天赋加成（需要整合到属性计算中）
function getCompanionBonuses() {
    if (!player.equippedCompanionId) return {
        attackMultiplier: 1,
        critDamageMultiplier: 1,
        healthMultiplier: 1,
        allStatsMultiplier: 1,
        combo: 0,
        critRateMultiplier: 1
    };
    
    const companion = player.companions.find(c => c.id === player.equippedCompanionId);
    if (!companion) return {
        attackMultiplier: 1,
        critDamageMultiplier: 1,
        healthMultiplier: 1,
        allStatsMultiplier: 1,
        combo: 0,
        critRateMultiplier: 1
    };
    
    // 基础加成
    let bonuses = {
        attackMultiplier: 1,
        critDamageMultiplier: 1,
        healthMultiplier: 1,
        allStatsMultiplier: 1,
        combo: 0,
        critRateMultiplier: 1
    };
    
    
    const effectiveScore = Math.min(companion.score, 50000);
    
    // 应用天赋，最多25个
    const maxTalents = 25;
    const effectiveTalents = companion.talents.slice(0, maxTalents);
    
    effectiveTalents.forEach(talent => {
        const rank = talent.rank;
        const type = talentTypes[talent.type];
        const baseMultiplier = companionRarities[companion.rarity].upgradeMultiplier;
        const scoreDivided = Math.floor(effectiveScore / 100);
        const qualityMultiplier = (scoreDivided + baseMultiplier) * player.companionLevel;
        const advanceMultiplier = 1 + (companion.advanceLevel * 1);
        switch (talent.type) {
            case 0: // 攻击
                bonuses.attackMultiplier += (type.base + type.perLevel * rank) * (1+qualityMultiplier*0.01) * advanceMultiplier;
                break;
            case 1: // 爆伤
                bonuses.critDamageMultiplier += (type.base + type.perLevel * rank) *  (1+qualityMultiplier*0.01)  * advanceMultiplier;
                break;
            case 2: // 生命
                bonuses.healthMultiplier += (type.base + type.perLevel * rank) *  (1+qualityMultiplier*0.01)  * advanceMultiplier;
                break;
            case 3: // 全属性
                bonuses.allStatsMultiplier += (type.base + type.perLevel * rank) *  (1+qualityMultiplier*0.01)  * advanceMultiplier;
                break;
            case 4: // 连击
                bonuses.combo += (type.base + type.perLevel * rank) * 2 * advanceMultiplier ;
                break;
            case 5: // 暴击率
                bonuses.critRateMultiplier += (type.base + type.perLevel * rank) *  (1+qualityMultiplier*0.01)  * (1+advanceMultiplier*0.1) ;
                break;
        }
    });
    
    // 全属性加成应用到攻击和爆伤
    bonuses.attackMultiplier += bonuses.allStatsMultiplier;
    bonuses.critDamageMultiplier += bonuses.allStatsMultiplier;
    
    return bonuses;
}

// 切换通天塔UI
function toggleTowerUI() {
    // 检查转生次数是否达到100次（和普通打怪模式一致）
    if (player.reincarnationCount < 100) {
        alert("需要达到100转才能开启通天塔模式！");
        return;
    }
  
    const towerUI = document.getElementById('towerUI');
    towerUI.style.display = towerUI.style.display === 'none' ? 'block' : 'none';
    if (towerUI.style.display === 'block') {
        // 初始化玩家属性
        generateTowerMonster();
        initTowerPlayerStats();
        player.tower.playerHealth = player.battle.playerHealth;
    player.tower.playerAttack = player.battle.playerAttack;
    player.tower.playerCritRate = player.battle.playerCritRate;
    player.tower.playerCritDamage = player.battle.playerCritDamage;
    player.tower.playerAccuracy = player.battle.playerAccuracy;
    player.tower.playerDodge = player.battle.playerDodge;
        // 如果没有当前怪物，生成一个
        if (!player.tower.monster) {
            generateTowerMonster();
        }
        updateTowerUI();
    }
}

// 初始化通天塔玩家属性
function initTowerPlayerStats() {
    player.tower.playerHealth = player.battle.playerHealth;
    player.tower.playerAttack = player.battle.playerAttack;
    player.tower.playerCritRate = player.battle.playerCritRate;
    player.tower.playerCritDamage = player.battle.playerCritDamage;
    player.tower.playerMultiAttack = player.battle.playerMultiAttack;
}

// 生成通天塔怪物
function generateTowerMonster() {
    const floor = player.tower.currentFloor;
    const monsterRanks = ['普通', '精英', '普通BOSS', '特殊BOSS', '领主BOSS', '霸主级BOSS', '王级BOSS', '皇级BOSS', '帝级BOSS', '神级BOSS', '圣级BOSS'];
    const rankProbabilities = [0.45, 0.20, 0.10, 0.06, 0.05, 0.04, 0.03, 0.03, 0.02, 0.015, 0.005];

    // 随机生成怪物品阶
    let rankIndex = 0;
    let rand = Math.random();
    for (let i = 0; i < rankProbabilities.length; i++) {
        rand -= rankProbabilities[i];
        if (rand < 0) {
            rankIndex = i;
            break;
        }
    }
    const rank = monsterRanks[rankIndex];

    // 根据品阶选择词条
    const modifierPool = monsterRankModifiers[rank].pool;
    const selectCount = monsterRankModifiers[rank].selectCount;
    const selectedModifiers = [];
    const usedModifiers = new Set();

    for (let i = 0; i < selectCount; i++) {
        let modifier;
        do {
            modifier = modifierPool[Math.floor(Math.random() * modifierPool.length)];
        } while (usedModifiers.has(modifier));
        usedModifiers.add(modifier);
        selectedModifiers.push(modifier);
    }

    // 计算怪物属性（通天塔特殊逻辑）
    const baseHealth = 10000000000; // 初始1亿血量
    const healthMultiplier = Math.pow(1.001386, floor); // 每层乘以1.001386
    let attackMultiplier;
    
    if (floor <= 5) {
      attackMultiplier = Math.floor(Math.random() * 50) + 10;
    } else if (floor <= 1500) {
      attackMultiplier = Math.floor(Math.random() * 100) + 100;
    } else if (floor <= 3000) {
      attackMultiplier = 300 + (floor - 1499) * 200;
    } else if (floor <= 10000) {
      attackMultiplier = 1000 + (floor - 2999) * 1000;
    } else if (floor <= 25000) {
      attackMultiplier = 5000 + (floor - 9999) * 10000;
    } else if (floor <= 50000) {
      attackMultiplier = 10000 + (floor - 24999) * 1000000;
    } else if (floor <= 75000) {
      attackMultiplier = 10000 + (floor - 49999) * 1e9;
    } else if (floor <= 100000) {
      attackMultiplier = 10000 + (floor - 74999) * 1e12;
    } else if (floor <= 125000) {
      attackMultiplier = 10000 + (floor - 99999) * 1e15;
    } else if (floor <= 150000) {
      attackMultiplier = 10000 + (floor - 124999) * 1e18;
    } else if (floor <= 175000) {
      attackMultiplier = 10000 + (floor - 149999) * 1e21;
    } else if (floor <= 200000) {
      attackMultiplier = 200000 + (floor - 164999) * 1e24;
    } else if (floor <= 225000) {
      attackMultiplier = 200000 + (floor - 199999) * 1e27;
    } else if (floor <= 250000) {
      attackMultiplier = 3000000 + (floor - 224999) * 1e30;
    } else if (floor <= 275000) {
      attackMultiplier = 3000000 + (floor - 249999) * 1e35;
    } else if (floor <= 300000) {
      attackMultiplier = 3000000 + (floor - 274999) * 1e40;
    } else if (floor <= 325000) {
      attackMultiplier = 50000000 + (floor - 299999) * 1e50;
    } else if (floor <= 350000) {
      attackMultiplier = 60000000 + (floor - 324999) * 1e60;
    } else if (floor <= 375000) {
      attackMultiplier = 60000000 + (floor - 349999) * 1e80;
   }  else if (floor <= 400000) {
     attackMultiplier = 70000000 + (floor - 374999) * 1e100;
    } else if (floor <= 425000) {
     attackMultiplier = 80000000 + (floor - 399999) * 1e120;
    } else if (floor <= 450000) {
     attackMultiplier = 80000000 + (floor - 424999) * 1e150;
    } else {
      attackMultiplier = 90000000 + (floor - 409999) * 1e200;
    }

    let attack = attackMultiplier * (3 + floor * 50);
    let damageReduction = 0;
    let dodgeChance = 0;
    let blockCount = 0;
    let attackCount = 1;
    let damageTakenMultiplier = 1;

    selectedModifiers.forEach(modifier => {
        const effect = monsterModifiers[modifier];
        if (effect.attackMultiplier) attack *= effect.attackMultiplier;
        if (effect.damageReduction) damageReduction += effect.damageReduction;
        if (effect.dodgeChance) dodgeChance += effect.dodgeChance;
        if (effect.blockCount) blockCount += effect.blockCount;
        if (effect.attackCount) attackCount = effect.attackCount;
        if (effect.damageTakenMultiplier) damageTakenMultiplier *= effect.damageTakenMultiplier;
    });

    // 生成怪物，包含复活次数
    player.tower.monster = {
        name: `${getRandomMonsterName()} 等级${Math.floor(floor * 3 + 7)}`,
        rank: rank,
        health: baseHealth * healthMultiplier,
        maxHealth: baseHealth * healthMultiplier,
        attack: attack,
        modifiers: selectedModifiers,
        damageReduction: damageReduction,
        dodgeChance: dodgeChance,
        blockCount: blockCount,
        attackCount: attackCount,
        damageTakenMultiplier: damageTakenMultiplier,
        resurrectionsLeft: 3 // 3次复活机会
    };
}

// 攻击通天塔怪物
function attackTowerMonster() {
const now = Date.now();
            // 移除超过1秒的点击记录
            player.clickTimestamps = player.clickTimestamps.filter(timestamp => now - timestamp < 1000);

            const clickLimit = 10 + player.reincarnationStats.clickLimitBonus.level; // 每级增加1次点击上限
            if (player.clickTimestamps.length >= clickLimit) {
                logAction("点击速度过快，请稍后再试！", "error");
                return;
            }

            player.clickTimestamps.push(now);
// 使用打怪模式属性
    const playerAttack = player.battle.playerAttack;
    const playerCritRate = player.battle.playerCritRate;
    const playerCritDamage = player.battle.playerCritDamage;
    const playerMultiAttack = player.battle.playerMultiAttack;

    if (!player.tower.monster) return;
    
    const monster = player.tower.monster;
    let totalDamage = 0;
    let normalDamage = 0;
    let critDamage = 0;
    let critCount = 0;
    let dodgeCount = 0;
    let totalAttacks = player.tower.playerMultiAttack || 1;
    let battleLogs = [];
    let monsterDefeated = false;

    // 玩家攻击
    for (let i = 0; i < totalAttacks; i++) {
        // 检查是否已被击败
        if (monster.health <= 0) break;
        
        // 检查闪避
        if (Math.random() < monster.dodgeChance) {
            dodgeCount++;
            battleLogs.push(`${monster.name}闪避了你的攻击！`);
            continue;
        }
        
        // 计算基础伤害
        let damage = player.tower.playerAttack;
        
        // 应用伤害减免
        damage *= (1 - monster.damageReduction);
        
        // 应用伤害乘数
        damage *= monster.damageTakenMultiplier;
        
        // 检查暴击
        let isCrit = Math.random() < player.tower.playerCritRate;
        if (isCrit) {
            damage *= player.tower.playerCritDamage;
            critCount++;
            critDamage += damage;
        } else {
            normalDamage += damage;
        }
        
        // 应用伤害
        monster.health -= damage;
        totalDamage += damage;
        
        battleLogs.push(`你对${monster.name}造成了${Math.floor(damage)}点伤害${isCrit ? '（暴击！）' : ''}`);
        
        // 检查怪物是否被击败
        if (monster.health <= 0) {
            // 检查是否还有复活次数
            if (monster.resurrectionsLeft > 0) {
                monster.resurrectionsLeft--;
                monster.health = monster.maxHealth; // 复活回满血
                battleLogs.push(`${monster.name}复活了！剩余复活次数: ${monster.resurrectionsLeft}`);
                
                // BOSS复活后立刻攻击玩家1次
                towerMonsterCounterAttack();
            } else {
                battleLogs.push(`你击败了${monster.name}！`);
                monsterDefeated = true;
            }
            break; // 结束当前连击
          initTowerPlayerStats();
         updateOfficialSystemDisplay();
        updateMonsterUI(); // 更新UI显示
        }
    }

    // 输出综合攻击日志
    battleLogs.push(`你造成了${Math.floor(totalDamage)}点伤害 (${totalAttacks}连击) - 普通伤害: ${Math.floor(normalDamage)}, 闪避x${dodgeCount}, 暴击x${critCount}`);
    
    // 添加到战斗日志
    battleLogs.forEach(log => {
        addTowerBattleLog(log);
    });

    // 如果怪物被彻底击败（无复活次数）
    if (monsterDefeated) {
        player.tower.currentFloor++;
        player.tower.maxFloor = Math.max(player.tower.maxFloor, player.tower.currentFloor);
        addTowerBattleLog(`通关通天塔第${player.tower.currentFloor}层！`);
        checkTitleUnlocks();
        // 更新总属性点
        player.attributes.totalPoints = player.reincarnationCount * 1 + player.battle.maxStage * 10 + player.tower.currentFloor * 1;
        player.attributes.remainingPoints++; // 每通关一层增加1点剩余属性点
        initTowerPlayerStats();
        // 自动进入下一关
        generateTowerMonster();
        updateTowerUI();
        return;
    }

    // 怪物反击（如果还活着）
    if (monster.health > 0) {
        towerMonsterCounterAttack();
    }

    // 检查玩家是否被击败
    if (player.tower.playerHealth <= 0) {
        addTowerBattleLog('你被怪物击败了！');
       // 重置当前层怪物
        generateTowerMonster();
        // 重置玩家状态
        initTowerPlayerStats();
      
      
    }

    updateTowerUI();

}

// 通天塔怪物反击
function towerMonsterCounterAttack() {
    const monster = player.tower.monster;
    if (!monster || monster.health <= 0) return;
    
    for (let i = 0; i < monster.attackCount; i++) {
        // 检查玩家闪避
        if (Math.random() < (player.attributes.dodge * 0.001 || 0)) {
            addTowerBattleLog(`你闪避了${monster.name}的攻击！`);
            continue;
        }        
        
        // 玩家受到伤害
        player.tower.playerHealth -= monster.attack;
        addTowerBattleLog(`${monster.name}对你造成了${monster.attack}点伤害`);
        
        // 检查玩家是否被击败
        if (player.tower.playerHealth <= 0) {
            break;
        }
    }
}

// 切换通天塔自动攻击
function toggleTowerAutoAttack() {
    player.tower.isAutoAttacking = !player.tower.isAutoAttacking;
    document.getElementById('towerAutoAttackStatus').textContent = player.tower.isAutoAttacking ? '开' : '关';
    
    if (player.tower.isAutoAttacking) {
        startTowerAutoAttack();
    } else {
        stopTowerAutoAttack();
    }
}

// 开始通天塔自动攻击
function startTowerAutoAttack() {
    // 先停止现有的自动攻击
    stopTowerAutoAttack();
    
    // 每秒攻击10次
    player.tower.autoAttackInterval = registerInterval(() => {
        if (player.tower.isAutoAttacking && player.tower.monster) {
            attackTowerMonster();
        }
    }, 100);
}

// 停止通天塔自动攻击
function stopTowerAutoAttack() {
    if (player.tower.autoAttackInterval) {
        clearInterval(player.tower.autoAttackInterval);
        player.tower.autoAttackInterval = null;
    }
}

// 添加通天塔战斗日志
function addTowerBattleLog(message) {
    player.tower.battleLog.push({
        time: new Date(),
        message: message
    });
    
    // 限制日志长度
    if (player.tower.battleLog.length > 10) {
        player.tower.battleLog.shift();
    }
    
    // 更新UI显示
    updateTowerBattleLog();
}

// 更新通天塔战斗日志UI
function updateTowerBattleLog() {
    const logElement = document.getElementById('towerBattleLog');
    logElement.innerHTML = '';
    
    player.tower.battleLog.forEach(entry => {
        const logItem = document.createElement('div');
        logItem.className = 'battle-log-entry';
        logItem.textContent = entry.message;
        logElement.appendChild(logItem);
    });
    
    // 滚动到底部
    logElement.scrollTop = logElement.scrollHeight;
}

// 更新通天塔UI
function updateTowerUI() {
    // 更新玩家信息
    document.getElementById('towerPlayerHealth').textContent = Math.floor(player.tower.playerHealth).toExponential(3);
    document.getElementById('towerPlayerAttack').textContent = player.tower.playerAttack.toExponential(3);
    document.getElementById('towerPlayerCritRate').textContent = (player.tower.playerCritRate * 100).toFixed(1) + '%';
    document.getElementById('towerPlayerCritDamage').textContent = ((player.tower.playerCritDamage - 1) * 100).toFixed(1) + '%';

    // 更新通天塔层数显示
    document.getElementById('towerFloor').textContent = player.tower.currentFloor;
    document.getElementById('towerCurrentFloor').textContent = player.tower.currentFloor;
    
    const bonus = player.tower.currentFloor * 0.01; // 每层增加0.01%
    document.getElementById("towerBonus").textContent = bonus.toFixed(2) + "倍";
    // 更新怪物信息
    if (player.tower.monster) {
        const monster = player.tower.monster;
        document.getElementById('towerMonsterName').textContent = monster.name;
        document.getElementById('towerMonsterRank').textContent = monster.rank;
        document.getElementById('towerMonsterHealth').textContent = Math.floor(monster.health).toExponential(3); + '/' + Math.floor(monster.maxHealth).toExponential(3);
        document.getElementById('towerMonsterAttack').textContent = monster.attack.toExponential(3);
        document.getElementById('towerMonsterModifiers').textContent = monster.modifiers.join(', ');
        document.getElementById('towerMonsterResurrections').textContent = monster.resurrectionsLeft;
    }
    
    // 更新自动攻击状态
    document.getElementById('towerAutoAttackStatus').textContent = player.tower.isAutoAttacking ? '开' : '关';
    // 更新战斗日志
    updateTowerBattleLog();
}
// 老虎机配置
const slotMachineConfig = {
    symbols: ["🍒", "🍋", "🍊", "🍇", "🍉", "🍎", "7️⃣"],
    symbolProbabilities: [0.3, 0.25, 0.2, 0.15, 0.07, 0.02, 0.01],
    payouts: {
        "🍒🍒🍒": 5,
        "🍋🍋🍋": 10,
        "🍊🍊🍊": 15,
        "🍇🍇🍇": 20,
        "🍉🍉🍉": 25,
        "🍎🍎🍎": 50,
        "7️⃣7️⃣7️⃣": 100
    },
    minBet: 10,
    maxBet: 1000,
    autoSpinDelay: 2000 // 自动旋转间隔(毫秒)
};

// 初始化老虎机数据
function initSlotMachine() {
    if (!player.slotMachine) {
        player.slotMachine = {
            bet: 10,
            autoSpin: false,
            history: [],
            lastResult: null
        };
    }
}

// 切换老虎机界面
function toggleSlotMachine() {
    const overlay = document.getElementById("slotMachineOverlay");
    const ui = document.getElementById("slotMachineUI");
    
    if (ui.style.display === "block") {
        ui.style.display = "none";
        overlay.style.display = "none";
        
        // 停止自动旋转
        if (player.slotMachine.autoSpin) {
            toggleAutoSpin();
        }
    } else {
        ui.style.display = "block";
        overlay.style.display = "block";
        updateSlotMachineUI();
        
        // 初始化转轴符号
        initReels();
    }
}

// 初始化转轴符号
function initReels() {
    for (let i = 1; i <= 3; i++) {
        const reel = document.getElementById(`reel${i}`);
        reel.innerHTML = "";
        reel.style.top = "0px";
        
        // 为每个转轴添加符号
        for (let j = 0; j < 20; j++) {
            const symbolIndex = Math.floor(Math.random() * slotMachineConfig.symbols.length);
            const symbol = document.createElement("div");
            symbol.style.height = "100px";
            symbol.style.display = "flex";
            symbol.style.alignItems = "center";
            symbol.style.justifyContent = "center";
            symbol.style.fontSize = "40px";
            symbol.textContent = slotMachineConfig.symbols[symbolIndex];
            reel.appendChild(symbol);
        }
    }
}

// 更新老虎机界面
function updateSlotMachineUI() {
    document.getElementById("slotMachineBalance").textContent = formatNumber(player.items.yuzhou1);
    document.getElementById("currentBet").textContent = player.slotMachine.bet;
    
    const autoSpinButton = document.getElementById("autoSpinButton");
    autoSpinButton.textContent = `自动旋转: ${player.slotMachine.autoSpin ? "开启" : "关闭"}`;
    autoSpinButton.style.background = player.slotMachine.autoSpin ? 
        "linear-gradient(45deg, #FFD700, #FF8C00)" : "#444";
    
    // 更新历史记录
    const historyContainer = document.getElementById("slotHistory");
    historyContainer.innerHTML = "";
    
    player.slotMachine.history.slice(-5).forEach(result => {
        const historyItem = document.createElement("div");
        historyItem.style.fontSize = "12px";
        historyItem.style.marginBottom = "3px";
        
        if (result.win > 0) {
            historyItem.style.color = "#90EE90"; // 绿色表示赢
            historyItem.textContent = `${result.combination} - 赢得 ${formatNumber(result.win)} 星尘发票`;
        } else {
            historyItem.style.color = "#FF6B6B"; // 红色表示输
            historyItem.textContent = `${result.combination} - 未中奖`;
        }
        
        historyContainer.appendChild(historyItem);
    });
}

// 改变下注金额
function changeBet(amount) {
    const newBet = player.slotMachine.bet + amount * 10;
    
    if (newBet >= slotMachineConfig.minBet && newBet <= slotMachineConfig.maxBet) {
        player.slotMachine.bet = newBet;
        updateSlotMachineUI();
    }
}

// 旋转老虎机
function spinSlotMachine() {
    if (player.items.yuzhou1 < player.slotMachine.bet) {
        logAction("转生币不足，无法旋转老虎机", "error");
        return;
    }
    
    // 扣除下注金额
    player.items.yuzhou1 -= player.slotMachine.bet;
    
    // 禁用旋转按钮
    const spinButton = document.getElementById("spinButton");
    spinButton.disabled = true;
    spinButton.textContent = "旋转中...";
    
    // 生成随机结果
    const results = [];
    for (let i = 0; i < 3; i++) {
        const rand = Math.random();
        let cumulativeProb = 0;
        
        for (let j = 0; j < slotMachineConfig.symbolProbabilities.length; j++) {
            cumulativeProb += slotMachineConfig.symbolProbabilities[j];
            if (rand <= cumulativeProb) {
                results.push(slotMachineConfig.symbols[j]);
                break;
            }
        }
    }
    
    // 动画效果
    animateReels(results);
    
    // 检查中奖
    setTimeout(() => {
        checkWin(results);
        
        // 重新启用旋转按钮
        spinButton.disabled = false;
        spinButton.textContent = "旋转";
        
        // 如果自动旋转开启，继续旋转
        if (player.slotMachine.autoSpin) {
            setTimeout(() => {
                if (player.items.yuzhou1 >= player.slotMachine.bet) {
                    spinSlotMachine();
                } else {
                    toggleAutoSpin(); // 余额不足，停止自动旋转
                    logAction("星尘发票不足，自动旋转已停止", "warning");
                }
            }, slotMachineConfig.autoSpinDelay);
        }
    }, 3500); // 等待动画完成
}

// 转轴动画
function animateReels(results) {
    for (let i = 1; i <= 3; i++) {
        const reel = document.getElementById(`reel${i}`);
        const symbolHeight = 100; // 每个符号的高度
        
        // 随机停止位置，确保显示正确的符号
        const targetPosition = -((Math.floor(Math.random() * 5) + 5) * symbolHeight);
        
        // 设置动画
        reel.style.transition = "top 3s cubic-bezier(0.17, 0.67, 0.83, 0.67)";
        reel.style.top = `${targetPosition}px`;
    }
}

// 检查中奖
function checkWin(results) {
    const combination = results.join("");
    let winAmount = 0;
    
    // 检查是否中奖
    if (slotMachineConfig.payouts[combination]) {
        winAmount = player.slotMachine.bet * slotMachineConfig.payouts[combination];
        player.items.yuzhou1 += winAmount;
        
        // 显示中奖信息
        const resultElement = document.getElementById("slotResult");
        resultElement.textContent = `恭喜！${combination} 赢得 ${formatNumber(winAmount)} 星尘发票！`;
        resultElement.style.color = "#90EE90";
        resultElement.style.fontSize = "18px";
        
        // 中奖动画
        resultElement.animate([
            { transform: 'scale(1)', opacity: 1 },
            { transform: 'scale(1.2)', opacity: 0.8 },
            { transform: 'scale(1)', opacity: 1 }
        ], {
            duration: 500,
            iterations: 3
        });
        
        logAction(`老虎机中奖：${combination}，赢得 ${formatNumber(winAmount)} 星尘发票`, "success");
    } else {
        const resultElement = document.getElementById("slotResult");
        resultElement.textContent = "未中奖，再试一次！";
        resultElement.style.color = "#FF6B6B";
        
        logAction(`老虎机未中奖：${combination}`, "info");
    }
    
    // 保存结果历史
    player.slotMachine.history.push({
        combination: combination,
        win: winAmount,
        timestamp: Date.now()
    });
    
    // 限制历史记录数量
    if (player.slotMachine.history.length > 10) {
        player.slotMachine.history.shift();
    }
    
    updateSlotMachineUI();
    updateDisplay();
}

// 切换自动旋转
function toggleAutoSpin() {
    player.slotMachine.autoSpin = !player.slotMachine.autoSpin;
    updateSlotMachineUI();
    
    if (player.slotMachine.autoSpin && player.items.yuzhou1 >= player.slotMachine.bet) {
        spinSlotMachine();
    }
}

// 格式化数字显示
function formatNumber(num) {
    if (num >= 1e6) {
        return (num / 1e6).toFixed(2) + "M";
    } else if (num >= 1e3) {
        return (num / 1e3).toFixed(2) + "K";
    }
    return Math.floor(num);
}






// 官职配置
const officialConfig = [
    { level: 1, name: "将仕郎（九品）", attackMultiplier: 2, cost: 100 },
    { level: 2, name: "文林郎（九品）", attackMultiplier: 3, cost: 1000 },
    { level: 3, name: "登仕郎（九品）", attackMultiplier: 4, cost: 10000 },
    { level: 4, name: "儒林郎（九品）", attackMultiplier: 5, cost: 100000 },
    { level: 5, name: "承务郎（八品）", attackMultiplier: 6, cost: 1000000 },
    { level: 6, name: "承奉郎（八品）", attackMultiplier: 7, cost: 1000000 },
    { level: 7, name: "征事郎（八品）", attackMultiplier: 8, cost: 10000000 },
    { level: 8, name: "给事郎（八品）", attackMultiplier: 9, cost: 100000000 },
    { level: 9, name: "宣议郎（七品）", attackMultiplier: 10, cost: 1000000000 },
    { level: 10, name: "朝散郎（七品）", attackMultiplier: 15, cost: 1000000000 },
    { level: 11, name: "武骑尉（七品）", attackMultiplier: 20, cost: 10000000000 },
    { level: 12, name: "宣德郎（七品）", attackMultiplier: 25, cost: 100000000000 },
    { level: 13, name: "朝请郎（七品）", attackMultiplier: 30, cost: 1000000000000 },
    { level: 14, name: "云骑尉（七品）", attackMultiplier: 35, cost: 10000000000000 },
    { level: 15, name: "通直郎（六品）", attackMultiplier: 40, cost: 100000000000000 },
    { level: 16, name: "奉议郎（六品）", attackMultiplier: 45, cost: 1000000000000000 },
    { level: 17, name: "飞骑尉（六品）", attackMultiplier: 50, cost: 10000000000000000 },
    { level: 18, name: "飞骑尉（六品）", attackMultiplier: 55, cost: 100000000000000000 },
    { level: 19, name: "承议郎（六品）", attackMultiplier: 60, cost: 1000000000000000000 },
    { level: 20, name: "承议郎（六品）", attackMultiplier: 65, cost: 10000000000000000000 },
    { level: 21, name: "朝议郎（六品）", attackMultiplier: 70, cost: 100000000000000000000 },
    { level: 22, name: "晓骑尉（六品）", attackMultiplier: 75, cost: 1000000000000000000000 },
    { level: 23, name: "游击将军（五品）", attackMultiplier: 80, cost: 10000000000000000000000 },
    { level: 24, name: "游击将军（五品）", attackMultiplier: 85, cost: 100000000000000000000000 },
    { level: 25, name: "游骑将军（五品）", attackMultiplier: 90, cost: 1000000000000000000000000 },
    { level: 26, name: "骑都尉（五品）", attackMultiplier: 95, cost: 10000000000000000000000000 },
    { level: 27, name: "怀化郎将（五品）", attackMultiplier: 100, cost: 100000000000000000000000000 },
    { level: 28, name: "宁远将军（五品）", attackMultiplier: 150, cost: 1000000000000000000000000000 },
    { level: 29, name: "定远将军（五品）", attackMultiplier: 200, cost: 10000000000000000000000000000 },
    { level: 30, name: "归德中郎将（四品）", attackMultiplier: 250, cost: 100000000000000000000000000000 },
    { level: 31, name: "明威将军（四品）", attackMultiplier: 300, cost: 1000000000000000000000000000000 },
    { level: 32, name: "宣威将军（四品）", attackMultiplier: 350, cost: 10000000000000000000000000000000 },
    { level: 33, name: "轻车都尉（四品）", attackMultiplier: 400, cost: 100000000000000000000000000000000 },
    { level: 34, name: "怀化中郎将（四品）", attackMultiplier: 450, cost: 1000000000000000000000000000000000 },
    { level: 35, name: "忠武将军（四品）", attackMultiplier: 500, cost: 10000000000000000000000000000000000 },
    { level: 36, name: "归德将军（三品）", attackMultiplier: 550, cost: 100000000000000000000000000000000000 },
    { level: 37, name: "云麾将军（三品）", attackMultiplier: 600, cost: 1000000000000000000000000000000000000 },
    { level: 38, name: "护军（三品）", attackMultiplier: 650, cost: 10000000000000000000000000000000000000 },
    { level: 39, name: "怀化大将军（三品）", attackMultiplier: 700, cost: 100000000000000000000000000000000000000 },
    { level: 40, name: "冠军大将军（三品）", attackMultiplier: 750, cost: 1000000000000000000000000000000000000000 },
    { level: 41, name: "镇军大将军（二品）", attackMultiplier: 800, cost: 10000000000000000000000000000000000000000 },
    { level: 42, name: "辅国大将军（二品）", attackMultiplier: 850, cost: 100000000000000000000000000000000000000000 },
    { level: 43, name: "骠骑大将军（一品）", attackMultiplier: 900, cost: 1000000000000000000000000000000000000000000 },
    { level: 44, name: "异地王（特品）", attackMultiplier: 950, cost: 10000000000000000000000000000000000000000000 },
    { level: 45, name: "王爷（特品）", attackMultiplier: 1000, cost: 100000000000000000000000000000000000000000000 },
    { level: 46, name: "国师（特品）", attackMultiplier: 1500, cost: 1000000000000000000000000000000000000000000000 },
    { level: 47, name: "丞相（特品）", attackMultiplier: 2000, cost: 10000000000000000000000000000000000000000000000 },
    { level: 48, name: "辅佐王（特品）", attackMultiplier: 2500, cost: 100000000000000000000000000000000000000000000000 },
    { level: 49, name: "监证（圣品）", attackMultiplier: 3000, cost: 1000000000000000000000000000000000000000000000000 },
    { level: 50, name: "七皇子（圣品）", attackMultiplier: 3500, cost: 10000000000000000000000000000000000000000000000000 },
    { level: 51, name: "六皇子（圣品）", attackMultiplier: 4000, cost: 100000000000000000000000000000000000000000000000000 },
    { level: 52, name: "五皇子（圣品）", attackMultiplier: 4500, cost: 1000000000000000000000000000000000000000000000000000 },
    { level: 53, name: "四皇子（圣品）", attackMultiplier: 5000, cost: 10000000000000000000000000000000000000000000000000000 },
    { level: 54, name: "三皇子（神品）", attackMultiplier: 5500, cost: 100000000000000000000000000000000000000000000000000000 },
    { level: 55, name: "二皇子（神品）", attackMultiplier: 6000, cost: 1000000000000000000000000000000000000000000000000000000 },
    { level: 56, name: "一皇子（神品）", attackMultiplier: 6500, cost: 10000000000000000000000000000000000000000000000000000000 },
    { level: 57, name: "大殿下（神品）", attackMultiplier: 7000, cost: 100000000000000000000000000000000000000000000000000000000 },
    { level: 58, name: "太子爷（仙品）", attackMultiplier: 7500, cost: 1000000000000000000000000000000000000000000000000000000000 },
    { level: 59, name: "皇帝（仙品）", attackMultiplier: 8000, cost: 10000000000000000000000000000000000000000000000000000000000 },
    { level: 60, name: "太上皇（仙品）", attackMultiplier: 8500, cost: 100000000000000000000000000000000000000000000000000000000000 },
  { level: 61, name: "仙兵（帝品）", attackMultiplier: 9000, cost: 1000000000000000000000000000000000000000000000000000000000000000 },
 { level: 62, name: "仙君（帝品）", attackMultiplier: 9500, cost: 100000000000000000000000000000000000000000000000000000000000000000000 },
 { level: 63, name: "仙皇（帝品）", attackMultiplier: 10000, cost: 10000000000000000000000000000000000000000000000000000000000000000000000000 },
 { level: 64, name: "仙王（帝品）", attackMultiplier: 15000, cost: 1000000000000000000000000000000000000000000000000000000000000000000000000000000 },
 { level: 65, name: "仙帝（帝品）", attackMultiplier: 20000, cost: 100000000000000000000000000000000000000000000000000000000000000000000000000000000000 }

];

// 切换官职系统界面显示
function toggleOfficialSystem() {
   if (player.reincarnationCount < 10) {
        alert("需要达到10转才能开启官职系统！");
        return;
    }
    const ui = document.getElementById('officialSystemUI');
    const overlay = document.getElementById('officialSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateOfficialSystemDisplay();
    }
}

// 更新官职系统界面显示
function updateOfficialSystemDisplay() {
    const currentLevel = player.officialLevel;
    let currentOfficial = null;
    let nextOfficial = null;
    
    if (currentLevel > 0) {
        currentOfficial = officialConfig.find(oc => oc.level === currentLevel);
    }
    
    if (currentLevel < 65) {
        nextOfficial = officialConfig.find(oc => oc.level === currentLevel + 1);
    }
    
    // 更新当前官职显示
    document.getElementById('officialTitleDisplay').textContent = currentOfficial ? currentOfficial.name : '无';
    document.getElementById('officialLevelDisplay').textContent = currentLevel;
    document.getElementById('officialBonusDisplay').textContent = currentOfficial ? currentOfficial.attackMultiplier : 1;
    document.getElementById('currentOfficialTitle').textContent = currentOfficial ? currentOfficial.name : '无';
    
    // 更新下一阶官职信息
    const nextOfficialEl = document.getElementById('nextOfficialInfo');
    if (nextOfficial) {
        nextOfficialEl.innerHTML = `${nextOfficial.name} - 攻击加成: ${nextOfficial.attackMultiplier}倍, 消耗: ${formatNumber(nextOfficial.cost)}转生币`;
    } else if (currentLevel >= 65) {
        nextOfficialEl.textContent = '已达到最高官职';
    } else {
        nextOfficialEl.textContent = '请升级官职';
    }
}

// 按指定次数升级官职
function upgradeOfficialByAmount() {
    const amount = parseInt(document.getElementById('officialUpgradeAmount').value) || 1;
    let upgraded = 0;
    
    for (let i = 0; i < amount; i++) {
        if (!upgradeOfficial()) {
            break;
        }
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级官职！`, 'success');
        updateOfficialSystemDisplay();
        updateDisplay();
    }
}        

// 一键升级到最大可能等级
function upgradeOfficialMaxPossible() {
    let upgraded = 0;
    
    while (upgradeOfficial()) {
        upgraded++;
    }
    
    if (upgraded > 0) {
        logAction(`成功升级${upgraded}级官职！`, 'success');
        updateOfficialSystemDisplay();
        updateDisplay();
    }
}

// 升级一级官职
function upgradeOfficial() {
    const nextLevel = player.officialLevel + 1;
    if (nextLevel > 65) {
        logAction("已达到最高官职！", "error");
        return false;
    }
    
    const nextOfficial = officialConfig.find(oc => oc.level === nextLevel);
    if (!nextOfficial) {
        logAction("无法找到下一阶官职配置！", "error");
        return false;
    }
    
    if (player.reincarnationCoin >= nextOfficial.cost) {
        player.reincarnationCoin -= nextOfficial.cost;
        player.officialLevel = nextLevel;
        return true;
    } else {
        logAction("转生币不足，无法升级官职！", "error");
        return false;
    }
}

// 添加格式化大数字的函数（如果没有的话）
function formatNumber(num) {
    if (num >= 1e8) {
        return num.toExponential(3);
    } else {
        return num.toLocaleString();
    }
}
function getOfficialBonus() {
    if (player.officialLevel === 0) return 1;
    
    const official = officialConfig.find(oc => oc.level === player.officialLevel);
    return official ? official.attackMultiplier : 1;
}
// 跑商系统：离线模拟时使用模拟时间，否则使用真实时间
function tradingNow() {
    return (player.trading && player.trading._simulatedNow != null) ? player.trading._simulatedNow : Date.now();
}
// 跑商系统配置和数据
const tradingConfig = {
    cities: {
        '绿叶镇': { region: '森林区', connections: ['林荫城', '精灵之都'], travelTime: 9 },
        '林荫城': { region: '森林区', connections: ['绿叶镇', '精灵之都', '铁石堡'], travelTime: 11 },
        '精灵之都': { region: '森林区', connections: ['绿叶镇', '林荫城', '王都'], travelTime: 14 },
        '铁石堡': { region: '山区', connections: ['林荫城', '高山城', '矿石镇'], travelTime: 10 },
        '高山城': { region: '山区', connections: ['铁石堡', '矿石镇', '金沙城'], travelTime: 12 },
        '矿石镇': { region: '山区', connections: ['铁石堡', '高山城', '平原镇'], travelTime: 11 },
        '海港城': { region: '沿海区', connections: ['渔村', '珍珠港', '贸易中心'], travelTime: 9 },
        '渔村': { region: '沿海区', connections: ['海港城', '珍珠港'], travelTime: 8 },
        '珍珠港': { region: '沿海区', connections: ['海港城', '渔村', '香料市'], travelTime: 10 },
        '谷物乡': { region: '平原区', connections: ['牧野城', '平原镇'], travelTime: 9 },
        '牧野城': { region: '平原区', connections: ['谷物乡', '平原镇', '王都'], travelTime: 11 },
        '平原镇': { region: '平原区', connections: ['谷物乡', '牧野城', '矿石镇'], travelTime: 10 },
        '金沙城': { region: '沙漠区', connections: ['高山城', '绿洲镇', '香料市'], travelTime: 14 },
        '绿洲镇': { region: '沙漠区', connections: ['金沙城', '香料市'], travelTime: 11 },
        '香料市': { region: '沙漠区', connections: ['金沙城', '绿洲镇', '珍珠港', '荒漠哨站'], travelTime: 12 },
        '王都': { region: '都市区', connections: ['精灵之都', '牧野城', '商盟总部', '贸易中心'], travelTime: 6 },
        '商盟总部': { region: '都市区', connections: ['王都', '贸易中心', '工艺之都'], travelTime: 8 },
        '贸易中心': { region: '都市区', connections: ['王都', '商盟总部', '海港城'], travelTime: 6 },
        '工艺之都': { region: '都市区', connections: ['商盟总部', '魔法学院'], travelTime: 9 },
        '魔法学院': { region: '都市区', connections: ['工艺之都', '边陲集市'], travelTime: 10 },
        '边陲集市': { region: '边陲区', connections: ['魔法学院', '北境关', '荒漠哨站', '虚空裂隙'], travelTime: 16 },
        '北境关': { region: '边陲区', connections: ['边陲集市', '雪原堡', '龙脊城', '天穹哨塔'], travelTime: 17 },
        '雪原堡': { region: '边陲区', connections: ['北境关', '龙脊城', '极北冰原'], travelTime: 18 },
        '龙脊城': { region: '边陲区', connections: ['北境关', '雪原堡', '荒漠哨站', '龙巢深渊'], travelTime: 18 },
        '荒漠哨站': { region: '边陲区', connections: ['边陲集市', '龙脊城', '香料市', '荒漠废墟'], travelTime: 19 },
        '极北冰原': { region: '远境', connections: ['雪原堡', '永冻神殿'], travelTime: 23 },
        '龙巢深渊': { region: '远境', connections: ['龙脊城', '龙心禁地'], travelTime: 24 },
        '荒漠废墟': { region: '远境', connections: ['荒漠哨站', '太古遗迹'], travelTime: 25 },
        '天穹哨塔': { region: '远境', connections: ['北境关', '星界之门'], travelTime: 22 },
        '虚空裂隙': { region: '远境', connections: ['边陲集市', '虚空深渊'], travelTime: 21 },
        '永冻神殿': { region: '极远境', connections: ['极北冰原'], travelTime: 27 },
        '龙心禁地': { region: '极远境', connections: ['龙巢深渊'], travelTime: 28 },
        '太古遗迹': { region: '极远境', connections: ['荒漠废墟'], travelTime: 29 },
        '星界之门': { region: '极远境', connections: ['天穹哨塔'], travelTime: 26 },
        '虚空深渊': { region: '极远境', connections: ['虚空裂隙'], travelTime: 30 }
    },

    goods: {
        '木材': { basePrice: 100, type: '资源', slots: 1, shelfLife: Infinity, fluctuation: '小', 
                production: ['绿叶镇', '林荫城', '精灵之都'], scarcity: ['金沙城', '绿洲镇', '香料市'] },
        '铁矿': { basePrice: 150, type: '资源', slots: 1, shelfLife: Infinity, fluctuation: '中',
                production: ['铁石堡', '高山城', '矿石镇'], scarcity: ['海港城', '渔村', '珍珠港'] },
        '谷物': { basePrice: 80, type: '农产品', slots: 1, shelfLife: 15, fluctuation: '中',
                production: ['谷物乡', '牧野城', '平原镇'], scarcity: ['铁石堡', '高山城', '矿石镇'] },
        '棉花': { basePrice: 180, type: '农产品', slots: 1, shelfLife: 30, fluctuation: '中',
                production: ['平原镇', '谷物乡'], scarcity: ['铁石堡', '高山城', '矿石镇'] },
        '盐': { basePrice: 300, type: '必需品', slots: 1, shelfLife: Infinity, fluctuation: '小',
                production: ['渔村', '海港城'], scarcity: ['铁石堡', '高山城', '矿石镇', '金沙城', '绿洲镇', '香料市'] },
        '鱼类': { basePrice: 280, type: '食品', slots: 1, shelfLife: 7, fluctuation: '大',
                production: ['渔村', '珍珠港'], scarcity: ['铁石堡', '高山城', '矿石镇', '金沙城', '绿洲镇', '香料市'] },
        '皮毛': { basePrice: 400, type: '特产', slots: 1, shelfLife: 90, fluctuation: '中',
                production: ['牧野城', '绿叶镇'], scarcity: ['海港城', '渔村', '珍珠港'] },
        '草药': { basePrice: 250, type: '特产', slots: 1, shelfLife: 30, fluctuation: '大',
                production: ['林荫城', '香料市'], scarcity: ['海港城', '渔村', '珍珠港', '金沙城', '绿洲镇'] },
        '陶器': { basePrice: 350, type: '工艺品', slots: 1, shelfLife: Infinity, fluctuation: '中',
                production: ['绿洲镇', '工艺之都'], scarcity: ['绿叶镇', '林荫城', '精灵之都'] },
        '香料': { basePrice: 500, type: '奢侈品', slots: 1, shelfLife: 180, fluctuation: '极大',
                production: ['香料市', '金沙城'], scarcity: ['绿叶镇', '林荫城', '精灵之都', '铁石堡', '高山城', '矿石镇'] },
        '丝绸': { basePrice: 900, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '大',
                production: ['平原镇', '工艺之都'], scarcity: ['绿叶镇', '林荫城', '精灵之都', '铁石堡', '高山城', '矿石镇'] },
        '珠宝': { basePrice: 1300, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['高山城', '王都'], scarcity: ['渔村', '海港城', '珍珠港', '谷物乡', '牧野城', '平原镇'] },
        '葡萄酒': { basePrice: 400, type: '特产', slots: 1, shelfLife: 60, fluctuation: '中',
                production: ['精灵之都', '王都'], scarcity: ['铁石堡', '高山城', '矿石镇', '金沙城', '绿洲镇'] },
        '牲畜': { basePrice: 600, type: '活物', slots: 1, shelfLife: Infinity, fluctuation: '小',
                production: ['牧野城', '平原镇'], scarcity: ['王都', '商盟总部', '贸易中心', '工艺之都', '魔法学院'] },
        '魔法水晶': { basePrice: 1000, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['魔法学院', '高山城'], scarcity: ['渔村', '海港城', '珍珠港', '谷物乡', '牧野城', '平原镇'] },
        '茶叶': { basePrice: 320, type: '特产', slots: 1, shelfLife: 90, fluctuation: '中',
                production: ['林荫城', '绿叶镇'], scarcity: ['金沙城', '绿洲镇', '铁石堡'] },
        '瓷器': { basePrice: 550, type: '工艺品', slots: 1, shelfLife: Infinity, fluctuation: '中',
                production: ['工艺之都', '绿洲镇'], scarcity: ['渔村', '海港城', '牧野城'] },
        '蜜糖': { basePrice: 220, type: '食品', slots: 1, shelfLife: 60, fluctuation: '小',
                production: ['精灵之都', '绿叶镇'], scarcity: ['海港城', '珍珠港', '金沙城'] },
        '玉器': { basePrice: 1100, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '大',
                production: ['高山城', '王都'], scarcity: ['渔村', '谷物乡', '平原镇'] },
        '药材': { basePrice: 380, type: '特产', slots: 1, shelfLife: 45, fluctuation: '大',
                production: ['魔法学院', '林荫城'], scarcity: ['渔村', '珍珠港', '平原镇'] },
        '龙鳞矿': { basePrice: 2500, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '大',
                production: ['龙脊城', '边陲集市'], scarcity: ['王都', '渔村', '海港城', '珍珠港', '谷物乡'] },
        '冰晶': { basePrice: 2200, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '中',
                production: ['雪原堡', '北境关'], scarcity: ['王都', '渔村', '珍珠港', '金沙城', '香料市'] },
        '陨铁': { basePrice: 2800, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '大',
                production: ['荒漠哨站', '龙脊城'], scarcity: ['王都', '渔村', '海港城', '牧野城', '平原镇'] },
        '圣水': { basePrice: 3000, type: '稀有', slots: 1, shelfLife: 90, fluctuation: '极大',
                production: ['边陲集市', '北境关'], scarcity: ['王都', '渔村', '海港城', '铁石堡', '金沙城'] },
        '凤凰羽': { basePrice: 3500, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['边陲集市', '荒漠哨站'], scarcity: ['王都', '铁石堡', '矿石镇', '渔村', '珍珠港'] },
        '龙涎香': { basePrice: 3200, type: '奢侈品', slots: 1, shelfLife: 180, fluctuation: '极大',
                production: ['边陲集市', '荒漠哨站'], scarcity: ['王都', '绿叶镇', '林荫城', '铁石堡', '高山城'] },
        '星陨石': { basePrice: 4000, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['荒漠哨站', '龙脊城'], scarcity: ['王都', '渔村', '海港城', '谷物乡', '牧野城', '平原镇'] },
        '秘银': { basePrice: 2600, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '中',
                production: ['北境关', '雪原堡'], scarcity: ['王都', '渔村', '珍珠港', '绿叶镇', '精灵之都'] },
        '魔核': { basePrice: 3800, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['雪原堡', '龙脊城'], scarcity: ['王都', '渔村', '海港城', '谷物乡', '牧野城'] },
        '神谕卷轴': { basePrice: 4500, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['边陲集市', '龙脊城'], scarcity: ['王都', '渔村', '海港城', '铁石堡', '金沙城', '绿洲镇'] },
        '极寒之心': { basePrice: 5500, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['极北冰原'], scarcity: ['王都', '渔村', '海港城', '珍珠港', '金沙城', '香料市'] },
        '龙魂结晶': { basePrice: 7200, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['龙巢深渊'], scarcity: ['王都', '渔村', '海港城', '谷物乡', '牧野城', '平原镇'] },
        '远古符文': { basePrice: 6800, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '大',
                production: ['荒漠废墟'], scarcity: ['王都', '渔村', '珍珠港', '绿叶镇', '精灵之都'] },
        '天穹星砂': { basePrice: 9000, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['天穹哨塔'], scarcity: ['王都', '铁石堡', '矿石镇', '渔村', '海港城', '牧野城'] },
        '虚空精华': { basePrice: 10000, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['虚空裂隙'], scarcity: ['王都', '渔村', '海港城', '谷物乡', '铁石堡', '金沙城'] },
        '永恒冰髓': { basePrice: 6000, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '大',
                production: ['极北冰原'], scarcity: ['王都', '渔村', '海港城', '珍珠港', '绿洲镇', '香料市', '牧野城'] },
        '太古龙骨': { basePrice: 8500, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['龙巢深渊'], scarcity: ['王都', '渔村', '珍珠港', '谷物乡', '平原镇', '精灵之都'] },
        '神格碎片': { basePrice: 9500, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['荒漠废墟'], scarcity: ['王都', '海港城', '渔村', '牧野城', '林荫城', '工艺之都'] },
        '命运丝线': { basePrice: 7500, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['天穹哨塔'], scarcity: ['王都', '渔村', '珍珠港', '铁石堡', '金沙城', '绿叶镇'] },
        '混沌之核': { basePrice: 8000, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['虚空裂隙'], scarcity: ['王都', '渔村', '海港城', '谷物乡', '高山城', '矿石镇'] },
        '永霜之心': { basePrice: 11500, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['永冻神殿'], scarcity: ['王都', '渔村', '海港城', '珍珠港', '金沙城', '香料市'] },
        '龙神之泪': { basePrice: 12800, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['龙心禁地'], scarcity: ['王都', '渔村', '海港城', '谷物乡', '牧野城', '平原镇'] },
        '创世残页': { basePrice: 14200, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['太古遗迹'], scarcity: ['王都', '渔村', '珍珠港', '绿叶镇', '精灵之都', '工艺之都'] },
        '星河之种': { basePrice: 13800, type: '奢侈品', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['星界之门'], scarcity: ['王都', '铁石堡', '矿石镇', '渔村', '海港城', '牧野城'] },
        '虚空王冠': { basePrice: 15000, type: '稀有', slots: 1, shelfLife: Infinity, fluctuation: '极大',
                production: ['虚空深渊'], scarcity: ['王都', '渔村', '海港城', '谷物乡', '铁石堡', '金沙城', '绿洲镇'] }
    },

    warehouseLevels: [
        { level: 1, capacity: 20, cost: 0 },
        { level: 2, capacity: 30, cost: 300000 },
        { level: 3, capacity: 40, cost: 1000000 },
        { level: 4, capacity: 50, cost: 5000000 },
        { level: 5, capacity: 60, cost: 10000000 },
        { level: 6, capacity: 70, cost: 50000000 },
        { level: 7, capacity: 80, cost: 100000000 },
        { level: 8, capacity: 90, cost: 500000000 },
        { level: 9, capacity: 100, cost: 1000000000 },
        { level: 10, capacity: 120, cost: 5000000000 }
    ],

    transports: [
        { name: '手推车', capacityBonus: 5, speedBonus: 0, cost: 10, maintenance: 0 },
        { name: '驴车', capacityBonus: 10, speedBonus: 1, cost: 200000, maintenance: 10000 },
        { name: '马队', capacityBonus: 20, speedBonus: 2, cost: 1000000, maintenance: 20000 },
        { name: '商队', capacityBonus: 30, speedBonus: 3, cost: 5000000, maintenance: 40000 },
        { name: 'A级战队', capacityBonus: 40, speedBonus: 4, cost: 50000000, maintenance: 50000 },
        { name: '王国商队', capacityBonus: 60, speedBonus: 5, cost: 100000000, maintenance: 800000 },
        { name: '帝国商队', capacityBonus: 80, speedBonus: 6, cost: 1000000000, maintenance: 100000 },
        { name: '皇国商队', capacityBonus: 100, speedBonus: 7, cost: 5000000000, maintenance: 200000 }
    ],

    employees: [
        { type: '初级商贩', efficiencyBonus: 5, cost: 5000, salary: 1000, requirement: 'warehouse30', desc: '自动贸易效率+5%' },
        { type: '资深掌柜', efficiencyBonus: 15, cost: 20000, salary: 5000, requirement: 'warehouse50', desc: '自动贸易效率+15%' },
        { type: '商业间谍', intelligenceDiscount: 30, cost: 50000, salary: 10000, requirement: 'reputation3', desc: '情报折扣30%，假情报率降低' },
        { type: '保镖队长', robberyReduction: 50, cost: 30000, salary: 8000, requirement: 'experiencedRobbery', desc: '被劫损失减免50%' },
        { type: '账房先生', sellBonus: 2, cost: 40000, salary: 6000, requirement: 'warehouse40', desc: '出售收益+2%' },
        { type: '跑腿伙计', travelSpeedBonus: 5, cost: 15000, salary: 2500, requirement: 'warehouse30', desc: '旅行时间-5%' },
        { type: '防损专员', spoilReduction: 30, cost: 25000, salary: 4000, requirement: 'warehouse40', desc: '商品腐败概率-30%' },
        { type: '市场顾问', rumorBonus: 20, cost: 80000, salary: 15000, requirement: 'reputation5', desc: '传闻涨价效果+20%（如15%→18%）' }
    ]
};

// 初始化玩家跑商数据（可选传入 save 对象，用于离线跑商时用 save.lastUpdate 计算离线时长）
function initTradingData(saveForOffline) {
    try {
        if (typeof tradingConfig === 'undefined') {
            setTimeout(function() { initTradingData(saveForOffline); }, 200);
            return;
        }
    } catch (e) {
        setTimeout(function() { initTradingData(saveForOffline); }, 200);
        return;
    }
    if (!player.trading) {
        player.trading = {
            currentCity: '王都',
            warehouse: {
                level: 1,
                capacity: 20,
                used: 0
            },
            transport: {
                type: '手推车',
                capacityBonus: 5,
                speedBonus: 0
            },
            ownedTransports: ['手推车'], // 已拥有的运输工具，购买后永久拥有可切换
            inventory: {}, // 改为对象结构，记录每个商品的详细数据
           autoTrade: {
                enabled: false,
                routes: [],
                efficiency: 0.6,
                currentRoute: null,
                currentState: 'idle',
                currentProgress: 0,
                totalTravelTime: 0,
                lastUpdate: Date.now(),
                logs: [], // 新增：自动贸易日志
                stats: { // 新增：统计信息
                    totalProfit: 0,
                    totalTrades: 0,
                    successfulTrades: 0,
                    failedTrades: 0,
                    totalTravelTime: 0,
                    startTime: Date.now()
                },
            purchaseSettings: {
                    maxGoods: 50, // 最多采购50种商品
                    purchaseStrategy: 'priceDesc', // 价格降序策略
                    minProfitMargin: 10, // 最小利润率
                    maxWarehouseUsage: 0.8, // 最大货仓使用率
                    priceTolerance: 0 // 价格容忍度（0=严格按最大买入价，不超限）
                },
             flexibleTrade: {
                    enabled: true, // 启用灵活贸易
                    maxInventoryValue: 0, // 库存总金额上限（0=不限制）
                    minProfitThreshold: 5, // 最小利润阈值
                    maxCityStayTime: 3600000, // 最大城市停留时间（1小时）
                    explorationChance: 0.2, // 探索新城市的概率
                    returnToBaseChance: 0.3, // 返回基地的概率
                    priceMonitoring: true // 启用价格监控
                },
            backgroundMode: false,
                lastBackgroundUpdate: Date.now(),
                backgroundInterval: null, 
                 currentCityStayStart: Date.now()
            },
            employees: [],
            tradeHistory: [],
             lastTradeTime: player.lastUpdate || Date.now(),
            tradeVolumeToday: 0,
            tradeCountToday: 0,
            cityPrices: {},
           lastPriceUpdate: player.lastUpdate || Date.now(), 
            isTraveling: false,
            travelStartTime: 0,
            travelEndTime: 0,
            travelDestination: '',
            insurance: {
                goods: false,
                transport: false,
                bundle: false
            },
            riskAppetite: 'balanced',
            intelligence: {
                basic: true,
                advanced: false,
                full: false
            },
            reputation: 0,
            merchantLevel: 1,
            guildQuests: { list: [], lastReset: 0 },
            eventBonus: null,
            luckyMerchantNextBuy: false,
            blackMarket: { available: false, endTime: 0, city: '' },
            rumor: { text: '', good: '', city: '', effectEndTime: 0 },
            dailyLucky: { lastDate: '', used: false, buff: null }
        };
        
        // 初始化城市价格
        initCityPrices();
    } else {
        // 离线后加载：先更新城市价格；离线跑商由 loadSave 末尾统一执行
        if (typeof updateCityPrices === 'function') updateCityPrices();
        if (player.trading.reputation == null) player.trading.reputation = 0;
        if (player.trading.merchantLevel == null) player.trading.merchantLevel = 1;
        if (!player.trading.guildQuests) player.trading.guildQuests = { list: [], lastReset: 0 };
        if (player.trading.eventBonus === undefined) player.trading.eventBonus = null;
        if (player.trading.luckyMerchantNextBuy === undefined) player.trading.luckyMerchantNextBuy = false;
        if (!player.trading.blackMarket) player.trading.blackMarket = { available: false, endTime: 0, city: '' };
        if (!player.trading.rumor) player.trading.rumor = { text: '', good: '', city: '', effectEndTime: 0 };
        if (!player.trading.dailyLucky) player.trading.dailyLucky = { lastDate: '', used: false, buff: null };
        if (player.trading.insurance.bundle === undefined) player.trading.insurance.bundle = false;
        if (!player.trading.riskAppetite) player.trading.riskAppetite = 'balanced';
        if (typeof updateMerchantLevelFromReputation === 'function') updateMerchantLevelFromReputation();
        if (typeof ensureGuildQuests === 'function') ensureGuildQuests();
        // 兼容旧存档：已拥有运输工具列表，若不存在则至少包含手推车和当前使用的
        if (!player.trading.ownedTransports || !Array.isArray(player.trading.ownedTransports)) {
            player.trading.ownedTransports = ['手推车'];
            if (player.trading.transport && player.trading.transport.type && player.trading.ownedTransports.indexOf(player.trading.transport.type) === -1) {
                player.trading.ownedTransports.push(player.trading.transport.type);
            }
        }
        // 兼容旧数据：如果inventory是简单数量形式，转换为新格式
        if (player.trading.inventory && typeof player.trading.inventory === 'object') {
            let needsConversion = false;
            Object.keys(player.trading.inventory).forEach(good => {
                if (typeof player.trading.inventory[good] === 'number') {
                    needsConversion = true;
                }
            });
            
            if (needsConversion) {
                const oldInventory = {...player.trading.inventory};
                player.trading.inventory = {};
                Object.keys(oldInventory).forEach(good => {
                    if (oldInventory[good] > 0) {
                        // 使用当前价格作为估算成本（因为没有历史记录）
                        const estimatedCost = player.trading.cityPrices[player.trading.currentCity][good] || tradingConfig.goods[good].basePrice;
                        player.trading.inventory[good] = {
                            quantity: oldInventory[good],
                            averageCost: estimatedCost,
                            totalCost: estimatedCost * oldInventory[good]
                        };
                    }
                });
                logAction("库存数据已升级为新格式", "info");
            }
        }
        
        // 检查是否有未完成的旅行（含离线期间已到达的情况）
        // 若 tradingConfig 尚未定义（loadSave 在脚本前部执行时），延迟执行以免 ReferenceError
        if (player.trading.isTraveling) {
            const now = Date.now();
            const doTravelComplete = function() {
                if (typeof tradingConfig === 'undefined') return;
                if (!player.trading.isTraveling) return;
                if (Date.now() >= player.trading.travelEndTime) {
                    if (player.trading.autoTrade && player.trading.autoTrade.enabled) completeAutoTravel();
                    else completeTravel();
                } else {
                    player.trading.travelInterval = registerInterval(checkTravelStatus, 1000);
                }
            };
            if (typeof tradingConfig === 'undefined') {
                setTimeout(doTravelComplete, 150);
            } else {
                if (now >= player.trading.travelEndTime) {
                    if (player.trading.autoTrade && player.trading.autoTrade.enabled) completeAutoTravel();
                    else completeTravel();
                } else {
                    player.trading.travelInterval = registerInterval(checkTravelStatus, 1000);
                }
            }
        }
    }
}

// 根据当前库存重算仓库占用，避免 warehouse.used 与库存不同步
function syncWarehouseUsedFromInventory() {
    if (!player.trading || !player.trading.inventory || !player.trading.warehouse) return;
    let used = 0;
    Object.keys(player.trading.inventory).forEach(good => {
        const item = player.trading.inventory[good];
        const qty = typeof item === 'object' && item != null && 'quantity' in item ? item.quantity : 0;
        if (qty <= 0) return;
        const goodConfig = tradingConfig.goods[good];
        if (goodConfig && goodConfig.slots) used += goodConfig.slots * qty;
    });
    player.trading.warehouse.used = used;
}

// 初始化城市价格
function initCityPrices() {
    Object.keys(tradingConfig.cities).forEach(city => {
        player.trading.cityPrices[city] = {};
        Object.keys(tradingConfig.goods).forEach(good => {
            player.trading.cityPrices[city][good] = calculateCurrentPrice(city, good);
        });
    });
}
function calculateCurrentPrice(city, good) {
    const goodConfig = tradingConfig.goods[good];
    let price = goodConfig.basePrice;
    
    // 地区修正
    if (goodConfig.production.includes(city)) {
        price *= 0.75; // 产地价格-25%
    } else if (goodConfig.scarcity.includes(city)) {
        price *= 1.3; // 稀缺地价格+30%
    } else {
        price *= 1.1; // 普通地区+10%
    }
    
    // 随机波动 (-30% 到 +50%)
    const randomFluctuation = Math.random() * 0.8 - 0.3;
    price *= (1 + randomFluctuation);
    
    return Math.round(price);
}

// 跑商价格刷新间隔（与 updateCityPrices 一致，确保倒计时同步）
const TRADING_PRICE_REFRESH_INTERVAL_MS = 60 * 60 * 1000;

// 获取价格刷新倒计时文本（与跑商1小时价格刷新同步）
function getPriceRefreshCountdown() {
    if (!player || !player.trading || player.trading.lastPriceUpdate == null) return '';
    const now = Date.now();
    const nextRefresh = (player.trading.lastPriceUpdate || 0) + TRADING_PRICE_REFRESH_INTERVAL_MS;
    let ms = nextRefresh - now;
    if (ms <= 0) return '（即将刷新）';
    const mins = Math.floor(ms / 60000);
    const secs = Math.floor((ms % 60000) / 1000);
    return '（' + mins + '分' + secs + '秒后刷新）';
}

// 更新城市价格（每小时，与价格刷新倒计时同步），返回是否执行了刷新
function updateCityPrices() {
    const now = Date.now();
    const hoursSinceUpdate = (now - player.trading.lastPriceUpdate) / (1000 * 60 * 60);
    
    if (hoursSinceUpdate >= 1) {
        if (!player.trading.cityPrices) player.trading.cityPrices = {};
        Object.keys(tradingConfig.cities).forEach(city => {
            if (!player.trading.cityPrices[city]) player.trading.cityPrices[city] = {};
            Object.keys(tradingConfig.goods).forEach(good => {
                player.trading.cityPrices[city][good] = calculateCurrentPrice(city, good);
            });
        });
        if (player.trading.rumor && player.trading.rumor.city && player.trading.rumor.good && player.trading.rumor.effectEndTime > now) {
            var c = player.trading.rumor.city, g = player.trading.rumor.good;
            var rumorMult = (typeof getEmployeeRumorBonusMultiplier === 'function') ? getEmployeeRumorBonusMultiplier() : 1;
            if (player.trading.cityPrices[c] && player.trading.cityPrices[c][g] != null)
                player.trading.cityPrices[c][g] = Math.ceil((player.trading.cityPrices[c][g] || 0) * (1 + 0.15 * rumorMult));
        }
        player.trading.lastPriceUpdate = now;
        return true;
    }
    return false;
}

function addAutoTradeLog(message, type = 'info') {
    // 确保消息有效
    if (!message || typeof message !== 'string') {
        console.error("无效的日志消息:", message);
        return;
    }
    
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = {
        timestamp,
        message,
        type,
        city: player.trading.currentCity,
        state: player.trading.autoTrade.currentState,
        funds: player.nightClub.starCoins,
        warehouseUsage: calculateWarehouseUsage(),
        isTraveling: player.trading.isTraveling,
        purchaseOpportunities: getAllPurchasableGoods().length,
        saleOpportunities: getAllSalableGoods().length
    };
    
    player.trading.autoTrade.logs.unshift(logEntry);
    
    // 限制日志数量
    if (player.trading.autoTrade.logs.length > 50) {
        player.trading.autoTrade.logs.pop();
    }
    
    // 离线模拟时不更新 DOM，避免报错或界面未就绪
    if (player.trading._simulatedNow != null) return;
    
    // 如果日志界面打开，实时更新
    const logModal = document.getElementById('autoTradeLogModal');
    if (logModal && logModal.style.display === 'block') {
        updateAutoTradeLogDisplay();
    }
    
    // 更新界面状态显示
    updateAutoTradeTab();
}

// 智能灵活贸易：离线期间模拟推进（多次到达、买卖），使重新打开游戏时数据已更新
function simulateOfflineAutoTrade(offlineMs) {
    if (!player.trading || !player.trading.autoTrade || !player.trading.autoTrade.enabled) return;
    offlineMs = Math.min(offlineMs, 24 * 3600 * 1000);
    if (offlineMs < 60000) {
        if (typeof logAction === 'function') logAction('跑商离线: 需至少离线1分钟才模拟，当前约' + Math.floor(offlineMs / 1000) + '秒，未执行', 'info');
        return;
    }
    // 确保城市价格结构存在；价格刷新遵守1小时规则，不因离线而强制刷新
    if (typeof tradingConfig !== 'undefined' && tradingConfig.cities) {
        if (!player.trading.cityPrices) player.trading.cityPrices = {};
        Object.keys(tradingConfig.cities).forEach(function(city) {
            if (!player.trading.cityPrices[city]) player.trading.cityPrices[city] = {};
        });
    }
    if (typeof updateCityPrices === 'function') updateCityPrices();
    if (!player.trading.autoTrade.stats) player.trading.autoTrade.stats = { totalProfit: 0, totalTrades: 0, successfulTrades: 0, failedTrades: 0, totalTravelTime: 0, startTime: Date.now() };
    if (player.trading.autoTrade.stats.totalProfit == null) player.trading.autoTrade.stats.totalProfit = 0;
    var profitBefore = player.trading.autoTrade.stats.totalProfit;
    var simulatedNow = Date.now() - offlineMs;
    var iter = 0;
    var maxIter = 4000; // 提高上限以支持约24小时离线（每步约20–60秒）
    player.trading._simulatedNow = simulatedNow;
    player.trading.autoTrade.nextMonitorTime = 0;
    player.trading.autoTrade.lastUpdate = simulatedNow - 20000;
    try {
        while (simulatedNow < Date.now() && iter < maxIter) {
            iter++;
            player.trading._simulatedNow = simulatedNow;
            try {
                if (player.trading.isTraveling) {
                    if (player.trading.travelEndTime <= simulatedNow) {
                        completeAutoTravel();
                        simulatedNow += 60000;
                    } else {
                        simulatedNow = Math.min(simulatedNow + 60000, player.trading.travelEndTime);
                    }
                } else {
                    player.trading.autoTrade.nextMonitorTime = 0;
                    player.trading.autoTrade.lastUpdate = simulatedNow - 20000;
                    runAutoTrade();
                    simulatedNow += 20000; // 非旅行时每次推进20秒，兼顾次数与覆盖时长
                }
            } catch (e) {
                console.warn('离线跑商模拟单步异常，继续下一轮:', e);
                simulatedNow += 20000;
            }
        }
        if (player.trading.isTraveling && player.trading.travelEndTime > Date.now()) {
            var remaining = player.trading.travelEndTime - simulatedNow;
            player.trading.travelStartTime = Date.now();
            player.trading.travelEndTime = Date.now() + Math.max(0, remaining);
        }
    } finally {
        player.trading._simulatedNow = undefined;
        player.trading.autoTrade.nextMonitorTime = 0;
        player.trading.autoTrade.lastUpdate = Date.now() - 15000;
        var profitAfter = (player.trading.autoTrade.stats && player.trading.autoTrade.stats.totalProfit != null) ? player.trading.autoTrade.stats.totalProfit : 0;
        var offlineProfit = profitAfter - profitBefore;
        var usedSimplified = false;
        if (offlineProfit <= 0 && offlineMs >= 120000) {
            var cap = 0;
            if (player.trading.autoTrade.routes && player.trading.autoTrade.routes[0] && player.trading.autoTrade.routes[0].tradeCapital > 0)
                cap = player.trading.autoTrade.routes[0].tradeCapital;
            if (cap <= 0) cap = Math.max(10000, (player.nightClub.starCoins || 0) * 0.5);
            var offlineHours = offlineMs / (3600 * 1000);
            var simplified = Math.floor(Math.min(offlineHours * cap * 0.008, cap * 0.8));
            if (simplified > 0) {
                if (!player.trading.autoTrade.stats) player.trading.autoTrade.stats = { totalProfit: 0 };
                player.trading.autoTrade.stats.totalProfit = (player.trading.autoTrade.stats.totalProfit || 0) + simplified;
                player.nightClub.starCoins = (player.nightClub.starCoins || 0) + simplified;
                offlineProfit = simplified;
                usedSimplified = true;
            }
        }
        if (typeof logAction === 'function') {
            if (usedSimplified)
                logAction('跑商离线总收益: +' + offlineProfit.toLocaleString() + ' 星币（简化结算）', 'success');
            else if (offlineProfit !== 0)
                logAction((offlineProfit >= 0 ? '跑商离线总收益: +' : '跑商离线总收益: ') + (Math.abs(offlineProfit) >= 1e8 ? offlineProfit.toExponential(2) : Math.floor(offlineProfit).toLocaleString()) + ' 星币', offlineProfit >= 0 ? 'success' : 'error');
            else
                logAction('跑商离线总收益: 0 星币', 'info');
        }
        var profitText = usedSimplified ? ('+' + offlineProfit.toLocaleString() + ' 星币（简化结算）') : (offlineProfit !== 0 ? ((offlineProfit >= 0 ? '+' : '') + (Math.abs(offlineProfit) >= 1e8 ? offlineProfit.toExponential(2) : Math.floor(offlineProfit).toLocaleString()) + ' 星币') : '0 星币');
        if (typeof addAutoTradeLog === 'function') addAutoTradeLog('[离线] 总收益: ' + profitText, offlineProfit > 0 ? 'success' : (offlineProfit < 0 ? 'error' : 'info'));
    }
}

// 统一执行离线跑商结算（在 loadSave 之后调用；会清空 window._tradingOfflineMs）
function runTradingOfflineIfNeeded() {
    var offMs = 0;
    // 最高优先级：页面加载时 head 里抢先读的 lastUpdate（在任何写存档之前），保证离线时长不被覆盖
    if (window.__goldGameSaveLastUpdate != null) {
        var fromFirstRead = Date.now() - window.__goldGameSaveLastUpdate;
        if (fromFirstRead > 0) offMs = Math.min(fromFirstRead, 24 * 3600 * 1000);
        window.__goldGameSaveLastUpdate = null;
    }
    // 其次：loadSave 内算好的 _tradingOfflineMsFromSave
    if (offMs <= 0 && window._tradingOfflineMsFromSave > 0) {
        offMs = Math.min(window._tradingOfflineMsFromSave, 24 * 3600 * 1000);
        window._tradingOfflineMsFromSave = 0;
    }
    var lastUnload = parseInt(localStorage.getItem('goldGameLastUnload') || '0', 10);
    // 来源1：关页时写入的 goldGameLastUnload（任意正数即用，不要求>1分钟）
    if (offMs <= 0 && lastUnload > 0) {
        var fromStorage = Date.now() - lastUnload;
        if (fromStorage > 0) offMs = Math.min(fromStorage, 24 * 3600 * 1000);
    }
    // 来源2：loadSave 里算好的 _tradingOfflineMs / 快照
    if (offMs <= 0) offMs = window._tradingOfflineMs || window._tradingOfflineMsSnapshot || 0;
    // 来源3：直接读存档 lastUpdate（关页未写入 lastUnload 时用）
    if (offMs <= 0) {
        try {
            var save = JSON.parse(localStorage.getItem('goldGameSave'));
            if (save && save.lastUpdate != null) {
                var fromSave = Date.now() - save.lastUpdate;
                if (fromSave > 0) offMs = Math.min(fromSave, 24 * 3600 * 1000);
            }
        } catch (e) {}
    }
    if (typeof logAction === 'function') logAction('跑商离线: 检查中(离线' + Math.floor(offMs / 60000) + '分钟, ' + (player ? player.reincarnationCount + '转' : '无玩家') + ')', 'info');
    if (offMs > 0 && typeof logAction === 'function') logAction('跑商离线: 检测到离线' + Math.floor(offMs / 60000) + '分钟，准备结算…', 'info');
    if (offMs <= 0) {
        window._tradingOfflineMs = 0;
        window._tradingOfflineMsSnapshot = 0;
        if (typeof logAction === 'function') logAction('跑商离线: 未结算 — 原因：离线时长为0（未检测到有效离线间隔，请关页/关游戏一段时间后再打开）', 'info');
        return;
    }
    if (!player) {
        window._tradingOfflineMs = 0;
        window._tradingOfflineMsSnapshot = 0;
        if (typeof logAction === 'function') logAction('跑商离线: 未结算 — 原因：玩家数据未就绪', 'info');
        return;
    }
    if (player.reincarnationCount < 1000) {
        window._tradingOfflineMs = 0;
        window._tradingOfflineMsSnapshot = 0;
        if (typeof logAction === 'function') logAction('跑商离线: 未结算 — 原因：需1000转以上才开启跑商', 'info');
        return;
    }
    if (!player.trading && typeof initTradingData === 'function') initTradingData();
    if (!player.trading || !player.trading.autoTrade || !player.trading.autoTrade.enabled) {
        window._tradingOfflineMs = 0;
        window._tradingOfflineMsSnapshot = 0;
        if (typeof logAction === 'function') logAction('跑商离线: 未结算 — 原因：请先在跑商中勾选「启用自动贸易」并保存路线后再离线', 'info');
        return;
    }
    if (!player.trading.autoTrade.routes || player.trading.autoTrade.routes.length === 0) {
        window._tradingOfflineMs = 0;
        window._tradingOfflineMsSnapshot = 0;
        if (typeof logAction === 'function') logAction('跑商离线: 未结算 — 原因：未保存自动贸易路线（请先设好路线并点「保存路线」）', 'info');
        return;
    }
    window._tradingOfflineRunThisSession = true; // 防止同一会话重复结算
    var offMinutes = Math.floor(offMs / 60000);
    if (typeof logAction === 'function') logAction('跑商离线结算: 开始（离线约' + offMinutes + '分钟）', 'info');
    if (typeof addAutoTradeLog === 'function') addAutoTradeLog('[离线] 开始结算，离线约' + offMinutes + '分钟', 'info');
    try {
        if (typeof updateCityPrices === 'function') updateCityPrices();
        if (typeof simulateOfflineAutoTrade === 'function') {
            simulateOfflineAutoTrade(offMs);
            if (typeof updateDisplay === 'function') updateDisplay();
        }
        if (typeof addAutoTradeLog === 'function') addAutoTradeLog('[离线] 结算完成', 'success');
    } catch (e) {
        console.warn('跑商离线执行异常', e);
        if (typeof logAction === 'function') logAction('跑商离线结算异常: ' + (e && e.message), 'error');
        if (typeof addAutoTradeLog === 'function') addAutoTradeLog('[离线] 结算异常: ' + (e && e.message), 'error');
    }
    window._tradingOfflineMs = 0;
    window._tradingOfflineMsSnapshot = 0;
    localStorage.setItem('goldGameLastUnload', String(Date.now())); // 结算后更新，避免重复计入
}

function withRetry(func, maxRetries = 3, delay = 100) {
    return function(...args) {
        let retries = 0;
        
        function attempt() {
            try {
                return func.apply(this, args);
            } catch (error) {
                if (retries < maxRetries) {
                    retries++;
                    console.warn(`操作失败，第${retries}次重试:`, error);
                    setTimeout(attempt, delay * retries);
                } else {
                    console.error(`操作失败，已达到最大重试次数:`, error);
                    throw error;
                }
            }
        }
        
        return attempt();
    };
}
const safeUpdateAutoTradeProgressBar = withRetry(updateAutoTradeProgressBar);
// 切换跑商系统界面
function toggleTradingSystem() {
    if (player.reincarnationCount < 1000) {
        alert("需要达到1000转才能开启跑商系统！");
        return;
    }
    
    initTradingData();
    updateCityPrices();
    
    const overlay = document.getElementById('tradingSystemOverlay');
    const ui = document.getElementById('tradingSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        if (window.priceRefreshCountdownTimer) {
            clearInterval(window.priceRefreshCountdownTimer);
            window.priceRefreshCountdownTimer = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateTradingUI();
        if (!window.priceRefreshCountdownTimer) {
            window._lastCountdownWasRefresh = false;
            window.priceRefreshCountdownTimer = setInterval(function() {
                const marketTab = document.getElementById('marketTab');
                const ui = document.getElementById('tradingSystemUI');
                if (ui && ui.style.display === 'block' && marketTab && marketTab.classList.contains('active')) {
                    var txt = getPriceRefreshCountdown();
                    if (txt === '（即将刷新）' && typeof updateCityPrices === 'function') {
                        var refreshed = updateCityPrices();
                        if (refreshed && typeof updateMarketTab === 'function') updateMarketTab();
                        txt = getPriceRefreshCountdown();
                    }
                    const el = document.getElementById('priceRefreshCountdown');
                    if (el) el.textContent = txt;
                }
            }, 1000);
        }
    }
}

// 更新跑商界面显示
function updateTradingUI() {
    if (!player || !player.trading || !player.nightClub) return;
    // 更新状态栏
    var cityEl = document.getElementById('currentCity');
    if (cityEl) cityEl.textContent = player.trading.currentCity;
    var starEl = document.getElementById('tradingStarCoins');
    if (starEl) starEl.textContent = (player.nightClub.starCoins != null ? player.nightClub.starCoins : 0).toFixed(0);
    var capEl = document.getElementById('warehouseCapacity');
    if (capEl) capEl.textContent = (player.trading.warehouse.used != null ? player.trading.warehouse.used : 0) + '/' + (typeof getTradingTotalCapacity === 'function' ? getTradingTotalCapacity() : 20);
    var transEl = document.getElementById('transportType');
    if (transEl) transEl.textContent = (player.trading.transport && player.trading.transport.type) ? player.trading.transport.type : '手推车';
    addCancelTravelButton();
    // 添加库存统计按钮
    addInventorySummaryButton();

    // 更新市场标签页
    updateMarketTab();
    
    // 更新地图标签页
    updateMapTab();
    
    // 更新自动贸易标签页
    updateAutoTradeTab();
    
    // 更新经营管理标签页
    updateManagementTab();
    // 更新趣味玩法标签页（若当前显示）
    var funTab = document.getElementById('funTab');
    if (funTab && funTab.classList.contains('active')) updateFunTab();
}

// 更新市场标签页
function updateMarketTab() {
    const city = player.trading.currentCity;
    const goodsList = document.getElementById('cityGoodsList');
    const inventoryList = document.getElementById('playerInventory');
    
    // 更新价格刷新倒计时
    const countdownEl = document.getElementById('priceRefreshCountdown');
    if (countdownEl) countdownEl.textContent = getPriceRefreshCountdown();
    
    // 清空现有内容
    goodsList.innerHTML = '';
    inventoryList.innerHTML = '';
    
    // 生成商品列表（市场商品）
    Object.keys(tradingConfig.goods).forEach(good => {
        const price = player.trading.cityPrices[city][good];
        const goodConfig = tradingConfig.goods[good];
        
        const trend = getPriceTrend(good, city);
        const trendColor = getPriceTrendColorByTrend(trend);
        const trendHint = getPriceTrendHint(good, city);
        const goodElement = document.createElement('div');
        goodElement.className = 'good-item';
        goodElement.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr; gap: 10px; padding: 5px; border-bottom: 1px solid #444; align-items: center;">
                <div><strong>${good}</strong></div>
                <div>${price.toLocaleString()}星币</div>
                <div>${goodConfig.type}</div>
                <div>${goodConfig.slots}格</div>
                <div style="color: ${trendColor}; cursor: help;" title="${trendHint}">${trend}</div>
                <div>
                    <button onclick="buyGood('${good}', 1)" style="padding: 2px 8px; margin: 1px;">买1</button>
                    <button onclick="buyGood('${good}', 10)" style="padding: 2px 8px; margin: 1px;">买10</button>
                </div>
            </div>
        `;
        goodsList.appendChild(goodElement);
    });
    
    // 生成库存列表（玩家库存）
    Object.keys(player.trading.inventory).forEach(good => {
        const inventoryItem = player.trading.inventory[good];
        const quantity = inventoryItem.quantity;
        const currentPrice = player.trading.cityPrices[city][good];
        const averageCost = inventoryItem.averageCost;
        const totalCost = inventoryItem.totalCost;
        
        // 计算盈亏
        const currentValue = currentPrice * quantity;
        const profit = currentValue - totalCost;
        const profitRate = totalCost > 0 ? (profit / totalCost) * 100 : 0;
        
        const goodConfig = tradingConfig.goods[good];
        const profitColor = profit >= 0 ? '#4CAF50' : '#f44336'; // 绿色盈利，红色亏损
        const profitSign = profit >= 0 ? '+' : '';
        
        const inventoryElement = document.createElement('div');
        inventoryElement.className = 'inventory-item';
        inventoryElement.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr; gap: 10px; padding: 5px; border-bottom: 1px solid #444; align-items: center;">
                <div><strong>${good}</strong></div>
                <div>${quantity}个</div>
                <div>${currentPrice.toLocaleString()}星币</div>
                <div title="平均成本：${averageCost.toFixed(0)}星币">${averageCost.toFixed(0)}星币</div>
                <div style="color: ${profitColor}; font-weight: bold;">
                    ${profitSign}${profitRate.toFixed(1)}%
                </div>
                <div style="color: ${profitColor};">
                    ${profitSign}${Math.abs(profit).toFixed(0)}
                </div>
                <div>
                    <button onclick="sellGood('${good}', 1)" style="padding: 2px 8px; margin: 1px;">卖1</button>
                    <button onclick="sellGood('${good}', 10)" style="padding: 2px 8px; margin: 1px;">卖10</button>
                </div>
            </div>
        `;
        inventoryList.appendChild(inventoryElement);
    });
    
    // 如果没有库存，显示提示
    if (Object.keys(player.trading.inventory).length === 0) {
        inventoryList.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">暂无库存商品</div>';
    }
}
// 价格趋势：基于「当前价/基础价」判断，对跑商有参考意义
// 低于基础价=便宜=看涨(↑)适合在此买入；高于基础价=贵=看跌(↓)适合卖出或去别处买
function getPriceTrend(good, city) {
    var goodConfig, basePrice, currentPrice, ratio;
    try {
        goodConfig = tradingConfig.goods[good];
        if (!goodConfig || goodConfig.basePrice <= 0) return '→';
        basePrice = goodConfig.basePrice;
        currentPrice = (player.trading && player.trading.cityPrices && player.trading.cityPrices[city]) ? player.trading.cityPrices[city][good] : null;
        if (currentPrice == null) return '→';
        ratio = currentPrice / basePrice;
        if (ratio >= 1.25) return '↓↓↓';
        if (ratio >= 1.15) return '↓↓';
        if (ratio >= 1.05) return '↓';
        if (ratio <= 0.75) return '↑↑↑';
        if (ratio <= 0.85) return '↑↑';
        if (ratio <= 0.95) return '↑';
        return '→';
    } catch (e) {
        return '→';
    }
}

// 趋势说明（用于 title 提示）
function getPriceTrendHint(good, city) {
    var goodConfig, basePrice, currentPrice, ratio, pct;
    try {
        goodConfig = tradingConfig.goods[good];
        if (!goodConfig || goodConfig.basePrice <= 0) return '价格平稳';
        basePrice = goodConfig.basePrice;
        currentPrice = (player.trading && player.trading.cityPrices && player.trading.cityPrices[city]) ? player.trading.cityPrices[city][good] : null;
        if (currentPrice == null) return '价格平稳';
        ratio = currentPrice / basePrice;
        pct = Math.round((ratio - 1) * 100);
        if (ratio >= 1.05) return '当前价比基础价高' + pct + '%，偏高，适合卖出或去产地买';
        if (ratio <= 0.95) return '当前价比基础价低' + Math.abs(pct) + '%，偏低，适合在此买入';
        return '当前价接近基础价，平稳';
    } catch (e) {
        return '价格平稳';
    }
}

// 根据趋势符号返回颜色（不重复调用 getPriceTrend，避免与显示不一致）
function getPriceTrendColorByTrend(trend) {
    if (trend && trend.indexOf('↑') >= 0) return '#4CAF50';
    if (trend && trend.indexOf('↓') >= 0) return '#f44336';
    return '#FFC107';
}

// 获取价格趋势颜色（兼容其它调用处）
function getPriceTrendColor(good, city) {
    return getPriceTrendColorByTrend(getPriceTrend(good, city));
}
// 更新地图标签页
function updateMapTab() {
    const mapContainer = document.getElementById('mapTab');
    if (!mapContainer) return;
    
    mapContainer.innerHTML = `
        <div style="text-align: center; margin-bottom: 15px;">
            <h3>世界地图</h3>
            <div style="font-size: 0.9em; color: #aaa;">点击城市选择目的地</div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
            ${generateRegionMap()}
        </div>
        
        <div style="margin-bottom: 15px; padding: 12px; background: #2a2a2a; border-radius: 5px;">
            <h4 style="color: #FFD700; margin: 0 0 8px 0;">城市路线与时间</h4>
            <div style="font-size: 0.85em; color: #aaa; max-height: 200px; overflow-y: auto;">
                ${generateRoutesWithTime()}
            </div>
        </div>
        
        <div id="travelInfo" style="margin-top: 15px; padding: 15px; background: #333; border-radius: 5px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div><strong>当前位置:</strong> <span id="currentLocation">${player.trading.currentCity}</span></div>
                <div><strong>目标城市:</strong> <span id="targetCity">${player.trading.travelDestination || '-'}</span></div>
                <div><strong>预计时间:</strong> <span id="travelTime">${calculateTravelTime()}</span></div>
                <div><strong>状态:</strong> <span id="travelStatus">${getTravelStatus()}</span></div>
            </div>
            
            <div id="travelProgressContainer" style="${player.trading.isTraveling ? '' : 'display: none;'}">
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>旅行进度</span>
                    <span id="progressPercentage">0%</span>
                </div>
                <div style="width: 100%; height: 10px; background: #444; border-radius: 5px;">
                    <div id="travelProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 5px; transition: width 0.5s;"></div>
                </div>
            </div>
            
            <div style="margin-top: 15px; display: flex; gap: 10px;">
                <button id="startTravelBtn" onclick="startTravel()" style="flex: 1; padding: 8px; ${getStartTravelButtonStyle()}">${getTravelButtonText()}</button>
                <button id="cancelTravelBtn" onclick="cancelTravel()" style="flex: 1; padding: 8px; background: #f44336; ${!player.trading.isTraveling ? 'display: none;' : ''}">取消旅行</button>
             <button onclick="showIntelligencePurchaseOptions('${player.trading.currentCity}')" style="flex: 1; padding: 8px; background: #9C27B0; color: white; border: none; border-radius: 3px; cursor: pointer;">购买情报</button>
            </div>
            
            ${player.trading.autoTrade.enabled ? `
                <div style="margin-top: 10px; padding: 8px; background: #2a2a2a; border-radius: 3px; border-left: 3px solid #FF9800;">
                    <div style="color: #FF9800; font-size: 0.9em; text-align: center;">
                        ⚠️ 自动贸易已启用，手动旅行已禁用
                    </div>
                </div>
            ` : ''}
        </div>
    <!-- 显示当前城市的情报信息 -->
        <div style="margin-top: 20px;">
            <h4>当前情报信息</h4>
            ${generateCurrentIntelligenceInfo()}
        </div>
    `;
    
    // 更新旅行进度（如果正在旅行中）
    if (player.trading.isTraveling) {
        updateTravelProgress();
    }
}
// 生成当前情报信息
function generateCurrentIntelligenceInfo() {
    if (!player || !player.trading || !player.trading.intelligence || !player.trading.currentCity || !player.trading.intelligence[player.trading.currentCity]) {
        return `
            <div style="text-align: center; color: #aaa; padding: 20px; background: #2a2a2a; border-radius: 5px;">
                <p>暂无可用情报</p>
                <p style="font-size: 0.9em;">点击上方"购买情报"按钮获取市场信息</p>
            </div>
        `;
    }
    
    const cityIntelligence = player.trading.intelligence[player.trading.currentCity];
    let infoHtml = '';
    const titles = { 'marketPrices': '市场价格', 'supplyDemand': '供需情况', 'futureTrends': '未来趋势', 'specialEvents': '特殊事件' };
    
    Object.keys(cityIntelligence).forEach(type => {
        const intel = cityIntelligence[type];
        const expiryTime = intel.expiryTime != null ? intel.expiryTime : 0;
        const isExpired = Date.now() > expiryTime;
        const remainingMin = isExpired ? 0 : Math.max(0, Math.ceil((expiryTime - Date.now()) / (60 * 1000)));
        const borderColor = isExpired ? "#f44336" : "#4CAF50";
        const textColor = isExpired ? "#f44336" : "#4CAF50";
        const subColor = isExpired ? "#f44336" : "#aaa";
        const statusText = isExpired ? "已过期" : ("剩余 " + remainingMin + " 分钟");
        infoHtml += "<div style=\"background: #2a2a2a; border-radius: 5px; padding: 15px; margin-bottom: 10px; border-left: 4px solid " + borderColor + ";\">" +
            "<div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;\">" +
            "<div style=\"font-weight: bold; color: " + textColor + ";\">" + titles[type] + "</div>" +
            "<div style=\"font-size: 0.8em; color: " + subColor + ";\">" + statusText + "</div>" +
            "</div>" +
            "<div style=\"font-size: 0.85em; color: #888;\">购买: " + (intel.purchaseTime ? new Date(intel.purchaseTime).toLocaleString() : "-") + " · " + (intel.price != null ? intel.price : 0).toLocaleString() + "星币</div>" +
            "<div style=\"margin-top: 10px;\">" +
            "<button onclick=\"viewIntelligenceDetails('" + player.trading.currentCity + "', '" + type + "')\" style=\"background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.8em;\">查看详情</button>" +
            "</div></div>";
    });
    
    return infoHtml;
}

// 查看情报详情
function viewIntelligenceDetails(city, type) {
    const intelligence = player.trading.intelligence[city][type];
    showIntelligenceDetails(city, type, intelligence.data, intelligence.isFake);
}

// 添加情报配置到游戏配置
function initTradingConfig() {
    if (!tradingConfig.intelligence) {
        tradingConfig.intelligence = {
            marketPrices: {
                price: 5000,
                duration: 60, // 60分钟
                description: "获取所有商品的当前市场价格"
            },
            supplyDemand: {
                price: 8000,
                duration: 45, // 45分钟
                description: "了解市场供需情况，发现潜在机会"
            },
            futureTrends: {
                price: 12000,
                duration: 30, // 30分钟
                description: "预测未来价格趋势，把握市场动向"
            },
            specialEvents: {
                price: 15000,
                duration: 20, // 20分钟
                description: "获取特殊市场事件信息，抢占先机"
            }
        };
    }
}
function getStartTravelButtonStyle() {
    if (player.trading.autoTrade.enabled) {
        return 'background: #666; color: #999; cursor: not-allowed;';
    } else if (player.trading.isTraveling) {
        return 'background: #666; cursor: not-allowed;';
    } else {
        return 'background: #4CAF50; color: white; cursor: pointer;';
    }
}
// 生成「城市路线与时间」列表（基础行程时间，双向只按起点列一次）
function generateRoutesWithTime() {
    const cities = tradingConfig.cities || {};
    const list = [];
    Object.keys(cities).forEach(from => {
        const conns = cities[from].connections || [];
        const parts = conns.map(to => {
            const baseMin = (cities[to] && cities[to].travelTime != null) ? cities[to].travelTime : '-';
            return `${to}(${baseMin}分)`;
        });
        if (parts.length) list.push(`${from} → ${parts.join('、')}`);
    });
    return list.length ? list.join('<br>') : '暂无路线';
}

function generateRegionMap() {
    // 从 tradingConfig.cities 动态生成区域与城市，新城市自动显示
    const regions = {};
    Object.keys(tradingConfig.cities).forEach(city => {
        const region = tradingConfig.cities[city].region;
        if (!regions[region]) regions[region] = [];
        regions[region].push(city);
    });
    const regionOrder = ['森林区', '山区', '沿海区', '平原区', '沙漠区', '都市区', '边陲区', '远境', '极远境'];
    const orderedRegionKeys = regionOrder.filter(r => regions[r]);
    Object.keys(regions).forEach(r => { if (orderedRegionKeys.indexOf(r) === -1) orderedRegionKeys.push(r); });
    
    let html = '';
    orderedRegionKeys.forEach(region => {
        html += `
            <div class="region" style="background: #2a2a2a; padding: 10px; border-radius: 5px;">
                <h4 style="color: #FFD700; margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 5px;">${region}</h4>
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    ${regions[region].map(city => generateCityButton(city)).join('')}
                </div>
            </div>
        `;
    });
    
    return html;
}

// 计算到某城市的预计行程时间（分钟，含运输/停车加成）
function getTravelTimeToCity(destinationCity) {
    const cityCfg = tradingConfig.cities[destinationCity];
    if (!cityCfg) return null;
    const baseTime = cityCfg.travelTime;
    const speedBonus = player.trading.transport && player.trading.transport.speedBonus ? player.trading.transport.speedBonus : 0;
    const parkingLevel = (player.parking && typeof player.parking.level === 'number') ? player.parking.level : 0;
    const parkingReduce = Math.min(parkingLevel / 33, 1.21);
    return Math.max(0.1, (baseTime * (100 - speedBonus) / 100) - parkingReduce);
}

// 生成城市按钮（含行程时间）
function generateCityButton(city) {
    const isCurrentCity = player.trading.currentCity === city;
    const isSelected = player.trading.travelDestination === city;
    const isConnected = tradingConfig.cities[player.trading.currentCity].connections.includes(city);
    const timeStr = isCurrentCity ? '当前' : (isConnected ? getTravelTimeToCity(city).toFixed(1) + '分钟' : '-');
    
    let buttonStyle = 'padding: 8px; border-radius: 3px; border: none; cursor: pointer;';
    
    // 如果自动贸易启用，禁用所有城市按钮
    if (player.trading.autoTrade.enabled) {
        buttonStyle += 'background: #666; color: #999; cursor: not-allowed;';
    } else if (isCurrentCity) {
        buttonStyle += 'background: #FFD700; color: black; font-weight: bold;';
    } else if (isSelected) {
        buttonStyle += 'background: #4CAF50; color: white;';
    } else if (isConnected) {
        buttonStyle += 'background: #2196F3; color: white;';
    } else {
        buttonStyle += 'background: #666; color: white; cursor: not-allowed;';
    }
    
    return `
        <button 
            onclick="selectDestination('${city}')" 
            style="${buttonStyle}"
            ${(player.trading.autoTrade.enabled || !isConnected && !isCurrentCity) ? 'disabled' : ''}
            title="${player.trading.autoTrade.enabled ? '自动贸易已启用，无法手动选择' : (!isConnected && !isCurrentCity ? '未连接到此城市' : `点击选择${city}，预计${timeStr}`)}"
        >
            ${city}${timeStr !== '当前' ? ' (' + timeStr + ')' : ''}
        </button>
    `;
}
function calculateTravelTime() {
    if (!player.trading.travelDestination) return '-';
    const cityCfg = tradingConfig.cities[player.trading.travelDestination];
    if (!cityCfg) return '-';
    const baseTime = cityCfg.travelTime;
    const speedBonus = player.trading.transport.speedBonus || 0;
    const parkingLevel = (player.parking && typeof player.parking.level === 'number') ? player.parking.level : 0;
    const parkingReduce = Math.min(parkingLevel / 33, 1.21);
    let actualTime = Math.max(0.1, (baseTime * (100 - speedBonus) / 100) - parkingReduce);
    var empTravel = (typeof getEmployeeTravelSpeedBonus === 'function') ? getEmployeeTravelSpeedBonus() : 0;
    if (empTravel > 0) actualTime = Math.max(0.1, actualTime * (1 - empTravel / 100));
    if (player.trading.travelTimeReductionEnd && Date.now() <= player.trading.travelTimeReductionEnd && (player.trading.travelTimeReduction || 0) > 0)
        actualTime = Math.max(0.1, actualTime * (1 - player.trading.travelTimeReduction));
    return `${actualTime.toFixed(1)}分钟`;
}

function getTravelStatus() {
    if (player.trading.isTraveling) {
        const now = Date.now();
        const progress = Math.min(100, ((now - player.trading.travelStartTime) / (player.trading.travelEndTime - player.trading.travelStartTime)) * 100);
        return `旅行中... ${progress.toFixed(1)}%`;
    }
    return player.trading.travelDestination ? '准备出发' : '选择目的地';
}

// 获取旅行按钮文本
function getTravelButtonText() {
    if (player.trading.autoTrade.enabled) {
        return '自动贸易中';
    } else if (player.trading.isTraveling) {
        return '旅行中';
    } else {
        return player.trading.travelDestination ? '开始旅行' : '选择目的地';
    }
}
function selectDestination(city) {
    // 如果自动贸易启用，禁用手动选择目的地
    if (player.trading.autoTrade.enabled) {
        logAction("自动贸易已启用，无法手动选择目的地", "warning");
        return;
    }
    
    if (player.trading.isTraveling) {
        logAction("当前正在旅行中，无法更改目的地", "error");
        return;
    }
    
    if (city === player.trading.currentCity) {
        logAction("已经在当前城市", "info");
        return;
    }
    
    // 检查是否连接
    if (!tradingConfig.cities[player.trading.currentCity].connections.includes(city)) {
        logAction(`无法直接前往${city}，需要先连接到该城市`, "error");
        return;
    }
    
    player.trading.travelDestination = city;
    logAction(`已选择目的地：${city}`, "info");
    
    // 更新界面
    updateMapTab();
}

// 更新自动贸易标签页

// 修改自动贸易界面HTML
function updateAutoTradeTab() {
    const autoTab = document.getElementById('autoTab');
    if (!autoTab) return;
    
    // 检查是否有保存的路线
    const hasRoutes = player.trading.autoTrade.routes && player.trading.autoTrade.routes.length > 0;
    
    // 获取当前城市的采购和销售机会数量
    const purchaseOpportunities = getAllPurchasableGoods().length;
    const saleOpportunities = getAllSalableGoods().length;
    
    autoTab.innerHTML = `
        <div style="margin-bottom: 20px;">
            <h3>智能灵活贸易系统 ${player.trading.autoTrade.backgroundMode ? '(后台运行中)' : ''}</h3>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <label>
                    <input type="checkbox" id="autoTradeEnabled" onchange="toggleAutoTrade()" ${player.trading.autoTrade.enabled ? 'checked' : ''} ${!hasRoutes ? 'disabled' : ''}>
                    启用自动贸易
                </label>
                <span id="autoTradeState" style="color: #FFD700; font-weight: bold;">${getAutoTradeStateText()}</span>
                <span id="backgroundIndicator" style="color: #4CAF50; font-size: 0.9em; ${player.trading.autoTrade.backgroundMode ? '' : 'display: none;'}">
                    ✓ 后台运行中
                </span>
                <button onclick="showAutoTradeLog()" style="margin-left: auto; background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">查看日志</button>
            </div>
            
            ${!hasRoutes ? `
                <div style="background: #2a2a2a; border-left: 4px solid #FF9800; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                    <h4 style="color: #FF9800; margin-top: 0;">⚠️ 未设置自动贸易路线</h4>
                    <p style="margin: 0; color: #aaa;">请先设置自动贸易路线才能启用自动贸易功能。</p>
                </div>
            ` : generateAutoTradeProgressBar()}
            
            <div id="autoTradeStatus" class="auto-trade-status" style="${player.trading.autoTrade.enabled ? '' : 'display: none;'}">
                <h4>当前状态 - ${player.trading.currentCity}</h4>
                
                <!-- 机会概览 -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div style="background: rgba(76,175,80,0.1); border-left: 4px solid #4CAF50; padding: 10px; border-radius: 4px;">
                        <div style="font-size: 0.9em; color: #aaa;">采购机会</div>
                        <div style="font-size: 1.2em; font-weight: bold; color: #4CAF50;">${purchaseOpportunities}</div>
                    </div>
                    <div style="background: rgba(33,150,243,0.1); border-left: 4px solid #2196F3; padding: 10px; border-radius: 4px;">
                        <div style="font-size: 0.9em; color: #aaa;">销售机会</div>
                        <div style="font-size: 1.2em; font-weight: bold; color: #2196F3;">${saleOpportunities}</div>
                    </div>
                </div>
                
                <div class="auto-trade-stats">
                    <div class="stat-item">
                        <div class="stat-label">当前城市</div>
                        <div class="stat-value">${player.trading.currentCity}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">运行模式</div>
                        <div class="stat-value">${player.trading.autoTrade.backgroundMode ? '后台运行' : '前台运行'}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">贸易状态</div>
                        <div class="stat-value">${getFlexibleTradeStateText()}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">城市停留</div>
                        <div class="stat-value">${formatTimeInCity()}分钟</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">货仓使用率</div>
                        <div class="stat-value">${calculateWarehouseUsage()}%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">可用资金</div>
                        <div class="stat-value">${player.nightClub.starCoins.toLocaleString()}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">今日利润</div>
                        <div class="stat-value" style="color: ${player.trading.tradeVolumeToday >= 0 ? '#4CAF50' : '#f44336'}">
                            ${player.trading.tradeVolumeToday >= 0 ? '+' : ''}${player.trading.tradeVolumeToday.toLocaleString()}
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">总利润</div>
                        <div class="stat-value" style="color: ${player.trading.autoTrade.stats.totalProfit >= 0 ? '#4CAF50' : '#f44336'}">
                            ${player.trading.autoTrade.stats.totalProfit >= 0 ? '+' : ''}${player.trading.autoTrade.stats.totalProfit.toLocaleString()}
                        </div>
                    </div>
                </div>
                 
                <div class="auto-trade-controls">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;">
                        <button onclick="pauseAutoTrade()" class="control-btn warning">${player.trading.autoTrade.backgroundMode ? '暂停后台' : '暂停'}</button>
                        <div class="auto-trade-controls">
                        <button onclick="stopAutoTrade()" class="control-btn danger">停止</button>
                         
                        <button onclick="showAutoTradeLog()" class="control-btn primary">查看日志</button>
                        ${player.trading.autoTrade.backgroundMode ? 
                         '<button onclick="forceForeground()" class="control-btn secondary">切换到前台</button>' : ''}
                        <button onclick="forceMoveToNewCity()" class="control-btn info">前往新城市</button>
                        <button onclick="forceStayInCurrentCity()" class="control-btn success">停留当前城市</button>
                        <button onclick="resetAutoTradeState()" class="control-btn default">重置状态</button>
                        <button onclick="forceCheckOpportunities()" class="control-btn primary">立即检查机会</button>
                    </div>
                </div>
                
                ${isFrequentTravelDetected() ? `
                    <div style="margin-top: 15px; padding: 10px; background: #f44336; border-radius: 5px; text-align: center;">
                        <strong style="color: white;">⚠️ 检测到频繁旅行，建议重置状态或停留当前城市</strong>
                    </div>
                ` : ''}
            </div>
        </div>
        
        
        <div id="autoTradeSettings" style="${player.trading.autoTrade.enabled ? 'display: none;' : 'display: block;'}">
            <h4>设置灵活贸易路线</h4>
            <p style="color: #aaa; font-size: 0.9em; margin: 0 0 10px 0;">只需设置：<strong>最小利润率、单次资金、勾选贸易商品</strong>并点击「保存路线」，无需选择采购城/销售城，系统会自动在各城市寻找买卖机会。</p>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div>
                    <label>最小利润率:</label>
                    <input type="number" id="minProfitMargin" value="10">%
                </div>
                <div>
                    <label>单次资金:</label>
                    <input type="number" id="tradeCapital" value="10000">
                </div>
            </div>
            
            <h4>选择贸易商品（最多50种）</h4>
            <div id="goodsSelection" style="margin-bottom: 15px;">
                ${generateGoodsSelection()}
            </div>
            
            <h4>采购策略设置</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div>
                    <label>最多商品种类:</label>
                    <input type="number" id="maxGoods" value="${(player.trading.autoTrade.purchaseSettings.maxGoods || 50)}" min="1" max="50" title="可选择1-50种贸易商品" onchange="if(typeof updateSelectedGoodsCount==='function')updateSelectedGoodsCount()">
                </div>
                <div>
                    <label>采购策略:</label>
                    <select id="purchaseStrategy">
                        <option value="priceDesc">价格降序（先买最贵的）</option>
                        <option value="priceAsc">价格升序（先买最便宜的）</option>
                        <option value="profitMargin">利润率优先</option>
                    </select>
                </div>
                <div>
                    <label>最大货仓使用率:</label>
                    <input type="number" id="maxWarehouseUsage" value="80" min="50" max="95">%
                </div>
                <div>
                    <label>价格容忍度:</label>
                    <input type="number" id="priceTolerance" value="0" min="0" max="50">%
                </div>
            </div>
            
            <h4>灵活贸易设置</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <div>
                    <label>最大城市停留时间:</label>
                    <input type="number" id="maxCityStayTime" value="60" min="10" max="240">分钟
                </div>
                <div>
                    <label>探索新城市概率:</label>
                    <input type="number" id="explorationChance" value="20" min="0" max="100">%
                </div>
                <div>
                    <label>最小利润阈值:</label>
                    <input type="number" id="minProfitThreshold" value="5" min="0" max="50">%
                </div>
                <div>
                    <label>价格监控:</label>
                    <select id="priceMonitoring">
                        <option value="true">启用</option>
                        <option value="false">禁用</option>
                    </select>
                </div>
                <div>
                    <label>库存总金额上限:</label>
                    <input type="number" id="maxInventoryValue" value="${((player.trading.autoTrade.flexibleTrade || {}).maxInventoryValue) || 0}" min="0" placeholder="0=不限制" title="库存总成本超过此值则不再购买">
                </div>
            </div>
            
            <button onclick="saveAutoTradeRoute()" style="background: #4CAF50; padding: 8px 16px;">保存路线</button>
        </div>
        
       <div id="autoTradeRoutes" style="margin-top: 20px;">
            <h4>已保存的路线 ${hasRoutes ? `(${player.trading.autoTrade.routes.length}条)` : ''}</h4>
            ${hasRoutes ? generateAutoTradeRoutes() : `
                <div style="text-align: center; color: #aaa; padding: 20px; background: #2a2a2a; border-radius: 5px;">
                    <p>暂无保存的路线</p>
                    <p style="font-size: 0.9em;">请在下方设置贸易路线</p>
                </div>
            `}
        </div>
        
        <div style="margin-top: 20px; padding: 10px; background: #2a2a2a; border-radius: 5px; border-left: 4px solid #4CAF50;">
            <h4 style="color: #4CAF50; margin-top: 0;">灵活贸易说明</h4>
            <ul style="margin: 0; padding-left: 20px; font-size: 0.9em;">
                <li>系统会在任何城市寻找采购和销售机会</li>
                <li>到达新城市后会同时检查采购和销售机会</li>
                <li>货仓满了或资金不足时会自动前往其他城市</li>
                <li>会根据价格自动决定最佳行动</li>
                <li>会自动探索新城市寻找更好的机会</li>
                <li>可以手动控制前往新城市或停留当前城市</li>
                <li>检测到频繁旅行时会自动重置状态</li>
            </ul>
        </div>
    `;
    
    // 如果自动贸易启用且界面打开，启动进度条更新定时器
    if (player.trading.autoTrade.enabled && !player.trading.autoTrade.backgroundMode) {
        startProgressUpdateTimer();
    }
}

function isFrequentTravelDetected() {
    const recentLogs = player.trading.autoTrade.logs.slice(0, 10);
    const travelLogs = recentLogs.filter(log => log.message.includes("前往") || log.message.includes("旅行"));
    
    // 如果最近10条日志中有5条以上是关于旅行的，认为是频繁旅行
    return travelLogs.length >= 5;
}
function forceCheckOpportunities() {
    if (!player.trading.autoTrade.enabled) {
        logAction("自动贸易未启用", "error");
        return;
    }
    
    addAutoTradeLog("手动触发检查采购和销售机会", "info");
    checkBothPurchaseAndSaleOpportunities();
}


function resetAutoTradeState() {
    addAutoTradeLog("手动重置自动贸易状态", "info");
    
    // 停止所有旅行
    if (player.trading.isTraveling) {
        if (player.trading.travelInterval) {
            clearInterval(player.trading.travelInterval);
            player.trading.travelInterval = null;
        }
        player.trading.isTraveling = false;
        player.trading.travelDestination = '';
    }
    
    // 重置自动贸易状态
    player.trading.autoTrade.currentState = 'monitoring';
    player.trading.autoTrade.currentProgress = 0;
    player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes.length > 0 ? player.trading.autoTrade.routes[0] : null;
    player.trading.autoTrade.currentCityStayStart = tradingNow();
    player.trading.autoTrade.lastUpdate = tradingNow();
    player.trading.autoTrade.nextMonitorTime = tradingNow() + 30000; // 30秒后再开始监控（离线模拟时用模拟时间）
    
    // 清除频繁旅行的检测标志
    if (player.trading.autoTrade.frequentTravelDetection) {
        delete player.trading.autoTrade.frequentTravelDetection;
    }
    
    addAutoTradeLog("自动贸易状态已重置，将在当前城市重新开始监控", "success");
    
    // 更新界面
    updateAutoTradeTab();
    updateMapTab();
}
function forceStayInCurrentCity() {
    addAutoTradeLog("手动设置为停留在当前城市", "info");
    
    // 重置当前城市停留时间
    player.trading.autoTrade.currentCityStayStart = tradingNow();
    
    // 设置较长的停留时间阈值
    player.trading.autoTrade.nextMonitorTime = tradingNow() + 600000; // 10分钟后再检查是否移动（离线模拟时用模拟时间）
    
    // 强制设置为监控状态
    player.trading.autoTrade.currentState = 'monitoring';
    
    addAutoTradeLog("将在当前城市停留至少10分钟，深入寻找机会", "success");
    updateAutoTradeTab();
}


function getFlexibleTradeStateText() {
    if (!player.trading.autoTrade.enabled) return '未启用';
    
    switch (player.trading.autoTrade.currentState) {
        case 'idle': return '空闲';
        case 'buying': return '采购中';
        case 'traveling': return `旅行中 (${getTravelProgress()}%)`;
        case 'selling': return '销售中';
        case 'monitoring': return '监控价格';
        default: return '未知';
    }
}
function getTravelProgress() {
    if (!player.trading.isTraveling) return 0;
    
    const now = Date.now();
    const totalTime = player.trading.travelEndTime - player.trading.travelStartTime;
    const elapsedTime = now - player.trading.travelStartTime;
    const progress = Math.min(100, (elapsedTime / totalTime) * 100);
    
    return progress.toFixed(1);
}
function formatTimeInCity() {
    const now = Date.now();
    const timeInCity = now - player.trading.autoTrade.currentCityStayStart;
    const minutes = Math.floor(timeInCity / (1000 * 60));
    return minutes;
}
function forceMoveToNewCity() {
    if (!player.trading.autoTrade.enabled) {
        logAction("自动贸易未启用", "error");
        return;
    }
    
    if (player.trading.isTraveling) {
        logAction("当前正在旅行中，无法更改目的地", "error");
        return;
    }
    
    addAutoTradeLog("手动触发前往新城市", "info");
    decideNextDestination();
}

function forceForeground() {
    if (player.trading.autoTrade.backgroundMode) {
        exitBackgroundMode();
    }
}
function generateGoodsSelection() {
    const maxGoods = player.trading.autoTrade.purchaseSettings.maxGoods || 50;
    let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">';
    
    Object.keys(tradingConfig.goods).forEach(good => {
        const goodConfig = tradingConfig.goods[good];
        const basePrice = goodConfig.basePrice;
        
        html += `
            <div class="good-selection-item" style="border: 1px solid #444; border-radius: 5px; padding: 10px; background: #2a2a2a;">
                <div style="display: flex; align-items: center; margin-bottom: 8px;">
                    <input type="checkbox" id="good_${good}" value="${good}" onchange="toggleGoodSelection('${good}')">
                    <label for="good_${good}" style="margin-left: 5px; font-weight: bold;">${good}</label>
                </div>
                <div style="font-size: 0.9em; color: #aaa;">
                    <div>类型: ${goodConfig.type}</div>
                    <div>基础价格: ${basePrice.toLocaleString()}</div>
                    <div>占用空间: ${goodConfig.slots}格</div>
                </div>
                <div id="priceInput_${good}" style="display: none; margin-top: 8px;">
                    <label style="font-size: 0.9em;">最大买入价:</label>
                    <input type="number" id="maxPrice_${good}" value="${Math.round(basePrice * 1.2)}" style="width: 100%; padding: 3px; background: #333; color: white; border: 1px solid #555;">
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    html += '<div id="selectedGoodsCount" style="margin-top: 10px; color: #aaa;">已选择 0/' + maxGoods + ' 种商品</div>';
    
    return html;
}

function toggleGoodSelection(good) {
    const checkbox = document.getElementById(`good_${good}`);
    const priceInput = document.getElementById(`priceInput_${good}`);
    
    // 获取最多商品种类限制（优先从输入框读取，否则从设置）
    const maxGoodsInput = document.getElementById('maxGoods');
    const maxGoods = maxGoodsInput ? Math.min(50, Math.max(1, parseInt(maxGoodsInput.value) || 50)) : (player.trading.autoTrade.purchaseSettings.maxGoods || 50);
    
    // 检查已选择的商品数量
    const selectedCount = document.querySelectorAll('#goodsSelection input[type="checkbox"]:checked').length;
    
    if (selectedCount > maxGoods) {
        // 超过限制，取消选择
        checkbox.checked = false;
        priceInput.style.display = 'none';
        updateSelectedGoodsCount();
        logAction(`最多只能选择${maxGoods}种商品`, "error");
        return;
    }
    
    // 显示或隐藏价格输入框
    priceInput.style.display = checkbox.checked ? 'block' : 'none';
    
    // 更新已选择商品计数
    updateSelectedGoodsCount();
}

// 更新已选择商品计数
function updateSelectedGoodsCount() {
    const selectedCount = document.querySelectorAll('#goodsSelection input[type="checkbox"]:checked').length;
    const maxGoodsInput = document.getElementById('maxGoods');
    const maxGoods = maxGoodsInput ? Math.min(50, Math.max(1, parseInt(maxGoodsInput.value) || 50)) : (player.trading.autoTrade.purchaseSettings.maxGoods || 50);
    const countEl = document.getElementById('selectedGoodsCount');
    if (countEl) countEl.textContent = `已选择 ${selectedCount}/${maxGoods} 种商品`;
}
function calculateWarehouseUsage() {
    const totalCapacity = getTradingTotalCapacity();
    if (totalCapacity === 0) return 0;
    
    const usageRate = (player.trading.warehouse.used / totalCapacity) * 100;
    return usageRate.toFixed(1);
}

// 获取自动贸易目标
function getAutoTradeTarget() {
    if (!player.trading.autoTrade.currentRoute) return '-';
    
    switch (player.trading.autoTrade.currentState) {
        case 'buying':
            return player.trading.autoTrade.currentRoute.buyCity ? `在${player.trading.autoTrade.currentRoute.buyCity}采购` : `在${player.trading.currentCity}采购`;
        case 'traveling':
            return `前往${player.trading.travelDestination}`;
        case 'selling':
            return player.trading.autoTrade.currentRoute.sellCity ? `在${player.trading.autoTrade.currentRoute.sellCity}销售` : `在${player.trading.currentCity}销售`;
        default:
            return '等待指令';
    }
}
function savePurchaseStrategy() {
    const maxGoods = parseInt(document.getElementById('maxGoods').value);
    const purchaseStrategy = document.getElementById('purchaseStrategy').value;
    const maxWarehouseUsage = parseInt(document.getElementById('maxWarehouseUsage').value) / 100;
    const priceTolerance = parseInt(document.getElementById('priceTolerance').value) / 100;
    
    player.trading.autoTrade.purchaseSettings.maxGoods = maxGoods;
    player.trading.autoTrade.purchaseSettings.purchaseStrategy = purchaseStrategy;
    player.trading.autoTrade.purchaseSettings.maxWarehouseUsage = maxWarehouseUsage;
    player.trading.autoTrade.purchaseSettings.priceTolerance = priceTolerance;
    
    logAction("采购策略设置已保存", "success");
}


function generateAutoTradeProgressBar() {
    if (!player.trading.autoTrade.enabled) {
        return '<div style="text-align: center; color: #aaa; padding: 10px;">自动贸易未启用</div>';
    }
    
    let progressPercent = 0;
    let statusText = '';
    
    if (player.trading.isTraveling) {
        progressPercent = getTravelProgress();
        statusText = `前往 ${player.trading.travelDestination}`;
    } else {
        switch (player.trading.autoTrade.currentState) {
            case 'buying':
                progressPercent = 50;
                statusText = `在 ${player.trading.currentCity} 采购`;
                break;
            case 'selling':
                progressPercent = 50;
                statusText = `在 ${player.trading.currentCity} 销售`;
                break;
            case 'monitoring':
                progressPercent = 25;
                statusText = `在 ${player.trading.currentCity} 监控价格`;
                break;
            default:
                progressPercent = 0;
                statusText = '等待开始';
        }
    }
    
    return `
        <div class="auto-trade-progress" style="margin-bottom: 15px;">
            <div class="progress-label">
                <span>${statusText}</span>
                <span id="autoTravelPercentage">${progressPercent}%</span>
            </div>
            <div class="progress-bar">
                <div id="autoTravelProgress" class="progress-fill" style="width: ${progressPercent}%;"></div>
            </div>
        </div>
    `;
}
function startProgressUpdateTimer() {
    // 清除现有定时器
    stopProgressUpdateTimer();
    
    // 启动新定时器
    window.autoTradeProgressInterval = registerInterval(() => {
        safeUpdateAutoTradeProgressBar();
    }, 500);
}

// 生成自动贸易进度显示
function generateAutoTradeProgress() {
    if (player.trading.autoTrade.currentState === 'traveling') {
        const progressPercent = Math.min(100, (player.trading.autoTrade.currentProgress / player.trading.autoTrade.totalTravelTime) * 100);
        return `
            <div style="margin-top: 10px;">
                <div style="display: flex; justify-content: space-between;">
                    <span>旅行进度</span>
                    <span>${progressPercent.toFixed(1)}%</span>
                </div>
                <div style="width: 100%; height: 10px; background: #444; border-radius: 5px;">
                    <div style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 5px; transition: width 0.5s;"></div>
                </div>
                <div style="text-align: center; margin-top: 5px; font-size: 0.8em; color: #aaa;">
                    前往 ${player.trading.travelDestination}
                </div>
            </div>
        `;
    }
    
    if (player.trading.autoTrade.currentState === 'buying' || player.trading.autoTrade.currentState === 'selling') {
        const action = player.trading.autoTrade.currentState === 'buying' ? '采购' : '销售';
        const route = player.trading.autoTrade.currentRoute;
        const city = (route && (action === 'buying' ? route.buyCity : route.sellCity)) || player.trading.currentCity || '-';
        const good = (route && route.goods && route.goods[0]) ? route.goods[0].good : (route && route.good) || '商品';
        
        return `
            <div style="text-align: center; margin-top: 10px;">
                <div style="color: #FFD700; font-weight: bold;">${action}中...</div>
                <div style="font-size: 0.9em; color: #aaa;">
                    在${city}${action}${good}
                </div>
            </div>
        `;
    }
    
    return '<div style="text-align: center; color: #aaa; margin-top: 10px;">等待开始...</div>';
}

// 生成自动贸易路线列表
function generateAutoTradeRoutes() {
    if (!player.trading.autoTrade.routes || player.trading.autoTrade.routes.length === 0) {
        return '<div style="text-align: center; color: #aaa; padding: 20px;">暂无保存的路线</div>';
    }
    
    let routesHtml = '';
    player.trading.autoTrade.routes.forEach((route, index) => {
        const isActive = player.trading.autoTrade.currentRoute === route;
        
        routesHtml += `
            <div class="auto-trade-route ${isActive ? 'active' : ''}" style="border: 1px solid #444; border-radius: 5px; padding: 15px; margin-bottom: 10px; background: #2a2a2a;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h5 style="margin: 0; color: #FFD700;">灵活贸易路线 ${index + 1}</h5>
                    <span style="color: ${isActive ? '#4CAF50' : '#aaa'}">${isActive ? '运行中' : '已保存'}</span>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <div style="font-weight: bold; margin-bottom: 5px;">贸易商品:</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 5px;">
                        ${route.goods.map(item => `
                            <div style="background: #333; padding: 5px; border-radius: 3px; font-size: 0.9em;">
                                <div>${item.good}</div>
                                <div style="color: #aaa; font-size: 0.8em;">最大买入: ${item.maxBuyPrice.toLocaleString()}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px;">
                    <div>
                        <div style="font-size: 0.9em; color: #aaa;">最小利润率</div>
                        <div>${route.minProfitMargin}%</div>
                    </div>
                    <div>
                        <div style="font-size: 0.9em; color: #aaa;">单次资金</div>
                        <div>${route.tradeCapital.toLocaleString()}</div>
                    </div>
                    <div>
                        <div style="font-size: 0.9em; color: #aaa;">状态</div>
                        <div>${isActive ? getFlexibleTradeStateText() : '等待中'}</div>
                    </div>
                </div>
                
                <div style="text-align: right;">
                    ${!isActive ? `
                        <button onclick="setActiveRoute(${index})" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">设为活动</button>
                    ` : ''}
                    <button onclick="deleteRoute(${index})" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">删除</button>
                </div>
            </div>
        `;
    });
    
    return routesHtml;
}
// 获取自动贸易状态文本
function getAutoTradeStateText() {
    if (!player.trading.autoTrade.enabled) return '未启用';
    
    switch (player.trading.autoTrade.currentState) {
        case 'idle': return '空闲';
        case 'buying': return '采购中';
        case 'traveling': return '旅行中';
        case 'selling': return '销售中';
        default: return '未知';
    }
}
function validateTradingData() {
    // 验证自动贸易数据
    if (!player.trading.autoTrade) {
        player.trading.autoTrade = {
            enabled: false,
            routes: [],
            efficiency: 0.6,
            currentRoute: null,
            currentState: 'idle',
            currentProgress: 0,
            totalTravelTime: 0,
            lastUpdate: Date.now(),
            logs: [],
            stats: {
                totalProfit: 0,
                totalTrades: 0,
                successfulTrades: 0,
                failedTrades: 0,
                totalTravelTime: 0,
                startTime: Date.now()
            },
            purchaseSettings: {
                maxGoods: 50,
                purchaseStrategy: 'priceDesc',
                minProfitMargin: 10,
                maxWarehouseUsage: 0.8,
                priceTolerance: 0
            },
            backgroundMode: false,
            lastBackgroundUpdate: Date.now(),
            backgroundInterval: null
        };
    }
    
    // 兼容旧存档：flexibleTrade 及 maxInventoryValue、purchaseSettings.maxGoods
    if (!player.trading.autoTrade.flexibleTrade) player.trading.autoTrade.flexibleTrade = {};
    if (player.trading.autoTrade.flexibleTrade.maxInventoryValue === undefined) player.trading.autoTrade.flexibleTrade.maxInventoryValue = 0;
    if (!player.trading.autoTrade.purchaseSettings) player.trading.autoTrade.purchaseSettings = {};
    if (player.trading.autoTrade.purchaseSettings.maxGoods === undefined) player.trading.autoTrade.purchaseSettings.maxGoods = 50;
    
    // 验证路线数据
    if (!Array.isArray(player.trading.autoTrade.routes)) {
        player.trading.autoTrade.routes = [];
    }
    
    // 清理无效路线：支持「固定路线」(buyCity+sellCity) 与「灵活路线」(仅 goods+tradeCapital)
    player.trading.autoTrade.routes = player.trading.autoTrade.routes.filter(route => {
        if (!route || !Array.isArray(route.goods) || route.goods.length === 0) return false;
        if (route.buyCity && route.sellCity) return true;  // 固定路线
        return (route.tradeCapital != null && route.tradeCapital > 0) || true; // 灵活路线：有商品即可
    });
    
    // 验证当前路线
    if (player.trading.autoTrade.currentRoute && 
        !player.trading.autoTrade.routes.includes(player.trading.autoTrade.currentRoute)) {
        player.trading.autoTrade.currentRoute = null;
    }
    
    // 验证日志
    if (!Array.isArray(player.trading.autoTrade.logs)) {
        player.trading.autoTrade.logs = [];
    }
}

// 设置活动路线
function setActiveRoute(index) {
    if (!player.trading.autoTrade.routes || index >= player.trading.autoTrade.routes.length) {
        logAction("无效的路线索引", "error");
        return;
    }
    
    player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[index];
    player.trading.autoTrade.currentState = 'idle';
    logAction(`已设置活动路线：灵活贸易路线${index + 1}`, "success");
    updateAutoTradeTab();
}

// 删除路线
function deleteRoute(index) {
    if (!player.trading.autoTrade.routes || index >= player.trading.autoTrade.routes.length) {
        logAction("无效的路线索引", "error");
        return;
    }
    
    const route = player.trading.autoTrade.routes[index];
    
    showCustomConfirm(`确定要删除灵活贸易路线${index + 1}吗？`, (confirmed) => {
        if (confirmed) {
            player.trading.autoTrade.routes.splice(index, 1);
            
            // 如果删除的是当前活动路线，重置状态
            if (player.trading.autoTrade.currentRoute === route) {
                player.trading.autoTrade.currentRoute = null;
                player.trading.autoTrade.currentState = 'idle';
                
                // 如果自动贸易已启用，停用它
                if (player.trading.autoTrade.enabled) {
                    player.trading.autoTrade.enabled = false;
                    stopAutoTradeSystem();
                    stopProgressUpdateTimer();
                    logAction("活动路线已删除，自动贸易已停用", "info");
                }
            }
            
            logAction("贸易路线已删除", "success");
            updateAutoTradeTab();
        }
    });
}

// 暂停自动贸易
function pauseAutoTrade() {
    player.trading.autoTrade.enabled = false;
    
    // 停止进度条更新定时器
    if (window.autoTradeProgressInterval) {
        clearInterval(window.autoTradeProgressInterval);
        window.autoTradeProgressInterval = null;
    }
    
    logAction("自动贸易已暂停", "info");
    
    // 更新自动贸易界面
    updateAutoTradeTab();
    
    // 如果世界地图界面打开，也更新它
    if (document.getElementById('mapTab').style.display !== 'none') {
        updateMapTab();
    }
}

function stopAutoTrade() {
    player.trading.autoTrade.enabled = false;
    player.trading.autoTrade.currentState = 'idle';
    player.trading.autoTrade.currentRoute = null;
    player.trading.autoTrade.currentProgress = 0;
    
    // 停止进度条更新定时器
    if (window.autoTradeProgressInterval) {
        clearInterval(window.autoTradeProgressInterval);
        window.autoTradeProgressInterval = null;
    }
    
    logAction("自动贸易已停止", "info");
    
    // 更新自动贸易界面
    updateAutoTradeTab();
    
    // 如果世界地图界面打开，也更新它
    if (document.getElementById('mapTab').style.display !== 'none') {
        updateMapTab();
    }
}


// 显示自动贸易日志
function showAutoTradeLog() {
    createAutoTradeLogModal();
    updateAutoTradeLogDisplay();
    updateAutoTradeStats();
    
    document.getElementById('autoTradeLogModal').style.display = 'block';
    document.getElementById('autoTradeLogOverlay').style.display = 'block';
}
// 关闭自动贸易日志
function closeAutoTradeLog() {
    document.getElementById('autoTradeLogModal').style.display = 'none';
    document.getElementById('autoTradeLogOverlay').style.display = 'none';
}

// 更新自动贸易日志显示
function updateAutoTradeLogDisplay() {
    const container = document.getElementById('autoTradeLogContainer');
    const searchTerm = document.getElementById('logSearch')?.value || '';
    const filterType = document.getElementById('logFilter')?.value || 'all';
    
    let filteredLogs = player.trading.autoTrade.logs;
    
    // 应用筛选
    if (filterType !== 'all') {
        filteredLogs = filteredLogs.filter(log => log.type === filterType);
    }
    
    // 应用搜索
    if (searchTerm) {
        filteredLogs = filteredLogs.filter(log => 
            log.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
            log.timestamp.includes(searchTerm) ||
            log.city.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }
    
    container.innerHTML = '';
    
    if (filteredLogs.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">暂无日志记录</div>';
        return;
    }
    
    filteredLogs.forEach(log => {
        const logElement = document.createElement('div');
        logElement.className = 'log-entry';
        logElement.style.cssText = `
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            border-left: 4px solid ${getLogColor(log.type)};
            background: #2a2a2a;
            font-size: 0.9em;
        `;
        
        logElement.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #aaa;">[${log.timestamp}] ${log.city}</span>
                <span style="color: ${getLogColor(log.type)}; font-weight: bold;">${getLogTypeText(log.type)}</span>
            </div>
            <div style="margin-top: 5px;">${log.message}</div>
            <div style="margin-top: 5px; font-size: 0.8em; color: #666;">
                资金: ${log.funds.toLocaleString()} | 货仓: ${log.warehouseUsage}% | 状态: ${log.state}
                ${log.purchaseOpportunities > 0 ? `| 采购: ${log.purchaseOpportunities}` : ''}
                ${log.saleOpportunities > 0 ? `| 销售: ${log.saleOpportunities}` : ''}
            </div>
        `;
        
        container.appendChild(logElement);
    });
}

// 获取日志颜色
function getLogColor(type) {
    switch (type) {
        case 'success': return '#4CAF50';
        case 'warning': return '#FF9800';
        case 'error': return '#f44336';
        default: return '#2196F3';
    }
}

// 获取日志类型文本
function getLogTypeText(type) {
    switch (type) {
        case 'success': return '成功';
        case 'warning': return '警告';
        case 'error': return '错误';
        default: return '信息';
    }
}
// 更新自动贸易统计信息
function updateAutoTradeStats() {
    const statsContainer = document.getElementById('autoTradeStats');
    const stats = player.trading.autoTrade.stats;
    
    // 计算运行时间
    const runTime = Date.now() - stats.startTime;
    const hours = Math.floor(runTime / (1000 * 60 * 60));
    const minutes = Math.floor((runTime % (1000 * 60 * 60)) / (1000 * 60));
    
    // 计算成功率
    const successRate = stats.totalTrades > 0 ? 
        (stats.successfulTrades / stats.totalTrades * 100).toFixed(1) : 0;
    
    statsContainer.innerHTML = `
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">总利润</div>
            <div style="font-size: 1.2em; font-weight: bold; color: ${stats.totalProfit >= 0 ? '#4CAF50' : '#f44336'}">
                ${stats.totalProfit >= 0 ? '+' : ''}${stats.totalProfit.toLocaleString()}
            </div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">交易次数</div>
            <div style="font-size: 1.2em; font-weight: bold;">${stats.totalTrades}</div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">成功率</div>
            <div style="font-size: 1.2em; font-weight: bold;">${successRate}%</div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">运行时间</div>
            <div style="font-size: 1.2em; font-weight: bold;">${hours}h ${minutes}m</div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">当前状态</div>
            <div style="font-size: 1.2em; font-weight: bold;">${getAutoTradeStateText()}</div>
        </div>
        <div style="text-align: center; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 0.9em; color: #aaa;">贸易效率</div>
            <div style="font-size: 1.2em; font-weight: bold;">${(player.trading.autoTrade.efficiency * 100).toFixed(0)}%</div>
        </div>
    `;
}

// 清空自动贸易日志
function clearAutoTradeLogs() {
    showCustomConfirm("确定要清空所有自动贸易日志吗？此操作不可撤销。", (confirmed) => {
        if (confirmed) {
            player.trading.autoTrade.logs = [];
            updateAutoTradeLogDisplay();
            addAutoTradeLog("日志已清空", "info");
        }
    });
}


function updateAutoTradeStatus() {
    const state = player.trading.autoTrade.currentState;
    let stateText = '';
    let progressHtml = '';
    
    switch (state) {
        case 'idle':
            stateText = '空闲';
            break;
        case 'buying':
            stateText = `在${player.trading.autoTrade.currentRoute?.buyCity || '-'}采购`;
            break;
        case 'traveling':
            const progressPercent = (player.trading.autoTrade.currentProgress / player.trading.autoTrade.totalTravelTime) * 100;
            stateText = `前往${player.trading.travelDestination}`;
            progressHtml = `
                <div style="margin-top: 10px;">
                    <div style="display: flex; justify-content: space-between;">
                        <span>旅行进度</span>
                        <span id="autoTravelPercentage">${progressPercent.toFixed(1)}%</span>
                    </div>
                    <div style="width: 100%; height: 10px; background: #444; border-radius: 5px;">
                        <div id="autoTravelProgress" style="height: 100%; width: ${progressPercent}%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 5px;"></div>
                    </div>
                </div>
            `;
            break;
        case 'selling':
            stateText = `在${player.trading.autoTrade.currentRoute?.sellCity || '-'}销售`;
            break;
    }
    
    document.getElementById('autoTradeState').textContent = stateText;
    document.getElementById('autoTradeProgress').innerHTML = progressHtml;
    document.getElementById('autoTradeEfficiency').textContent = `${(player.trading.autoTrade.efficiency * 100).toFixed(0)}%`;
    
    // 今日利润可能是负数（如果买入多于卖出），但我们只显示净收入
    const todayProfit = player.trading.tradeVolumeToday;
    document.getElementById('todayProfit').textContent = 
        `${todayProfit >= 0 ? '+' : ''}${todayProfit.toLocaleString()}星币`;
}

// 更新经营管理标签页
function updateManagementTab() {
    if (!player || !player.trading) return;
    if (!player.trading.insurance) player.trading.insurance = { goods: false, transport: false, bundle: false };
    if (player.trading.insurance.bundle === undefined) player.trading.insurance.bundle = false;
    if (!player.trading.riskAppetite) player.trading.riskAppetite = 'balanced';
    if (typeof ensureGuildQuests === 'function') ensureGuildQuests();
    // 商人声望与等级
    const rep = player.trading.reputation != null ? player.trading.reputation : 0;
    const ml = player.trading.merchantLevel != null ? player.trading.merchantLevel : 1;
    const repEl = document.getElementById('merchantReputation');
    const mlEl = document.getElementById('merchantLevel');
    const mlDescEl = document.getElementById('merchantLevelDesc');
    if (repEl) repEl.textContent = rep;
    if (mlEl) mlEl.textContent = ml;
    if (mlDescEl) mlDescEl.textContent = 'L2+卖价+2%/级 · L3+情报折扣 · L4+被劫减免 · L5/10/15/20货仓+5/10/15/20格';
    // 商会任务（5个）+ 刷新倒计时
    const gqBlock = document.getElementById('guildQuestsBlock');
    if (gqBlock && player.trading.guildQuests) {
        var countdownHtml = '<div id="guildQuestCountdown" style="margin-bottom:8px; font-size:13px;"></div>';
        if (player.trading.guildQuests.list && player.trading.guildQuests.list.length > 0) {
            const list = player.trading.guildQuests.list;
            let html = countdownHtml;
            for (let i = 0; i < list.length; i++) {
                const q = list[i];
                if (q.type === 'deliver') html += `<div style="margin:6px 0; padding:6px; background:#2a2a2a; border-radius:4px;">运送：带 ${q.amount} 件【${q.good}】到达 ${q.toCity} · 奖励 ${q.reward} 星币</div>`;
                else if (q.type === 'profit') html += `<div style="margin:6px 0; padding:6px; background:#2a2a2a; border-radius:4px;">当日利润：达到 ${q.target.toLocaleString()} · 进度 ${Math.floor(player.trading.profitToday || 0).toLocaleString()}/${q.target.toLocaleString()} · 奖励 ${q.reward} 星币</div>`;
                else if (q.type === 'visit') html += `<div style="margin:6px 0; padding:6px; background:#2a2a2a; border-radius:4px;">旅游：抵达 ${q.toCity} 即完成 · 奖励 ${q.reward} 星币</div>`;
                else if (q.type === 'tour') html += `<div style="margin:6px 0; padding:6px; background:#2a2a2a; border-radius:4px;">跑图：路过 ${q.targetCount} 座不同城市 · 进度 ${q.progress || 0}/${q.targetCount} · 奖励 ${q.reward} 星币</div>`;
                else if (q.type === 'buyAtCity') html += `<div style="margin:6px 0; padding:6px; background:#2a2a2a; border-radius:4px;">代购：在【${q.city}】购买 ${q.amount} 件【${q.good}】 · 进度 ${q.progress || 0}/${q.amount} · 奖励 ${q.reward} 星币</div>`;
            }
            gqBlock.innerHTML = html;
        } else {
            gqBlock.innerHTML = countdownHtml + '<div style="color:#888;">任务已全部完成，下次进入本页或 24 小时后将刷新 5 个新任务</div>';
        }
        updateGuildQuestCountdownOnly();
    }
    // 货仓信息
    const currentLevel = player.trading.warehouse.level;
    const nextLevel = Math.min(currentLevel + 1, tradingConfig.warehouseLevels.length);
    const nextLevelConfig = tradingConfig.warehouseLevels[nextLevel - 1];
    
    document.getElementById('warehouseLevel').textContent = currentLevel;
    document.getElementById('currentCapacity').textContent = getTradingTotalCapacity();
    document.getElementById('upgradeCosta').textContent = nextLevelConfig.cost.toLocaleString();
    
    // 运输工具
    const transportList = document.getElementById('transportList');
    transportList.innerHTML = '';
    
    if (!player.trading.ownedTransports) player.trading.ownedTransports = ['手推车'];
    tradingConfig.transports.forEach(transport => {
        const canBuy = player.nightClub.starCoins >= transport.cost;
        const isOwned = player.trading.ownedTransports.indexOf(transport.name) >= 0;
        const isCurrent = player.trading.transport.type === transport.name;
        
        const transportElement = document.createElement('div');
        let actionHtml;
        if (isOwned) {
            if (isCurrent) {
                actionHtml = '<span style="color: #4CAF50;">使用中</span>';
            } else {
                actionHtml = `<button onclick="switchTransport('${transport.name}')">切换使用</button>`;
            }
        } else {
            actionHtml = `<button onclick="buyTransport('${transport.name}')" ${!canBuy ? 'disabled' : ''}>购买</button>`;
        }
        transportElement.innerHTML = `
            <div style="border: 1px solid #444; padding: 10px; margin: 5px 0;">
                <strong>${transport.name}</strong><br>
                容量: +${transport.capacityBonus}格<br>
                速度: +${transport.speedBonus}%<br>
                价格: ${transport.cost.toLocaleString()}星币<br>
                ${actionHtml}
            </div>
        `;
        transportList.appendChild(transportElement);
    });
    
    // 雇员管理：从配置生成全部可雇类型，已雇佣的显示效果
    const employeeList = document.getElementById('employeeList');
    if (!employeeList) return;
    employeeList.innerHTML = '';
    const cap = (player.trading.warehouse && player.trading.warehouse.capacity) ? player.trading.warehouse.capacity : 20;
    const hasRobbery = !!player.trading.hasExperiencedRobbery;
    var empList = player.trading.employees;
    if (!Array.isArray(empList)) player.trading.employees = empList = [];
    if (tradingConfig.employees && tradingConfig.employees.length) {
        tradingConfig.employees.forEach(empCfg => {
            const hired = empList.find(e => e.type === empCfg.type);
            let reqText = '';
            if (empCfg.requirement === 'warehouse30') reqText = '货仓30格';
            else if (empCfg.requirement === 'warehouse40') reqText = '货仓40格';
            else if (empCfg.requirement === 'warehouse50') reqText = '货仓50格';
            else if (empCfg.requirement === 'reputation3') reqText = '商人Lv.3';
            else if (empCfg.requirement === 'reputation5') reqText = '商人Lv.5';
            else if (empCfg.requirement === 'experiencedRobbery') reqText = '曾遇劫';
            let canHire = !hired && (player.nightClub && player.nightClub.starCoins >= empCfg.cost);
            if (empCfg.requirement === 'warehouse30' && cap < 30) canHire = false;
            if (empCfg.requirement === 'warehouse40' && cap < 40) canHire = false;
            if (empCfg.requirement === 'warehouse50' && cap < 50) canHire = false;
            if (empCfg.requirement === 'reputation3' && ml < 3) canHire = false;
            if (empCfg.requirement === 'reputation5' && ml < 5) canHire = false;
            if (empCfg.requirement === 'experiencedRobbery' && !hasRobbery) canHire = false;
            const btn = hired ? '<span style="color:#4CAF50;">已雇佣</span>' : ('<button onclick="hireEmployee(\'' + empCfg.type + '\')" ' + (!canHire ? 'disabled' : '') + ' style="padding:4px 10px;">雇佣</button>');
            employeeList.innerHTML += '<div style="border:1px solid #444; padding:8px; margin:5px 0; font-size:0.9em;"><strong>' + empCfg.type + '</strong> ' + (empCfg.desc || '') + '<br>费用' + empCfg.cost.toLocaleString() + ' 工资' + empCfg.salary + '/天 条件:' + reqText + ' ' + btn + '</div>';
        });
    }
    
    // 保险状态
    if (!player.trading.insurance.bundle) {
        document.getElementById('goodsInsurance').checked = player.trading.insurance.goods;
        document.getElementById('transportInsurance').checked = player.trading.insurance.transport;
    } else {
        document.getElementById('goodsInsurance').checked = true;
        document.getElementById('transportInsurance').checked = true;
    }
    var bundleEl = document.getElementById('bundleInsurance');
    if (bundleEl) bundleEl.checked = !!player.trading.insurance.bundle;
    var riskEl = document.getElementById('riskAppetite');
    if (riskEl) riskEl.value = player.trading.riskAppetite || 'balanced';
}

// 趣味玩法标签页
function updateFunTab() {
    var bmBlock = document.getElementById('blackMarketBlock');
    var rumorBlock = document.getElementById('rumorBlock');
    var dailyBlock = document.getElementById('dailyLuckyBlock');
    if (!bmBlock || !rumorBlock || !dailyBlock) return;
    var bm = player.trading.blackMarket || {};
    var rumor = player.trading.rumor || {};
    var daily = player.trading.dailyLucky || {};
    var now = Date.now();
    if (bm.available && bm.endTime <= now) {
        player.trading.blackMarket = { available: false, endTime: 0, city: '' };
        bm = player.trading.blackMarket;
    }
    if (rumor.effectEndTime && rumor.effectEndTime <= now) {
        player.trading.rumor = { text: '', good: '', city: '', effectEndTime: 0 };
        rumor = player.trading.rumor;
    }
    var todayStr = new Date().toDateString();
    if (daily.lastDate && daily.lastDate !== todayStr) {
        player.trading.dailyLucky = { lastDate: todayStr, used: false, buff: null };
        daily = player.trading.dailyLucky;
    }

    if (bm.available && bm.city === player.trading.currentCity) {
        var goods = Object.keys(tradingConfig.goods);
        if (!bm.goods || !Array.isArray(bm.goods) || bm.goods.length === 0) {
            var pick = [];
            while (pick.length < 3) {
                var g = goods[Math.floor(Math.random() * goods.length)];
                if (pick.indexOf(g) === -1) pick.push(g);
            }
            player.trading.blackMarket.goods = pick;
        }
        var pick = player.trading.blackMarket.goods;
        var listHtml = '<p style="color:#aaa; font-size:0.9em;">黑市买入价约市价70%，卖出价约150%，每次交易10%概率被查罚款</p>';
        pick.forEach(function(g) {
            var mkt = player.trading.cityPrices[player.trading.currentCity][g] || tradingConfig.goods[g].basePrice;
            var buyP = Math.floor(mkt * 0.7);
            var sellP = Math.floor(mkt * 1.5);
            listHtml += '<div style="margin:8px 0; padding:8px; background:#333; border-radius:4px;">' +
                '<strong>' + g + '</strong> 买:' + buyP.toLocaleString() + ' 卖:' + sellP.toLocaleString() + ' ' +
                '<button onclick="blackMarketBuy(\'' + g + '\', 1)" style="margin-left:6px;">买1</button>' +
                '<button onclick="blackMarketSell(\'' + g + '\', 1)">卖1</button></div>';
        });
        listHtml += '<p style="color:#888; font-size:0.85em;">剩余' + Math.max(0, Math.ceil((bm.endTime - now) / 60000)) + '分钟</p>';
        bmBlock.innerHTML = listHtml;
    } else {
        bmBlock.innerHTML = '<p style="color:#888;">当前无黑市入口。旅行到达某城市时有机遇事件「发现黑市入口」可开启。</p>';
    }

    if (rumor.text) {
        var remain = rumor.effectEndTime ? Math.max(0, Math.ceil((rumor.effectEndTime - now) / 60000)) : 0;
        rumorBlock.innerHTML = '<p style="color:#FF9800;">' + rumor.text + '</p><p style="color:#888; font-size:0.85em;">效果剩余约' + remain + '分钟</p>';
    } else {
        rumorBlock.innerHTML = '<p style="color:#888;">暂无传闻。机遇事件「打听到小道消息」可获得某城某商品涨价提示。</p>';
    }

    if (!daily.lastDate) player.trading.dailyLucky = { lastDate: todayStr, used: false, buff: null };
    daily = player.trading.dailyLucky;
    if (daily.used && daily.buff) {
        dailyBlock.innerHTML = '<p style="color:#4CAF50;">今日已领取：' + (daily.buff.name || daily.buff) + '</p>';
    } else {
        dailyBlock.innerHTML = '<p style="color:#aaa;">每日可领取一次随机幸运加成。</p><button onclick="doDailyLucky()" style="padding:8px 16px; background:#4CAF50; color:white; border:none; border-radius:4px; cursor:pointer;">领取今日幸运</button>';
    }
}

function blackMarketBuy(good, quantity) {
    if (!player.trading.blackMarket || !player.trading.blackMarket.available || player.trading.blackMarket.city !== player.trading.currentCity) return;
    var price = Math.floor((player.trading.cityPrices[player.trading.currentCity][good] || tradingConfig.goods[good].basePrice) * 0.7) * quantity;
    var slots = (tradingConfig.goods[good].slots || 1) * quantity;
    if (player.nightClub.starCoins < price) { logAction('星币不足', 'error'); return; }
    if (player.trading.warehouse.used + slots > getTradingTotalCapacity()) { logAction('货仓不足', 'error'); return; }
    if (Math.random() < 0.1) {
        var fine = Math.floor(player.nightClub.starCoins * 0.05);
        if (fine > 0) { player.nightClub.starCoins -= fine; logAction('黑市被查！罚款' + fine + '星币', 'event'); }
    }
    player.nightClub.starCoins -= price;
    var item = player.trading.inventory[good];
    if (item) { item.quantity += quantity; item.totalCost += price; item.averageCost = item.totalCost / item.quantity; }
    else player.trading.inventory[good] = { quantity: quantity, averageCost: price / quantity, totalCost: price };
    player.trading.warehouse.used += slots;
    logAction('黑市购入' + quantity + '件' + good, 'success');
    updateTradingUI(); updateFunTab();
}

function blackMarketSell(good, quantity) {
    if (!player.trading.blackMarket || !player.trading.blackMarket.available || player.trading.blackMarket.city !== player.trading.currentCity) return;
    var item = player.trading.inventory[good];
    if (!item || (typeof item === 'object' ? item.quantity : 0) < quantity) { logAction('库存不足', 'error'); return; }
    var price = Math.floor((player.trading.cityPrices[player.trading.currentCity][good] || tradingConfig.goods[good].basePrice) * 1.5) * quantity;
    if (Math.random() < 0.1) {
        var fine = Math.floor(price * 0.2);
        if (fine > 0) { price -= fine; logAction('黑市被查！收益扣减' + fine + '星币', 'event'); }
    }
    player.nightClub.starCoins += price;
    item.quantity -= quantity;
    if (item.quantity <= 0) { delete player.trading.inventory[good]; player.trading.warehouse.used -= (tradingConfig.goods[good].slots || 1) * quantity; }
    else { item.totalCost = item.averageCost * item.quantity; player.trading.warehouse.used -= (tradingConfig.goods[good].slots || 1) * quantity; }
    syncWarehouseUsedFromInventory();
    logAction('黑市售出' + quantity + '件' + good + '，获得' + price + '星币', 'success');
    updateTradingUI(); updateFunTab();
}

function doDailyLucky() {
    var daily = player.trading.dailyLucky || {};
    var todayStr = new Date().toDateString();
    if (daily.lastDate !== todayStr) player.trading.dailyLucky = { lastDate: todayStr, used: false, buff: null };
    daily = player.trading.dailyLucky;
    if (daily.used) { logAction('今日已领取过幸运', 'info'); return; }
    var buffs = [
        { name: '今日卖价+5%', key: 'dailySellBonus', value: 1.05, endTime: Date.now() + 24 * 60 * 60 * 1000 },
        { name: '下次购买+1件', key: 'luckyMerchantNextBuy', value: true },
        { name: '下次旅行时间-15%', key: 'travelTimeReduction', value: 0.15, endKey: 'travelTimeReductionEnd', endValue: Date.now() + 12 * 60 * 60 * 1000 },
        { name: '获得5000星币', key: 'starCoinsBonus', value: 5000 },
        { name: '商人声望+3', key: 'reputationBonus', value: 3 }
    ];
    var b = buffs[Math.floor(Math.random() * buffs.length)];
    if (b.key === 'starCoinsBonus') { player.nightClub.starCoins += b.value; }
    else if (b.key === 'reputationBonus') { player.trading.reputation = (player.trading.reputation || 0) + b.value; if (typeof updateMerchantLevelFromReputation === 'function') updateMerchantLevelFromReputation(); }
    else if (b.key === 'luckyMerchantNextBuy') { player.trading.luckyMerchantNextBuy = true; }
    else if (b.key === 'travelTimeReduction') { player.trading.travelTimeReduction = b.value; player.trading.travelTimeReductionEnd = b.endValue; }
    else if (b.key === 'dailySellBonus') { player.trading.dailySellBonus = b.value; player.trading.dailySellBonusEnd = b.endTime; }
    player.trading.dailyLucky.used = true;
    player.trading.dailyLucky.buff = b;
    logAction('今日幸运：' + b.name, 'success');
    updateFunTab(); updateTradingUI();
}

// 切换标签页
function switchTradingTab(tabName) {
    // 隐藏所有标签页
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // 移除所有标签按钮的激活状态
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // 显示选中的标签页
    document.getElementById(tabName + 'Tab').classList.add('active');
    
    // 激活对应的标签按钮
    if (event && event.target) event.target.classList.add('active');
    
    // 切换到世界地图时强制刷新地图，避免重启后仍显示静态旧城市列表
    if (tabName === 'map') updateMapTab();
    // 切换到经营管理时刷新声望、等级、商会任务，并启动刷新倒计时
    if (tabName === 'management') {
        updateManagementTab();
        if (window._guildQuestCountdownTimer) clearInterval(window._guildQuestCountdownTimer);
        window._guildQuestCountdownTimer = setInterval(updateGuildQuestCountdownOnly, 1000);
    } else {
        if (window._guildQuestCountdownTimer) { clearInterval(window._guildQuestCountdownTimer); window._guildQuestCountdownTimer = null; }
    }
    if (tabName === 'fun') updateFunTab();
}

// 获取商品的实际买入价（含关税加成等）
function getActualBuyPrice(city, good) {
    let price = player.trading.cityPrices && player.trading.cityPrices[city] && player.trading.cityPrices[city][good];
    if (price == null || !Number.isFinite(price)) return price;
    if (player.trading.tariffBonus && player.trading.tariffBonus.city === city && Date.now() <= player.trading.tariffBonus.endTime && player.trading.tariffBonus.buyMultiplier)
        price = Math.ceil(price * player.trading.tariffBonus.buyMultiplier);
    return price;
}

// 购买商品
function buyGood(good, quantity) {
    // 确保商品名称有效
    if (!good || typeof good !== 'string') {
        addAutoTradeLog("无法购买无效的商品", "error");
        return;
    }
    
    const city = player.trading.currentCity;
    const price = getActualBuyPrice(city, good);
    const totalCost = price * quantity;
    const goodConfig = tradingConfig.goods[good];
    const slotsNeeded = goodConfig.slots * quantity;
    
    // 检查资金
    if (player.nightClub.starCoins < totalCost) {
        logAction(`星币不足！需要${totalCost.toLocaleString()}星币`, "error");
        return;
    }
    
    // 检查货仓空间
    const availableSlots = getTradingTotalCapacity() - player.trading.warehouse.used;
    if (slotsNeeded > availableSlots) {
        logAction(`货仓空间不足！需要${slotsNeeded}格，可用${availableSlots}格`, "error");
        return;
    }
    
    // 执行购买
    player.nightClub.starCoins -= totalCost;
    
    // 更新库存（计算平均成本）
    if (!player.trading.inventory[good]) {
        // 第一次购买此商品
        player.trading.inventory[good] = {
            quantity: quantity,
            averageCost: price,
            totalCost: totalCost,
            lastBuyPrice: price
        };
    } else {
        // 已有库存，计算新的平均成本
        const current = player.trading.inventory[good];
        const newTotalCost = current.totalCost + totalCost;
        const newQuantity = current.quantity + quantity;
        const newAverageCost = newTotalCost / newQuantity;
        
        player.trading.inventory[good] = {
            quantity: newQuantity,
            averageCost: newAverageCost,
            totalCost: newTotalCost,
            lastBuyPrice: price
        };
    }
    
    player.trading.warehouse.used += slotsNeeded;
    
    if (player.trading.luckyMerchantNextBuy) {
        player.trading.inventory[good].quantity += 1;
        player.trading.warehouse.used += goodConfig.slots;
        player.trading.luckyMerchantNextBuy = false;
        logAction('幸运商人！额外获得1个' + good, "success");
    }
    
    if (typeof checkGuildQuestProgress === 'function') checkGuildQuestProgress('buy', good, quantity, totalCost, city);
    
    // 记录交易
    recordTrade('buy', good, quantity, price, totalCost);
    
    logAction(`购买了${quantity}个${good}，花费${totalCost.toLocaleString()}星币`, "success");
    updateTradingUI();
    updateDisplay();
}

// 出售商品
function sellGood(good, quantity) {
    const city = player.trading.currentCity;
    const price = player.trading.cityPrices[city][good];
    const totalRevenue = price * quantity;
    const goodConfig = tradingConfig.goods[good];
    
    // 检查库存
    if (!player.trading.inventory[good] || player.trading.inventory[good].quantity < quantity) {
        logAction(`库存不足！只有${player.trading.inventory[good] ? player.trading.inventory[good].quantity : 0}个${good}`, "error");
        return;
    }
    
    const inventoryItem = player.trading.inventory[good];
    const costOfGoodsSold = inventoryItem.averageCost * quantity;
    const fullProfit = totalRevenue - costOfGoodsSold;
    // 短途跑商：只对「利润」打折，成本必收回，不会亏本；旅行不足15分钟则利润按比例打折
    const lastTravelMin = (player.trading && typeof player.trading.lastTravelTimeMinutes === 'number') ? player.trading.lastTravelTimeMinutes : 999;
    const fullRevenueMinutes = 15;
    const profitMultiplier = Math.min(1, lastTravelMin / fullRevenueMinutes);
    const actualProfit = Math.floor(fullProfit * profitMultiplier);
    let actualRevenue = costOfGoodsSold + actualProfit;
    const profit = actualProfit;
    const profitRate = costOfGoodsSold > 0 ? (profit / costOfGoodsSold) * 100 : 0;
    
    if (player.trading.merchantLevel > 1) {
        actualRevenue = Math.floor(actualRevenue * (1 + (player.trading.merchantLevel - 1) * 0.02));
    }
    if (player.trading.eventBonus && player.trading.eventBonus.city === city && Date.now() <= player.trading.eventBonus.endTime && player.trading.eventBonus.sellMultiplier) {
        actualRevenue = Math.floor(actualRevenue * player.trading.eventBonus.sellMultiplier);
        if (typeof logAction === 'function') logAction('节日促销！出售收益+' + Math.round((player.trading.eventBonus.sellMultiplier - 1) * 100) + '%', 'success');
    }
    if (player.trading.dailySellBonus && player.trading.dailySellBonusEnd && Date.now() <= player.trading.dailySellBonusEnd) {
        actualRevenue = Math.floor(actualRevenue * player.trading.dailySellBonus);
    }
    var empSellBonus = (typeof getEmployeeSellBonus === 'function') ? getEmployeeSellBonus() : 0;
    if (empSellBonus > 0) actualRevenue = Math.floor(actualRevenue * (1 + empSellBonus / 100));
    if (player.trading.riskAppetite === 'aggressive') actualRevenue = Math.floor(actualRevenue * 1.05);
    if (profit > 0 && player.trading.reputation != null) {
        player.trading.reputation = (player.trading.reputation || 0) + Math.max(1, Math.floor(profit / 400));
        if (typeof updateMerchantLevelFromReputation === 'function') updateMerchantLevelFromReputation();
    }
    if (typeof addDailyProfit === 'function') addDailyProfit(profit);
    
    // 执行出售（成本全收，利润按旅行时长折算，保证不亏本）
    player.nightClub.starCoins += actualRevenue;
    
    // 更新库存
    if (inventoryItem.quantity === quantity) {
        // 全部售出
        delete player.trading.inventory[good];
    } else {
        // 部分售出（平均成本不变，因为采用加权平均法）
        inventoryItem.quantity -= quantity;
        inventoryItem.totalCost -= costOfGoodsSold;
        // 平均成本保持不变，因为我们采用先进先出或加权平均
    }
    
    player.trading.warehouse.used -= goodConfig.slots * quantity;
    
    if (typeof checkGuildQuestProgress === 'function') checkGuildQuestProgress('sell', good, quantity, actualRevenue, city);
    
    // 记录交易（按实际收入记录）
    recordTrade('sell', good, quantity, price, actualRevenue);
    
    // 更新自动贸易总利润（灵活贸易路径依赖此处，否则离线收益始终为0）
    if (player.trading.autoTrade && player.trading.autoTrade.stats) {
        if (player.trading.autoTrade.stats.totalProfit == null) player.trading.autoTrade.stats.totalProfit = 0;
        player.trading.autoTrade.stats.totalProfit += profit;
    }
    
    // 显示盈亏信息（若短途打折则提示，成本必收不会亏本）
    const profitSign = profit >= 0 ? '+' : '';
    const shortTripHint = profitMultiplier < 1 ? `（短途利润${(profitMultiplier * 100).toFixed(0)}%）` : '';
    logAction(`出售了${quantity}个${good}，获得${actualRevenue.toLocaleString()}星币${shortTripHint}（${profitSign}${profit.toFixed(0)}星币，${profitSign}${profitRate.toFixed(1)}%）`, "success");
    
    updateTradingUI();
    updateDisplay();
}

// 记录交易
function recordTrade(type, good, quantity, price, amount) {
    const trade = {
        type: type,
        good: good,
        quantity: quantity,
        price: price,
        amount: amount,
        city: player.trading.currentCity,
        timestamp: Date.now()
    };
    
    player.trading.tradeHistory.unshift(trade);
    
    // 买入是支出（减少利润），卖出是收入（增加利润）
    if (type === 'buy') {
        player.trading.tradeVolumeToday -= amount; // 买入减少利润
    } else if (type === 'sell') {
        player.trading.tradeVolumeToday += amount; // 卖出增加利润
    }
    
    player.trading.tradeCountToday++;
    
    // 限制交易记录数量
    if (player.trading.tradeHistory.length > 100) {
        player.trading.tradeHistory.pop();
    }
}

// 根据声望更新商人等级（1–20），声望阈值较高
var MERCHANT_LEVEL_REPUTATION = [0, 500, 1500, 3000, 6000, 10000, 16000, 24000, 34000, 46000, 60000, 76000, 94000, 115000, 140000, 168000, 200000, 236000, 276000, 320000];
function updateMerchantLevelFromReputation() {
    if (!player.trading || player.trading.reputation == null) return;
    const r = player.trading.reputation;
    let level = 1;
    for (let i = MERCHANT_LEVEL_REPUTATION.length - 1; i >= 1; i--) {
        if (r >= MERCHANT_LEVEL_REPUTATION[i]) { level = i; break; }
    }
    player.trading.merchantLevel = level;
}

// 商人等级货仓加成：L5+每5级+5格（L5=+5, L10=+10, L20=+20）
function getMerchantWarehouseBonus() {
    if (!player.trading) return 0;
    const ml = player.trading.merchantLevel || 1;
    return Math.floor(ml / 5) * 5;
}

// 总货仓容量（含仓库+运输工具+商人等级加成）
function getTradingTotalCapacity() {
    if (!player.trading) return 0;
    const base = player.trading.warehouse.capacity + (player.trading.transport ? player.trading.transport.capacityBonus : 0);
    return base + getMerchantWarehouseBonus();
}

// 每日商会任务：5 个；刷新条件 = 任务全完成（list 为空）或距上次生成已过 24 小时
function ensureGuildQuests() {
    if (!player.trading || !player.trading.guildQuests) return;
    const gq = player.trading.guildQuests;
    const now = Date.now();
    const dayMs = 24 * 60 * 60 * 1000;
    var shouldRefresh = false;
    if (!gq.list || gq.list.length === 0) shouldRefresh = true;
    else if (gq.lastReset > 0 && now - gq.lastReset >= dayMs) shouldRefresh = true;
    if (!shouldRefresh) return;
    const cities = Object.keys(tradingConfig.cities || {});
    const goods = Object.keys(tradingConfig.goods || {});
    if (cities.length < 2 || goods.length < 1) return;
    gq.list = [];
    gq.lastReset = now;
    if (player.trading.profitToday == null) player.trading.profitToday = 0;
    player.trading.profitToday = 0;
    for (let i = 0; i < 5; i++) {
        const typeRoll = i % 5;
        if (typeRoll === 0) {
            const good = goods[Math.floor(Math.random() * goods.length)];
            const toCity = cities[Math.floor(Math.random() * cities.length)];
            const amount = 5 + Math.floor(Math.random() * 16);
            const reward = 2000 + Math.floor(Math.random() * 6000);
            gq.list.push({ type: 'deliver', good, toCity, amount, reward, progress: 0, id: 'd' + i + now });
        } else if (typeRoll === 1) {
            const target = 50000 + Math.floor(Math.random() * 250001);
            const reward = 5000 + Math.floor(Math.random() * 10000);
            gq.list.push({ type: 'profit', target, reward, progress: 0, id: 'p' + i + now });
        } else if (typeRoll === 2) {
            const toCity = cities[Math.floor(Math.random() * cities.length)];
            const reward = 3000 + Math.floor(Math.random() * 4000);
            gq.list.push({ type: 'visit', toCity, reward, id: 'v' + i + now });
        } else if (typeRoll === 3) {
            const targetCount = 3 + Math.floor(Math.random() * 4);
            const reward = 4000 + Math.floor(Math.random() * 5000);
            gq.list.push({ type: 'tour', targetCount, reward, progress: 0, visitedCities: {}, id: 't' + i + now });
        } else {
            const good = goods[Math.floor(Math.random() * goods.length)];
            const toCity = cities[Math.floor(Math.random() * cities.length)];
            const amount = 3 + Math.floor(Math.random() * 8);
            const reward = 3500 + Math.floor(Math.random() * 4500);
            gq.list.push({ type: 'buyAtCity', good, city: toCity, amount, reward, progress: 0, id: 'ba' + i + now });
        }
    }
}

// 仅更新商会任务刷新倒计时（供定时器调用）
function updateGuildQuestCountdownOnly() {
    const el = document.getElementById('guildQuestCountdown');
    if (!el || !player.trading || !player.trading.guildQuests) return;
    const gq = player.trading.guildQuests;
    const now = Date.now();
    const dayMs = 24 * 60 * 60 * 1000;
    if (!gq.list || gq.list.length === 0) {
        el.textContent = '任务已全部完成，下次进入本页将刷新';
        el.style.color = '#8BC34A';
        return;
    }
    if (!gq.lastReset || gq.lastReset <= 0) {
        el.textContent = '刷新计时：--';
        return;
    }
    const nextRefresh = gq.lastReset + dayMs;
    let remain = nextRefresh - now;
    if (remain <= 0) {
        el.textContent = '已到刷新时间，下次进入本页将刷新';
        el.style.color = '#FF9800';
        return;
    }
    const h = Math.floor(remain / 3600000);
    const m = Math.floor((remain % 3600000) / 60000);
    const s = Math.floor((remain % 60000) / 1000);
    el.textContent = '下次刷新：' + (h + '时' + String(m).padStart(2, '0') + '分' + String(s).padStart(2, '0') + '秒');
    el.style.color = '#aaa';
}

// 更新商会任务进度；type: 'sell'|'buy'|'arrive'；buy 时第5参为购买所在城市（代购用）
function checkGuildQuestProgress(type, good, quantity, amountOrRevenue, arrivedCity) {
    if (!player.trading || !player.trading.guildQuests || !player.trading.guildQuests.list) return;
    const list = player.trading.guildQuests.list;
    if (type === 'arrive' && arrivedCity) {
        for (let i = list.length - 1; i >= 0; i--) {
            const q = list[i];
            if (q.type === 'deliver' && q.toCity === arrivedCity) {
                const inv = (player.trading.inventory && player.trading.inventory[q.good]) ? player.trading.inventory[q.good].quantity : 0;
                if (inv >= q.amount) {
                    if (player.nightClub && player.nightClub.starCoins != null) player.nightClub.starCoins += q.reward;
                    if (typeof logAction === 'function') logAction(`商会任务完成：将${q.amount}件${q.good}运至${arrivedCity}，获得${q.reward}星币`, 'success');
                    list.splice(i, 1);
                }
            } else if (q.type === 'visit' && q.toCity === arrivedCity) {
                if (player.nightClub && player.nightClub.starCoins != null) player.nightClub.starCoins += q.reward;
                if (typeof logAction === 'function') logAction(`商会任务完成：抵达${arrivedCity}（旅游），获得${q.reward}星币`, 'success');
                list.splice(i, 1);
            } else if (q.type === 'tour') {
                if (!q.visitedCities[arrivedCity]) {
                    q.visitedCities[arrivedCity] = true;
                    q.progress = (q.progress || 0) + 1;
                }
                if (q.progress >= q.targetCount) {
                    if (player.nightClub && player.nightClub.starCoins != null) player.nightClub.starCoins += q.reward;
                    if (typeof logAction === 'function') logAction(`商会任务完成：跑图路过${q.targetCount}座城市，获得${q.reward}星币`, 'success');
                    list.splice(i, 1);
                }
            }
        }
        return;
    }
    if (type === 'sell' && good != null) {
        for (let i = list.length - 1; i >= 0; i--) {
            const q = list[i];
            if (q.type !== 'profit') continue;
            q.progress = Math.floor(player.trading.profitToday || 0);
            if (q.progress >= q.target) {
                if (player.nightClub && player.nightClub.starCoins != null) player.nightClub.starCoins += q.reward;
                if (typeof logAction === 'function') logAction(`商会任务完成：当日利润达到${q.target}，获得${q.reward}星币`, 'success');
                list.splice(i, 1);
            }
        }
    }
    if (type === 'buy' && good != null) {
        const buyCity = arrivedCity;
        for (let i = list.length - 1; i >= 0; i--) {
            const q = list[i];
            if (q.type !== 'buyAtCity' || q.good !== good || !buyCity || q.city !== buyCity) continue;
            q.progress = (q.progress || 0) + quantity;
            if (q.progress >= q.amount) {
                if (player.nightClub && player.nightClub.starCoins != null) player.nightClub.starCoins += q.reward;
                if (typeof logAction === 'function') logAction(`商会任务完成：在${q.city}代购${q.amount}件${good}，获得${q.reward}星币`, 'success');
                list.splice(i, 1);
            }
        }
    }
}

// 在卖出时累计当日利润（用于“当日利润”任务）
function addDailyProfit(profit) {
    if (!player.trading) return;
    if (player.trading.profitToday == null) player.trading.profitToday = 0;
    player.trading.profitToday += profit;
}

// 旅行到其他城市
function travelToCity(city) {
    updateMapTab();
    if (player.trading.isTraveling) {
        logAction("当前正在旅行中，无法更改目的地", "error");
        return;
    }
    
    if (city === player.trading.currentCity) {
        logAction("已经在目标城市", "info");
        return;
    }
    
    player.trading.travelDestination = city;
    
    // 显示旅行信息
    const baseTime = tradingConfig.cities[city].travelTime;
    const speedBonus = player.trading.transport.speedBonus;
    const actualTime = baseTime * (100 - speedBonus) / 100 - Math.min(player.parking.level / 33, 1.21);
       
    logAction(`已选择目的地：${city}，预计需要${actualTime.toFixed(1)}分钟`, "info");
    updateMapTab();
     
}
function cancelTravel() {
    // 如果自动贸易启用，禁用手动取消旅行
    if (player.trading.autoTrade.enabled) {
        logAction("自动贸易已启用，无法手动取消旅行", "warning");
        return;
    }
    
    if (!player.trading.isTraveling) {
        logAction("当前没有进行中的旅行", "info");
        return;
    }
    
    showCustomConfirm("确定要取消当前旅行吗？已花费的时间将不会返还。", (confirmed) => {
        if (confirmed) {
            if (player.trading.travelInterval) {
                clearInterval(player.trading.travelInterval);
                player.trading.travelInterval = null;
            }
            
            player.trading.isTraveling = false;
            player.trading.travelDestination = '';
            
            logAction("已取消旅行", "info");
            updateMapTab();
        }
    });
}
function addCancelTravelButton() {
    const travelInfo = document.getElementById('travelInfo');
    if (!document.getElementById('cancelTravelBtn')) {
        const cancelBtn = document.createElement('button');
        cancelBtn.id = 'cancelTravelBtn';
        cancelBtn.textContent = '取消旅行';
        cancelBtn.style.marginLeft = '10px';
        cancelBtn.style.background = '#f44336';
        cancelBtn.onclick = cancelTravel;
        travelInfo.appendChild(cancelBtn);
    }
}
// 开始旅行
function startTravel() {
    // 如果自动贸易启用，禁用手动旅行
    if (player.trading.autoTrade.enabled) {
        logAction("自动贸易已启用，无法手动旅行", "warning");
        return;
    }
    
    if (!player.trading.travelDestination) {
        logAction("请先选择目的地", "error");
        return;
    }
    
    if (player.trading.isTraveling) {
        logAction("当前正在旅行中", "error");
        return;
    }
    
    const destination = player.trading.travelDestination;
    const baseTime = tradingConfig.cities[destination].travelTime;
    const speedBonus = player.trading.transport.speedBonus || 0;
    const parkingLevel = (player.parking && typeof player.parking.level === 'number') ? player.parking.level : 0;
    let actualTime = Math.max(0.1, baseTime * (100 - speedBonus) / 100 - Math.min(parkingLevel / 33, 1.21));
    var empTravel = (typeof getEmployeeTravelSpeedBonus === 'function') ? getEmployeeTravelSpeedBonus() : 0;
    if (empTravel > 0) actualTime = Math.max(0.1, actualTime * (1 - empTravel / 100));
    if (player.trading.travelTimeReductionEnd && Date.now() <= player.trading.travelTimeReductionEnd && (player.trading.travelTimeReduction || 0) > 0) {
        actualTime = Math.max(0.1, actualTime * (1 - player.trading.travelTimeReduction));
        player.trading.travelTimeReduction = 0;
        player.trading.travelTimeReductionEnd = 0;
    }
    player.trading.isTraveling = true;
    player.trading.travelStartTime = Date.now();
    player.trading.travelEndTime = Date.now() + actualTime * 60 * 1000;
    
    logAction(`开始前往${destination}，预计需要${actualTime.toFixed(1)}分钟`, "info");
    
    // 确保清除之前的计时器
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
    }
    
    // 启动旅行计时器
    player.trading.travelInterval = registerInterval(checkTravelStatus, 1000);
    
    updateMapTab();
}

// 检查旅行状态
function checkTravelStatus() {
    if (!player.trading.isTraveling) return;
    
    const now = Date.now();
    if (now >= player.trading.travelEndTime) {
        // 到达目的地：自动贸易走 completeAutoTravel，手动旅行走 completeTravel（含随机事件）
        if (player.trading.autoTrade && player.trading.autoTrade.enabled) {
            completeAutoTravel();
        } else {
            completeTravel();
        }
    } else {
        // 更新旅行进度显示
        updateTravelProgress();
    }
}
// 完成旅行
function completeTravel() {
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
        player.trading.travelInterval = null;
    }
    // 记录本次旅行时长（用于短途收益衰减，抑制王都↔附近城市刷钱）
    if (player.trading.travelEndTime != null && player.trading.travelStartTime != null) {
        player.trading.lastTravelTimeMinutes = (player.trading.travelEndTime - player.trading.travelStartTime) / 60000;
    }
    
    player.trading.currentCity = player.trading.travelDestination;
    const arrivedCity = player.trading.currentCity;
    player.trading.isTraveling = false;
    player.trading.travelDestination = '';
    
    logAction(`已到达${arrivedCity}`, "success");
    
    if (typeof checkGuildQuestProgress === 'function') checkGuildQuestProgress('arrive', null, 0, 0, arrivedCity);
    
    // 更新界面
    updateMapTab();
    updateTradingUI();
    
    // 触发随机事件
    triggerRandomEvent();
}

function updateTravelProgress() {
    const now = Date.now();
    const elapsed = now - player.trading.travelStartTime;
    const total = player.trading.travelEndTime - player.trading.travelStartTime;
    const progress = Math.min(100, (elapsed / total) * 100);
    
    // 更新UI显示
    const minutesRemaining = Math.ceil((player.trading.travelEndTime - now) / (1000 * 60));
    
    // 更新自动贸易进度条
    updateAutoTradeProgressBar();
    
    // 如果世界地图界面打开，也更新那里的进度条
    if (document.getElementById('travelProgressBar')) {
        document.getElementById('travelProgressBar').style.width = `${progress}%`;
        document.getElementById('travelTime').textContent = `${minutesRemaining}分钟`;
        document.getElementById('travelStatus').textContent = `旅行中... ${progress.toFixed(1)}%`;
    }
}


// 触发随机事件（受风险偏好影响）
function triggerRandomEvent() {
    if (!player || !player.trading) return;
    var eventChance = Math.random();
    var risk = (player.trading.riskAppetite != null && player.trading.riskAppetite !== '') ? player.trading.riskAppetite : 'balanced';
    var pPos = 0.2, pNeg = 0.25, pOpp = 0.1;
    if (risk === 'aggressive') { pPos = 0.22; pNeg = 0.27; pOpp = 0.11; }
    if (eventChance < pPos) {
        triggerPositiveEvent();
    } else if (eventChance < pPos + pNeg) {
        if (risk === 'steady' && Math.random() < 0.1) return;
        triggerNegativeEvent();
    } else if (eventChance < pPos + pNeg + pOpp) {
        triggerOpportunityEvent();
    }
}

// 正面事件
function triggerPositiveEvent() {
    const events = [
        {
            type: 'discount',
            message: '特价采购！所有商品临时降价40%，持续1小时',
            effect: () => {
                logAction("特价采购事件触发！商品价格下降40%", "success");
            }
        },
        {
            type: 'demand',
            message: '豪商收购！随机商品临时涨价50%，持续1小时',
            effect: () => {
                const goods = Object.keys(tradingConfig.goods);
                const randomGood = goods[Math.floor(Math.random() * goods.length)];
                logAction(`豪商收购事件触发！${randomGood}价格上涨50%`, "success");
            }
        },
        {
            type: 'festival',
            message: '节日促销！当前城市出售收益+15%，持续10分钟',
            effect: () => {
                if (player.trading && player.trading.currentCity) {
                    player.trading.eventBonus = {
                        endTime: Date.now() + 10 * 60 * 1000,
                        sellMultiplier: 1.15,
                        city: player.trading.currentCity
                    };
                    logAction("节日促销！当前城市出售收益+15%，持续10分钟", "success");
                }
            }
        },
        {
            type: 'luckyMerchant',
            message: '幸运商人眷顾！下次购买任意商品将额外获得1个',
            effect: () => {
                if (player.trading) {
                    player.trading.luckyMerchantNextBuy = true;
                    logAction("幸运商人眷顾！下次购买将额外获得1个该商品", "success");
                }
            }
        },
        {
            type: 'mysteryMerchant',
            message: '神秘商人出现！以市价七折卖给你一批随机货物',
            effect: () => {
                const goods = Object.keys(tradingConfig.goods);
                const good = goods[Math.floor(Math.random() * goods.length)];
                const city = player.trading.currentCity;
                const marketPrice = player.trading.cityPrices[city][good] || tradingConfig.goods[good].basePrice;
                const qty = 3 + Math.floor(Math.random() * 5);
                const cost = Math.floor(marketPrice * 0.7 * qty);
                if (player.nightClub.starCoins >= cost) {
                    player.nightClub.starCoins -= cost;
                    const item = player.trading.inventory[good];
                    const slots = tradingConfig.goods[good].slots * qty;
                    if (getTradingTotalCapacity() >= (player.trading.warehouse.used || 0) + slots) {
                        if (item) { item.quantity += qty; item.totalCost += cost; item.averageCost = item.totalCost / item.quantity; }
                        else player.trading.inventory[good] = { quantity: qty, averageCost: cost / qty, totalCost: cost };
                        player.trading.warehouse.used = (player.trading.warehouse.used || 0) + slots;
                        if (typeof logAction === 'function') logAction(`神秘商人：以${cost.toLocaleString()}星币购入${qty}件${good}`, "success");
                    }
                }
            }
        },
        {
            type: 'roadTreasure',
            message: '路边发现宝箱！获得一笔星币',
            effect: () => {
                const amount = 5000 + Math.floor(Math.random() * 15001);
                if (player.nightClub && player.nightClub.starCoins != null) player.nightClub.starCoins += amount;
                if (typeof logAction === 'function') logAction(`路边宝箱：获得${amount.toLocaleString()}星币`, "success");
            }
        },
        {
            type: 'travelBoost',
            message: '贵人相助！下次旅行时间减少20%',
            effect: () => {
                if (player.trading) {
                    player.trading.travelTimeReduction = (player.trading.travelTimeReduction || 0) + 0.2;
                    player.trading.travelTimeReductionEnd = Date.now() + 60 * 60 * 1000;
                    if (typeof logAction === 'function') logAction("贵人相助！1小时内下次旅行时间-20%", "success");
                }
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    event.effect();
    logAction(event.message, "event");
}

// 负面事件
function triggerNegativeEvent() {
    const events = [
        {
            type: 'robbery',
            message: '遭遇强盗！损失部分货物',
            effect: () => {
                if (!player.trading.insurance) player.trading.insurance = { goods: false, transport: false, bundle: false };
                if (player.trading.insurance.goods || player.trading.insurance.bundle) {
                    logAction("强盗事件触发！但已投保，损失由保险公司承担", "event");
                    return;
                }
                // 员工「保镖队长」+ 商人等级L4+ 减免抢劫损失
                let robberyReduction = 0;
                if (player.trading.employees && player.trading.employees.length > 0) {
                    player.trading.employees.forEach(emp => {
                        if (emp.robberyReduction) robberyReduction = Math.min(100, robberyReduction + emp.robberyReduction);
                    });
                }
                var ml = player.trading.merchantLevel || 1;
                if (ml >= 4) robberyReduction = Math.min(100, robberyReduction + 10 + (ml - 4));
                const lossMultiplier = Math.max(0, 1 - robberyReduction / 100);
                const lossPercentage = (0.1 + Math.random() * 0.2) * lossMultiplier;
                let totalLoss = 0;
                const inv = player.trading.inventory;
                Object.keys(inv).forEach(good => {
                    const item = inv[good];
                    const qty = typeof item === 'object' && item != null && 'quantity' in item ? item.quantity : 0;
                    if (qty <= 0) return;
                    const lossQuantity = Math.floor(qty * lossPercentage);
                    if (lossQuantity > 0) {
                        const goodConfig = tradingConfig.goods[good];
                        if (!goodConfig) return;
                        if (item.quantity === lossQuantity) {
                            player.trading.warehouse.used -= goodConfig.slots * lossQuantity;
                            delete player.trading.inventory[good];
                        } else {
                            item.quantity -= lossQuantity;
                            item.totalCost = item.averageCost * item.quantity;
                            player.trading.warehouse.used -= goodConfig.slots * lossQuantity;
                        }
                        totalLoss += lossQuantity;
                    }
                });
                player.trading.hasExperiencedRobbery = true;
                logAction(`强盗事件触发！损失了约${Math.round(lossPercentage * 100)}%的货物`, "event");
            }
        },
        {
            type: 'spoilage',
            message: '商品腐败！部分易腐商品价值归零',
            effect: () => {
                // 先检查是否有易腐商品，没有则直接返回，避免误报或仓库异常
                let hasPerishable = false;
                Object.keys(tradingConfig.goods).forEach(good => {
                    const goodConfig = tradingConfig.goods[good];
                    if (goodConfig.shelfLife === Infinity) return;
                    const item = player.trading.inventory[good];
                    if (item && typeof item === 'object' && 'quantity' in item && item.quantity > 0) hasPerishable = true;
                });
                if (!hasPerishable) return;

                let anySpoiled = false;
                Object.keys(tradingConfig.goods).forEach(good => {
                    const goodConfig = tradingConfig.goods[good];
                    if (goodConfig.shelfLife === Infinity) return;
                    const item = player.trading.inventory[good];
                    if (!item) return;
                    const qty = typeof item === 'object' && item != null && 'quantity' in item ? item.quantity : 0;
                    if (qty <= 0) return;
                    var spoilChance = 0.1;
                    var spoilRed = (typeof getEmployeeSpoilReduction === 'function') ? getEmployeeSpoilReduction() : 0;
                    spoilChance = spoilChance * Math.max(0.05, 1 - spoilRed / 100);
                    if (Math.random() < spoilChance) {
                        const spoilQuantity = Math.max(1, Math.floor(qty * 0.5));
                        if (item.quantity === spoilQuantity) {
                            player.trading.warehouse.used -= goodConfig.slots * spoilQuantity;
                            delete player.trading.inventory[good];
                        } else {
                            item.quantity -= spoilQuantity;
                            item.totalCost = item.averageCost * item.quantity;
                            player.trading.warehouse.used -= goodConfig.slots * spoilQuantity;
                        }
                        logAction(`${good}腐败了${spoilQuantity}个`, "event");
                        anySpoiled = true;
                    }
                });
                // 无论是否发生腐败，都按当前库存重算仓库占用，避免 used 与库存不同步
                syncWarehouseUsedFromInventory();
            }
        },
        {
            type: 'tariff',
            message: '临时关税！当前城市买入价临时上涨10%，持续30分钟',
            effect: () => {
                if (player.trading) {
                    player.trading.tariffBonus = { endTime: Date.now() + 30 * 60 * 1000, buyMultiplier: 1.1, city: player.trading.currentCity };
                    if (typeof logAction === 'function') logAction("临时关税：当前城市买入价+10%，持续30分钟", "event");
                }
            }
        },
        {
            type: 'transportFailure',
            message: '运输故障！车辆损坏需维修',
            effect: () => {
                if (!player.trading.insurance) player.trading.insurance = { goods: false, transport: false, bundle: false };
                if (player.trading.insurance.transport || player.trading.insurance.bundle) {
                    logAction("运输故障！运输险已赔付，无损失", "event");
                    return;
                }
                var transport = tradingConfig.transports.find(function(t) { return t.name === player.trading.transport.type; });
                if (transport && transport.maintenance > 0) {
                    var repairCost = Math.floor(transport.maintenance * 3);
                    if (player.nightClub.starCoins >= repairCost) {
                        player.nightClub.starCoins -= repairCost;
                        logAction("运输故障！支付维修费" + repairCost.toLocaleString() + "星币", "event");
                    } else {
                        player.trading.transport = { type: '手推车', capacityBonus: 5, speedBonus: 0 };
                        logAction("运输故障！资金不足维修，降级为手推车", "warning");
                    }
                }
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    event.effect();
    logAction(event.message, "event");
}

// 机遇事件
function triggerOpportunityEvent() {
    const events = [
        {
            type: 'limitedOffer',
            message: '发现限时商机！特定商品利润丰厚',
            effect: () => {
                const goods = Object.keys(tradingConfig.goods);
                const randomGood = goods[Math.floor(Math.random() * goods.length)];
                logAction(`限时商机：${randomGood}当前利润丰厚！`, "opportunity");
            }
        },
        {
            type: 'blackMarket',
            message: '发现黑市入口！当前城市可进入黑市交易，持续1小时',
            effect: () => {
                if (player.trading && player.trading.currentCity) {
                    player.trading.blackMarket = { available: true, endTime: Date.now() + 60 * 60 * 1000, city: player.trading.currentCity };
                    if (typeof logAction === 'function') logAction("黑市入口已开启！请到「趣味玩法」- 黑市进行交易", "opportunity");
                }
            }
        },
        {
            type: 'rumor',
            message: '打听到小道消息！某城某商品即将涨价',
            effect: () => {
                const cities = Object.keys(tradingConfig.cities);
                const goods = Object.keys(tradingConfig.goods);
                const city = cities[Math.floor(Math.random() * cities.length)];
                const good = goods[Math.floor(Math.random() * goods.length)];
                const effectEndTime = Date.now() + 2 * 60 * 60 * 1000;
                if (player.trading) {
                    player.trading.rumor = { text: `传闻：${city}的${good}两小时内可能涨价`, good: good, city: city, effectEndTime: effectEndTime };
                    if (typeof logAction === 'function') logAction(`小道消息：${city}的${good}两小时内可能涨价`, "opportunity");
                }
            }
        },
        {
            type: 'bargain',
            message: '捡漏成功！随机一种商品以五折购入1件（若货仓有余）',
            effect: () => {
                const goods = Object.keys(tradingConfig.goods);
                const good = goods[Math.floor(Math.random() * goods.length)];
                const city = player.trading.currentCity;
                const marketPrice = player.trading.cityPrices[city][good] || tradingConfig.goods[good].basePrice;
                const cost = Math.floor(marketPrice * 0.5);
                const slots = tradingConfig.goods[good].slots;
                if (player.nightClub.starCoins >= cost && (player.trading.warehouse.used || 0) + slots <= getTradingTotalCapacity()) {
                    player.nightClub.starCoins -= cost;
                    const item = player.trading.inventory[good];
                    if (item) { item.quantity += 1; item.totalCost += cost; item.averageCost = item.totalCost / item.quantity; }
                    else player.trading.inventory[good] = { quantity: 1, averageCost: cost, totalCost: cost };
                    player.trading.warehouse.used = (player.trading.warehouse.used || 0) + slots;
                    if (typeof logAction === 'function') logAction(`捡漏：以${cost}星币购入1件${good}`, "success");
                }
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    event.effect();
    logAction(event.message, "opportunity");
}

// 自动贸易功能
function toggleAutoTrade() {
    // 检查是否有保存的路线
    if (player.trading.autoTrade.routes.length === 0) {
        logAction("请先设置自动贸易路线", "error");
        
        // 显示设置界面
        document.getElementById('autoTradeSettings').style.display = 'block';
        document.getElementById('autoTradeStatus').style.display = 'none';
        
        return;
    }
    
    player.trading.autoTrade.enabled = !player.trading.autoTrade.enabled;
    
    if (player.trading.autoTrade.enabled) {
        // 重置状态
        player.trading.autoTrade.currentState = 'idle';
        player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0]; // 使用第一条路线
        player.trading.autoTrade.currentProgress = 0;
        player.trading.autoTrade.lastUpdate = Date.now();
        
        // 启动自动贸易系统
        startAutoTradeSystem();
        
        // 启动进度条更新定时器（如果界面打开）
        if (document.getElementById('autoTab').style.display !== 'none') {
            startProgressUpdateTimer();
        }
        
        logAction("自动贸易已启用", "success");
    } else {
        // 停止自动贸易系统
        stopAutoTradeSystem();
        
        // 停止进度条更新定时器
        stopProgressUpdateTimer();
        
        logAction("自动贸易已停用", "info");
    }
    
    updateAutoTradeTab();
}


// 运行自动贸易
function runAutoTrade() {
    if (!player.trading.autoTrade.enabled) return;
    
    const now = tradingNow();
    const elapsed = now - player.trading.autoTrade.lastUpdate;
    
    // 更严格的频率控制：至少间隔10秒才执行一次；离线模拟时不节流，保证每次循环都执行
    if (player.trading._simulatedNow == null && elapsed < 10000) return;
    
    player.trading.autoTrade.lastUpdate = now;
    
    // 检查是否正在旅行中，如果是则跳过其他逻辑
    if (player.trading.isTraveling) {
        updateAutoTravel(elapsed);
        return;
    }
    
    // 检查是否有下一次监控的时间设置
    if (player.trading.autoTrade.nextMonitorTime && now < player.trading.autoTrade.nextMonitorTime) {
        return; // 等待下一次监控时间
    }
    
    // 验证数据
    validateAutoTradeData();
    
    // 检查状态是否有效
    validateAutoTradeState();
    
    switch (player.trading.autoTrade.currentState) {
        case 'idle':
            startFlexibleTrade();
            break;
        case 'buying':
            executeFlexibleBuying();
            break;
        case 'selling':
            executeFlexibleSelling();
            break;
        case 'monitoring':
            monitorPricesAndDecide();
            break;
    }
    
    // 离线模拟时不更新进度条，避免 DOM 未就绪
    if (player.trading._simulatedNow != null) return;
    updateAutoTradeProgressBar();
}

function startFlexibleTrade() {
    if (player.trading.autoTrade.routes.length === 0) {
        if (player.trading._simulatedNow != null) return; // 离线模拟时不关闭 enabled，避免加载后自动贸易被关
        addAutoTradeLog("没有设置自动贸易路线", "warning");
        player.trading.autoTrade.enabled = false;
        updateAutoTradeTab();
        return;
    }
    
    // 选择一条路线
    player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0];
    
    // 开始在当前城市寻找机会
    player.trading.autoTrade.currentState = 'monitoring';
    addAutoTradeLog(`开始在${player.trading.currentCity}寻找贸易机会`, "info");
}

function executeFlexibleBuying() {
    // 检查是否正在旅行中
    if (player.trading.isTraveling) {
        return;
    }
    
    const city = player.trading.currentCity;
    
    // 检查货仓使用率
    const totalCapacity = getTradingTotalCapacity();
    const usageRate = player.trading.warehouse.used / totalCapacity;
    
    if (usageRate >= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage) {
        addAutoTradeLog("货仓已满，开始寻找销售机会", "info");
        player.trading.autoTrade.currentState = 'selling';
        return;
    }
    
    // 检查库存总金额上限（超限则不再购买）
    const maxInvVal = player.trading.autoTrade.flexibleTrade.maxInventoryValue || 0;
    if (maxInvVal > 0) {
        const totalInvCost = getTotalInventoryCost();
        if (totalInvCost >= maxInvVal) {
            addAutoTradeLog(`库存总金额已达上限${maxInvVal.toLocaleString()}，当前${totalInvCost.toLocaleString()}，不再购买`, "info");
            player.trading.autoTrade.currentState = 'selling';
            return;
        }
    }
    
    // 检查可用资金（路线可能无 tradeCapital，用星币或默认 10000 兜底）
    const availableFunds = player.nightClub.starCoins || 0;
    const routeCapital = player.trading.autoTrade.currentRoute.tradeCapital;
    const minCapital = (routeCapital != null && routeCapital > 0) ? routeCapital * 0.1 : 1000;
    if (availableFunds < minCapital) {
        addAutoTradeLog("资金不足，开始寻找其他城市的机会", "info");
        decideNextDestination();
        return;
    }
    
    // 获取所有可购买的商品
    const allPurchasableGoods = getAllPurchasableGoods();
    
    if (allPurchasableGoods.length === 0) {
        addAutoTradeLog("当前没有价格合适的商品可购买，开始寻找其他城市的机会", "info");
        decideNextDestination();
        return;
    }
    
    // 根据策略选择商品
    const targetGood = selectGoodForPurchase(allPurchasableGoods);
    
    if (!targetGood) {
        addAutoTradeLog("无法确定要购买的商品，开始寻找其他城市的机会", "warning");
        decideNextDestination();
        return;
    }
    
    const route = player.trading.autoTrade.currentRoute;
    const actualPrice = getActualBuyPrice(city, targetGood);
    const routeGood = route && route.goods ? route.goods.find(g => g && g.good === targetGood) : null;
    const maxBuyPrice = routeGood && routeGood.maxBuyPrice != null && Number.isFinite(routeGood.maxBuyPrice) ? routeGood.maxBuyPrice : Infinity;
    if (actualPrice > maxBuyPrice) {
        addAutoTradeLog(`${targetGood}实际买入价${actualPrice}超过最大${maxBuyPrice}，跳过购买`, "info");
        decideNextDestination();
        return;
    }
    const capitalForPurchase = (routeCapital != null && routeCapital > 0) ? routeCapital : Math.max(availableFunds, 10000);
    const quantity = calculateOptimalPurchaseQuantity(targetGood, capitalForPurchase);
    
    if (quantity > 0) {
        buyGood(targetGood, quantity);
        addAutoTradeLog(`购买了${quantity}个${targetGood}，花费${(actualPrice * quantity).toLocaleString()}星币`, "success");
        
        // 购买后检查是否需要转为销售模式
        if (usageRate >= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage * 0.8) {
            addAutoTradeLog("货仓接近满载，开始寻找销售机会", "info");
            player.trading.autoTrade.currentState = 'selling';
        }
    } else {
        addAutoTradeLog(`无法购买${targetGood}，资金或空间不足，开始寻找其他城市的机会`, "warning");
        decideNextDestination();
    }
}

function executeFlexibleSelling() {
    // 检查是否正在旅行中
    if (player.trading.isTraveling) {
        return;
    }
    
    const city = player.trading.currentCity;
    
    // 获取所有可销售的商品
    const allSalableGoods = getAllSalableGoods();
    
    if (allSalableGoods.length === 0) {
        addAutoTradeLog("当前没有利润率合适的商品可销售，开始寻找其他城市的机会", "info");
        decideNextDestination();
        return;
    }
    
    // 选择利润率最高的商品
    const targetGood = allSalableGoods[0].good;
    const price = player.trading.cityPrices[city][targetGood];
    const averageCost = player.trading.inventory[targetGood].averageCost;
    const profitMargin = ((price - averageCost) / averageCost) * 100;
    
    // 计算销售数量
    const quantity = calculateOptimalSaleQuantity(targetGood);
    
    if (quantity > 0) {
        sellGood(targetGood, quantity);
        addAutoTradeLog(`出售了${quantity}个${targetGood}，利润率${profitMargin.toFixed(1)}%`, "success");
        
        // 销售后检查是否需要转为采购模式
        const totalCapacity = getTradingTotalCapacity();
        const usageRate = player.trading.warehouse.used / totalCapacity;
        
        if (usageRate <= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage * 0.3) {
            addAutoTradeLog("货仓空间充足，开始寻找采购机会", "info");
            player.trading.autoTrade.currentState = 'buying';
        }
    } else {
        addAutoTradeLog(`无法销售${targetGood}，库存不足，开始寻找其他城市的机会`, "warning");
        decideNextDestination();
    }
}

function validateAutoTradeState() {
    // 离线模拟时跳过“频繁旅行”检测，否则会误判并取消旅行导致离线无收益
    if (player.trading._simulatedNow != null) return;
    // 检查是否处于无效状态循环
    const recentLogs = player.trading.autoTrade.logs.slice(0, 10);
    const travelLogs = recentLogs.filter(log => log.message.includes("前往") || log.message.includes("旅行"));
    
    // 如果最近10条日志中有6条以上是关于旅行的，自动重置状态
    if (travelLogs.length >= 6) {
        addAutoTradeLog("检测到频繁旅行，自动重置为监控状态", "warning");
        player.trading.autoTrade.currentState = 'monitoring';
        player.trading.autoTrade.nextMonitorTime = Date.now() + 120000; // 等待2分钟再检查
        
        // 如果当前正在旅行，取消旅行
        if (player.trading.isTraveling) {
            if (player.trading.travelInterval) {
                clearInterval(player.trading.travelInterval);
                player.trading.travelInterval = null;
            }
            player.trading.isTraveling = false;
            player.trading.travelDestination = '';
        }
        
        // 标记频繁旅行检测
        player.trading.autoTrade.frequentTravelDetection = true;
    }
}

function monitorPricesAndDecide() {
    const city = player.trading.currentCity;
    
    // 检查是否正在旅行中
    if (player.trading.isTraveling) {
        return;
    }
    
    // 同时检查采购和销售机会
    checkBothPurchaseAndSaleOpportunities();
}


function getAllPurchasableGoods() {
    const city = player.trading.currentCity;
    if (!player.trading.cityPrices || !player.trading.cityPrices[city]) return [];
    // 灵活贸易：只考虑路线中选定的商品
    const route = player.trading.autoTrade.currentRoute;
    const allGoods = (route && Array.isArray(route.goods) && route.goods.length > 0)
        ? route.goods.map(g => g && g.good).filter(Boolean)
        : Object.keys(tradingConfig.goods || {});
    const purchasableGoods = [];
    
    allGoods.forEach(good => {
        const price = getActualBuyPrice(city, good); // 使用实际买入价（含关税），严格不超过用户设置
        let maxBuyPrice = Infinity;
        
        // 检查是否有设置该商品的最大买入价（缺省或无效时视为不限制）
        if (player.trading.autoTrade.currentRoute && Array.isArray(player.trading.autoTrade.currentRoute.goods)) {
            const routeGood = player.trading.autoTrade.currentRoute.goods.find(g => g && g.good === good);
            if (routeGood && routeGood.maxBuyPrice != null && Number.isFinite(routeGood.maxBuyPrice)) {
                maxBuyPrice = routeGood.maxBuyPrice; // 用户设置的最大买入价，实际成交价不得超过
            }
        }
        
        if (price != null && Number.isFinite(price) && price <= maxBuyPrice) {
            const basePrice = tradingConfig.goods[good].basePrice;
            const priceRatio = price / basePrice;
            
            purchasableGoods.push({
                good: good,
                price: price,
                basePrice: basePrice,
                priceRatio: priceRatio,
                maxBuyPrice: maxBuyPrice
            });
        }
    });
    
    // 根据策略排序
    const strategy = player.trading.autoTrade.purchaseSettings.purchaseStrategy;
    switch (strategy) {
        case 'priceDesc':
            purchasableGoods.sort((a, b) => b.price - a.price);
            break;
        case 'priceAsc':
            purchasableGoods.sort((a, b) => a.price - b.price);
            break;
        case 'profitMargin':
            purchasableGoods.sort((a, b) => {
                const aProfitPotential = 1 / a.priceRatio;
                const bProfitPotential = 1 / b.priceRatio;
                return bProfitPotential - aProfitPotential;
            });
            break;
    }
    
    return purchasableGoods;
}

function getAllSalableGoods() {
    const city = player.trading.currentCity;
    const salableGoods = [];
    
    // 检查库存中的商品
    Object.keys(player.trading.inventory).forEach(good => {
        if (player.trading.inventory[good].quantity > 0) {
            const price = player.trading.cityPrices[city][good];
            const averageCost = player.trading.inventory[good].averageCost;
            
            if (averageCost > 0) {
                const profitMargin = ((price - averageCost) / averageCost) * 100;
                const minProfitMargin = player.trading.autoTrade.currentRoute?.minProfitMargin || 
                                      player.trading.autoTrade.purchaseSettings.minProfitMargin;
                
                if (profitMargin >= minProfitMargin) {
                    salableGoods.push({
                        good: good,
                        profitMargin: profitMargin,
                        price: price,
                        cost: averageCost,
                        quantity: player.trading.inventory[good].quantity
                    });
                }
            }
        }
    });
    
    // 按利润率降序排序
    salableGoods.sort((a, b) => b.profitMargin - a.profitMargin);
    
    return salableGoods;
}


function selectGoodForPurchase(goodsList) {
    if (goodsList.length === 0) return null;
    
    const strategy = player.trading.autoTrade.purchaseSettings.purchaseStrategy;
    
    switch (strategy) {
        case 'priceDesc':
            return goodsList[0].good; // 最贵的商品
        case 'priceAsc':
            return goodsList[goodsList.length - 1].good; // 最便宜的商品
        case 'profitMargin':
            return goodsList[0].good; // 利润率潜力最高的商品
        default:
            return goodsList[0].good;
    }
}

// 决定下一个目的地
function decideNextDestination() {
    const currentCity = player.trading.currentCity;
    const connectedCities = tradingConfig.cities[currentCity].connections;
    
    if (connectedCities.length === 0) {
        addAutoTradeLog("没有可连接的城市，继续在当前城市监控", "warning");
        player.trading.autoTrade.currentState = 'monitoring';
        return;
    }
    
    // 评估每个城市的潜在机会
    const cityScores = [];
    
    connectedCities.forEach(city => {
        let score = 0;
        
        // 基本分数：随机性
        score += Math.random() * 20;
        
        // 检查采购机会
        const purchasableGoods = evaluateCityPurchasePotential(city);
        score += purchasableGoods.length * 15;
        
        // 检查销售机会
        const salableGoods = evaluateCitySalePotential(city);
        score += salableGoods.length * 20;
        
        // 检查城市类型（优先选择不同类型的城市）
        const currentCityType = tradingConfig.cities[currentCity].region;
        const targetCityType = tradingConfig.cities[city].region;
        if (currentCityType !== targetCityType) {
            score += 25; // 不同类型城市加分
        }
        
        // 最近访问过的城市分数降低
        if (isRecentlyVisited(city)) {
            score -= 30;
        }
        
        // 检查是否有库存商品在该城市有高利润
        const highProfitGoods = getHighProfitGoodsInCity(city);
        score += highProfitGoods.length * 30;
        
        // 检查是否有便宜的商品可购买
        const cheapGoods = getCheapGoodsInCity(city);
        score += cheapGoods.length * 10;
        
        cityScores.push({
            city: city,
            score: score,
            purchasePotential: purchasableGoods.length,
            salePotential: salableGoods.length,
            highProfitGoods: highProfitGoods.length,
            cheapGoods: cheapGoods.length
        });
    });
    
    // 选择分数最高的城市
    cityScores.sort((a, b) => b.score - a.score);
    const bestCity = cityScores[0].city;
    const bestCityScore = cityScores[0];
    
    // 记录决策原因
    let decisionReason = "决定前往";
    if (bestCityScore.purchasePotential > 0) {
        decisionReason += ` ${bestCityScore.purchasePotential}个采购机会`;
    }
    if (bestCityScore.salePotential > 0) {
        decisionReason += ` ${bestCityScore.salePotential}个销售机会`;
    }
    if (bestCityScore.highProfitGoods > 0) {
        decisionReason += ` ${bestCityScore.highProfitGoods}个高利润商品`;
    }
    if (bestCityScore.cheapGoods > 0) {
        decisionReason += ` ${bestCityScore.cheapGoods}个低价商品`;
    }
    if (bestCityScore.purchasePotential === 0 && bestCityScore.salePotential === 0) {
        decisionReason += " 探索新城市";
    }
    
    addAutoTradeLog(`${decisionReason}，前往${bestCity}`, "info");
    startAutoTravel(bestCity);
}
function getHighProfitGoodsInCity(city) {
    const highProfitGoods = [];
    
    // 检查库存中的商品
    Object.keys(player.trading.inventory).forEach(good => {
        if (player.trading.inventory[good].quantity > 0) {
            const price = player.trading.cityPrices[city][good];
            const averageCost = player.trading.inventory[good].averageCost;
            
            if (averageCost > 0) {
                const profitMargin = ((price - averageCost) / averageCost) * 100;
                const highProfitThreshold = (player.trading.autoTrade.currentRoute?.minProfitMargin || 
                                           player.trading.autoTrade.purchaseSettings.minProfitMargin) * 2;
                
                if (profitMargin >= highProfitThreshold) {
                    highProfitGoods.push({
                        good: good,
                        profitMargin: profitMargin
                    });
                }
            }
        }
    });
    
    return highProfitGoods;
}

function getCheapGoodsInCity(city) {
    const cheapGoods = [];
    const allGoods = Object.keys(tradingConfig.goods);
    
    allGoods.forEach(good => {
        const price = player.trading.cityPrices[city][good];
        const basePrice = tradingConfig.goods[good].basePrice;
        const priceRatio = price / basePrice;
        
        // 价格低于基础价格的商品认为是便宜的
        if (priceRatio < 0.9) {
            cheapGoods.push({
                good: good,
                price: price,
                basePrice: basePrice,
                discount: (1 - priceRatio) * 100
            });
        }
    });
    
    return cheapGoods;
}

function evaluateCityPurchasePotential(city) {
    const goods = Object.keys(tradingConfig.goods);
    const purchasableGoods = [];
    
    goods.forEach(good => {
        const price = getActualBuyPrice(city, good);
        let maxBuyPrice = Infinity;
        
        if (player.trading.autoTrade.currentRoute) {
            const routeGood = player.trading.autoTrade.currentRoute.goods.find(g => g && g.good === good);
            if (routeGood && routeGood.maxBuyPrice != null && Number.isFinite(routeGood.maxBuyPrice)) {
                maxBuyPrice = routeGood.maxBuyPrice;
            }
        }
        
        if (price != null && Number.isFinite(price) && price <= maxBuyPrice) {
            purchasableGoods.push(good);
        }
    });
    
    return purchasableGoods;
}

// 评估城市的销售潜力
function evaluateCitySalePotential(city) {
    const salableGoods = [];
    
    Object.keys(player.trading.inventory).forEach(good => {
        if (player.trading.inventory[good].quantity > 0) {
            const price = player.trading.cityPrices[city][good];
            const averageCost = player.trading.inventory[good].averageCost;
            
            if (averageCost > 0) {
                const profitMargin = ((price - averageCost) / averageCost) * 100;
                const minProfitMargin = player.trading.autoTrade.currentRoute?.minProfitMargin || 
                                      player.trading.autoTrade.purchaseSettings.minProfitMargin;
                
                if (profitMargin >= minProfitMargin) {
                    salableGoods.push(good);
                }
            }
        }
    });
    
    return salableGoods;
}

// 检查城市是否最近访问过
function isRecentlyVisited(city) {
    // 简化实现：检查最近5条日志中是否提到该城市
    const recentLogs = player.trading.autoTrade.logs.slice(0, 5);
    return recentLogs.some(log => log.message.includes(city));
}
function updateAutoTradeProgressBar() {
    // 检查进度条元素是否存在
    const progressBar = document.getElementById('autoTravelProgress');
    const percentageText = document.getElementById('autoTravelPercentage');
    const statusElement = document.querySelector('#autoTradeProgress .progress-label span:first-child');
    
    // 如果元素不存在，直接返回
    if (!progressBar || !percentageText || !statusElement) {
        return;
    }
    
    let progressPercent = 0;
    let statusText = '';
    
    switch (player.trading.autoTrade.currentState) {
        case 'traveling':
            progressPercent = Math.min(100, (player.trading.autoTrade.currentProgress / player.trading.autoTrade.totalTravelTime) * 100);
            statusText = `前往 ${player.trading.travelDestination}`;
            break;
        case 'buying':
            progressPercent = 50;
            statusText = `在 ${player.trading.autoTrade.currentRoute?.buyCity || player.trading.currentCity || '-'} 采购`;
            break;
        case 'selling':
            progressPercent = 50;
            statusText = `在 ${player.trading.autoTrade.currentRoute?.sellCity || player.trading.currentCity || '-'} 销售`;
            break;
        default:
            progressPercent = 0;
            statusText = '等待开始';
    }
    
    // 更新进度条
    progressBar.style.width = `${progressPercent}%`;
    percentageText.textContent = `${progressPercent.toFixed(1)}%`;
    
    // 更新状态文本
    statusElement.textContent = statusText;
}
// 智能采购逻辑
function executeSmartBuying() {
    // 确保当前城市有效
    if (!player.trading.currentCity || !tradingConfig.cities[player.trading.currentCity]) {
        logAction("当前城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都'; // 默认城市
        return;
    }
    
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    
    // 检查货仓使用率
    const totalCapacity = getTradingTotalCapacity();
    const usageRate = player.trading.warehouse.used / totalCapacity;
    
    if (usageRate >= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage) {
        addAutoTradeLog("货仓使用率超过设定值，开始前往销售城市", "info");
        startAutoTravel(route.sellCity);
        return;
    }
    
    // 获取可购买的商品列表（按策略排序）
    const availableGoods = getAvailableGoodsForPurchase(route);
    
    if (availableGoods.length === 0) {
        addAutoTradeLog("没有价格合适的商品可购买，开始前往销售城市", "info");
        startAutoTravel(route.sellCity);
        return;
    }
    
    // 购买策略选择的商品
    const targetGood = availableGoods[0];
    
    // 确保商品名称有效
    if (!targetGood || typeof targetGood !== 'string') {
        addAutoTradeLog("无法确定要购买的商品，开始前往销售城市", "error");
        startAutoTravel(route.sellCity);
        return;
    }
    
    const actualPrice = getActualBuyPrice(city, targetGood);
    const routeGood = route.goods.find(g => g && g.good === targetGood);
    const maxBuyPrice = routeGood && routeGood.maxBuyPrice != null && Number.isFinite(routeGood.maxBuyPrice) ? routeGood.maxBuyPrice : Infinity;
    if (actualPrice > maxBuyPrice) {
        addAutoTradeLog(`${targetGood}实际买入价${actualPrice}超过最大${maxBuyPrice}，跳过`, "info");
        startAutoTravel(route.sellCity);
        return;
    }
    const quantity = calculateOptimalPurchaseQuantity(targetGood, route.tradeCapital);
    
    if (quantity > 0) {
        buyGood(targetGood, quantity);
        addAutoTradeLog(`购买了${quantity}个${targetGood}，花费${(actualPrice * quantity).toLocaleString()}星币`, "success");
    } else {
        addAutoTradeLog(`无法购买${targetGood}，资金或空间不足`, "warning");
        
        // 尝试购买下一个商品
        if (availableGoods.length > 1) {
            player.trading.autoTrade.currentRoute.currentGoodIndex = 
                (player.trading.autoTrade.currentRoute.currentGoodIndex + 1) % availableGoods.length;
        } else {
            // 没有其他商品可买，开始旅行
            addAutoTradeLog("所有商品都无法购买，开始前往销售城市", "info");
            startAutoTravel(route.sellCity);
        }
    }
}

function getAvailableGoodsForPurchase(route) {
    const city = player.trading.currentCity;
    const availableGoods = [];
    const strategy = player.trading.autoTrade.purchaseSettings.purchaseStrategy;
    
    // 确保route和route.goods存在
    if (!route || !route.goods || !Array.isArray(route.goods)) {
        return [];
    }
    
    route.goods.forEach(item => {
        // 确保item和item.good存在
        if (!item || !item.good) return;
        
        const good = item.good;
        const price = getActualBuyPrice(city, good); // 使用实际买入价（含关税）
        // 使用用户设置的最大买入价，实际成交价不得超过
        const maxPrice = item.maxBuyPrice;
        
        if (price != null && Number.isFinite(price) && price <= maxPrice) {
            const basePrice = tradingConfig.goods[good].basePrice;
            const priceRatio = price / basePrice;
            
            availableGoods.push({
                good: good,
                price: price,
                basePrice: basePrice,
                priceRatio: priceRatio,
                maxBuyPrice: item.maxBuyPrice
            });
        }
    });
    
    // 根据策略排序
    switch (strategy) {
        case 'priceDesc':
            // 价格降序（先买最贵的）
            availableGoods.sort((a, b) => b.price - a.price);
            break;
        case 'priceAsc':
            // 价格升序（先买最便宜的）
            availableGoods.sort((a, b) => a.price - b.price);
            break;
        case 'profitMargin':
            // 利润率优先（基于基础价格计算潜在利润率）
            availableGoods.sort((a, b) => {
                // 价格接近基础价格的商品有更高潜在利润率
                const aProfitPotential = 1 / a.priceRatio;
                const bProfitPotential = 1 / b.priceRatio;
                return bProfitPotential - aProfitPotential;
            });
            break;
    }
    
    return availableGoods.map(item => item.good);
}


// 计算最优购买数量（使用实际买入价，含关税）
function calculateOptimalPurchaseQuantity(good, availableCapital) {
    const city = player.trading.currentCity;
    const price = getActualBuyPrice(city, good);
    const goodConfig = tradingConfig.goods[good];
    if (!price || price <= 0 || !goodConfig) return 0;
    var cap = Number(availableCapital);
    if (!Number.isFinite(cap) || cap <= 0) cap = player.nightClub.starCoins || 0;
    var funds = player.nightClub.starCoins || 0;
    
    // 基于可用资金计算
    const maxByFunds = Math.floor(Math.min(cap, funds) / price);
    
    // 基于货仓空间计算
    const totalCapacity = getTradingTotalCapacity();
    const availableSlots = totalCapacity - player.trading.warehouse.used;
    const maxBySlots = Math.floor(availableSlots / goodConfig.slots);
    
    // 基于策略计算（价格高的商品少买，价格低的商品多买）
    const basePrice = goodConfig.basePrice;
    const priceRatio = basePrice > 0 ? price / basePrice : 1;
    const strategyMultiplier = priceRatio > 1.5 ? 0.5 : 1;
    
    const optimalQuantity = Math.min(maxByFunds, maxBySlots, 10) * strategyMultiplier;
    const q = Math.max(0, Math.floor(optimalQuantity));
    return q >= 1 ? q : (maxByFunds >= 1 && maxBySlots >= 1 ? 1 : 0);
}

function executeSmartSelling() {
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    
    // 获取可销售的商品列表（按利润率降序）
    const availableGoods = getAvailableGoodsForSale(route);
    
    if (availableGoods.length === 0) {
        addAutoTradeLog("没有利润率合适的商品可销售", "info");
        
        // 决定下一步行动
        decideNextAction();
         
        return;
    }
    
    // 销售利润率最高的商品
    const targetGood = availableGoods[0];
    const price = player.trading.cityPrices[city][targetGood.good];
    const averageCost = player.trading.inventory[targetGood.good].averageCost;
    const profitMargin = ((price - averageCost) / averageCost) * 100;
    
    // 计算销售数量（基于库存和策略）
    const quantity = calculateOptimalSaleQuantity(targetGood.good);
    
    if (quantity > 0) {
        sellGood(targetGood.good, quantity);
        addAutoTradeLog(`出售了${quantity}个${targetGood.good}，利润率${profitMargin.toFixed(1)}%`, "success");
    } else {
        addAutoTradeLog(`无法销售${targetGood.good}，库存不足`, "warning");
        
        // 尝试销售下一个商品
        if (availableGoods.length > 1) {
            availableGoods.shift(); // 移除当前商品
            const nextGood = availableGoods[0];
            // 继续尝试销售下一个商品
        } else {
            // 没有其他商品可卖，决定下一步行动
            decideNextAction();
        }
    }
}
function getAvailableGoodsForSale(route) {
    const city = player.trading.currentCity;
    const availableGoods = [];
    
    // 检查库存中的商品
    Object.keys(player.trading.inventory).forEach(good => {
        if (player.trading.inventory[good].quantity > 0) {
            const price = player.trading.cityPrices[city][good];
            const averageCost = player.trading.inventory[good].averageCost;
            
            if (averageCost > 0) {
                const profitMargin = ((price - averageCost) / averageCost) * 100;
                
                if (profitMargin >= route.minProfitMargin) {
                    availableGoods.push({
                        good: good,
                        profitMargin: profitMargin,
                        price: price,
                        cost: averageCost
                    });
                }
            }
        }
    });
    
    // 按利润率降序排序
    availableGoods.sort((a, b) => b.profitMargin - a.profitMargin);
    
    return availableGoods;
}
function calculateOptimalSaleQuantity(good) {
    const inventory = player.trading.inventory[good];
    if (!inventory) return 0;
    
    const quantity = inventory.quantity;
    
    // 销售策略：利润率越高，销售比例越大
    const currentPrice = player.trading.cityPrices[player.trading.currentCity][good];
    const profitMargin = ((currentPrice - inventory.averageCost) / inventory.averageCost) * 100;
    
    let saleRatio = 0.5; // 默认销售50%
    
    if (profitMargin >= 50) {
        saleRatio = 0.8; // 高利润率时销售80%
    } else if (profitMargin >= 20) {
        saleRatio = 0.6; // 中等利润率时销售60%
    } else if (profitMargin >= 10) {
        saleRatio = 0.4; // 低利润率时销售40%
    }
    
    // 确保至少销售1个，最多销售库存数量
    return Math.max(1, Math.min(quantity, Math.floor(quantity * saleRatio)));
}


// 决定下一步行动（智能决策）
function decideNextAction() {
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    
    // 确保当前城市有效
    if (!city || !tradingConfig.cities[city]) {
        logAction("当前城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都'; // 默认城市
        return;
    }
    
    // 检查当前城市是否有库存
    const hasInventory = Object.keys(player.trading.inventory).some(good => 
        player.trading.inventory[good].quantity > 0
    );
    
    // 检查当前城市是否有可购买的商品
    const hasPurchasableGoods = getAvailableGoodsForPurchase(route).length > 0;
    
    // 灵活路线（无 buyCity/sellCity）：统一用 decideNextDestination 决定下一站
    if (!route.buyCity || !route.sellCity) {
        if (hasPurchasableGoods) {
            player.trading.autoTrade.currentState = 'buying';
            addAutoTradeLog("继续在当前城市寻找可购买的商品", "info");
        } else if (hasInventory) {
            player.trading.autoTrade.currentState = 'selling';
            addAutoTradeLog("有库存，寻找销售机会", "info");
        } else {
            decideNextDestination();
        }
        return;
    }
    // 固定路线决策逻辑
    if (city === route.buyCity) {
        if (hasPurchasableGoods) {
            player.trading.autoTrade.currentState = 'buying';
            addAutoTradeLog("继续在采购城市寻找可购买的商品", "info");
        } else {
            startAutoTravel(route.sellCity);
        }
    } else if (city === route.sellCity) {
        if (hasInventory) {
            const randomDecision = Math.random();
            if (randomDecision < 0.3) {
                goToRandomCity();
            } else if (randomDecision < 0.6) {
                startAutoTravel(route.buyCity);
            } else {
                addAutoTradeLog("利润率不足，等待价格变化", "info");
                setTimeout(() => {
                    if (player.trading.autoTrade.currentState === 'selling') {
                        executeSmartSelling();
                    }
                }, 30000);
            }
        } else {
            startAutoTravel(route.buyCity);
        }
    } else {
        startAutoTravel(route.buyCity);
    }
}
function goToRandomCity() {
    const currentCity = player.trading.currentCity;
    
    // 确保当前城市有效
    if (!currentCity || !tradingConfig.cities[currentCity]) {
        logAction("当前城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都'; // 默认城市
        return;
    }
    
    const connectedCities = tradingConfig.cities[currentCity].connections;
    
    if (connectedCities.length === 0) {
        addAutoTradeLog("没有可连接的城市，返回采购城市", "warning");
        startAutoTravel(player.trading.autoTrade.currentRoute.buyCity);
        return;
    }
    
    // 随机选择一个城市
    const randomIndex = Math.floor(Math.random() * connectedCities.length);
    const randomCity = connectedCities[randomIndex];
    
    // 确保随机城市有效
    if (!randomCity || !tradingConfig.cities[randomCity]) {
        addAutoTradeLog("随机选择的城市无效，返回采购城市", "error");
        startAutoTravel(player.trading.autoTrade.currentRoute.buyCity);
        return;
    }
    
    addAutoTradeLog(`随机选择前往${randomCity}`, "info");
    startAutoTravel(randomCity);
}

function startAutoTradeRoute() {
    if (player.trading.autoTrade.routes.length === 0) {
        addAutoTradeLog("没有设置自动贸易路线", "warning");
        player.trading.autoTrade.enabled = false;
        updateAutoTradeTab();
        return;
    }
    
    // 选择一条路线（简单实现：选择第一条）
    player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0];
    
    // 确保路线有效
    if (!player.trading.autoTrade.currentRoute) {
        addAutoTradeLog("自动贸易路线无效", "error");
        player.trading.autoTrade.enabled = false;
        updateAutoTradeTab();
        return;
    }
    
    // 检查是否已经在采购城市
    if (player.trading.currentCity === player.trading.autoTrade.currentRoute.buyCity) {
        player.trading.autoTrade.currentState = 'buying';
        
        // 修复日志显示 - 不指定具体商品，因为可能采购多种商品
        addAutoTradeLog(`开始在${player.trading.currentCity}采购商品`, "info");
    } else {
        // 需要旅行到采购城市
        startAutoTravel(player.trading.autoTrade.currentRoute.buyCity);
    }
}
function startAutoTravel(destination) {
    // 确保当前城市有效
    if (!player.trading.currentCity || !tradingConfig.cities[player.trading.currentCity]) {
        logAction("当前城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都'; // 默认城市
        return;
    }
    
    // 确保目标城市有效
    if (!destination || !tradingConfig.cities[destination]) {
        addAutoTradeLog("目标城市无效，无法开始旅行", "error");
        player.trading.autoTrade.currentState = 'monitoring';
        return;
    }
    
    if (player.trading.currentCity === destination) {
        // 已经在目的地
        player.trading.autoTrade.currentState = player.trading.autoTrade.currentState === 'buying' ? 'buying' : 'selling';
        return;
    }
    
    // 检查是否连接
    if (!tradingConfig.cities[player.trading.currentCity].connections.includes(destination)) {
        addAutoTradeLog(`无法直接前往${destination}，需要先连接到该城市`, "error");
        player.trading.autoTrade.currentState = 'monitoring';
        return;
    }
    
    const baseTime = tradingConfig.cities[destination].travelTime;
    const speedBonus = player.trading.transport.speedBonus || 0;
    const parkingLevel = (player.parking && typeof player.parking.level === 'number') ? player.parking.level : 0;
    const actualTime = Math.max(0.1, baseTime * (100 - speedBonus) / 100 - Math.min(parkingLevel / 33, 1.21));
    
    player.trading.autoTrade.currentState = 'traveling';
    player.trading.autoTrade.totalTravelTime = actualTime * 60 * 1000;
    player.trading.autoTrade.currentProgress = 0;
    player.trading.travelDestination = destination;
    player.trading.isTraveling = true;
    const tNow = tradingNow();
    player.trading.travelStartTime = tNow;
    player.trading.travelEndTime = tNow + actualTime * 60 * 1000;
    
    addAutoTradeLog(`开始前往${destination}，预计需要${actualTime.toFixed(1)}分钟`, "info");
    
    // 离线模拟时不创建真实定时器，由 simulateOfflineAutoTrade 的循环按模拟时间推进并判定到达
    if (player.trading._simulatedNow != null) return;
    // 确保清除之前的计时器
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
    }
    // 启动旅行计时器
    player.trading.travelInterval = registerInterval(checkTravelStatus, 1000);
}



function updateAutoTravel(elapsed) {
    player.trading.autoTrade.currentProgress += elapsed;
    
    // 更新旅行进度显示
    updateTravelProgress();
    
    // 检查是否到达目的地
    if (player.trading.autoTrade.currentProgress >= player.trading.autoTrade.totalTravelTime) {
        completeAutoTravel();
    }
}

function completeAutoTravel() {
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
        player.trading.travelInterval = null;
    }
    // 记录本次旅行时长（用于短途收益衰减）
    if (player.trading.autoTrade && typeof player.trading.autoTrade.totalTravelTime === 'number') {
        player.trading.lastTravelTimeMinutes = player.trading.autoTrade.totalTravelTime / 60000;
    }
    
    player.trading.currentCity = player.trading.travelDestination;
    const arrivedCityAuto = player.trading.currentCity;
    player.trading.isTraveling = false;
    player.trading.travelDestination = '';
    player.trading.autoTrade.currentProgress = 0;
    
    if (typeof checkGuildQuestProgress === 'function') checkGuildQuestProgress('arrive', null, 0, 0, arrivedCityAuto);
    
    // 重置当前城市停留时间（离线模拟时使用模拟时间）
    player.trading.autoTrade.currentCityStayStart = tradingNow();
    
    // 先检查采购/销售机会并更新状态，再打日志，这样日志里状态会显示 selling/buying/monitoring 而不是 traveling
    checkBothPurchaseAndSaleOpportunities();
    addAutoTradeLog(`已到达${arrivedCityAuto}，开始寻找贸易机会`, "success");
    
    // 离线模拟时不更新 DOM
    if (player.trading._simulatedNow != null) return;
    updateMapTab();
    updateTradingUI();
}
function checkBothPurchaseAndSaleOpportunities() {
    const city = player.trading.currentCity;
    
    // 检查是否有销售机会（优先检查，因为可能已有库存）
    const salableGoods = getAllSalableGoods();
    if (salableGoods.length > 0) {
        addAutoTradeLog(`发现${salableGoods.length}个销售机会，开始销售`, "info");
        player.trading.autoTrade.currentState = 'selling';
        return;
    }
    
    // 检查是否有采购机会
    const purchasableGoods = getAllPurchasableGoods();
    if (purchasableGoods.length > 0) {
        addAutoTradeLog(`发现${purchasableGoods.length}个采购机会，开始采购`, "info");
        player.trading.autoTrade.currentState = 'buying';
        return;
    }
    
    // 如果都没有机会，前往其他城市寻找机会（否则会一直卡在当前城市）
    addAutoTradeLog("当前城市没有发现采购或销售机会，前往其他城市", "info");
    decideNextDestination();
}

function executeAutoBuy() {
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    const price = player.trading.cityPrices[city][route.good];
    
    if (price > route.maxBuyPrice) {
        addAutoTradeLog(`${route.good}价格${price}高于最大购买价${route.maxBuyPrice}，等待降价`, "info");
        return;
    }
    
    // 计算可购买数量
    const availableFunds = Math.min(player.nightClub.starCoins, route.tradeCapital);
    const maxByFunds = Math.floor(availableFunds / price);
    const goodConfig = tradingConfig.goods[route.good];
    const availableSlots = getTradingTotalCapacity() - player.trading.warehouse.used;
    const maxBySlots = Math.floor(availableSlots / goodConfig.slots);
    
    const quantity = Math.min(maxByFunds, maxBySlots, 10);
    
    if (quantity > 0) {
        buyGood(route.good, quantity);
        addAutoTradeLog(`购买了${quantity}个${route.good}，花费${(price * quantity).toLocaleString()}星币`, "success");
        
        // 购买完成后，前往销售城市
        startAutoTravel(route.sellCity);
    } else {
        addAutoTradeLog("资金或货仓空间不足，无法购买", "warning");
    }
}

function validateCity(cityName) {
    return cityName && tradingConfig.cities[cityName];
}
function validateAutoTradeData() {
    // 确保routes数组存在
    if (!player.trading.autoTrade.routes) {
        player.trading.autoTrade.routes = [];
    }
    
    var cur = player.trading.autoTrade.currentRoute;
    var routes = player.trading.autoTrade.routes;
    // 存档加载后 currentRoute 与 routes[i] 是不同引用，用 includes 会误判为「当前路线无效已重置」；改为按内容匹配或直接选用第一条
    if (cur && !routes.includes(cur) && routes.length > 0) {
        var match = routes.find(function (r) {
            if (!r || !cur) return false;
            if (r.buyCity != null && cur.buyCity != null)
                return r.buyCity === cur.buyCity && r.sellCity === cur.sellCity && Array.isArray(r.goods) && Array.isArray(cur.goods) && r.goods.length === cur.goods.length;
            return Array.isArray(r.goods) && Array.isArray(cur.goods) && r.goods.length === cur.goods.length && r.tradeCapital === cur.tradeCapital && (r.minProfitMargin == null ? cur.minProfitMargin == null : r.minProfitMargin === cur.minProfitMargin);
        });
        player.trading.autoTrade.currentRoute = match || routes[0];
        if (player.trading._simulatedNow == null) {
            addAutoTradeLog("已恢复当前路线引用", "info");
        }
    }
    
    // 如果没有当前路线但有保存的路线，选择第一条
    if (!player.trading.autoTrade.currentRoute && player.trading.autoTrade.routes.length > 0) {
        player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0];
        if (player.trading._simulatedNow == null) {
            addAutoTradeLog("已选择第一条路线作为活动路线", "info");
        }
    }
}

function executeAutoSell() {
    const route = player.trading.autoTrade.currentRoute;
    const city = player.trading.currentCity;
    const price = player.trading.cityPrices[city][route.good];
    
    // 检查库存
    if (!player.trading.inventory[route.good] || player.trading.inventory[route.good].quantity === 0) {
        addAutoTradeLog("没有库存可出售，返回采购城市", "info");
        startAutoTravel(route.buyCity);
        return;
    }
    
    // 计算利润率
    const averageCost = player.trading.inventory[route.good].averageCost;
    const profitMargin = ((price - averageCost) / averageCost) * 100;
    
    if (profitMargin < route.minProfitMargin) {
        addAutoTradeLog(`${route.good}利润率${profitMargin.toFixed(1)}%低于最低要求${route.minProfitMargin}%，等待价格上涨`, "info");
        return;
    }
    
    // 出售部分库存
    const quantity = Math.min(player.trading.inventory[route.good].quantity, 5);
    const revenue = price * quantity;
    const cost = averageCost * quantity;
    const profit = revenue - cost;
    
    sellGood(route.good, quantity);
    
    // 更新统计信息
    player.trading.autoTrade.stats.totalProfit += profit;
    player.trading.autoTrade.stats.totalTrades++;
    player.trading.autoTrade.stats.successfulTrades++;
    
    addAutoTradeLog(`出售了${quantity}个${route.good}，获得${revenue.toLocaleString()}星币，利润${profit.toLocaleString()}星币，利润率${profitMargin.toFixed(1)}%`, "success");
    
    // 出售完成后，返回采购城市继续采购
    startAutoTravel(route.buyCity);
}

function createAutoTradeLogModal() {
    const modalHTML = `
    <div id="autoTradeLogModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1002; width: 800px; max-height: 80vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="color: #FFD700; margin: 0;">自动贸易日志</h2>
            <button onclick="closeAutoTradeLog()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        
        <div style="margin-bottom: 15px;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" id="logSearch" placeholder="搜索日志..." style="flex: 1; padding: 5px; background: #333; color: white; border: 1px solid #444; border-radius: 3px;">
                <select id="logFilter" style="padding: 5px; background: #333; color: white; border: 1px solid #444; border-radius: 3px;">
                    <option value="all">所有类型</option>
                    <option value="info">信息</option>
                    <option value="success">成功</option>
                    <option value="warning">警告</option>
                    <option value="error">错误</option>
                </select>
                <button onclick="clearAutoTradeLogs()" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">清空日志</button>
            </div>
        </div>
        
        <div id="autoTradeLogContainer" style="max-height: 400px; overflow-y: auto; background: #222; border-radius: 5px; padding: 10px;">
            <!-- 日志内容将在这里动态生成 -->
        </div>
        
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #444;">
            <h3 style="color: #FFD700;">统计信息</h3>
            <div id="autoTradeStats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <!-- 统计信息将在这里动态生成 -->
            </div>
        </div>
    </div>
    <div id="autoTradeLogOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1001;"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

// 尝试自动买入
function tryAutoBuy(route) {
    const good = route.good;
    const maxPrice = route.maxBuyPrice;
    const currentPrice = getActualBuyPrice(player.trading.currentCity, good);
    
    if (currentPrice != null && Number.isFinite(currentPrice) && currentPrice <= maxPrice) {
        // 计算可购买数量
        const availableFunds = player.nightClub.starCoins * 0.1;
        const maxByFunds = Math.floor(availableFunds / currentPrice);
        const goodConfig = tradingConfig.goods[good];
        const availableSlots = getTradingTotalCapacity() - player.trading.warehouse.used;
        const maxBySlots = Math.floor(availableSlots / goodConfig.slots);
        
        const quantity = Math.min(maxByFunds, maxBySlots, 10);
        
        if (quantity > 0) {
            buyGood(good, quantity);
        }
    }
}

// 尝试自动卖出
function tryAutoSell(route) {
    const good = route.good;
    const minProfitMargin = route.minProfitMargin;
    
    if (player.trading.inventory[good] && player.trading.inventory[good].quantity > 0) {
        const currentPrice = player.trading.cityPrices[player.trading.currentCity][good];
        const averageCost = player.trading.inventory[good].averageCost;
        const profitMargin = ((currentPrice - averageCost) / averageCost) * 100;
        
        if (profitMargin >= minProfitMargin) {
            const quantity = Math.min(player.trading.inventory[good].quantity, 5);
            sellGood(good, quantity);
        }
    }
}

function createInventorySummaryModal() {
    // 检查是否已存在弹窗，避免重复创建
    if (document.getElementById('inventorySummaryModal')) {
        return;
    }
    
    const modalHTML = `
    <div id="inventorySummaryModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; color: white; padding: 20px; border: 3px solid #FFD700; border-radius: 10px; z-index: 1002; width: 800px; max-height: 80vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="color: #FFD700; margin: 0;">库存统计详情</h2>
            <button onclick="closeInventorySummary()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h3>总体统计</h3>
            <div id="overallStats" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; background: #333; padding: 10px; border-radius: 5px;">
                <!-- 总体统计数据将在这里动态生成 -->
            </div>
        </div>
        
        <div>
            <h3>商品详情</h3>
            <div style="max-height: 400px; overflow-y: auto;">
                <table id="inventoryDetails" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #333;">
                            <th style="padding: 10px; text-align: left; border-bottom: 1px solid #444;">商品</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">数量</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">当前价格</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">平均成本</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">总成本</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">当前价值</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">盈亏金额</th>
                            <th style="padding: 10px; text-align: right; border-bottom: 1px solid #444;">盈亏率</th>
                        </tr>
                    </thead>
                    <tbody id="inventoryDetailsBody">
                        <!-- 商品详情将在这里动态生成 -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <div style="margin-top: 20px; text-align: center;">
            <button onclick="sortInventoryBy('profitRate')" style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 3px; cursor: pointer;">按盈亏率排序</button>
        </div>
    </div>
    <div id="inventorySummaryOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1001;"></div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function showInventorySummary() {
    // 确保弹窗已创建
    createInventorySummaryModal();
    
    // 计算库存统计数据
    const stats = calculateInventoryStats();
    
    // 更新总体统计
    updateOverallStats(stats);
    
    // 更新商品详情
    updateInventoryDetails(stats);
    
    // 显示弹窗
    document.getElementById('inventorySummaryModal').style.display = 'block';
    document.getElementById('inventorySummaryOverlay').style.display = 'block';
}

// 关闭库存统计弹窗
function closeInventorySummary() {
    document.getElementById('inventorySummaryModal').style.display = 'none';
    document.getElementById('inventorySummaryOverlay').style.display = 'none';
}

// 获取库存总成本金额（用于库存总金额上限检查）
function getTotalInventoryCost() {
    if (!player.trading || !player.trading.inventory) return 0;
    let total = 0;
    Object.keys(player.trading.inventory).forEach(good => {
        const item = player.trading.inventory[good];
        if (item && typeof item === 'object' && item.totalCost != null && Number.isFinite(item.totalCost)) {
            total += item.totalCost;
        }
    });
    return total;
}

// 计算库存统计数据
function calculateInventoryStats() {
    let totalValue = 0;
    let totalCost = 0;
    let totalProfit = 0;
    let itemCount = 0;
    let bestPerformer = { name: '', profitRate: -Infinity };
    let worstPerformer = { name: '', profitRate: Infinity };
    
    const items = [];
    
    Object.keys(player.trading.inventory).forEach(good => {
        const item = player.trading.inventory[good];
        const currentPrice = player.trading.cityPrices[player.trading.currentCity][good];
        const itemValue = currentPrice * item.quantity;
        const itemCost = item.totalCost;
        const itemProfit = itemValue - itemCost;
        const itemProfitRate = itemCost > 0 ? (itemProfit / itemCost) * 100 : 0;
        
        totalValue += itemValue;
        totalCost += itemCost;
        totalProfit += itemProfit;
        itemCount++;
        
        // 更新最佳和最差表现者
        if (itemProfitRate > bestPerformer.profitRate) {
            bestPerformer = { name: good, profitRate: itemProfitRate };
        }
        if (itemProfitRate < worstPerformer.profitRate) {
            worstPerformer = { name: good, profitRate: itemProfitRate };
        }
        
        // 添加商品详情
        items.push({
            name: good,
            quantity: item.quantity,
            currentPrice: currentPrice,
            averageCost: item.averageCost,
            totalCost: itemCost,
            currentValue: itemValue,
            profit: itemProfit,
            profitRate: itemProfitRate
        });
    });
    
    const overallProfitRate = totalCost > 0 ? (totalProfit / totalCost) * 100 : 0;
    
    return {
        totalValue,
        totalCost,
        totalProfit,
        overallProfitRate,
        itemCount,
        bestPerformer,
        worstPerformer,
        items
    };
}
function updateOverallStats(stats) {
    const overallStats = document.getElementById('overallStats');
    const profitColor = stats.totalProfit >= 0 ? '#4CAF50' : '#f44336';
    const profitSign = stats.totalProfit >= 0 ? '+' : '';
    
    overallStats.innerHTML = `
        <div style="text-align: center;">
            <div style="font-size: 0.9em; color: #aaa;">商品种类</div>
            <div style="font-size: 1.2em; font-weight: bold;">${stats.itemCount}</div>
        </div>
        <div style="text-align: center;">
            <div style="font-size: 0.9em; color: #aaa;">总成本</div>
            <div style="font-size: 1.2em; font-weight: bold;">${stats.totalCost.toLocaleString()}</div>
        </div>
        <div style="text-align: center;">
            <div style="font-size: 0.9em; color: #aaa;">总价值</div>
            <div style="font-size: 1.2em; font-weight: bold;">${stats.totalValue.toLocaleString()}</div>
        </div>
        <div style="text-align: center;">
            <div style="font-size: 0.9em; color: #aaa;">总盈亏</div>
            <div style="font-size: 1.2em; font-weight: bold; color: ${profitColor};">${profitSign}${stats.totalProfit.toLocaleString()}</div>
            <div style="font-size: 0.9em; color: ${profitColor};">${profitSign}${stats.overallProfitRate.toFixed(2)}%</div>
        </div>
    `;
    
    // 添加最佳和最差表现者
    if (stats.itemCount > 0) {
        overallStats.innerHTML += `
            <div style="text-align: center; grid-column: 1 / span 2;">
                <div style="font-size: 0.9em; color: #aaa;">最佳表现</div>
                <div style="font-size: 1em; color: #4CAF50;">${stats.bestPerformer.name}</div>
                <div style="font-size: 0.9em; color: #4CAF50;">+${stats.bestPerformer.profitRate.toFixed(2)}%</div>
            </div>
            <div style="text-align: center; grid-column: 3 / span 2;">
                <div style="font-size: 0.9em; color: #aaa;">最差表现</div>
                <div style="font-size: 1em; color: #f44336;">${stats.worstPerformer.name}</div>
                <div style="font-size: 0.9em; color: #f44336;">${stats.worstPerformer.profitRate.toFixed(2)}%</div>
            </div>
        `;
    }
}
function updateInventoryDetails(stats) {
    const tbody = document.getElementById('inventoryDetailsBody');
    tbody.innerHTML = '';
    
    if (stats.items.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="8" style="text-align: center; padding: 20px; color: #888;">暂无库存商品</td>
            </tr>
        `;
        return;
    }
    
    stats.items.forEach(item => {
        const profitColor = item.profit >= 0 ? '#4CAF50' : '#f44336';
        const profitSign = item.profit >= 0 ? '+' : '';
        
        const row = document.createElement('tr');
        row.style.borderBottom = '1px solid #444';
        row.innerHTML = `
            <td style="padding: 8px;">${item.name}</td>
            <td style="padding: 8px; text-align: right;">${item.quantity}</td>
            <td style="padding: 8px; text-align: right;">${item.currentPrice.toLocaleString()}</td>
            <td style="padding: 8px; text-align: right;">${item.averageCost.toFixed(0)}</td>
            <td style="padding: 8px; text-align: right;">${item.totalCost.toLocaleString()}</td>
            <td style="padding: 8px; text-align: right;">${item.currentValue.toLocaleString()}</td>
            <td style="padding: 8px; text-align: right; color: ${profitColor};">${profitSign}${item.profit.toLocaleString()}</td>
            <td style="padding: 8px; text-align: right; color: ${profitColor};">${profitSign}${item.profitRate.toFixed(2)}%</td>
        `;
        tbody.appendChild(row);
    });
}

// 按指定字段排序库存
function sortInventoryBy(field) {
    const stats = calculateInventoryStats();
    
    stats.items.sort((a, b) => {
        if (field === 'profitRate') {
            return b.profitRate - a.profitRate; // 降序排列
        } else if (field === 'name') {
            return a.name.localeCompare(b.name);
        } else if (field === 'quantity') {
            return b.quantity - a.quantity;
        } else if (field === 'profit') {
            return b.profit - a.profit;
        }
        return 0;
    });
    
    updateInventoryDetails(stats);
}
function addInventorySummaryButton() {
    const inventoryList = document.getElementById('playerInventory');
    if (!document.getElementById('inventorySummaryBtn')) {
        const summaryBtn = document.createElement('button');
        summaryBtn.id = 'inventorySummaryBtn';
        summaryBtn.textContent = '库存统计';
        summaryBtn.style.marginTop = '10px';
        summaryBtn.style.padding = '5px 15px';
        summaryBtn.onclick = showInventorySummary; // 改为显示弹窗
        inventoryList.parentNode.insertBefore(summaryBtn, inventoryList.nextSibling);
    }
}

// 保存自动贸易路线
function saveAutoTradeRoute() {
    const minProfitMargin = parseInt(document.getElementById('minProfitMargin').value);
    const tradeCapital = parseInt(document.getElementById('tradeCapital').value);
    const purchaseStrategy = document.getElementById('purchaseStrategy').value;
    const maxWarehouseUsage = parseInt(document.getElementById('maxWarehouseUsage').value) / 100;
    const priceTolerance = parseInt(document.getElementById('priceTolerance').value) / 100;
    
    // 获取灵活贸易设置
    const maxCityStayTime = parseInt(document.getElementById('maxCityStayTime').value) * 60 * 1000; // 转换为毫秒
    const explorationChance = parseInt(document.getElementById('explorationChance').value) / 100;
    const minProfitThreshold = parseInt(document.getElementById('minProfitThreshold').value);
    const priceMonitoring = document.getElementById('priceMonitoring').value === 'true';
    const maxInventoryValue = parseInt(document.getElementById('maxInventoryValue').value) || 0;
    
    // 获取采购策略设置（含最多商品种类）
    const maxGoods = Math.min(50, Math.max(1, parseInt(document.getElementById('maxGoods').value) || 50));
    
    // 获取选择的商品和对应的最大买入价
    const selectedGoods = [];
    const selectedCheckboxes = document.querySelectorAll('#goodsSelection input[type="checkbox"]:checked');
    
    if (selectedCheckboxes.length === 0) {
        logAction("请至少选择一种商品", "error");
        return;
    }
    
    selectedCheckboxes.forEach(checkbox => {
        const good = checkbox.value;
        const maxPrice = parseInt(document.getElementById(`maxPrice_${good}`).value);
        
        selectedGoods.push({
            good: good,
            maxBuyPrice: maxPrice
        });
    });
    
    // 保存采购策略设置
    player.trading.autoTrade.purchaseSettings.purchaseStrategy = purchaseStrategy;
    player.trading.autoTrade.purchaseSettings.maxWarehouseUsage = maxWarehouseUsage;
    player.trading.autoTrade.purchaseSettings.priceTolerance = priceTolerance;
    
    // 保存采购策略（最多商品种类）
    player.trading.autoTrade.purchaseSettings.maxGoods = maxGoods;
    
    // 保存灵活贸易设置
    player.trading.autoTrade.flexibleTrade.maxCityStayTime = maxCityStayTime;
    player.trading.autoTrade.flexibleTrade.explorationChance = explorationChance;
    player.trading.autoTrade.flexibleTrade.minProfitThreshold = minProfitThreshold;
    player.trading.autoTrade.flexibleTrade.priceMonitoring = priceMonitoring;
    player.trading.autoTrade.flexibleTrade.maxInventoryValue = maxInventoryValue;
    
    const route = {
        goods: selectedGoods,
        minProfitMargin: minProfitMargin,
        tradeCapital: tradeCapital
    };
    
    // 确保routes数组存在
    if (!player.trading.autoTrade.routes) {
        player.trading.autoTrade.routes = [];
    }
    
    player.trading.autoTrade.routes.push(route);
    logAction(`灵活贸易路线已保存，包含${selectedGoods.length}种商品`, "success");
    
    // 如果自动贸易已启用，设置为当前路线
    if (player.trading.autoTrade.enabled) {
        player.trading.autoTrade.currentRoute = route;
        player.trading.autoTrade.currentState = 'idle';
        addAutoTradeLog("已切换到新保存的路线", "info");
    }
    
    // 更新界面
    updateAutoTradeTab();
}

// 货仓升级
function upgradeWarehouse() {
    const currentLevel = player.trading.warehouse.level;
    if (currentLevel >= tradingConfig.warehouseLevels.length) {
        logAction("货仓已达最高等级", "info");
        return;
    }
    
    const nextLevelConfig = tradingConfig.warehouseLevels[currentLevel];
    
    if (player.nightClub.starCoins < nextLevelConfig.cost) {
        logAction(`星币不足！升级需要${nextLevelConfig.cost.toLocaleString()}星币`, "error");
        return;
    }
    
    player.nightClub.starCoins -= nextLevelConfig.cost;
    player.trading.warehouse.level++;
    player.trading.warehouse.capacity = nextLevelConfig.capacity;
    
    logAction(`货仓升级到${player.trading.warehouse.level}级，容量增加到${nextLevelConfig.capacity}格`, "success");
    updateTradingUI();
    updateDisplay();
}
function buyTransport(transportName) {
    const transport = tradingConfig.transports.find(t => t.name === transportName);
    
    if (!transport) {
        logAction("无效的运输工具", "error");
        return;
    }
    
    if (!player.trading.ownedTransports) player.trading.ownedTransports = ['手推车'];
    const isOwned = player.trading.ownedTransports.indexOf(transportName) >= 0;
    
    if (isOwned) {
        // 已拥有：直接切换使用，不扣费
        player.trading.transport = {
            type: transport.name,
            capacityBonus: transport.capacityBonus,
            speedBonus: transport.speedBonus
        };
        logAction(`已切换为使用${transport.name}`, "success");
    } else {
        // 未拥有：需购买
        if (player.nightClub.starCoins < transport.cost) {
            logAction(`星币不足！购买需要${transport.cost.toLocaleString()}星币`, "error");
            return;
        }
        player.nightClub.starCoins -= transport.cost;
        player.trading.tradeVolumeToday -= transport.cost;
        player.trading.ownedTransports.push(transportName);
        player.trading.transport = {
            type: transport.name,
            capacityBonus: transport.capacityBonus,
            speedBonus: transport.speedBonus
        };
        logAction(`购买了${transport.name}，容量+${transport.capacityBonus}格，速度+${transport.speedBonus}%，已拥有可随时切换`, "success");
    }
    updateTradingUI();
    updateDisplay();
}

// 仅切换已拥有的运输工具（不扣费），供界面“切换”按钮调用
function switchTransport(transportName) {
    buyTransport(transportName);
}

// 雇佣雇员
function hireEmployee(employeeType) {
    const employee = tradingConfig.employees.find(e => e.type === employeeType);
    
    if (!employee) {
        logAction("无效的雇员类型", "error");
        return;
    }
    
    var rep = (player.trading.reputation != null) ? player.trading.reputation : 0;
    var ml = (player.trading.merchantLevel != null) ? player.trading.merchantLevel : 1;
    
    if (employee.requirement === 'warehouse30' && player.trading.warehouse.capacity < 30) {
        logAction("需要货仓容量达到30格才能雇佣此雇员", "error");
        return;
    }
    if (employee.requirement === 'warehouse40' && player.trading.warehouse.capacity < 40) {
        logAction("需要货仓容量达到40格才能雇佣此雇员", "error");
        return;
    }
    if (employee.requirement === 'warehouse50' && player.trading.warehouse.capacity < 50) {
        logAction("需要货仓容量达到50格才能雇佣此雇员", "error");
        return;
    }
    if (employee.requirement === 'reputation3' && ml < 3) {
        logAction("需要商人等级达到3级才能雇佣此雇员", "error");
        return;
    }
    if (employee.requirement === 'reputation5' && ml < 5) {
        logAction("需要商人等级达到5级才能雇佣此雇员", "error");
        return;
    }
    if (employee.requirement === 'experiencedRobbery' && !player.trading.hasExperiencedRobbery) {
        logAction("需要经历过强盗事件才能雇佣此雇员", "error");
        return;
    }
    
    if (player.nightClub.starCoins < employee.cost) {
        logAction(`星币不足！雇佣需要${employee.cost.toLocaleString()}星币`, "error");
        return;
    }
    if (player.trading.employees.some(e => e.type === employeeType)) {
        logAction("已经雇佣了此类型的雇员", "error");
        return;
    }
    
    player.nightClub.starCoins -= employee.cost;
    player.trading.tradeVolumeToday -= employee.cost;
    
    var empObj = {
        type: employee.type,
        efficiencyBonus: employee.efficiencyBonus || 0,
        intelligenceDiscount: employee.intelligenceDiscount || 0,
        robberyReduction: employee.robberyReduction || 0,
        sellBonus: employee.sellBonus || 0,
        travelSpeedBonus: employee.travelSpeedBonus || 0,
        spoilReduction: employee.spoilReduction || 0,
        rumorBonus: employee.rumorBonus || 0,
        salary: employee.salary
    };
    player.trading.employees.push(empObj);
    
    if (employee.efficiencyBonus) {
        player.trading.autoTrade.efficiency += employee.efficiencyBonus / 100;
    }
    
    logAction(`雇佣了${employee.type}，每日工资${employee.salary}星币`, "success");
    updateTradingUI();
    updateDisplay();
}

// 雇员效果汇总：卖价加成（百分比）
function getEmployeeSellBonus() {
    var sum = 0;
    if (player.trading.employees && player.trading.employees.length > 0) {
        player.trading.employees.forEach(function(emp) { if (emp.sellBonus) sum += emp.sellBonus; });
    }
    return Math.min(50, sum);
}
// 雇员效果：旅行时间减免（百分比）
function getEmployeeTravelSpeedBonus() {
    var sum = 0;
    if (player.trading.employees && player.trading.employees.length > 0) {
        player.trading.employees.forEach(function(emp) { if (emp.travelSpeedBonus) sum += emp.travelSpeedBonus; });
    }
    return Math.min(25, sum);
}
// 雇员效果：腐败概率减免（百分比）
function getEmployeeSpoilReduction() {
    var sum = 0;
    if (player.trading.employees && player.trading.employees.length > 0) {
        player.trading.employees.forEach(function(emp) { if (emp.spoilReduction) sum += emp.spoilReduction; });
    }
    return Math.min(80, sum);
}
// 雇员效果：传闻涨价倍率加成（如 20 表示在基础 15% 上再乘 (1+20%)=1.2，即 18%）
function getEmployeeRumorBonusMultiplier() {
    var sum = 0;
    if (player.trading.employees && player.trading.employees.length > 0) {
        player.trading.employees.forEach(function(emp) { if (emp.rumorBonus) sum += emp.rumorBonus; });
    }
    return 1 + Math.min(50, sum) / 100;
}

// 切换保险
function toggleInsurance(type) {
    if (!player || !player.trading) return;
    if (!player.trading.insurance) player.trading.insurance = { goods: false, transport: false, bundle: false };
    if (type === 'bundle') {
        player.trading.insurance.bundle = !player.trading.insurance.bundle;
        if (player.trading.insurance.bundle) {
            player.trading.insurance.goods = true;
            player.trading.insurance.transport = true;
            logAction("已购买综合险（货物+运输），保费合计6%", "info");
        } else {
            player.trading.insurance.goods = false;
            player.trading.insurance.transport = false;
            logAction("已取消综合险", "info");
        }
    } else {
        if (player.trading.insurance.bundle) return;
        player.trading.insurance[type] = !player.trading.insurance[type];
        const insuranceCost = type === 'goods' ? 0.05 : 0.03;
        const message = player.trading.insurance[type] ? 
            `已购买${type === 'goods' ? '货物' : '运输'}险，保费${insuranceCost * 100}%` : 
            `已取消${type === 'goods' ? '货物' : '运输'}险`;
        logAction(message, "info");
    }
    updateTradingUI();
}

// 风险偏好
function setRiskAppetite(value) {
    if (!player || !player.trading) return;
    player.trading.riskAppetite = value || 'balanced';
    var msg = value === 'steady' ? '稳健：负面事件概率-10%' : (value === 'aggressive' ? '激进：收益+5%，负面事件+5%' : '平衡');
    logAction("风险偏好已设为：" + msg, "info");
}

// 获取情报折扣（雇员 + 商人等级L3+加成）
function getIntelligenceDiscount() {
    let discount = 0;
    try {
        if (player && player.trading && player.trading.employees && player.trading.employees.length > 0) {
            player.trading.employees.forEach(emp => {
                if (emp.intelligenceDiscount) discount = Math.min(100, discount + emp.intelligenceDiscount);
            });
        }
        var ml = (player && player.trading && player.trading.merchantLevel) ? player.trading.merchantLevel : 1;
        if (ml >= 3) discount = Math.min(100, discount + 10 + (ml - 3));
    } catch (e) {}
    return discount;
}

// 购买情报
function buyIntelligence(city, intelligenceType) {
    const intelligenceConfig = tradingConfig.intelligence[intelligenceType];
    const listPrice = intelligenceConfig.price;
    const discount = getIntelligenceDiscount();
    const price = Math.max(1, Math.floor(listPrice * (1 - discount / 100)));
    
    if (player.nightClub.starCoins < price) {
        logAction(`星币不足！需要${price.toLocaleString()}星币购买情报`, "error");
        return;
    }
    
    player.nightClub.starCoins -= price;
    
    // 假情报率：基础25%，有商业间谍则降低（每30%折扣约降10%假情报率，最低约10%）
    const baseFakeRate = 0.25;
    const fakeRate = Math.max(0.1, baseFakeRate - (discount / 100) * 0.2);
    const isFake = Math.random() < fakeRate;
    const intelligenceData = generateIntelligenceData(city, intelligenceType, isFake);
    
    if (!player.trading.intelligence) player.trading.intelligence = {};
    if (!player.trading.intelligence[city]) player.trading.intelligence[city] = {};
    
    player.trading.intelligence[city][intelligenceType] = {
        data: intelligenceData,
        isFake: isFake,
        purchaseTime: Date.now(),
        expiryTime: Date.now() + intelligenceConfig.duration * 60 * 1000,
        price: price
    };
    
    closeIntelligencePurchaseModal();
    showIntelligenceDetails(city, intelligenceType, intelligenceData, isFake);
    logAction(`购买了${city}的${intelligenceConfig.description}，花费${price.toLocaleString()}星币${discount > 0 ? `（已享${discount}%折扣）` : ''}`, "success");
    updateTradingUI();
}
function generateIntelligenceData(city, intelligenceType, isFake) {
    const data = {};
    
    switch (intelligenceType) {
        case 'marketPrices':
            Object.keys(tradingConfig.goods).forEach(good => {
                const realPrice = player.trading.cityPrices[city][good];
                if (isFake) {
                    const fluctuation = 0.2 + Math.random() * 0.3;
                    const direction = Math.random() > 0.5 ? 1 : -1;
                    data[good] = Math.max(1, Math.round(realPrice * (1 + direction * fluctuation)));
                } else {
                    data[good] = realPrice;
                }
            });
            break;
            
        case 'supplyDemand':
            // 真实数据：根据产地/稀缺计算。产地=供应高，稀缺=需求高
            Object.keys(tradingConfig.goods).forEach(good => {
                const cfg = tradingConfig.goods[good];
                const inProduction = cfg.production && cfg.production.indexOf(city) >= 0;
                const inScarcity = cfg.scarcity && cfg.scarcity.indexOf(city) >= 0;
                if (isFake) {
                    data[good] = {
                        supply: Math.max(0, Math.min(100, 50 + Math.round((Math.random() - 0.5) * 40))),
                        demand: Math.max(0, Math.min(100, 50 + Math.round((Math.random() - 0.5) * 40)))
                    };
                } else {
                    const supply = inProduction ? 75 + Math.round(Math.random() * 20) : (inScarcity ? 25 + Math.round(Math.random() * 25) : 45 + Math.round(Math.random() * 20));
                    const demand = inScarcity ? 75 + Math.round(Math.random() * 20) : (inProduction ? 25 + Math.round(Math.random() * 25) : 45 + Math.round(Math.random() * 20));
                    data[good] = { supply: Math.min(100, supply), demand: Math.min(100, demand) };
                }
            });
            break;
            
        case 'futureTrends':
            const trends = ['上涨', '下跌', '平稳'];
            Object.keys(tradingConfig.goods).forEach(good => {
                if (isFake) {
                    data[good] = trends[Math.floor(Math.random() * trends.length)];
                } else {
                    const currentPrice = player.trading.cityPrices[city][good];
                    const basePrice = tradingConfig.goods[good].basePrice;
                    const ratio = currentPrice / basePrice;
                    if (ratio > 1.2) data[good] = '下跌';
                    else if (ratio < 0.8) data[good] = '上涨';
                    else data[good] = '平稳';
                }
            });
            break;
            
        case 'specialEvents':
            const events = [
                "商会促销活动", "货物运输延误", "市场需求激增", "供应商提价",
                "政府征税调整", "天气影响收成", "新贸易路线开通", "库存积压处理"
            ];
            if (isFake) {
                data.event = events[Math.floor(Math.random() * events.length)];
                data.impact = Math.random() > 0.5 ? "正面" : "负面";
                data.confidence = Math.round(60 + Math.random() * 35);
            } else {
                // 真实：根据当前城市是否为多商品产地/稀缺地生成描述
                const cityCfg = tradingConfig.cities[city];
                const isRemote = cityCfg && (cityCfg.region === '边陲区' || cityCfg.region === '远境' || cityCfg.region === '极远境');
                let productionCount = 0, scarcityCount = 0;
                Object.keys(tradingConfig.goods).forEach(good => {
                    const cfg = tradingConfig.goods[good];
                    if (cfg.production && cfg.production.indexOf(city) >= 0) productionCount++;
                    if (cfg.scarcity && cfg.scarcity.indexOf(city) >= 0) scarcityCount++;
                });
                if (productionCount >= 3) {
                    data.event = "本地为多处产地，供应充足";
                    data.impact = "正面";
                    data.confidence = 88;
                } else if (scarcityCount >= 3) {
                    data.event = "本地多种商品稀缺，价格偏高";
                    data.impact = "负面";
                    data.confidence = 90;
                } else if (isRemote) {
                    data.event = "远境商路稳定，适合长途贩运";
                    data.impact = "中性";
                    data.confidence = 82;
                } else {
                    data.event = "市场正常波动";
                    data.impact = "中性";
                    data.confidence = 85;
                }
            }
            break;
    }
    
    return data;
}
function showIntelligenceDetails(city, intelligenceType, intelligenceData, isFake) {
    // 创建模态框
    const modalId = 'intelligenceModal';
    const overlayId = 'intelligenceOverlay';
    
    // 移除已存在的模态框
    removeElement(modalId);
    removeElement(overlayId);
    
    // 创建覆盖层
    const overlay = document.createElement('div');
    overlay.id = overlayId;
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 10050;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    const modal = document.createElement('div');
    modal.id = modalId;
    modal.style.cssText = `
        background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
        border: 2px solid #FFD700;
        border-radius: 10px;
        padding: 20px;
        width: 80%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        color: white;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        position: relative;
        z-index: 10051;
    `;
    
    // 生成情报内容
    let intelligenceContent = '';
    const intelligenceTitles = {
        'marketPrices': '市场价格情报',
        'supplyDemand': '供需情况情报',
        'futureTrends': '未来趋势预测',
        'specialEvents': '特殊事件情报'
    };
    
    // 标题
    intelligenceContent += `
        <div style="text-align: center; margin-bottom: 20px;">
            <h2 style="color: #FFD700; margin: 0; border-bottom: 2px solid #444; padding-bottom: 10px;">${city} - ${intelligenceTitles[intelligenceType]}</h2>
            <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                获取时间: ${new Date().toLocaleString()}
            </div>
        </div>
    `;
    
    // 根据情报类型生成不同内容
    switch (intelligenceType) {
        case 'marketPrices':
            intelligenceContent += generateMarketPricesContent(intelligenceData);
            break;
        case 'supplyDemand':
            intelligenceContent += generateSupplyDemandContent(intelligenceData);
            break;
        case 'futureTrends':
            intelligenceContent += generateFutureTrendsContent(intelligenceData);
            break;
        case 'specialEvents':
            intelligenceContent += generateSpecialEventsContent(intelligenceData);
            break;
    }
    
    // 添加可信度指示器（但不透露真假）
    intelligenceContent += `
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #444;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="color: #aaa;">情报可信度评估</span>
                <div style="display: flex; align-items: center;">
                    <div style="width: 100px; height: 6px; background: #333; border-radius: 3px; margin-right: 10px;">
                        <div style="width: ${isFake ? (70 + Math.random() * 25) : (80 + Math.random() * 15)}%; height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); border-radius: 3px;"></div>
                    </div>
                    <span style="color: #4CAF50; font-weight: bold;">${isFake ? '高' : '很高'}</span>
                </div>
            </div>
            <div style="font-size: 0.8em; color: #666; margin-top: 5px;">
                基于多方来源交叉验证，仅供参考
            </div>
        </div>
    `;
    
    // 添加免责声明
    intelligenceContent += `
        <div style="margin-top: 15px; padding: 10px; background: rgba(255, 215, 0, 0.1); border-radius: 5px; border-left: 3px solid #FFD700;">
            <div style="font-size: 0.8em; color: #FFD700;">
                <strong>免责声明:</strong> 市场情报基于多方来源收集，实际市场情况可能有所变化。本情报仅供参考，不构成投资建议。
            </div>
        </div>
    `;
    
    // 添加关闭按钮
    intelligenceContent += `
        <div style="text-align: center; margin-top: 20px;">
            <button onclick="closeIntelligenceModal()" style="background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                关闭情报
            </button>
        </div>
    `;
    
    modal.innerHTML = intelligenceContent;
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // 添加动画效果
    setTimeout(() => {
        modal.style.transform = 'scale(1)';
        modal.style.opacity = '1';
    }, 10);
}

// 生成市场价格情报内容（按机会排序：偏低优先，便于采购决策）
function generateMarketPricesContent(data) {
    const rows = [];
    Object.keys(data).forEach(good => {
        const price = data[good];
        const basePrice = tradingConfig.goods[good].basePrice;
        const ratio = basePrice > 0 ? price / basePrice : 1;
        let status = ratio > 1.2 ? '偏高' : (ratio < 0.8 ? '偏低' : '正常');
        let statusColor = ratio > 1.2 ? '#f44336' : (ratio < 0.8 ? '#4CAF50' : '#FFC107');
        rows.push({ good, price, ratio, status, statusColor });
    });
    rows.sort((a, b) => a.ratio - b.ratio);
    
    let content = `
        <div style="margin-bottom: 15px;">
            <h3 style="color: #FFD700; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">商品价格信息（按性价比排序）</h3>
            <div style="max-height: 300px; overflow-y: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: rgba(255, 215, 0, 0.1);">
                            <th style="padding: 8px; text-align: left; border-bottom: 1px solid #333;">商品</th>
                            <th style="padding: 8px; text-align: right; border-bottom: 1px solid #333;">价格 (星币)</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">状态</th>
                        </tr>
                    </thead>
                    <tbody>
    `;
    rows.forEach(r => {
        content += `
            <tr style="border-bottom: 1px solid #333;">
                <td style="padding: 8px;">${r.good}</td>
                <td style="padding: 8px; text-align: right; font-weight: bold;">${r.price.toLocaleString()}</td>
                <td style="padding: 8px; text-align: center; color: ${r.statusColor};">${r.status}</td>
            </tr>
        `;
    });
    content += `
                    </tbody>
                </table>
            </div>
        </div>
    `;
    return content;
}

// 生成供需情况情报内容
function generateSupplyDemandContent(data) {
    let content = `
        <div style="margin-bottom: 15px;">
            <h3 style="color: #FFD700; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">市场供需情况</h3>
            <div style="max-height: 300px; overflow-y: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: rgba(255, 215, 0, 0.1);">
                            <th style="padding: 8px; text-align: left; border-bottom: 1px solid #333;">商品</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">供应量</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">需求量</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">市场状况</th>
                        </tr>
                    </thead>
                    <tbody>
    `;
    
    Object.keys(data).forEach(good => {
        const supply = data[good].supply;
        const demand = data[good].demand;
        const balance = supply - demand;
        
        let condition = '';
        let conditionColor = '';
        
        if (balance > 20) {
            condition = '供过于求';
            conditionColor = '#f44336';
        } else if (balance < -20) {
            condition = '供不应求';
            conditionColor = '#4CAF50';
        } else {
            condition = '供需平衡';
            conditionColor = '#FFC107';
        }
        
        content += `
            <tr style="border-bottom: 1px solid #333;">
                <td style="padding: 8px;">${good}</td>
                <td style="padding: 8px; text-align: center;">
                    <div style="display: inline-block; width: 50px; height: 10px; background: #333; border-radius: 5px; position: relative;">
                        <div style="width: ${supply}%; height: 100%; background: linear-gradient(90deg, #2196F3, #03A9F4); border-radius: 5px;"></div>
                    </div>
                    <span style="margin-left: 5px;">${supply}%</span>
                </td>
                <td style="padding: 8px; text-align: center;">
                    <div style="display: inline-block; width: 50px; height: 10px; background: #333; border-radius: 5px; position: relative;">
                        <div style="width: ${demand}%; height: 100%; background: linear-gradient(90deg, #E91E63, #AD1457); border-radius: 5px;"></div>
                    </div>
                    <span style="margin-left: 5px;">${demand}%</span>
                </td>
                <td style="padding: 8px; text-align: center; color: ${conditionColor}; font-weight: bold;">${condition}</td>
            </tr>
        `;
    });
    
    content += `
                    </tbody>
                </table>
            </div>
        </div>
    `;
    
    return content;
}

// 生成未来趋势情报内容
function generateFutureTrendsContent(data) {
    let content = `
        <div style="margin-bottom: 15px;">
            <h3 style="color: #FFD700; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">价格趋势预测</h3>
            <div style="max-height: 300px; overflow-y: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: rgba(255, 215, 0, 0.1);">
                            <th style="padding: 8px; text-align: left; border-bottom: 1px solid #333;">商品</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">预期趋势</th>
                            <th style="padding: 8px; text-align: center; border-bottom: 1px solid #333;">建议操作</th>
                        </tr>
                    </thead>
                    <tbody>
    `;
    
    Object.keys(data).forEach(good => {
        const trend = data[good];
        
        let trendColor = '';
        let suggestion = '';
        
        switch (trend) {
            case '上涨':
                trendColor = '#4CAF50';
                suggestion = '考虑买入';
                break;
            case '下跌':
                trendColor = '#f44336';
                suggestion = '考虑卖出';
                break;
            case '平稳':
                trendColor = '#FFC107';
                suggestion = '持有观望';
                break;
        }
        
        content += `
            <tr style="border-bottom: 1px solid #333;">
                <td style="padding: 8px;">${good}</td>
                <td style="padding: 8px; text-align: center; color: ${trendColor}; font-weight: bold;">${trend}</td>
                <td style="padding: 8px; text-align: center;">${suggestion}</td>
            </tr>
        `;
    });
    
    content += `
                    </tbody>
                </table>
            </div>
        </div>
    `;
    
    return content;
}

// 生成特殊事件情报内容
function generateSpecialEventsContent(data) {
    let content = `
        <div style="margin-bottom: 15px;">
            <h3 style="color: #FFD700; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">特殊市场事件</h3>
            <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">${data.event}</div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span>预期影响: <strong style="color: ${data.impact === '正面' ? '#4CAF50' : data.impact === '负面' ? '#f44336' : '#FFC107'}">${data.impact}</strong></span>
                    <span>可信度: <strong>${data.confidence}%</strong></span>
                </div>
                <div style="font-size: 0.9em; color: #aaa;">
                    ${generateEventDescription(data.event, data.impact)}
                </div>
            </div>
        </div>
    `;
    
    return content;
}

// 生成事件描述
function generateEventDescription(event, impact) {
    const descriptions = {
        "商会促销活动": "本地商会即将举办大型促销活动，预计将刺激消费者需求。",
        "货物运输延误": "主要贸易路线出现运输问题，可能导致商品短缺。",
        "市场需求激增": "近期市场需求异常增长，价格可能上涨。",
        "供应商提价": "主要供应商宣布提高批发价格，成本将增加。",
        "政府征税调整": "政府计划调整贸易税率，可能影响商品价格。",
        "天气影响收成": "不利天气条件影响农作物收成，供应可能减少。",
        "新贸易路线开通": "新贸易路线即将开通，可能带来新的商机。",
        "库存积压处理": "商家处理积压库存，可能提供折扣优惠。",
        "市场正常波动": "市场处于正常波动周期，无明显特殊事件。",
        "本地为多处产地，供应充足": "该城市为多种商品产地，进货价格有优势，适合在此采购后运往稀缺地销售。",
        "本地多种商品稀缺，价格偏高": "该城市多种商品依赖外地输入，售价偏高，适合作为销售目的地而非采购地。",
        "远境商路稳定，适合长途贩运": "远境城市商路稳定，高价商品在此有产地优势，适合规划长途跑商路线。"
    };
    return descriptions[event] || "市场情报显示特殊事件可能影响贸易环境。";
}
function closeIntelligenceModal() {
    const modal = document.getElementById('intelligenceModal');
    const overlay = document.getElementById('intelligenceOverlay');
    
    if (modal) {
        modal.style.transform = 'scale(0.9)';
        modal.style.opacity = '0';
        setTimeout(() => {
            if (modal.parentNode) {
                modal.parentNode.removeChild(modal);
            }
        }, 300);
    }
    
    if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        }, 300);
    }
}

// 添加移除元素的辅助函数
function removeElement(elementId) {
    const element = document.getElementById(elementId);
    if (element && element.parentNode) {
        element.parentNode.removeChild(element);
    }
}


// 添加情报购买界面
function showIntelligencePurchaseOptions(city) {
    if (typeof initTradingConfig === 'function') initTradingConfig();
    const modalId = 'intelligencePurchaseModal';
    const overlayId = 'intelligencePurchaseOverlay';
    
    // 移除已存在的模态框
    removeElement(modalId);
    removeElement(overlayId);
    
    // 创建覆盖层
    const overlay = document.createElement('div');
    overlay.id = overlayId;
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 10050;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    overlay.onclick = function(e) { if (e.target === overlay) closeIntelligencePurchaseModal(); };
    
    const modal = document.createElement('div');
    modal.id = modalId;
    modal.style.cssText = `
        background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
        border: 2px solid #FFD700;
        border-radius: 10px;
        padding: 20px;
        width: 80%;
        max-width: 500px;
        color: white;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        position: relative;
        z-index: 10051;
    `;
    modal.onclick = function(e) { e.stopPropagation(); };
    
    // 生成情报购买选项
    modal.innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
            <h2 style="color: #FFD700; margin: 0;">${city} - 情报购买</h2>
            <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                选择您需要的情报类型
            </div>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr; gap: 10px; margin-bottom: 20px;">
            ${generateIntelligenceOptions(city)}
        </div>
        
        <div style="text-align: center;">
            <button onclick="closeIntelligencePurchaseModal()" style="background: #f44336; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                取消
            </button>
        </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // 添加动画效果
    setTimeout(() => {
        modal.style.transform = 'scale(1)';
        modal.style.opacity = '1';
    }, 10);
}

// 生成情报选项
function generateIntelligenceOptions(city) {
    const intelligenceTypes = tradingConfig.intelligence;
    const discount = getIntelligenceDiscount();
    let optionsHtml = '';
    
    Object.keys(intelligenceTypes).forEach(type => {
        const config = intelligenceTypes[type];
        const listPrice = config.price;
        const actualPrice = Math.max(1, Math.floor(listPrice * (1 - discount / 100)));
        const titles = {
            'marketPrices': '市场价格情报',
            'supplyDemand': '供需情况情报',
            'futureTrends': '未来趋势预测',
            'specialEvents': '特殊事件情报'
        };
        
        optionsHtml += `
            <div style="background: rgba(255,255,255,0.05); border-radius: 5px; padding: 15px; cursor: pointer; transition: all 0.3s ease; border-left: 4px solid #FFD700;" 
                 onclick="buyIntelligence('${city}', '${type}')">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-weight: bold; color: #FFD700;">${titles[type]}</div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">${config.description}</div>
                    </div>
                    <div style="text-align: right;">
                        ${actualPrice < listPrice ? `<div style="font-size: 0.75em; color: #888; text-decoration: line-through;">${listPrice.toLocaleString()}</div>` : ''}
                        <div style="font-size: 1.2em; font-weight: bold; color: #4CAF50;">${actualPrice.toLocaleString()}</div>
                        <div style="font-size: 0.8em; color: #aaa;">星币${discount > 0 ? ' · 已享' + discount + '%折扣' : ''}</div>
                    </div>
                </div>
                <div style="margin-top: 10px; font-size: 0.8em; color: #666;">
                    有效期: ${config.duration}分钟
                </div>
            </div>
        `;
    });
    
    return optionsHtml;
}

// 关闭情报购买模态框
function closeIntelligencePurchaseModal() {
    const modal = document.getElementById('intelligencePurchaseModal');
    const overlay = document.getElementById('intelligencePurchaseOverlay');
    
    if (modal) {
        modal.style.transform = 'scale(0.9)';
        modal.style.opacity = '0';
        setTimeout(() => {
            if (modal.parentNode) {
                modal.parentNode.removeChild(modal);
            }
        }, 300);
    }
    
    if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        }, 300);
    }
}

// 检查情报过期
function checkIntelligenceExpiry() {
    const now = Date.now();
    
    if (player.trading.intelligence.advanced && player.trading.intelligence.advancedExpire < now) {
        player.trading.intelligence.advanced = false;
        logAction("高级情报已过期", "info");
    }
    
    if (player.trading.intelligence.full && player.trading.intelligence.fullExpire < now) {
        player.trading.intelligence.full = false;
        logAction("全境情报已过期", "info");
    }
}

// 每日重置
function resetDailyTrading() {
    player.trading.tradeVolumeToday = 0; // 重置为0，而不是正数
    player.trading.tradeCountToday = 0;
    
    // 支付雇员工资
    let totalSalary = 0;
    player.trading.employees.forEach(employee => {
        totalSalary += employee.salary;
    });
    
    if (totalSalary > 0) {
        if (player.nightClub.starCoins >= totalSalary) {
            player.nightClub.starCoins -= totalSalary;
            // 工资支出也减少今日利润
            player.trading.tradeVolumeToday -= totalSalary;
            logAction(`支付雇员工资${totalSalary.toLocaleString()}星币`, "info");
        } else {
            // 资金不足，解雇所有雇员
            logAction("资金不足支付工资，所有雇员已被解雇", "warning");
            player.trading.employees = [];
        }
    }
    
    // 支付运输工具维护费
    const transport = tradingConfig.transports.find(t => t.name === player.trading.transport.type);
    if (transport && transport.maintenance > 0) {
        if (player.nightClub.starCoins >= transport.maintenance) {
            player.nightClub.starCoins -= transport.maintenance;
            // 维护费支出也减少今日利润
            player.trading.tradeVolumeToday -= transport.maintenance;
            logAction(`支付${transport.name}维护费${transport.maintenance.toLocaleString()}星币`, "info");
        } else {
            // 降级到免费运输工具
            logAction("资金不足支付维护费，运输工具降级为手推车", "warning");
            player.trading.transport = {
                type: '手推车',
                capacityBonus: 5,
                speedBonus: 0
            };
        }
    }
}

// 跑商系统主循环
function tradingSystemLoop() {
    // 每小时更新一次价格
    const pricesRefreshed = updateCityPrices();
    if (pricesRefreshed) {
        var ui = document.getElementById('tradingSystemUI');
        var marketTab = document.getElementById('marketTab');
        if (ui && ui.style.display === 'block' && marketTab && marketTab.classList.contains('active') && typeof updateMarketTab === 'function') {
            updateMarketTab();
        }
    }
    
    // 检查情报过期
    checkIntelligenceExpiry();
    
    // 检查旅行状态
    if (player.trading.isTraveling) {
        checkTravelStatus();
    }
    
    // 更新自动贸易（如果启用）
    if (player.trading.autoTrade.enabled) {
        runAutoTrade();
        
        // 更新界面显示（每秒更新一次进度）
        if (Date.now() % 1000 < 50) { // 大约每秒更新一次
            updateAutoTradeTab();
        }
    }
    
    
}

function startAutoTradeSystem() {
    if (player.trading.autoTrade.enabled && !window.autoTradeInterval) {
        window.autoTradeInterval = registerInterval(() => {
            try {
                if (player.trading.autoTrade.enabled) {
                    // 定期验证数据
                    validateAutoTradeData();
                    
                    // 运行自动贸易
                    runAutoTrade();
                }
            } catch (error) {
                console.error("自动贸易系统错误:", error);
                // 发生错误时尝试恢复
                handleTradingError(error, "autoTradeSystem");
            }
        }, 1000); // 每秒执行一次
    }
}
function safeUpdateUI() {
    // 检查自动贸易界面是否可见
    if (isElementVisible('autoTab')) {
        updateAutoTradeTab();
    }
    
    // 检查世界地图界面是否可见
    if (isElementVisible('mapTab')) {
        updateMapTab();
    }
    
    // 检查市场界面是否可见
    if (isElementVisible('marketTab')) {
        updateMarketTab();
    }
}
// 停止自动贸易系统
function stopAutoTradeSystem() {
    if (window.autoTradeInterval) {
        clearInterval(window.autoTradeInterval);
        window.autoTradeInterval = null;
    }
}
function isElementVisible(elementId) {
    const element = document.getElementById(elementId);
    return element && element.offsetParent !== null;
}
function stopProgressUpdateTimer() {
    if (window.autoTradeProgressInterval) {
        clearInterval(window.autoTradeProgressInterval);
        window.autoTradeProgressInterval = null;
    }
}
// 初始化跑商系统
function initTradingSystem() {
    // 确保玩家数据存在
    if (!player.trading) {
        initTradingData();
    }
    
    // 启动主循环（每分钟检查一次）
    if (!window.tradingInterval) {
        window.tradingInterval = registerInterval(tradingSystemLoop, 60000);
    }
}
window.addEventListener('error', function(event) {
    console.error("全局错误:", event.error);
    // 可以在这里添加错误报告或用户通知
});

// 添加页面卸载时的清理函数
window.addEventListener('beforeunload', function() {
    // 先写入离开时间戳（跑商离线用），避免 saveGame 未执行完页面就被关闭导致离线时长为 0
    try { localStorage.setItem('goldGameLastUnload', String(Date.now())); } catch (e) {}
    // 保存游戏状态
    saveGame();
    
    // 停止所有定时器
    try { stopProgressUpdateTimer(); stopAutoTradeSystem(); } catch (e) {}
    if (player && player.trading && player.trading.autoTrade && player.trading.autoTrade.backgroundInterval) {
        clearInterval(player.trading.autoTrade.backgroundInterval);
        player.trading.autoTrade.backgroundInterval = null;
    }
    // 统一清理所有已注册的定时器，避免页面关闭后仍运行
    try {
        if (window._gameIntervals && window._gameIntervals.length) {
            window._gameIntervals.forEach(function(id) { clearInterval(id); });
            window._gameIntervals.length = 0;
        }
    } catch (e) {}
});

// 修改页面可见性变化处理
document.addEventListener('visibilitychange', function() {
    const game = player.investmentGame;
    if (!game) return;
    
    if (document.hidden) {
        // 页面隐藏时停止定时器
        if (game.priceUpdateTimer) {
            clearInterval(game.priceUpdateTimer);
            game.priceUpdateTimer = null;
        }
        if (game.chartUpdateTimer) {
            clearInterval(game.chartUpdateTimer);
            game.chartUpdateTimer = null;
        }
    } else {
        // 页面显示时重新开始定时器
        if (document.getElementById('investmentGameUI').style.display === 'block') {
            startPriceSimulation();
        }
    }
});
function enterBackgroundMode() {
    if (!player.trading.autoTrade.enabled) return;
    
    try {
        player.trading.autoTrade.backgroundMode = true;
        player.trading.autoTrade.lastBackgroundUpdate = Date.now();
        
        // 停止前台定时器
        stopProgressUpdateTimer();
        
        // 启动后台定时器（频率较低，节省资源）
        if (!player.trading.autoTrade.backgroundInterval) {
            player.trading.autoTrade.backgroundInterval = registerInterval(() => {
                try {
                    updateBackgroundTrade();
                } catch (error) {
                    console.error("后台贸易更新错误:", error);
                    // 发生错误时停止后台定时器
                    if (player.trading.autoTrade.backgroundInterval) {
                        clearInterval(player.trading.autoTrade.backgroundInterval);
                        player.trading.autoTrade.backgroundInterval = null;
                    }
                }
            }, 5000); // 每5秒更新一次
        }
        
        addAutoTradeLog("自动贸易已切换到后台模式", "info");
    } catch (error) {
        console.error("进入后台模式错误:", error);
    }
}

// 退出后台模式
function exitBackgroundMode() {
    if (!player.trading.autoTrade.enabled) return;
    
    try {
        player.trading.autoTrade.backgroundMode = false;
        
        // 停止后台定时器
        if (player.trading.autoTrade.backgroundInterval) {
            clearInterval(player.trading.autoTrade.backgroundInterval);
            player.trading.autoTrade.backgroundInterval = null;
        }
        
        // 启动前台定时器
        startProgressUpdateTimer();
        
        // 更新界面
        updateAutoTradeTab();
        
        addAutoTradeLog("自动贸易已切换到前台模式", "info");
    } catch (error) {
        console.error("退出后台模式错误:", error);
    }
}
function updateBackgroundTrade() {
    if (!player.trading.autoTrade.enabled || !player.trading.autoTrade.backgroundMode) return;
    
    const now = Date.now();
    const elapsed = now - player.trading.autoTrade.lastBackgroundUpdate;
    player.trading.autoTrade.lastBackgroundUpdate = now;
    
    // 模拟时间流逝，处理后台运行
    simulateBackgroundTrade(elapsed);
}

// 模拟后台贸易
function simulateBackgroundTrade(elapsed) {
    // 验证数据
    validateAutoTradeData();
    
    // 根据时间流逝模拟贸易活动
    const timeScale = elapsed / 1000; // 转换为秒
    
    switch (player.trading.autoTrade.currentState) {
        case 'traveling':
            // 模拟旅行进度
            player.trading.autoTrade.currentProgress += elapsed;
            
            // 检查是否到达目的地
            if (player.trading.autoTrade.currentProgress >= player.trading.autoTrade.totalTravelTime) {
                completeBackgroundTravel();
            }
            break;
            
        case 'buying':
            // 模拟采购（简化处理）
            if (Math.random() < 0.3 * timeScale) { // 30%概率每秒
                simulateBackgroundPurchase();
            }
            break;
            
        case 'selling':
            // 模拟销售（简化处理）
            if (Math.random() < 0.4 * timeScale) { // 40%概率每秒
                simulateBackgroundSale();
            }
            break;
            
        default:
            // 空闲状态，尝试开始新的贸易路线
            if (Math.random() < 0.1 * timeScale) { // 10%概率每秒
                startAutoTradeRoute();
            }
    }
    
    // 保存游戏状态（后台运行期间定期保存）
    if (Math.random() < 0.05) { // 5%概率每次更新时保存
        saveGame();
    }
}
function completeBackgroundTravel() {
    // 确保目标城市有效
    if (!player.trading.travelDestination || !tradingConfig.cities[player.trading.travelDestination]) {
        logAction("后台旅行：目标城市无效，重置为默认城市", "error");
        player.trading.currentCity = '王都';
        player.trading.travelDestination = '';
        player.trading.isTraveling = false;
        return;
    }
    
    const route = player.trading.autoTrade.currentRoute;
    if (!route) return;
    
    player.trading.currentCity = player.trading.travelDestination;
    player.trading.isTraveling = false;
    player.trading.travelDestination = '';
    player.trading.autoTrade.currentProgress = 0;
    
    // 根据目的地决定下一步行动（灵活路线无 buyCity/sellCity 时用检查机会）
    if (route.buyCity && route.sellCity) {
        if (player.trading.currentCity === route.buyCity) {
            player.trading.autoTrade.currentState = 'buying';
            addAutoTradeLog(`后台运行：已到达${route.buyCity}，开始采购`, "info");
        } else if (player.trading.currentCity === route.sellCity) {
            player.trading.autoTrade.currentState = 'selling';
            addAutoTradeLog(`后台运行：已到达${route.sellCity}，开始销售`, "info");
        }
    } else if (typeof checkBothPurchaseAndSaleOpportunities === 'function') {
        checkBothPurchaseAndSaleOpportunities();
        addAutoTradeLog(`后台运行：已到达${player.trading.currentCity}，寻找贸易机会`, "info");
    }
    
    // 触发随机事件（简化版）
    if (Math.random() < 0.2) {
        triggerBackgroundRandomEvent();
    }
}
// 模拟后台采购
function simulateBackgroundPurchase() {
    const route = player.trading.autoTrade.currentRoute;
    if (!route || player.trading.autoTrade.currentState !== 'buying') return;
    
    const city = player.trading.currentCity;
    
    // 随机选择一个商品
    const availableGoods = getAvailableGoodsForPurchase(route);
    if (availableGoods.length === 0) {
        if (route.sellCity) startAutoTravel(route.sellCity);
        else if (typeof decideNextDestination === 'function') decideNextDestination();
        return;
    }
    
    const randomGood = availableGoods[Math.floor(Math.random() * availableGoods.length)];
    const price = player.trading.cityPrices[city][randomGood];
    const quantity = Math.floor(Math.random() * 5) + 1; // 随机购买1-5个
    
    // 模拟购买
    if (player.nightClub.starCoins >= price * quantity) {
        buyGood(randomGood, quantity);
        addAutoTradeLog(`后台运行：购买了${quantity}个${randomGood}，花费${(price * quantity).toLocaleString()}星币`, "success");
        
        // 检查货仓使用率
        const totalCapacity = getTradingTotalCapacity();
        const usageRate = player.trading.warehouse.used / totalCapacity;
        
        if (usageRate >= player.trading.autoTrade.purchaseSettings.maxWarehouseUsage) {
            addAutoTradeLog("后台运行：货仓已满，开始前往其他城市", "info");
            if (route.sellCity) startAutoTravel(route.sellCity);
            else if (typeof decideNextDestination === 'function') decideNextDestination();
        }
    }
}

// 模拟后台销售
function simulateBackgroundSale() {
    const route = player.trading.autoTrade.currentRoute;
    if (!route || player.trading.autoTrade.currentState !== 'selling') return;
    
    const city = player.trading.currentCity;
    
    // 检查库存
    const availableGoods = getAvailableGoodsForSale(route);
    if (availableGoods.length === 0) {
        if (route.buyCity) startAutoTravel(route.buyCity);
        else if (typeof decideNextDestination === 'function') decideNextDestination();
        return;
    }
    
    const targetGood = availableGoods[0].good;
    const price = player.trading.cityPrices[city][targetGood];
    const quantity = Math.min(player.trading.inventory[targetGood].quantity, Math.floor(Math.random() * 3) + 1); // 随机销售1-3个
    
    // 模拟销售
    if (quantity > 0) {
        sellGood(targetGood, quantity);
        addAutoTradeLog(`后台运行：出售了${quantity}个${targetGood}，获得${(price * quantity).toLocaleString()}星币`, "success");
        
        // 检查是否还有库存
        if (Object.keys(player.trading.inventory).every(good => player.trading.inventory[good].quantity === 0)) {
            addAutoTradeLog("后台运行：库存已清空，前往其他城市", "info");
            if (route.buyCity) startAutoTravel(route.buyCity);
            else if (typeof decideNextDestination === 'function') decideNextDestination();
        }
    }
}

// 触发后台随机事件
function triggerBackgroundRandomEvent() {
    const events = [
        {
            type: 'priceChange',
            message: "市场价格波动",
            effect: () => {
                // 随机调整一些商品价格
                Object.keys(tradingConfig.goods).forEach(good => {
                    if (Math.random() < 0.3) {
                        const change = (Math.random() - 0.5) * 0.2; // ±10%变化
                        player.trading.cityPrices[player.trading.currentCity][good] *= (1 + change);
                    }
                });
                addAutoTradeLog("后台运行：市场价格发生波动", "info");
            }
        },
        {
            type: 'specialOffer',
            message: "特价优惠",
            effect: () => {
                // 随机选择一个商品打折
                const goods = Object.keys(tradingConfig.goods);
                const randomGood = goods[Math.floor(Math.random() * goods.length)];
                const discount = 0.1 + Math.random() * 0.2; // 10%-30%折扣
                player.trading.cityPrices[player.trading.currentCity][randomGood] *= (1 - discount);
                
                addAutoTradeLog(`后台运行：${randomGood}特价优惠，降价${(discount * 100).toFixed(0)}%`, "success");
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    if (Math.random() < 0.1) { // 10%概率触发事件
        event.effect();
    }
}
function handleTradingError(error, context) {
    console.error(`自动贸易错误 (${context}):`, error);
    addAutoTradeLog(`自动贸易系统遇到问题: ${error.message}`, "error");
    
    // 尝试恢复系统
    try {
        recoverFromAutoTradeError();
        updateAutoTradeTab();
    } catch (recoveryError) {
        console.error("自动贸易恢复失败:", recoveryError);
        player.trading.autoTrade.enabled = false;
        addAutoTradeLog("自动贸易已停用，请重新设置路线", "error");
    }
}

// 在游戏加载时初始化
window.addEventListener('load', function() {
    // 延迟初始化，确保玩家数据已加载
    setTimeout(() => {
        initTradingData();
          initTradingConfig();
        // 验证自动贸易数据
        validateAutoTradeData();
        
        // 检查是否有后台运行的自动贸易
        if (player.trading.autoTrade.enabled) {
            // 自动贸易在运行，检查是否在后台模式
            if (document.hidden) {
                player.trading.autoTrade.backgroundMode = true;
            } else {
                player.trading.autoTrade.backgroundMode = false;
                startProgressUpdateTimer();
            }
            
            // 启动自动贸易系统
            startAutoTradeSystem();
        }
        
        updateAutoTradeTab();
    }, 1000);
});
function recoverFromAutoTradeError() {
    logAction("自动贸易系统遇到问题，正在尝试恢复", "warning");
    
    // 重置自动贸易状态
    player.trading.autoTrade.currentState = 'idle';
    player.trading.autoTrade.currentProgress = 0;
    
    // 验证并修复城市数据
    validateAutoTradeData();
    
    // 如果当前城市无效，设置为默认城市
    if (!validateCity(player.trading.currentCity)) {
        player.trading.currentCity = '王都';
    }
    
    // 清除无效的旅行目的地
    if (player.trading.travelDestination && !validateCity(player.trading.travelDestination)) {
        player.trading.travelDestination = '';
    }
    
    // 停止所有旅行
    player.trading.isTraveling = false;
    if (player.trading.travelInterval) {
        clearInterval(player.trading.travelInterval);
        player.trading.travelInterval = null;
    }
    
    // 尝试重新开始自动贸易
    if (player.trading.autoTrade.enabled && player.trading.autoTrade.routes.length > 0) {
        player.trading.autoTrade.currentRoute = player.trading.autoTrade.routes[0];
        startAutoTradeRoute();
    }
    
    logAction("自动贸易系统已恢复", "success");
}

// 符文属性配置
const runeAttributes = {
    types: ['critRate', 'health', 'critDamage','critRate', 'combo', 'attack', 'critRate', 'critDamage', 'combo', 'worldExp', 'combo'],
    ranges: {
        attack: { min: 0.01, max: 2.00 }, // 1% - 200%
        health: { min: 0.01, max: 2.00 },
        critDamage: { min: 0.01, max: 2.00 },
        combo: { min: 1, max: 10 }, // 1-10次连击
        critRate: { min: 0.01, max: 0.05 },
        worldExp: { min: 0.01, max: 0.20 } // 1% - 20%
    },
    names: {
        attack: '攻击加成',
        health: '生命加成',
        critDamage: '爆伤加成',
        combo: '连击次数',
        critRate: '暴击率',
        worldExp: '世界经验'
    }
};

// 材料名称映射
const materialNames = {
    gold: '金',
    wood: '木',
    water: '水',
    fire: '火',
    earth: '土',
    light: '光',
    dark: '暗',
    wind: '风',
    ice: '冰',
    electric: '电'
};

// 切换符文系统界面
function toggleRuneSystem() {
     if (player.level.ascentionCounta < 3) {
        alert("需要达到轮回3转才能开启符文系统！");
        return;
    }
    const overlay = document.getElementById('runeSystemOverlay');
    const ui = document.getElementById('runeSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateRuneSystemUI();
    }
}

// 更新符文系统界面
function updateRuneSystemUI() {
    // 更新材料数量显示
    Object.keys(player.runes.materials).forEach(material => {
        document.getElementById(`runeMaterial${material.charAt(0).toUpperCase() + material.slice(1)}`).textContent = 
            player.runes.materials[material];
    });
    
    // 更新材料选择界面
    updateMaterialSelection();
    
    // 更新已选材料显示
    updateSelectedMaterials();
    
    // 更新装备的符文显示
    updateEquippedRune();
    
    // 更新符文背包显示
    updateRuneInventory();
    
    // 更新符文升级信息
    updateRuneUpgradeInfo();
}

// 更新材料选择界面
function updateMaterialSelection() {
    const container = document.getElementById('runeMaterialSelection');
    container.innerHTML = '';
    
    // 材料掉落概率配置
    const materialDropRates = {
        gold: 0.50,
        wood: 0.25,
        water: 0.125,
        fire: 0.0625,
        earth: 0.03125,
        light: 0.015625,
        dark: 0.0078125,
        wind: 0.00390625,
        ice: 0.001953125,
        electric: 0.0009765625
    };
    
    Object.keys(player.runes.materials).forEach(material => {
        const count = player.runes.materials[material];
        const selectedCount = player.runes.selectedMaterials.filter(m => m === material).length;
        const remainingCount = count - selectedCount;
        const dropRate = materialDropRates[material] * 100; // 转换为百分比
        
        const button = document.createElement('button');
        button.innerHTML = `
            <div>${materialNames[material]}</div>
            <div>拥有: ${remainingCount}</div>
            <div style="font-size: 10px; color: #d8bfd8;">掉落率: ${dropRate.toFixed(4)}%</div>
        `;
        button.style.cssText = `
            padding: 5px;
            border: 1px solid #9370db;
            background: ${remainingCount > 0 ? 'rgba(147, 112, 219, 0.3)' : 'rgba(128, 128, 128, 0.3)'};
            color: ${remainingCount > 0 ? '#e6e6fa' : '#888'};
            border-radius: 3px;
            cursor: ${remainingCount > 0 ? 'pointer' : 'not-allowed'};
            width: 80px;
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        `;
        
        if (remainingCount > 0) {
            button.onclick = () => selectMaterial(material);
        }
        
        container.appendChild(button);
    });
}


// 选择材料
function selectMaterial(material) {
    if (player.runes.selectedMaterials.length >= 5) {
        logAction('最多只能选择5个材料！', 'error');
        return;
    }
    
    // 检查该材料是否还有剩余
    const selectedCount = player.runes.selectedMaterials.filter(m => m === material).length;
    const totalCount = player.runes.materials[material];
    
    if (selectedCount >= totalCount) {
        logAction(`${materialNames[material]}材料不足！`, 'error');
        return;
    }
    
    player.runes.selectedMaterials.push(material);
    updateSelectedMaterials();
    updateMaterialSelection();
}

// 更新已选材料显示
function updateSelectedMaterials() {
    const container = document.getElementById('selectedMaterials');
    
    if (player.runes.selectedMaterials.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center;">请选择5个材料</div>';
        return;
    }
    
    // 统计每种材料的数量
    const materialCounts = {};
    player.runes.selectedMaterials.forEach(material => {
        materialCounts[material] = (materialCounts[material] || 0) + 1;
    });
    
    container.innerHTML = Object.entries(materialCounts).map(([material, count]) => `
        <div style="display: inline-block; background: rgba(147, 112, 219, 0.5); padding: 5px 10px; margin: 2px; border-radius: 3px; border: 1px solid #9370db;">
            ${materialNames[material]} ×${count}
            <button onclick="removeMaterial('${material}')" style="background: none; border: none; color: #ff6b6b; cursor: pointer; margin-left: 5px;">×</button>
        </div>
    `).join('');
    addClearMaterialsButton();
    // 显示可能的属性预览（隐藏具体数值）
    if (player.runes.selectedMaterials.length === 5) {
        const preview = generateRunePreview(player.runes.selectedMaterials);
        container.innerHTML += `
            <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; border: 1px dashed #9370db;">
                <div style="color: #ffd700; font-weight: bold;">符文预览: ${preview.name}</div>
                ${preview.attributes.map(attr => `
                    <div style="font-size: 12px;">${attr.name}: ${attr.displayValue}</div>
                `).join('')}
                <div style="font-size: 10px; color: #d8bfd8; margin-top: 5px;">
                    合成后显示具体数值
                </div>
            </div>
        `;
    }
}

// 移除已选材料
function removeMaterial(material) {
    // 找到最后一个该材料的索引
    const lastIndex = player.runes.selectedMaterials.lastIndexOf(material);
    if (lastIndex !== -1) {
        player.runes.selectedMaterials.splice(lastIndex, 1);
        updateSelectedMaterials();
        updateMaterialSelection();
    }
}
// 生成符文预览（不实际创建符文）
function generateRunePreview(materials) {
    const seed = materials.sort().join('');
    const hash = stringHash(seed);
    const random = seededRandom(hash);
    
    // 确保属性类型数组不为空
    const attributeTypes = [...runeAttributes.types];
    if (attributeTypes.length === 0) {
        console.error("属性类型数组为空！");
        return { name: "未知符文", attributes: [] };
    }
    
    const selectedAttributes = [];
    
    // 确保总是生成5种属性类型
    for (let i = 0; i < 5; i++) {
        const index = Math.floor(random() * attributeTypes.length);
        // 确保索引在有效范围内
        const safeIndex = Math.max(0, Math.min(index, attributeTypes.length - 1));
        selectedAttributes.push(attributeTypes[safeIndex]);
    }
    
    const attributes = selectedAttributes.map(type => {
        return {
            type: type,
            name: runeAttributes.names[type],
            // 预览时不显示具体数值，只显示属性类型
            displayValue: '???'
        };
    });
    
    // 生成预览名称
    const previewName = generateRuneName(materials, hash);
    
    return {
        name: previewName,
        attributes: attributes
    };
}

// 合成符文
function synthesizeRune() {
    if (player.runes.selectedMaterials.length !== 5) {
        logAction('需要选择5个材料才能合成符文！', 'error');
        return;
    }
    
    // 验证材料组合
    if (!validateMaterialCombination(player.runes.selectedMaterials)) {
        logAction('无效的材料组合！', 'error');
        return;
    }
    
    // 检查材料是否足够（考虑重复材料）
    const materialCounts = {};
    player.runes.selectedMaterials.forEach(material => {
        materialCounts[material] = (materialCounts[material] || 0) + 1;
    });
    
    for (const [material, needed] of Object.entries(materialCounts)) {
        if (player.runes.materials[material] < needed) {
            logAction(`${materialNames[material]}材料不足！需要${needed}个，只有${player.runes.materials[material]}个`, 'error');
            return;
        }
    }
    
    // 消耗材料（考虑重复材料）
    for (const [material, needed] of Object.entries(materialCounts)) {
        player.runes.materials[material] -= needed;
    }
    
    // 生成符文
    const newRune = generateRune(player.runes.selectedMaterials);
    
    // 检查符文是否生成成功
    if (!newRune) {
        logAction('符文生成失败！', 'error');
        return;
    }
    
    player.runes.inventory.push(newRune);
    
    // 清空已选材料
    player.runes.selectedMaterials = [];
    
    logAction(`成功合成符文: ${newRune.name}`, 'success');
    updateRuneSystemUI();
    saveGame();
}
function generateRune(materials) {
    // 根据材料组合生成种子
    const seed = materials.sort().join('');
    const hash = stringHash(seed);
    
    // 使用种子生成确定性随机属性类型
    const random = seededRandom(hash);
    
    // 确保属性类型数组不为空
    const attributeTypes = [...runeAttributes.types];
    if (attributeTypes.length === 0) {
        console.error("属性类型数组为空！");
        return null;
    }
    
    const selectedAttributes = [];
    
    // 确保总是生成5种属性类型
    for (let i = 0; i < 5; i++) {
        const index = Math.floor(random() * attributeTypes.length);
        // 确保索引在有效范围内
        const safeIndex = Math.max(0, Math.min(index, attributeTypes.length - 1));
        selectedAttributes.push(attributeTypes[safeIndex]);
    }
    
    // 生成属性值（保持类型固定，数值有随机幅度）
    const attributes = selectedAttributes.map(type => {
        const range = runeAttributes.ranges[type];
        let value;
        
        if (type === 'combo') {
            // 连击次数为整数，确保在范围内
            value = Math.floor(range.min + Math.random() * (range.max - range.min + 1));
            value = Math.max(range.min, Math.min(range.max, value));
        } else {
            // 其他属性为百分比，确保在范围内
            value = range.min + Math.random() * (range.max - range.min);
            value = Math.max(range.min, Math.min(range.max, value));
            value = Math.round(value * 100) / 100; // 保留两位小数
        }
        
        return {
            type: type,
            value: value,
            displayValue: type === 'combo' ? `${value}次` : `${(value * 100).toFixed(1)}%`,
            name: runeAttributes.names[type]
        };
    });
    
    // 生成符文名称（基于材料组合）
    const runeName = generateRuneName(materials, hash);
    
    // 创建符文对象
    return {
        id: 'rune_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: runeName,
        materials: [...materials],
        attributes: attributes,
        level: player.runes.level,
        isLocked: false,
        createdAt: Date.now()
    };
}

// 生成符文名称
function generateRuneName(materials, hash) {
    // 神秘符文前缀
    const mysticalPrefixes = [
        '虚空', '混沌', '永恒', '不朽', '星辰', '命运', '时空', '创世', '灭世', '轮回',
        '天界', '冥界', '神域', '魔域', '圣光', '暗影', '元素', '本源', '真理', '法则',
        '秩序', '混沌', '起源', '终焉', '无限', '绝对', '至高', '无上', '至尊', '究极',
        '洪荒', '太古', '鸿蒙', '太初', '元始', '造化', '玄黄', '阴阳', '五行', '八卦',
        '天道', '地道', '人道', '神道', '魔道', '仙道', '佛道', '妖道', '鬼道', '圣道'
    ];
    
    // 神秘符文中缀
    const mysticalInfixes = [
        '吞噬', '湮灭', '创造', '毁灭', '平衡', '秩序', '混沌', '时间', '空间', '命运',
        '生命', '死亡', '光明', '黑暗', '火焰', '寒冰', '风暴', '大地', '雷霆', '海洋',
        '灵魂', '精神', '意志', '力量', '智慧', '勇气', '荣耀', '信仰', '希望', '绝望',
        '真理', '谎言', '现实', '虚幻', '过去', '未来', '现在', '因果', '轮回', '宿命',
        '天命', '劫难', '造化', '机缘', '气运', '功德', '业力', '报应', '涅槃', '超脱'
    ];
    
    // 神秘符文后缀
    const mysticalSuffixes = [
        '符文', '印记', '徽记', '圣印', '咒文', '法印', '图腾', '刻印', '符石', '神印',
        '宝珠', '晶石', '灵珠', '魂石', '魔印', '道符', '灵符', '神符', '天符', '地符',
        '龙符', '凤印', '麒麟印', '白虎符', '朱雀印', '玄武符', '青龙印', '白虎印',
        '之眼', '之心', '之魂', '之灵', '之源', '之核', '之种', '之泪', '之血', '之骨',
        '圣典', '秘典', '天书', '地书', '人书', '神书', '魔书', '仙书', '佛书', '妖书'
    ];
    
    // 使用哈希值选择前缀、中缀和后缀
    const prefixIndex = Math.abs(hash % mysticalPrefixes.length);
    const infixIndex = Math.abs((hash >> 8) % mysticalInfixes.length);
    const suffixIndex = Math.abs((hash >> 16) % mysticalSuffixes.length);
    
    // 根据重复材料的数量决定是否使用中缀
    const materialCounts = {};
    materials.forEach(material => {
        materialCounts[material] = (materialCounts[material] || 0) + 1;
    });
    
    const maxRepeat = Math.max(...Object.values(materialCounts));
    const useInfix = maxRepeat >= 3; // 如果有材料重复3次或以上，使用中缀
    
    if (useInfix) {
        return `${mysticalPrefixes[prefixIndex]}${mysticalInfixes[infixIndex]}${mysticalSuffixes[suffixIndex]}`;
    } else {
        return `${mysticalPrefixes[prefixIndex]}${mysticalSuffixes[suffixIndex]}`;
    }
}

// 字符串哈希函数
function stringHash(str) {
    let hash = 0;
    if (str.length === 0) return hash;
    
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // 转换为32位整数
    }
    
    // 确保哈希值不为0
    if (hash === 0) hash = 1;
    
    return hash;
}

// 种子随机数生成器
function seededRandom(seed) {
    // 确保种子不为0
    if (seed === 0) seed = 1;
    
    return function() {
        seed = (seed * 9301 + 49297) % 233280;
        // 确保返回值不为0
        return Math.max(0.0001, seed / 233280);
    };
}  
// 添加符文品质颜色系统
function getRuneQualityColor(rune) {
    // 根据符文等级和属性数量决定品质颜色
    const totalValue = rune.attributes.reduce((sum, attr) => {
        if (attr.type === 'combo') {
            return sum + attr.value * 10; // 连击次数价值较高
        } else {
            return sum + attr.value * 100; // 百分比属性价值
        }
    }, 0);
    
    const averageValue = totalValue / rune.attributes.length;
    
    if (averageValue > 80) {
        return '#ffd700'; // 传说品质（金色）
    } else if (averageValue > 60) {
        return '#9370db'; // 史诗品质（紫色）
    } else if (averageValue > 40) {
        return '#1e90ff'; // 稀有品质（蓝色）
    } else if (averageValue > 20) {
        return '#32cd32'; // 优秀品质（绿色）
    } else {
        return '#ffffff'; // 普通品质（白色）
    }
}
// 添加材料组合验证函数
function validateMaterialCombination(materials) {
    if (!materials || materials.length !== 5) {
        console.error("无效的材料组合：材料数量不正确");
        return false;
    }
    
    // 检查所有材料是否有效
    for (const material of materials) {
        if (!player.runes.materials.hasOwnProperty(material)) {
            console.error("无效的材料：", material);
            return false;
        }
    }
    
    return true;
}
// 更新装备的符文显示
function updateEquippedRune() {
    const container = document.getElementById('equippedRune');
    
    if (!player.runes.equipped) {
        container.innerHTML = '<div style="color: #888; text-align: center;">未装备符文</div>';
        return;
    }
    
    const rune = player.runes.equipped;
    const runeBonuses = calculateRuneBonuses();
    const qualityColor = getRuneQualityColor(rune);
    
    // 统计属性重复次数
    const attributeCounts = {};
    rune.attributes.forEach(attr => {
        attributeCounts[attr.type] = (attributeCounts[attr.type] || 0) + 1;
    });
    
    container.innerHTML = `
        <div style="font-size: 18px; font-weight: bold; color: ${qualityColor}; margin-bottom: 10px; text-shadow: 0 0 5px ${qualityColor};">${rune.name}</div>
        <div style="margin-bottom: 10px; max-height: 120px; overflow-y: auto;">
            ${rune.attributes.map((attr, index) => {
                const count = attributeCounts[attr.type];
                const countText = count > 1 ? ` (x${count})` : '';
                return `<div>${attr.name}: ${attr.displayValue}${countText}</div>`;
            }).join('')}
        </div>
        <div style="font-size: 12px; color: #d8bfd8; margin-bottom: 5px;">
            等级: ${rune.level} (${(rune.level * 100).toFixed(0)}%加成)
        </div>
        <div style="font-size: 11px; color: #90ee90; margin-bottom: 10px;">
            当前总加成:<br>
            ${runeBonuses.attack > 0 ? `攻击: +${(runeBonuses.attack * 100).toFixed(1)}%<br>` : ''}
            ${runeBonuses.health > 0 ? `生命: +${(runeBonuses.health * 100).toFixed(1)}%<br>` : ''}
            ${runeBonuses.critRate > 0 ? `暴击率: +${(runeBonuses.critRate * 100).toFixed(2)}%<br>` : ''}
            ${runeBonuses.critDamage > 0 ? `爆伤: +${(runeBonuses.critDamage * 100).toFixed(1)}%<br>` : ''}
            ${runeBonuses.combo > 0 ? `连击: +${runeBonuses.combo.toFixed(0)}次<br>` : ''}
            ${runeBonuses.worldExp > 0 ? `世界经验: +${(runeBonuses.worldExp * 100).toFixed(1)}%<br>` : ''}
        </div>
        <button onclick="unequipRune()" style="background: linear-gradient(to bottom, #dc143c, #8b0000); color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-top: 5px;">卸下</button>
    `;
}
function showRuneSynthesisHelp() {
    showCustomConfirm(`
        <div style="text-align: left;">
            <h3 style="color: #ffd700;">符文合成说明</h3>
            <p><strong>材料选择:</strong> 选择5个材料（可以重复使用同一种材料）</p>
            <p><strong>重复材料:</strong> 使用重复材料会影响符文属性和名称</p>
            <ul>
                <li>重复材料会增加符文分解价值</li>
                <li>重复3次以上的材料会生成更复杂的符文名称</li>
                <li>重复材料组合会生成独特的符文属性</li>
            </ul>
            <p><strong>属性生成:</strong> 每个符文有5条属性，可能重复</p>
            <p><strong>符文命名:</strong> 使用神秘词汇组合，不包含材料名称</p>
            <p><strong>属性范围:</strong></p>
            <ul>
                <li>攻击/生命/爆伤/暴击率: 1% - 100%</li>
                <li>连击次数: 1-10次</li>
                <li>世界经验: 1% - 10%</li>
            </ul>
            <p><strong>符文升级:</strong> 使用秘法符文升级，每级提升100%属性</p>
            <p><strong>重复属性:</strong> 相同属性会叠加，分解时价值更高</p>
            <p><strong>预览隐藏:</strong> 合成前只显示属性类型，不显示具体数值</p>
        </div>
    `, () => {});
}
function addClearMaterialsButton() {
    const container = document.getElementById('selectedMaterials');
    if (player.runes.selectedMaterials.length > 0) {
        container.innerHTML += `
            <div style="margin-top: 10px;">
                <button onclick="clearSelectedMaterials()" style="background: #dc143c; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px;">清空已选材料</button>
            </div>
        `;
    }
}

// 清空已选材料函数
function clearSelectedMaterials() {
    player.runes.selectedMaterials = [];
    updateSelectedMaterials();
    updateMaterialSelection();
}

// 更新符文背包显示
function updateRuneInventory() {
    const container = document.getElementById('runeInventory');
    container.innerHTML = '';
    
    let filteredRunes = player.runes.inventory;
    
    // 应用过滤器
    if (player.runes.currentFilter !== 'all') {
        filteredRunes = filteredRunes.filter(rune => {
            return rune.attributes.some(attr => attr.type === player.runes.currentFilter);
        });
    }
    
    if (filteredRunes.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; grid-column: 1 / -1;">符文背包为空</div>';
        return;
    }
    
    filteredRunes.forEach(rune => {
        const runeElement = document.createElement('div');
        runeElement.style.cssText = `
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
            border: 2px solid ${rune.isLocked ? '#ffd700' : '#9370db'};
            position: relative;
            box-shadow: 0 0 10px ${rune.isLocked ? '#ffd700' : '#9370db'};
        `;
        
        // 统计属性重复次数
        const attributeCounts = {};
        rune.attributes.forEach(attr => {
            attributeCounts[attr.type] = (attributeCounts[attr.type] || 0) + 1;
        });
        
        runeElement.innerHTML = `
            <div style="font-weight: bold; color: ${rune.isLocked ? '#ffd700' : '#e6e6fa'}; margin-bottom: 5px; text-shadow: 0 0 5px ${rune.isLocked ? '#ffd700' : '#9370db'};">${rune.name}</div>
            <div style="font-size: 12px; margin-bottom: 5px; max-height: 100px; overflow-y: auto;">
                ${rune.attributes.map((attr, index) => {
                    const count = attributeCounts[attr.type];
                    const countText = count > 1 ? ` (x${count})` : '';
                    return `<div>${attr.name}: ${attr.displayValue}${countText}</div>`;
                }).join('')}
            </div>
            <div style="font-size: 11px; color: #d8bfd8;">
                等级: ${rune.level} (${(rune.level * 100).toFixed(0)}%加成)
            </div>
            <div style="margin-top: 10px; display: flex; justify-content: space-between;">
                <button onclick="equipRune('${rune.id}')" style="background: #9370db; color: white; border: none; padding: 3px 8px; border-radius: 2px; cursor: pointer; font-size: 11px;">装备</button>
                <button onclick="toggleLockRune('${rune.id}')" style="background: ${rune.isLocked ? '#ffd700' : '#6a5acd'}; color: white; border: none; padding: 3px 8px; border-radius: 2px; cursor: pointer; font-size: 11px;">
                    ${rune.isLocked ? '解锁' : '锁定'}
                </button>
                <button onclick="decomposeRune('${rune.id}')" style="background: #dc143c; color: white; border: none; padding: 3px 8px; border-radius: 2px; cursor: pointer; font-size: 11px;">分解</button>
            </div>
        `;
        
        container.appendChild(runeElement);
    });
}

// 装备符文
function equipRune(runeId) {
    const runeIndex = player.runes.inventory.findIndex(r => r.id === runeId);
    if (runeIndex === -1) return;
    
    player.runes.equipped = player.runes.inventory[runeIndex];
    logAction(`装备了符文: ${player.runes.equipped.name}`, 'success');
    updatePlayerBattleStats();
    updateRuneSystemUI();
    saveGame();
}

// 卸下符文
function unequipRune() {
    if (!player.runes.equipped) return;
    
    logAction(`卸下了符文: ${player.runes.equipped.name}`, 'info');
    player.runes.equipped = null;
    updatePlayerBattleStats();
    updateRuneSystemUI();
    saveGame();
}

// 切换符文锁定状态
function toggleLockRune(runeId) {
    const runeIndex = player.runes.inventory.findIndex(r => r.id === runeId);
    if (runeIndex === -1) return;
    
    player.runes.inventory[runeIndex].isLocked = !player.runes.inventory[runeIndex].isLocked;
    logAction(`${player.runes.inventory[runeIndex].isLocked ? '锁定' : '解锁'}了符文: ${player.runes.inventory[runeIndex].name}`, 'info');
    updateRuneSystemUI();
    saveGame();
}

// 分解符文
function decomposeRune(runeId) {
    const runeIndex = player.runes.inventory.findIndex(r => r.id === runeId);
    if (runeIndex === -1) return;
    
    const rune = player.runes.inventory[runeIndex];
    
    if (rune.isLocked) {
        logAction('无法分解已锁定的符文！', 'error');
        return;
    }
    
    // 计算分解奖励（星币）
    const starCoins = calculateRuneDecomposeValue(rune);
    player.nightClub.starCoins += starCoins;
    
    // 从背包中移除
    player.runes.inventory.splice(runeIndex, 1);
    
    logAction(`分解了符文: ${rune.name}，获得${starCoins}星币`, 'success');
    updateRuneSystemUI();
    updateDisplay();
    saveGame();
}

// 计算符文分解价值
function calculateRuneDecomposeValue(rune) {
    // 基础价值 + 属性价值 + 等级价值 + 重复材料奖励
    let value = 1; // 基础价值
    
    // 统计材料重复次数
    const materialCounts = {};
    rune.materials.forEach(material => {
        materialCounts[material] = (materialCounts[material] || 0) + 1;
    });
    
    // 材料重复奖励
    const maxRepeat = Math.max(...Object.values(materialCounts));
    if (maxRepeat > 1) {
        value *= Math.pow(1.2, maxRepeat - 1); // 每重复一次增加20%基础价值
    }
    
    // 统计属性重复次数
    const attributeCounts = {};
    rune.attributes.forEach(attr => {
        attributeCounts[attr.type] = (attributeCounts[attr.type] || 0) + 1;
    });
    
    // 属性价值
    rune.attributes.forEach(attr => {
        let attrValue;
        
        if (attr.type === 'combo') {
            attrValue = attr.value * 5; // 每次连击价值5星币
        } else {
            attrValue = attr.value * 1; // 每1%属性价值1星币
        }
        
        // 重复属性奖励
        const count = attributeCounts[attr.type];
        if (count > 1) {
            attrValue *= Math.pow(1.5, count - 1); // 每重复一次增加50%价值
        }
        
        value += attrValue;
    });
    
    // 等级价值
    value *= rune.level;
    
    return Math.floor(value);
}


// 一键分解所有未锁定的符文
function decomposeAllRunes() {
    const unlockedRunes = player.runes.inventory.filter(rune => !rune.isLocked);
    
    if (unlockedRunes.length === 0) {
        logAction('没有可分解的符文！', 'error');
        return;
    }
    
    showCustomConfirm(`确定要分解所有未锁定的符文吗？共${unlockedRunes.length}个，将获得大量星币！`, (confirmed) => {
        if (confirmed) {
            let totalStarCoins = 0;
            
            // 分解所有未锁定的符文
            player.runes.inventory = player.runes.inventory.filter(rune => {
                if (rune.isLocked) {
                    return true; // 保留锁定的符文
                }
                
                totalStarCoins += calculateRuneDecomposeValue(rune);
                return false; // 移除未锁定的符文
            });
            
            player.nightClub.starCoins += totalStarCoins;
            
            logAction(`一键分解了${unlockedRunes.length}个符文，获得${totalStarCoins}星币`, 'success');
            updateRuneSystemUI();
            updateDisplay();
            saveGame();
        }
    });
}

// 切换符文过滤器
function toggleRuneFilter() {
    const filterBtn = document.getElementById('runeFilterBtn');
    const filters = ['all', 'attack', 'health', 'critDamage', 'combo', 'critRate', 'worldExp'];
    const filterNames = {
        all: '显示全部',
        attack: '攻击加成',
        health: '生命加成',
        critDamage: '爆伤加成',
        combo: '连击次数',
        critRate: '暴击率',
        worldExp: '世界经验'
    };
    
    const currentIndex = filters.indexOf(player.runes.currentFilter);
    const nextIndex = (currentIndex + 1) % filters.length;
    player.runes.currentFilter = filters[nextIndex];
    
    filterBtn.textContent = filterNames[player.runes.currentFilter];
    updateRuneInventory();
}

// 更新符文升级信息
function updateRuneUpgradeInfo() {
    document.getElementById('runeLevel').textContent = player.runes.level;
    document.getElementById('runeUpgradeCost').textContent = player.runes.upgradeCost;
    
    // 检查是否有足够的秘法符文
    const upgradeBtn = document.getElementById('upgradeRuneBtn');
    if (player.items.fuwen1 >= player.runes.upgradeCost) {
        upgradeBtn.disabled = false;
        upgradeBtn.style.opacity = '1';
    } else {
        upgradeBtn.disabled = true;
        upgradeBtn.style.opacity = '0.5';
    }
}

// 升级符文
function upgradeRune() {
    if (player.items.fuwen1 < player.runes.upgradeCost) {
        logAction('秘法符文不足！', 'error');
        return;
    }
    
    player.items.fuwen1 -= player.runes.upgradeCost;
    player.runes.level++;
    player.runes.upgradeCost += 10;
    
    // 更新所有符文的等级
    player.runes.inventory.forEach(rune => {
        rune.level = player.runes.level;
    });
    
    if (player.runes.equipped) {
        player.runes.equipped.level = player.runes.level;
    }
    
    logAction(`符文等级提升至 ${player.runes.level}级，所有符文属性提升100%！`, 'success');
     updatePlayerBattleStats();
    updateRuneSystemUI();
    updateDisplay();
    saveGame();
}

// 在次元4以上掉落材料
function dropRuneMaterials() {
    if (player.dimensionLevel < 4) return;
    
    // 只有1%的几率触发材料掉落
    if (Math.random() >= 0.001) return;
    
    // 材料掉落概率配置（从50%到0.01%）
    const materialDropRates = {
        gold: 0.50,      // 50%
        wood: 0.25,      // 25%
        water: 0.125,    // 12.5%
        fire: 0.0625,    // 6.25%
        earth: 0.03125,  // 3.125%
        light: 0.015625, // 1.5625%
        dark: 0.0078125, // 0.78125%
        wind: 0.00390625, // 0.390625%
        ice: 0.001953125, // 0.1953125%
        electric: 0.0009765625 // 0.09765625% (约0.1%)
    };
    
    // 计算总概率（用于归一化）
    const totalRate = Object.values(materialDropRates).reduce((sum, rate) => sum + rate, 0);
    
    // 生成随机数决定掉落哪个材料
    const rand = Math.random() * totalRate;
    let cumulativeRate = 0;
    let droppedMaterial = null;
    
    // 选择掉落的材料
    for (const [material, rate] of Object.entries(materialDropRates)) {
        cumulativeRate += rate;
        if (rand <= cumulativeRate) {
            droppedMaterial = material;
            break;
        }
    }
    
    // 增加材料数量
    if (droppedMaterial) {
        player.runes.materials[droppedMaterial]++;
        
        // 记录掉落日志
        logAction(`获得了符文材料: ${materialNames[droppedMaterial]}`, 'success');
        
        // 更新界面显示
        updateRuneSystemUI();
    }
}
function calculateRuneBonuses() {
    const bonuses = {
        attack: 0,
        health: 0,
        critDamage: 0,
        combo: 0,
        critRate: 0,
        worldExp: 0
    };
    
    if (player.runes.equipped) {
        const rune = player.runes.equipped;
        const levelMultiplier = rune.level; // 等级加成倍数
        
        rune.attributes.forEach(attr => {
            // 应用等级加成
            const baseValue = Math.max(0, attr.value);
            const finalValue = baseValue * levelMultiplier;
            
            switch(attr.type) {
                case 'attack':
                    bonuses.attack += finalValue;
                    break;
                case 'health':
                    bonuses.health += finalValue;
                    break;
                case 'critDamage':
                    bonuses.critDamage += finalValue;
                    break;
                case 'combo':
                    bonuses.combo +=  Math.floor(finalValue);
                    break;
                case 'critRate':
                    bonuses.critRate += finalValue;
                    break;
                case 'worldExp':
                    bonuses.worldExp += finalValue;
                    break;
            }
        });
    }
    
    return bonuses;
}
// 职业配置
const classConfig = {
    warrior: {
        name: "战士",
        branches: [
            {
                requiredStage: 20,
                options: [
                    {desc: "玩家攻击加成总和提升2倍", type: "attackMultiplier", value: 2},
                    {desc: "玩家爆伤总和提升2倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 2}},
                    {desc: "玩家生命加成总和提升1.1倍", type: "healthMultiplier", value: 1.1}
                ]
            },
            {
                requiredStage: 200,
                options: [
                    {desc: "玩家攻击加成总和提升5倍", type: "attackMultiplier", value: 5},
                    {desc: "玩家爆伤总和提升5倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 5}},
                    {desc: "玩家生命加成总和提升1.5倍", type: "healthMultiplier", value: 1.5}
                ]
            },
            {
                requiredStage: 500,
                options: [
                    {desc: "玩家攻击加成总和提升10倍", type: "attackMultiplier", value: 10},
                    {desc: "玩家爆伤总和提升10倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 10}},
                    {desc: "玩家生命加成总和提升3倍", type: "healthMultiplier", value: 3}
                ]
            },
            {
                requiredStage: 1000,
                options: [
                    {desc: "玩家攻击加成总和提升20倍", type: "attackMultiplier", value: 20},
                    {desc: "玩家爆伤总和提升20倍伤害", type: "critMultiplier", value: {chance: 0.01, multiplier: 20}},
                    {desc: "玩家生命加成总和提升5倍", type: "healthMultiplier", value: 5}
                ]
            },
            {
                requiredStage: 1500,
                options: [
                    {desc: "玩家攻击加成总和提升30倍", type: "attackMultiplier", value: 30},
                    {desc: "玩家爆伤总和提升40倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 40}},
                    {desc: "玩家生命加成总和提升7倍", type: "healthMultiplier", value: 7}
                ]
            },
            {
                requiredStage: 2000,
                options: [
                    {desc: "玩家攻击加成总和提升80倍", type: "attackMultiplier", value: 80},
                    {desc: "玩家爆伤总和提升100倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 100}},
                    {desc: "玩家生命加成总和提升10倍", type: "healthMultiplier", value: 10}
                ]
            },
            {
                requiredStage: 2500,
                options: [
                    {desc: "玩家攻击加成总和提升150倍", type: "attackMultiplier", value: 150},
                    {desc: "玩家爆伤总和提升180倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 180}},
                    {desc: "玩家生命加成总和提升14倍", type: "healthMultiplier", value: 13}
               ]
            },
            {
                requiredStage: 3000,
                options: [
                    {desc: "玩家攻击加成总和提升300倍", type: "attackMultiplier", value: 300},
                    {desc: "玩家爆伤总和提升330倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 330}},
                    {desc: "玩家生命加成总和提升18倍", type: "healthMultiplier", value: 18}
               ]
            },
            {
                requiredStage: 3500,
                options: [
                    {desc: "玩家攻击加成总和提升600倍", type: "attackMultiplier", value: 600},
                    {desc: "玩家爆伤总和提升620倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 620}},
                    {desc: "玩家生命加成总和提升25倍", type: "healthMultiplier", value: 25}
             ]
            },
            {
                requiredStage: 4000,
                options: [
                    {desc: "玩家攻击加成总和提升1200倍", type: "attackMultiplier", value: 1200},
                    {desc: "玩家爆伤总和提升1300倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 1300}},
                    {desc: "玩家生命加成总和提升30倍", type: "healthMultiplier", value: 30}
               ]
            },
            {
                requiredStage: 4500,
                options: [
                    {desc: "玩家攻击加成总和提升2200倍", type: "attackMultiplier", value: 2200},
                    {desc: "玩家爆伤总和提升2500倍", type: "critMultiplier", value: {chance: 0.01, multiplier: 2500}},
                    {desc: "玩家生命加成总和提升35倍", type: "healthMultiplier", value: 35}
                ]
            }
        ],
        // 二转职业配置
        secondJobs: {
            berserker: {
                name: "狂战士",
                requiredTower: 150000,
                bonus: { attackMultiplier: 10 }
            },
            swordSoul: {
                name: "剑魂", 
                requiredTower: 150000,
                bonus: { critMultiplier: 10 }
            },
            asura: {
                name: "阿修罗",
                requiredTower: 150000, 
                bonus: { healthMultiplier: 5 }
            }
        },
        // 三转职业配置
        thirdJobs: {
            bloodGod: {
                name: "狱血魔神",
                requiredTower: 300000,
                baseJob: "berserker",
                bonus: { attackMultiplier: 100 }
            },
            swordSaint: {
                name: "剑圣",
                requiredTower: 300000,
                baseJob: "swordSoul", 
                bonus: { critMultiplier: 100 }
            },
            darkLord: {
                name: "大暗黑天",
                requiredTower: 300000,
                baseJob: "asura",
                bonus: { healthMultiplier: 25 }
            }
        },
        // 四转职业配置
        fourthJobs: {
            bloodEmperor: {
                name: "帝血弑天",
                requiredTower: 400000,
                baseJob: "bloodGod",
                bonus: { attackMultiplier: 1000 }
            },
            swordGod: {
                name: "剑神",
                requiredTower: 400000,
                baseJob: "swordSaint",
                bonus: { critMultiplier: 1000 }
            },
            heavenlyEmperor: {
                name: "天帝",
                requiredTower: 400000,
                baseJob: "darkLord",
                bonus: { healthMultiplier: 50 }
            }
        }
    },
    mage: {
        name: "法师",
        branches: [
            {
                requiredStage: 20,
                options: [
                    {desc: "玩家生命加成总和提升1.1倍", type: "healthMultiplier", value: 1.1},
                    {desc: "副本装备加成总和提升1.2倍", type: "dungeonEquipMultiplier", value: 1.2},
                    {desc: "魂环加成总和提升1.5倍", type: "soulRingMultiplier", value: 1.5}
                ]
            },
            {
                requiredStage: 200,
                options: [
                    {desc: "玩家生命加成总和提升1.3倍", type: "healthMultiplier", value: 1.3},
                    {desc: "副本装备加成总和提升1.8倍", type: "dungeonEquipMultiplier", value: 1.8},
                    {desc: "魂环加成总和提升2倍", type: "soulRingMultiplier", value: 2}
                ]
            },
            {
                requiredStage: 500,
                options: [
                    {desc: "玩家生命加成总和提升2.5倍", type: "healthMultiplier", value: 2.5},
                    {desc: "副本装备加成总和提升3倍", type: "dungeonEquipMultiplier", value: 3},
                    {desc: "魂环加成总和提升4倍", type: "soulRingMultiplier", value: 4}
                ]
            },
            {
                requiredStage: 1000,
                options: [
                    {desc: "玩家生命加成总和提升4倍", type: "healthMultiplier", value: 4},
                    {desc: "副本装备加成总和提升4倍", type: "dungeonEquipMultiplier", value: 4},
                    {desc: "魂环加成总和提升5倍", type: "soulRingMultiplier", value: 5}
                ]
            },
            {
                requiredStage: 1500,
                options: [
                    {desc: "玩家生命加成总和提升5倍", type: "healthMultiplier", value: 5},
                    {desc: "副本装备加成总和提升8倍", type: "dungeonEquipMultiplier", value: 8},
                    {desc: "魂环加成总和提升10倍", type: "soulRingMultiplier", value: 10}
                ]
            },
            {
                requiredStage: 2000,
                options: [
                    {desc: "玩家生命加成总和提升9倍", type: "healthMultiplier", value: 9},
                    {desc: "副本装备加成总和提升15倍", type: "dungeonEquipMultiplier", value: 15},
                    {desc: "魂环加成总和提升20倍", type: "soulRingMultiplier", value: 20}
                ]
            },
            {
                requiredStage: 2500,
                options: [
                    {desc: "玩家生命加成总和提升12倍", type: "healthMultiplier", value: 12},
                    {desc: "副本装备加成总和提升20倍", type: "dungeonEquipMultiplier", value: 20},
                    {desc: "魂环加成总和提升30倍", type: "soulRingMultiplier", value: 30}
                ]
            },
            {
                requiredStage: 3000,
                options: [
                    {desc: "玩家生命加成总和提升15倍", type: "healthMultiplier", value: 15},
                    {desc: "副本装备加成总和提升30倍", type: "dungeonEquipMultiplier", value: 30},
                    {desc: "魂环加成总和提升50倍", type: "soulRingMultiplier", value: 50}
                ]
            },
            {
                requiredStage: 3500,
                options: [
                    {desc: "玩家生命加成总和提升18倍", type: "healthMultiplier", value: 18},
                    {desc: "副本装备加成总和提升50倍", type: "dungeonEquipMultiplier", value: 50},
                    {desc: "魂环加成总和提升60倍", type: "soulRingMultiplier", value: 60}
                ]
            },
            {
                requiredStage: 4000,
                options: [
                    {desc: "玩家生命加成总和提升20倍", type: "healthMultiplier", value: 20},
                    {desc: "副本装备加成总和提升70倍", type: "dungeonEquipMultiplier", value: 70},
                    {desc: "魂环加成总和提升80倍", type: "soulRingMultiplier", value: 80}
                ]
            },
            {
                requiredStage: 4500,
                options: [
                    {desc: "玩家生命加成总和提升25倍", type: "healthMultiplier", value: 25},
                    {desc: "副本装备加成总和提升80倍", type: "dungeonEquipMultiplier", value: 80},
                    {desc: "魂环加成总和提升100倍", type: "soulRingMultiplier", value: 100}
                ]
            }
        ],
        // 二转职业配置
        secondJobs: {
            elementalist: {
                name: "元素师",
                requiredTower: 100000,
                bonus: { dungeonEquipMultiplier: 3 }
            },
            magicScholar: {
                name: "魔道学者",
                requiredTower: 100000,
                bonus: { soulRingMultiplier: 5 }
            },
            battleMage: {
                name: "战斗法师",
                requiredTower: 100000,
                bonus: { healthMultiplier: 4 }
            }
        },
        // 三转职业配置
        thirdJobs: {
            archmage: {
                name: "大魔导师",
                requiredTower: 200000,
                baseJob: "elementalist",
                bonus: { dungeonEquipMultiplier: 10 }
            },
            magician: {
                name: "魔术师",
                requiredTower: 200000,
                baseJob: "magicScholar",
                bonus: { soulRingMultiplier: 15 }
            },
            battleGoddess: {
                name: "贝亚娜斗神",
                requiredTower: 200000,
                baseJob: "battleMage",
                bonus: { healthMultiplier: 15 }
            }
        },
        // 四转职业配置
        fourthJobs: {
            darkGod: {
                name: "黑暗之神",
                requiredTower: 300000,
                baseJob: "archmage",
                bonus: { dungeonEquipMultiplier: 50 }
            },
            magicSovereign: {
                name: "魔道至尊",
                requiredTower: 300000,
                baseJob: "magician",
                bonus: { soulRingMultiplier: 50 }
            },
            lightGod: {
                name: "光明之神",
                requiredTower: 300000,
                baseJob: "battleGoddess",
                bonus: { healthMultiplier: 30 }
            }
        }
    },
 explorer: {
        name: "探险家",
        branches: [
            {
                requiredStage: 20,
                options: [
                    {desc: "世界地图经验获取提升2.5%", type: "worldExpMultiplier", value: 0.025},
                    {desc: "修仙系统经验获取提升2.5%", type: "cultivationExpMultiplier", value: 0.025},
                    {desc: "奥秘系统经验获取提升2.5%", type: "mysteryExpMultiplier", value: 0.025}
                ]
            },
            {
                requiredStage: 200,
                options: [
                    {desc: "世界地图经验获取提升5%", type: "worldExpMultiplier", value: 0.05},
                    {desc: "修仙系统经验获取提升5%", type: "cultivationExpMultiplier", value: 0.05},
                    {desc: "奥秘系统经验获取提升5%", type: "mysteryExpMultiplier", value: 0.05}
                ]
            },
            {
                requiredStage: 500,
                options: [
                    {desc: "世界地图经验获取提升7.5%", type: "worldExpMultiplier", value: 0.075},
                    {desc: "修仙系统经验获取提升7.5%", type: "cultivationExpMultiplier", value: 0.075},
                    {desc: "奥秘系统经验获取提升7.5%", type: "mysteryExpMultiplier", value: 0.075}
                ]
            },
            {
                requiredStage: 1000,
                options: [
                    {desc: "世界地图经验获取提升10%", type: "worldExpMultiplier", value: 0.10},
                    {desc: "修仙系统经验获取提升10%", type: "cultivationExpMultiplier", value: 0.10},
                    {desc: "奥秘系统经验获取提升10%", type: "mysteryExpMultiplier", value: 0.10}
                ]
            },
            {
                requiredStage: 1500,
                options: [
                    {desc: "世界地图经验获取提升12.5%", type: "worldExpMultiplier", value: 0.125},
                    {desc: "修仙系统经验获取提升12.5%", type: "cultivationExpMultiplier", value: 0.125},
                    {desc: "奥秘系统经验获取提升12.5%", type: "mysteryExpMultiplier", value: 0.125}
                ]
            },
            {
                requiredStage: 2000,
                options: [
                    {desc: "世界地图经验获取提升15%", type: "worldExpMultiplier", value: 0.15},
                    {desc: "修仙系统经验获取提升15%", type: "cultivationExpMultiplier", value: 0.15},
                    {desc: "奥秘系统经验获取提升15%", type: "mysteryExpMultiplier", value: 0.15}
                ]
            },
            {
                requiredStage: 2500,
                options: [
                    {desc: "世界地图经验获取提升17.5%", type: "worldExpMultiplier", value: 0.175},
                    {desc: "修仙系统经验获取提升17.5%", type: "cultivationExpMultiplier", value: 0.175},
                    {desc: "奥秘系统经验获取提升17.5%", type: "mysteryExpMultiplier", value: 0.175}
                ]
            },
            {
                requiredStage: 3000,
                options: [
                    {desc: "世界地图经验获取提升20%", type: "worldExpMultiplier", value: 0.20},
                    {desc: "修仙系统经验获取提升20%", type: "cultivationExpMultiplier", value: 0.20},
                    {desc: "奥秘系统经验获取提升20%", type: "mysteryExpMultiplier", value: 0.20}
                ]
            },
            {
                requiredStage: 3500,
                options: [
                    {desc: "世界地图经验获取提升22.5%", type: "worldExpMultiplier", value: 0.225},
                    {desc: "修仙系统经验获取提升22.5%", type: "cultivationExpMultiplier", value: 0.225},
                    {desc: "奥秘系统经验获取提升22.5%", type: "mysteryExpMultiplier", value: 0.225}
                ]
            },
            {
                requiredStage: 4000,
                options: [
                    {desc: "世界地图经验获取提升25%", type: "worldExpMultiplier", value: 0.25},
                    {desc: "修仙系统经验获取提升25%", type: "cultivationExpMultiplier", value: 0.25},
                    {desc: "奥秘系统经验获取提升25%", type: "mysteryExpMultiplier", value: 0.25}
                ]
            },
            {
                requiredStage: 4500,
                options: [
                    {desc: "世界地图经验获取提升30%", type: "worldExpMultiplier", value: 0.30},
                    {desc: "修仙系统经验获取提升30%", type: "cultivationExpMultiplier", value: 0.30},
                    {desc: "奥秘系统经验获取提升30%", type: "mysteryExpMultiplier", value: 0.30}
                ]
            }
        ],
        // 二转职业配置
        secondJobs: {
            pathfinder: {
                name: "堪舆师",
                requiredTower: 100000,
                bonus: { worldExpMultiplier: 1.1 }
            },
            adventurer: {
                name: "问道客",
                requiredTower: 100000,
                bonus: { cultivationExpMultiplier: 1.1 }
            },
            scholar: {
                name: "解律者",
                requiredTower: 100000,
                bonus: { mysteryExpMultiplier: 1.1 }
            }
        },
        // 三转职业配置
        thirdJobs: {
            explorerKing: {
                name: "山河司命",
                requiredTower: 200000,
                baseJob: "pathfinder",
                bonus: { worldExpMultiplier: 1.2 }
            },
            legendAdventurer: {
                name: "归墟引渡人",
                requiredTower: 200000,
                baseJob: "adventurer",
                bonus: { cultivationExpMultiplier: 1.2 }
            },
            mysteryMaster: {
                name: "御法真君",
                requiredTower: 200000,
                baseJob: "scholar",
                bonus: { mysteryExpMultiplier: 1.2 }
            }
        },
        // 四转职业配置
        fourthJobs: {
            worldWalker: {
                name: "造化寰宇主",
                requiredTower: 300000,
                baseJob: "explorerKing",
                bonus: { worldExpMultiplier: 1.3 }
            },
            immortalExplorer: {
                name: "天命窥秘师",
                requiredTower: 300000,
                baseJob: "legendAdventurer",
                bonus: { cultivationExpMultiplier: 1.3 }
            },
            mysteryGod: {
                name: "万法道主",
                requiredTower: 300000,
                baseJob: "mysteryMaster",
                bonus: { mysteryExpMultiplier: 1.3 }
            }
        }
    }
};

// 切换职业系统界面显示
function toggleClassSystem() {
 if (player.reincarnationCount < 20) {
        alert("需要达到20转才能开启职业系统！");
        return;
    }
    const ui = document.getElementById('classSystemUI');
    const overlay = document.getElementById('classSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateClassSystemDisplay();
    }
}

// 选择职业
function selectClass(classType) {
    // 检查是否需要消耗职业转换书
    if (player.class && player.class !== classType) {
        if (player.items.zhiye1 < 1) {
            alert("职业转换书不足，更换职业需要1本职业转换书！");
            return;
        }
        
        player.items.zhiye1 -= 1;
        
        // 重置所有转职状态
        player.classBranches = [];
        player.classSecond = null;
        player.classThird = null;
        player.classFourth = null;
        
        logAction(`消耗1职业转换书，更换职业为${classConfig[classType].name}，所有转职状态已重置`, 'success');
    }
    
    // 设置职业
    player.class = classType;
    
    // 更新显示
    updateClassSystemDisplay();
    updatePlayerClassNameDisplay();
    updateDisplay(); // 更新整体显示
}

// 更新职业系统界面显示
function updateClassSystemDisplay() {
    const className = player.class ? classConfig[player.class].name : "无";
    let fullClassName = className;
    
    // 构建完整的职业名称
    if (player.classFourth) {
        fullClassName += `·${classConfig[player.class].fourthJobs[player.classFourth].name}`;
    } else if (player.classThird) {
        fullClassName += `·${classConfig[player.class].thirdJobs[player.classThird].name}`;
    } else if (player.classSecond) {
        fullClassName += `·${classConfig[player.class].secondJobs[player.classSecond].name}`;
    }
    
    document.getElementById('currentClassName').textContent = fullClassName;
    
    const branchesContainer = document.getElementById('classBranches');
    const branchPointsContainer = document.getElementById('branchPointsContainer');
    
    if (player.class) {
        branchesContainer.style.display = 'block';
        branchPointsContainer.innerHTML = '';
        
        // 显示一转分支（原有逻辑）
        const branches = classConfig[player.class].branches;
        branches.forEach((branch, index) => {
            const isUnlocked = player.battle.maxStage >= branch.requiredStage;
            const selectedOption = player.classBranches[index] !== undefined ? player.classBranches[index] : -1;
            
            let branchHtml = `<div style="margin: 15px 0; padding: 10px; border: 1px solid #ccc;">`;
            branchHtml += `<div>第${index + 1}排 (需要最高关卡: ${branch.requiredStage})</div>`;
            
            if (!isUnlocked) {
                branchHtml += `<div style="color: #999;">未解锁，需要达到${branch.requiredStage}关</div>`;
            } else {
                branch.options.forEach((option, optIndex) => {
                    const isSelected = selectedOption === optIndex;
                    branchHtml += `
                        <div style="margin: 5px 0; padding: 5px; ${isSelected ? 'background: #ccf;' : ''}">
                            <button onclick="selectBranch(${index}, ${optIndex})" 
                                style="${isSelected ? 'background: #00f; color: white;' : ''}">
                                ${isSelected ? '✓ ' : ''}选择
                            </button>
                            ${option.desc}
                        </div>
                    `;
                });
            }
            
            branchHtml += `</div>`;
            branchPointsContainer.innerHTML += branchHtml;
        });
        
        // 新增：显示二转职业选择
        if (player.tower.currentFloor >= 100000 && !player.classSecond) {
            let secondJobHtml = `<div style="margin: 20px 0; padding: 15px; border: 2px solid #ff9900; background: #fff9e6;">`;
            secondJobHtml += `<h4 style="color: #ff9900;">二转职业选择（需要通天塔10万层）</h4>`;
            
            Object.entries(classConfig[player.class].secondJobs).forEach(([key, job]) => {
                secondJobHtml += `
                    <div style="margin: 10px 0; padding: 10px; border: 1px solid #ddd;">
                        <strong>${job.name}</strong><br>
                        ${getJobBonusDescription(job.bonus)}<br>
                        <button onclick="selectSecondJob('${key}')" style="margin-top: 5px;">选择此职业</button>
                    </div>
                `;
            });
            secondJobHtml += `</div>`;
            branchPointsContainer.innerHTML += secondJobHtml;
        }
        
        // 显示已选择的二转职业
        if (player.classSecond) {
            const job = classConfig[player.class].secondJobs[player.classSecond];
            let jobHtml = `<div style="margin: 15px 0; padding: 10px; border: 2px solid #00aa00; background: #f0fff0;">`;
            jobHtml += `<h4 style="color: #00aa00;">二转职业：${job.name}</h4>`;
            jobHtml += `<div>加成：${getJobBonusDescription(job.bonus)}</div>`;
            jobHtml += `</div>`;
            branchPointsContainer.innerHTML += jobHtml;
        }
        
        // 显示三转职业信息
        if (player.tower.currentFloor >= 200000 && player.classSecond && !player.classThird) {
            const thirdJobs = classConfig[player.class].thirdJobs;
            let availableThirdJob = null;
            
            // 找到对应的三转职业
            for (const [key, job] of Object.entries(thirdJobs)) {
                if (job.baseJob === player.classSecond) {
                    availableThirdJob = job;
                    break;
                }
            }
            
            if (availableThirdJob) {
                let thirdJobHtml = `<div style="margin: 15px 0; padding: 15px; border: 2px solid #aa00aa; background: #faf0ff;">`;
                thirdJobHtml += `<h4 style="color: #aa00aa;">三转职业晋升（需要通天塔20万层）</h4>`;
                thirdJobHtml += `<div><strong>${availableThirdJob.name}</strong></div>`;
                thirdJobHtml += `<div>加成：${getJobBonusDescription(availableThirdJob.bonus)}</div>`;
                thirdJobHtml += `<button onclick="selectThirdJob()" style="margin-top: 10px;">晋升为三转</button>`;
                thirdJobHtml += `</div>`;
                branchPointsContainer.innerHTML += thirdJobHtml;
            }
        }
        
        // 显示已选择的三转职业
        if (player.classThird) {
            const job = classConfig[player.class].thirdJobs[player.classThird];
            let jobHtml = `<div style="margin: 15px 0; padding: 10px; border: 2px solid #aa00aa; background: #faf0ff;">`;
            jobHtml += `<h4 style="color: #aa00aa;">三转职业：${job.name}</h4>`;
            jobHtml += `<div>加成：${getJobBonusDescription(job.bonus)}</div>`;
            jobHtml += `</div>`;
            branchPointsContainer.innerHTML += jobHtml;
        }
        
        // 显示四转职业信息
        if (player.tower.currentFloor >= 300000 && player.classThird && !player.classFourth) {
            const fourthJobs = classConfig[player.class].fourthJobs;
            let availableFourthJob = null;
            
            // 找到对应的四转职业
            for (const [key, job] of Object.entries(fourthJobs)) {
                if (job.baseJob === player.classThird) {
                    availableFourthJob = job;
                    break;
                }
            }
            
            if (availableFourthJob) {
                let fourthJobHtml = `<div style="margin: 15px 0; padding: 15px; border: 2px solid #ff0000; background: #fff0f0;">`;
                fourthJobHtml += `<h4 style="color: #ff0000;">四转职业晋升（需要通天塔30万层）</h4>`;
                fourthJobHtml += `<div><strong>${availableFourthJob.name}</strong></div>`;
                fourthJobHtml += `<div>加成：${getJobBonusDescription(availableFourthJob.bonus)}</div>`;
                fourthJobHtml += `<button onclick="selectFourthJob()" style="margin-top: 10px;">晋升为四转</button>`;
                fourthJobHtml += `</div>`;
                branchPointsContainer.innerHTML += fourthJobHtml;
            }
        }
        
        // 显示已选择的四转职业
        if (player.classFourth) {
            const job = classConfig[player.class].fourthJobs[player.classFourth];
            let jobHtml = `<div style="margin: 15px 0; padding: 10px; border: 2px solid #ff0000; background: #fff0f0;">`;
            jobHtml += `<h4 style="color: #ff0000;">四转职业：${job.name}</h4>`;
            jobHtml += `<div>加成：${getJobBonusDescription(job.bonus)}</div>`;
            jobHtml += `</div>`;
            branchPointsContainer.innerHTML += jobHtml;
        }
    } else {
        branchesContainer.style.display = 'none';
    }
    
    // 更新玩家名字旁的职业显示
    updatePlayerClassNameDisplay();
}
// 辅助函数：获取职业加成描述
function getJobBonusDescription(bonus) {
    const descriptions = [];
    if (bonus.attackMultiplier) descriptions.push(`攻击加成${bonus.attackMultiplier}倍`);
    if (bonus.critMultiplier) descriptions.push(`爆伤加成${bonus.critMultiplier}倍`);
    if (bonus.healthMultiplier) descriptions.push(`生命加成${bonus.healthMultiplier}倍`);
    if (bonus.dungeonEquipMultiplier) descriptions.push(`副本装备加成${bonus.dungeonEquipMultiplier}倍`);
    if (bonus.soulRingMultiplier) descriptions.push(`魂环加成${bonus.soulRingMultiplier}倍`);
    if (bonus.worldExpMultiplier) descriptions.push(`世界地图经验${bonus.worldExpMultiplier}倍`);
    if (bonus.cultivationExpMultiplier) descriptions.push(`修仙经验${bonus.cultivationExpMultiplier}倍`);
    if (bonus.mysteryExpMultiplier) descriptions.push(`奥秘经验${bonus.mysteryExpMultiplier}倍`);
    return descriptions.join('，');
}
// 选择二转职业
function selectSecondJob(jobKey) {
    if (player.tower.currentFloor < 100000) {
        alert("需要通天塔达到10万层才能进行二转！");
        return;
    }
    
    player.classSecond = jobKey;
    logAction(`成功转职为${classConfig[player.class].secondJobs[jobKey].name}！`, 'success');
    updateClassSystemDisplay();
    updatePlayerBattleStats();
}

// 选择三转职业
function selectThirdJob() {
    if (player.tower.currentFloor < 200000) {
        alert("需要通天塔达到20万层才能进行三转！");
        return;
    }
    
    if (!player.classSecond) {
        alert("需要先完成二转才能进行三转！");
        return;
    }
    
    // 自动确定三转职业
    const thirdJobs = classConfig[player.class].thirdJobs;
    for (const [key, job] of Object.entries(thirdJobs)) {
        if (job.baseJob === player.classSecond) {
            player.classThird = key;
            logAction(`成功晋升为三转${job.name}！`, 'success');
            break;
        }
    }
    
    updateClassSystemDisplay();
    updatePlayerBattleStats();
}

// 选择四转职业
function selectFourthJob() {
    if (player.tower.currentFloor < 300000) {
        alert("需要通天塔达到30万层才能进行四转！");
        return;
    }
    
    if (!player.classThird) {
        alert("需要先完成三转才能进行四转！");
        return;
    }
    
    // 自动确定四转职业
    const fourthJobs = classConfig[player.class].fourthJobs;
    for (const [key, job] of Object.entries(fourthJobs)) {
        if (job.baseJob === player.classThird) {
            player.classFourth = key;
            logAction(`成功晋升为四转${job.name}！`, 'success');
            break;
        }
    }
    
    updateClassSystemDisplay();
    updatePlayerBattleStats();
}
// 选择分支选项
function selectBranch(branchIndex, optionIndex) {
    // 检查是否解锁
    const branch = classConfig[player.class].branches[branchIndex];
    if (player.battle.maxStage < branch.requiredStage) {
        alert(`需要达到${branch.requiredStage}关才能解锁此分支！`);
        return;
    }
    
    // 保存选择
    player.classBranches[branchIndex] = optionIndex;
    logAction(`选择了${classConfig[player.class].name}第${branchIndex + 1}排第${optionIndex + 1}个分支`, 'success');
    
    // 更新显示
    updateClassSystemDisplay();
    updatePlayerBattleStats();
}

 
// 更新玩家名字旁的职业显示
function updatePlayerClassNameDisplay() {
    const classNameElement = document.getElementById('playerClassName');
    if (player.class) {
        let displayName = classConfig[player.class].name;
        
        // 添加转职后缀
        if (player.classFourth) {
            displayName += `·${classConfig[player.class].fourthJobs[player.classFourth].name}`;
        } else if (player.classThird) {
            displayName += `·${classConfig[player.class].thirdJobs[player.classThird].name}`;
        } else if (player.classSecond) {
            displayName += `·${classConfig[player.class].secondJobs[player.classSecond].name}`;
        }
        
        classNameElement.textContent = `[${displayName}]`;
    } else {
        classNameElement.textContent = '';
    }
}
// 新增：计算魂环总加成（含职业分支乘数）
function getTotalSoulRingBonus() {
  let total = 0;
  player.soulRings.forEach(ring => {
    // 基础加成：等级 × 单级倍率
    total += ring.level * ring.multiplier;
  });
  // 应用职业分支的魂环加成乘数
  return total * player.classBonuses.soulRingMultiplier;
}
// 新增：计算副本装备总加成（含职业分支乘数）
function getTotalDungeonEquipBonus() {
  let total = 0;
  player.dungeonEquipment.forEach(eq => {
    // 基础加成：等级 × 成长率（示例，需结合实际装备效果逻辑）
    total += eq.level * eq.growthRate;
  });
  // 应用职业分支的副本装备加成乘数
  return total * player.classBonuses.dungeonEquipMultiplier;
}
// 计算职业加成 (需要在战斗计算相关函数中调用)
function calculateClassBonuses() {
    const bonuses = {
        attackMultiplier: 1,
        healthMultiplier: 1,
        critChance: 0,
        critMultiplier: 1,
        collectionMultiplier: 1,
        dungeonEquipMultiplier: 1,
        soulRingMultiplier: 1,
        worldExpMultiplier: 1,
        cultivationExpMultiplier: 1,
        mysteryExpMultiplier: 1
    };
    
    if (!player.class) return bonuses;
    
    const classData = classConfig[player.class];
    
    // 累加一转分支加成（原有逻辑）
    player.classBranches.forEach((optionIndex, branchIndex) => {
        if (optionIndex === undefined) return;
        
        const branch = classData.branches[branchIndex];
        const option = branch.options[optionIndex];
        
        switch (option.type) {
            case 'attackMultiplier':
                bonuses.attackMultiplier *= (1 + option.value);
                break;
            case 'healthMultiplier':
                bonuses.healthMultiplier *= (1 + option.value);
                break;
            case 'critMultiplier':
                if (option.value.multiplier) {
                    bonuses.critMultiplier *= (1 + option.value.multiplier);
                } else {
                    bonuses.critMultiplier *= (1 + option.value);
                }
                break;
            case 'dungeonEquipMultiplier':
                bonuses.dungeonEquipMultiplier *= (1 + option.value);
                break;
            case 'soulRingMultiplier':
                bonuses.soulRingMultiplier *= (1 + option.value);
                break;
          case 'worldExpMultiplier':
                bonuses.worldExpMultiplier *= (1 + option.value);
                break;
            case 'cultivationExpMultiplier':
                bonuses.cultivationExpMultiplier *= (1 + option.value);
                break;
            case 'mysteryExpMultiplier':
                bonuses.mysteryExpMultiplier *= (1 + option.value);
                break;
        }
    });
    
    // 新增：应用二转职业加成
    if (player.classSecond) {
        const secondJob = classData.secondJobs[player.classSecond];
        if (secondJob && secondJob.bonus) {
            for (const [key, value] of Object.entries(secondJob.bonus)) {
                if (bonuses[key] !== undefined) {
                    bonuses[key] *= value;
                }
            }
        }
    }
    
    // 新增：应用三转职业加成
    if (player.classThird) {
        const thirdJob = classData.thirdJobs[player.classThird];
        if (thirdJob && thirdJob.bonus) {
            for (const [key, value] of Object.entries(thirdJob.bonus)) {
                if (bonuses[key] !== undefined) {
                    bonuses[key] *= value;
                }
            }
        }
    }
    
    // 新增：应用四转职业加成
    if (player.classFourth) {
        const fourthJob = classData.fourthJobs[player.classFourth];
        if (fourthJob && fourthJob.bonus) {
            for (const [key, value] of Object.entries(fourthJob.bonus)) {
                if (bonuses[key] !== undefined) {
                    bonuses[key] *= value;
                }
            }
        }
    }
    
    return bonuses;
}
// 黑龙潭副本数据
const blackDragonAbyss = {
    bossLevel: 1,
    bossHealth: 1e50,
    bossMaxHealth: 1e50,
    bossAttack: 1e5,
    bossResurrections: 0,
    isBattleActive: false,
    playerHealth: 0,
    playerMaxHealth: 0,
    playerAttack: 0,
    playerCritRate: 0,
    playerCritDamage: 0
};

// 初始化黑龙潭副本
function initBlackDragonAbyss() {
    // 确保玩家数据中有副本令牌
    if (player.items.fuben1 === undefined) {
        player.items.fuben1 = 0;
    }
}

// 切换黑龙潭副本界面
function toggleBlackDragonAbyss() {
    if (player.level.ascentionCounta < 1) {
        alert("需要达到轮回1转才能开启黑龙潭副本！");
        return;
    }
    const overlay = document.getElementById('blackDragonAbyssOverlay');
    const ui = document.getElementById('blackDragonAbyssUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateBlackDragonAbyssUI();
    }
}

// 更新黑龙潭副本UI
function updateBlackDragonAbyssUI() {
    // 更新副本令牌数量
    document.getElementById('dungeonTokenCount').textContent = player.items.fuben1 || 0;
    
    // 更新玩家属性
    document.getElementById('bdaPlayerHealth').textContent = formatSci(blackDragonAbyss.playerHealth);
    document.getElementById('bdaPlayerAttack').textContent = formatSci(blackDragonAbyss.playerAttack);
    document.getElementById('bdaPlayerCritRate').textContent = (blackDragonAbyss.playerCritRate * 100).toFixed(2) + '%';
    document.getElementById('bdaPlayerCritDamage').textContent = (blackDragonAbyss.playerCritDamage * 100).toFixed(2) + '%';
    
    // 更新BOSS属性
    document.getElementById('bdaBossLevel').textContent = blackDragonAbyss.bossLevel;
    document.getElementById('bdaBossHealth').textContent = formatSci(blackDragonAbyss.bossHealth);
    document.getElementById('bdaBossMaxHealth').textContent = formatSci(blackDragonAbyss.bossMaxHealth);
    document.getElementById('bdaBossAttack').textContent = formatSci(blackDragonAbyss.bossAttack);
    document.getElementById('bdaBossResurrections').textContent = blackDragonAbyss.bossResurrections;
}

// 开始黑龙王战斗
function startBlackDragonBattle() {
    // 检查是否有副本令牌
    if (player.items.fuben1 < 1) {
        logAction("副本令牌不足！", "error");
        return;
    }
    
    // 消耗副本令牌
    player.items.fuben1--;
    
    // 重置BOSS状态
    blackDragonAbyss.bossLevel = 1;
    blackDragonAbyss.bossHealth = 1e50;
    blackDragonAbyss.bossMaxHealth = 1e50;
    blackDragonAbyss.bossAttack = 1e5;
    blackDragonAbyss.bossResurrections = 0;
    
    // 设置玩家战斗属性
    blackDragonAbyss.playerMaxHealth = player.battle.playerHealth;
    blackDragonAbyss.playerHealth = player.battle.playerHealth;
    blackDragonAbyss.playerAttack = player.battle.playerAttack;
    blackDragonAbyss.playerCritRate = player.battle.playerCritRate;
    blackDragonAbyss.playerCritDamage = player.battle.playerCritDamage;
    
    // 开始战斗
    blackDragonAbyss.isBattleActive = true;
    
    // 更新UI
    document.getElementById('startBattleBtn').style.display = 'none';
    document.getElementById('attackBossBtn').style.display = 'inline-block';
    document.getElementById('fleeBossBtn').style.display = 'inline-block';
    
    // 清空战斗日志
    document.getElementById('bdaBattleLog').innerHTML = '';
    
    // 添加战斗开始日志
    addBdaBattleLog("战斗开始！挑战黑龙王(Lv.1)");
    addBdaBattleLog("黑龙王: 蝼蚁，也敢挑战本王？");
    
    updateBlackDragonAbyssUI();
}

// 攻击黑龙王
function attackBlackDragon() {
    if (!blackDragonAbyss.isBattleActive) return;
    
    // 玩家攻击
    let isCrit = Math.random() < blackDragonAbyss.playerCritRate;
    let damage = blackDragonAbyss.playerAttack * (isCrit ? blackDragonAbyss.playerCritDamage : 1);
    
    blackDragonAbyss.bossHealth -= damage;
    
    addBdaBattleLog(`你对黑龙王造成${formatSci(damage)}点${isCrit ? "暴击 " : ""}伤害`);
    
    // 检查BOSS是否死亡
    if (blackDragonAbyss.bossHealth <= 0) {
        handleBossDefeated();
        return; // 直接返回，不执行后续的BOSS反击
    }
    
    // BOSS反击（仅在BOSS未死亡时执行）
    let bossDamage = blackDragonAbyss.bossAttack;
    blackDragonAbyss.playerHealth -= bossDamage;
    
    addBdaBattleLog(`黑龙王对你造成${formatSci(bossDamage)}点伤害`);
    
    // 检查玩家是否死亡
    if (blackDragonAbyss.playerHealth <= 0) {
        handlePlayerDefeated();
        return;
    }
    
    updateBlackDragonAbyssUI();
}

// 处理BOSS被击败
function handleBossDefeated() {
    // 检查BOSS复活次数
    if (blackDragonAbyss.bossResurrections < 10) {
        // BOSS复活
        blackDragonAbyss.bossResurrections++;
        blackDragonAbyss.bossHealth = blackDragonAbyss.bossMaxHealth * Math.pow(2, blackDragonAbyss.bossResurrections);
        blackDragonAbyss.bossAttack *= 2;
        
        addBdaBattleLog(`黑龙王复活了！(第${blackDragonAbyss.bossResurrections}次复活)`);
        addBdaBattleLog("黑龙王: 你无法杀死我！");
        
        // 新增：BOSS复活后立即攻击玩家
        bossResurrectionAttack();
    } else {
        // BOSS真正死亡，升级
        blackDragonAbyss.bossLevel++;
        blackDragonAbyss.bossMaxHealth = 1e50 * Math.pow(1e10, blackDragonAbyss.bossLevel - 1);
        blackDragonAbyss.bossHealth = blackDragonAbyss.bossMaxHealth;
        blackDragonAbyss.bossAttack = 1e5 * Math.pow(1e5, blackDragonAbyss.bossLevel - 1);
        blackDragonAbyss.bossResurrections = 0;
        
        addBdaBattleLog(`恭喜！你击败了黑龙王，等级提升至${blackDragonAbyss.bossLevel}`);
        addBdaBattleLog("黑龙王: 不...这不可能...");
    }
    
    updateBlackDragonAbyssUI();
}

// 新增：BOSS复活后立即攻击玩家的函数
function bossResurrectionAttack() {
    // BOSS复活后立即攻击玩家
    let bossDamage = blackDragonAbyss.bossAttack;
    blackDragonAbyss.playerHealth -= bossDamage;
    
    addBdaBattleLog(`黑龙王复活后立即对你造成${formatSci(bossDamage)}点伤害`);
    
    // 检查玩家是否死亡
    if (blackDragonAbyss.playerHealth <= 0) {
        handlePlayerDefeated();
        return;
    }
    
    updateBlackDragonAbyssUI();
}

// 处理玩家被击败
function handlePlayerDefeated() {
    blackDragonAbyss.isBattleActive = false;
    
    addBdaBattleLog("你被黑龙王击败了！");
    addBdaBattleLog("战斗结束");
    
    // 隐藏攻击按钮
    document.getElementById('attackBossBtn').style.display = 'none';
    document.getElementById('fleeBossBtn').style.display = 'none';
    document.getElementById('startBattleBtn').style.display = 'inline-block';
    
    // 显示奖励
    showBdaRewards();
}

// 从黑龙王战斗逃跑
function fleeBlackDragonBattle() {
    blackDragonAbyss.isBattleActive = false;
    
    addBdaBattleLog("你逃离了战斗");
    
    // 隐藏攻击按钮
    document.getElementById('attackBossBtn').style.display = 'none';
    document.getElementById('fleeBossBtn').style.display = 'none';
    document.getElementById('startBattleBtn').style.display = 'inline-block';
    
    // 显示奖励
    showBdaRewards();
}

// 显示奖励
function showBdaRewards() {
   // 如果BOSS等级为1，则没有奖励
    if (blackDragonAbyss.bossLevel === 1) {
        addBdaBattleLog("黑龙王等级1，没有获得任何奖励。");
        // 直接返回，不显示奖励界面
        return;
    }
    const multiplier = blackDragonAbyss.bossLevel;
    
    // 计算奖励
    const rewards = {
        // 这里使用游戏内已有的道具字段，如果没有需要先定义
        chiban1: Math.floor(randomBetween(1, 3) * multiplier), // 黑龙王翅膀
        rebornDan: Math.floor(randomBetween(1, 5) * multiplier), // 洗髓丹
        rootDetector: Math.floor(randomBetween(1, 2) * multiplier), // 灵根检测器
        bloodlineDetector: Math.floor(randomBetween(1, 2) * multiplier), // 血脉检测剂
        roseq: Math.floor(randomBetween(1, 2) * multiplier), // 香囊
        banlv1: Math.floor(randomBetween(1, 3) * multiplier), // 普通灵魂伴侣
        yuzhou1: Math.floor(randomBetween(10, 50) * multiplier), // 星辰发票
        yuzhou2: Math.floor(randomBetween(10, 50) * multiplier), // 暗物质发票
        yuzhou3: Math.floor(randomBetween(1, 5) * multiplier), // 宇宙结晶发票
        yuzhou4: Math.floor(randomBetween(1, 5) * multiplier) // 神器碎片发票
    };
    
    // 更新奖励UI
    document.getElementById('rewardBossLevel').textContent = blackDragonAbyss.bossLevel;
    document.getElementById('rewardMultiplier').textContent = multiplier;
    
    let rewardHtml = '';
    for (const [item, amount] of Object.entries(rewards)) {
        // 添加到玩家物品
        player.items[item] = (player.items[item] || 0) + amount;
        
        // 生成奖励显示
        rewardHtml += `<div>${getItemName(item)}: ${amount}</div>`;
    }
    
    document.getElementById('rewardItems').innerHTML = rewardHtml;
    
    // 显示奖励UI
    document.getElementById('bdaRewardOverlay').style.display = 'block';
    document.getElementById('bdaRewardUI').style.display = 'block';
}

// 关闭奖励界面
function closeBdaReward() {
    document.getElementById('bdaRewardOverlay').style.display = 'none';
    document.getElementById('bdaRewardUI').style.display = 'none';
}

// 添加战斗日志
function addBdaBattleLog(message) {
    const logElement = document.createElement('div');
    logElement.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    document.getElementById('bdaBattleLog').appendChild(logElement);
    document.getElementById('bdaBattleLog').scrollTop = document.getElementById('bdaBattleLog').scrollHeight;
}

// 辅助函数：生成随机数范围
function randomBetween(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// 辅助函数：获取物品名称
function getItemName(itemKey) {
    const itemNames = {
        chiban1: "黑龙王翅膀",
        rebornDan: "洗髓丹",
        rootDetector: "灵根检测器",
        bloodlineDetector: "血脉检测剂",
        roseq: "香囊",
        banlv1: "普通灵魂伴侣",
        yuzhou1: "星辰发票",
        yuzhou2: "暗物质发票",
        yuzhou3: "宇宙结晶发票",
        yuzhou4: "神器碎片发票"
    };
    
    return itemNames[itemKey] || itemKey;
}

// 辅助函数：科学计数法格式化
function formatSci(number) {
    if (number < 1000000) {
        return Math.floor(number).toLocaleString();
    }
    return number.toExponential(3).replace(/(\.\d+?)0+e/, '$1e').replace(/\.?e\+?/, 'e');
}
initBlackDragonAbyss();

// 圣兽岛奖励配置
const hbiRewards = {
    baseRewards: {
        '远古圣兽精魄': { min: 1, max: 3 },
        '神兽蛋': { min: 1, max: 2 },
        '洗髓丹': { min: 3, max: 7 },
        '香囊': { min: 3, max: 5 },
        '星辰发票': { min: 100, max: 200 },
        '暗物质发票': { min: 100, max: 200 },
        '宇宙结晶发票': { min: 20, max: 30 },
        '神器碎片': { min: 20, max: 30 }
    },
    itemMapping: {
        '远古圣兽精魄': 'zuoqi1',
        '神兽蛋': 'shenshou1',
        '洗髓丹': 'rebornDan',
        '香囊': 'roseq',
        '星辰发票': 'yuzhou1',
        '暗物质发票': 'yuzhou2',
        '宇宙结晶发票': 'yuzhou3',
        '神器碎片': 'yuzhou4'
    }
};

// 切换圣兽岛副本界面
function toggleHolyBeastIsland() {
   if (player.level.ascentionCounta < 2) {
        alert("需要达到轮回2转才能开启圣兽岛副本！");
        return;
    }
    const overlay = document.getElementById('holyBeastIslandOverlay');
    const ui = document.getElementById('holyBeastIslandUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        // 停止自动战斗
        if (player.holyBeastIsland.autoBattleInterval) {
            clearInterval(player.holyBeastIsland.autoBattleInterval);
            player.holyBeastIsland.autoBattleInterval = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateHolyBeastIslandUI();
    }
}

// 更新圣兽岛界面显示
function updateHolyBeastIslandUI() {
    // 更新令牌数量
    document.getElementById('hbiTokenCount').textContent = player.items.fuben1 || 0;
    
    // 更新玩家属性
    const playerStats = calculatePlayerBattleStats();
    document.getElementById('hbiPlayerHealth').textContent = formatSci(playerStats.health);
    document.getElementById('hbiPlayerAttack').textContent = formatSci(playerStats.attack);
    document.getElementById('hbiPlayerCritRate').textContent = (playerStats.critRate * 100).toFixed(2) + '%';
    document.getElementById('hbiPlayerCritDamage').textContent = (playerStats.critDamage * 100).toFixed(2) + '%';
    
    // 更新BOSS属性
    document.getElementById('hbiBossLevel').textContent = player.holyBeastIsland.bossLevel;
    document.getElementById('hbiBossHealth').textContent = formatSci(player.holyBeastIsland.bossHealth);
    document.getElementById('hbiBossMaxHealth').textContent = formatSci(player.holyBeastIsland.bossMaxHealth);
    document.getElementById('hbiBossAttack').textContent = formatSci(player.holyBeastIsland.bossAttack);
    document.getElementById('hbiBossResurrections').textContent = player.holyBeastIsland.bossResurrections;
    
    // 更新按钮状态
    const startBtn = document.getElementById('startHbiBattleBtn');
    const attackBtn = document.getElementById('attackHbiBossBtn');
    const fleeBtn = document.getElementById('fleeHbiBossBtn');
    
    if (player.holyBeastIsland.isBattling) {
        startBtn.style.display = 'none';
        attackBtn.style.display = 'inline-block';
        fleeBtn.style.display = 'inline-block';
    } else {
        startBtn.style.display = 'inline-block';
        attackBtn.style.display = 'none';
        fleeBtn.style.display = 'none';
    }
}

// 开始圣兽岛战斗
function startHolyBeastBattle() {
    // 检查副本令牌
    if (!player.items.fuben1 || player.items.fuben1 < 1) {
        logAction('副本令牌不足！', 'error');
        return;
    }
    
    // 消耗副本令牌
    player.items.fuben1--;
    
    // 初始化BOSS属性（每次重新挑战都从1级开始）
    player.holyBeastIsland.bossLevel = 1;
    player.holyBeastIsland.bossMaxHealth = 1e100;
    player.holyBeastIsland.bossHealth = 1e100;
    player.holyBeastIsland.bossAttack = 1e10;
    player.holyBeastIsland.bossResurrections = 0;
    player.holyBeastIsland.isBattling = true;
    
    // 初始化玩家战斗属性
    const playerStats = calculatePlayerBattleStats();
    player.holyBeastIsland.playerHealth = playerStats.health;
    player.holyBeastIsland.playerAttack = playerStats.attack;
    player.holyBeastIsland.playerCritRate = playerStats.critRate;
    player.holyBeastIsland.playerCritDamage = playerStats.critDamage;
    
    // 清空战斗日志
    document.getElementById('hbiBattleLog').innerHTML = '';
    
    // 添加战斗开始日志
    addHbiBattleLog('=== 圣兽岛副本挑战开始 ===');
    addHbiBattleLog(`挑战上古火麒麟 Lv.${player.holyBeastIsland.bossLevel}`);
    addHbiBattleLog(`BOSS生命: ${formatSci(player.holyBeastIsland.bossHealth)}`);
    addHbiBattleLog(`BOSS攻击: ${formatSci(player.holyBeastIsland.bossAttack)}`);
    
    updateHolyBeastIslandUI();
    logAction('开始挑战圣兽岛副本上古火麒麟！', 'success');
}

// 攻击圣兽岛BOSS
function attackHolyBeastBoss() {
    if (!player.holyBeastIsland.isBattling) return;
    
    const playerAttack = player.holyBeastIsland.playerAttack;
    const critRate = player.holyBeastIsland.playerCritRate;
    const critDamage = player.holyBeastIsland.playerCritDamage;
    
    // 计算伤害（考虑暴击）
    const isCrit = Math.random() < critRate;
    let damage = playerAttack;
    
    if (isCrit) {
        damage *= critDamage;
    }
    
    // 应用伤害
    player.holyBeastIsland.bossHealth -= damage;
    
    // 记录攻击日志
    addHbiBattleLog(`你对上古火麒麟造成了${formatSci(damage)}点${isCrit ? '暴击 ' : ''}伤害`);
    addHbiBattleLog(`BOSS剩余生命: ${formatSci(player.holyBeastIsland.bossHealth)}/${formatSci(player.holyBeastIsland.bossMaxHealth)}`);
    
    // 检查BOSS是否死亡
    if (player.holyBeastIsland.bossHealth <= 0) {
        handleHbiBossDefeated();
    } else {
        // BOSS反击
        hbiBossCounterAttack();
    }
    
    updateHolyBeastIslandUI();
}

// BOSS反击
function hbiBossCounterAttack() {
    const bossAttack = player.holyBeastIsland.bossAttack;
    
    // 应用伤害
    player.holyBeastIsland.playerHealth -= bossAttack;
    
    // 记录反击日志
    addHbiBattleLog(`上古火麒麟对你造成了${formatSci(bossAttack)}点伤害`);
    addHbiBattleLog(`你剩余生命: ${formatSci(player.holyBeastIsland.playerHealth)}`);
    
    // 检查玩家是否死亡
    if (player.holyBeastIsland.playerHealth <= 0) {
        handleHbiPlayerDefeated();
    }
    
    updateHolyBeastIslandUI();
}

// 处理BOSS被击败
function handleHbiBossDefeated() {
    player.holyBeastIsland.bossResurrections++;
    
    if (player.holyBeastIsland.bossResurrections < 10) {
        // BOSS复活（属性提升3倍）
        player.holyBeastIsland.bossHealth = player.holyBeastIsland.bossMaxHealth * Math.pow(3, player.holyBeastIsland.bossResurrections);
        player.holyBeastIsland.bossAttack *= 3;
        
        addHbiBattleLog(`上古火麒麟复活了！(第${player.holyBeastIsland.bossResurrections}次复活)`);
        addHbiBattleLog(`BOSS属性提升3倍！`);
        
        // BOSS复活后立即反击
        hbiBossCounterAttack();
    } else {
        // BOSS真正死亡，进入下一级
        addHbiBattleLog(`上古火麒麟被彻底击败！`);
        player.holyBeastIsland.bossLevel++;
        
        // 计算下一级BOSS属性（每级提升1e10倍）
        const levelMultiplier = Math.pow(1e10, player.holyBeastIsland.bossLevel - 1);
        player.holyBeastIsland.bossMaxHealth = 1e100 * levelMultiplier;
        player.holyBeastIsland.bossHealth = player.holyBeastIsland.bossMaxHealth;
        player.holyBeastIsland.bossAttack = 1e10 * levelMultiplier;
        player.holyBeastIsland.bossResurrections = 0;
        
        addHbiBattleLog(`上古火麒麟晋升至 Lv.${player.holyBeastIsland.bossLevel}`);
        addHbiBattleLog(`BOSS属性提升${formatSci(levelMultiplier)}倍！`);
        
        // 新等级BOSS立即反击
        hbiBossCounterAttack();
    }
}

// 处理玩家被击败
function handleHbiPlayerDefeated() {
    addHbiBattleLog('=== 你被上古火麒麟击败了！ ===');
    player.holyBeastIsland.isBattling = false;
    
    // 显示奖励界面
    if (player.holyBeastIsland.bossLevel >= 2) {
        showHbiRewards();
    } else {
        addHbiBattleLog('等级1没有奖励，请继续挑战！');
    }
    
    updateHolyBeastIslandUI();
}

// 逃跑函数
function fleeHolyBeastBattle() {
    addHbiBattleLog('=== 你选择逃离战斗 ===');
    player.holyBeastIsland.isBattling = false;
    
    // 显示奖励界面（即使逃跑也结算当前进度奖励）
    if (player.holyBeastIsland.bossLevel >= 2) {
        showHbiRewards();
    } else {
        addHbiBattleLog('等级1没有奖励，请继续挑战！');
    }
    
    updateHolyBeastIslandUI();
}

// 显示奖励界面
function showHbiRewards() {
if (player.holyBeastIsland.bossLevel < 2) {
        return;
    }

    const rewardMultiplier = player.holyBeastIsland.bossLevel-1;
    const rewards = calculateHbiRewards(rewardMultiplier);
    
    // 更新奖励界面显示
    document.getElementById('hbiRewardBossLevel').textContent = player.holyBeastIsland.bossLevel;
    document.getElementById('hbiRewardMultiplier').textContent = rewardMultiplier;
    
    // 显示奖励物品
    const rewardItemsContainer = document.getElementById('hbiRewardItems');
    rewardItemsContainer.innerHTML = '';
    
    Object.entries(rewards).forEach(([itemName, quantity]) => {
        const itemDiv = document.createElement('div');
        itemDiv.style.margin = '5px 0';
        itemDiv.innerHTML = `<span style="color: #ffd700;">${itemName}</span>: ${quantity}个`;
        rewardItemsContainer.appendChild(itemDiv);
    });
    
    // 显示奖励界面
    document.getElementById('hbiRewardOverlay').style.display = 'block';
    document.getElementById('hbiRewardUI').style.display = 'block';
}

// 计算奖励
function calculateHbiRewards(multiplier) {
    const rewards = {};
    
    Object.entries(hbiRewards.baseRewards).forEach(([itemName, range]) => {
        const baseQuantity = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        const finalQuantity = baseQuantity * multiplier;
        rewards[itemName] = finalQuantity;
        
        // 添加到玩家物品
        const itemKey = hbiRewards.itemMapping[itemName];
        if (itemKey) {
            player.items[itemKey] = (player.items[itemKey] || 0) + finalQuantity;
        }
    });
    
    return rewards;
}

// 关闭奖励界面
function closeHbiReward() {
    document.getElementById('hbiRewardOverlay').style.display = 'none';
    document.getElementById('hbiRewardUI').style.display = 'none';
    
    // 记录奖励日志
    logAction('圣兽岛副本挑战结束，获得丰厚奖励！', 'success');
    updateDisplay();
}

// 添加战斗日志
function addHbiBattleLog(message) {
    const logContainer = document.getElementById('hbiBattleLog');
    const logEntry = document.createElement('div');
    logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logEntry.style.margin = '2px 0';
    logEntry.style.padding = '2px 5px';
    
    // 根据消息类型添加颜色
    if (message.includes('击败') || message.includes('奖励')) {
        logEntry.style.color = '#00ff00';
    } else if (message.includes('伤害')) {
        logEntry.style.color = '#ffa500';
    } else if (message.includes('复活')) {
        logEntry.style.color = '#ff0000';
    }
    
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

// 计算玩家战斗属性（需要根据你的游戏系统实现）
function calculatePlayerBattleStats() {
    // 这里需要根据你的游戏系统计算玩家属性
    // 返回格式：{ health: number, attack: number, critRate: number, critDamage: number }
    return {
        health: player.battle.playerHealth || 1e10,
        attack: player.battle.playerAttack || 1e8,
        critRate: player.battle.playerCritRate || 0.1,
        critDamage: player.battle.playerCritDamage || 1.5
    };
}

// 科学计数法格式化函数
function formatSci(number) {
    if (number >= 1e6) {
        return number.toExponential(3);
    }
    return Math.floor(number).toLocaleString();
}
// 蓬莱仙岛奖励配置
const penglaiRewards = {
    baseRewards: {
        '秘法符文': { min: 1, max: 3 },
        '洗髓丹': { min: 5, max: 10 },
        '香囊': { min: 10, max: 20 },
        '星辰发票': { min: 300, max: 500 },
        '暗物质发票': { min: 300, max: 500 },
        '宇宙结晶发票': { min: 100, max: 200 },
        '神器碎片': { min: 100, max: 200 }
    },
    itemMapping: {
        '秘法符文': 'fuwen1',
        '洗髓丹': 'rebornDan',
        '香囊': 'roseq',
        '星辰发票': 'yuzhou1',
        '暗物质发票': 'yuzhou2',
        '宇宙结晶发票': 'yuzhou3',
        '神器碎片': 'yuzhou4'
    }
};

// 切换蓬莱仙岛副本界面
function togglePenglaiIsland() {
    if (player.level.ascentionCounta < 3) {
        alert("需要达到轮回3转才能开启蓬莱仙岛副本！");
        return;
    }
    const overlay = document.getElementById('penglaiIslandOverlay');
    const ui = document.getElementById('penglaiIslandUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        // 停止自动战斗
        if (player.penglaiIsland.autoBattleInterval) {
            clearInterval(player.penglaiIsland.autoBattleInterval);
            player.penglaiIsland.autoBattleInterval = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updatePenglaiIslandUI();
    }
}

// 更新蓬莱仙岛界面显示
function updatePenglaiIslandUI() {
    // 更新令牌数量
    document.getElementById('penglaiTokenCount').textContent = player.items.fuben1 || 0;
    
    // 更新玩家属性
    const playerStats = calculatePlayerBattleStats();
    document.getElementById('penglaiPlayerHealth').textContent = formatSci(playerStats.health);
    document.getElementById('penglaiPlayerAttack').textContent = formatSci(playerStats.attack);
    document.getElementById('penglaiPlayerCritRate').textContent = (playerStats.critRate * 100).toFixed(2) + '%';
    document.getElementById('penglaiPlayerCritDamage').textContent = (playerStats.critDamage * 100).toFixed(2) + '%';
    
    // 更新BOSS属性
    document.getElementById('penglaiBossLevel').textContent = player.penglaiIsland.bossLevel;
    document.getElementById('penglaiBossHealth').textContent = formatSci(player.penglaiIsland.bossHealth);
    document.getElementById('penglaiBossMaxHealth').textContent = formatSci(player.penglaiIsland.bossMaxHealth);
    document.getElementById('penglaiBossAttack').textContent = formatSci(player.penglaiIsland.bossAttack);
    document.getElementById('penglaiBossResurrections').textContent = player.penglaiIsland.bossResurrections;
    
    // 更新按钮状态
    const startBtn = document.getElementById('startPenglaiBattleBtn');
    const attackBtn = document.getElementById('attackPenglaiBossBtn');
    const fleeBtn = document.getElementById('fleePenglaiBossBtn');
    
    if (player.penglaiIsland.isBattling) {
        startBtn.style.display = 'none';
        attackBtn.style.display = 'inline-block';
        fleeBtn.style.display = 'inline-block';
    } else {
        startBtn.style.display = 'inline-block';
        attackBtn.style.display = 'none';
        fleeBtn.style.display = 'none';
    }
}

// 开始蓬莱仙岛战斗
function startPenglaiBattle() {
    // 检查副本令牌
    if (!player.items.fuben1 || player.items.fuben1 < 1) {
        logAction('副本令牌不足！', 'error');
        return;
    }
    
    // 消耗副本令牌
    player.items.fuben1--;
    
    // 初始化BOSS属性（每次重新挑战都从1级开始）
    player.penglaiIsland.bossLevel = 1;
    player.penglaiIsland.bossMaxHealth = 1e120;
    player.penglaiIsland.bossHealth = 1e120;
    player.penglaiIsland.bossAttack = 1e20;
    player.penglaiIsland.bossResurrections = 0;
    player.penglaiIsland.isBattling = true;
    
    // 初始化玩家战斗属性
    const playerStats = calculatePlayerBattleStats();
    player.penglaiIsland.playerHealth = playerStats.health;
    player.penglaiIsland.playerAttack = playerStats.attack;
    player.penglaiIsland.playerCritRate = playerStats.critRate;
    player.penglaiIsland.playerCritDamage = playerStats.critDamage;
    
    // 清空战斗日志
    document.getElementById('penglaiBattleLog').innerHTML = '';
    
    // 添加战斗开始日志
    addPenglaiBattleLog('=== 蓬莱仙岛副本挑战开始 ===');
    addPenglaiBattleLog(`挑战太古饕鬄 Lv.${player.penglaiIsland.bossLevel}`);
    addPenglaiBattleLog(`BOSS生命: ${formatSci(player.penglaiIsland.bossHealth)}`);
    addPenglaiBattleLog(`BOSS攻击: ${formatSci(player.penglaiIsland.bossAttack)}`);
    
    updatePenglaiIslandUI();
    logAction('开始挑战蓬莱仙岛副本太古饕鬄！', 'success');
}

// 攻击蓬莱仙岛BOSS
function attackPenglaiBoss() {
    if (!player.penglaiIsland.isBattling) return;
    
    const playerAttack = player.penglaiIsland.playerAttack;
    const critRate = player.penglaiIsland.playerCritRate;
    const critDamage = player.penglaiIsland.playerCritDamage;
    
    // 计算伤害（考虑暴击）
    const isCrit = Math.random() < critRate;
    let damage = playerAttack;
    
    if (isCrit) {
        damage *= critDamage;
    }
    
    // 应用伤害
    player.penglaiIsland.bossHealth -= damage;
    
    // 记录攻击日志
    addPenglaiBattleLog(`你对太古饕鬄造成了${formatSci(damage)}点${isCrit ? '暴击 ' : ''}伤害`);
    addPenglaiBattleLog(`BOSS剩余生命: ${formatSci(player.penglaiIsland.bossHealth)}/${formatSci(player.penglaiIsland.bossMaxHealth)}`);
    
    // 检查BOSS是否死亡
    if (player.penglaiIsland.bossHealth <= 0) {
        handlePenglaiBossDefeated();
    } else {
        // BOSS反击
        penglaiBossCounterAttack();
    }
    
    updatePenglaiIslandUI();
}

// BOSS反击
function penglaiBossCounterAttack() {
    const bossAttack = player.penglaiIsland.bossAttack;
    
    // 应用伤害
    player.penglaiIsland.playerHealth -= bossAttack;
    
    // 记录反击日志
    addPenglaiBattleLog(`太古饕鬄对你造成了${formatSci(bossAttack)}点伤害`);
    addPenglaiBattleLog(`你剩余生命: ${formatSci(player.penglaiIsland.playerHealth)}`);
    
    // 检查玩家是否死亡
    if (player.penglaiIsland.playerHealth <= 0) {
        handlePenglaiPlayerDefeated();
    }
    
    updatePenglaiIslandUI();
}

// 处理BOSS被击败
function handlePenglaiBossDefeated() {
    player.penglaiIsland.bossResurrections++;
    
    if (player.penglaiIsland.bossResurrections < 10) {
        // BOSS复活（属性提升3倍）
        player.penglaiIsland.bossHealth = player.penglaiIsland.bossMaxHealth * Math.pow(3, player.penglaiIsland.bossResurrections);
        player.penglaiIsland.bossAttack *= 3;
        
        addPenglaiBattleLog(`太古饕鬄复活了！(第${player.penglaiIsland.bossResurrections}次复活)`);
        addPenglaiBattleLog(`BOSS属性提升3倍！`);
        
        // BOSS复活后立即反击
        penglaiBossCounterAttack();
    } else {
        // BOSS真正死亡，进入下一级
        addPenglaiBattleLog(`太古饕鬄被彻底击败！`);
        player.penglaiIsland.bossLevel++;
        
        // 计算下一级BOSS属性（每级提升1e20倍）
        const levelMultiplier = Math.pow(1e20, player.penglaiIsland.bossLevel - 1);
        player.penglaiIsland.bossMaxHealth = 1e120 * levelMultiplier;
        player.penglaiIsland.bossHealth = player.penglaiIsland.bossMaxHealth;
        player.penglaiIsland.bossAttack = 1e15 * levelMultiplier;
        player.penglaiIsland.bossResurrections = 0;
        
        addPenglaiBattleLog(`太古饕鬄晋升至 Lv.${player.penglaiIsland.bossLevel}`);
        addPenglaiBattleLog(`BOSS属性提升${formatSci(levelMultiplier)}倍！`);
        
        // 新等级BOSS立即反击
        penglaiBossCounterAttack();
    }
}

// 处理玩家被击败
function handlePenglaiPlayerDefeated() {
    addPenglaiBattleLog('=== 你被太古饕鬄击败了！ ===');
    player.penglaiIsland.isBattling = false;
    
    // 只在等级2及以上显示奖励界面
    if (player.penglaiIsland.bossLevel >= 2) {
        showPenglaiRewards();
    } else {
        addPenglaiBattleLog('等级1没有奖励，请继续挑战！');
    }
    
    updatePenglaiIslandUI();
}

// 逃跑函数
function fleePenglaiBattle() {
    addPenglaiBattleLog('=== 你选择逃离战斗 ===');
    player.penglaiIsland.isBattling = false;
    
    // 只在等级2及以上显示奖励界面
    if (player.penglaiIsland.bossLevel >= 2) {
        showPenglaiRewards();
    } else {
        addPenglaiBattleLog('等级1没有奖励，请继续挑战！');
    }
    
    updatePenglaiIslandUI();
}

// 显示奖励界面
function showPenglaiRewards() {
    // 只在等级2及以上计算奖励
    if (player.penglaiIsland.bossLevel < 2) {
        return;
    }
    
    const rewardMultiplier = player.penglaiIsland.bossLevel - 1; // 等级2开始有奖励，倍数为1
    const rewards = calculatePenglaiRewards(rewardMultiplier);
    
    // 更新奖励界面显示
    document.getElementById('penglaiRewardBossLevel').textContent = player.penglaiIsland.bossLevel;
    document.getElementById('penglaiRewardMultiplier').textContent = rewardMultiplier;
    
    // 显示奖励物品
    const rewardItemsContainer = document.getElementById('penglaiRewardItems');
    rewardItemsContainer.innerHTML = '';
    
    Object.entries(rewards).forEach(([itemName, quantity]) => {
        const itemDiv = document.createElement('div');
        itemDiv.style.margin = '5px 0';
        itemDiv.innerHTML = `<span style="color: #ffd700;">${itemName}</span>: ${quantity}个`;
        rewardItemsContainer.appendChild(itemDiv);
    });
    
    // 显示奖励界面
    document.getElementById('penglaiRewardOverlay').style.display = 'block';
    document.getElementById('penglaiRewardUI').style.display = 'block';
}

// 计算奖励
function calculatePenglaiRewards(multiplier) {
    const rewards = {};
    
    Object.entries(penglaiRewards.baseRewards).forEach(([itemName, range]) => {
        const baseQuantity = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        const finalQuantity = baseQuantity * multiplier;
        rewards[itemName] = finalQuantity;
        
        // 添加到玩家物品
        const itemKey = penglaiRewards.itemMapping[itemName];
        if (itemKey) {
            player.items[itemKey] = (player.items[itemKey] || 0) + finalQuantity;
        }
    });
    
    return rewards;
}

// 关闭奖励界面
function closePenglaiReward() {
    document.getElementById('penglaiRewardOverlay').style.display = 'none';
    document.getElementById('penglaiRewardUI').style.display = 'none';
    
    // 记录奖励日志
    logAction('蓬莱仙岛副本挑战结束，获得丰厚奖励！', 'success');
    updateDisplay();
}

// 添加战斗日志
function addPenglaiBattleLog(message) {
    const logContainer = document.getElementById('penglaiBattleLog');
    const logEntry = document.createElement('div');
    logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logEntry.style.margin = '2px 0';
    logEntry.style.padding = '2px 5px';
    
    // 根据消息类型添加颜色
    if (message.includes('击败') || message.includes('奖励')) {
        logEntry.style.color = '#00ff00';
    } else if (message.includes('伤害')) {
        logEntry.style.color = '#ffa500';
    } else if (message.includes('复活')) {
        logEntry.style.color = '#ff0000';
    }
    
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}


function toggleLunhuiFuben() {
    if (!player.lunhuiFuben) {
        player.lunhuiFuben = { bossLevel: 1, bossHealth: 1e98, bossAttack: 1e8, bossMaxHealth: 1e98, bossResurrections: 0, isBattling: false, playerHealth: 0, playerAttack: 0, playerCritRate: 0, playerCritDamage: 0 };
    }
    if (player.level.ascentionCounta < 2) {
        alert("需要达到轮回2转才能开启轮回试炼副本！");
        return;
    }
    const overlay = document.getElementById('lunhuiFubenOverlay');
    const ui = document.getElementById('lunhuiFubenUI');
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        if (player.lunhuiFuben.autoBattleInterval) {
            clearInterval(player.lunhuiFuben.autoBattleInterval);
            player.lunhuiFuben.autoBattleInterval = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateLunhuiFubenUI();
    }
}

function updateLunhuiFubenUI() {
    document.getElementById('lunhuiFubenTokenCount').textContent = player.items.fuben1 || 0;
    const playerStats = calculatePlayerBattleStats();
    document.getElementById('lunhuiFubenPlayerHealth').textContent = formatSci(playerStats.health);
    document.getElementById('lunhuiFubenPlayerAttack').textContent = formatSci(playerStats.attack);
    document.getElementById('lunhuiFubenPlayerCritRate').textContent = (playerStats.critRate * 100).toFixed(2) + '%';
    document.getElementById('lunhuiFubenPlayerCritDamage').textContent = (playerStats.critDamage * 100).toFixed(2) + '%';
    document.getElementById('lunhuiFubenBossLevel').textContent = player.lunhuiFuben.bossLevel;
    document.getElementById('lunhuiFubenBossHealth').textContent = formatSci(player.lunhuiFuben.bossHealth);
    document.getElementById('lunhuiFubenBossMaxHealth').textContent = formatSci(player.lunhuiFuben.bossMaxHealth);
    document.getElementById('lunhuiFubenBossAttack').textContent = formatSci(player.lunhuiFuben.bossAttack);
    document.getElementById('lunhuiFubenBossResurrections').textContent = player.lunhuiFuben.bossResurrections;
    const startBtn = document.getElementById('startLunhuiFubenBattleBtn');
    const attackBtn = document.getElementById('attackLunhuiFubenBossBtn');
    const fleeBtn = document.getElementById('fleeLunhuiFubenBossBtn');
    if (player.lunhuiFuben.isBattling) {
        startBtn.style.display = 'none';
        attackBtn.style.display = 'inline-block';
        fleeBtn.style.display = 'inline-block';
    } else {
        startBtn.style.display = 'inline-block';
        attackBtn.style.display = 'none';
        fleeBtn.style.display = 'none';
    }
}

function startLunhuiFubenBattle() {
    if (!player.items.fuben1 || player.items.fuben1 < 1) {
        logAction('副本令牌不足！', 'error');
        return;
    }
    player.items.fuben1--;
    player.lunhuiFuben.bossLevel = 1;
    player.lunhuiFuben.bossMaxHealth = 1e98;
    player.lunhuiFuben.bossHealth = 1e98;
    player.lunhuiFuben.bossAttack = 1e8;
    player.lunhuiFuben.bossResurrections = 0;
    player.lunhuiFuben.isBattling = true;
    const playerStats = calculatePlayerBattleStats();
    player.lunhuiFuben.playerHealth = playerStats.health;
    player.lunhuiFuben.playerAttack = playerStats.attack;
    player.lunhuiFuben.playerCritRate = playerStats.critRate;
    player.lunhuiFuben.playerCritDamage = playerStats.critDamage;
    document.getElementById('lunhuiFubenBattleLog').innerHTML = '';
    addLunhuiFubenBattleLog('=== 轮回试炼副本挑战开始 ===');
    addLunhuiFubenBattleLog('挑战太古混沌 Lv.' + player.lunhuiFuben.bossLevel);
    addLunhuiFubenBattleLog('BOSS生命: ' + formatSci(player.lunhuiFuben.bossHealth));
    addLunhuiFubenBattleLog('BOSS攻击: ' + formatSci(player.lunhuiFuben.bossAttack));
    updateLunhuiFubenUI();
    logAction('开始挑战轮回试炼副本太古混沌！', 'success');
}

function attackLunhuiFubenBoss() {
    if (!player.lunhuiFuben.isBattling) return;
    const playerAttack = player.lunhuiFuben.playerAttack;
    const critRate = player.lunhuiFuben.playerCritRate;
    const critDamage = player.lunhuiFuben.playerCritDamage;
    const isCrit = Math.random() < critRate;
    let damage = playerAttack;
    if (isCrit) damage *= critDamage;
    player.lunhuiFuben.bossHealth -= damage;
    addLunhuiFubenBattleLog('你对太古混沌造成了' + formatSci(damage) + '点' + (isCrit ? '暴击 ' : '') + '伤害');
    addLunhuiFubenBattleLog('BOSS剩余生命: ' + formatSci(player.lunhuiFuben.bossHealth) + '/' + formatSci(player.lunhuiFuben.bossMaxHealth));
    if (player.lunhuiFuben.bossHealth <= 0) {
        handleLunhuiFubenBossDefeated();
    } else {
        lunhuiFubenBossCounterAttack();
    }
    updateLunhuiFubenUI();
}

function lunhuiFubenBossCounterAttack() {
    const bossAttack = player.lunhuiFuben.bossAttack;
    player.lunhuiFuben.playerHealth -= bossAttack;
    addLunhuiFubenBattleLog('太古混沌对你造成了' + formatSci(bossAttack) + '点伤害');
    addLunhuiFubenBattleLog('你剩余生命: ' + formatSci(player.lunhuiFuben.playerHealth));
    if (player.lunhuiFuben.playerHealth <= 0) {
        handleLunhuiFubenPlayerDefeated();
    }
    updateLunhuiFubenUI();
}

function handleLunhuiFubenBossDefeated() {
    player.lunhuiFuben.bossResurrections++;
    if (player.lunhuiFuben.bossResurrections < 10) {
        player.lunhuiFuben.bossHealth = player.lunhuiFuben.bossMaxHealth * Math.pow(3, player.lunhuiFuben.bossResurrections);
        player.lunhuiFuben.bossAttack *= 3;
        addLunhuiFubenBattleLog('太古混沌复活了！(第' + player.lunhuiFuben.bossResurrections + '次复活)');
        addLunhuiFubenBattleLog('BOSS属性提升3倍！');
        lunhuiFubenBossCounterAttack();
    } else {
        addLunhuiFubenBattleLog('太古混沌被彻底击败！');
        player.lunhuiFuben.bossLevel++;
        const levelMultiplier = Math.pow(1e8, player.lunhuiFuben.bossLevel - 1);
        player.lunhuiFuben.bossMaxHealth = 1e98 * levelMultiplier;
        player.lunhuiFuben.bossHealth = player.lunhuiFuben.bossMaxHealth;
        player.lunhuiFuben.bossAttack = 1e8 * levelMultiplier;
        player.lunhuiFuben.bossResurrections = 0;
        addLunhuiFubenBattleLog('太古混沌晋升至 Lv.' + player.lunhuiFuben.bossLevel);
        addLunhuiFubenBattleLog('BOSS属性提升' + formatSci(levelMultiplier) + '倍！');
        lunhuiFubenBossCounterAttack();
    }
}

function handleLunhuiFubenPlayerDefeated() {
    addLunhuiFubenBattleLog('=== 你被太古混沌击败了！ ===');
    player.lunhuiFuben.isBattling = false;
    if (player.lunhuiFuben.bossLevel >= 2) {
        showLunhuiFubenRewards();
    } else {
        addLunhuiFubenBattleLog('等级1没有奖励，请继续挑战！');
    }
    updateLunhuiFubenUI();
}

function fleeLunhuiFubenBattle() {
    addLunhuiFubenBattleLog('=== 你选择逃离战斗 ===');
    player.lunhuiFuben.isBattling = false;
    if (player.lunhuiFuben.bossLevel >= 2) {
        showLunhuiFubenRewards();
    } else {
        addLunhuiFubenBattleLog('等级1没有奖励，请继续挑战！');
    }
    updateLunhuiFubenUI();
}

function showLunhuiFubenRewards() {
    if (player.lunhuiFuben.bossLevel < 2) return;
    const rewardMultiplier = player.lunhuiFuben.bossLevel - 1;
    const rewardResult = calculateLunhuiFubenRewards(rewardMultiplier);
    document.getElementById('lunhuiFubenRewardBossLevel').textContent = player.lunhuiFuben.bossLevel;
    document.getElementById('lunhuiFubenRewardMultiplier').textContent = rewardMultiplier;
    const container = document.getElementById('lunhuiFubenRewardItems');
    container.innerHTML = '';
    rewardResult.texts.forEach(function(t) {
        const div = document.createElement('div');
        div.style.margin = '5px 0';
        div.innerHTML = '<span style="color: #ffd700;">' + t + '</span>';
        container.appendChild(div);
    });
    document.getElementById('lunhuiFubenRewardOverlay').style.display = 'block';
    document.getElementById('lunhuiFubenRewardUI').style.display = 'block';
}

// 轮回试炼副本神兽蛋数量结构（与圣兽岛等副本一致：min~max 随机后乘倍数）
const lunhuiFubenEggRange = { min: 1, max: 2 };

function calculateLunhuiFubenRewards(multiplier) {
    const texts = [];
    if (Math.random() < 0.30) {
        // 从第2关起 1 件+1 只，第3关 2 件+2 只，第4关 3 件+3 只… 即数量 = multiplier
        var count = Math.max(1, multiplier);
        if (!player.reincarnationEquipment) {
            player.reincarnationEquipment = { inventory: [], equipped: { helmet: null, chest: null, pants: null, shoes: null, necklace: null, weapon: null }, lockedItems: [], batchDiscardMode: false, selectedItems: [] };
        }
        if (!player.beasts) player.beasts = { inventory: [], equipped: [] };
        if (!player.beasts.inventory) player.beasts.inventory = [];
        for (var i = 0; i < count; i++) {
            var eq = generateT1ReincarnationEquipment();
            if (eq) {
                player.reincarnationEquipment.inventory.push(eq);
                texts.push('获得T1轮回装备: ' + eq.name + ' (' + reincarnationEquipmentConfig.rarities[eq.rarity].name + ')');
                logAction('获得T1轮回装备: ' + eq.name, 'success');
            }
            var beast = generateS1Beast();
            if (beast) {
                player.beasts.inventory.push(beast);
                texts.push('获得S1轮回神兽: ' + beast.name + '（' + beast.rarity + '·S1）');
                logAction('获得S1轮回神兽: ' + beast.name + '（' + beast.rarity + '·S1）', 'legendary');
            }
        }
        if (typeof updateBeastUI === 'function') updateBeastUI();
    } else {
        // 神兽蛋与前面副本一致：(min~max 随机) * 倍数
        var baseEgg = Math.floor(Math.random() * (lunhuiFubenEggRange.max - lunhuiFubenEggRange.min + 1)) + lunhuiFubenEggRange.min;
        var eggAmount = baseEgg * Math.max(1, multiplier);
        player.items.shenshou1 = (player.items.shenshou1 || 0) + eggAmount;
        texts.push('神兽蛋 x' + eggAmount);
        logAction('获得神兽蛋 x' + eggAmount, 'success');
    }
    if (typeof updateReincarnationEquipmentUI === 'function') updateReincarnationEquipmentUI();
    return { texts: texts };
}

function closeLunhuiFubenReward() {
    document.getElementById('lunhuiFubenRewardOverlay').style.display = 'none';
    document.getElementById('lunhuiFubenRewardUI').style.display = 'none';
    logAction('轮回试炼副本挑战结束，获得奖励！', 'success');
    updateDisplay();
}

function addLunhuiFubenBattleLog(message) {
    var logContainer = document.getElementById('lunhuiFubenBattleLog');
    if (!logContainer) return;
    var logEntry = document.createElement('div');
    logEntry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + message;
    logEntry.style.margin = '2px 0';
    logEntry.style.padding = '2px 5px';
    if (message.indexOf('击败') !== -1 || message.indexOf('奖励') !== -1) logEntry.style.color = '#00ff00';
    else if (message.indexOf('伤害') !== -1) logEntry.style.color = '#ffa500';
    else if (message.indexOf('复活') !== -1) logEntry.style.color = '#ff0000';
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

// ========== 轮回仙岛副本（数值=蓬莱×1e3，掉落 20% T2+S2 / 20% 神兽蛋 / 20% 秘法符文 / 20% 黑龙王翅膀 / 20% 远古圣兽精魄） ==========
function toggleLunhuiPenglai() {
    if (!player.lunhuiPenglai) {
        player.lunhuiPenglai = { bossLevel: 1, bossHealth: 1e123, bossAttack: 1e23, bossMaxHealth: 1e123, bossResurrections: 0, isBattling: false, playerHealth: 0, playerAttack: 0, playerCritRate: 0, playerCritDamage: 0 };
    }
    if (player.level.ascentionCounta < 3) {
        alert("需要达到轮回3转才能开启轮回仙岛副本！");
        return;
    }
    var overlay = document.getElementById('lunhuiPenglaiOverlay');
    var ui = document.getElementById('lunhuiPenglaiUI');
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
        if (player.lunhuiPenglai.autoBattleInterval) {
            clearInterval(player.lunhuiPenglai.autoBattleInterval);
            player.lunhuiPenglai.autoBattleInterval = null;
        }
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateLunhuiPenglaiUI();
    }
}

function updateLunhuiPenglaiUI() {
    document.getElementById('lunhuiPenglaiTokenCount').textContent = player.items.fuben1 || 0;
    var playerStats = calculatePlayerBattleStats();
    document.getElementById('lunhuiPenglaiPlayerHealth').textContent = formatSci(playerStats.health);
    document.getElementById('lunhuiPenglaiPlayerAttack').textContent = formatSci(playerStats.attack);
    document.getElementById('lunhuiPenglaiPlayerCritRate').textContent = (playerStats.critRate * 100).toFixed(2) + '%';
    document.getElementById('lunhuiPenglaiPlayerCritDamage').textContent = (playerStats.critDamage * 100).toFixed(2) + '%';
    document.getElementById('lunhuiPenglaiBossLevel').textContent = player.lunhuiPenglai.bossLevel;
    document.getElementById('lunhuiPenglaiBossHealth').textContent = formatSci(player.lunhuiPenglai.bossHealth);
    document.getElementById('lunhuiPenglaiBossMaxHealth').textContent = formatSci(player.lunhuiPenglai.bossMaxHealth);
    document.getElementById('lunhuiPenglaiBossAttack').textContent = formatSci(player.lunhuiPenglai.bossAttack);
    document.getElementById('lunhuiPenglaiBossResurrections').textContent = player.lunhuiPenglai.bossResurrections;
    var startBtn = document.getElementById('startLunhuiPenglaiBattleBtn');
    var attackBtn = document.getElementById('attackLunhuiPenglaiBossBtn');
    var fleeBtn = document.getElementById('fleeLunhuiPenglaiBossBtn');
    if (player.lunhuiPenglai.isBattling) {
        startBtn.style.display = 'none';
        attackBtn.style.display = 'inline-block';
        fleeBtn.style.display = 'inline-block';
    } else {
        startBtn.style.display = 'inline-block';
        attackBtn.style.display = 'none';
        fleeBtn.style.display = 'none';
    }
}

function startLunhuiPenglaiBattle() {
    if (!player.items.fuben1 || player.items.fuben1 < 1) {
        logAction('副本令牌不足！', 'error');
        return;
    }
    player.items.fuben1--;
    player.lunhuiPenglai.bossLevel = 1;
    player.lunhuiPenglai.bossMaxHealth = 1e123;
    player.lunhuiPenglai.bossHealth = 1e123;
    player.lunhuiPenglai.bossAttack = 1e23;
    player.lunhuiPenglai.bossResurrections = 0;
    player.lunhuiPenglai.isBattling = true;
    var playerStats = calculatePlayerBattleStats();
    player.lunhuiPenglai.playerHealth = playerStats.health;
    player.lunhuiPenglai.playerAttack = playerStats.attack;
    player.lunhuiPenglai.playerCritRate = playerStats.critRate;
    player.lunhuiPenglai.playerCritDamage = playerStats.critDamage;
    document.getElementById('lunhuiPenglaiBattleLog').innerHTML = '';
    addLunhuiPenglaiBattleLog('=== 轮回仙岛副本挑战开始 ===');
    addLunhuiPenglaiBattleLog('挑战太古玄冥 Lv.' + player.lunhuiPenglai.bossLevel);
    addLunhuiPenglaiBattleLog('BOSS生命: ' + formatSci(player.lunhuiPenglai.bossHealth));
    addLunhuiPenglaiBattleLog('BOSS攻击: ' + formatSci(player.lunhuiPenglai.bossAttack));
    updateLunhuiPenglaiUI();
    logAction('开始挑战轮回仙岛副本太古玄冥！', 'success');
}

function attackLunhuiPenglaiBoss() {
    if (!player.lunhuiPenglai.isBattling) return;
    var playerAttack = player.lunhuiPenglai.playerAttack;
    var critRate = player.lunhuiPenglai.playerCritRate;
    var critDamage = player.lunhuiPenglai.playerCritDamage;
    var isCrit = Math.random() < critRate;
    var damage = playerAttack;
    if (isCrit) damage *= critDamage;
    player.lunhuiPenglai.bossHealth -= damage;
    addLunhuiPenglaiBattleLog('你对太古玄冥造成了' + formatSci(damage) + '点' + (isCrit ? '暴击 ' : '') + '伤害');
    addLunhuiPenglaiBattleLog('BOSS剩余生命: ' + formatSci(player.lunhuiPenglai.bossHealth) + '/' + formatSci(player.lunhuiPenglai.bossMaxHealth));
    if (player.lunhuiPenglai.bossHealth <= 0) {
        handleLunhuiPenglaiBossDefeated();
    } else {
        lunhuiPenglaiBossCounterAttack();
    }
    updateLunhuiPenglaiUI();
}

function lunhuiPenglaiBossCounterAttack() {
    var bossAttack = player.lunhuiPenglai.bossAttack;
    player.lunhuiPenglai.playerHealth -= bossAttack;
    addLunhuiPenglaiBattleLog('太古玄冥对你造成了' + formatSci(bossAttack) + '点伤害');
    addLunhuiPenglaiBattleLog('你剩余生命: ' + formatSci(player.lunhuiPenglai.playerHealth));
    if (player.lunhuiPenglai.playerHealth <= 0) {
        handleLunhuiPenglaiPlayerDefeated();
    }
    updateLunhuiPenglaiUI();
}

function handleLunhuiPenglaiBossDefeated() {
    player.lunhuiPenglai.bossResurrections++;
    if (player.lunhuiPenglai.bossResurrections < 10) {
        player.lunhuiPenglai.bossHealth = player.lunhuiPenglai.bossMaxHealth * Math.pow(3, player.lunhuiPenglai.bossResurrections);
        player.lunhuiPenglai.bossAttack *= 3;
        addLunhuiPenglaiBattleLog('太古玄冥复活了！(第' + player.lunhuiPenglai.bossResurrections + '次复活)');
        addLunhuiPenglaiBattleLog('BOSS属性提升3倍！');
        lunhuiPenglaiBossCounterAttack();
    } else {
        addLunhuiPenglaiBattleLog('太古玄冥被彻底击败！');
        player.lunhuiPenglai.bossLevel++;
        var levelMultiplier = Math.pow(1e23, player.lunhuiPenglai.bossLevel - 1);
        player.lunhuiPenglai.bossMaxHealth = 1e123 * levelMultiplier;
        player.lunhuiPenglai.bossHealth = player.lunhuiPenglai.bossMaxHealth;
        player.lunhuiPenglai.bossAttack = 1e18 * levelMultiplier;
        player.lunhuiPenglai.bossResurrections = 0;
        addLunhuiPenglaiBattleLog('太古玄冥晋升至 Lv.' + player.lunhuiPenglai.bossLevel);
        addLunhuiPenglaiBattleLog('BOSS属性提升' + formatSci(levelMultiplier) + '倍！');
        lunhuiPenglaiBossCounterAttack();
    }
}

function handleLunhuiPenglaiPlayerDefeated() {
    addLunhuiPenglaiBattleLog('=== 你被太古玄冥击败了！ ===');
    player.lunhuiPenglai.isBattling = false;
    if (player.lunhuiPenglai.bossLevel >= 2) {
        showLunhuiPenglaiRewards();
    } else {
        addLunhuiPenglaiBattleLog('等级1没有奖励，请继续挑战！');
    }
    updateLunhuiPenglaiUI();
}

function fleeLunhuiPenglaiBattle() {
    addLunhuiPenglaiBattleLog('=== 你选择逃离战斗 ===');
    player.lunhuiPenglai.isBattling = false;
    if (player.lunhuiPenglai.bossLevel >= 2) {
        showLunhuiPenglaiRewards();
    } else {
        addLunhuiPenglaiBattleLog('等级1没有奖励，请继续挑战！');
    }
    updateLunhuiPenglaiUI();
}

function showLunhuiPenglaiRewards() {
    if (player.lunhuiPenglai.bossLevel < 2) return;
    var rewardMultiplier = player.lunhuiPenglai.bossLevel - 1;
    var rewardResult = calculateLunhuiPenglaiRewards(rewardMultiplier);
    document.getElementById('lunhuiPenglaiRewardBossLevel').textContent = player.lunhuiPenglai.bossLevel;
    document.getElementById('lunhuiPenglaiRewardMultiplier').textContent = rewardMultiplier;
    var container = document.getElementById('lunhuiPenglaiRewardItems');
    container.innerHTML = '';
    rewardResult.texts.forEach(function(t) {
        var div = document.createElement('div');
        div.style.margin = '5px 0';
        div.innerHTML = '<span style="color: #ffd700;">' + t + '</span>';
        container.appendChild(div);
    });
    document.getElementById('lunhuiPenglaiRewardOverlay').style.display = 'block';
    document.getElementById('lunhuiPenglaiRewardUI').style.display = 'block';
}

// 轮回仙岛掉落数量结构（与轮回试炼一致：神兽蛋 1~2*倍数，其余 1~3*倍数）
var lunhuiPenglaiEggRange = { min: 1, max: 2 };
var lunhuiPenglaiOtherRange = { min: 1, max: 3 };

function calculateLunhuiPenglaiRewards(multiplier) {
    var texts = [];
    var mult = Math.max(1, multiplier);
    var r = Math.random();
    if (r < 0.20) {
        if (!player.reincarnationEquipment) {
            player.reincarnationEquipment = { inventory: [], equipped: { helmet: null, chest: null, pants: null, shoes: null, necklace: null, weapon: null }, lockedItems: [], batchDiscardMode: false, selectedItems: [] };
        }
        if (!player.beasts) player.beasts = { inventory: [], equipped: [] };
        if (!player.beasts.inventory) player.beasts.inventory = [];
        for (var i = 0; i < mult; i++) {
            var eq = generateT2ReincarnationEquipment();
            if (eq) {
                player.reincarnationEquipment.inventory.push(eq);
                texts.push('获得T2轮回装备: ' + eq.name + ' (' + reincarnationEquipmentConfig.rarities[eq.rarity].name + ')');
                logAction('获得T2轮回装备: ' + eq.name, 'success');
            }
            var beast = generateS2Beast();
            if (beast) {
                player.beasts.inventory.push(beast);
                texts.push('获得S2轮回神兽: ' + beast.name + '（' + beast.rarity + '·S2）');
                logAction('获得S2轮回神兽: ' + beast.name + '（' + beast.rarity + '·S2）', 'legendary');
            }
        }
        if (typeof updateBeastUI === 'function') updateBeastUI();
    } else if (r < 0.40) {
        var baseEgg = Math.floor(Math.random() * (lunhuiPenglaiEggRange.max - lunhuiPenglaiEggRange.min + 1)) + lunhuiPenglaiEggRange.min;
        var eggAmount = baseEgg * mult;
        player.items.shenshou1 = (player.items.shenshou1 || 0) + eggAmount;
        texts.push('神兽蛋 x' + eggAmount);
        logAction('获得神兽蛋 x' + eggAmount, 'success');
    } else if (r < 0.60) {
        var baseFuwen = Math.floor(Math.random() * (lunhuiPenglaiOtherRange.max - lunhuiPenglaiOtherRange.min + 1)) + lunhuiPenglaiOtherRange.min;
        var fuwenAmount = baseFuwen * mult;
        player.items.fuwen1 = (player.items.fuwen1 || 0) + fuwenAmount;
        texts.push('秘法符文 x' + fuwenAmount);
        logAction('获得秘法符文 x' + fuwenAmount, 'success');
    } else if (r < 0.80) {
        var baseWing = Math.floor(Math.random() * (lunhuiPenglaiOtherRange.max - lunhuiPenglaiOtherRange.min + 1)) + lunhuiPenglaiOtherRange.min;
        var wingAmount = baseWing * mult;
        player.items.chiban1 = (player.items.chiban1 || 0) + wingAmount;
        texts.push('黑龙王翅膀 x' + wingAmount);
        logAction('获得黑龙王翅膀 x' + wingAmount, 'success');
    } else {
        var baseJingpo = Math.floor(Math.random() * (lunhuiPenglaiOtherRange.max - lunhuiPenglaiOtherRange.min + 1)) + lunhuiPenglaiOtherRange.min;
        var jingpoAmount = baseJingpo * mult;
        player.items.zuoqi1 = (player.items.zuoqi1 || 0) + jingpoAmount;
        texts.push('远古圣兽精魄 x' + jingpoAmount);
        logAction('获得远古圣兽精魄 x' + jingpoAmount, 'success');
    }
    if (typeof updateReincarnationEquipmentUI === 'function') updateReincarnationEquipmentUI();
    return { texts: texts };
}

function closeLunhuiPenglaiReward() {
    document.getElementById('lunhuiPenglaiRewardOverlay').style.display = 'none';
    document.getElementById('lunhuiPenglaiRewardUI').style.display = 'none';
    logAction('轮回仙岛副本挑战结束，获得奖励！', 'success');
    updateDisplay();
}

function addLunhuiPenglaiBattleLog(message) {
    var logContainer = document.getElementById('lunhuiPenglaiBattleLog');
    if (!logContainer) return;
    var logEntry = document.createElement('div');
    logEntry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + message;
    logEntry.style.margin = '2px 0';
    logEntry.style.padding = '2px 5px';
    if (message.indexOf('击败') !== -1 || message.indexOf('奖励') !== -1) logEntry.style.color = '#00ff00';
    else if (message.indexOf('伤害') !== -1) logEntry.style.color = '#ffa500';
    else if (message.indexOf('复活') !== -1) logEntry.style.color = '#ff0000';
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

// 科学计数法格式化函数
function formatSci(number) {
    if (number >= 1e6) {
        return number.toExponential(3);
    }
    return Math.floor(number).toLocaleString();
}
// 切换时光秘境界面
function toggleTimeSecretRealm() {
   if (player.reincarnationCount < 2000) {
        alert("需要达到2000转才能开启秘境系统！");
        return;
    }
    const overlay = document.getElementById('timeSecretRealmOverlay');
    const ui = document.getElementById('timeSecretRealmUI');
    
    if (ui.style.display === 'block') {
        // 关闭界面
        ui.style.display = 'none';
        overlay.style.display = 'none';
        if (player.timeSecretRealm.timer) {
            clearInterval(player.timeSecretRealm.timer);
            player.timeSecretRealm.timer = null;
        }
    } else {
        // 打开界面
        ui.style.display = 'block';
        overlay.style.display = 'block';
        
        // 根据是否在冒险中显示不同的界面
        const tsr = player.timeSecretRealm;
        if (tsr.currentRun && tsr.currentRun.isActive) {
            // 冒险进行中，显示冒险界面
            document.getElementById('tsrDifficultySelection').style.display = 'none';
            document.getElementById('startTsrBtn').style.display = 'none';
            document.getElementById('openTsrShopBtn').style.display = 'none';
            document.getElementById('tsrStatusDisplay').style.display = 'block';
            document.getElementById('tsrRoomDisplay').style.display = 'block';
            document.getElementById('tsrActionControls').style.display = 'block';
            document.getElementById('tsrBuffsDisplay').style.display = 'block';
            document.getElementById('tsrSkillsDisplay').style.display = 'block';
            document.getElementById('tsrHealthBar').style.display = 'block';
        } else {
            // 不在冒险中，显示难度选择界面
            document.getElementById('tsrDifficultySelection').style.display = 'block';
            document.getElementById('startTsrBtn').style.display = 'inline-block';
            document.getElementById('openTsrShopBtn').style.display = 'inline-block';
            document.getElementById('tsrStatusDisplay').style.display = 'none';
            document.getElementById('tsrRoomDisplay').style.display = 'none';
            document.getElementById('tsrActionControls').style.display = 'none';
            document.getElementById('tsrBuffsDisplay').style.display = 'none';
            document.getElementById('tsrSkillsDisplay').style.display = 'none';
            document.getElementById('tsrHealthBar').style.display = 'none';
        }
        
        updateTimeSecretRealmUI();
    }
}


// 更新时光秘境界面
function updateTimeSecretRealmUI() {
    const tsr = player.timeSecretRealm;
    
    // 更新永久数据
    document.getElementById('tsrCurrency').textContent = tsr.currency.toFixed(0);
    document.getElementById('tsrBestFloor').textContent = tsr.bestFloor;
    document.getElementById('tsrClearCount').textContent = tsr.clearCount;
    
    // 更新难度选择界面
    updateDifficultyUI();
    
    // 更新当前冒险数据（仅在冒险进行时显示）
    if (tsr.currentRun.isActive) {
        const difficulty = tsr.difficulty.levels[tsr.currentRun.difficulty];
        const clearFloor = difficulty.clearFloor;
        const progress = Math.min(100, (tsr.currentRun.currentFloor / clearFloor) * 100);
        
        document.getElementById('tsrCurrentFloor').textContent = `${tsr.currentRun.currentFloor}/${clearFloor}`;
        document.getElementById('tsrTimeLeft').textContent = tsr.currentRun.timeLeft + '秒';
        document.getElementById('tsrTempBuffs').textContent = tsr.currentRun.tempBuffs.length + '个';
        document.getElementById('tsrCurrentCurrency').textContent = tsr.currentRun.currencyEarned;
        
        // 添加通关进度显示
        const progressElement = document.getElementById('tsrProgress');
        if (!progressElement) {
            // 如果进度条不存在，创建一个
            const statusDisplay = document.getElementById('tsrStatusDisplay');
            const progressHTML = `
                <div id="tsrProgress" style="margin-top: 10px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span>通关进度:</span>
                        <span>${tsr.currentRun.currentFloor}/${clearFloor} (${progress.toFixed(1)}%)</span>
                    </div>
                    <div style="background: #333; height: 10px; border-radius: 5px; overflow: hidden;">
                        <div style="background: linear-gradient(to right, #00bfff, #ffd700); height: 100%; width: ${progress}%; transition: width 0.3s;"></div>
                    </div>
                </div>
            `;
            statusDisplay.insertAdjacentHTML('beforeend', progressHTML);
        } else {
            // 更新现有进度条
            progressElement.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>通关进度:</span>
                    <span>${tsr.currentRun.currentFloor}/${clearFloor} (${progress.toFixed(1)}%)</span>
                </div>
                <div style="background: #333; height: 10px; border-radius: 5px; overflow: hidden;">
                    <div style="background: linear-gradient(to right, #00bfff, #ffd700); height: 100%; width: ${progress}%; transition: width 0.3s;"></div>
                </div>
            `;
        }
        
        updateCurrentRoomDisplay();
        updateBuffsDisplay();
        updateSkillsDisplay();
    }
}
// 难度选择函数
function selectTsrDifficulty(difficulty) {
    const tsr = player.timeSecretRealm;
    
    // 检查是否已解锁该难度
    if (!tsr.difficulty.unlocked.includes(difficulty)) {
        const condition = tsr.difficulty.levels[difficulty].unlockCondition;
        logAction(`尚未解锁${tsr.difficulty.levels[difficulty].name}难度！需要：${condition}`, 'error');
        return;
    }
    
    tsr.difficulty.current = difficulty;
    updateDifficultyUI();
    logAction(`已选择${tsr.difficulty.levels[difficulty].name}难度`, 'success');
}

// 更新难度UI显示
function updateDifficultyUI() {
    const tsr = player.timeSecretRealm;
    const difficulty = tsr.difficulty.levels[tsr.difficulty.current];
    
    // 更新按钮状态
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.style.opacity = '0.6';
        btn.style.transform = 'scale(0.95)';
        btn.style.boxShadow = 'none';
    });
    
    const currentBtn = document.getElementById(`difficulty${tsr.difficulty.current.charAt(0).toUpperCase() + tsr.difficulty.current.slice(1)}`);
    if (currentBtn) {
        currentBtn.style.opacity = '1';
        currentBtn.style.transform = 'scale(1.05)';
        currentBtn.style.boxShadow = '0 0 15px currentColor';
    }
    
    // 更新难度信息
    document.getElementById('difficultyDescription').innerHTML = `
        <strong>${difficulty.name}难度</strong>: ${difficulty.description}<br>
        <span style="color: #ff6b6b;">怪物强度: ${difficulty.multiplier}x</span> | 
        <span style="color: #ffd700;">奖励倍数: ${difficulty.rewardMultiplier}x</span><br>
        <span style="color: #00bfff;">通关要求: ${difficulty.clearFloor}层</span>
    `;
    
    // 更新解锁条件显示
    let unlockInfo = '<strong>已解锁难度:</strong> ';
    tsr.difficulty.unlocked.forEach((diff, index) => {
        unlockInfo += `${tsr.difficulty.levels[diff].name}${index < tsr.difficulty.unlocked.length - 1 ? ', ' : ''}`;
    });
    document.getElementById('difficultyUnlockCondition').innerHTML = unlockInfo;
}

// 检查难度解锁条件（与描述一致：简单3次→普通，普通5次→困难，困难10次→噩梦，噩梦20次→地狱）
function checkDifficultyUnlocks() {
    const tsr = player.timeSecretRealm;
    const levels = tsr.difficulty.levels;
    const unlocked = tsr.difficulty.unlocked;
    const c = tsr.clearCountByDifficulty || { easy: 0, normal: 0, hard: 0, nightmare: 0, hell: 0 };
    
    if (!unlocked.includes('normal') && c.easy >= 3) {
        unlocked.push('normal');
        logAction('解锁了普通难度！（通关简单难度3次）', 'success');
    }
    if (!unlocked.includes('hard') && c.normal >= 5) {
        unlocked.push('hard');
        logAction('解锁了困难难度！（通关普通难度5次）', 'success');
    }
    if (!unlocked.includes('nightmare') && c.hard >= 10) {
        unlocked.push('nightmare');
        logAction('解锁了噩梦难度！（通关困难难度10次）', 'success');
    }
    if (!unlocked.includes('hell') && c.nightmare >= 20) {
        unlocked.push('hell');
        logAction('解锁了地狱难度！（通关噩梦难度20次）', 'success');
    }
    
    updateDifficultyUI();
}




// 开始时光秘境冒险
function startTimeSecretRealm() {
    if (player.items.fuben2 < 1) {
        alert("需要至少 1 把秘境钥匙才能进入！");
        return;
    }
    const tsr = player.timeSecretRealm;
    const difficulty = tsr.difficulty.levels[tsr.difficulty.current];
    
    // 检查是否已选择难度
    if (!tsr.difficulty.current) {
        logAction("请先选择难度！", "error");
        return;
    }    
    // 消耗秘境钥匙
    player.items.fuben2--;
    // 隐藏难度选择界面
    document.getElementById('tsrDifficultySelection').style.display = 'none';
    document.getElementById('startTsrBtn').style.display = 'none';
    document.getElementById('openTsrShopBtn').style.display = 'none';
    
    // 计算基础时间（应用永久加成）
    const baseTime = 300 + (tsr.permanentBonuses?.baseTime || 0);
    const adjustedTime = Math.floor(baseTime * (1 / difficulty.multiplier));
    
    // 初始化当前冒险数据
    tsr.currentRun = {
        isActive: true,
        currentFloor: 1,
        difficulty: tsr.difficulty.current,
        difficultyMultiplier: difficulty.multiplier,
        rewardMultiplier: difficulty.rewardMultiplier,
        clearFloor: difficulty.clearFloor,
        timeLeft: adjustedTime, // 应用永久时间加成
        tempBuffs: [],
        currentRoom: null,
        exploredRooms: 0,
        currencyEarned: 0,
        playerHealth: calculateTsrPlayerHealth(),
        playerAttack: calculateTsrPlayerAttack(),
        consecutiveFloors: 0,
        lastAction: null
    };
    
    // 应用起始祝福效果
    applyStartingBuffs();
    
    // 应用陷阱感知药水（商店购买的“下次冒险生效”）
    if (tsr.nextRunDetectionBoost) {
        tsr.currentRun.detectionBoost = true;
        tsr.nextRunDetectionBoost = false;
    }
    
    // 生成第一个房间
    generateNewRoom();
    
    // 开始计时器
    startTsrTimer();
    
    // 显示冒险界面元素
    document.getElementById('tsrStatusDisplay').style.display = 'block';
    document.getElementById('tsrRoomDisplay').style.display = 'block';
    document.getElementById('tsrActionControls').style.display = 'block';
    document.getElementById('tsrBuffsDisplay').style.display = 'block';
    document.getElementById('tsrSkillsDisplay').style.display = 'block';
    document.getElementById('tsrHealthBar').style.display = 'block';
    
    // 更新界面
    updateTimeSecretRealmUI();
    updateHealthBar();
    
    // 添加开始日志
    addTsrLog(`=== ${difficulty.name}难度冒险开始 ===`);
    addTsrLog(`时间限制: ${tsr.currentRun.timeLeft}秒（基础${baseTime}秒 + 永久加成${tsr.permanentBonuses?.baseTime || 0}秒）`);
    addTsrLog(`怪物强度: ${difficulty.multiplier}x`);
    addTsrLog(`奖励倍数: ${difficulty.rewardMultiplier}x`);
    addTsrLog(`通关要求: ${difficulty.clearFloor}层`);
}
// 应用起始祝福效果
function applyStartingBuffs() {
    const tsr = player.timeSecretRealm;
    const startingBuffCount = tsr.permanentBonuses?.startingBuffs || 0;
    
    if (startingBuffCount <= 0) return;
    
    // 可用的起始增益类型
    const availableBuffTypes = ['attack', 'health', 'critRate', 'critDamage', 'speed'];
    
    for (let i = 0; i < startingBuffCount; i++) {
        // 随机选择一个增益类型
        const randomType = availableBuffTypes[Math.floor(Math.random() * availableBuffTypes.length)];
        const buff = getStartingBuffByType(randomType);
        
        if (buff) {
            addTempBuff(buff);
            addTsrLog(`起始祝福生效！获得${buff.name}`, 'success');
        }
    }
}

// 根据类型获取起始增益
function getStartingBuffByType(type) {
    const tsr = player.timeSecretRealm;
    const buffs = tsr.tempBuffs;
    
    switch(type) {
        case 'attack':
            return {
                name: '起始攻击强化',
                effect: 'attack',
                value: 0.3, // 起始效果稍弱
                timeBonus: 30,
                duration: 0,
                isDebuff: false
            };
        case 'health':
            return {
                name: '起始生命强化',
                effect: 'health',
                value: 0.3,
                timeBonus: 60,
                duration: 0,
                isDebuff: false
            };
        case 'critRate':
            return {
                name: '起始暴击强化',
                effect: 'critRate',
                value: 0.05,
                timeBonus: 90,
                duration: 0,
                isDebuff: false
            };
        case 'critDamage':
            return {
                name: '起始爆伤强化',
                effect: 'critDamage',
                value: 0.3,
                timeBonus: 120,
                duration: 0,
                isDebuff: false
            };
        case 'speed':
            return {
                name: '起始速度强化',
                effect: 'speed',
                value: 5,
                timeBonus: 150,
                duration: 0,
                isDebuff: false
            };
        default:
            return null;
    }
}
// 生成新房间
function generateNewRoom() {
    const tsr = player.timeSecretRealm;
    const difficultyMultiplier = tsr.currentRun.difficultyMultiplier;
    
    // 根据难度调整房间类型权重
    const roomWeights = {
        battle: Math.floor(40 * difficultyMultiplier), // 难度越高战斗房间越多
        event: 25,
        treasure: Math.floor(20 / difficultyMultiplier), // 难度越高宝箱越少
        rest: Math.floor(10 / difficultyMultiplier), // 难度越高休息房间越少
        shop: Math.floor(5 / difficultyMultiplier) // 难度越高商店越少
    };
    
    // 根据权重随机选择房间类型
    const totalWeight = Object.values(roomWeights).reduce((sum, weight) => sum + weight, 0);
    let randomValue = Math.random() * totalWeight;
    
    let selectedType = null;
    for (const [type, weight] of Object.entries(roomWeights)) {
        randomValue -= weight;
        if (randomValue <= 0) {
            selectedType = type;
            break;
        }
    }
    
    // 决定是否包含陷阱（难度越高陷阱越多）
    let hasTrap = false;
    let trap = null;
    if (selectedType !== 'rest' && Math.random() < (0.3 * difficultyMultiplier)) {
        hasTrap = true;
        trap = generateRandomTrap();
        // 难度越高陷阱越强
        if (trap.damageType === 'percentage' || trap.damageType === 'fixed') {
            trap.damage *= difficultyMultiplier;
        }
    }
    
    // 创建房间对象
    tsr.currentRun.currentRoom = {
        type: selectedType,
        name: tsr.roomTypes[selectedType].name,
        explored: false,
        hasTrap: hasTrap,
        trap: trap,
        trapDetected: false,
        trapDisarmed: false,
        rewards: generateRoomRewards(selectedType, difficultyMultiplier)
    };
    
    updateCurrentRoomDisplay();
}

// 生成随机陷阱
function generateRandomTrap() {
    const traps = player.timeSecretRealm.traps.types;
    const totalWeight = Object.values(traps).reduce((sum, trap) => sum + trap.weight, 0);
    let randomValue = Math.random() * totalWeight;
    
    for (const [trapType, config] of Object.entries(traps)) {
        randomValue -= config.weight;
        if (randomValue <= 0) {
            return {
                type: trapType,
                name: config.name,
                damageType: config.damageType,
                damage: config.damage,
                effect: config.effect,
                value: config.value,
                duration: config.duration
            };
        }
    }
    
    // 默认返回毒液陷阱
    return {
        type: 'poison',
        name: '毒液陷阱',
        damageType: 'percentage',
        damage: 0.15,
        duration: 3
    };
}

// 更新当前房间显示
function updateCurrentRoomDisplay() {
    const room = player.timeSecretRealm.currentRun.currentRoom;
    const container = document.getElementById('tsrCurrentRoom');
    
    if (!room) return;
    
    let roomContent = '';
    let roomColor = '#00bfff';
    
    switch(room.type) {
        case 'battle':
            roomContent = `
                <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间充满了危险的怪物...</div>
            `;
            roomColor = '#ff6b6b';
            break;
            
        case 'event':
            roomContent = `
                <div style="color: #00bfff; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间有一个神秘的事件...</div>
            `;
            roomColor = '#00bfff';
            break;
            
        case 'treasure':
            roomContent = `
                <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间有一个宝箱...</div>
            `;
            roomColor = '#ffd700';
            break;
            
        case 'rest':
            roomContent = `
                <div style="color: #32cd32; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间可以休息恢复...</div>
            `;
            roomColor = '#32cd32';
            break;
            
        case 'shop':
            roomContent = `
                <div style="color: #9370db; font-weight: bold; margin-bottom: 10px;">${room.name}</div>
                <div>这个房间有一个神秘商店...</div>
            `;
            roomColor = '#9370db';
            break;
    }
    
    // 添加陷阱信息
    if (room.hasTrap && !room.trapDisarmed) {
        if (room.trapDetected) {
            roomContent += `
                <div style="margin-top: 10px; padding: 5px; background: rgba(255, 0, 0, 0.2); border: 1px solid #ff0000; border-radius: 3px;">
                    <div style="color: #ff6b6b; font-weight: bold;">⚠️ 发现陷阱: ${room.trap.name}</div>
                    <div style="font-size: 12px; color: #ff6b6b;">${getTrapDescription(room.trap)}</div>
                </div>
            `;
        } else {
            roomContent += `
                <div style="margin-top: 10px; padding: 5px; background: rgba(255, 165, 0, 0.2); border: 1px dashed #ffa500; border-radius: 3px;">
                    <div style="color: #ffa500; font-size: 12px;">⚠️ 这个房间可能有陷阱...</div>
                </div>
            `;
        }
    }
    
    // 添加奖励信息（商店房间无秘境币奖励，显示可购买）
    if (room.type === 'shop') {
        roomContent += `<div style="margin-top: 10px; color: ${roomColor};">可在此购买临时强化（消耗本次冒险获得的秘境币）</div>`;
    } else {
        roomContent += `<div style="margin-top: 10px; color: ${roomColor};">奖励: ${room.rewards.currency}秘境币</div>`;
    }
    
    container.innerHTML = roomContent;
    
    // 更新行动按钮
    updateActionButtons();
}
// 获取陷阱描述
function getTrapDescription(trap) {
    switch(trap.damageType) {
        case 'percentage':
            return `造成${(trap.damage * 100)}%生命值的伤害，持续${trap.duration}回合`;
        case 'fixed':
            return `造成${formatSci(trap.damage)}点固定伤害`;
        case 'debuff':
            return `${trap.effect === 'attack' ? '攻击力' : '暴击率'}降低${(trap.value * 100)}%，持续${trap.duration}回合`;
        case 'time':
            return `减少${trap.damage}秒探索时间`;
        case 'random':
            return `随机造成${(trap.damage * 100)}%生命值的伤害`;
        default:
            return '未知效果的陷阱';
    }
}
function updateActionButtons() {
    const actionContainer = document.getElementById('tsrActionControls');
    
    // 添加侦查和解除按钮
    actionContainer.innerHTML = `
        <button onclick="tsrDetectTrap()" id="tsrDetectBtn" style="display: none; background: linear-gradient(to bottom, #ffa500, #daa520); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">侦查陷阱</button>
        <button onclick="tsrDisarmTrap()" id="tsrDisarmBtn" style="display: none; background: linear-gradient(to bottom, #32cd32, #228b22); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">解除陷阱</button>
        <button onclick="tsrExploreRoom()" id="tsrExploreBtn" style="display: inline-block; background: linear-gradient(to bottom, #1e90ff, #006994); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">探索房间</button>
        <button onclick="tsrRest()" id="tsrRestBtn" style="background: linear-gradient(to bottom, #9370db, #6a5acd); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">休息恢复</button>
        <button onclick="tsrNextFloor()" id="tsrNextFloorBtn" style="background: linear-gradient(to bottom, #ffa500, #daa520); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">前往下一层</button>
        <button onclick="tsrExitRealm()" id="tsrExitBtn" style="background: linear-gradient(to bottom, #dc143c, #8b0000); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;">退出秘境</button>
    `;
    
    // 更新按钮状态
    const room = player.timeSecretRealm.currentRun.currentRoom;
    const exploreBtn = document.getElementById('tsrExploreBtn');
    const detectBtn = document.getElementById('tsrDetectBtn');
    const disarmBtn = document.getElementById('tsrDisarmBtn');
    
    if (room.hasTrap && !room.trapDisarmed) {
        if (room.trapDetected) {
            exploreBtn.style.display = 'none';
            detectBtn.style.display = 'none';
            disarmBtn.style.display = 'inline-block';
        } else {
            exploreBtn.style.display = 'none';
            detectBtn.style.display = 'inline-block';
            disarmBtn.style.display = 'none';
        }
    } else {
        exploreBtn.style.display = 'inline-block';
        detectBtn.style.display = 'none';
        disarmBtn.style.display = 'none';
    }
}
// 更新增益效果显示
function updateBuffsDisplay() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrCurrentBuffs');
    container.innerHTML = '';
    
    if (!tsr.currentRun.tempBuffs || tsr.currentRun.tempBuffs.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; grid-column: 1 / -1;">无增益效果</div>';
        return;
    }
    
    tsr.currentRun.tempBuffs.forEach((buff, index) => {
        const buffElement = document.createElement('div');
        buffElement.style.cssText = `
            background: ${buff.isDebuff ? 'rgba(255, 0, 0, 0.2)' : 'rgba(0, 255, 0, 0.2)'};
            padding: 10px;
            border-radius: 5px;
            border: 1px solid ${buff.isDebuff ? '#ff6b6b' : '#32cd32'};
            position: relative;
        `;
        
        let effectText = '';
        let valueText = '';
        let effectDescription = '';
        
        // 修复：正确显示各种增益效果
        switch(buff.effect) {
            case 'attack':
                effectText = '攻击力';
                valueText = `${buff.value > 0 ? '+' : ''}${(buff.value * 100).toFixed(0)}%`;
                effectDescription = `攻击力提升${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'health':
                effectText = '生命值';
                valueText = `${buff.value > 0 ? '+' : ''}${(buff.value * 100).toFixed(0)}%`;
                effectDescription = `生命值提升${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'critRate':
                effectText = '暴击率';
                valueText = `${buff.value > 0 ? '+' : ''}${(buff.value * 100).toFixed(1)}%`;
                effectDescription = `暴击率提升${(buff.value * 100).toFixed(1)}%`;
                break;
            case 'critDamage':
                effectText = '爆伤';
                valueText = `${buff.value > 0 ? '+' : ''}${(buff.value * 100).toFixed(0)}%`;
                effectDescription = `爆伤提升${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'speed':
                effectText = '探索速度';
                valueText = buff.timeBonus ? `+${buff.timeBonus}秒` : `${buff.value > 0 ? '+' : ''}${buff.value}`;
                effectDescription = buff.timeBonus ? `探索时间+${buff.timeBonus}秒` : `探索速度提升`;
                break;
            case 'luck':
                effectText = '幸运';
                valueText = '双倍秘境币';
                effectDescription = '获得双倍秘境币';
                break;
            default:
                effectText = '未知效果';
                valueText = '';
                effectDescription = buff.name;
        }
        
        buffElement.innerHTML = `
            <div style="font-weight: bold; color: ${buff.isDebuff ? '#ff6b6b' : '#32cd32'}; margin-bottom: 5px;">
                ${buff.name}
            </div>
            <div style="font-size: 12px; color: ${buff.isDebuff ? '#ff6b6b' : '#32cd32'}; margin-bottom: 3px;">
                ${effectDescription}
            </div>
            ${buff.duration ? `
                <div style="font-size: 11px; color: #d8bfd8; margin-top: 5px;">
                    剩余: ${buff.duration}回合
                </div>
            ` : ''}
            ${buff.isDebuff ? `
                <div style="position: absolute; top: 5px; right: 5px; color: #ff6b6b;">⚠️</div>
            ` : `
                <div style="position: absolute; top: 5px; right: 5px; color: #32cd32;">✨</div>
            `}
        `;
        
        container.appendChild(buffElement);
    });
}
// 更新技能效果显示
function updateSkillsDisplay() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrCurrentSkills');
    container.innerHTML = '';
    
    const detectionSkill = tsr.traps.detectionSkills[tsr.traps.playerSkills.detection];
    const disarmSkill = tsr.traps.disarmSkills[tsr.traps.playerSkills.disarm];
    
    // 侦查技能显示
    const detectElement = document.createElement('div');
    detectElement.style.cssText = `
        background: rgba(0, 191, 255, 0.2);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #00bfff;
    `;
    
    detectElement.innerHTML = `
        <div style="font-weight: bold; color: #00bfff; margin-bottom: 5px;">
            ${detectionSkill.name}
        </div>
        <div style="font-size: 12px; color: #00bfff;">
            成功率: ${(detectionSkill.successRate * 100).toFixed(0)}%
        </div>
        <div style="font-size: 11px; color: #d8bfd8;">
            消耗: ${detectionSkill.cost}秒
        </div>
    `;
    
    // 解除技能显示
    const disarmElement = document.createElement('div');
    disarmElement.style.cssText = `
        background: rgba(50, 205, 50, 0.2);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #32cd32;
    `;
    
    disarmElement.innerHTML = `
        <div style="font-weight: bold; color: #32cd32; margin-bottom: 5px;">
            ${disarmSkill.name}
        </div>
        <div style="font-size: 12px; color: #32cd32;">
            成功率: ${(disarmSkill.successRate * 100).toFixed(0)}%
        </div>
        <div style="font-size: 11px; color: #d8bfd8;">
            消耗: ${disarmSkill.cost}秒
        </div>
    `;
    
    container.appendChild(detectElement);
    container.appendChild(disarmElement);
    
    // 如果有侦查加成，显示额外信息
    if (tsr.currentRun.detectionBoost) {
        const boostElement = document.createElement('div');
        boostElement.style.cssText = `
            background: rgba(255, 215, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ffd700;
        `;
        
        boostElement.innerHTML = `
            <div style="font-weight: bold; color: #ffd700; margin-bottom: 5px;">
                陷阱感知药水
            </div>
            <div style="font-size: 12px; color: #ffd700;">
                侦查成功率 +30%
            </div>
            <div style="font-size: 11px; color: #d8bfd8;">
                本次冒险有效
            </div>
        `;
        
        container.appendChild(boostElement);
    }
}
// 在每次行动后更新增益持续时间
function updateBuffDurations() {
    const tsr = player.timeSecretRealm;
    
    // 更新增益持续时间
    tsr.currentRun.tempBuffs = tsr.currentRun.tempBuffs.filter(buff => {
        if (buff.duration) {
            buff.duration--;
            return buff.duration > 0;
        }
        return true; // 没有持续时间的增益永久有效
    });
    
    // 更新显示
    updateBuffsDisplay();
}
// 在探索房间、战斗等行动后调用
function afterAction() {
    updateBuffDurations();
    updateTimeSecretRealmUI();
}
// 侦查陷阱
function tsrDetectTrap() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    
    if (!room.hasTrap || room.trapDetected) return;
    
    const skill = tsr.traps.detectionSkills[tsr.traps.playerSkills.detection];
    const success = Math.random() < skill.successRate;
    
    // 消耗时间
    tsr.currentRun.timeLeft -= skill.cost;
    
    if (success) {
        room.trapDetected = true;
        addTsrLog(`侦查成功！发现了${room.trap.name}`, 'success');
    } else {
        addTsrLog(`侦查失败！没有发现陷阱`, 'warning');
    }
    
    updateCurrentRoomDisplay();
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
    }
}

// 解除陷阱
function tsrDisarmTrap() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    
    if (!room.hasTrap || !room.trapDetected || room.trapDisarmed) return;
    
    const skill = tsr.traps.disarmSkills[tsr.traps.playerSkills.disarm];
    const success = Math.random() < skill.successRate;
    
    // 消耗时间
    tsr.currentRun.timeLeft -= skill.cost;
    
    if (success) {
        room.trapDisarmed = true;
        addTsrLog(`解除成功！安全解除了${room.trap.name}`, 'success');
        
        // 解除陷阱奖励
        const reward = 200 + Math.floor(Math.random() * 30);
        tsr.currentRun.currencyEarned += reward;
        addTsrLog(`获得${reward}秘境币作为解除陷阱的奖励`);
    } else {
        // 解除失败，触发陷阱
        addTsrLog(`解除失败！触发了${room.trap.name}`, 'error');
        triggerTrap(room.trap);
    }
    
    updateCurrentRoomDisplay();
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
    }
}

// 触发陷阱效果
function triggerTrap(trap) {
    const tsr = player.timeSecretRealm;
    
    switch(trap.damageType) {
        case 'percentage':
            const percentageDamage = Math.floor(tsr.currentRun.playerHealth * trap.damage);
            applyDamage(percentageDamage);
            addTsrLog(`受到${percentageDamage}点伤害（${trap.damage * 100}%生命值）`, 'error');
            break;
            
        case 'fixed':
            applyDamage(trap.damage);
            addTsrLog(`受到${formatSci(trap.damage)}点固定伤害`, 'error');
            break;
            
        case 'debuff':
            // 添加减益效果
            const debuff = {
                name: trap.name + '减益',
                effect: trap.effect,
                value: trap.value,
                duration: trap.duration,
                isDebuff: true
            };
            addTempBuff(debuff);
            addTsrLog(`${trap.effect === 'attack' ? '攻击力' : '暴击率'}降低${trap.value * 100}%，持续${trap.duration}回合`, 'warning');
            break;
            
        case 'time':
            tsr.currentRun.timeLeft -= trap.damage;
            addTsrLog(`时间减少${trap.damage}秒`, 'warning');
            break;
            
        case 'random':
            const randomDamage = Math.floor(tsr.currentRun.playerHealth * (Math.random() * trap.damage));
            applyDamage(randomDamage);
            addTsrLog(`受到${randomDamage}点随机伤害`, 'error');
            break;
    }
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
    }
}
// 更新血条显示
function updateHealthBar() {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun || !tsr.currentRun.isActive) return;
    
    const maxHealth = calculateTsrPlayerHealth();
    const currentHealth = tsr.currentRun.playerHealth;
    const healthPercentage = (currentHealth / maxHealth) * 100;
    
    // 更新血条
    const healthBar = document.getElementById('tsrHealthBarFill');
    const healthText = document.getElementById('tsrHealthText');
    const healthWarning = document.getElementById('tsrHealthWarning');
    
    if (healthBar && healthText) {
        healthBar.style.width = `${healthPercentage}%`;
        healthText.textContent = `${healthPercentage.toFixed(1)}% (${formatSci(currentHealth)}/${formatSci(maxHealth)})`;
        
        // 警告显示
        if (healthPercentage <= 30) {
            healthWarning.style.display = 'inline';
            healthBar.style.background = 'linear-gradient(to right, #ff4500, #8b0000)';
        } else if (healthPercentage <= 50) {
            healthWarning.style.display = 'none';
            healthBar.style.background = 'linear-gradient(to right, #ffa500, #ff4500)';
        } else {
            healthWarning.style.display = 'none';
            healthBar.style.background = 'linear-gradient(to right, #32cd32, #ffa500)';
        }
    }
}

// 检查生命值是否低于失败阈值（30%）
function checkHealthFailure() {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun || !tsr.currentRun.isActive) return false;
    
    const maxHealth = calculateTsrPlayerHealth();
    const currentHealth = tsr.currentRun.playerHealth;
    const healthPercentage = (currentHealth / maxHealth) * 100;
    
    // 生命值低于30%时失败
    if (healthPercentage < 30) {
        endTimeSecretRealm('生命值过低');
        return true;
    }
    
    return false;
}
function applyDamage(damage) {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun) return;
    
    tsr.currentRun.playerHealth -= damage;
    
    // 更新血条
    updateHealthBar();
    
    // 检查是否失败
    if (checkHealthFailure()) {
        return;
    }
    
    // 检查是否死亡
    if (tsr.currentRun.playerHealth <= 0) {
        endTimeSecretRealm('战斗失败');
        return;
    }
}
// 探索房间
function tsrExploreRoom() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    const difficultyMultiplier = tsr.currentRun.difficultyMultiplier;
    
    if (!room || room.explored) return;
    
    // 检查生命值是否过低
    if (checkHealthFailure()) {
        return;
    }
    
    room.explored = true;
    tsr.currentRun.exploredRooms++;
    tsr.currentRun.lastAction = 'explore';
    tsr.currentRun.consecutiveFloors = 0; // 重置连续层数
    
    // 消耗时间（难度越高消耗越多）
    const timeCost = Math.floor(10 * difficultyMultiplier);
    tsr.currentRun.timeLeft -= timeCost;
    
    // 如果有未解除的陷阱，触发它
    if (room.hasTrap && !room.trapDisarmed) {
        addTsrLog(`触发了${room.trap.name}！`, 'error');
        triggerTrap(room.trap);
        
        if (tsr.currentRun.playerHealth <= 0 || tsr.currentRun.timeLeft <= 0) {
            return;
        }
    }
    
    // 处理房间事件
    switch(room.type) {
        case 'battle':
            handleBattleRoom();
            break;
        case 'event':
            handleEventRoom();
            break;
        case 'treasure':
            handleTreasureRoom();
            break;
        case 'rest':
            handleRestRoom();
            break;
        case 'shop':
            handleShopRoom();
            break;
    }
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
        return;
    }
    
    updateTimeSecretRealmUI();
}



// 处理战斗房间
function handleBattleRoom() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    const difficultyMultiplier = tsr.currentRun.difficultyMultiplier;
    
    // 模拟战斗，难度越高成功率越低
    const baseSuccessRate = 0.7;
    const successRate = baseSuccessRate / difficultyMultiplier;
    const battleSuccess = Math.random() < successRate;
    
    if (battleSuccess) {
        // 战斗胜利，获得奖励（应用难度奖励倍数）
        const reward = Math.floor(room.rewards.currency * tsr.currentRun.rewardMultiplier);
        tsr.currentRun.currencyEarned += reward;
        
        addTsrLog(`战斗胜利！获得${reward}秘境币`, 'success');
        
        // 有几率获得临时强化（难度越高几率越低但效果更强）
        if (Math.random() < (0.2 / difficultyMultiplier)) {
            const buff = getRandomTempBuff();
            // 难度越高强化效果越强
            if (buff.value) {
                buff.value *= difficultyMultiplier;
            }
            // 确保增益包含时间奖励
            if (!buff.timeBonus) {
                buff.timeBonus = getTimeBonusByEffect(buff.effect);
            }
            addTempBuff(buff);
        }
    } else {
        // 战斗失败，受到伤害（难度越高伤害越大）
        const damage = Math.floor(tsr.currentRun.playerHealth * (0.2 * difficultyMultiplier));
        applyDamage(damage);
        addTsrLog(`战斗失败！受到${damage}点伤害`, 'error');
        
        if (tsr.currentRun.playerHealth <= 0) return;
    }
    
    afterAction();
}
// 修复增益效果应用验证函数
function validateBuffEffects() {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun || !tsr.currentRun.tempBuffs) return;
    
    console.log('当前增益效果:');
    tsr.currentRun.tempBuffs.forEach((buff, index) => {
        console.log(`${index + 1}. ${buff.name}: ${buff.effect} = ${buff.value}`);
    });
    
    console.log('计算后的属性:');
    console.log('攻击力:', calculateTsrPlayerAttack());
    console.log('爆伤:', calculateTsrPlayerCritDamage());
    console.log('暴击率:', calculateTsrPlayerCritRate());
    console.log('生命值:', calculateTsrPlayerHealth());
}

// 处理事件房间
function handleEventRoom() {
    const tsr = player.timeSecretRealm;
    
    // 随机事件
    const events = [
        { 
            name: '神秘祝福', 
            effect: () => {
                const buff = getRandomTempBuff();
                // 确保增益包含时间奖励
                if (!buff.timeBonus) {
                    buff.timeBonus = getTimeBonusByEffect(buff.effect);
                }
                addTempBuff(buff);
                return `获得了临时强化: ${buff.name}`;
            }
        },
        { 
            name: '时间扭曲', 
            effect: () => {
                const timeChange = Math.random() > 0.5 ? 30 : -20;
                tsr.currentRun.timeLeft += timeChange;
                return `时间${timeChange > 0 ? '增加' : '减少'}了${Math.abs(timeChange)}秒`;
            }
        },
        { 
            name: '财富降临', 
            effect: () => {
                const currency = 100 + Math.floor(Math.random() * 100);
                tsr.currentRun.currencyEarned += currency;
                return `获得了${currency}秘境币`;
            }
        }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    const result = event.effect();
    afterAction();
    addTsrLog(`事件: ${event.name} - ${result}`);
}

// 辅助函数：根据增益效果获取时间奖励
function getTimeBonusByEffect(effect) {
    switch(effect) {
        case 'attack': return 30;
        case 'health': return 60;
        case 'critRate': return 90;
        case 'critDamage': return 120;
        case 'speed': return 150;
        default: return 0;
    }
}
function handleTreasureRoom() {
    const tsr = player.timeSecretRealm;
    const room = tsr.currentRun.currentRoom;
    
    tsr.currentRun.currencyEarned += room.rewards.currency;
    addTsrLog(`打开了宝箱！获得${room.rewards.currency}秘境币`);
    
    // 有几率获得稀有奖励
    if (Math.random() < 0.1) {
        const rareCurrency = room.rewards.currency * 3;
        tsr.currentRun.currencyEarned += rareCurrency;
        addTsrLog(`发现隐藏宝藏！额外获得${rareCurrency}秘境币`);
    }
}

// 处理休息房间
function handleRestRoom() {
    const tsr = player.timeSecretRealm;
    
    // 恢复生命值
    const maxHealth = calculateTsrPlayerHealth();
    const healAmount = Math.floor(maxHealth * 0.3);
    tsr.currentRun.playerHealth = Math.min(maxHealth, tsr.currentRun.playerHealth + healAmount);
    
    addTsrLog(`休息恢复！恢复了${healAmount}点生命值`, 'success');
    updateHealthBar();
}


// 处理商店房间
function handleShopRoom() {
    const tsr = player.timeSecretRealm;
    
    // 随机提供2-3个临时强化购买选项
    const availableBuffs = Object.values(tsr.tempBuffs);
    const numOffers = 2 + Math.floor(Math.random() * 2); // 2-3个选项
    const offers = [];
    
    for (let i = 0; i < numOffers; i++) {
        const randomIndex = Math.floor(Math.random() * availableBuffs.length);
        const buff = availableBuffs[randomIndex];
        const cost = 100 + Math.floor(Math.random() * 50); // 50-100秘境币
        
        offers.push({
            buff: buff,
            cost: cost
        });
    }
    
    // 显示购买选项
    addTsrLog(`神秘商店提供以下强化:`);
    offers.forEach((offer, index) => {
        addTsrLog(`${index + 1}. ${offer.buff.name} - ${offer.cost}秘境币`);
    });
    
    // 存储当前商店信息
    tsr.currentRun.currentShop = offers;
    
    // 显示购买按钮
    showShopOptions(offers);
}

// 显示商店购买选项
function showShopOptions(offers) {
    const container = document.getElementById('tsrCurrentRoom');
    let optionsHTML = '<div style="margin-top: 10px;">';
    
    offers.forEach((offer, index) => {
        optionsHTML += `
            <button onclick="buyTsrBuff(${index})" style="background: #9370db; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin: 2px; font-size: 12px;">
                ${offer.buff.name} (${offer.cost}币)
            </button>
        `;
    });
    
    optionsHTML += '</div>';
    container.innerHTML += optionsHTML;
}

// 购买临时强化
function buyTsrBuff(index) {
    const tsr = player.timeSecretRealm;
    const offer = tsr.currentRun.currentShop[index];
    
    if (!offer) return;
    
    if (tsr.currentRun.currencyEarned >= offer.cost) {
        tsr.currentRun.currencyEarned -= offer.cost;
        
        // 确保增益包含时间奖励
        if (!offer.buff.timeBonus) {
            offer.buff.timeBonus = getTimeBonusByEffect(offer.buff.effect);
        }
        
        addTempBuff(offer.buff);
        
        addTsrLog(`购买了${offer.buff.name}，消耗${offer.cost}秘境币`);
        updateTimeSecretRealmUI();
    } else {
        addTsrLog(`秘境币不足！需要${offer.cost}秘境币，只有${tsr.currentRun.currencyEarned}秘境币`);
    }
}

// 休息恢复
function tsrRest() {
    const tsr = player.timeSecretRealm;
    
    // 消耗时间
    tsr.currentRun.timeLeft -= 15;
    
    // 恢复生命值
    const maxHealth = calculateTsrPlayerHealth();
    const healAmount = Math.floor(maxHealth * 0.5);
    tsr.currentRun.playerHealth = Math.min(maxHealth, tsr.currentRun.playerHealth + healAmount);
    
    addTsrLog(`休息恢复！恢复了${healAmount}点生命值，消耗15秒时间`);
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
        return;
    }
    
    updateTimeSecretRealmUI();
}

// 前往下一层
function tsrNextFloor() {
    const tsr = player.timeSecretRealm;
    const difficulty = tsr.difficulty.levels[tsr.currentRun.difficulty];
    const clearFloor = difficulty.clearFloor;
    const difficultyMultiplier = tsr.currentRun.difficultyMultiplier;
    
    // 检查是否连续前往下一层（惩罚机制）
    if (tsr.currentRun.lastAction === 'nextFloor') {
        tsr.currentRun.consecutiveFloors++;
        
        // 连续层数越多，惩罚越大
        const penalty = Math.min(5, tsr.currentRun.consecutiveFloors);
        const timePenalty = 30 + (penalty * 15); // 额外时间惩罚
        const healthPenalty = Math.floor(tsr.currentRun.playerHealth * (penalty * 0.05)); // 生命值惩罚
        
        tsr.currentRun.timeLeft -= timePenalty;
        tsr.currentRun.playerHealth -= healthPenalty;
        
        addTsrLog(`连续探索惩罚！时间减少${timePenalty}秒，生命值减少${healthPenalty}点`, 'warning');
        
        // 检查是否失败
        if (checkHealthFailure() || tsr.currentRun.timeLeft <= 0) {
            return;
        }
    } else {
        tsr.currentRun.consecutiveFloors = 0;
    }
    
    tsr.currentRun.lastAction = 'nextFloor';
    
    // 消耗时间（难度越高消耗越多）
    const timeCost = Math.floor(30 * difficultyMultiplier);
    tsr.currentRun.timeLeft -= timeCost;
    
    // 增加层数
    tsr.currentRun.currentFloor++;
    tsr.currentRun.exploredRooms = 0;
    
    // 更新最佳层数
    if (tsr.currentRun.currentFloor > tsr.bestFloor) {
        tsr.bestFloor = tsr.currentRun.currentFloor;
    }
    
    // 生成新房间（难度越高房间越难）
    generateNewRoom();
    
    // 检查是否达到通关要求
    if (tsr.currentRun.currentFloor >= clearFloor) {
        addTsrLog(`🎉 恭喜！已达到${clearFloor}层通关要求！`, 'success');
        addTsrLog(`继续前进可获得更多奖励，或随时退出获得通关奖励`);
    } else if (tsr.currentRun.currentFloor >= clearFloor * 0.8) {
        addTsrLog(`📈 当前层数: ${tsr.currentRun.currentFloor}/${clearFloor}，接近通关！`, 'info');
    } else if (tsr.currentRun.currentFloor >= clearFloor * 0.5) {
        addTsrLog(`📈 当前层数: ${tsr.currentRun.currentFloor}/${clearFloor}，已完成一半进度`, 'info');
    }
    
    addTsrLog(`进入了第${tsr.currentRun.currentFloor}层！消耗${timeCost}秒时间`);
    
    // 检查时间是否用完
    if (tsr.currentRun.timeLeft <= 0) {
        endTimeSecretRealm('时间耗尽');
        return;
    }
    
    updateTimeSecretRealmUI();
}

// 退出秘境
function tsrExitRealm() {
    endTimeSecretRealm('主动退出');
}

// 结束时光秘境冒险
function endTimeSecretRealm(reason) {
    const tsr = player.timeSecretRealm;
    const difficulty = tsr.difficulty.levels[tsr.currentRun.difficulty];
    const clearFloor = difficulty.clearFloor;
    
    // 检查是否通关（达到该难度的通关层数要求）
    const isCleared = tsr.currentRun.currentFloor >= clearFloor;
    
    if (isCleared && reason !== '战斗失败' && reason !== '时间耗尽' && reason !== '生命值过低') {
        tsr.clearCount++;
        const diffKey = tsr.currentRun.difficulty;
        if (tsr.clearCountByDifficulty[diffKey] !== undefined) {
            tsr.clearCountByDifficulty[diffKey]++;
        }
        addTsrLog(`恭喜！成功通关${difficulty.name}难度（达到${clearFloor}层）`, 'success');
        
        // 检查难度解锁（按各难度通关次数，与界面描述一致）
        checkDifficultyUnlocks();
        
        // 通关额外奖励
        const clearBonus = Math.floor(tsr.currentRun.currencyEarned * 0.5); // 50%额外奖励
        tsr.currentRun.currencyEarned += clearBonus;
        addTsrLog(`通关奖励！额外获得${clearBonus}秘境币`, 'success');
    }
    
    // 计算最终奖励
    let finalReward = tsr.currentRun.currencyEarned * tsr.currentRun.rewardMultiplier;
    finalReward *= tsr.currentRun.currentFloor;
    tsr.currency += finalReward;
    
    // 更新最佳层数
    if (tsr.currentRun.currentFloor > tsr.bestFloor) {
        tsr.bestFloor = tsr.currentRun.currentFloor;
    }
    
    // 记录结束日志
    addTsrLog(`=== ${difficulty.name}难度冒险结束 ===`);
    addTsrLog(`结束原因: ${reason}`);
    addTsrLog(`最终层数: ${tsr.currentRun.currentFloor}/${clearFloor}`);
    addTsrLog(`通关要求: ${clearFloor}层`);
    addTsrLog(isCleared ? '状态: 通关成功 ✓' : '状态: 未通关 ✗');
    addTsrLog(`获得秘境币: ${finalReward}`);
    addTsrLog(`总秘境币: ${tsr.currency}`);
    
    // 重置当前冒险
    tsr.currentRun.isActive = false;
    
    // 显示难度选择界面
    document.getElementById('tsrDifficultySelection').style.display = 'block';
    document.getElementById('startTsrBtn').style.display = 'inline-block';
    document.getElementById('openTsrShopBtn').style.display = 'inline-block';
    
    // 隐藏冒险界面元素
    document.getElementById('tsrStatusDisplay').style.display = 'none';
    document.getElementById('tsrRoomDisplay').style.display = 'none';
    document.getElementById('tsrActionControls').style.display = 'none';
    document.getElementById('tsrBuffsDisplay').style.display = 'none';
    document.getElementById('tsrSkillsDisplay').style.display = 'none';
    document.getElementById('tsrHealthBar').style.display = 'none';
    
    // 更新界面
    updateTimeSecretRealmUI();
    saveGame();
}
function initTimeSecretRealm() {
    const tsr = player.timeSecretRealm;
     // 初始化永久加成数据
    if (!tsr.permanentBonuses) {
        tsr.permanentBonuses = {
            baseTime: 0,
            startingBuffs: 0
        };
    }
    
    // 初始化各难度通关次数（旧存档兼容：无此字段时用总通关次数当作简单难度次数，避免进度丢失）
    if (!tsr.clearCountByDifficulty) {
        tsr.clearCountByDifficulty = { easy: 0, normal: 0, hard: 0, nightmare: 0, hell: 0 };
        if (tsr.clearCount > 0) {
            tsr.clearCountByDifficulty.easy = Math.min(tsr.clearCount, 999);
        }
    }
    
    // 初始化商店物品购买记录
    Object.values(tsr.shopItems).forEach(item => {
        if (!item.purchased) {
            item.purchased = 0;
        }
    });
    if (!tsr.difficulty) {
        tsr.difficulty = {
            levels: {
                easy: { 
            name: '简单', 
            multiplier: 0.8, 
            rewardMultiplier: 0.7, 
            description: '适合新手玩家', 
            unlockCondition: '无',
            clearFloor: 10  // 通关层数要求
        },
        normal: { 
            name: '普通', 
            multiplier: 1.0, 
            rewardMultiplier: 1.0, 
            description: '标准难度', 
            unlockCondition: '通关简单难度3次',
            clearFloor: 15
        },
        hard: { 
            name: '困难', 
            multiplier: 1.5, 
            rewardMultiplier: 1.5, 
            description: '更具挑战性', 
            unlockCondition: '通关普通难度5次',
            clearFloor: 20
        },
        nightmare: { 
            name: '噩梦', 
            multiplier: 2.0, 
            rewardMultiplier: 2.5, 
            description: '极限挑战', 
            unlockCondition: '通关困难难度10次',
            clearFloor: 25
        },
        hell: { 
            name: '地狱', 
            multiplier: 3.0, 
            rewardMultiplier: 4.0, 
            description: '终极考验', 
            unlockCondition: '通关噩梦难度20次',
            clearFloor: 30
        }
            },
            current: 'easy', // 默认选择简单难度
            unlocked: ['easy']
        };
    }
    
    // 检查解锁条件
    checkDifficultyUnlocks();
    updateDifficultyUI();
}

// 开始秘境计时器
function startTsrTimer() {
    const tsr = player.timeSecretRealm;
    
    // 清除现有计时器
    if (tsr.timer) {
        clearInterval(tsr.timer);
    }
    
    // 每秒更新一次时间
    tsr.timer = registerInterval(() => {
        if (tsr.currentRun.isActive) {
            tsr.currentRun.timeLeft--;
            
            // 更新界面显示
            document.getElementById('tsrTimeLeft').textContent = tsr.currentRun.timeLeft + '秒';
            
            // 检查时间是否用完
            if (tsr.currentRun.timeLeft <= 0) {
                endTimeSecretRealm('时间耗尽');
            }
        }
    }, 1000);
}


// 在玩家属性计算中应用增益效果
function calculateTsrPlayerHealth() {
    const baseHealth = player.battle.playerHealth || 1e4;
    
    // 应用临时强化
    let multiplier = 1;
    const tsr = player.timeSecretRealm;
    if (tsr.currentRun && tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs.forEach(buff => {
            if (buff.effect === 'health') {
                multiplier += buff.value;
            }
        });
    }
    
    return Math.floor(baseHealth * multiplier);
}

function calculateTsrPlayerAttack() {
    const baseAttack = player.battle.playerAttack || 1e4;
    
    // 应用临时强化
    let multiplier = 1;
    const tsr = player.timeSecretRealm;
    if (tsr.currentRun && tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs.forEach(buff => {
            if (buff.effect === 'attack') {
                multiplier += buff.value;
            }
        });
    }
    
    return Math.floor(baseAttack * multiplier);
}

function calculateTsrPlayerCritRate() {
    const baseCritRate = player.battle.playerCritRate || 0.1;
    
    // 应用临时强化
    let bonus = 0;
    const tsr = player.timeSecretRealm;
    if (tsr.currentRun && tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs.forEach(buff => {
            if (buff.effect === 'critRate') {
                bonus += buff.value;
            }
        });
    }
    
    return Math.min(0.9, baseCritRate + bonus);
}

function calculateTsrPlayerCritDamage() {
    const baseCritDamage = player.battle.playerCritDamage || 1.5;
    
    // 应用临时强化
    let multiplier = 1;
    const tsr = player.timeSecretRealm;
    if (tsr.currentRun && tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs.forEach(buff => {
            if (buff.effect === 'critDamage') {
                multiplier += buff.value;
            }
        });
    }
    
    return baseCritDamage * multiplier;
}

function updatePlayerStatsDisplay() {
    const tsr = player.timeSecretRealm;
    
    // 计算正确的属性值
    const playerHealth = calculateTsrPlayerHealth();
    const playerAttack = calculateTsrPlayerAttack();
    const playerCritRate = calculateTsrPlayerCritRate();
    const playerCritDamage = calculateTsrPlayerCritDamage();
    
    // 更新界面显示
    document.getElementById('penglaiPlayerHealth').textContent = formatSci(playerHealth);
    document.getElementById('penglaiPlayerAttack').textContent = formatSci(playerAttack);
    document.getElementById('penglaiPlayerCritRate').textContent = (playerCritRate * 100).toFixed(2) + '%';
    document.getElementById('penglaiPlayerCritDamage').textContent = (playerCritDamage * 100).toFixed(1) + '%';
    
    // 更新当前运行数据（用于战斗计算）
    if (tsr.currentRun) {
        tsr.currentRun.playerHealth = playerHealth;
        tsr.currentRun.playerAttack = playerAttack;
    }
}
function calculateBattleDamage() {
    const tsr = player.timeSecretRealm;
    const baseAttack = tsr.currentRun.playerAttack;
    const critRate = calculateTsrPlayerCritRate();
    const critDamage = calculateTsrPlayerCritDamage();
    
    // 计算是否暴击
    const isCrit = Math.random() < critRate;
    let damage = baseAttack;
    
    if (isCrit) {
        damage *= critDamage;
        addTsrLog('暴击！', 'success');
    }
    
    return {
        damage: damage,
        isCrit: isCrit
    };
}
// 修复增益效果应用函数
function applyBuffEffects() {
    const tsr = player.timeSecretRealm;
    
    // 重置基础属性
    tsr.currentRun.playerHealth = calculateTsrPlayerHealth();
    tsr.currentRun.playerAttack = calculateTsrPlayerAttack();
    
    // 应用特殊效果（如幸运加成）
    tsr.currentRun.hasLuckBuff = tsr.currentRun.tempBuffs.some(buff => buff.effect === 'luck');
    tsr.currentRun.hasSpeedBuff = tsr.currentRun.tempBuffs.some(buff => buff.effect === 'speed');
}

// 修复增益显示函数，确保数值正确
function updateBuffsDisplay() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrCurrentBuffs');
    container.innerHTML = '';
    
    if (!tsr.currentRun.tempBuffs || tsr.currentRun.tempBuffs.length === 0) {
        container.innerHTML = '<div style="color: #888; text-align: center; grid-column: 1 / -1;">无增益效果</div>';
        return;
    }
    
    tsr.currentRun.tempBuffs.forEach((buff, index) => {
        const buffElement = document.createElement('div');
        buffElement.style.cssText = `
            background: ${buff.isDebuff ? 'rgba(255, 0, 0, 0.2)' : 'rgba(0, 255, 0, 0.2)'};
            padding: 10px;
            border-radius: 5px;
            border: 1px solid ${buff.isDebuff ? '#ff6b6b' : '#32cd32'};
            position: relative;
        `;
        
        let effectText = '';
        let valueText = '';
        let timeBonusText = '';
        
        // 根据增益类型生成描述
        switch(buff.effect) {
            case 'attack':
                effectText = '攻击力';
                valueText = `${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'health':
                effectText = '生命值';
                valueText = `${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'critRate':
                effectText = '暴击率';
                valueText = `${(buff.value * 100).toFixed(1)}%`;
                break;
            case 'critDamage':
                effectText = '爆伤';
                valueText = `${(buff.value * 100).toFixed(0)}%`;
                break;
            case 'speed':
                effectText = '探索速度';
                valueText = `+${buff.value}秒`;
                break;
            case 'luck':
                effectText = '幸运';
                valueText = '双倍秘境币';
                break;
            default:
                effectText = '未知效果';
                valueText = '';
        }
        
        // 添加时间奖励显示
        if (buff.timeBonus && buff.timeBonus > 0) {
            timeBonusText = `<div style="font-size: 11px; color: #00bfff; margin-top: 3px;">⏱️ +${buff.timeBonus}秒</div>`;
        }
        
        buffElement.innerHTML = `
            <div style="font-weight: bold; color: ${buff.isDebuff ? '#ff6b6b' : '#32cd32'}; margin-bottom: 5px;">
                ${buff.name}
            </div>
            <div style="font-size: 12px; color: ${buff.isDebuff ? '#ff6b6b' : '#32cd32'}; margin-bottom: 3px;">
                ${effectText}: +${valueText}
            </div>
            ${timeBonusText}
            ${buff.duration ? `
                <div style="font-size: 11px; color: #d8bfd8; margin-top: 5px;">
                    剩余: ${buff.duration}回合
                </div>
            ` : ''}
            ${buff.isDebuff ? `
                <div style="position: absolute; top: 5px; right: 5px; color: #ff6b6b;">⚠️</div>
            ` : `
                <div style="position: absolute; top: 5px; right: 5px; color: #32cd32;">✨</div>
            `}
        `;
        
        container.appendChild(buffElement);
    });
}
// 在战斗日志中显示增益效果变化
function addBuffChangeLog(buff, isGained) {
    let effectDescription = '';
    let timeBonusText = '';
    
    // 生成效果描述
    switch(buff.effect) {
        case 'attack':
            effectDescription = `攻击力提升${(buff.value * 100).toFixed(0)}%`;
            break;
        case 'health':
            effectDescription = `生命值提升${(buff.value * 100).toFixed(0)}%`;
            break;
        case 'critRate':
            effectDescription = `暴击率提升${(buff.value * 100).toFixed(1)}%`;
            break;
        case 'critDamage':
            effectDescription = `爆伤提升${(buff.value * 100).toFixed(0)}%`;
            break;
        case 'speed':
            effectDescription = `探索速度提升`;
            break;
        case 'luck':
            effectDescription = '获得双倍秘境币';
            break;
        default:
            effectDescription = buff.name;
    }
    
    // 添加时间奖励描述
    if (buff.timeBonus && buff.timeBonus > 0) {
        timeBonusText = `，探索时间+${buff.timeBonus}秒`;
    }
    
    if (isGained) {
        addTsrLog(`获得增益: ${buff.name} (${effectDescription}${timeBonusText})`, 'success');
    } else {
        addTsrLog(`增益消失: ${buff.name}`, 'warning');
    }
}
// 修改增益添加逻辑，添加日志
function addTempBuff(buff) {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun.tempBuffs) {
        tsr.currentRun.tempBuffs = [];
    }
    
    // 检查是否已存在相同类型的增益
    const existingBuffIndex = tsr.currentRun.tempBuffs.findIndex(b => b.effect === buff.effect);
    
    if (existingBuffIndex !== -1) {
        // 如果已存在，替换为新的增益
        tsr.currentRun.tempBuffs[existingBuffIndex] = buff;
    } else {
        // 如果不存在，添加新增益
        tsr.currentRun.tempBuffs.push(buff);
    }
    
    // 应用时间奖励
    if (buff.timeBonus && buff.timeBonus > 0) {
        tsr.currentRun.timeLeft += buff.timeBonus;
        addTsrLog(`获得${buff.timeBonus}秒探索时间奖励！`, 'success');
    }
    
    addBuffChangeLog(buff, true);
    updateBuffsDisplay();
    
    // 重新计算玩家属性
    tsr.currentRun.playerHealth = calculateTsrPlayerHealth();
    tsr.currentRun.playerAttack = calculateTsrPlayerAttack();
    updateHealthBar();
    
    // 更新界面显示
    updateTimeSecretRealmUI();
}
// 修改增益移除逻辑，添加日志
function removeExpiredBuffs() {
    const tsr = player.timeSecretRealm;
    if (!tsr.currentRun.tempBuffs) return;
    
    const expiredBuffs = [];
    
    tsr.currentRun.tempBuffs = tsr.currentRun.tempBuffs.filter(buff => {
        if (buff.duration && buff.duration > 0) {
            buff.duration--;
            if (buff.duration <= 0) {
                expiredBuffs.push(buff);
                return false;
            }
        }
        return true;
    });
    
    expiredBuffs.forEach(buff => {
        addBuffChangeLog(buff, false);
    });
    
    // 重新计算玩家属性
    if (expiredBuffs.length > 0) {
        tsr.currentRun.playerHealth = calculateTsrPlayerHealth();
        tsr.currentRun.playerAttack = calculateTsrPlayerAttack();
        updateBuffsDisplay();
        updateHealthBar();
    }
}
// 生成房间奖励
function generateRoomRewards(roomType, difficultyMultiplier) {
    const baseRewards = {
        battle: { currency: 20, buffChance: 0.2 },
        event: { currency: 10, buffChance: 0.5 },
        treasure: { currency: 50, buffChance: 0.1 },
        rest: { currency: 0, buffChance: 0 },
        shop: { currency: 0, buffChance: 0 }
    };
    
    const reward = { ...baseRewards[roomType] };
    
    // 应用难度奖励倍数
    reward.currency = Math.floor(reward.currency * difficultyMultiplier);
    reward.buffChance *= difficultyMultiplier;
    
    return reward;
}


// 获取随机临时强化
function getRandomTempBuff() {
    const tsr = player.timeSecretRealm;
    const buffs = Object.values(tsr.tempBuffs);
    const randomBuff = buffs[Math.floor(Math.random() * buffs.length)];
    
    // 返回完整的buff对象，包含时间奖励
    return {
        name: randomBuff.name,
        effect: randomBuff.effect,
        value: randomBuff.value,
        timeBonus: randomBuff.timeBonus || getTimeBonusByEffect(randomBuff.effect),
        duration: randomBuff.duration || 0,
        isDebuff: false
    };
}

// 添加秘境日志
function addTsrLog(message) {
    const logContainer = document.getElementById('tsrBattleLog');
    const logEntry = document.createElement('div');
    logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    logEntry.style.margin = '2px 0';
    logEntry.style.padding = '2px 5px';
    
    // 根据消息类型添加颜色
    if (message.includes('获得') || message.includes('恢复') || message.includes('幸运')) {
        logEntry.style.color = '#00ff00';
    } else if (message.includes('消耗') || message.includes('时间')) {
        logEntry.style.color = '#ffa500';
    } else if (message.includes('失败') || message.includes('伤害') || message.includes('死亡')) {
        logEntry.style.color = '#ff6b6b';
    } else if (message.includes('进入') || message.includes('开始') || message.includes('层')) {
        logEntry.style.color = '#00bfff';
    } else if (message.includes('购买') || message.includes('商店')) {
        logEntry.style.color = '#9370db';
    }
    
    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

// 打开秘境商店
function openTsrShop() {
    const overlay = document.getElementById('tsrShopOverlay');
    const ui = document.getElementById('tsrShopUI');
    
    overlay.style.display = 'block';
    ui.style.display = 'block';
    
    updateTsrShop();
}

// 关闭秘境商店
function closeTsrShop() {
    document.getElementById('tsrShopOverlay').style.display = 'none';
    document.getElementById('tsrShopUI').style.display = 'none';
}

// 更新秘境商店
function updateTsrShop() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrShopItems');
    
    // 更新货币显示
    document.getElementById('tsrShopCurrency').textContent = tsr.currency.toFixed(0);
    
    // 清空容器
    container.innerHTML = '';
    
    // 添加商店物品
    Object.entries(tsr.shopItems).forEach(([key, item]) => {
        const itemElement = document.createElement('div');
        
        // 检查是否已达到购买上限
        const isMaxPurchased = item.maxPurchase && item.purchased >= item.maxPurchase;
        const purchaseInfo = item.maxPurchase ? 
            `（${item.purchased || 0}/${item.maxPurchase}）` : '';
        
        itemElement.style.cssText = `
            background: ${isMaxPurchased ? 'rgba(128,128,128,0.3)' : 'rgba(0,0,0,0.3)'};
            padding: 15px;
            border-radius: 5px;
            border: 1px solid ${isMaxPurchased ? '#666' : '#ffd700'};
            text-align: left;
            opacity: ${isMaxPurchased ? 0.6 : 1};
        `;
        
        itemElement.innerHTML = `
            <div style="font-weight: bold; color: ${isMaxPurchased ? '#666' : '#ffd700'}; margin-bottom: 5px;">
                ${item.name}${purchaseInfo}
            </div>
            <div style="font-size: 14px; color: ${isMaxPurchased ? '#888' : '#d8bfd8'}; margin-bottom: 10px;">
                ${item.description}
            </div>
            <div style="color: #00bfff;">价格: ${item.cost}秘境币</div>
            <button onclick="buyTsrShopItem('${key}')" 
                style="background: ${isMaxPurchased ? '#666' : 'linear-gradient(to bottom, #ffd700, #daa520)'}; 
                       color: ${isMaxPurchased ? '#999' : '#004d73'}; 
                       border: none; padding: 5px 10px; border-radius: 3px; 
                       cursor: ${isMaxPurchased ? 'not-allowed' : 'pointer'}; 
                       margin-top: 10px; font-weight: bold;"
                ${isMaxPurchased ? 'disabled' : ''}>
                ${isMaxPurchased ? '已售罄' : '购买'}
            </button>
            ${isMaxPurchased ? `
                <div style="color: #ff6b6b; font-size: 12px; margin-top: 5px;">
                    ⚠️ 已达到购买上限
                </div>
            ` : ''}
        `;
        
        container.appendChild(itemElement);
    });
    
    // 显示永久加成信息
    updatePermanentBonusesDisplay();
}

// 显示永久加成信息
function updatePermanentBonusesDisplay() {
    const tsr = player.timeSecretRealm;
    const container = document.getElementById('tsrPermanentBonuses');
    
    if (!tsr.permanentBonuses) {
        container.innerHTML = '<div style="color: #888; text-align: center;">暂无永久加成</div>';
        return;
    }
    
    let bonusesHTML = '<div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">永久加成效果:</div>';
    
    if (tsr.permanentBonuses.baseTime) {
        bonusesHTML += `
            <div style="color: #00bfff; margin: 5px 0;">
                ⏱️ 时间沙漏: +${tsr.permanentBonuses.baseTime}秒基础探索时间
            </div>
        `;
    }
    
    if (tsr.permanentBonuses.startingBuffs) {
        bonusesHTML += `
            <div style="color: #32cd32; margin: 5px 0;">
                ✨ 起始祝福: 每次冒险开始获得${tsr.permanentBonuses.startingBuffs}个随机增益
            </div>
        `;
    }
    
    container.innerHTML = bonusesHTML;
}

// 购买商店物品
function buyTsrShopItem(itemKey) {
    const tsr = player.timeSecretRealm;
    const item = tsr.shopItems[itemKey];
    
    if (!item) return;
    
    // 检查限购
    if (item.maxPurchase && item.purchased >= item.maxPurchase) {
        logAction(`${item.name}已达到购买上限（${item.maxPurchase}个）`, 'error');
        return;
    }
    
    if (tsr.currency >= item.cost) {
        tsr.currency -= item.cost;
        
        // 增加已购买数量
        if (item.maxPurchase) {
            item.purchased = (item.purchased || 0) + 1;
        }
        
        // 应用物品效果
        switch(item.effect) {
            case 'time':
                // 时间沙漏：永久增加基础探索时间
                if (!tsr.permanentBonuses) {
                    tsr.permanentBonuses = {};
                }
                tsr.permanentBonuses.baseTime = (tsr.permanentBonuses.baseTime || 0) + 60;
                logAction(`永久增加60秒基础探索时间！当前总加成：${tsr.permanentBonuses.baseTime}秒`, 'success');
                break;
                
            case 'startingBuff':
                // 起始祝福：每次冒险开始时获得随机增益
                if (!tsr.permanentBonuses) {
                    tsr.permanentBonuses = {};
                }
                tsr.permanentBonuses.startingBuffs = (tsr.permanentBonuses.startingBuffs || 0) + 1;
                logAction(`永久获得起始祝福！每次冒险开始时随机获得${tsr.permanentBonuses.startingBuffs}个增益效果`, 'success');
                break;
                
            case 'attack':
                player.attributes.attackBonus += 0.50;
                logAction(`临时攻击力提升50%！当前总加成：${(player.attributes.attackBonus * 100).toFixed(2)}%`, 'success');
                break;
                
            case 'health':
                player.attributes.healthBonus += 0.50;
                logAction(`临时生命值提升50%！当前总加成：${(player.attributes.healthBonus * 100).toFixed(2)}%`, 'success');
                break;
                
            case 'detection_advanced':
                tsr.traps.playerSkills.detection = 'advanced';
                logAction('侦查技能提升至高级！成功率60%', 'success');
                break;
                
            case 'detection_expert':
                tsr.traps.playerSkills.detection = 'expert';
                logAction('侦查技能提升至专家级！成功率80%', 'success');
                break;
                
            case 'disarm_advanced':
                tsr.traps.playerSkills.disarm = 'advanced';
                logAction('解除技能提升至高级！成功率70%', 'success');
                break;
                
            case 'disarm_expert':
                tsr.traps.playerSkills.disarm = 'expert';
                logAction('解除技能提升至专家级！成功率85%', 'success');
                break;
                
            case 'detection_boost':
                // 下次冒险侦查加成（非冒险中购买时也生效）
                tsr.nextRunDetectionBoost = true;
                logAction('获得陷阱感知药水！下次冒险侦查成功率+30%', 'success');
                break;
                
            case 'material':
                player.items.yuzhou4 += 1000;
                logAction('获得1000个神器碎片', 'success');
                break;
        }
        
        // 标记物品为已解锁
        if (!tsr.unlockedItems.includes(itemKey)) {
            tsr.unlockedItems.push(itemKey);
        }
        
        logAction(`购买了${item.name}，消耗${item.cost}秘境币`, 'success');
        updateTsrShop();
        updateTimeSecretRealmUI();
        updateSkillsDisplay();
        saveGame();
    } else {
        logAction(`秘境币不足！需要${item.cost}秘境币，只有${tsr.currency}秘境币`, 'error');
    }
}
  // 种子属性
        const seedProperties = {
            "土豆": { price: 0, minWeight: 0.1, maxWeight: 10, color: "#8B4513" },
            "金桔": { price: 1000, minWeight: 0.1, maxWeight: 3, color: "#8B4513" },
            "牵牛花": { price: 3000, minWeight: 0.1, maxWeight: 5, color: "#9B59B6" },
            "无花果": { price: 5000, minWeight: 0.1, maxWeight: 5, color: "#9B59B6" },
            "黄瓜": { price: 9000, minWeight: 0.1, maxWeight: 6, color: "#27AE60" },
            "西瓜": { price: 30000, minWeight: 0.1, maxWeight: 7, color: "#2ECC71" },
            "猕猴桃": { price: 60000, minWeight: 0.1, maxWeight: 8, color: "#2ECC71" },
            "百合花": { price: 80000, minWeight: 0.1, maxWeight: 10, color: "#2ECC71" },
            "枣树": { price: 100000, minWeight: 0.1, maxWeight: 15, color: "#2ECC71" },
            "蓝莓": { price: 120000, minWeight: 0.1, maxWeight: 8, color: "#2ECC71" },
            "苹果": { price: 150000, minWeight: 0.1, maxWeight: 8, color: "#E74C3C" },
            "丝瓜": { price: 200000, minWeight: 0.1, maxWeight: 9, color: "#E74C3C" },
            "香蕉": { price: 300000, minWeight: 0.1, maxWeight: 10, color: "#F1C40F" },
            "哈密瓜": { price: 400000, minWeight: 0.1, maxWeight: 11, color: "#F1C40F" },
            "冰淇淋豆": { price: 500000, minWeight: 0.1, maxWeight: 12, color: "#F1C40F" },
            "南瓜": { price: 600000, minWeight: 0.1, maxWeight: 12, color: "#D35400" },
            "红茶": { price: 700000, minWeight: 0.1, maxWeight: 12, color: "#D35400" },
            "橙子": { price: 800000, minWeight: 0.1, maxWeight: 13, color: "#D35400" },
            "玫瑰花": { price: 900000, minWeight: 0.1, maxWeight: 13, color: "#D35400" },
            "茄子": { price: 1000000, minWeight: 0.1, maxWeight: 14, color: "#D35400" },
            "草莓": { price: 1200000, minWeight: 0.1, maxWeight: 15, color: "#E74C3C" },
            "芒果": { price: 1500000, minWeight: 0.1, maxWeight: 16, color: "#E74C3C" },
            "樱桃": { price: 2100000, minWeight: 0.1, maxWeight: 18, color: "#E74C3C" }, 
            "柚子": { price: 2400000, minWeight: 0.1, maxWeight: 19, color: "#E74C3C" }, 
            "向日葵": { price: 3000000, minWeight: 0.1, maxWeight: 20, color: "#F1C40F" },
            "松树": { price: 4000000, minWeight: 0.1, maxWeight: 22, color: "#F1C40F" },
            "茶树": { price: 5000000, minWeight: 0.1, maxWeight: 24, color: "#F1C40F" },
            "大王菊": { price: 6000000, minWeight: 0.1, maxWeight: 25, color: "#9B59B6" },
            "红袍梅": { price: 7000000, minWeight: 0.1, maxWeight: 26, color: "#9B59B6" },
            "火龙果": { price: 8000000, minWeight: 0.1, maxWeight: 22, color: "#9B59B6" },
            "柳树": { price: 9000000, minWeight: 0.1, maxWeight: 35, color: "#9B59B6" },
            "闫闫果": { price: 10000000, minWeight: 0.1, maxWeight: 29, color: "#9B59B6" },
            "菠萝": { price: 12000000, minWeight: 0.1, maxWeight: 31, color: "#9B59B6" },
            "葡萄": { price: 15000000, minWeight: 0.1, maxWeight: 30, color: "#8E44AD" },  
            "蟠桃": { price: 20000000, minWeight: 0.1, maxWeight: 30, color: "#8E44AD" },                       
            "惊奇菇": { price: 25000000, minWeight: 0.1, maxWeight: 50, color: "#8E44AD" },
            "红毛丹": { price: 30000000, minWeight: 0.1, maxWeight: 55, color: "#8E44AD" },
            "泡泡果": { price: 40000000, minWeight: 0.1, maxWeight: 50, color: "#8E44AD" },
            "人参树": { price: 50000000, minWeight: 0.1, maxWeight: 80, color: "#8E44AD" },
            "神秘果": { price: 100000000, minWeight: 0.1, maxWeight: 100, color: "#8E44AD" }
        };

        // 种子刷新概率
        const refreshProbabilities = {
            "土豆": 100,
            "牵牛花": 100,
            "黄瓜": 100,
            "金桔": 100,
            "无花果": 100,
            "西瓜": 20,
            "苹果": 20,
            "香蕉": 20,
            "丝瓜": 20,
            "哈密瓜": 20,
            "猕猴桃": 20,
            "百合花": 20,
            "蓝莓": 20,
            "冰淇淋豆": 10,
            "枣树": 10,
            "茄子": 10,
            "南瓜": 10,
            "橙子": 10,
            "红茶": 10,
            "玫瑰花": 5,
            "草莓": 5,
            "樱桃": 5,
            "芒果": 5,
            "柚子": 3,
            "向日葵": 3,            
            "松树": 3,
            "茶树": 3,
            "大王菊": 1,
            "柳树": 1,
            "红袍梅": 1,
            "火龙果": 1,
            "菠萝": 1,            
            "闫闫果": 1,
            "葡萄": 1,
            "蟠桃": 0.1,
            "惊奇菇": 0.1,
            "红毛丹": 0.1,
            "泡泡果": 0.1,
            "人参树": 0.1,
           "神秘果": 0.01
        };

        // 道具属性
        const itemProperties = {
            "普通浇水器": { 
                price: 2000, 
                color: "#3498db",
                refreshProbability: 100,
                description: "加速成长10分钟，如果没有特殊突变或者基础突变，2%几率特殊突变和基础突变"
            },
            "高级浇水器": { 
                price: 20000, 
                color: "#9b59b6",
                refreshProbability: 20,
                description: "加速成长20分钟，如果没有特殊突变或者基础突变，5%几率特殊突变和基础突变"
            },
            "超级浇水器": { 
                price: 100000, 
                color: "#e74c3c",
                refreshProbability: 5,
                description: "加速成长60分钟，如果没有特殊突变或者基础突变，10%几率特殊突变和基础突变"
            },
            "天气附加器": { 
                price: 500000, 
                color: "#f1c40f",
                refreshProbability: 1,
                description: "直接获得一个没有获得的天气突变"
            },
         "流星棒": { 
        price: 200000, 
        color: "#ff6b6b",
        refreshProbability: 3,
        description: "已有天气词条时，如果词条中无亮晶晶词条，则直接获得亮晶晶词条"
    },
    "火盆": { 
        price: 20000, 
        color: "#ff6b35",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无灼热词条，则直接获得灼热词条"
    },
    "吹风机": { 
        price: 200000, 
        color: "#4d96ff",
        refreshProbability: 3,
        description: "已有天气词条时，如果词条中无龙卷风词条，则直接获得龙卷风词条"
    },
    "避雷针": { 
        price: 200000, 
        color: "#ffd93d",
        refreshProbability: 2,
        description: "已有天气词条时，如果词条中无落雷词条，则直接获得落雷词条"
    },
    "雪球机": { 
        price: 20000, 
        color: "#6bc5ff",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无覆雪词条，则直接获得覆雪词条"
    },
    "催化器": { 
        price: 50000, 
        color: "#6bcf7f",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无生机词条，则直接获得生机词条"
    },
    "臭气弹": { 
        price: 50000, 
        color: "#8b5a2b",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无臭气词条，则直接获得臭气词条"
    },
    "生化弹": { 
        price: 50000, 
        color: "#6b8b3d",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无腐烂词条，则直接获得腐烂词条"
    },
    "雾霾制造器": { 
        price: 50000, 
        color: "#a9a9a9",
        refreshProbability: 5,
        description: "已有天气词条时，如果词条中无迷雾词条，则直接获得迷雾词条"
    }
        };
// 突变倍率
        const mutationMultipliers = {
            // 灰色词条
            "潮湿": 1, "颤栗": 1, "生机": 1, "覆雪": 1,"腐烂": 1,
            "迷雾": 1, "灼热": 1, "沙尘": 1, "结霜": 1,"臭气": 1,
            // 绿色词条
            "银": 3, "落雷": 3, "冰冻": 3, "陶化": 3,
            // 蓝色词条
            "金": 10, "荧光": 10, "彩虹": 10,"龙卷风": 10,
            // 紫色词条
            "星环": 15, "瓷化": 15, "亮晶晶": 15, "台风": 15,
            // 金色词条
            "水晶": 20, "红月": 20, "陨石": 20,
            // 彩色词条
            "流光": 25, "霓虹": 25, "渡劫": 25
        };

        // 特殊突变
        const specialMutations = {
            "土豆": "薯片",
            "牵牛花": "牛郎", 
            "黄瓜": "黄瓜蛇",
            "西瓜": "方形",
            "金桔": "桔王",
            "无花果": "芜湖",
            "苹果": "糖葫芦",
            "枣树": "大枣王",
            "香蕉": "橡胶猴",
            "丝瓜": "丝雨",
            "茄子": "巨无霸",
            "红茶": "冰红茶",
            "草莓": "连体",
            "哈密瓜": "哈批",
            "樱桃": "双胞胎",
            "猕猴桃": "齐天大圣",
            "冰淇淋豆": "冰淇淋",
            "向日葵": "海绵宝宝",
            "大王菊": "超人菊", 
            "红袍梅": "红袍尊者",
            "玫瑰花": "爱心",
            "柚子": "柚水",
            "蓝莓": "蓝颜知己",
            "百合花": "友情",
            "惊奇菇": "奥特曼",
            "葡萄": "菩提祖师",
            "松树": "三只松鼠",
            "茶树": "茶茶萝莉",
            "蟠桃": "仙桃",
           "红毛丹": "仙丹",
           "闫闫果": "小闫闫",
           "人参树": "人参果",
           "菠萝": "菠萝吹雪",
            "泡泡果": "泡神",
             "柳树": "柳神",
           "火龙果": "火龙真身",
           "神秘果": "未来之心",
            "南瓜": "万圣节"
        };

        // 天气列表
        const weatherList = [
            "潮湿", "颤栗", "生机", "覆雪", "迷雾","冰冻", "陶化", "瓷化","臭气",
            "灼热", "沙尘", "结霜", "落雷", "荧光","龙卷风","台风","腐烂",
            "彩虹", "星环", "亮晶晶", "霓虹", "红月", "渡劫", "陨石"
        ];

        // 天气突变颜色映射
        const weatherMutationColors = {
            "潮湿": "grey",      // 灰色
            "腐烂": "grey", 
            "臭气": "grey", 
            "颤栗": "grey",    // 灰色
            "生机": "grey",     // 灰色
            "覆雪": "grey",           // 灰色
            "迷雾": "grey",           // 灰色
            "灼热": "grey",         // 灰色
            "沙尘": "grey",         // 灰色
            "结霜": "grey",     // 灰色
            "落雷": "green",          // 绿色
            "冰冻": "green", 
            "陶化": "green", 
            "荧光": "blue",           // 蓝色
            "龙卷风": "blue",  
            "彩虹": "rainbow",        // 彩虹色
            "星环": "purple",         // 紫色
            "瓷化": "purple",  
            "亮晶晶": "purple",
            "台风": "purple",  
            "霓虹": "rainbow",        // 彩虹色
            "渡劫": "rainbow",
            "陨石": "gold", 
            "红月": "gold"           // 金色
                    };
const seedSynthesisRules = {
    "土豆": {
        nextLevel: "金桔",
        required: 3,
        description: "3个土豆可合成1个金桔种子"
    },
    "金桔": {
        nextLevel: "牵牛花",
        required: 3,
        description: "3个金桔可合成1个牵牛花种子"
    },
    "牵牛花": {
        nextLevel: "无花果", 
        required: 3,
        description: "3个牵牛花可合成1个无花果种子"
    },
       "无花果": {
        nextLevel: "黄瓜", 
        required: 3,
        description: "3个无花果可合成1个黄瓜种子"
    },
    "黄瓜": {
        nextLevel: "西瓜",
        required: 3,
        description: "3个黄瓜可合成1个西瓜种子"
    },
    "西瓜": {
        nextLevel: "猕猴桃",
        required: 3,
        description: "3个西瓜可合成1个猕猴桃种子"
    },
    "猕猴桃": {
        nextLevel: "百合花",
        required: 3,
        description: "3个猕猴桃可合成1个百合花种子"
    },
    "百合花": {
        nextLevel: "枣树",
        required: 3,
        description: "3个百合花可合成1个枣树种子"
    },
    "枣树": {
        nextLevel: "蓝莓",
        required: 3,
        description: "3个枣树可合成1个蓝莓种子"
    },
    "蓝莓": {
        nextLevel: "苹果",
        required: 3,
        description: "3个蓝莓可合成1个苹果种子"
    },
    "苹果": {
        nextLevel: "丝瓜",
        required: 3,
        description: "3个苹果可合成1个丝瓜种子"
    },
    "丝瓜": {
        nextLevel: "香蕉",
        required: 3,
        description: "3个丝瓜可合成1个香蕉种子"
    },
    "香蕉": {
        nextLevel: "哈密瓜",
        required: 3,
        description: "3个香蕉可合成1个哈密瓜种子"
    },
    "哈密瓜": {
        nextLevel: "冰淇淋豆",
        required: 3,
        description: "3个哈密瓜可合成1个冰淇淋豆种子"
    },
    "冰淇淋豆": {
        nextLevel: "南瓜",
        required: 3,
        description: "3个冰淇淋豆可合成1个南瓜种子"
    },
    "南瓜": {
        nextLevel: "红茶",
        required: 3,
        description: "3个南瓜可合成1个红茶种子"
    },
    "红茶": {
        nextLevel: "橙子",
        required: 3,
        description: "3个红茶可合成1个橙子种子"
    },
    "橙子": {
        nextLevel: "玫瑰花",
        required: 3,
        description: "3个橙子可合成1个玫瑰花种子"
    },
    "玫瑰花": {
        nextLevel: "茄子",
        required: 3,
        description: "3个玫瑰花可合成1个茄子种子"
    },
    "茄子": {
        nextLevel: "草莓",
        required: 3,
        description: "3个茄子可合成1个草莓种子"
    },
    "草莓": {
        nextLevel: "芒果",
        required: 3,
        description: "3个草莓可合成1个芒果种子"
    },
    "芒果": {
        nextLevel: "樱桃",
        required: 3,
        description: "3个芒果可合成1个樱桃种子"
    },
    "樱桃": {
        nextLevel: "柚子",
        required: 3,
        description: "3个樱桃可合成1个柚子种子"
    },
    "柚子": {
        nextLevel: "向日葵",
        required: 3,
        description: "3个柚子可合成1个向日葵种子"
    },
    "向日葵": {
        nextLevel: "松树",
        required: 3,
        description: "3个向日葵可合成1个松树种子"
    },
    "松树": {
        nextLevel: "茶树",
        required: 3,
        description: "3个松树可合成1个茶树种子"
    },
    "茶树": {
        nextLevel: "大王菊",
        required: 3,
        description: "3个茶树可合成1个大王菊种子"
    },
    "大王菊": {
        nextLevel: "红袍梅",
        required: 3,
        description: "3个大王菊可合成1个红袍梅种子"
    },
    "红袍梅": {
        nextLevel: "火龙果",
        required: 3,
        description: "3个红袍梅可合成1个火龙果种子"
    },
    "火龙果": {
        nextLevel: "柳树",
        required: 3,
        description: "3个火龙果可合成1个柳树种子"
    },
    "柳树": {
        nextLevel: "闫闫果",
        required: 3,
        description: "3个柳树可合成1个闫闫果种子"
    },
    "闫闫果": {
        nextLevel: "菠萝",
        required: 3,
        description: "3个闫闫果可合成1个菠萝种子"
    },
    "菠萝": {
        nextLevel: "葡萄",
        required: 3,
        description: "3个菠萝可合成1个葡萄种子"
    },
    "葡萄": {
        nextLevel: "蟠桃",
        required: 3,
        description: "3个葡萄可合成1个蟠桃种子"
    },
    "蟠桃": {
        nextLevel: "惊奇菇",
        required: 3,
        description: "3个蟠桃可合成1个惊奇菇种子"
    },
    "惊奇菇": {
        nextLevel: "红毛丹",
        required: 3,
        description: "3个惊奇菇可合成1个红毛丹种子"
    },
    "红毛丹": {
        nextLevel: "泡泡果",
        required: 3,
        description: "3个红毛丹可合成1个泡泡果种子"
    },
    "泡泡果": {
        nextLevel: "人参树",
        required: 3,
        description: "3个泡泡果可合成1个人参树种子"
    },
    "人参树": {
        nextLevel: "神秘果",
        required: 3,
        description: "3个人参树可合成1个神秘果种子"
    },
    "神秘果": {
        nextLevel: null, // 最高级，无法再合成
        required: 0,
        description: "神秘果是最高级种子，无法继续合成"
    }
};

const lotterySystem = {
    // 可抽奖的词条
    eligibleMutations: ["银", "金", "水晶", "流光"],
    
    // 奖品池
    prizePool: [
              { name: "金桔", probability: 25,  weight: 1  },
         { name: "牵牛花",  probability: 20,  weight: 1  },
        { name: "无花果", probability: 20,  weight: 1  },
         { name: "黄瓜", probability: 15,  weight: 1  },
          { name: "西瓜", probability: 5,  weight: 1  },
      { name: "猕猴桃", probability: 3,  weight: 1  },
        { name: "百合花",  probability: 3,  weight: 1  },
         { name: "蓝莓", probability: 3,  weight: 1  },
        { name: "苹果", probability: 2,  weight: 1  },
        { name: "哈密瓜", probability: 1,  weight: 1  },
         { name: "南瓜", probability: 1,  weight: 1  },
        { name: "玫瑰花", probability: 1,  weight: 1  },
       { name: "草莓", probability: 0.7,  weight: 1 },
       { name: "柚子", probability: 0.15,  weight: 1  },
       { name: "向日葵", probability: 0.12,  weight: 1  },
       { name: "松树", probability: 0.013,  weight: 1  },
       { name: "大王菊", probability: 0.012,  weight: 1  },
     { name: "闫闫果", probability: 0.002,  weight: 1  },
      { name: "葡萄", probability: 0.002,  weight: 1  },
      { name: "惊奇菇", probability: 0.001,  weight: 1  }       
    ],
    
    // 抽奖消耗
    costPerDraw: 1, // 每次抽奖消耗1次抽奖次数
    
    // 初始化抽奖概率
    initPrizeProbabilities: function() {
        let totalProbability = 0;
        this.prizePool.forEach(prize => {
            totalProbability += prize.probability;
        });
        
        // 计算实际概率
        this.prizePool.forEach(prize => {
            prize.actualProbability = (prize.probability / totalProbability * 100).toFixed(2);
        });
    }
};

// 初始化抽奖概率
lotterySystem.initPrizeProbabilities();
        // 疯狂地主游戏控制函数
        function toggleLandlordGame() {
        if (player.battle.maxStage < 2) {
        alert("需要打怪模式达到第3层才能开启疯狂地主！");
        return;
    }
            const ui = document.getElementById('landlordUI');
            if (ui.style.display === 'block') {
                closeLandlordGame();
            } else {
                openLandlordGame();
            }
        }

        function openLandlordGame() {
            const ui = document.getElementById('landlordUI');
            ui.style.display = 'block';
            initLandlordGame();
        }

        function closeLandlordGame() {
            const ui = document.getElementById('landlordUI');
            ui.style.display = 'none';
            if (player.landlord && player.landlord._timerId) {
                clearInterval(player.landlord._timerId);
                player.landlord._timerId = null;
            }
            saveGame(); // 关闭时保存游戏
        }

        // 初始化疯狂地主游戏
        function initLandlordGame() {
            refreshLandlordStore();
            refreshLandlordItemStore();
            updateLandlordWeather();
            renderAllLandlordUI();
            startLandlordTimers();
            
            // 检查离线收益
            checkLandlordOfflineEarnings();
        }

        // 刷新种子商店
        function refreshLandlordStore() {
            const now = Date.now();
            const timeSinceRefresh = now - player.landlord.lastSeedRefreshTime;
            
            // 每10分钟刷新一次
            if (timeSinceRefresh >= 10 * 60 * 1000) {
                player.landlord.storeItems = {};
                
                for (const seed in refreshProbabilities) {
                    if (Math.random() * 100 < refreshProbabilities[seed]) {
                        player.landlord.storeItems[seed] = 1; // 库存1个
                    } else {
                        player.landlord.storeItems[seed] = 0; // 无库存
                    }
                }
                
                player.landlord.lastSeedRefreshTime = now;
                showLandlordNotification("种子商店已刷新！", "info");
            }
            
            renderLandlordStore();
        }

        // 刷新道具商店
        function refreshLandlordItemStore() {
            const now = Date.now();
            const timeSinceRefresh = now - player.landlord.lastItemRefreshTime;
            
            // 每10分钟刷新一次
            if (timeSinceRefresh >= 10 * 60 * 1000) {
                player.landlord.itemStoreItems = {};
                
                for (const item in itemProperties) {
                    const probability = itemProperties[item].refreshProbability;
                    if (Math.random() * 100 < probability) {
                        player.landlord.itemStoreItems[item] = 1; // 库存1个
                    } else {
                        player.landlord.itemStoreItems[item] = 0; // 无库存
                    }
                }
                
                player.landlord.lastItemRefreshTime = now;
                showLandlordNotification("道具商店已刷新！", "info");
            }
            
            renderLandlordItemStore();
        }

        // 购买种子
        function buyLandlordSeed(seedName) {
            const seed = seedProperties[seedName];
            
            if (!seed) {
                showLandlordNotification("种子不存在！", "error");
                return;
            }
            
            if (player.landlord.storeItems[seedName] <= 0) {
                showLandlordNotification("该种子已售罄！", "error");
                return;
            }
            
            if (player.landlord.coins < seed.price) {
                showLandlordNotification("地主币不足！", "error");
                return;
            }
            
            // 扣除货币
            player.landlord.coins -= seed.price;
            
            // 添加到种子仓库
            if (!player.landlord.seedStorage[seedName]) {
                player.landlord.seedStorage[seedName] = 0;
            }
            player.landlord.seedStorage[seedName]++;
            
            // 减少库存
            player.landlord.storeItems[seedName]--;
            
            // 更新显示
            updateLandlordCoinDisplay();
            renderLandlordStore();
            renderLandlordSeedStorage();
            
            showLandlordNotification(`成功购买${seedName}种子！`, "success");
            saveGame();
        }

        // 购买道具
        function buyLandlordItem(itemName) {
            const item = itemProperties[itemName];
            
            if (!item) {
                showLandlordNotification("道具不存在！", "error");
                return;
            }
            
            if (player.landlord.itemStoreItems[itemName] <= 0) {
                showLandlordNotification("该道具已售罄！", "error");
                return;
            }
            
            if (player.landlord.coins < item.price) {
                showLandlordNotification("地主币不足！", "error");
                return;
            }
            
            // 扣除货币
            player.landlord.coins -= item.price;
            
            // 添加到道具仓库
            if (!player.landlord.itemStorage[itemName]) {
                player.landlord.itemStorage[itemName] = 0;
            }
            player.landlord.itemStorage[itemName]++;
            
            // 减少库存
            player.landlord.itemStoreItems[itemName]--;
            
            // 更新显示
            updateLandlordCoinDisplay();
            renderLandlordItemStore();
            renderLandlordItemStorage();
            
            showLandlordNotification(`成功购买${itemName}！`, "success");
            saveGame();
        }

        // 选择种子种植
        function selectLandlordSeedForPlanting(fieldIndex) {
            player.landlord.selectedFieldIndex = fieldIndex;
            
            // 打开种子选择模态框
            const modal = document.getElementById('landlordSeedModal');
            const content = document.getElementById('landlordSeedModalContent');
            
            content.innerHTML = '';
            
            for (const seedName in player.landlord.seedStorage) {
                if (player.landlord.seedStorage[seedName] > 0) {
                    const seedDiv = document.createElement('div');
                    seedDiv.className = 'landlord-seed-item';
                    seedDiv.style.cursor = 'pointer';
                    seedDiv.style.marginBottom = '10px';
                    seedDiv.onclick = () => plantLandlordSeed(fieldIndex, seedName);
                    
                    const seedColor = seedProperties[seedName].color;
                    
                    seedDiv.innerHTML = `
                        <div class="landlord-seed-icon" style="background: ${seedColor};">${seedName.charAt(0)}</div>
                        <div>${seedName}</div>
                        <div>库存: ${player.landlord.seedStorage[seedName]}</div>
                    `;
                    
                    content.appendChild(seedDiv);
                }
            }
            
            if (content.children.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 20px;">种子仓库为空</div>';
            }
            
            modal.style.display = 'block';
        }

        // 关闭种子选择模态框
        function closeLandlordSeedModal() {
            document.getElementById('landlordSeedModal').style.display = 'none';
            player.landlord.selectedFieldIndex = null;
        }

        // 选择道具使用
        function selectLandlordItemForUsing(fieldIndex) {
            player.landlord.selectedFieldIndex = fieldIndex;
            
            // 打开道具选择模态框
            const modal = document.getElementById('landlordItemModal');
            const content = document.getElementById('landlordItemModalContent');
            
            content.innerHTML = '';
            
            for (const itemName in player.landlord.itemStorage) {
                if (player.landlord.itemStorage[itemName] > 0) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'landlord-item-item';
                    itemDiv.style.cursor = 'pointer';
                    itemDiv.style.marginBottom = '10px';
                    itemDiv.onclick = () => useLandlordItem(fieldIndex, itemName);
                    
                    const itemColor = itemProperties[itemName].color;
                    const itemDesc = itemProperties[itemName].description;
                    
                    itemDiv.innerHTML = `
                        <div class="landlord-item-icon" style="background: ${itemColor};">${itemName.charAt(0)}</div>
                        <div>${itemName}</div>
                        <div style="font-size: 0.8em; color: #7f8c8d; margin: 5px 0;">${itemDesc}</div>
                        <div>库存: ${player.landlord.itemStorage[itemName]}</div>
                    `;
                    
                    content.appendChild(itemDiv);
                }
            }
            
            if (content.children.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 20px;">道具仓库为空</div>';
            }
            
            modal.style.display = 'block';
        }

        // 关闭道具选择模态框
        function closeLandlordItemModal() {
            document.getElementById('landlordItemModal').style.display = 'none';
            player.landlord.selectedFieldIndex = null;
        }

        // 种植种子
        function plantLandlordSeed(fieldIndex, seedName) {
            if (!player.landlord.seedStorage[seedName] || player.landlord.seedStorage[seedName] <= 0) {
                showLandlordNotification("种子不足！", "error");
                closeLandlordSeedModal();
                return;
            }
            
            if (player.landlord.fields[fieldIndex] !== null) {
                showLandlordNotification("地块已被占用！", "error");
                closeLandlordSeedModal();
                return;
            }
            
            // 消耗种子
            player.landlord.seedStorage[seedName]--;
            
            // 创建新植物
            const plant = createNewLandlordPlant(seedName);
            
            // 放置到田地
            player.landlord.fields[fieldIndex] = plant;
            
            // 更新统计
            player.landlord.stats.totalPlants++;
            
            // 更新显示
            renderLandlordFields();
            renderLandlordSeedStorage();
            closeLandlordSeedModal();
            
            showLandlordNotification(`${seedName}已种植！`, "success");
            saveGame();
        }

        // 使用道具
        function useLandlordItem(fieldIndex, itemName) {
            const plant = player.landlord.fields[fieldIndex];
            
            if (!plant) {
                showLandlordNotification("地块为空，无法使用道具！", "error");
                closeLandlordItemModal();
                return;
            }
            
            if (!player.landlord.itemStorage[itemName] || player.landlord.itemStorage[itemName] <= 0) {
                showLandlordNotification("道具不足！", "error");
                closeLandlordItemModal();
                return;
            }
            
            // 消耗道具
            player.landlord.itemStorage[itemName]--;
            
            // 应用道具效果
            let effectMessage = applyLandlordItemEffect(plant, itemName);
            
            // 更新统计
            player.landlord.stats.itemsUsed++;
            
            // 更新显示
            renderLandlordFields();
            renderLandlordItemStorage();
            closeLandlordItemModal();
            
            showLandlordNotification(`使用${itemName}成功！${effectMessage}`, "success");
            saveGame();
        }

        // 应用道具效果
        function applyLandlordItemEffect(plant, itemName) {
            let effectMessage = "";
            
            switch(itemName) {
                case "普通浇水器":
                    // 加速成长5分钟
                    const acceleratedTime1 = Date.now() - 10 * 60 * 1000;
                    plant.plantedAt = Math.min(plant.plantedAt, acceleratedTime1);
                    effectMessage = "生长加速10分钟！";
                    
                    // 如果没有特殊突变或者基础突变，2%几率特殊突变和基础突变
                    if (plant.mutations.length === 0 && !plant.specialMutation) {
                        if (Math.random() * 100 < 2) {
                            applyLandlordBasicMutation(plant);
                            effectMessage += " 触发了基础突变！";
                        }
                    }
                    break;
                    
                case "高级浇水器":
                    // 加速成长15分钟
                    const acceleratedTime2 = Date.now() - 20 * 60 * 1000;
                    plant.plantedAt = Math.min(plant.plantedAt, acceleratedTime2);
                    effectMessage = "生长加速20分钟！";
                    
                    // 如果没有特殊突变或者基础突变，5%几率特殊突变和基础突变
                    if (plant.mutations.length === 0 && !plant.specialMutation) {
                        if (Math.random() * 100 < 5) {
                            applyLandlordBasicMutation(plant);
                            effectMessage += " 触发了基础突变！";
                        }
                    }
                    break;
                    
                case "超级浇水器":
                    // 加速成长30分钟
                    const acceleratedTime3 = Date.now() - 60 * 60 * 1000;
                    plant.plantedAt = Math.min(plant.plantedAt, acceleratedTime3);
                    effectMessage = "生长加速60分钟！";
                    
                    // 如果没有特殊突变或者基础突变，10%几率特殊突变和基础突变
                    if (plant.mutations.length === 0 && !plant.specialMutation) {
                        if (Math.random() * 100 < 10) {
                            applyLandlordBasicMutation(plant);
                            effectMessage += " 触发了基础突变！";
                        }
                    }
                    break;
                    
                case "天气附加器":
                    // 直接获得一个没有获得的天气突变
                    const availableWeathers = weatherList.filter(weather => 
                        !plant.weatherMutations.includes(weather)
                    );
                    
                    if (availableWeathers.length > 0) {
                        const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                        plant.weatherMutations.push(randomWeather);
                        player.landlord.stats.weatherMutations++;
                        effectMessage = `获得了${randomWeather}天气突变！`;
                    } else {
                        effectMessage = "已拥有所有天气突变！";
                    }
                    break;
            case "流星棒":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("亮晶晶")) {
                    plant.weatherMutations.push("亮晶晶");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了亮晶晶词条！";
                } else {
                    effectMessage = "已有亮晶晶词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "火盆":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("灼热")) {
                    plant.weatherMutations.push("灼热");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了灼热词条！";
                } else {
                    effectMessage = "已有灼热词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "吹风机":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("龙卷风")) {
                    plant.weatherMutations.push("龙卷风");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了龙卷风词条！";
                } else {
                    effectMessage = "已有龙卷风词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "避雷针":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("落雷")) {
                    plant.weatherMutations.push("落雷");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了落雷词条！";
                } else {
                    effectMessage = "已有落雷词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "雪球机":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("覆雪")) {
                    plant.weatherMutations.push("覆雪");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了覆雪词条！";
                } else {
                    effectMessage = "已有覆雪词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "催化器":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("生机")) {
                    plant.weatherMutations.push("生机");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了生机词条！";
                } else {
                    effectMessage = "已有生机词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "臭气弹":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("臭气")) {
                    plant.weatherMutations.push("臭气");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了臭气词条！";
                } else {
                    effectMessage = "已有臭气词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "生化弹":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("腐烂")) {
                    plant.weatherMutations.push("腐烂");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了腐烂词条！";
                } else {
                    effectMessage = "已有腐烂词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            
        case "雾霾制造器":
            if (plant.weatherMutations.length > 0) {
                if (!plant.weatherMutations.includes("迷雾")) {
                    plant.weatherMutations.push("迷雾");
                    player.landlord.stats.weatherMutations++;
                    effectMessage = "获得了迷雾词条！";
                } else {
                    effectMessage = "已有迷雾词条！";
                }
            } else {
                effectMessage = "没有天气词条，无法使用！";
            }
            break;
            }
            
            return effectMessage;
        }

        // 创建新植物
        function createNewLandlordPlant(seedName) {
            // 计算重量
            const maxWeight = seedProperties[seedName].maxWeight;
            let weight = calculateLandlordWeight(maxWeight);
            
            // 计算生长时间（10分钟基础 + 每kg加1分钟）
            const growTime = 10 + Math.floor(weight);
            
            // 创建植物对象
            const plant = {
                type: seedName,
                weight: weight,
                plantedAt: Date.now(),
                growTime: growTime, // 分钟
                mutations: [], // 基础突变
                weatherMutations: [], // 天气突变
                specialMutation: false, // 特殊突变
                isMature: false
            };
            
            // 应用基础突变
            applyLandlordBasicMutation(plant);
            
            return plant;
        }

        // 计算重量
        function calculateLandlordWeight(maxWeight) {
            const random = Math.random() * 100;
            let weightPercentage;
            
            if (random < 90) {
                weightPercentage = 0.05 + Math.random() * 0.05; // 5%-10%
            } else if (random < 94) {
                weightPercentage = 0.1 + Math.random() * 0.2; // 10%-30%
            } else if (random < 97) {
                weightPercentage = 0.3 + Math.random() * 0.5; // 30%-80%
            } else if (random < 99) {
                weightPercentage = 0.5 + Math.random() * 0.5; // 50%-100%
            } else {
                weightPercentage = Math.random(); // 0-100%
            }
            
            // 确保重量在最小值和最大值之间
            const minWeight = 0.1;
            return Math.max(minWeight, Math.min(maxWeight, maxWeight * weightPercentage));
        }

        // 应用基础突变
        function applyLandlordBasicMutation(plant) {
            const random = Math.random() * 100;
            
            if (random < 95) {
                // 无突变
            } else if (random < 97) {
                plant.mutations.push("银");
                player.landlord.stats.basicMutations++;
            } else if (random < 98) {
                plant.mutations.push("金");
                player.landlord.stats.basicMutations++;
            } else if (random < 99) {
                plant.mutations.push("水晶");
                player.landlord.stats.basicMutations++;
            } else {
                plant.mutations.push("流光");
                player.landlord.stats.basicMutations++;
            }
            
            // 检查特殊突变 (5%几率)
            if (Math.random() * 100 < 5) {
                plant.specialMutation = true;
                player.landlord.stats.specialMutations++;
            }
        }

        // 收获植物
       function harvestLandlordPlant(fieldIndex) {
            const plant = player.landlord.fields[fieldIndex];
            
            if (!plant || !plant.isMature) {
                showLandlordNotification("植物尚未成熟！", "error");
                return;
            }
            
            // 计算价格
            const value = calculateLandlordPlantValue(plant);
            
            // 添加到果实仓库
            const fruit = {
                type: plant.type,
                weight: plant.weight,
                value: value,
                mutations: [...plant.mutations],
                weatherMutations: [...plant.weatherMutations],
                specialMutation: plant.specialMutation,
                harvestedAt: new Date().toLocaleString('zh-CN', { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                }),
                harvestedTimestamp: Date.now(),
                isLocked: false  // 添加锁定状态，默认为未锁定
            };
            
            // 检查仓库容量
            if (player.landlord.fruitStorage.length >= 200) {
                showLandlordNotification("果实仓库已满！", "error");
                return;
            }
            
            player.landlord.fruitStorage.push(fruit);
            
            // 重新生成一个新植物（同种类，但重量和突变重新随机）
            const newPlant = createNewLandlordPlant(plant.type);
            
            // 注意：收获后天气突变重置，不复制旧植物的天气突变
            
            // 替换地块上的植物
            player.landlord.fields[fieldIndex] = newPlant;
            
            // 更新统计
            player.landlord.stats.totalHarvests++;
            player.landlord.stats.totalCoinsEarned += value;
            
            // 更新最高倍率
            const multiplier = calculateLandlordMultiplier(plant);
            if (multiplier > player.landlord.stats.highestMultiplier) {
                player.landlord.stats.highestMultiplier = multiplier;
            }
            
            // 更新显示
            renderLandlordFields();
            renderLandlordFruitStorage();
            updateLandlordStats();
            
            showLandlordNotification(`收获${plant.type}，价值${formatNumber(value)}地主币！`, "success");
            saveGame();
        }

        // 铲除植物
        function removeLandlordPlant(fieldIndex) {
            if (!player.landlord.fields[fieldIndex]) {
                showLandlordNotification("地块为空！", "error");
                return;
            }
            
            player.landlord.fields[fieldIndex] = null;
            
            renderLandlordFields();
            showLandlordNotification("植物已移除！", "info");
            saveGame();
        }

        // 计算植物价值
        function calculateLandlordPlantValue(plant) {
            const seedPrice = seedProperties[plant.type].price;
            
            // 基础价格
            const basePrice = (1 + (seedPrice / 100)) * plant.weight;
            
            // 基础突变倍率
            let basicMultiplier = 1;
            plant.mutations.forEach(mutation => {
                basicMultiplier *= (mutationMultipliers[mutation] || 1);
            });
            
            // 天气突变倍率 (加法)
            let weatherMultiplier = 1;
            if (plant.weatherMutations.length > 0) {
                const weatherMultipliers = plant.weatherMutations.map(m => mutationMultipliers[m] || 1);
                weatherMultiplier = 1 + weatherMultipliers.reduce((a, b) => a + b) - weatherMultipliers.length;
            }
            
            // 特殊突变倍率
            const specialMultiplier = plant.specialMutation ? 5 : 1;
            
            // 最终价格
            let finalPrice = basePrice * basicMultiplier * weatherMultiplier * specialMultiplier;
            
            // 如果是特殊突变植物，应用额外的5倍倍率
            if (plant.specialMutation && specialMutations[plant.type]) {
                finalPrice *= 5;
            }
            
            return Math.floor(finalPrice);
        }

        // 计算总倍率
        function calculateLandlordMultiplier(plant) {
            let multiplier = 1;
            
            plant.mutations.forEach(mutation => {
                multiplier *= (mutationMultipliers[mutation] || 1);
            });
            
            if (plant.weatherMutations.length > 0) {
                const weatherMultipliers = plant.weatherMutations.map(m => mutationMultipliers[m] || 1);
                multiplier *= (1 + weatherMultipliers.reduce((a, b) => a + b) - weatherMultipliers.length);
            }
            
            if (plant.specialMutation) {
                multiplier *= 5;
            }
            
            return multiplier;
        }

        // 卖出果实
       function sellLandlordFruit(fruitIndex) {
    const fruit = player.landlord.fruitStorage[fruitIndex];
    
    if (!fruit) {
        showLandlordNotification("果实不存在！", "error");
        return;
    }
    
    // 检查是否锁定
    if (fruit.isLocked) {
        showLandlordNotification("该果实已锁定，无法卖出！", "error");
        return;
    }
    
    let lotteryEarned = 0;
    
    // 检查是否获得抽奖次数
    if (isFruitEligibleForLottery(fruit)) {
        lotteryEarned = 1;
        player.landlord.lottery.drawCount += lotteryEarned;
    }
    
    // 增加地主币
    player.landlord.coins += fruit.value;
    
    // 移除果实
    player.landlord.fruitStorage.splice(fruitIndex, 1);
    
    // 更新显示
    updateLandlordCoinDisplay();
    renderLandlordFruitStorage();
    updateLotteryDisplay();
    
    let message = `卖出${fruit.type}，获得${formatNumber(fruit.value)}地主币`;
    if (lotteryEarned > 0) {
        message += `，获得${lotteryEarned}次抽奖机会！`;
    }
    
    showLandlordNotification(message, "success");
    saveGame();
}
 // 添加锁定/解锁果实函数
        function toggleLockLandlordFruit(fruitIndex) {
            const fruit = player.landlord.fruitStorage[fruitIndex];
            
            if (!fruit) {
                showLandlordNotification("果实不存在！", "error");
                return;
            }
            
            // 切换锁定状态
            fruit.isLocked = !fruit.isLocked;
            
            // 更新显示
            renderLandlordFruitStorage();
            
            showLandlordNotification(`${fruit.type}已${fruit.isLocked ? '锁定' : '解锁'}！`, "info");
            saveGame();
        }

        // 解锁新地块
        function unlockLandlordField() {
            const currentFields = player.landlord.unlockedFields;
            let unlockCost = 0;
            
            if (currentFields === 5) {
                unlockCost = 100000; // 解锁6-10块地
            } else if (currentFields === 10) {
                unlockCost = 2000000; // 解锁11-15块地
            } else if (currentFields === 15) {
                unlockCost = 50000000; // 解锁16-20块地
            } else if (currentFields === 20) {
                unlockCost = 500000000; // 解锁21-25块地
             } else if (currentFields === 25) {
                unlockCost = 5000000000; // 解锁26-30块地
             } else if (currentFields === 30) {
                unlockCost = 50000000000; // 解锁31-35块地
             } else if (currentFields === 35) {
                unlockCost = 5000000000000; // 解锁36-40块地
            } else if (currentFields === 40) {
                unlockCost = 500000000000000; // 解锁41-45块地
            } else if (currentFields === 45) {
                unlockCost = 50000000000000000; // 解锁46-50块地
            } else {
                showLandlordNotification("已解锁所有地块！", "info");
                return;
            }
            
            if (player.landlord.coins < unlockCost) {
                showLandlordNotification(`需要${formatNumber(unlockCost)}地主币！`, "error");
                return;
            }
            
            // 扣除地主币
            player.landlord.coins -= unlockCost;
            
            // 解锁新地块
            player.landlord.unlockedFields += 5;
            
            // 扩展田地数组
            for (let i = 0; i < 5; i++) {
                player.landlord.fields.push(null);
            }
            
            // 更新显示
            updateLandlordCoinDisplay();
            renderLandlordFields();
            updateLandlordStats();
            
            showLandlordNotification(`成功解锁5块新田地！`, "success");
            saveGame();
        }

        // 更新天气
        function updateLandlordWeather() {
            const now = Date.now();
            const timeSinceChange = now - player.landlord.lastWeatherChange;
            
            // 每10分钟有几率改变天气
            if (timeSinceChange >= 10 * 60 * 1000) {
                // 40%几率改变天气
                if (Math.random() * 100 < 40) {
                    const newWeather = weatherList[Math.floor(Math.random() * weatherList.length)];
                    player.landlord.weather = newWeather;
                    player.landlord.lastWeatherChange = now;
                    
                    // 应用天气突变
                    applyLandlordWeatherMutation();
                    
                    showLandlordNotification(`天气变为：${newWeather}`, "info");
                } else {
                    player.landlord.weather = "晴朗";
                }
                
                updateLandlordStats();
            }
        }

        // 应用天气突变 (15%几率)
        function applyLandlordWeatherMutation() {
            if (player.landlord.weather === "晴朗") return;
            
            let weatherApplied = false;
            
            player.landlord.fields.forEach((plant, index) => {
                if (plant) { // 只要有植物，无论是否成熟
                    // 15%几率应用天气突变
                    if (Math.random() * 100 < 15) {
                        if (!plant.weatherMutations.includes(player.landlord.weather)) {
          plant.weatherMutations.push(player.landlord.weather);
                            player.landlord.stats.weatherMutations++;
                            weatherApplied = true;
                            
                            // 重新渲染这个地块
                            renderLandlordField(index);
                        }
                    }
                }
            });
            
            if (weatherApplied) {
                showLandlordNotification(`${player.landlord.weather}天气影响了田地！`, "info");
            }
        }

        // 检查植物生长状态
        function checkLandlordPlantGrowth() {
            const now = Date.now();
            let changed = false;
            
            player.landlord.fields.forEach((plant, index) => {
                if (plant && !plant.isMature) {
                    const plantedAt = plant.plantedAt;
                    const elapsedMinutes = (now - plantedAt) / (1000 * 60);
                    
                    if (elapsedMinutes >= plant.growTime) {
                        plant.isMature = true;
                        changed = true;
                        
                        // 渲染这个地块
                        renderLandlordField(index);
                    }
                }
            });
            
            if (changed) {
                saveGame();
            }
        }

        // 渲染种子商店
        function renderLandlordStore() {
            const storeContainer = document.getElementById('landlordStoreItems');
            if (!storeContainer) return;
            
            storeContainer.innerHTML = '';
            
            for (const seedName in seedProperties) {
                const seed = seedProperties[seedName];
                const stock = player.landlord.storeItems[seedName] || 0;
                const canAfford = player.landlord.coins >= seed.price;
                
                const seedDiv = document.createElement('div');
                seedDiv.className = 'landlord-seed-item';
                seedDiv.innerHTML = `
                    <div class="landlord-seed-icon" style="background: ${seed.color};">${seedName.charAt(0)}</div>
                    <div style="font-weight: bold;">${seedName}</div>
                    <div style="font-size: 0.9em; color: #7f8c8d; margin: 5px 0;">
                        重量: ${seed.minWeight}-${seed.maxWeight}kg
                    </div>
                    <div class="landlord-seed-price">${formatNumber(seed.price)} 地主币</div>
                    <div style="margin: 5px 0; font-size: 0.9em;">库存: ${stock}</div>
                    <button class="landlord-buy-button" ${stock <= 0 || !canAfford ? 'disabled' : ''} 
                            onclick="buyLandlordSeed('${seedName}')">
                        ${stock <= 0 ? '售罄' : (canAfford ? '购买' : '货币不足')}
                    </button>
                `;
                
                storeContainer.appendChild(seedDiv);
            }
            
            // 更新刷新计时器
            updateLandlordSeedRefreshTimer();
        }

        // 渲染道具商店
        function renderLandlordItemStore() {
            const storeContainer = document.getElementById('landlordItemStoreItems');
            if (!storeContainer) return;
            
            storeContainer.innerHTML = '';
            
            for (const itemName in itemProperties) {
                const item = itemProperties[itemName];
                const stock = player.landlord.itemStoreItems[itemName] || 0;
                const canAfford = player.landlord.coins >= item.price;
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'landlord-item-item';
                itemDiv.innerHTML = `
                    <div class="landlord-item-icon" style="background: ${item.color};">${itemName.charAt(0)}</div>
                    <div style="font-weight: bold;">${itemName}</div>
                    <div style="font-size: 0.8em; color: #7f8c8d; margin: 5px 0;">${item.description}</div>
                    <div class="landlord-item-price">${formatNumber(item.price)} 地主币</div>
                    <div style="margin: 5px 0; font-size: 0.9em;">库存: ${stock}</div>
                    <button class="landlord-buy-button" ${stock <= 0 || !canAfford ? 'disabled' : ''} 
                            onclick="buyLandlordItem('${itemName}')">
                        ${stock <= 0 ? '售罄' : (canAfford ? '购买' : '货币不足')}
                    </button>
                `;
                
                storeContainer.appendChild(itemDiv);
            }
            
            // 更新刷新计时器
            updateLandlordItemRefreshTimer();
        }

        // 渲染田地
        function renderLandlordFields() {
    const fieldsContainer = document.getElementById('landlordFieldsContainer');
    const unlockSection = document.getElementById('landlordUnlockSection');
    
    if (!fieldsContainer) return;
    
    fieldsContainer.innerHTML = '';
    
    for (let i = 0; i < player.landlord.unlockedFields; i++) {
        const plant = player.landlord.fields[i];
        const isLocked = player.landlord.lockedFields[i];
        const fieldDiv = document.createElement('div');
        fieldDiv.className = `landlord-field ${!plant ? 'empty' : ''} ${isLocked ? 'locked' : ''}`;
        
        if (!plant) {
            fieldDiv.innerHTML = `
                <div class="landlord-field-header">
                    <div class="landlord-field-info">
                        <div class="landlord-field-number">田地 ${i + 1}</div>
                        <div class="landlord-field-status">空闲</div>
                    </div>
                    <button class="landlord-lock-button ${isLocked ? 'active' : ''}" 
                            onclick="toggleFieldLock(${i})" 
                            title="${isLocked ? '解锁田地' : '锁定田地'}">
                        ${isLocked ? '🔓' : '🔒'}
                    </button>
                </div>
                <div class="landlord-empty-content">
                    <div style="font-size: 3em; color: rgba(0,0,0,0.1); margin: 20px 0;">+</div>
                    <button class="landlord-plant-button" onclick="selectLandlordSeedForPlanting(${i})">种植</button>
                </div>
            `;
        } else {
            const timeLeft = plant.isMature ? 0 : 
                Math.max(0, Math.ceil(plant.growTime - (Date.now() - plant.plantedAt) / (1000 * 60)));
            
            const progress = plant.isMature ? 100 : 
                Math.min(100, Math.floor(((Date.now() - plant.plantedAt) / (1000 * 60)) / plant.growTime * 100));
            
            // 突变标签
            let mutationTags = '';
            
            plant.mutations.forEach(mutation => {
                const colorClass = getLandlordMutationColorClass(mutation);
                mutationTags += `<span class="landlord-mutation-tag ${colorClass}">${mutation}</span>`;
            });
            
            plant.weatherMutations.forEach(mutation => {
                const colorClass = getLandlordMutationColorClass(mutation);
                mutationTags += `<span class="landlord-mutation-tag ${colorClass}">${mutation}</span>`;
            });
            
            if (plant.specialMutation) {
                const specialName = specialMutations[plant.type] || '特殊突变';
                mutationTags += `<span class="landlord-mutation-tag landlord-mutation-rainbow">${specialName}</span>`;
            }
            
            fieldDiv.innerHTML = `
                <div class="landlord-field-header">
                    <div class="landlord-field-info">
                        <div class="landlord-field-number">田地 ${i + 1}</div>
                        <div class="landlord-field-status">
                            <span class="plant-name">${plant.type}</span>
                            ${plant.isMature ? '<span class="mature-badge">已成熟</span>' : ''}
                            ${isLocked ? '<span class="lock-badge">已锁定</span>' : ''}
                        </div>
                    </div>
                    <button class="landlord-lock-button ${isLocked ? 'active' : ''}" 
                            onclick="toggleFieldLock(${i})" 
                            title="${isLocked ? '解锁田地' : '锁定田地'}">
                        ${isLocked ? '🔓' : '🔒'}
                    </button>
                </div>
                
                <div class="landlord-plant-details">
                    <div class="landlord-plant-info">
                        <div class="plant-weight">重量: <span>${plant.weight.toFixed(2)}kg</span></div>
                        <div class="plant-growth">
                            ${plant.isMature ? 
                                '<span style="color: #27ae60;">✓ 可收获</span>' : 
                                `<span style="color: #f39c12;">成长中... ${timeLeft}分钟</span>`
                            }
                        </div>
                        ${mutationTags ? `<div class="landlord-mutations-list">${mutationTags}</div>` : ''}
                    </div>
                    
                    ${!plant.isMature ? `
                        <div class="landlord-progress-bar">
                            <div class="landlord-progress-fill" style="width: ${progress}%"></div>
                        </div>
                    ` : ''}
                    
                    <div class="landlord-field-actions">
                        <div class="landlord-action-row">
                            ${plant.isMature ? 
                                `<button class="landlord-harvest-button" onclick="harvestLandlordPlant(${i})">收获</button>` : 
                                `<button class="landlord-growth-button" disabled>${progress}%</button>`
                            }
                            <button class="landlord-remove-button" onclick="removeLandlordPlant(${i})">铲除</button>
                        </div>
                        <div class="landlord-action-row">
                            <button class="landlord-item-button" onclick="selectLandlordItemForUsing(${i})">使用道具</button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        fieldsContainer.appendChild(fieldDiv);
    }
            
            // 解锁地块信息
            let unlockCost = 0;
            if (player.landlord.unlockedFields === 5) {
                unlockCost = 100000;
            } else if (player.landlord.unlockedFields === 10) {
                unlockCost = 2000000;
            } else if (player.landlord.unlockedFields === 15) {
                unlockCost = 50000000;
            } else if (player.landlord.unlockedFields === 20) {
                unlockCost = 500000000;
            } else if (player.landlord.unlockedFields === 25) {
                unlockCost = 5000000000;
            }else if (player.landlord.unlockedFields === 30) {
                unlockCost = 50000000000;
            }else if (player.landlord.unlockedFields === 35) {
                unlockCost = 5000000000000;
            }else if (player.landlord.unlockedFields === 40) {
                unlockCost = 500000000000000;
            }else if (player.landlord.unlockedFields === 45) {
                unlockCost = 50000000000000000;
            }
            
            if (unlockCost > 0) {
                unlockSection.innerHTML = `
                    <h3>解锁更多田地</h3>
                    <p>解锁${player.landlord.unlockedFields + 1}-${player.landlord.unlockedFields + 5}号田地</p>
                    <p>需要: ${formatNumber(unlockCost)} 地主币</p>
                    <button class="landlord-unlock-button" ${player.landlord.coins >= unlockCost ? '' : 'disabled'} 
                            onclick="unlockLandlordField()">
                        ${player.landlord.coins >= unlockCost ? '解锁' : '货币不足'}
                    </button>
                `;
            } else {
                unlockSection.innerHTML = '<p>所有田地已解锁！</p>';
            }
        }

        // 渲染种子仓库
       function renderLandlordSeedStorage() {
    const storageContainer = document.getElementById('landlordSeedStorage');
    if (!storageContainer) return;
    
    storageContainer.innerHTML = '';
    
    // 添加合成界面标题
    const synthesisHeader = document.createElement('div');
    synthesisHeader.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #3498db;">
            <h3 style="margin: 0; color: #2c3e50;">种子仓库</h3>
            <button onclick="toggleSynthesisMode()" class="synthesis-toggle-button" style="background: #9b59b6; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">
                ${player.landlord.synthesisMode ? '退出合成' : '种子合成'}
            </button>
        </div>
    `;
    storageContainer.appendChild(synthesisHeader);
    
    // 合成模式下的界面
    if (player.landlord.synthesisMode) {
        renderSynthesisInterface(storageContainer);
        return;
    }
    
    // 正常模式下的种子仓库
    let hasSeeds = false;
    
    for (const seedName in player.landlord.seedStorage) {
        if (player.landlord.seedStorage[seedName] > 0) {
            hasSeeds = true;
            const seedDiv = document.createElement('div');
            seedDiv.className = 'landlord-storage-item';
            seedDiv.innerHTML = `
                <div class="landlord-item-info">
                    <div style="font-weight: bold;">${seedName}</div>
                    <div>价格: ${formatNumber(seedProperties[seedName].price)}</div>
                    ${seedSynthesisRules[seedName] && seedSynthesisRules[seedName].nextLevel ? 
                        `<div style="font-size: 0.8em; color: #9b59b6;">可合成: ${seedSynthesisRules[seedName].nextLevel}</div>` : 
                        ''}
                </div>
                <div style="font-weight: bold; color: #3498db; font-size: 1.2em;">${player.landlord.seedStorage[seedName]}</div>
            `;
            storageContainer.appendChild(seedDiv);
        }
    }
    
    if (!hasSeeds) {
        storageContainer.innerHTML += '<div style="text-align: center; padding: 20px; color: #7f8c8d;">种子仓库为空</div>';
    }
}

        // 渲染果实仓库
       function renderLandlordFruitStorage() {
            const storageContainer = document.getElementById('landlordFruitStorage');
            const totalAssets = document.getElementById('landlordTotalAssetsValue');
            
            if (!storageContainer) return;
            
            storageContainer.innerHTML = '';
             // 添加抽奖信息提示
    const lotteryInfo = document.createElement('div');
    lotteryInfo.style.background = '#fff3cd';
    lotteryInfo.style.padding = '15px';
    lotteryInfo.style.borderRadius = '5px';
    lotteryInfo.style.marginBottom = '15px';
    lotteryInfo.style.borderLeft = '4px solid #f39c12';
    
    const eligibleCount = player.landlord.fruitStorage.filter(fruit => 
        fruit && isFruitEligibleForLottery(fruit) && !fruit.isLocked
    ).length;
    
    lotteryInfo.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <div style="font-weight: bold; color: #856404;">🎯 抽奖提示</div>
                <div style="font-size: 0.9em; color: #8d6a00; margin-top: 5px;">
                    出售带有【银、金、水晶、流光】词条的果实可获得抽奖机会
                </div>
                <div style="font-size: 0.8em; color: #8d6a00; margin-top: 3px;">
                    当前可获抽奖次数: <span style="font-weight: bold;">${eligibleCount}</span> 次
                </div>
            </div>
            <div style="text-align: right;">
                <div style="font-size: 0.9em; color: #8d6a00;">当前抽奖次数</div>
                <div style="font-size: 1.5em; font-weight: bold; color: #e74c3c;">
                    ${player.landlord.lottery.drawCount || 0}
                </div>
            </div>
        </div>
    `;
    
    storageContainer.appendChild(lotteryInfo);
            let totalValue = 0;
            let lockedValue = 0;
            let unlockedValue = 0;
            
            if (player.landlord.fruitStorage.length === 0) {
                storageContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">果实仓库为空</div>';
            } else {
                player.landlord.fruitStorage.forEach((fruit, index) => {
                    totalValue += fruit.value;
                    if (fruit.isLocked) {
                        lockedValue += fruit.value;
                    } else {
                        unlockedValue += fruit.value;
                    }
                    
                    const fruitDiv = document.createElement('div');
                    fruitDiv.className = `landlord-storage-item ${fruit.isLocked ? 'locked' : ''}`;
                    if (fruit.isLocked) {
                        fruitDiv.style.background = 'linear-gradient(135deg, #fff3cd, #ffeaa7)';
                        fruitDiv.style.border = '2px solid #f39c12';
                    }
                    
                    // 突变标签
                    let mutationTags = '';
                    
                    // 基础突变标签
                    fruit.mutations.forEach(mutation => {
                        const colorClass = getLandlordMutationColorClass(mutation);
                        mutationTags += `<span class="landlord-mutation-tag ${colorClass}" style="font-size: 0.7em; margin-right: 2px;">${mutation}</span>`;
                    });
                    
                    // 天气突变标签
                    fruit.weatherMutations.forEach(mutation => {
                        const colorClass = getLandlordMutationColorClass(mutation);
                        mutationTags += `<span class="landlord-mutation-tag ${colorClass}" style="font-size: 0.7em; margin-right: 2px;">${mutation}</span>`;
                    });
                    
                    // 特殊突变标签
                    if (fruit.specialMutation) {
                        const specialName = specialMutations[fruit.type] || '特殊';
                        mutationTags += `<span class="landlord-mutation-tag landlord-mutation-rainbow" style="font-size: 0.7em; margin-right: 2px;">${specialName}</span>`;
                    }
                    
                    fruitDiv.innerHTML = `
                        <div class="landlord-item-info" style="flex: 1;">
                            <div style="font-weight: bold; display: flex; justify-content: space-between; align-items: center;">
                                <span>${fruit.type} ${fruit.isLocked ? '🔒' : ''}</span>
                                <span>${fruit.weight.toFixed(2)}kg</span>
                            </div>
                            <div style="color: #27ae60; font-weight: bold; font-size: 1.1em;">
                                ${formatNumber(fruit.value)} 地主币
                                ${fruit.isLocked ? '<span style="color: #f39c12; font-size: 0.8em;"> (已锁定)</span>' : ''}
                            </div>
                            <div style="margin-top: 5px;">
                                ${mutationTags || '<span style="color: #95a5a6; font-size: 0.9em;">无突变</span>'}
                            </div>
                            <div style="color: #7f8c8d; font-size: 0.8em; margin-top: 5px;">
                                收获: ${fruit.harvestedAt}
                            </div>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 5px;">
                            <button onclick="toggleLockLandlordFruit(${index})" 
                                    style="background: ${fruit.isLocked ? '#f39c12' : '#95a5a6'}; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">
                                ${fruit.isLocked ? '解锁' : '锁定'}
                            </button>
                            <button onclick="sellLandlordFruit(${index})" 
                                    ${fruit.isLocked ? 'disabled' : ''}
                                    style="background: ${fruit.isLocked ? '#bdc3c7' : '#2ecc71'}; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">
                                ${fruit.isLocked ? '已锁定' : '卖出'}
                            </button>
                        </div>
                    `;
                    
                    storageContainer.appendChild(fruitDiv);
                });
            }
            
            if (totalAssets) {
                let displayText = formatNumber(unlockedValue) + ' 地主币';
                if (lockedValue > 0) {
                    displayText += ` (锁定: ${formatNumber(lockedValue)})`;
                }
                totalAssets.textContent = displayText;
            }
        }

        // 渲染道具仓库
        function renderLandlordItemStorage() {
            const storageContainer = document.getElementById('landlordItemStorage');
            if (!storageContainer) return;
            
            storageContainer.innerHTML = '';
            
            let hasItems = false;
            
            for (const itemName in player.landlord.itemStorage) {
                if (player.landlord.itemStorage[itemName] > 0) {
                    hasItems = true;
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'landlord-storage-item';
                    
                    const itemColor = itemProperties[itemName].color;
                    
                    itemDiv.innerHTML = `
                        <div class="landlord-item-info">
                            <div style="font-weight: bold; display: flex; align-items: center; gap: 10px;">
                                <div style="width: 20px; height: 20px; border-radius: 50%; background: ${itemColor};"></div>
                                <span>${itemName}</span>
                            </div>
                            <div style="font-size: 0.9em; color: #7f8c8d;">${itemProperties[itemName].description}</div>
                        </div>
                        <div style="font-weight: bold; color: #9b59b6; font-size: 1.2em;">${player.landlord.itemStorage[itemName]}</div>
                    `;
                    storageContainer.appendChild(itemDiv);
                }
            }
            
            if (!hasItems) {
                storageContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">道具仓库为空</div>';
            }
        }

        // 更新统计
        function updateLandlordStats() {
            const stats = player.landlord.stats;
            
            document.getElementById('landlordTotalPlants').textContent = stats.totalPlants;
            document.getElementById('landlordTotalHarvests').textContent = stats.totalHarvests;
            document.getElementById('landlordTotalCoinsEarned').textContent = formatNumber(stats.totalCoinsEarned);
            document.getElementById('landlordCurrentWeather').textContent = player.landlord.weather;
            document.getElementById('landlordBasicMutations').textContent = stats.basicMutations;
            document.getElementById('landlordWeatherMutations').textContent = stats.weatherMutations;
            document.getElementById('landlordSpecialMutations').textContent = stats.specialMutations;
            document.getElementById('landlordHighestMultiplier').textContent = stats.highestMultiplier.toFixed(1) + 'x';
            document.getElementById('landlordUnlockedFields').textContent = player.landlord.unlockedFields;
            document.getElementById('landlordItemUsageCount').textContent = stats.itemsUsed;
            document.getElementById('landlordSynthesisCount').textContent = stats.synthesisCount || 0;
            document.getElementById('landlordSeedsUpgraded').textContent = stats.seedsUpgraded || 0;
             // 计算种子和果实数量
            let seedCount = 0;
            for (const seed in player.landlord.seedStorage) {
                seedCount += player.landlord.seedStorage[seed];
            }
            document.getElementById('landlordSeedStorageCount').textContent = seedCount;
            
            // 计算锁定果实数量
            let lockedFruitCount = 0;
            let totalFruitValue = 0;
            let lockedFruitValue = 0;
            
            player.landlord.fruitStorage.forEach(fruit => {
                totalFruitValue += fruit.value;
                if (fruit.isLocked) {
                    lockedFruitCount++;
                    lockedFruitValue += fruit.value;
                }
            });
            
            document.getElementById('landlordFruitStorageCount').textContent = 
                `${player.landlord.fruitStorage.length} (${lockedFruitCount}锁定)`;
            
            // 在仓库总资产中显示锁定信息
            const totalAssetsElement = document.getElementById('landlordTotalAssetsValue');
            if (totalAssetsElement) {
                let assetsText = formatNumber(totalFruitValue) + ' 地主币';
                if (lockedFruitCount > 0) {
                    assetsText += ` (锁定: ${formatNumber(lockedFruitValue)})`;
                }
                totalAssetsElement.textContent = assetsText;
            }
        }
        // 更新货币显示
        function updateLandlordCoinDisplay() {
            document.getElementById('landlordCoinBalance').textContent = formatNumber(player.landlord.coins);
        }

        // 更新种子商店刷新计时器
        function updateLandlordSeedRefreshTimer() {
            const now = Date.now();
            const timeSinceRefresh = now - player.landlord.lastSeedRefreshTime;
            const timeUntilRefresh = Math.max(0, 10 * 60 * 1000 - timeSinceRefresh);
            
            const minutes = Math.floor(timeUntilRefresh / (1000 * 60));
            const seconds = Math.floor((timeUntilRefresh % (1000 * 60)) / 1000);
            
            const timerElement = document.getElementById('landlordSeedRefreshTimer');
            if (timerElement) {
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // 更新道具商店刷新计时器
        function updateLandlordItemRefreshTimer() {
            const now = Date.now();
            const timeSinceRefresh = now - player.landlord.lastItemRefreshTime;
            const timeUntilRefresh = Math.max(0, 10 * 60 * 1000 - timeSinceRefresh);
            
            const minutes = Math.floor(timeUntilRefresh / (1000 * 60));
            const seconds = Math.floor((timeUntilRefresh % (1000 * 60)) / 1000);
            
            const timerElement = document.getElementById('landlordItemRefreshTimer');
            if (timerElement) {
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // 获取突变颜色类
        function getLandlordMutationColorClass(mutation) {
            // 基础突变颜色
            if (["银", "落雷", "冰冻", "陶化"].includes(mutation)) return "landlord-mutation-green";
            if (["金", "荧光", "彩虹"].includes(mutation)) return "landlord-mutation-blue";
            if (["星环", "瓷化", "亮晶晶"].includes(mutation)) return "landlord-mutation-purple";
            if (["水晶", "红月"].includes(mutation)) return "landlord-mutation-gold";
            if (["流光", "霓虹"].includes(mutation)) return "landlord-mutation-rainbow";
            
            // 天气突变颜色
            if (weatherMutationColors[mutation]) {
                return `landlord-mutation-${weatherMutationColors[mutation]}`;
            }
            
            return "landlord-mutation-grey";
        }

function addLotteryTabToNavigation() {
    const navTabs = document.querySelector('.landlord-nav');
    if (!navTabs) {
        console.error('导航栏未找到！');
        return;
    }
    
    // 检查是否已存在抽奖标签
    if (!navTabs.querySelector('.lottery-tab')) {
        const lotteryTab = document.createElement('button');
        lotteryTab.className = 'landlord-tab lottery-tab';
        lotteryTab.innerHTML = '🎰 果实抽奖';
        lotteryTab.onclick = () => switchLandlordTab('lottery');
        navTabs.appendChild(lotteryTab);
    }
    
    // 添加抽奖内容区域
    const tabContent = document.querySelector('.landlord-content');
    if (tabContent && !tabContent.querySelector('#landlordLotteryTab')) {
        const lotteryTab = document.createElement('div');
        lotteryTab.id = 'landlordLotteryTab';
        lotteryTab.className = 'landlord-tab-content';
        lotteryTab.style.display = 'none'; // 默认隐藏
        lotteryTab.innerHTML = '<div id="landlordLotteryContainer"></div>';
        tabContent.appendChild(lotteryTab);
    }
}

// 14. 在游戏初始化时添加抽奖界面
function initLotterySystem() {
    // 确保抽奖数据存在
    if (!player.landlord.lottery) {
        player.landlord.lottery = {
            drawCount: 0,
            totalDraws: 0,
            prizesWon: {},
            lastDrawTime: 0,
            drawHistory: []
        };
    }
    
    // 确保奖品统计存在
    if (!player.landlord.lottery.prizesWon) {
        player.landlord.lottery.prizesWon = {};
    }
    
    // 确保抽奖历史存在
    if (!player.landlord.lottery.drawHistory) {
        player.landlord.lottery.drawHistory = [];
    }
    
    addLotteryTabToNavigation();
}

// 15. 添加CSS动画
const lotteryStyles = `
    @keyframes lotteryWin {
        0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
        70% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    
    .lottery-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    
    .lottery-button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
    }
    
    .eligible-fruit {
        border: 2px solid #f39c12 !important;
        position: relative;
    }
    
    .eligible-fruit::before {
        content: '🎯';
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 1.2em;
    }
`;

// 添加样式
const lotteryStyleSheet = document.createElement('style');
lotteryStyleSheet.textContent = lotteryStyles;
document.head.appendChild(lotteryStyleSheet);

// 16. 在游戏加载时初始化抽奖系统
window.addEventListener('load', function() {
    setTimeout(function() {
        initLotterySystem();
        console.log('抽奖系统已初始化');
    }, 1000);
});
function renderSynthesisInterface(container) {
    // 合成说明
    const infoDiv = document.createElement('div');
    infoDiv.style.background = '#e8f4fd';
    infoDiv.style.padding = '15px';
    infoDiv.style.borderRadius = '5px';
    infoDiv.style.marginBottom = '15px';
    infoDiv.style.borderLeft = '4px solid #3498db';
    infoDiv.innerHTML = `
        <h4 style="margin: 0 0 10px 0; color: #2c3e50;">种子合成规则</h4>
        <div style="font-size: 0.9em; color: #34495e;">
            <div>• 3个低级种子可合成1个高级种子</div>
            <div>• 合成不可逆，高级种子无法拆分为低级种子</div>
            <div>• 神秘果为最高级种子，无法继续合成</div>
        </div>
    `;
    container.appendChild(infoDiv);
    
    // 合成统计
    const statsDiv = document.createElement('div');
    statsDiv.style.background = '#f8f9fa';
    statsDiv.style.padding = '10px';
    statsDiv.style.borderRadius = '5px';
    statsDiv.style.marginBottom = '15px';
    statsDiv.style.textAlign = 'center';
    statsDiv.innerHTML = `
        <div style="font-weight: bold; color: #2c3e50;">合成统计</div>
        <div style="display: flex; justify-content: space-around; margin-top: 10px;">
            <div>
                <div style="font-size: 1.2em; color: #e74c3c;">${player.landlord.stats.synthesisCount || 0}</div>
                <div style="font-size: 0.8em; color: #7f8c8d;">总合成次数</div>
            </div>
            <div>
                <div style="font-size: 1.2em; color: #27ae60;">${player.landlord.stats.seedsUpgraded || 0}</div>
                <div style="font-size: 0.8em; color: #7f8c8d;">升级种子数</div>
            </div>
        </div>
    `;
    container.appendChild(statsDiv);
    
    // 合成列表
    const synthesisList = document.createElement('div');
    synthesisList.className = 'synthesis-list';
    
    let hasSynthesisOptions = false;
    
    for (const seedName in seedSynthesisRules) {
        const rule = seedSynthesisRules[seedName];
        if (!rule.nextLevel) continue; // 跳过最高级种子
        
        const currentCount = player.landlord.seedStorage[seedName] || 0;
        const canSynthesize = currentCount >= rule.required;
        const nextSeedValue = seedProperties[rule.nextLevel] ? seedProperties[rule.nextLevel].price : 0;
        const currentSeedValue = seedProperties[seedName] ? seedProperties[seedName].price : 0;
        const valueIncrease = nextSeedValue - (currentSeedValue * rule.required);
        
        const synthesisItem = document.createElement('div');
        synthesisItem.className = 'synthesis-item';
        synthesisItem.style.background = canSynthesize ? '#f8fff8' : '#f8f9fa';
        synthesisItem.style.border = canSynthesize ? '2px solid #27ae60' : '1px solid #ddd';
        synthesisItem.style.padding = '15px';
        synthesisItem.style.borderRadius = '8px';
        synthesisItem.style.marginBottom = '10px';
        synthesisItem.style.transition = 'all 0.3s';
        
        synthesisItem.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="flex: 1;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                        <div style="font-weight: bold; font-size: 1.1em;">${seedName} → ${rule.nextLevel}</div>
                        <span style="background: ${canSynthesize ? '#27ae60' : '#95a5a6'}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8em;">
                            ${canSynthesize ? '可合成' : '材料不足'}
                        </span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 8px;">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span style="font-weight: bold; color: #e74c3c;">${currentCount}</span>
                            <span style="color: #7f8c8d;">/</span>
                            <span style="font-weight: bold;">${rule.required}</span>
                            <span style="color: #7f8c8d;">个${seedName}</span>
                        </div>
                        <div style="color: #7f8c8d;">→</div>
                        <div style="font-weight: bold; color: #27ae60;">1个${rule.nextLevel}</div>
                    </div>
                    
                    <div style="font-size: 0.8em; color: #7f8c8d;">
                        ${rule.description}
                        ${valueIncrease > 0 ? 
                            `<span style="color: #27ae60;"> (价值提升: +${formatNumber(valueIncrease)})</span>` : 
                            ''}
                    </div>
                </div>
                
                <div style="margin-left: 15px;">
                    <button onclick="synthesizeSeed('${seedName}')" 
                            ${canSynthesize ? '' : 'disabled'}
                            class="synthesis-button"
                            style="background: ${canSynthesize ? '#27ae60' : '#bdc3c7'}; 
                                   color: white; border: none; padding: 8px 15px; 
                                   border-radius: 5px; cursor: pointer; min-width: 80px;">
                        ${canSynthesize ? '合成' : '材料不足'}
                    </button>
                </div>
            </div>
        `;
        
        synthesisList.appendChild(synthesisItem);
        hasSynthesisOptions = true;
    }
    
    if (!hasSynthesisOptions) {
        synthesisList.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
                <div style="font-size: 3em; margin-bottom: 10px;">🌱</div>
                <div>暂无可合成的种子</div>
                <div style="font-size: 0.9em; margin-top: 5px;">请先收集足够的低级种子</div>
            </div>
        `;
    }
    
    container.appendChild(synthesisList);
    
    // 一键合成区域
    const autoSynthesisDiv = document.createElement('div');
    autoSynthesisDiv.style.background = '#fff3cd';
    autoSynthesisDiv.style.padding = '15px';
    autoSynthesisDiv.style.borderRadius = '5px';
    autoSynthesisDiv.style.marginTop = '20px';
    autoSynthesisDiv.style.border = '1px solid #ffeaa7';
    autoSynthesisDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <div style="font-weight: bold; color: #856404;">一键合成</div>
                <div style="font-size: 0.9em; color: #8d6a00; margin-top: 5px;">
                    自动合成所有可合成的种子
                </div>
            </div>
            <button onclick="autoSynthesizeAll()" class="auto-synthesis-button"
                    style="background: #f39c12; color: white; border: none; 
                           padding: 10px 20px; border-radius: 5px; cursor: pointer;
                           font-weight: bold;">
                一键合成全部
            </button>
        </div>
    `;
    container.appendChild(autoSynthesisDiv);
}
function synthesizeSeed(seedName) {
    const rule = seedSynthesisRules[seedName];
    if (!rule || !rule.nextLevel) {
        showLandlordNotification("合成规则不存在！", "error");
        return;
    }
    
    const currentCount = player.landlord.seedStorage[seedName] || 0;
    if (currentCount < rule.required) {
        showLandlordNotification(`${seedName}数量不足！需要${rule.required}个`, "error");
        return;
    }
    
    // 消耗种子
    player.landlord.seedStorage[seedName] -= rule.required;
    
    // 如果数量为0，删除该键
    if (player.landlord.seedStorage[seedName] <= 0) {
        delete player.landlord.seedStorage[seedName];
    }
    
    // 获得新种子
    if (!player.landlord.seedStorage[rule.nextLevel]) {
        player.landlord.seedStorage[rule.nextLevel] = 0;
    }
    player.landlord.seedStorage[rule.nextLevel] += 1;
    
    // 更新统计
    player.landlord.stats.synthesisCount = (player.landlord.stats.synthesisCount || 0) + 1;
    player.landlord.stats.seedsUpgraded = (player.landlord.stats.seedsUpgraded || 0) + rule.required;
    
    // 显示合成动画效果
    showSynthesisAnimation(seedName, rule.nextLevel);
    
    // 更新显示
    renderLandlordSeedStorage();
    
    showLandlordNotification(`成功合成！${rule.required}个${seedName} → 1个${rule.nextLevel}`, "success");
    saveGame();
}
function autoSynthesizeAll() {
    let totalSynthesized = 0;
    let synthesizedItems = [];
    
    // 从低级到高级依次合成
    const seedOrder = ["土豆", "金桔", "牵牛花", "无花果", "黄瓜", "西瓜", "猕猴桃", "百合花", "枣树", "蓝莓", "苹果", "丝瓜", "香蕉", "哈密瓜", "冰淇淋豆", "南瓜", "红茶", "橙子", "玫瑰花", "茄子", "草莓", "芒果", "樱桃", "柚子", "向日葵", "松树", "茶树", "大王菊", "红袍梅", "火龙果", "柳树", "闫闫果", "菠萝", "葡萄", "蟠桃", "惊奇菇", "红毛丹", "泡泡果", "人参树"];
    
    let hasSynthesis = true;
    while (hasSynthesis) {
        hasSynthesis = false;
        
        for (const seedName of seedOrder) {
            const rule = seedSynthesisRules[seedName];
            if (!rule || !rule.nextLevel) continue;
            
            const currentCount = player.landlord.seedStorage[seedName] || 0;
            if (currentCount >= rule.required) {
                // 计算可合成次数
                const synthesisTimes = Math.floor(currentCount / rule.required);
                
                // 消耗种子
                player.landlord.seedStorage[seedName] -= synthesisTimes * rule.required;
                if (player.landlord.seedStorage[seedName] <= 0) {
                    delete player.landlord.seedStorage[seedName];
                }
                
                // 获得新种子
                if (!player.landlord.seedStorage[rule.nextLevel]) {
                    player.landlord.seedStorage[rule.nextLevel] = 0;
                }
                player.landlord.seedStorage[rule.nextLevel] += synthesisTimes;
                
                // 更新统计
                totalSynthesized += synthesisTimes;
                synthesizedItems.push(`${synthesisTimes}次 ${seedName}→${rule.nextLevel}`);
                
                hasSynthesis = true;
            }
        }
    }
    
    if (totalSynthesized > 0) {
        // 更新总统计
        player.landlord.stats.synthesisCount = (player.landlord.stats.synthesisCount || 0) + totalSynthesized;
        player.landlord.stats.seedsUpgraded = (player.landlord.stats.seedsUpgraded || 0) + totalSynthesized;
        
        // 更新显示
        renderLandlordSeedStorage();
        
        showLandlordNotification(`一键合成完成！共合成${totalSynthesized}次`, "success");
        saveGame();
    } else {
        showLandlordNotification("没有可合成的种子！", "info");
    }
}
function toggleSynthesisMode() {
    player.landlord.synthesisMode = !player.landlord.synthesisMode;
    renderLandlordSeedStorage();
}
function showSynthesisAnimation(fromSeed, toSeed) {
    const animationContainer = document.createElement('div');
    animationContainer.style.position = 'fixed';
    animationContainer.style.top = '50%';
    animationContainer.style.left = '50%';
    animationContainer.style.transform = 'translate(-50%, -50%)';
    animationContainer.style.zIndex = '1000';
    animationContainer.style.pointerEvents = 'none';
    
    animationContainer.innerHTML = `
        <div style="background: rgba(39, 174, 96, 0.9); color: white; padding: 20px; border-radius: 10px; text-align: center; animation: synthesisPop 0.5s ease-out;">
            <div style="font-size: 2em; margin-bottom: 10px;">✨</div>
            <div style="font-weight: bold; font-size: 1.2em;">合成成功！</div>
            <div style="margin: 10px 0;">${fromSeed} → ${toSeed}</div>
        </div>
    `;
    
    document.body.appendChild(animationContainer);
    
    setTimeout(() => {
        document.body.removeChild(animationContainer);
    }, 1000);
}

// 8. 添加合成相关CSS样式
const synthesisStyles = `
    .synthesis-toggle-button:hover {
        background: #8e44ad !important;
        transform: translateY(-2px);
    }
    
    .synthesis-button:hover:not(:disabled) {
        background: #219653 !important;
        transform: scale(1.05);
    }
    
    .synthesis-button:disabled {
        cursor: not-allowed;
    }
    
    .auto-synthesis-button:hover {
        background: #e67e22 !important;
        transform: translateY(-2px);
    }
    
    .synthesis-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    @keyframes synthesisPop {
        0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
        70% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
`;

// 添加样式到页面
const styleSheet = document.createElement('style');
styleSheet.textContent = synthesisStyles;
document.head.appendChild(styleSheet);

// 9. 初始化合成模式状态
if (typeof player.landlord.synthesisMode === 'undefined') {
    player.landlord.synthesisMode = false;
}
        // 检查离线收益
        function checkLandlordOfflineEarnings() {
            const now = Date.now();
            const lastPlayTime = player.landlord.lastSaveTime || now;
            const offlineMinutes = (now - lastPlayTime) / (1000 * 60);
            
            // 最大离线20小时
            const maxOfflineMinutes = 1200;
            const effectiveOfflineMinutes = Math.min(offlineMinutes, maxOfflineMinutes);
            
            if (effectiveOfflineMinutes >= 10) {
                // 计算商店刷新次数
                const refreshCount = Math.floor(effectiveOfflineMinutes / 10);
                
                // 生长进度计算
                player.landlord.fields.forEach((plant, index) => {
                    if (plant && !plant.isMature) {
                        const plantedAt = plant.plantedAt;
                        const elapsedMinutes = (now - plantedAt) / (1000 * 60);
                        
                        if (elapsedMinutes >= plant.growTime) {
                            plant.isMature = true;
                        }
                    }
                });
                
                // 天气变化计算
                const weatherChangeCount = Math.floor(effectiveOfflineMinutes / 10);
                for (let i = 0; i < weatherChangeCount; i++) {
                    if (Math.random() * 100 < 40) {
                        const newWeather = weatherList[Math.floor(Math.random() * weatherList.length)];
                        player.landlord.weather = newWeather;
                        
                        // 离线期间对植物应用天气突变
                        player.landlord.fields.forEach((plant, index) => {
                            if (plant && Math.random() * 100 < 15) { // 15%几率应用天气突变
                                if (!plant.weatherMutations.includes(player.landlord.weather)) {
                                    plant.weatherMutations.push(player.landlord.weather);
                                    player.landlord.stats.weatherMutations++;
                                }
                            }
                        });
                    }
                }
                
                // 商店刷新
                for (let i = 0; i < refreshCount; i++) {
                    // 刷新种子商店
                    for (const seed in refreshProbabilities) {
                        if (Math.random() * 100 < refreshProbabilities[seed]) {
                            player.landlord.storeItems[seed] = 1;
                        } else {
                            player.landlord.storeItems[seed] = 0;
                        }
                    }
                    
                    // 刷新道具商店
                    for (const item in itemProperties) {
                        const probability = itemProperties[item].refreshProbability;
                        if (Math.random() * 100 < probability) {
                            player.landlord.itemStoreItems[item] = 1;
                        } else {
                            player.landlord.itemStoreItems[item] = 0;
                        }
                    }
                }
                
                if (refreshCount > 0) {
                    showLandlordNotification(`离线期间商店刷新了${refreshCount}次，天气变化了${weatherChangeCount}次`, "info");
                }
            }
            
            // 保存当前时间
            player.landlord.lastSaveTime = now;
        }

        // 切换标签页
        function switchLandlordTab(tabName) {
    // 隐藏所有标签页内容
    document.querySelectorAll('.landlord-tab-content').forEach(tab => {
        tab.style.display = 'none';
    });
    
    // 移除所有标签页的活动状态
    document.querySelectorAll('.landlord-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // 显示目标标签页
    const targetTab = document.getElementById('landlord' + tabName.charAt(0).toUpperCase() + tabName.slice(1) + 'Tab');
    if (targetTab) {
        targetTab.style.display = 'block';
    }
    
    // 激活目标标签按钮
    const activeButton = document.querySelector(`.landlord-tab[onclick*="${tabName}"]`);
    if (activeButton) {
        activeButton.classList.add('active');
    }
    
    // 根据标签页加载相应内容
    switch(tabName) {
        case 'lottery':
            renderLotteryInterface();
            break;
        case 'store':
            renderLandlordStore();
            break;
        case 'itemStore':
            renderLandlordItemStore();
            break;
        case 'fields':
            renderLandlordFields();
            break;
        case 'storage':
            renderLandlordSeedStorage();
            renderLandlordFruitStorage();
            renderLandlordItemStorage();
            break;
        case 'stats':
            updateLandlordStats();
            break;
    }
}

        // 渲染单个地块
        function renderLandlordField(fieldIndex) {
            const fieldsContainer = document.getElementById('landlordFieldsContainer');
            if (!fieldsContainer) return;
            
            const fieldDiv = fieldsContainer.children[fieldIndex];
            if (!fieldDiv) return;
            
            const plant = player.landlord.fields[fieldIndex];
             const isLocked = player.landlord.lockedFields[fieldIndex];
           if (!plant) {
        fieldDiv.className = `landlord-field empty ${player.landlord.lockedFields[fieldIndex] ? 'locked' : ''}`;
        fieldDiv.innerHTML = `
            <div class="landlord-field-header">
                <div class="landlord-field-status">空闲${player.landlord.lockedFields[fieldIndex] ? ' 🔒' : ''}</div>
                <label class="field-lock-toggle">
                    <input type="checkbox" ${player.landlord.lockedFields[fieldIndex] ? 'checked' : ''} 
                           onchange="toggleFieldLock(${fieldIndex})">
                    <span class="lock-icon">🔒</span>
                </label>
            </div>
            <div style="font-size: 3em; color: rgba(0,0,0,0.1); margin: 20px 0;">+</div>
            <button class="landlord-plant-button" onclick="selectLandlordSeedForPlanting(${fieldIndex})">种植</button>
        `;
            } else {
                const timeLeft = plant.isMature ? 0 : 
                    Math.max(0, Math.ceil(plant.growTime - (Date.now() - plant.plantedAt) / (1000 * 60)));
                
                const progress = plant.isMature ? 100 : 
                    Math.min(100, Math.floor(((Date.now() - plant.plantedAt) / (1000 * 60)) / plant.growTime * 100));
                
                // 突变标签
                let mutationTags = '';
                
                // 基础突变标签
                plant.mutations.forEach(mutation => {
                    const colorClass = getLandlordMutationColorClass(mutation);
                    mutationTags += `<span class="landlord-mutation-tag ${colorClass}">${mutation}</span>`;
                });
                
                // 天气突变标签
                plant.weatherMutations.forEach(mutation => {
                    const colorClass = getLandlordMutationColorClass(mutation);
                    mutationTags += `<span class="landlord-mutation-tag ${colorClass}">${mutation}</span>`;
                });
                
                // 特殊突变标签
                if (plant.specialMutation) {
                    const specialName = specialMutations[plant.type] || '特殊突变';
                    mutationTags += `<span class="landlord-mutation-tag landlord-mutation-rainbow">${specialName}</span>`;
                }
                
                fieldDiv.className = `landlord-field ${player.landlord.lockedFields[fieldIndex] ? 'locked' : ''}`;
                fieldDiv.innerHTML = `
            <div class="landlord-field-header">
                <div class="landlord-field-status">${plant.type}${player.landlord.lockedFields[fieldIndex] ? ' 🔒' : ''}</div>
                <label class="field-lock-toggle">
                    <input type="checkbox" ${player.landlord.lockedFields[fieldIndex] ? 'checked' : ''} 
                           onchange="toggleFieldLock(${fieldIndex})">
                    <span class="lock-icon">🔒</span>
                </label>
            </div>
                    <div class="landlord-plant-info">
                        <div>重量: ${plant.weight.toFixed(2)}kg</div>
                        <div>${plant.isMature ? '已成熟' : `成长中... ${timeLeft}分钟`}</div>
                        ${mutationTags ? `<div class="landlord-mutations-list">${mutationTags}</div>` : ''}
                    </div>
                    <div class="landlord-field-actions">
                        <div class="landlord-action-row">
                            ${plant.isMature ? 
                                `<button class="landlord-harvest-button" onclick="harvestLandlordPlant(${fieldIndex})">收获</button>` : 
                                `<button class="landlord-action-button" style="background: #7f8c8d; color: white;" disabled>${progress}%</button>`
                            }
                            <button class="landlord-remove-button" onclick="removeLandlordPlant(${fieldIndex})">铲除</button>
                        </div>
                        <div class="landlord-action-row">
                            <button class="landlord-item-button" onclick="selectLandlordItemForUsing(${fieldIndex})">使用道具</button>
                        </div>
                    </div>
                `;
                
                // 添加生长进度条
                if (!plant.isMature) {
                    const progressBar = document.createElement('div');
                    progressBar.className = 'landlord-progress-bar';
                    progressBar.style.marginTop = '10px';
                    progressBar.innerHTML = `<div class="landlord-progress-fill" style="width: ${progress}%"></div>`;
                    fieldDiv.querySelector('.landlord-plant-info').appendChild(progressBar);
                }
            }
 if (isLocked) {
        // 为锁定的田地添加额外的装饰元素
        if (!fieldDiv.querySelector('.lock-decoration')) {
            const lockDecoration = document.createElement('div');
            lockDecoration.className = 'lock-decoration';
            lockDecoration.style.position = 'absolute';
            lockDecoration.style.top = '5px';
            lockDecoration.style.right = '5px';
            lockDecoration.style.fontSize = '0.8em';
            lockDecoration.style.color = 'rgba(212, 212, 170, 0.5)';
            lockDecoration.style.zIndex = '1';
            lockDecoration.textContent = '🔒 已锁定';
            fieldDiv.appendChild(lockDecoration);
            
            // 添加角标
            const cornerLock = document.createElement('div');
            cornerLock.className = 'corner-lock';
            cornerLock.style.position = 'absolute';
            cornerLock.style.top = '0';
            cornerLock.style.left = '0';
            cornerLock.style.width = '0';
            cornerLock.style.height = '0';
            cornerLock.style.borderTop = '20px solid #556b2f';
            cornerLock.style.borderRight = '20px solid transparent';
            cornerLock.style.zIndex = '2';
            fieldDiv.appendChild(cornerLock);
            
            const lockIcon = document.createElement('div');
            lockIcon.className = 'corner-lock-icon';
            lockIcon.style.position = 'absolute';
            lockIcon.style.top = '2px';
            lockIcon.style.left = '2px';
            lockIcon.style.color = '#d4d4aa';
            lockIcon.style.fontSize = '0.8em';
            lockIcon.style.zIndex = '3';
            lockIcon.textContent = '🔒';
            fieldDiv.appendChild(lockIcon);
        }
    }
       }

        // 启动定时器（避免每次打开界面重复创建导致定时器泄漏）
        function startLandlordTimers() {
            if (player.landlord._timerId) {
                clearInterval(player.landlord._timerId);
                player.landlord._timerId = null;
            }
            player.landlord._timerId = registerInterval(() => {
                checkLandlordPlantGrowth();
                updateLandlordSeedRefreshTimer();
                updateLandlordItemRefreshTimer();
                updateLandlordWeather();
                
                // 每60秒自动保存一次
                if (Date.now() - (player.landlord.lastSaveTime || 0) > 60000) {
                    saveGame();
                }
            }, 1000);
        }

        // 渲染所有UI
        function renderAllLandlordUI() {
            updateLandlordCoinDisplay();
            renderLandlordStore();
            renderLandlordItemStore();
            renderLandlordFields();
            renderLandlordSeedStorage();
            renderLandlordFruitStorage();
            renderLandlordItemStorage();
            updateLandlordStats();
        }

        // 显示通知
        function showLandlordNotification(message, type) {
            const notificationArea = document.getElementById('landlordNotificationArea');
            if (!notificationArea) return;
            
            const notification = document.createElement('div');
            notification.className = `landlord-notification ${type}`;
            notification.textContent = message;
            notificationArea.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        // 格式化数字
        function formatNumber(num) {
            if (num >= 1e9) {
                return (num / 1e9).toFixed(2) + 'B';
            } else if (num >= 1e6) {
                return (num / 1e6).toFixed(2) + 'M';
            } else if (num >= 1e3) {
                return (num / 1e3).toFixed(2) + 'K';
            }
            return Math.floor(num).toLocaleString();
        }

        // 初始化游戏数据
        function initLandlordGameData() {
            if (!player.landlord) {
                player.landlord = {
                    coins: 0,
                    unlockedFields: 5,
                    fields: Array(50).fill(null),
                    lockedFields: Array(50).fill(false),
                    seedStorage: {},
                    fruitStorage: [],
                    itemStorage: {},
                    storeItems: {},
                    itemStoreItems: {},
                    lastSeedRefreshTime: Date.now(),
                    lastItemRefreshTime: Date.now(),
                    weather: "晴朗",
                    lastWeatherChange: Date.now(),
                    stats: {
                        totalPlants: 0,
                        totalHarvests: 0,
                        totalCoinsEarned: 0,
                        basicMutations: 0,
                        weatherMutations: 0,
                        specialMutations: 0,
                        highestMultiplier: 1,
                        itemsUsed: 0
                    },
                    selectedFieldIndex: null,
                    lastSaveTime: Date.now()
                };
            }
            if (!player.landlord.lockedFields) {
        player.landlord.lockedFields = Array(50).fill(false);
    }
    while (player.landlord.lockedFields.length < player.landlord.unlockedFields) {
        player.landlord.lockedFields.push(false);
    }
            // 确保fields数组长度正确
            while (player.landlord.fields.length < player.landlord.unlockedFields) {
                player.landlord.fields.push(null);
            }
            
            // 确保所有必要的对象都存在
            if (!player.landlord.seedStorage) player.landlord.seedStorage = {};
            if (!player.landlord.fruitStorage) player.landlord.fruitStorage = [];
            if (!player.landlord.itemStorage) player.landlord.itemStorage = {};
            if (!player.landlord.storeItems) player.landlord.storeItems = {};
            if (!player.landlord.itemStoreItems) player.landlord.itemStoreItems = {};
            if (!player.landlord.stats) player.landlord.stats = {
                totalPlants: 0,
                totalHarvests: 0,
                totalCoinsEarned: 0,
                basicMutations: 0,
                weatherMutations: 0,
                specialMutations: 0,
                highestMultiplier: 1,
                itemsUsed: 0
            };
        }

        // 在游戏加载时初始化疯狂地主数据
        function loadLandlordGameData() {
            initLandlordGameData();
            if (player.landlord && player.landlord._timerId != null) {
                delete player.landlord._timerId;
            }
            if (!player.landlord.lockedFields || player.landlord.lockedFields.length < player.landlord.unlockedFields) {
        player.landlord.lockedFields = Array(50).fill(false);
    }
            // 检查离线收益
            checkLandlordOfflineEarnings();
        }

        // 在游戏保存时保存疯狂地主数据
        function saveLandlordGameData() {
            if (player.landlord) {
                player.landlord.lastSaveTime = Date.now();
            }
        }

        // 修改原有的loadGame函数，添加疯狂地主数据加载
        const originalLoadGame = loadGame;
        loadGame = function() {
            originalLoadGame();
            loadLandlordGameData();
        };

        // 修改原有的saveGame函数，添加疯狂地主数据保存（保存前移除定时器 id 避免写入存档）
        const originalSaveGame = saveGame;
        saveGame = function() {
            const landlordTimerId = player.landlord && player.landlord._timerId;
            if (player.landlord && player.landlord.hasOwnProperty('_timerId')) {
                delete player.landlord._timerId;
            }
            saveLandlordGameData();
            originalSaveGame();
            if (player.landlord != null) player.landlord._timerId = landlordTimerId;
        };

        // 在页面加载时初始化疯狂地主游戏
        window.addEventListener('load', function() {
            // 初始化疯狂地主游戏数据
            initLandlordGameData();
            
            // 如果疯狂地主界面是打开的，初始化UI
            if (document.getElementById('landlordUI').style.display === 'block') {
                initLandlordGame();
            }
        });

        // 添加测试数据函数（可选）
        function addTestLandlordData() {
            if (!localStorage.getItem('goldGameSave')) {
                // 添加初始数据
                player.landlord.coins = 10000;
                player.landlord.seedStorage = {
                    "土豆": 5,
                    "牵牛花": 3,
                    "黄瓜": 2
                };
                player.landlord.itemStorage = {
                    "普通浇水器": 2
                };
                
                // 初始化商店
                refreshLandlordStore();
                refreshLandlordItemStore();
            }
        }

        // 在游戏初始化时调用测试数据函数
        addTestLandlordData();

        // 添加一些辅助函数
        function getLandlordMutationColor(mutation) {
            const colorMap = {
                "银": "#c0c0c0",
                "金": "#ffd700", 
                "水晶": "#a7d8de",
                "流光": "#ff6b6b",
                "潮湿": "#87ceeb",
                "颤栗": "#d8bfd8",
                "生机": "#90ee90",
                "覆雪": "#f0f8ff",
                "迷雾": "#d3d3d3",
                "灼热": "#ff4500",
                "沙尘": "#f4a460",
                "结霜": "#b0e0e6",
                "落雷": "#9370db",
                "荧光": "#adff2f",
                "彩虹": "linear-gradient(45deg, #ff0000, #ff9900, #ffff00, #00ff00, #0099ff, #6600ff)",
                "星环": "#8a2be2",
                "瓷化": "#f5f5dc",
                "亮晶晶": "#e6e6fa",
                "红月": "#dc143c",
                "霓虹": "linear-gradient(45deg, #ff00ff, #00ffff, #ffff00)"
            };
            
            return colorMap[mutation] || "#bdc3c7";
        }
function toggleFieldLock(fieldIndex) {
    if (fieldIndex >= player.landlord.unlockedFields) {
        showLandlordNotification("田地未解锁！", "error");
        return;
    }
    
    player.landlord.lockedFields[fieldIndex] = !player.landlord.lockedFields[fieldIndex];
    
    // 更新显示
    renderLandlordFields();
    
    const fieldNumber = fieldIndex + 1;
    showLandlordNotification(`田地${fieldNumber}已${player.landlord.lockedFields[fieldIndex] ? '锁定' : '解锁'}！`, "info");
    saveGame();
    
  updateLockedFieldsCount();
}

// 一键锁定所有田地
function lockAllFields() {
    for (let i = 0; i < player.landlord.unlockedFields; i++) {
        player.landlord.lockedFields[i] = true;
    }
    renderLandlordFields();
    showLandlordNotification("已锁定所有田地！", "success");
    saveGame();
}

// 一键解锁所有田地
function unlockAllFields() {
    for (let i = 0; i < player.landlord.unlockedFields; i++) {
        player.landlord.lockedFields[i] = false;
    }
    renderLandlordFields();
    showLandlordNotification("所有田地已解锁！", "success");
    saveGame();
}
function lockPlantedFields() {
    let lockedCount = 0;
    for (let i = 0; i < player.landlord.unlockedFields; i++) {
        if (player.landlord.fields[i] !== null) {
            player.landlord.lockedFields[i] = true;
            lockedCount++;
        }
    }
    renderLandlordFields();
    showLandlordNotification(`已锁定${lockedCount}块有作物的田地！`, "success");
    saveGame();
}

// 仅锁定成熟作物
function lockMatureFields() {
    let lockedCount = 0;
    for (let i = 0; i < player.landlord.unlockedFields; i++) {
        const plant = player.landlord.fields[i];
        if (plant && plant.isMature) {
            player.landlord.lockedFields[i] = true;
            lockedCount++;
        }
    }
    renderLandlordFields();
    showLandlordNotification(`已锁定${lockedCount}块有成熟作物的田地！`, "success");
    saveGame();
}
        // 添加一个快速收获所有成熟作物的函数
       function harvestAllMatureLandlordPlants() {
    let harvestedCount = 0;
    let totalValue = 0;
    let skippedCount = 0;
    let lockedSkipped = 0;
    let storageFullSkipped = 0;
    
    player.landlord.fields.forEach((plant, index) => {
        if (plant && plant.isMature) {
            // 检查田地是否锁定
            if (player.landlord.lockedFields[index]) {
                lockedSkipped++;
                return; // 跳过锁定的田地
            }
            
            // 检查仓库是否已满
            if (player.landlord.fruitStorage.length >= 200) {
                storageFullSkipped++;
                return;
            }
            
            // 计算价值
            const value = calculateLandlordPlantValue(plant);
            totalValue += value;
            
            // 添加到果实仓库
            const fruit = {
                type: plant.type,
                weight: plant.weight,
                value: value,
                mutations: [...plant.mutations],
                weatherMutations: [...plant.weatherMutations],
                specialMutation: plant.specialMutation,
                harvestedAt: new Date().toLocaleString('zh-CN'),
                harvestedTimestamp: Date.now(),
                isLocked: false
            };
            
            player.landlord.fruitStorage.push(fruit);
            
            // 重新生成植物
            player.landlord.fields[index] = createNewLandlordPlant(plant.type);
            harvestedCount++;
        }
    });
    
    if (harvestedCount > 0) {
        // 更新统计
        player.landlord.stats.totalHarvests += harvestedCount;
        player.landlord.stats.totalCoinsEarned += totalValue;
        
        // 更新显示
        renderLandlordFields();
        renderLandlordFruitStorage();
        updateLandlordStats();
        
        let message = `一键收获了${harvestedCount}个作物，总价值${formatNumber(totalValue)}地主币！`;
        
        if (lockedSkipped > 0 || storageFullSkipped > 0) {
            message += `（已跳过`;
            if (lockedSkipped > 0) {
                message += ` ${lockedSkipped}个锁定的田地`;
            }
            if (storageFullSkipped > 0) {
                if (lockedSkipped > 0) message += '，';
                message += ` ${storageFullSkipped}个因仓库满`;
            }
            message += '）';
        }
        
        showLandlordNotification(message, "success");
        saveGame();
    } else {
        let message = "没有可收获的成熟作物！";
        if (lockedSkipped > 0) {
            message = `有${lockedSkipped}个成熟作物因田地锁定未收获`;
        } else if (storageFullSkipped > 0) {
            message = `有${storageFullSkipped}个成熟作物因仓库已满未收获`;
        }
        showLandlordNotification(message, "info");
    }
}

        // 添加一键收获按钮到界面
     function addHarvestAllButton() {
    const fieldsTab = document.getElementById('landlordFieldsTab');
    if (fieldsTab && !fieldsTab.querySelector('.harvest-controls')) {
        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'harvest-controls';
        controlsDiv.style.marginBottom = '20px';
        controlsDiv.style.padding = '15px';
        controlsDiv.style.background = 'linear-gradient(135deg, #f8f9fa, #e9ecef)';
        controlsDiv.style.borderRadius = '10px';
        controlsDiv.style.border = '2px solid #8f9779';
        controlsDiv.style.boxShadow = '0 4px 12px rgba(85, 107, 47, 0.1)';
        
        controlsDiv.innerHTML = `
            <div style="margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="color: #556b2f; font-size: 1.2em;">🔒</span>
                    <h3 style="margin: 0; color: #2c3e50;">田地锁定管理</h3>
                </div>
                <div style="font-size: 0.9em; color: #5a6f1f; padding-left: 25px;">
                    锁定的田地不会被一键收获，但仍可单独操作
                </div>
            </div>
            
            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                <button class="landlord-action-button harvest-all-button" onclick="harvestAllMatureLandlordPlants()">
                    <span style="font-size: 1.2em; margin-right: 8px;">🚜</span>
                    一键收获（跳过锁定）
                </button>
                
                <div style="flex: 1; min-width: 250px;">
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button class="lock-control-button lock-all-btn" onclick="lockAllFields()" 
                                title="锁定所有田地，防止被一键收获">
                            <span style="margin-right: 5px;">🔒</span>
                            全部锁定
                        </button>
                        <button class="lock-control-button unlock-all-btn" onclick="unlockAllFields()"
                                title="解锁所有田地，允许一键收获">
                            <span style="margin-right: 5px;">🔓</span>
                            全部解锁
                        </button>
                        <button class="lock-control-button lock-planted-btn" onclick="lockPlantedFields()"
                                title="只锁定有作物的田地">
                            <span style="margin-right: 5px;">🌱</span>
                            锁定有作物
                        </button>
                        <button class="lock-control-button lock-mature-btn" onclick="lockMatureFields()"
                                title="只锁定有成熟作物的田地">
                            <span style="margin-right: 5px;">🌾</span>
                            锁定成熟
                        </button>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; align-items: center; justify-content: space-between; 
                        padding: 10px 15px; background: rgba(85, 107, 47, 0.1); 
                        border-radius: 8px; border: 1px solid #8f9779;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="width: 12px; height: 12px; background: #556b2f; border-radius: 2px;"></div>
                    <span style="color: #5a6f1f; font-size: 0.85em;">锁定状态</span>
                </div>
                <div style="text-align: right;">
                    <div style="font-size: 0.85em; color: #6c757d;">已锁定</div>
                    <div style="font-size: 1.4em; font-weight: bold; color: #556b2f;">
                        <span id="lockedFieldsCount">0</span>
                        <span style="font-size: 0.7em; color: #8f9779;"> /∞</span>
                    </div>
                </div>
            </div>
        `;
        
        fieldsTab.insertBefore(controlsDiv, fieldsTab.firstChild);
        
        // 更新锁定计数显示
        updateLockedFieldsCount();
    }
}

// 更新锁定田地计数
function updateLockedFieldsCount() {
    const countElement = document.getElementById('lockedFieldsCount');
    if (countElement) {
        let lockedCount = 0;
        for (let i = 0; i < player.landlord.unlockedFields; i++) {
            if (player.landlord.lockedFields[i]) {
                lockedCount++;
            }
        }
        countElement.textContent = lockedCount;
    }
}

// 在渲染田地后更新计数
const originalRenderLandlordFields = renderLandlordFields;
renderLandlordFields = function() {
    originalRenderLandlordFields();
    updateLockedFieldsCount();
    addHarvestAllButton();
};
   
        // 卖出所有果实
       function sellAllLandlordFruits() {
    if (player.landlord.fruitStorage.length === 0) {
        showLandlordNotification("没有果实可卖出！", "error");
        return;
    }
    
    let totalValue = 0;
    let soldCount = 0;
    let lockedCount = 0;
    let lotteryEarned = 0;
    
    // 从后往前遍历，避免splice导致的索引问题
    for (let i = player.landlord.fruitStorage.length - 1; i >= 0; i--) {
        const fruit = player.landlord.fruitStorage[i];
        if (!fruit.isLocked) {
            totalValue += fruit.value;
            
            // 检查是否获得抽奖次数
            if (isFruitEligibleForLottery(fruit)) {
                lotteryEarned++;
            }
            
            player.landlord.fruitStorage.splice(i, 1);
            soldCount++;
        } else {
            lockedCount++;
        }
    }
    
    if (soldCount > 0) {
        // 增加地主币和抽奖次数
        player.landlord.coins += totalValue;
        player.landlord.lottery.drawCount += lotteryEarned;
        
        // 更新显示
        updateLandlordCoinDisplay();
        renderLandlordFruitStorage();
        updateLotteryDisplay();
        
        let message = `一键卖出${soldCount}个果实，获得${formatNumber(totalValue)}地主币`;
        if (lotteryEarned > 0) {
            message += `，获得${lotteryEarned}次抽奖机会！`;
        }
        if (lockedCount > 0) {
            message += ` (${lockedCount}个已锁定的果实未卖出)`;
        }
        
        showLandlordNotification(message, "success");
        saveGame();
    } else {
        if (lockedCount > 0) {
            showLandlordNotification(`所有${lockedCount}个果实都已锁定，无法卖出！`, "info");
        } else {
            showLandlordNotification("没有果实可卖出！", "error");
        }
    }
}
function drawLottery() {
    if (!player.landlord.lottery.drawCount) {
        player.landlord.lottery.drawCount = 0;
    }
    
    if (player.landlord.lottery.drawCount < lotterySystem.costPerDraw) {
        showLandlordNotification(`抽奖次数不足！需要${lotterySystem.costPerDraw}次抽奖机会`, "error");
        return;
    }
    
    // 消耗抽奖次数
    player.landlord.lottery.drawCount -= lotterySystem.costPerDraw;
    player.landlord.lottery.totalDraws = (player.landlord.lottery.totalDraws || 0) + 1;
    
    // 抽奖逻辑
    const randomValue = Math.random() * 100;
    let cumulativeProbability = 0;
    let wonPrize = null;
    
    for (const prize of lotterySystem.prizePool) {
        cumulativeProbability += prize.probability;
        if (randomValue <= cumulativeProbability) {
            wonPrize = prize;
            break;
        }
    }
    
    // 确保有奖品
    if (!wonPrize) {
        wonPrize = lotterySystem.prizePool[0];
    }
    
    // 记录抽奖结果
    const drawResult = {
        prize: wonPrize.name,
        time: new Date().toLocaleString('zh-CN'),
        timestamp: Date.now()
    };
    
    if (!player.landlord.lottery.drawHistory) {
        player.landlord.lottery.drawHistory = [];
    }
    
    player.landlord.lottery.drawHistory.unshift(drawResult);
    // 只保留最近20条记录
    if (player.landlord.lottery.drawHistory.length > 20) {
        player.landlord.lottery.drawHistory = player.landlord.lottery.drawHistory.slice(0, 20);
    }
    
    // 更新奖品统计
    if (!player.landlord.lottery.prizesWon) {
        player.landlord.lottery.prizesWon = {};
    }
    if (!player.landlord.lottery.prizesWon[wonPrize.name]) {
        player.landlord.lottery.prizesWon[wonPrize.name] = 0;
    }
    player.landlord.lottery.prizesWon[wonPrize.name]++;
    
    // 发放奖品（种子）
    if (!player.landlord.seedStorage) {
        player.landlord.seedStorage = {};
    }
    if (!player.landlord.seedStorage[wonPrize.name]) {
        player.landlord.seedStorage[wonPrize.name] = 0;
    }
    player.landlord.seedStorage[wonPrize.name] += wonPrize.weight;
    
    // 更新显示
    renderLotteryInterface();
    if (typeof renderLandlordSeedStorage === 'function') {
        renderLandlordSeedStorage();
    }
    showLotteryAnimation(wonPrize);
    
    // 记录抽奖时间
    player.landlord.lottery.lastDrawTime = Date.now();
    
    saveGame();
}

// 7. 十连抽功能
function drawTenLottery() {
    const requiredDraws = lotterySystem.costPerDraw * 10;
    
    if (player.landlord.lottery.drawCount < requiredDraws) {
        showLandlordNotification(`抽奖次数不足！需要${requiredDraws}次抽奖机会`, "error");
        return;
    }
    
    let results = {};
    let totalPrizes = 0;
    
    // 执行10次抽奖
    for (let i = 0; i < 10; i++) {
        if (player.landlord.lottery.drawCount < lotterySystem.costPerDraw) break;
        
        player.landlord.lottery.drawCount -= lotterySystem.costPerDraw;
        player.landlord.lottery.totalDraws++;
        
        const randomValue = Math.random() * 100;
        let cumulativeProbability = 0;
        let wonPrize = null;
        
        for (const prize of lotterySystem.prizePool) {
            cumulativeProbability += prize.probability;
            if (randomValue <= cumulativeProbability) {
                wonPrize = prize;
                break;
            }
        }
        
        if (!wonPrize) {
            wonPrize = lotterySystem.prizePool[0];
        }
        
        // 记录结果
        if (!results[wonPrize.name]) {
            results[wonPrize.name] = 0;
        }
        results[wonPrize.name] += wonPrize.weight;
        totalPrizes += wonPrize.weight;
        
        // 发放奖品
        if (!player.landlord.seedStorage[wonPrize.name]) {
            player.landlord.seedStorage[wonPrize.name] = 0;
        }
        player.landlord.seedStorage[wonPrize.name] += wonPrize.weight;
        
        // 更新奖品统计
        if (!player.landlord.lottery.prizesWon[wonPrize.name]) {
            player.landlord.lottery.prizesWon[wonPrize.name] = 0;
        }
        player.landlord.lottery.prizesWon[wonPrize.name] += wonPrize.weight;
        
        // 记录单次抽奖历史
        const drawResult = {
            prize: wonPrize.name,
            time: new Date().toLocaleString('zh-CN'),
            timestamp: Date.now(),
            isTenDraw: true
        };
        player.landlord.lottery.drawHistory.unshift(drawResult);
    }
    
    // 清理历史记录
    if (player.landlord.lottery.drawHistory.length > 20) {
        player.landlord.lottery.drawHistory = player.landlord.lottery.drawHistory.slice(0, 20);
    }
    
    // 更新显示
    updateLotteryDisplay();
    renderLandlordSeedStorage();
    showTenLotteryAnimation(results);
    
    player.landlord.lottery.lastDrawTime = Date.now();
    saveGame();
}

// 8. 抽奖动画效果
function showLotteryAnimation(prize) {
    const animationContainer = document.createElement('div');
    animationContainer.style.position = 'fixed';
    animationContainer.style.top = '50%';
    animationContainer.style.left = '50%';
    animationContainer.style.transform = 'translate(-50%, -50%)';
    animationContainer.style.zIndex = '1000';
    animationContainer.style.pointerEvents = 'none';
    
    const prizeColor = seedProperties[prize.name] ? seedProperties[prize.name].color : '#3498db';
    
    animationContainer.innerHTML = `
        <div style="background: linear-gradient(135deg, ${prizeColor}, #2ecc71); 
                    color: white; padding: 30px; border-radius: 15px; 
                    text-align: center; animation: lotteryWin 1s ease-out;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3); min-width: 200px;">
            <div style="font-size: 3em; margin-bottom: 10px;">🎉</div>
            <div style="font-weight: bold; font-size: 1.5em; margin-bottom: 10px;">抽奖成功！</div>
            <div style="font-size: 1.2em; margin-bottom: 15px;">获得奖品：</div>
            <div style="background: rgba(255,255,255,0.2); padding: 10px; border-radius: 8px; font-size: 1.3em; font-weight: bold;">
                ${prize.name}种子 ×${prize.weight}
            </div>
            <div style="margin-top: 15px; font-size: 0.9em; opacity: 0.9;">
                概率: ${prize.actualProbability}%
            </div>
        </div>
    `;
    
    document.body.appendChild(animationContainer);
    
    setTimeout(() => {
        document.body.removeChild(animationContainer);
    }, 2000);
}

// 9. 十连抽动画效果
function showTenLotteryAnimation(results) {
    const animationContainer = document.createElement('div');
    animationContainer.style.position = 'fixed';
    animationContainer.style.top = '50%';
    animationContainer.style.left = '50%';
    animationContainer.style.transform = 'translate(-50%, -50%)';
    animationContainer.style.zIndex = '1000';
    animationContainer.style.pointerEvents = 'none';
    
    let resultsHTML = '';
    for (const prizeName in results) {
        const count = results[prizeName];
        const prizeColor = seedProperties[prizeName] ? seedProperties[prizeName].color : '#3498db';
        resultsHTML += `
            <div style="display: flex; justify-content: space-between; align-items: center; 
                        padding: 8px; background: rgba(255,255,255,0.1); 
                        border-radius: 5px; margin: 5px 0;">
                <span>${prizeName}</span>
                <span style="font-weight: bold;">×${count}</span>
            </div>
        `;
    }
    
    animationContainer.innerHTML = `
        <div style="background: linear-gradient(135deg, #9b59b6, #e74c3c); 
                    color: white; padding: 25px; border-radius: 15px; 
                    text-align: center; animation: lotteryWin 1.5s ease-out;
                    box-shadow: 0 15px 40px rgba(0,0,0,0.4); max-width: 300px;">
            <div style="font-size: 3em; margin-bottom: 10px;">🎊</div>
            <div style="font-weight: bold; font-size: 1.5em; margin-bottom: 15px;">十连抽奖励！</div>
            <div style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;">
                ${resultsHTML}
            </div>
            <div style="font-size: 0.9em; opacity: 0.9;">
                共计获得 ${Object.keys(results).length} 种奖品
            </div>
        </div>
    `;
    
    document.body.appendChild(animationContainer);
    
    setTimeout(() => {
        document.body.removeChild(animationContainer);
    }, 3000);
}

// 10. 渲染抽奖界面
function renderLotteryInterface() {
    const lotteryContainer = document.getElementById('landlordLotteryContainer');
    if (!lotteryContainer) {
        console.error('抽奖容器未找到！');
        return;
    }
    
    const drawCount = player.landlord.lottery.drawCount || 0;
    const canDrawSingle = drawCount >= lotterySystem.costPerDraw;
    const canDrawTen = drawCount >= lotterySystem.costPerDraw * 10;
    
    lotteryContainer.innerHTML = `
        <div class="lottery-header" style="background: linear-gradient(135deg, #ff6b6b, #feca57); 
                 color: white; padding: 20px; border-radius: 10px; text-align: center; margin-bottom: 20px;">
            <h3 style="margin: 0 0 10px 0; font-size: 1.5em;">🎯 果实抽奖系统</h3>
            <div style="font-size: 0.9em; opacity: 0.9;">
                出售带有【银、金、水晶、流光】词条的果实可获得抽奖机会
            </div>
        </div>
        
        <div class="lottery-stats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px;">
            <div style="background: #34495e; color: white; padding: 15px; border-radius: 8px; text-align: center;">
                <div style="font-size: 1.8em; font-weight: bold; color: #feca57;">${drawCount}</div>
                <div style="font-size: 0.8em;">当前抽奖次数</div>
            </div>
            <div style="background: #2c3e50; color: white; padding: 15px; border-radius: 8px; text-align: center;">
                <div style="font-size: 1.8em; font-weight: bold; color: #1abc9c;">${player.landlord.lottery.totalDraws || 0}</div>
                <div style="font-size: 0.8em;">总抽奖次数</div>
            </div>
            <div style="background: #16a085; color: white; padding: 15px; border-radius: 8px; text-align: center;">
                <div style="font-size: 1.8em; font-weight: bold; color: #fff;">${Object.keys(player.landlord.lottery.prizesWon || {}).length}</div>
                <div style="font-size: 0.8em;">获得奖品种类</div>
            </div>
        </div>
        
        <div class="lottery-actions" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
            <button onclick="drawLottery()" ${canDrawSingle ? '' : 'disabled'} 
                    class="lottery-button single-draw"
                    style="background: ${canDrawSingle ? '#e74c3c' : '#95a5a6'}; 
                           color: white; border: none; padding: 15px; border-radius: 8px; 
                           font-size: 1.1em; font-weight: bold; cursor: pointer; 
                           transition: all 0.3s;">
                <div>🎲 单次抽奖</div>
                <div style="font-size: 0.8em; opacity: 0.9;">消耗${lotterySystem.costPerDraw}次</div>
            </button>
            
            <button onclick="drawTenLottery()" ${canDrawTen ? '' : 'disabled'} 
                    class="lottery-button ten-draw"
                    style="background: ${canDrawTen ? '#9b59b6' : '#95a5a6'}; 
                           color: white; border: none; padding: 15px; border-radius: 8px; 
                           font-size: 1.1em; font-weight: bold; cursor: pointer;
                           transition: all 0.3s;">
                <div>🎊 十连抽</div>
                <div style="font-size: 0.8em; opacity: 0.9;">消耗${lotterySystem.costPerDraw * 10}次</div>
            </button>
        </div>
        
        <div class="prize-pool" style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
            <h4 style="margin: 0 0 15px 0; color: #2c3e50;">🎁 奖品池概率</h4>
            <div class="prize-list">
                ${lotterySystem.prizePool.map(prize => `
                    <div style="display: flex; justify-content: space-between; align-items: center; 
                                padding: 8px 0; border-bottom: 1px solid #eee;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 20px; height: 20px; border-radius: 50%; 
                                      background: ${seedProperties[prize.name]?.color || '#3498db'};"></div>
                            <span style="font-weight: bold;">${prize.name}</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="color: #7f8c8d; font-size: 0.9em;">${prize.probability}%</span>
                            <span style="font-weight: bold; color: #e74c3c;">${prize.actualProbability}%</span>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
        
        <div class="draw-history" style="background: #ecf0f1; padding: 15px; border-radius: 10px;">
            <h4 style="margin: 0 0 10px 0; color: #2c3e50;">📜 最近抽奖记录</h4>
            <div style="max-height: 150px; overflow-y: auto;">
                ${player.landlord.lottery.drawHistory && player.landlord.lottery.drawHistory.length > 0 ? 
                    player.landlord.lottery.drawHistory.slice(0, 5).map(record => `
                        <div style="display: flex; justify-content: space-between; align-items: center; 
                                    padding: 5px 0; font-size: 0.9em; border-bottom: 1px solid #ddd;">
                            <span style="font-weight: bold;">${record.prize}</span>
                            <span style="color: #7f8c8d; font-size: 0.8em;">${record.time}</span>
                        </div>
                    `).join('') : 
                    '<div style="text-align: center; color: #7f8c8d; padding: 20px;">暂无抽奖记录</div>'
                }
            </div>
        </div>
        
        <div style="background: #e8f6f3; padding: 15px; border-radius: 10px; margin-top: 20px; border-left: 4px solid #1abc9c;">
            <h4 style="margin: 0 0 10px 0; color: #16a085;">💡 如何获得抽奖次数</h4>
            <div style="font-size: 0.9em; color: #27ae60;">
                <div>• 出售带有【银、金、水晶、流光】词条的果实</div>
                <div>• 每个符合条件的果实可获得1次抽奖机会</div>
                <div>• 在果实仓库查看可获抽奖次数的果实</div>
            </div>
        </div>
    `;
}

// 11. 更新抽奖显示
function updateLotteryDisplay() {
    const drawCountElement = document.getElementById('lotteryDrawCount');
    if (drawCountElement) {
        drawCountElement.textContent = player.landlord.lottery.drawCount || 0;
    }
}

function isFruitEligibleForLottery(fruit) {
    if (!fruit || !fruit.mutations) return false;
    
    // 检查是否有符合条件的词条
    for (const mutation of lotterySystem.eligibleMutations) {
        if (fruit.mutations.includes(mutation)) {
            return true;
        }
    }
    
    return false;
}

        // 添加一键卖出按钮到界面
        function addSellAllButton() {
            const storageTab = document.getElementById('landlordStorageTab');
            if (storageTab && !storageTab.querySelector('.sell-all-button')) {
                const sellAllButton = document.createElement('button');
                sellAllButton.className = 'landlord-unlock-button';
                sellAllButton.style.marginBottom = '20px';
                sellAllButton.textContent = '一键卖出所有果实';
                sellAllButton.onclick = sellAllLandlordFruits;
                sellAllButton.classList.add('sell-all-button');
                
                const storageContainer = storageTab.querySelector('.landlord-storage-container');
                if (storageContainer) {
                    storageContainer.parentNode.insertBefore(sellAllButton, storageContainer);
                }
            }
        }

        // 在渲染仓库时调用添加按钮函数
        const originalRenderLandlordFruitStorage = renderLandlordFruitStorage;
        renderLandlordFruitStorage = function() {
            originalRenderLandlordFruitStorage();
            addSellAllButton();
        };

        console.log("疯狂地主游戏已成功加载！");
   // 无尽挖矿配置
        const miningGemsConfig = [
        { name: '红宝石', key: 'ruby', rarity: 0.4, minDepth: 0, color: '#ff6b6b' },
        { name: '蓝宝石', key: 'sapphire', rarity: 0.3, minDepth: 10000, color: '#48cae4' },
        { name: '翡翠', key: 'emerald', rarity: 0.2, minDepth: 100000, color: '#52b788' },
        { name: '紫水晶', key: 'amethyst', rarity: 0.08, minDepth: 1000000, color: '#7b2cbf' },
        { name: '钻石', key: 'diamond', rarity: 0.02, minDepth: 10000000, color: '#caf0f8' }
    ];

         // 切换分页函数
        function switchMiningTab(tabName) {
            // 更新标签样式
            document.querySelectorAll('.mining-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`.mining-tab[onclick="switchMiningTab('${tabName}')"]`).classList.add('active');
            
            // 更新页面显示
            document.querySelectorAll('.mining-gems-page, .mining-upgrades-page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(`mining${tabName.charAt(0).toUpperCase() + tabName.slice(1)}Page`).classList.add('active');
        }

        function toggleMiningUI() {
       if (player.reincarnationCount < 1500) {
        alert("需要达到1500转才能开启无尽挖矿！");
        return;
    }
            const ui = document.getElementById('miningUI');
            if (ui.style.display === 'block') {
                ui.style.display = 'none';
            } else {
                ui.style.display = 'block';
                updateMiningUI();
                calculateOfflineMining();
            }
        }

        function getMiningMaxStamina() {
            return player.mining.baseMaxStamina + ((player.mining.staminaUpgradeLevel - 1) * 10);
        }

        function updateMiningUI() {
    const maxStamina = getMiningMaxStamina();
    const staminaPercent = (player.mining.stamina / maxStamina) * 100;
    
    // 更新基础信息
    document.getElementById('miningDepth').textContent = player.mining.depth.toLocaleString() + ' 米';
    document.getElementById('miningPower').textContent = player.mining.power;
    document.getElementById('miningMaxStamina').textContent = maxStamina;
    
    // 更新体力条
    document.getElementById('miningStaminaBar').style.width = staminaPercent + '%';
    document.getElementById('miningStaminaText').textContent = 
        Math.floor(player.mining.stamina) + ' / ' + maxStamina;
    
    // 确保所有宝石属性都存在
    for (let i = 0; i < miningGemsConfig.length; i++) {
        const gem = miningGemsConfig[i];
        if (player.mining.gems[gem.key] === undefined) {
            player.mining.gems[gem.key] = 0;
        }
    }
    
    // 更新宝石数量显示
    document.getElementById('miningRuby').textContent = player.mining.gems.ruby || 0;
    document.getElementById('miningSapphire').textContent = player.mining.gems.sapphire || 0;
    document.getElementById('miningEmerald').textContent = player.mining.gems.emerald || 0;
    document.getElementById('miningAmethyst').textContent = player.mining.gems.amethyst || 0;
    document.getElementById('miningDiamond').textContent = player.mining.gems.diamond || 0;
    document.getElementById('miningOre').textContent = player.mining.ore;
    
    // 更新药水数量
    document.getElementById('miningPotionCount').textContent = player.mining.potions;
    
    // 更新升级信息
    document.getElementById('miningPowerLevel').textContent = player.mining.upgrades.power;
    document.getElementById('miningStaminaLevel').textContent = player.mining.staminaUpgradeLevel;
    document.getElementById('miningDetectorLevel').textContent = player.mining.upgrades.detector;
    
    // 更新按钮状态
    document.getElementById('upgradeMiningPowerBtn').textContent = `升级 (${1000 * player.mining.upgrades.power})`;
    document.getElementById('upgradeMiningStaminaBtn').textContent = `升级 (${10000 * player.mining.staminaUpgradeLevel})`;
    document.getElementById('upgradeMiningDetectorBtn').textContent = `升级 (${50000 * player.mining.upgrades.detector})`;
    
    document.getElementById('upgradeMiningPowerBtn').disabled = player.mining.upgrades.power >= 100;
    document.getElementById('upgradeMiningStaminaBtn').disabled = player.mining.staminaUpgradeLevel >= 10;
    document.getElementById('upgradeMiningDetectorBtn').disabled = player.mining.upgrades.detector >= 10;
    
    // 更新挖矿按钮
    const miningBtn = document.getElementById('miningToggleBtn');
    miningBtn.textContent = player.mining.isMining ? '停止自动挖矿' : '开始自动挖矿';
    miningBtn.style.background = player.mining.isMining ? 
        'linear-gradient(135deg, #ff4757 0%, #ff3742 100%)' : 
        'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
    
    // 更新自动药水按钮
    const autoPotionBtn = document.getElementById('autoPotionToggleBtn');
    autoPotionBtn.textContent = player.mining.autoPotion ? '关闭自动药水' : '开启自动药水';
    autoPotionBtn.style.background = player.mining.autoPotion ? 
        'linear-gradient(135deg, #ff6b6b 0%, #ff4757 100%)' : 
        'linear-gradient(135deg, #48cae4 0%, #0096c7 100%)';
    
    // 更新通知显示
    updateMiningNotifications();
}
      function toggleAutoPotion() {
    player.mining.autoPotion = !player.mining.autoPotion;
    
    // 确保阈值已正确初始化
    if (player.mining.autoPotionThreshold === undefined) {
        player.mining.autoPotionThreshold = 5;
    }
    
    if (player.mining.autoPotion) {
        addMiningNotification('已开启自动药水，体力低于' + player.mining.autoPotionThreshold + '时自动使用药水');
    } else {
        addMiningNotification('已关闭自动药水');
    }
    
    updateMiningUI();
    saveGame();
}
  function checkAutoPotion() {
    if (!player.mining.autoPotion || player.mining.potions === 0) {
        return false;
    }
    
    const maxStamina = getMiningMaxStamina();
    
    // 确保阈值已初始化
    const threshold = player.mining.autoPotionThreshold || 5;
    
    // 检查体力是否低于阈值
    if (player.mining.stamina <= threshold && 
        player.mining.stamina < maxStamina) {
        
        // 使用药水
        player.mining.potions -= 1;
        player.mining.stamina = maxStamina;
        
        addMiningNotification('自动使用体力药水，恢复全部体力！', 'gem');
        return true;
    }
    
    return false;
}
function setAutoPotionThreshold(threshold) {
    if (threshold >= 1 && threshold <= 50) { // 限制阈值范围
        player.mining.autoPotionThreshold = threshold;
        if (player.mining.autoPotion) {
            addMiningNotification(`已设置自动药水阈值为${threshold}点体力`);
        }
        updateMiningUI();
        saveGame();
    }
}
function adjustPotionThreshold() {
    const currentThreshold = player.mining.autoPotionThreshold || 5;
    const newThreshold = prompt(`请输入自动使用药水的体力阈值(1-50)`, currentThreshold);
    
    if (newThreshold !== null) {
        const num = parseInt(newThreshold);
        if (!isNaN(num) && num >= 1 && num <= 50) {
            setAutoPotionThreshold(num);
        } else {
            alert('请输入1到50之间的数字！');
        }
    }
}
        function addMiningNotification(message, type = 'info') {
            const now = new Date();
            const timestamp = now.toLocaleTimeString();
            
            player.mining.notifications.unshift({
                message: message,
                type: type,
                timestamp: timestamp
            });
            
            // 限制通知数量，防止数组无限增长导致内存增长
            if (player.mining.notifications.length > 20) {
                player.mining.notifications.pop();
            }
            
            // 仅当挖矿界面显示时才更新 DOM，避免后台挖矿时频繁操作 DOM 导致卡顿
            const miningUI = document.getElementById('miningUI');
            if (miningUI && miningUI.style.display === 'block') {
                updateMiningNotifications();
            }
        }

        function updateMiningNotifications() {
            const container = document.getElementById('miningNotifications');
            container.innerHTML = '';
            
            player.mining.notifications.forEach(notif => {
                const div = document.createElement('div');
                div.className = 'mining-notification';
                div.style.borderLeftColor = notif.type === 'gem' ? '#4CAF50' : 
                                          notif.type === 'warning' ? '#ff6b6b' : '#4CAF50';
                div.innerHTML = `[${notif.timestamp}] ${notif.message}`;
                container.appendChild(div);
            });
        }

        function clearMiningNotifications() {
            player.mining.notifications = [];
            updateMiningNotifications();
        }

        function toggleMining() {
            player.mining.isMining = !player.mining.isMining;
            
            if (player.mining.isMining) {
                addMiningNotification('开始自动挖矿！');
                // 不在此处创建 setInterval，避免与 initMiningSystem 的定时器重复导致泄漏；由 initMiningSystem 的单一定时器驱动
            } else {
                addMiningNotification('停止自动挖矿！');
            }
            
            updateMiningUI();
            saveGame();
        }function findGem(depth, detectorLevel, isOffline = false) {
        const gemChance = 0.02 + (detectorLevel * 0.005);
        
        // 先检查是否发现宝石
        if (Math.random() < gemChance) {
            const gemRoll = Math.random();
            
            // 检查翡翠属性是否存在
            if (player.mining.gems.emerald === undefined) {
                player.mining.gems.emerald = 0;
            }
            
            // 收集符合条件的宝石
            const availableGems = [];
            let totalRarity = 0;
            
            for (let i = 0; i < miningGemsConfig.length; i++) {
                const gem = miningGemsConfig[i];
                if (depth >= gem.minDepth) {
                    availableGems.push(gem);
                    totalRarity += gem.rarity;
                }
            }
            
            let selectedGem = null;
            if (availableGems.length === 0) {
                selectedGem = miningGemsConfig[0]; // 红宝石
            } else {
                // 使用累积概率选择宝石
                let cumulative = 0;
                for (let i = 0; i < availableGems.length; i++) {
                    const gem = availableGems[i];
                    cumulative += gem.rarity / totalRarity; // 标准化概率
                    if (gemRoll <= cumulative) {
                        selectedGem = gem;
                        break;
                    }
                }
                if (!selectedGem) {
                    selectedGem = availableGems[availableGems.length - 1];
                }
            }
            
            if (selectedGem) {
                if (player.mining.gems[selectedGem.key] === undefined) {
                    player.mining.gems[selectedGem.key] = 0;
                }
                player.mining.gems[selectedGem.key] += 1;
                const prefix = isOffline ? '离线' : '';
                addMiningNotification(`${prefix}发现 ${selectedGem.name}！`, 'gem');
                return true;
            }
        }
        
        return false;
    }


      function mine() {
    if (!player.mining.isMining) return;
    
    // 先检查是否需要自动使用药水
    if (checkAutoPotion()) {
        updateMiningUI();
        saveGame();
    }
    
    // 检查体力
    if (player.mining.stamina < 1) {
        player.mining.isMining = false;
        addMiningNotification('体力不足，自动挖矿停止！请使用体力药水恢复体力。', 'warning');
        updateMiningUI();
        return;
    }
    
    // 消耗体力
    player.mining.stamina -= 1;
    
    // 增加深度
    const depthGain = player.mining.power;
    player.mining.depth += depthGain;
    
    // 获得矿石
    const oreGain = Math.floor(player.mining.power * (0.2 + Math.random() * 0.5));
    player.mining.ore += oreGain;
    
    // 宝石发现逻辑
    const gemFound = findGem(player.mining.depth, player.mining.upgrades.detector, false);
    checkTreasureDrop();
        if (Math.random() < 0.5) {
           dropMagicMaterial();
        }
    // 每挖掘100次自动保存
    if (player.mining.depth % 100 === 0) {
        saveGame();
    }
    
    // 仅当挖矿界面打开时更新 UI，减少后台挖矿时的 DOM 操作与重绘，避免越玩越卡
    const miningUI = document.getElementById('miningUI');
    if (miningUI && miningUI.style.display === 'block') {
        updateMiningUI();
    }
}

        function useMiningPotion() {
            if (player.mining.potions > 0 && player.mining.stamina < getMiningMaxStamina()) {
                player.mining.potions -= 1;
                player.mining.stamina = getMiningMaxStamina();
                addMiningNotification('使用体力药水，恢复全部体力！');
          if (player.mining.autoPotion) {
             addMiningNotification('已自动关闭自动药水功能');
             player.mining.autoPotion = false;
         }
                updateMiningUI();
                saveGame();
            }
        }

        function buyMiningPotion() {
            const cost = 1;
            if (player.items.primaryGemq >= cost) {
                player.items.primaryGemq -= cost;
                player.mining.potions += 1;
                addMiningNotification(`花费${cost}宝藏金币购买1个体力药水`);
                updateMiningUI();
                saveGame();
            } else {
                addMiningNotification('宝藏金币不足，无法购买药水', 'warning');
            }
        }

        function upgradeMiningPower() {
            if (player.mining.upgrades.power >= 100) {
                addMiningNotification('镐头已达到最大等级(100级)！', 'warning');
                return;
            }
            
            const cost = 1000 * player.mining.upgrades.power;
            if (player.mining.ore >= cost) {
                player.mining.ore -= cost;
                player.mining.power += 1;
                player.mining.upgrades.power += 1;
                addMiningNotification(`升级镐头成功！当前等级: ${player.mining.upgrades.power}`);
                updateMiningUI();
                saveGame();
            } else {
                addMiningNotification(`矿石不足，需要${cost}矿石`, 'warning');
            }
        }

        function upgradeMiningStamina() {
            if (player.mining.staminaUpgradeLevel >= 10) {
                addMiningNotification('体力上限已达到最大等级(10级)！', 'warning');
                return;
            }
            
            const cost = 10000 * player.mining.staminaUpgradeLevel;
            if (player.mining.ore >= cost) {
                player.mining.ore -= cost;
                
                // 保存当前体力比例
                const oldMaxStamina = getMiningMaxStamina();
                const staminaRatio = player.mining.stamina / oldMaxStamina;
                
                // 升级
                player.mining.staminaUpgradeLevel += 1;
                const newMaxStamina = getMiningMaxStamina();
                
                // 按比例恢复体力
                player.mining.stamina = Math.floor(newMaxStamina * staminaRatio);
                
                addMiningNotification(`升级体力上限成功！当前等级: ${player.mining.staminaUpgradeLevel}`);
                updateMiningUI();
                saveGame();
            } else {
                addMiningNotification(`矿石不足，需要${cost}矿石`, 'warning');
            }
        }

        function upgradeMiningDetector() {
            if (player.mining.upgrades.detector >= 10) {
                addMiningNotification('宝石探测器已达到最大等级(10级)！', 'warning');
                return;
            }
            
            const cost = 50000 * player.mining.upgrades.detector;
            if (player.mining.ore >= cost) {
                player.mining.ore -= cost;
                player.mining.upgrades.detector += 1;
                addMiningNotification(`升级宝石探测器成功！当前等级: ${player.mining.upgrades.detector}`);
                updateMiningUI();
                saveGame();
            } else {
                addMiningNotification(`矿石不足，需要${cost}矿石`, 'warning');
            }
        }

    function calculateOfflineMining() {
    const now = Date.now();
    const elapsed = Math.min(now - player.mining.lastUpdate, 86400000); // 最多24小时
    
    if (elapsed > 1000 && player.mining.isMining) {
        const seconds = Math.floor(elapsed / 1000);
        const maxStamina = getMiningMaxStamina();
        
        // 计算离线期间可以挖掘的次数
        const possibleMines = Math.min(seconds, player.mining.stamina);
        
        if (possibleMines > 0) {
            let gemsFound = 0;
            let potionsUsed = 0;
            
            console.log(`开始离线挖矿: ${possibleMines}次, 当前深度: ${player.mining.depth}`);
            
            // 模拟离线挖掘
            for (let i = 0; i < possibleMines; i++) {
                // 检查是否需要自动使用药水
                if (player.mining.autoPotion && 
                    player.mining.potions > 0 && 
                    player.mining.stamina <= player.mining.autoPotionThreshold && 
                    player.mining.stamina < maxStamina) {
                    
                    player.mining.potions -= 1;
                    player.mining.stamina = maxStamina;
                    potionsUsed++;
                }
                
                // 检查体力
                if (player.mining.stamina < 1) {
                    break;
                }
                
                // 消耗体力
                player.mining.stamina -= 1;
                
                // 增加深度
                player.mining.depth += player.mining.power;
                
                // 获得矿石
                const oreGain = Math.floor(player.mining.power * (0.2 + Math.random() * 0.5));
                player.mining.ore += oreGain;
                
                // 宝石发现逻辑
                if (findGem(player.mining.depth, player.mining.upgrades.detector, true)) {
                    gemsFound++;
                }
            }
            checkTreasureDrop();
            if (Math.random() < 0.5) {
           dropMagicMaterial();
        }
            console.log(`离线挖矿完成: 发现${gemsFound}个宝石, 使用${potionsUsed}个药水`);
            
            if (possibleMines > 0) {
                let message = `离线期间挖掘了 ${possibleMines} 次，发现 ${gemsFound} 个宝石`;
                if (potionsUsed > 0) {
                    message += `，自动使用了 ${potionsUsed} 个体力药水`;
                }
                addMiningNotification(message);
            }
        }
    }
    
    player.mining.lastUpdate = now;
    updateMiningUI();
}


        // 初始化无尽挖矿系统（只创建一次定时器，避免泄漏）
       function initMiningSystem() {
            if (window.miningInterval) return;
            window.miningInterval = registerInterval(() => {
                if (player.mining && player.mining.isMining) {
                    mine();
                }
            }, 1000);
            // 只注册一次 beforeunload，避免重复监听导致泄漏
            if (!window._miningBeforeUnloadRegistered) {
                window._miningBeforeUnloadRegistered = true;
                window.addEventListener('beforeunload', () => {
                    if (window.miningInterval) {
                        clearInterval(window.miningInterval);
                        window.miningInterval = null;
                    }
                });
            }
        }


        setTimeout(initMiningSystem, 1000);
function initMiningData() {
    if (!player.mining) {
        player.mining = {
            depth: 0,
            power: 1,
            isMining: false,
            ore: 100,
            stamina: 100,
            baseMaxStamina: 100,
            staminaUpgradeLevel: 1,
            potions: 3,
            gems: {
                ruby: 0,
                sapphire: 0,
                emerald: 0,
                amethyst: 0,
                diamond: 0
            },
            upgrades: {
                power: 1,
                detector: 1
            },
            notifications: [],
            lastUpdate: Date.now(),
            // 添加自动药水开关
            autoPotion: false,
            autoPotionThreshold: 5 // 自动使用药水的体力阈值
        };
    }
    
    // 确保所有宝石属性都存在
    for (let i = 0; i < miningGemsConfig.length; i++) {
        const gem = miningGemsConfig[i];
        if (player.mining.gems[gem.key] === undefined) {
            console.log(`初始化宝石属性: ${gem.key}`);
            player.mining.gems[gem.key] = 0;
        }
    }
    
    // 确保自动药水属性存在
    if (player.mining.autoPotion === undefined) {
        player.mining.autoPotion = false;
    }
    if (player.mining.autoPotionThreshold === undefined) {
        player.mining.autoPotionThreshold = 5;
    }
}

// 安全计算涨跌幅，保证返回有限数字，避免 NaN 导致界面显示异常（新号无历史时易出 NaN）
function safeChangePercent(currentPrice, basePrice) {
    const curr = Number(currentPrice);
    const base = Number(basePrice);
    if (base <= 0 || !Number.isFinite(base)) return 0;
    if (!Number.isFinite(curr)) return 0;
    const pct = ((curr - base) / base) * 100;
    return Number.isFinite(pct) ? Math.max(-999, Math.min(999, pct)) : 0;
}

// 检查并修复价格合理性
function validateStockPrices() {
    const game = player.investmentGame;
    if (!game) return;
    
    game.stocks.forEach((stock, index) => {
        const basePrice = Math.max(0.0001, Number(stock.basePrice) || Number(stock.price) || 10);
        if (!Number.isFinite(stock.price) || stock.price <= 0) stock.price = roundInvestmentPrice(basePrice);
        // 确保价格边界存在
        if (!stock.priceBounds) {
            stock.priceBounds = {
                min: 0.1,
                max: 200,
                support: Math.max(0.5, basePrice * 0.5),
                resistance: Math.min(150, basePrice * 1.5)
            };
        }
        
        const bounds = stock.priceBounds;
        
        // 如果价格异常，进行修复
        if (stock.price <= 0) {
            // 价格不能为0或负数
            stock.price = roundInvestmentPrice(bounds.min);
            console.warn(`修复股票 ${stock.code} 的异常价格: ${stock.price} -> ${bounds.min}`);
        }
        
        if (stock.price < bounds.min) {
            // 随机决定是反弹到支撑位还是保持低位
            if (Math.random() < 0.7) {
                stock.price = roundInvestmentPrice(bounds.support);
            }
        }
        
        if (stock.price > bounds.max * 1.5) {
            // 价格过高时回调
            stock.price = roundInvestmentPrice(bounds.resistance);
        }
        
        // 更新涨跌幅（安全计算，避免 NaN）
        stock.change = safeChangePercent(stock.price, basePrice);
    });
}

// 在每次打开游戏界面时调用
function toggleInvestmentGame() {
    if (player.battle.maxStage < 2) {
        alert("需要打怪模式达到第3层才能开启模拟投资！");
        return;
    }
    const ui = document.getElementById('investmentGameUI');
    if (!ui) return;
    if (ui.style.display === 'none') {
        try {
            // 初始化游戏数据
            initInvestmentGame();
            // 检查价格合理性
            validateStockPrices();
            // 模拟离线期间的价格变化
            simulateOfflinePriceChanges();
            // 生成游戏界面
            renderInvestmentGame();
            // 开始价格模拟
            startPriceSimulation();
            ui.style.display = 'block';
        } catch (e) {
            console.error('打开模拟投资异常:', e);
            alert('打开模拟投资时出错: ' + (e && e.message ? e.message : String(e)));
        }
    } else {
        closeInvestmentGame();
    }
}
function simulateOfflinePriceChanges() {
    if (!player.investmentGame || !player.investmentGame.userData) {
        return;
    }
    
    const game = player.investmentGame;
    const now = Date.now();
    
    // 使用单独的离线计时器
    if (!game.offlineData) {
        game.offlineData = {
            lastOfflineUpdate: now
        };
    }
    
    const lastOfflineUpdate = game.offlineData.lastOfflineUpdate || now;
    const timeDiff = now - lastOfflineUpdate;
    const minutesDiff = Math.floor(timeDiff / (1000 * 60));
    
    if (minutesDiff > 0) {
        console.log(`检测到离线 ${minutesDiff} 分钟，模拟价格变化`);
        
        // 初始化价格边界
        game.stocks.forEach(stock => {
            if (!stock.priceBounds) {
                const basePrice = stock.basePrice || 10;
                stock.priceBounds = {
                    min: 0.1,
                    max: 200,
                    support: Math.max(0.5, basePrice * 0.5),
                    resistance: Math.min(150, basePrice * 1.5)
                };
            }
        });
        
        // 每分钟模拟一次价格变化（新号/异常存档需先保证 price、params、bounds 有效，避免 NaN）
        for (let i = 0; i < Math.min(minutesDiff, 1440); i++) { // 最多模拟24小时
            game.stocks.forEach((stock, index) => {
                const basePrice = Math.max(0.0001, Number(stock.basePrice) || Number(stock.price) || 10);
                if (!Number.isFinite(stock.price) || stock.price <= 0) stock.price = roundInvestmentPrice(basePrice);
                const bounds = stock.priceBounds || { min: 0.1, max: 200, support: basePrice * 0.5, resistance: basePrice * 1.5 };
                const safeMin = Math.max(0.0001, bounds.min);
                const safeMax = Math.max(safeMin * 2, bounds.max || 200);
                if (!stock.randomParams) {
                    stock.randomParams = {
                        baseVolatility: 0.005 + Math.random() * 0.025,
                        trendStrength: (Math.random() - 0.5) * 0.002,
                        meanReversion: 0.2 + Math.random() * 0.3,
                        lastChange: 0
                    };
                }
                const params = stock.randomParams;
                const vol = typeof params.baseVolatility === 'number' ? params.baseVolatility : (0.005 + Math.random() * 0.025);
                const trend = typeof params.trendStrength === 'number' ? params.trendStrength : ((Math.random() - 0.5) * 0.002);
                const meanRev = typeof params.meanReversion === 'number' ? params.meanReversion : (0.2 + Math.random() * 0.3);
                const currentPrice = Number(stock.price);
                
                const normalRand = (Math.random() + Math.random() + Math.random() - 1.5) * 2;
                let priceChange = normalRand * vol;
                priceChange += trend;
                const deviation = basePrice > 0 ? (currentPrice - basePrice) / basePrice : 0;
                priceChange += -deviation * meanRev * 0.004;
                const distanceToMin = safeMin > 0 ? (currentPrice - safeMin) / safeMin : 0;
                if (distanceToMin < 0.5 && priceChange < 0) priceChange *= (1 - (0.5 - distanceToMin));
                if (!Number.isFinite(priceChange)) priceChange = 0;
                
                let newPrice = currentPrice * (1 + priceChange);
                if (newPrice < safeMin) {
                    if (Math.random() < 0.6) newPrice = currentPrice * (1 + Math.abs(priceChange) * 0.5);
                    else newPrice = Math.max(safeMin * 0.8, newPrice);
                }
                if (newPrice > safeMax) {
                    if (Math.random() < 0.6) newPrice = currentPrice * (1 - Math.abs(priceChange) * 0.5);
                    else newPrice = Math.min(safeMax * 1.2, newPrice);
                }
                
                stock.price = roundInvestmentPrice((Number.isFinite(newPrice) && newPrice > 0) ? newPrice : currentPrice);
                stock.change = safeChangePercent(stock.price, basePrice);
                
                // 记录历史（只存2位小数）
                params.lastChange = priceChange;
        stock.priceHistory = stock.priceHistory || [];
    stock.priceHistory.push(roundInvestmentPrice(stock.price));
    if (stock.priceHistory.length > 50) {
        stock.priceHistory.shift();
    }
    
    // 同时记录到randomParams中
    if (stock.randomParams) {
        stock.randomParams.priceHistory = stock.randomParams.priceHistory || [];
        stock.randomParams.priceHistory.push(roundInvestmentPrice(stock.price));
        if (stock.randomParams.priceHistory.length > 100) {
            stock.randomParams.priceHistory.shift();
        }
    }
    
    // 清除缓存
    if (stock._changeCache) {
        delete stock._changeCache;
    }
            });
        }
        
        // 更新离线计时器
        game.offlineData.lastOfflineUpdate = now;
        
        // 更新总资产
        updateInvestmentTotalAssets();

        logAction(`离线期间模拟了 ${Math.min(minutesDiff, 1440)} 分钟的价格变化`, 'info');
    }
}
function initPriceHistory() {
    const game = player.investmentGame;
    if (!game) return;
    
    game.stocks.forEach(stock => {
        const basePrice = Math.max(0.0001, Number(stock.basePrice) || Number(stock.price) || 10);
        if (!Number.isFinite(stock.price) || stock.price <= 0) stock.price = roundInvestmentPrice(basePrice);
        // 如果价格历史为空，填充一些初始数据
        if (!stock.priceHistory || stock.priceHistory.length === 0) {
            stock.priceHistory = [roundInvestmentPrice(stock.price)];
            
            // 生成一些模拟历史数据
            let currentPrice = Number(stock.price);
            for (let i = 0; i < 20; i++) {
                const change = (Math.random() - 0.5) * 0.1;
                currentPrice = Math.max(0.1, currentPrice * (1 + change));
                stock.priceHistory.unshift(currentPrice);
            }
            
            // 确保历史数据不超过50个
            if (stock.priceHistory.length > 50) {
                stock.priceHistory = stock.priceHistory.slice(-50);
            }
        }
        
        // 确保randomParams中也有价格历史
        if (!stock.randomParams) {
            stock.randomParams = {};
        }
        if (!stock.randomParams.priceHistory) {
            stock.randomParams.priceHistory = [...stock.priceHistory];
        }
    });
}
function closeInvestmentGame() {
    const ui = document.getElementById('investmentGameUI');
    ui.style.display = 'none';
    
    // 清理定时器
    const game = player.investmentGame;
    if (game.priceUpdateTimer) {
        clearInterval(game.priceUpdateTimer);
        game.priceUpdateTimer = null;
    }
    if (game.chartUpdateTimer) {
        clearInterval(game.chartUpdateTimer);
        game.chartUpdateTimer = null;
    }
    
    // 保存游戏数据
    saveGame();
}

// 渲染模拟投资游戏界面
function renderInvestmentGame() {
    const content = document.getElementById('investmentGameContent');
    const game = player.investmentGame;
    if (game && game.userData) updateInvestmentTotalAssets(); // 渲染前先按当前股价重算总资产，避免显示 NaN
    
    content.innerHTML = `
        <style>
            .investment-game * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            }
            
            .investment-game {
                background-color: #f5f7fa;
                color: #333;
                line-height: 1.6;
                padding: 20px;
                max-width: 1200px;
                margin: 0 auto;
            }
            .investment-game .profit-up {
    color: #10b981;
    font-weight: 600;
}

.investment-game .profit-up:after {
    content: ""; /* 移除默认的箭头 */
}

.investment-game .profit-down {
    color: #ef4444;
    font-weight: 600;
}

.investment-game .profit-down:after {
    content: ""; /* 移除默认的箭头 */
}
.investment-game .clickable {
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.investment-game .clickable:hover {
    background-color: #f0f7ff !important;
}

.investment-game .holding-item:hover {
    background-color: #f8fafc !important;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.investment-game .holding-item.selected {
    background-color: #eff6ff !important;
    border-left: 3px solid #3b82f6;
}
            .investment-game .header {
                text-align: center;
                margin-bottom: 25px;
                padding-bottom: 15px;
                border-bottom: 2px solid #e0e6ef;
                position: relative;
            }
            
            .investment-game h1 {
                color: #2c3e50;
                font-size: 2.2rem;
                margin-bottom: 8px;
            }
            
            .investment-game .subtitle {
                color: #7f8c8d;
                font-size: 1rem;
            }
            
            .investment-game .tabs {
                display: flex;
                background: white;
                border-radius: 12px 12px 0 0;
                overflow: hidden;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
                margin-bottom: 0;
            }
            
            .investment-game .tab {
                flex: 1;
                padding: 18px 5px;
                text-align: center;
                cursor: pointer;
                background: #f8f9fa;
                border-bottom: 3px solid transparent;
                transition: all 0.3s ease;
                font-weight: 600;
                color: #6c757d;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 6px;
            }
            
            .investment-game .tab i {
                font-size: 1.2rem;
            }
            
            .investment-game .tab.active {
                background: white;
                color: #4361ee;
                border-bottom: 3px solid #4361ee;
            }
            
            .investment-game .tab-content {
                display: none;
                background: white;
                padding: 25px;
                border-radius: 0 0 12px 12px;
                box-shadow: 0 6px 15px rgba(0, 0, 0, 0.08);
                min-height: 550px;
            }
            
            .investment-game .tab-content.active {
                display: block;
            }
            
            .investment-game .stock-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 25px;
                padding-bottom: 15px;
                border-bottom: 1px solid #eaeaea;
            }
            
            .investment-game .stock-name {
                font-size: 1.8rem;
                font-weight: 700;
                color: #2c3e50;
            }
            
            .investment-game .stock-price {
                font-size: 2.5rem;
                font-weight: 800;
                color: #10b981;
            }
            
            .investment-game .stock-price.down {
                color: #ef4444;
            }
            
            .investment-game .holdings-info {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                margin-bottom: 25px;
                background: #f8fafc;
                padding: 20px;
                border-radius: 10px;
            }
            
            .investment-game .info-item {
                display: flex;
                justify-content: space-between;
                padding: 10px 0;
                border-bottom: 1px dashed #e2e8f0;
            }
            
            .investment-game .info-item:last-child {
                border-bottom: none;
            }
            
            .investment-game .info-label {
                color: #64748b;
                font-weight: 500;
            }
            
            .investment-game .info-value {
                font-weight: 600;
                color: #334155;
            }
            
            .investment-game .transaction-section {
                margin-top: 30px;
            }
            
            .investment-game .transaction-title {
                font-size: 1.3rem;
                margin-bottom: 20px;
                color: #2c3e50;
                padding-bottom: 10px;
                border-bottom: 2px solid #e0e6ef;
            }
            
            .investment-game .transaction-form {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 25px;
            }
            
            .investment-game .form-group {
                margin-bottom: 20px;
            }
            
            .investment-game .form-label {
                display: block;
                margin-bottom: 8px;
                font-weight: 600;
                color: #475569;
            }
            
            .investment-game .input-group {
                display: flex;
                border: 1px solid #cbd5e1;
                border-radius: 8px;
                overflow: hidden;
            }
            
            .investment-game .input-group input {
                flex: 1;
                border: none;
                padding: 12px 15px;
                font-size: 1rem;
                outline: none;
            }
            
            .investment-game .input-group .unit {
                background: #f1f5f9;
                padding: 12px 15px;
                color: #475569;
                font-weight: 500;
            }
            
            .investment-game .quantity-buttons {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 10px;
            }
            
            .investment-game .qty-btn {
                flex: 1;
                min-width: calc(20% - 8px);
                padding: 10px 5px;
                background: #f1f5f9;
                border: 1px solid #cbd5e1;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 500;
                transition: all 0.2s;
                text-align: center;
            }
            
            .investment-game .qty-btn:hover {
                background: #e2e8f0;
            }
            
            .investment-game .qty-btn.highlight {
                background: #3b82f6;
                color: white;
                border-color: #3b82f6;
            }
            
            .investment-game .transaction-type {
                display: flex;
                gap: 15px;
                margin-top: 10px;
            }
            
            .investment-game .type-option {
                flex: 1;
                text-align: center;
                padding: 12px;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.2s;
            }
            
            .investment-game .type-option.active {
                border-color: #3b82f6;
                background: #eff6ff;
                color: #3b82f6;
            }
            
            .investment-game .type-buy.active {
                border-color: #10b981;
                background: #d1fae5;
                color: #10b981;
            }
            
            .investment-game .type-sell.active {
                border-color: #ef4444;
                background: #fee2e2;
                color: #ef4444;
            }
            
            .investment-game .fee-info {
                background: #fef3c7;
                padding: 12px 15px;
                border-radius: 8px;
                margin: 20px 0;
                color: #92400e;
                font-size: 0.95rem;
            }
            
            .investment-game .chart-container {
                margin-top: 30px;
                border-top: 1px solid #eaeaea;
                padding-top: 25px;
            }
            
            .investment-game .chart-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }
            
            .investment-game .chart-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #2c3e50;
            }
            
            .investment-game .time-filters {
                display: flex;
                gap: 10px;
            }
            
            .investment-game .time-filter {
                padding: 8px 15px;
                background: #f1f5f9;
                border-radius: 20px;
                font-size: 0.9rem;
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .investment-game .time-filter.active {
                background: #3b82f6;
                color: white;
            }
            
            .investment-game .chart-placeholder {
                height: 250px;
                background: #f8fafc;
                border-radius: 10px;
                position: relative;
                overflow: hidden;
                border: 1px solid #e2e8f0;
            }
            
            .investment-game .submit-section {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-top: 25px;
                padding-top: 20px;
                border-top: 1px solid #eaeaea;
            }
            
            .investment-game .trade-count {
                color: #6b7280;
                font-size: 0.95rem;
            }
            
            .investment-game .trade-count span {
                color: #3b82f6;
                font-weight: 600;
            }
            
            .investment-game .btn-submit {
                padding: 14px 40px;
                background: #3b82f6;
                color: white;
                border: none;
                border-radius: 8px;
                font-weight: 600;
                font-size: 1.1rem;
                cursor: pointer;
                transition: all 0.3s;
            }
            
            .investment-game .btn-submit:hover {
                background: #2563eb;
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(37, 99, 235, 0.2);
            }
            
            .investment-game .assets-header {
                background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
                color: white;
                padding: 25px;
                border-radius: 12px;
                margin-bottom: 25px;
            }
            
            .investment-game .assets-stats {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
            }
            
            .investment-game .stat-item {
                background: rgba(255, 255, 255, 0.1);
                padding: 20px;
                border-radius: 10px;
                backdrop-filter: blur(10px);
            }
            
            .investment-game .stat-label {
                font-size: 0.9rem;
                opacity: 0.9;
                margin-bottom: 8px;
            }
            
            .investment-game .stat-value {
                font-size: 1.8rem;
                font-weight: 700;
            }
            
            .investment-game .holdings-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
                border-radius: 10px;
                overflow: hidden;
            }
            
            .investment-game .holdings-table th {
                background: #f8fafc;
                padding: 18px 15px;
                text-align: left;
                color: #475569;
                font-weight: 600;
                border-bottom: 2px solid #e2e8f0;
            }
            
            .investment-game .holdings-table td {
                padding: 18px 15px;
                border-bottom: 1px solid #f1f5f9;
            }
            
            .investment-game .holdings-table tr:hover {
                background: #f8fafc;
            }
            
            .investment-game .stock-code {
                font-weight: 600;
                color: #334155;
            }
            
            .investment-game .profit-up {
                color: #10b981;
                font-weight: 600;
            }
            
            .investment-game .profit-up:after {
                content: " ↑";
            }
            
            .investment-game .profit-down {
                color: #ef4444;
                font-weight: 600;
            }
            
            .investment-game .profit-down:after {
                content: " ↓";
            }
            
            .investment-game .holding-percent {
                color: #3b82f6;
                font-weight: 600;
            }
            
            .investment-game .stocks-table-container {
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
                border: 1px solid #e2e8f0;
            }
            
            .investment-game .stocks-table {
                width: 100%;
                border-collapse: collapse;
            }
            
            .investment-game .stocks-table th {
                background: #f1f5f9;
                padding: 18px 15px;
                text-align: left;
                color: #475569;
                font-weight: 600;
            }
            
            .investment-game .stocks-table td {
                padding: 18px 15px;
                border-bottom: 1px solid #f1f5f9;
            }
            
            .investment-game .stocks-table tr:last-child td {
                border-bottom: none;
            }
            
            .investment-game .stock-item {
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .investment-game .stock-item:hover {
                background: #f8fafc;
            }
            
            .investment-game .stock-item.selected {
                background: #eff6ff;
            }
            
            .investment-game .footer-nav {
                display: flex;
                justify-content: center;
                gap: 30px;
                margin-top: 40px;
                padding-top: 20px;
                border-top: 1px solid #eaeaea;
            }
            
            .investment-game .nav-btn {
                display: flex;
                flex-direction: column;
                align-items: center;
                color: #6b7280;
                text-decoration: none;
                transition: all 0.3s;
                padding: 10px 20px;
                border-radius: 10px;
            }
            
            .investment-game .nav-btn i {
                font-size: 1.5rem;
                margin-bottom: 8px;
            }
            
            .investment-game .nav-btn.active {
                color: #3b82f6;
                background: #eff6ff;
            }
         .investment-game .notification {
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                color: white;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
                display: none;
                z-index: 1000;
                animation: slideIn 0.3s ease;
            }
            
            .investment-game .notification.success {
                background: #10b981;
            }
            
            .investment-game .notification.error {
                background: #ef4444;
            }
            
            .investment-game .notification.info {
                background: #3b82f6;
            }
            
            @keyframes slideIn {
                from {transform: translateX(100%); opacity: 0;}
                to {transform: translateX(0); opacity: 1;}
            }
            
            .investment-game .no-holding {
                text-align: center;
                padding: 40px 20px;
                color: #6b7280;
            }
            
            .investment-game .no-holding i {
                font-size: 3rem;
                margin-bottom: 15px;
                color: #cbd5e1;
            }
            
            @media (max-width: 768px) {
                .investment-game .transaction-form {
                    grid-template-columns: 1fr;
                }
                
                .investment-game .holdings-info {
                    grid-template-columns: 1fr;
                }
                
                .investment-game .assets-stats {
                    grid-template-columns: 1fr;
                }
                
                .investment-game .quantity-buttons {
                    justify-content: center;
                }
                
                .investment-game .qty-btn {
                    min-width: calc(33% - 8px);
                }
            }
        </style>
        
        <div class="investment-game">
            <div class="header">
                <h1>模拟投资交易游戏</h1>
                <p class="subtitle">虚拟交易 | 离线模拟 | 刺激体验</p>
            </div>
            
            <!-- 标签页导航 -->
            <div class="tabs">
                <div class="tab active" data-tab="trade">
                    <i class="fas fa-chart-line"></i>
                    <span>股票交易</span>
                </div>
                <div class="tab" data-tab="assets">
                    <i class="fas fa-chart-pie"></i>
                    <span>资产详情</span>
                </div>
                <div class="tab" data-tab="stocks">
                    <i class="fas fa-list"></i>
                    <span>股票列表</span>
                </div>
            </div>
            
            <!-- 股票交易界面 -->
            <div id="trade" class="tab-content active">
                <div class="stock-header">
                    <div>
                        <div class="stock-name" id="current-stock-name">${game.stocks[game.currentStockIndex].name}</div>
                        <div class="stock-update" id="update-time">股价上次更新时间：${new Date().toLocaleString()}</div>
                    </div>
                    <div class="stock-price" id="current-price">${(function(){ var p = game.stocks[game.currentStockIndex].price; return Number.isFinite(Number(p)) ? Number(p).toFixed(3) : '0.000'; })()}</div>
                </div>
                
                <div class="holdings-info">
                    <div>
                        <div class="info-item">
                            <span class="info-label">当前持有数量：</span>
                            <span class="info-value" id="hold-amount">${(function(){ var h = game.stocks[game.currentStockIndex].holdings; return Number.isFinite(Number(h)) ? Number(h).toLocaleString() : '0'; })()}</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">成本价格：</span>
                            <span class="info-value" id="cost-price">${(function(){ var c = game.stocks[game.currentStockIndex].costPrice; return c > 0 && Number.isFinite(Number(c)) ? Number(c).toFixed(3) : "0.000"; })()}</span>
                        </div>
                    </div>
                    <div>
                        <div class="info-item">
                            <span class="info-label">持仓市值：</span>
                            <span class="info-value" id="hold-value">${(function(){ var s = game.stocks[game.currentStockIndex]; var v = Number(s.holdings) * Number(s.price); return Number.isFinite(v) ? v.toLocaleString(undefined, {minimumFractionDigits: 3, maximumFractionDigits: 3}) : '0.000'; })()}</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">持仓盈亏：</span>
                            <span class="info-value" id="hold-profit">${calculateStockProfit(game.stocks[game.currentStockIndex])}</span>
                        </div>
                    </div>
                </div>
                
                <div class="transaction-section">
                    <h3 class="transaction-title">股票交易</h3>
                    
                    <div class="transaction-form">
                        <div>
                            <div class="form-group">
                                <label class="form-label">交易数量：</label>
                                <div class="input-group">
                                    <input type="number" id="trade-quantity" value="0" min="0">
                                    <div class="unit">股</div>
                                </div>
                                
                                <div class="quantity-buttons">
                                    <div class="qty-btn" data-action="0">清零</div>
                                    <div class="qty-btn" data-action="1">+1</div>
                                    <div class="qty-btn" data-action="10">+10</div>
                                    <div class="qty-btn" data-action="100">+100</div>
                                    <div class="qty-btn" data-action="max">最大</div>
                                    <div class="qty-btn" data-action="quarter">1/4仓</div>
                                    <div class="qty-btn" data-action="half">半仓</div>
                                    <div class="qty-btn" data-action="third">1/3仓</div>
                                    <div class="qty-btn" data-action="-1">-1</div>
                                    <div class="qty-btn" data-action="-10">-10</div>
                                    <div class="qty-btn" data-action="-100">-100</div>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">交易类型：</label>
                                <div class="transaction-type">
                                    <div class="type-option type-buy active" data-type="buy">买入</div>
                                    <div class="type-option type-sell" data-type="sell">卖出</div>
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <div class="form-group">
                                <label class="form-label">交易金额：</label>
                                <div class="input-group">
                                    <input type="text" id="trade-amount" value="0.00" readonly>
                                    <div class="unit">元</div>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">交易手续费：</label>
                                <div class="input-group">
                                    <input type="text" id="trade-fee" value="0.00" readonly>
                                    <div class="unit">元</div>
                                </div>
                            </div>
                            
                            <div class="fee-info">
                                交易手续费为交易资金的0.48%!本次将扣除——
                            </div>
                            
                            <div class="form-group">
                                <label class="form-label">最大可交易数量：</label>
                                <div class="input-group">
                                    <input type="text" id="max-quantity" value="0" readonly>
                                    <div class="unit">股</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
<div class="chart-container">
    <div class="chart-header">
        <div>
            <div class="chart-title">
                <i class="fas fa-chart-line"></i>
                价格走势图
            </div>
            <div class="price-range-info">
                <div class="price-range-item">
                    <span class="price-range-label">最高：</span>
                    <span class="price-range-value" id="chart-max-price">--</span>
                </div>
                <div class="price-range-item">
                    <span class="price-range-label">最低：</span>
                    <span class="price-range-value" id="chart-min-price">--</span>
                </div>
                <div class="price-range-item">
                    <span class="price-range-label">波动：</span>
                    <span class="price-range-value" id="chart-range">--</span>
                </div>
            </div>
        </div>
        <div class="time-filters">
            <div class="time-filter" id="refresh-chart-btn" title="刷新图表">
                <i class="fas fa-redo">点击刷新图表</i>
            </div>
        </div>
    </div>
    
    <div class="chart-placeholder" id="price-chart">
        <!-- 图表将通过JS动态生成 -->
    </div>
</div>
                    
                    <div class="submit-section">
                        <div class="trade-count">可用交易次数：<span id="trade-count">${game.userData.tradeCount}</span> 
                            <a href="#" id="add-trade-count" style="color: #3b82f6; text-decoration: none;">点我增加</a>
                        </div>
                        <button class="btn-submit" id="submit-trade">提交交易</button>
                    </div>
                </div>
            </div>
            
            <!-- 资产详情界面 -->
<div id="assets" class="tab-content">
    <div class="assets-header">
        <h2 style="margin-bottom: 20px;">资产详情</h2>
        <div class="assets-stats">
            <div class="stat-item">
                <div class="stat-label">可用资金</div>
                <div class="stat-value" id="available-funds">${(Number.isFinite(Number(game.userData.availableFunds)) ? Number(game.userData.availableFunds) : 0).toLocaleString(undefined, {minimumFractionDigits: 3, maximumFractionDigits: 3})}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">总资产</div>
                <div class="stat-value" id="total-assets">${(Number.isFinite(Number(game.userData.totalAssets)) ? Number(game.userData.totalAssets) : 0).toLocaleString(undefined, {minimumFractionDigits: 3, maximumFractionDigits: 3})}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">总持仓价值</div>
                <div class="stat-value" id="total-hold-value">${(Number.isFinite(calculateTotalHoldingsValue()) ? calculateTotalHoldingsValue() : 0).toLocaleString(undefined, {minimumFractionDigits: 3, maximumFractionDigits: 3})}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">总持仓占比</div>
                <div class="stat-value" id="total-holding-percent">${(Number.isFinite(Number(game.userData.holdingPercent)) ? Number(game.userData.holdingPercent) : 0).toFixed(3)}%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">总盈亏金额</div>
                <div class="stat-value" id="total-profit-amount">${(Number.isFinite(calculateTotalProfitAmount()) ? calculateTotalProfitAmount() : 0).toLocaleString(undefined, {minimumFractionDigits: 3, maximumFractionDigits: 3})}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">总盈亏比例</div>
                <div class="stat-value" id="total-profit-percent">${calculateTotalProfitPercent()}%</div>
            </div>
        </div>
    </div>
    
    <h3 style="margin-bottom: 15px; color: #2c3e50;">持仓详情 <span style="font-size: 0.8rem; color: #6b7280; font-weight: normal;">（点击任意持仓股票可快速切换到交易页面）</span></h3>
    
    <table class="holdings-table" id="holdings-table">
        <thead>
            <tr>
                <th>股票代码</th>
                <th>股票名称</th>
                <th>持股数量</th>
                <th>当前价格</th>
                <th>成本价格</th>
                <th>总市值</th>
                <th>盈亏金额</th>
                <th>盈亏比例</th>
                <th>持仓占比</th>
            </tr>
        </thead>
        <tbody id="holdings-body">
            ${generateHoldingsTable()}
        </tbody>
    </table>
    
    <div id="no-holdings" class="no-holding" style="${hasHoldings() ? 'display: none;' : ''}">
        <i class="fas fa-chart-line"></i>
        <h3>暂无持仓</h3>
        <p>您还没有持有任何股票，快去交易页面买入股票吧！</p>
    </div>
</div>
            
            <!-- 股票列表界面 -->
            <div id="stocks" class="tab-content">
                <h2 style="font-size: 1.8rem; margin-bottom: 25px; color: #2c3e50; text-align: center;">股票列表</h2>
                
                <div class="stocks-table-container">
                    <table class="stocks-table">
                        <thead>
                            <tr>
                                <th>股票代码</th>
                                <th>股票名称</th>
                                <th>当前价格</th>
                                <th>涨跌幅</th>
                            </tr>
                        </thead>
                        <tbody id="stocks-list">
                            ${generateStocksList()}
                        </tbody>
                    </table>
                </div>
                
                <div class="footer-nav">
                    <a href="#" class="nav-btn" data-nav="trade">
                        <i class="fas fa-chart-line"></i>
                        <span>股票交易</span>
                    </a>
                    <a href="#" class="nav-btn" data-nav="assets">
                        <i class="fas fa-chart-pie"></i>
                        <span>资产详情</span>
                    </a>
                </div>
            </div>
            
            <!-- 交易成功提示 -->
            <div class="notification" id="investment-notification"></div>
        </div>
    `;
    
    // 初始化事件监听
    initInvestmentEventListeners();
    // 初始化价格图表
    initInvestmentChart();
    // 更新交易信息
    updateInvestmentTradeInfo();
}

// 计算单只股票的盈亏
function calculateStockProfit(stock) {
    const safe = (v, d) => (v != null && Number.isFinite(Number(v)) ? Number(v) : (d || 0));
    const price = safe(stock.price, 10);
    const costPrice = safe(stock.costPrice, 0);
    const holdings = safe(stock.holdings, 0);
    if (costPrice <= 0 || holdings <= 0) return "0.000 (0.000%)";
    const profit = (price - costPrice) * holdings;
    const profitPercent = safeChangePercent(price, costPrice);
    return `${profit >= 0 ? '+' : ''}${(Number.isFinite(profit) ? profit : 0).toFixed(3)} (${profitPercent >= 0 ? '+' : ''}${(Number.isFinite(profitPercent) ? profitPercent : 0).toFixed(3)}%)`;
}

// 计算总持仓价值
function calculateTotalHoldingsValue() {
    const game = player.investmentGame;
    if (!game) return 0;
    const safe = (v, d) => (v != null && Number.isFinite(Number(v)) ? Number(v) : (d || 0));
    return game.stocks.reduce((sum, stock) => {
        const price = safe(stock.price, 10);
        const holdings = safe(stock.holdings, 0);
        return sum + (holdings * price);
    }, 0);
}
function calculateTotalProfitAmount() {
    const game = player.investmentGame;
    if (!game) return 0;
    let totalProfit = 0;
    const safe = (v, d) => (v != null && Number.isFinite(Number(v)) ? Number(v) : (d || 0));
    game.stocks.forEach(stock => {
        const holdings = safe(stock.holdings, 0);
        const costPrice = safe(stock.costPrice, 0);
        const price = safe(stock.price, 10);
        if (holdings > 0 && costPrice > 0) {
            const profit = (price - costPrice) * holdings;
            if (Number.isFinite(profit)) totalProfit += profit;
        }
    });
    return totalProfit;
}
// 更新图表价格范围显示
function updateChartPriceRange(data) {
    if (!data || data.length === 0) return;
    
    const minPrice = Math.min(...data);
    const maxPrice = Math.max(...data);
    const range = maxPrice - minPrice;
    const rangePercent = (range / minPrice * 100).toFixed(3);
    
    const maxElement = document.getElementById('chart-max-price');
    const minElement = document.getElementById('chart-min-price');
    const rangeElement = document.getElementById('chart-range');
    
    if (maxElement) maxElement.textContent = maxPrice.toFixed(3);
    if (minElement) minElement.textContent = minPrice.toFixed(3);
    if (rangeElement) rangeElement.textContent = `${range.toFixed(3)} (${rangePercent}%)`;
}
// 计算总盈亏比例（防护 NaN）
function calculateTotalProfitPercent() {
    const game = player.investmentGame;
    if (!game) return "0.000";
    let totalCost = 0;
    let totalValue = 0;
    const safe = (v, d) => (v != null && Number.isFinite(Number(v)) ? Number(v) : (d || 0));
    game.stocks.forEach(stock => {
        const h = safe(stock.holdings, 0), c = safe(stock.costPrice, 0), p = safe(stock.price, 10);
        if (h > 0 && c > 0) {
            totalCost += h * c;
            totalValue += h * p;
        }
    });
    if (totalCost <= 0 || !Number.isFinite(totalValue)) return "0.000";
    const profitPercent = ((totalValue - totalCost) / totalCost * 100);
    return Number.isFinite(profitPercent) ? `${profitPercent >= 0 ? '+' : ''}${profitPercent.toFixed(3)}` : "0.000";
}
// 生成持仓表格
function generateHoldingsTable() {
    const game = player.investmentGame;
    const holdings = game.stocks.filter(stock => stock.holdings > 0);
    const currentStock = game.stocks[game.currentStockIndex];
    
    if (holdings.length === 0) {
        return '';
    }
    
    const totalHoldingsValue = calculateTotalHoldingsValue();
    
    const safe = (v, d) => (v != null && Number.isFinite(Number(v)) ? Number(v) : (d || 0));
    const safeTotal = Number.isFinite(totalHoldingsValue) && totalHoldingsValue > 0 ? totalHoldingsValue : 1;
    
    return holdings.map(stock => {
        const price = safe(stock.price, 10);
        const costPrice = safe(stock.costPrice, 0);
        const h = safe(stock.holdings, 0);
        const holdValue = h * price;
        const profitAmount = costPrice > 0 ? (price - costPrice) * h : 0;
        const profitPercent = costPrice > 0 ? safeChangePercent(price, costPrice) : 0;
        const holdingPercent = holdValue / safeTotal * 100;
        const isSelected = stock.code === currentStock.code;
        
        return `
            <tr class="holding-item clickable ${isSelected ? 'selected' : ''}" data-code="${stock.code}">
                <td class="stock-code">${stock.code}</td>
                <td>${stock.name}</td>
                <td>${h.toLocaleString()}</td>
                <td>${price.toFixed(3)}</td>
                <td>${costPrice > 0 ? costPrice.toFixed(3) : "0.000"}</td>
                <td>${(Number.isFinite(holdValue) ? holdValue : 0).toLocaleString(undefined, {minimumFractionDigits: 3, maximumFractionDigits: 3})}</td>
                <td class="${profitAmount >= 0 ? 'profit-up' : 'profit-down'}">
                    ${profitAmount >= 0 ? '+' : ''}${(Number.isFinite(profitAmount) ? profitAmount : 0).toFixed(3)}
                </td>
                <td class="${profitPercent >= 0 ? 'profit-up' : 'profit-down'}">
                    ${profitPercent >= 0 ? '+' : ''}${(Number.isFinite(profitPercent) ? profitPercent : 0).toFixed(3)}%
                </td>
                <td class="holding-percent">${(Number.isFinite(holdingPercent) ? holdingPercent : 0).toFixed(3)}%</td>
            </tr>
        `;
    }).join('');
}

// 检查是否有持仓
function hasHoldings() {
    const game = player.investmentGame;
    return game.stocks.some(stock => stock.holdings > 0);
}

// 生成股票列表
function generateStocksList() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    
    return game.stocks.map(stock => {
        const recentChange = calculateRecentPriceChange(stock);
        const safeChange = Number.isFinite(recentChange) ? Math.max(-999, Math.min(999, recentChange)) : 0;
        stock.change = safeChange;
        
        const isSelected = stock.code === currentStock.code;
        const price = Number(stock.price);
        const priceStr = Number.isFinite(price) ? price.toFixed(3) : '0.000';
        
        return `
            <tr class="stock-item ${isSelected ? 'selected' : ''}" data-code="${stock.code}">
                <td class="stock-code">${stock.code}</td>
                <td>${stock.name}</td>
                <td>${priceStr}</td>
                <td class="${safeChange >= 0 ? 'profit-up' : 'profit-down'}">
                    ${safeChange >= 0 ? '+' : ''}${safeChange.toFixed(3)}%
                </td>
            </tr>
        `;
    }).join('');
}
function calculateRecentPriceChange(stock) {
    const priceHistory = stock.priceHistory || [];
    const historyLength = priceHistory.length;
    
    if (historyLength < 2) {
        // 新号无历史数据，用 basePrice 算涨跌幅，并保证不返回 NaN
        const basePrice = Math.max(0.0001, Number(stock.basePrice) || Number(stock.price) || 10);
        const price = Number(stock.price);
        return safeChangePercent(Number.isFinite(price) ? price : basePrice, basePrice);
    }
    
    const currentPrice = priceHistory[historyLength - 1];
    const lookbackPeriods = Math.min(10, historyLength - 1);
    const previousPrice = priceHistory[historyLength - 1 - lookbackPeriods];
    
    if (previousPrice <= 0 || !Number.isFinite(previousPrice) || !Number.isFinite(currentPrice)) {
        return 0;
    }
    
    return safeChangePercent(currentPrice, previousPrice);
}
function calculateChangeFromArray(priceArray) {
    const length = priceArray.length;
    const lookback = Math.min(10, length - 1);
    
    if (lookback < 1) return 0;
    
    let totalChange = 0;
    let changes = [];
    
    // 收集最近的变化
    for (let i = length - 1; i >= length - lookback; i--) {
        if (i > 0 && priceArray[i-1] > 0) {
            const change = ((priceArray[i] - priceArray[i-1]) / priceArray[i-1]) * 100;
            changes.push(change);
        }
    }
    
    if (changes.length === 0) return 0;
    
    // 计算总变化（不是平均值）
    totalChange = changes.reduce((sum, change) => sum + change, 0);
    
    // 可选：对近期变化给予更高权重
    if (changes.length >= 3) {
        const weights = [1.5, 1.3, 1.1, 1, 1, 1, 1, 1, 1, 1];
        totalChange = 0;
        for (let i = 0; i < Math.min(changes.length, 10); i++) {
            totalChange += changes[i] * (weights[i] || 1);
        }
        // 归一化
        totalChange = totalChange / changes.length;
    }
    
    return totalChange;
}
function getRecentPriceChange(stock) {
    // 创建缓存
    if (!stock._changeCache) {
        stock._changeCache = {
            value: 0,
            timestamp: 0,
            cacheDuration: 60000 // 缓存1分钟
        };
    }
    
    const cache = stock._changeCache;
    const now = Date.now();
    
    // 如果缓存有效且未过期，直接返回缓存值（保证不返回 NaN）
    if (now - cache.timestamp < cache.cacheDuration) {
        return Number.isFinite(cache.value) ? cache.value : 0;
    }
    
    // 重新计算涨跌幅
    const recentChange = calculateRecentPriceChange(stock);
    const safe = Number.isFinite(recentChange) ? recentChange : 0;
    
    cache.value = safe;
    cache.timestamp = now;
    
    return safe;
}
// 初始化投资游戏事件监听
function initInvestmentEventListeners() {
    const game = player.investmentGame;
    
    // 标签页切换
    document.querySelectorAll('.investment-game .tab').forEach(tab => {
        tab.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');
            
            // 更新活跃标签
            document.querySelectorAll('.investment-game .tab').forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            // 更新活跃内容
            document.querySelectorAll('.investment-game .tab-content').forEach(content => {
                content.classList.remove('active');
                if (content.id === tabId) {
                    content.classList.add('active');
                }
            });
            
            // 更新底部导航
            document.querySelectorAll('.investment-game .nav-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-nav') === tabId) {
                    btn.classList.add('active');
                }
            });
        });
    });
    
    // 底部导航点击
    document.querySelectorAll('.investment-game .nav-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            const tabId = this.getAttribute('data-nav');
            const targetTab = document.querySelector(`.investment-game .tab[data-tab="${tabId}"]`);
            if (targetTab) {
                targetTab.click();
            }
        });
    });
    
    // 交易数量按钮
    document.querySelectorAll('.investment-game .qty-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const action = this.getAttribute('data-action');
            updateInvestmentTradeQuantity(action);
        });
    });
    
    // 交易类型切换
    document.querySelectorAll('.investment-game .type-option').forEach(option => {
        option.addEventListener('click', function() {
            document.querySelectorAll('.investment-game .type-option').forEach(opt => {
                opt.classList.remove('active');
            });
            this.classList.add('active');
            game.tradeData.type = this.getAttribute('data-type');
            updateInvestmentTradeInfo();
        });
    });
    
    // 交易数量输入
    const quantityInput = document.getElementById('trade-quantity');
    if (quantityInput) {
        quantityInput.addEventListener('input', updateInvestmentTradeInfo);
        quantityInput.addEventListener('change', updateInvestmentTradeInfo);
    }
    
    // 增加交易次数按钮
    const addTradeCountBtn = document.getElementById('add-trade-count');
    if (addTradeCountBtn) {
        addTradeCountBtn.addEventListener('click', function(e) {
            e.preventDefault();
            game.userData.tradeCount += 5;
            document.getElementById('trade-count').textContent = game.userData.tradeCount;
            showInvestmentNotification('交易次数已增加5次！', 'success');
            saveGame();
        });
    }
    
    // 提交交易按钮
    const submitBtn = document.getElementById('submit-trade');
    if (submitBtn) {
        submitBtn.addEventListener('click', submitInvestmentTrade);
    }
    
    // 时间过滤器
    document.querySelectorAll('.investment-game .time-filter').forEach(filter => {
    filter.addEventListener('click', function() {
        document.querySelectorAll('.investment-game .time-filter').forEach(f => {
            f.classList.remove('active');
        });
        this.classList.add('active');
        updateInvestmentChartFromCache(100); // 固定使用100个点
    });
});
    
    // 持仓行点击事件处理（使用事件委托）
    document.addEventListener('click', function(e) {
        // 检查是否点击了持仓行
        const holdingRow = e.target.closest('.holding-item.clickable');
        if (holdingRow) {
            e.preventDefault();
            const stockCode = holdingRow.getAttribute('data-code');
            const game = player.investmentGame;
            const stockIndex = game.stocks.findIndex(s => s.code === stockCode);
            
            if (stockIndex >= 0) {
                game.currentStockIndex = stockIndex;
                
                // 切换到交易标签页
                const tradeTab = document.querySelector('.investment-game .tab[data-tab="trade"]');
                if (tradeTab) {
                    tradeTab.click();
                }
                
                // 更新显示
                updateInvestmentStockDisplay();
                updateInvestmentTradeInfo();
                updateInvestmentHoldingsInfo();
                showInvestmentNotification(`已切换到持仓股票: ${game.stocks[stockIndex].name}`, 'info');
            }
        }
        
        // 检查是否点击了股票列表行
        const stockRow = e.target.closest('.stock-item');
        if (stockRow) {
            e.preventDefault();
            const stockCode = stockRow.getAttribute('data-code');
            const game = player.investmentGame;
            const stockIndex = game.stocks.findIndex(s => s.code === stockCode);
            
            if (stockIndex >= 0) {
                game.currentStockIndex = stockIndex;
                
                // 切换到交易标签页
                const tradeTab = document.querySelector('.investment-game .tab[data-tab="trade"]');
                if (tradeTab) {
                    tradeTab.click();
                }
                
                // 更新显示
                updateInvestmentStockDisplay();
                updateInvestmentTradeInfo();
                updateInvestmentHoldingsInfo();
                showInvestmentNotification(`已切换到股票: ${game.stocks[stockIndex].name}`, 'info');
            }
        }
    });
}
function cleanInvestmentChartCache() {
    const game = player.investmentGame;
    const cacheKeys = Object.keys(game.chartHistoryCache);
    const now = Date.now();
    
    // 只保留最近30分钟的数据
    for (const key of cacheKeys) {
        // 简单实现：如果缓存条目超过100条，删除最旧的
        if (cacheKeys.length > 100) {
            delete game.chartHistoryCache[key];
        }
    }
}
// 更新股票显示
function updateInvestmentStockDisplay() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    const safePrice = Number.isFinite(Number(currentStock.price)) ? Number(currentStock.price) : (currentStock.basePrice || 10);
    const safeChange = Number.isFinite(Number(currentStock.change)) ? Number(currentStock.change) : 0;
    
    document.getElementById('current-stock-name').textContent = currentStock.name;
    document.getElementById('current-price').textContent = safePrice.toFixed(3);
    
    // 根据涨跌设置颜色（使用安全值，避免 NaN 导致样式错乱）
    const priceElement = document.getElementById('current-price');
    if (safeChange >= 0) {
        priceElement.className = 'stock-price';
    } else {
        priceElement.className = 'stock-price down';
    }
    
    // 更新时间显示
    document.getElementById('update-time').textContent = `股价上次更新时间：${new Date().toLocaleString()}`;
    
    // 高亮当前选中的股票行
    // 在股票列表页高亮
    document.querySelectorAll('.stock-item').forEach(row => {
        row.classList.remove('selected');
        if (row.getAttribute('data-code') === currentStock.code) {
            row.classList.add('selected');
        }
    });
    
    // 在持仓列表高亮
    document.querySelectorAll('.holding-item').forEach(row => {
        row.classList.remove('selected');
        if (row.getAttribute('data-code') === currentStock.code) {
            row.classList.add('selected');
        }
    });
}

// 更新交易数量
function updateInvestmentTradeQuantity(action) {
    const quantityInput = document.getElementById('trade-quantity');
    let quantity = parseInt(quantityInput.value) || 0;
    const maxQuantity = calculateInvestmentMaxQuantity();
    
    switch(action) {
        case '0':
            quantity = 0;
            break;
        case 'max':
            quantity = maxQuantity;
            break;
        case 'quarter':
            quantity = Math.floor(maxQuantity / 4);
            break;
        case 'half':
            quantity = Math.floor(maxQuantity / 2);
            break;
        case 'third':
            quantity = Math.floor(maxQuantity / 3);
            break;
        default:
            quantity += parseInt(action);
            if (quantity < 0) quantity = 0;
            if (quantity > maxQuantity) quantity = maxQuantity;
            break;
    }
    
    quantityInput.value = quantity;
    updateInvestmentTradeInfo();
}

// 计算最大可交易数量
function calculateInvestmentMaxQuantity() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    
    if (game.tradeData.type === 'buy') {
        // 根据可用资金计算最大可买入数量
        const maxByFunds = Math.floor(game.userData.availableFunds / (currentStock.price * (1 + game.tradeData.feeRate)));
         return Math.min(maxByFunds, 100000000000000000000); // 限制最大1000亿亿股
    } else {
        // 卖出时最多可卖出持有数量
        return currentStock.holdings;
    }
}

// 更新交易信息
function updateInvestmentTradeInfo() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    const quantityInput = document.getElementById('trade-quantity');
    const amountInput = document.getElementById('trade-amount');
    const feeInput = document.getElementById('trade-fee');
    const maxQuantityInput = document.getElementById('max-quantity');
    
    // 更新交易数量
    let quantity = parseInt(quantityInput.value) || 0;
    const maxQuantity = calculateInvestmentMaxQuantity();
    
    if (quantity > maxQuantity) {
        quantity = maxQuantity;
        quantityInput.value = quantity;
    }
    
    // 计算交易金额和手续费
    const amount = quantity * currentStock.price;
    const fee = amount * game.tradeData.feeRate;
    
    // 更新显示
    amountInput.value = amount.toFixed(3);
    feeInput.value = fee.toFixed(3);
    maxQuantityInput.value = maxQuantity.toLocaleString();
    
    // 更新持仓信息
    updateInvestmentHoldingsInfo();
}

// 更新持仓信息（价格、盈亏用安全值，避免 NaN）
function updateInvestmentHoldingsInfo() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    const safe = (v, d) => (v != null && Number.isFinite(Number(v)) ? Number(v) : (d || 0));
    const price = safe(currentStock.price, 10);
    const costPrice = safe(currentStock.costPrice, 0);
    const holdings = safe(currentStock.holdings, 0);
    const holdValue = holdings * price;
    const profit = costPrice > 0 ? (price - costPrice) * holdings : 0;
    const profitPercent = costPrice > 0 ? safeChangePercent(price, costPrice) : 0;
    
    document.getElementById('hold-amount').textContent = holdings.toLocaleString();
    document.getElementById('cost-price').textContent = costPrice > 0 ? costPrice.toFixed(3) : "0.000";
    document.getElementById('hold-value').textContent = (Number.isFinite(holdValue) ? holdValue : 0).toLocaleString(undefined, {
        minimumFractionDigits: 3,
        maximumFractionDigits: 3
    });
    
    const profitText = costPrice > 0 ? 
        `${profit >= 0 ? '+' : ''}${(Number.isFinite(profit) ? profit : 0).toFixed(3)} (${profitPercent >= 0 ? '+' : ''}${(Number.isFinite(profitPercent) ? profitPercent : 0).toFixed(3)}%)` : 
        "0.000 (0.000%)";
    
    const profitElement = document.getElementById('hold-profit');
    if (profitElement) profitElement.textContent = profitText;
    
    if (profit > 0) {
        profitElement.className = 'info-value profit-up';
    } else if (profit < 0) {
        profitElement.className = 'info-value profit-down';
    } else {
        profitElement.className = 'info-value';
    }
}

// 初始化价格图表
function initInvestmentChart() {
    updateInvestmentChartFromCache(100);
}

// 从缓存更新图表
function updateInvestmentChartFromCache(points = 100) {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    const chartContainer = document.getElementById('price-chart');
    
    if (!chartContainer) return;
    
    // 生成图表数据
    const data = generateInvestmentChartData(currentStock.code, points);
    
    // 更新价格范围显示
    updateChartPriceRange(data);
    
    // 创建SVG图表
    chartContainer.innerHTML = `
        <svg width="100%" height="100%" viewBox="0 0 800 300" preserveAspectRatio="none">
            ${generateInvestmentChartSVG(data, currentStock)}
        </svg>
    `;
}

// 生成图表数据
function generateInvestmentChartData(stockCode, points) {
    const game = player.investmentGame;
    const cacheKey = `${stockCode}_${points}`;
    const stock = game.stocks.find(s => s.code === stockCode);
    
    if (!stock) return [];
    
    // 检查缓存
    if (game.chartHistoryCache[cacheKey] && 
        Date.now() - (game.chartHistoryCache[cacheKey].timestamp || 0) < 30000) {
        return game.chartHistoryCache[cacheKey].data;
    }
    
    // 固定生成100个点
    const dataPoints = Math.min(points, 100);
    const data = [];
    
    // 获取最近的价格历史（如果有的话）
    const priceHistory = stock.randomParams?.priceHistory || [];
    const historyLength = priceHistory.length;
    
    if (historyLength >= dataPoints) {
        // 如果有足够的历史数据，直接使用（保留2位小数）
        data.push(...priceHistory.slice(-dataPoints).map(function(p) { return roundInvestmentPrice(p); }));
    } else {
        // 生成模拟历史数据
        let currentPrice = stock.price;
        
        for (let i = 0; i < dataPoints; i++) {
            // 模拟价格波动
            const progress = i / dataPoints;
            const volatility = 0.005 * (1 - progress * 0.5);
            
            const randomFactor = (Math.random() - 0.5) * 2;
            const timeFactor = Math.sin(i * 0.1) * 0.2;
            const noise = randomFactor * volatility + timeFactor * volatility * 0.3;
            
            currentPrice *= (1 + noise);
            
            // 确保价格在合理范围内
            const bounds = stock.priceBounds || { min: 0.1, max: 200 };
            if (currentPrice < bounds.min) {
                currentPrice = bounds.min * (1 + Math.random() * 0.1);
            }
            if (currentPrice > bounds.max) {
                currentPrice = bounds.max * (0.9 + Math.random() * 0.1);
            }
            
            // 确保数据足够平滑
            if (i > 0 && Math.abs(data[i-1] - currentPrice) > data[i-1] * 0.1) {
                currentPrice = data[i-1] * (1 + (Math.random() - 0.5) * 0.05);
            }
            
            data.unshift(roundInvestmentPrice(currentPrice)); // 添加到开头，只存2位小数
        }
        
        // 确保最后一个点是当前价格
        data[dataPoints - 1] = roundInvestmentPrice(stock.price);
    }
    
    // 平滑数据
    smoothChartData(data);
    
    // 确保价格有合理的波动范围
    const minPrice = Math.min(...data);
    const maxPrice = Math.max(...data);
    
    if (maxPrice - minPrice < 0.01) {
        // 如果价格波动太小，增加一些波动
        const midPrice = (maxPrice + minPrice) / 2;
        data.forEach((price, i) => {
            const variation = (Math.sin(i * 0.2) * 0.05 + (Math.random() - 0.5) * 0.02) * midPrice;
            data[i] = roundInvestmentPrice(Math.max(midPrice * 0.8, Math.min(midPrice * 1.2, price + variation)));
        });
    }
    
    // 存档只保留2位小数（原地修改，避免对 const data 重新赋值）
    for (let i = 0; i < data.length; i++) data[i] = roundInvestmentPrice(data[i]);
    
    // 缓存数据（带时间戳）
    game.chartHistoryCache[cacheKey] = {
        data: data,
        timestamp: Date.now(),
        min: roundInvestmentPrice(Math.min(...data)),
        max: roundInvestmentPrice(Math.max(...data))
    };
    
    return data;
}

function smoothChartData(data) {
    if (data.length < 3) return data;
    
    const smoothed = [...data];
    const smoothingFactor = 0.3; // 平滑系数
    
    for (let i = 1; i < data.length - 1; i++) {
        // 使用加权平均进行平滑
        smoothed[i] = (
            data[i-1] * smoothingFactor + 
            data[i] * (1 - smoothingFactor * 2) + 
            data[i+1] * smoothingFactor
        );
    }
    
    // 保持首尾不变
    smoothed[0] = data[0];
    smoothed[data.length - 1] = data[data.length - 1];
    
    // 复制回原数组
    for (let i = 0; i < data.length; i++) {
        data[i] = smoothed[i];
    }
}
function updateInvestmentChart() {
    const chartContainer = document.getElementById('price-chart');
    if (!chartContainer) return;
    
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    
    // 清除缓存，强制重新生成
    const cacheKey = `${currentStock.code}_100`;
    delete game.chartHistoryCache[cacheKey];
    
    // 更新图表
    updateInvestmentChartFromCache(100);
    
    // 添加更新动画效果
    chartContainer.style.opacity = '0.7';
    setTimeout(() => {
        chartContainer.style.opacity = '1';
    }, 300);
}
// 生成SVG图表
function generateInvestmentChartSVG(data, stock) {
    if (data.length === 0) return '';
    
    const width = 800;
    const height = 300;
    const padding = { top: 20, right: 60, bottom: 20, left: 60 }; // 增加左右边距
    
    const availableWidth = width - padding.left - padding.right;
    const availableHeight = height - padding.top - padding.bottom;
    
    const minPrice = Math.min(...data);
    const maxPrice = Math.max(...data);
    const range = maxPrice - minPrice || 1;
    
    // 生成更平滑的路径
    let pathData = '';
    data.forEach((price, index) => {
        const x = padding.left + (index / (data.length - 1)) * availableWidth;
        const y = padding.top + availableHeight - ((price - minPrice) / range) * availableHeight;
        
        if (index === 0) {
            pathData += `M ${x} ${y} `;
        } else {
            // 使用三次贝塞尔曲线让路径更平滑
            const prevX = padding.left + ((index - 1) / (data.length - 1)) * availableWidth;
            const prevY = padding.top + availableHeight - ((data[index - 1] - minPrice) / range) * availableHeight;
            const cp1x = prevX + (x - prevX) / 3;
            const cp1y = prevY;
            const cp2x = prevX + (x - prevX) * 2 / 3;
            const cp2y = y;
            
            pathData += `C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x} ${y} `;
        }
    });
    
    // 创建渐变填充
    const fillColor = stock.change >= 0 ? '#10b981' : '#ef4444';
    const gradientId = `gradient-${stock.code}-${Date.now()}`;
    
    // 计算当前价格在图表中的位置
    const currentPrice = data[data.length - 1];
    const currentX = width - padding.right;
    const currentY = padding.top + availableHeight - ((currentPrice - minPrice) / range) * availableHeight;
    
    return `
        <defs>
            <!-- 网格线 -->
            <pattern id="grid-${gradientId}" width="40" height="40" patternUnits="userSpaceOnUse">
                <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#e2e8f0" stroke-width="0.5"/>
            </pattern>
            
            <!-- 渐变填充 -->
            <linearGradient id="${gradientId}" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stop-color="${fillColor}" stop-opacity="0.3"/>
                <stop offset="100%" stop-color="${fillColor}" stop-opacity="0.1"/>
            </linearGradient>
        </defs>
        
        <!-- 网格背景 -->
        <rect x="${padding.left}" y="${padding.top}" width="${availableWidth}" height="${availableHeight}" 
              fill="url(#grid-${gradientId})" stroke="none"/>
        
        <!-- Y轴价格标签背景 -->
        <rect x="0" y="${padding.top}" width="${padding.left}" height="${availableHeight}" 
              fill="#f8fafc" stroke="#e2e8f0" stroke-width="1"/>
        
        <!-- 价格填充区域 -->
        <path d="${pathData} L ${width - padding.right} ${height - padding.bottom} L ${padding.left} ${height - padding.bottom} Z" 
              fill="url(#${gradientId})" stroke="none"/>
        
        <!-- 价格路径 -->
        <path d="${pathData}" fill="none" stroke="${fillColor}" 
              stroke-width="2" stroke-linejoin="round" stroke-linecap="round"/>
        
        <!-- 当前价格点 -->
        <circle cx="${currentX}" cy="${currentY}" 
                r="4" fill="white" stroke="${fillColor}" stroke-width="2"/>
        
        <!-- Y轴价格标签 -->
        <g font-family="'Segoe UI', Arial, sans-serif" font-size="12" fill="#6b7280">
            <!-- 最高价标签（左上角） -->
            <rect x="5" y="${padding.top - 10}" width="${padding.left - 10}" height="20" 
                  rx="4" fill="#f1f5f9" stroke="#e2e8f0" stroke-width="1"/>
            <text x="${padding.left / 2}" y="${padding.top + 4}" text-anchor="middle" font-weight="600" fill="#334155">
                ${maxPrice.toFixed(3)}
            </text>
            
            <!-- 最低价标签（左下角） -->
            <rect x="5" y="${height - padding.bottom - 10}" width="${padding.left - 10}" height="20" 
                  rx="4" fill="#f1f5f9" stroke="#e2e8f0" stroke-width="1"/>
            <text x="${padding.left / 2}" y="${height - padding.bottom + 4}" text-anchor="middle" font-weight="600" fill="#334155">
                ${minPrice.toFixed(3)}
            </text>
            
            <!-- 中间价格标签（可选） -->
            <rect x="5" y="${height / 2 - 10}" width="${padding.left - 10}" height="20" 
                  rx="4" fill="#f1f5f9" stroke="#e2e8f0" stroke-width="1"/>
            <text x="${padding.left / 2}" y="${height / 2 + 4}" text-anchor="middle" font-weight="600" fill="#334155">
                ${((maxPrice + minPrice) / 2).toFixed(3)}
            </text>
        </g>
        
        <!-- 当前价格标签 -->
        <g font-family="'Segoe UI', Arial, sans-serif" font-size="12">
            <rect x="${width - padding.right - 80}" y="${padding.top + 10}" width="70" height="24" rx="4" 
                  fill="${stock.change >= 0 ? '#10b981' : '#ef4444'}" fill-opacity="0.9"/>
            <text x="${width - padding.right - 45}" y="${padding.top + 26}" text-anchor="middle" fill="white" font-weight="600">
                ${stock.price.toFixed(3)}
            </text>
        </g>
        
        <!-- X轴网格线 -->
        <g stroke="#e2e8f0" stroke-width="1" stroke-dasharray="2,2">
            <line x1="${padding.left}" y1="${padding.top + availableHeight * 0.25}" 
                  x2="${width - padding.right}" y2="${padding.top + availableHeight * 0.25}"/>
            <line x1="${padding.left}" y1="${padding.top + availableHeight * 0.5}" 
                  x2="${width - padding.right}" y2="${padding.top + availableHeight * 0.5}"/>
            <line x1="${padding.left}" y1="${padding.top + availableHeight * 0.75}" 
                  x2="${width - padding.right}" y2="${padding.top + availableHeight * 0.75}"/>
        </g>
        
        <!-- Y轴网格线 -->
        <g stroke="#e2e8f0" stroke-width="1" stroke-dasharray="2,2">
            <line x1="${padding.left + availableWidth * 0.25}" y1="${padding.top}" 
                  x2="${padding.left + availableWidth * 0.25}" y2="${height - padding.bottom}"/>
            <line x1="${padding.left + availableWidth * 0.5}" y1="${padding.top}" 
                  x2="${padding.left + availableWidth * 0.5}" y2="${height - padding.bottom}"/>
            <line x1="${padding.left + availableWidth * 0.75}" y1="${padding.top}" 
                  x2="${padding.left + availableWidth * 0.75}" y2="${height - padding.bottom}"/>
        </g>
        
        <!-- 坐标轴 -->
        <g stroke="#cbd5e1" stroke-width="2">
            <!-- Y轴 -->
            <line x1="${padding.left}" y1="${padding.top}" 
                  x2="${padding.left}" y2="${height - padding.bottom}"/>
            <!-- X轴 -->
            <line x1="${padding.left}" y1="${height - padding.bottom}" 
                  x2="${width - padding.right}" y2="${height - padding.bottom}"/>
        </g>
        
        <!-- 时间标签（可选） -->
        <g font-family="'Segoe UI', Arial, sans-serif" font-size="10" fill="#94a3b8" text-anchor="middle">
            <text x="${padding.left}" y="${height - 5}">过去</text>
            <text x="${width - padding.right}" y="${height - 5}">现在</text>
        </g>
    `;
}

// 提交交易
function submitInvestmentTrade() {
    const game = player.investmentGame;
    const currentStock = game.stocks[game.currentStockIndex];
    
    if (game.userData.tradeCount <= 0) {
        showInvestmentNotification('交易次数不足！', 'error');
        return;
    }
    
    const quantityInput = document.getElementById('trade-quantity');
    const quantity = parseInt(quantityInput.value) || 0;
    
    if (quantity <= 0) {
        showInvestmentNotification('请输入有效的交易数量', 'error');
        return;
    }
    
    const amount = quantity * currentStock.price;
    const fee = amount * game.tradeData.feeRate;
    const totalCost = amount + fee;
    
    if (game.tradeData.type === 'buy') {
        if (totalCost > game.userData.availableFunds) {
            showInvestmentNotification('可用资金不足，无法完成买入', 'error');
            return;
        }
        
        // 执行买入
        game.userData.availableFunds -= totalCost;
        
        // 更新持仓
        const newTotalShares = currentStock.holdings + quantity;
        const newCostPrice = currentStock.holdings > 0 ? 
            (currentStock.holdings * currentStock.costPrice + amount) / newTotalShares : 
            currentStock.price;
        
        currentStock.holdings = newTotalShares;
        currentStock.costPrice = newCostPrice;
        game.userData.tradeCount--;
        
        showInvestmentNotification(`成功买入 ${quantity.toLocaleString()} 股${currentStock.name}，花费 ¥${totalCost.toFixed(3)}`, 'success');
    } else {
        if (quantity > currentStock.holdings) {
            showInvestmentNotification('持有数量不足，无法卖出', 'error');
            return;
        }
        
        // 执行卖出
        const sellAmount = amount - fee;
        game.userData.availableFunds += sellAmount;
        currentStock.holdings -= quantity;
        game.userData.tradeCount--;
        
        // 如果清仓，重置成本价
        if (currentStock.holdings === 0) {
            currentStock.costPrice = 0;
        }
        
        showInvestmentNotification(`成功卖出 ${quantity.toLocaleString()} 股${currentStock.name}，获得 ¥${sellAmount.toFixed(3)}`, 'success');
    }
    
    // 更新总资产
    updateInvestmentTotalAssets();
    
    // 更新界面
    document.getElementById('trade-count').textContent = game.userData.tradeCount;
    document.getElementById('available-funds').textContent = game.userData.availableFunds.toLocaleString(undefined, {
        minimumFractionDigits: 3,
        maximumFractionDigits: 3
    });
    
    // 重置交易数量
    quantityInput.value = 0;
    
    // 更新所有信息
    updateInvestmentTradeInfo();
    updateInvestmentHoldingsInfo();
    updateInvestmentAssetsDisplay();
    
    // 保存游戏
    saveGame();
}

// 更新总资产（所有参与计算的值都做 NaN 防护，避免总资产变 NaN）
function updateInvestmentTotalAssets() {
    const game = player.investmentGame;
    if (!game || !game.userData) return;
    
    const safeNum = (v, def) => (v != null && Number.isFinite(Number(v)) ? Number(v) : (def || 0));
    const totalHoldingsValue = game.stocks.reduce((sum, stock) => {
        const price = safeNum(stock.price, 10);
        const holdings = safeNum(stock.holdings, 0);
        return sum + (holdings * price);
    }, 0);
    
    const totalHoldingsCost = game.stocks.reduce((sum, stock) => {
        const cost = safeNum(stock.costPrice, 0);
        const holdings = safeNum(stock.holdings, 0);
        return sum + (holdings * cost);
    }, 0);
    
    const totalProfitLoss = Number.isFinite(totalHoldingsValue) && Number.isFinite(totalHoldingsCost)
        ? (totalHoldingsValue - totalHoldingsCost) : 0;
    const totalProfitLossPercent = totalHoldingsCost > 0 && Number.isFinite(totalProfitLoss)
        ? (totalProfitLoss / totalHoldingsCost * 100) : 0;
    
    const availableFunds = safeNum(game.userData.availableFunds, 1000);
    const totalAssets = availableFunds + (Number.isFinite(totalHoldingsValue) ? totalHoldingsValue : 0);
    const safeTotalAssets = Number.isFinite(totalAssets) && totalAssets >= 0 ? totalAssets : availableFunds;
    const holdingPercent = safeTotalAssets > 0 && Number.isFinite(totalHoldingsValue)
        ? (totalHoldingsValue / safeTotalAssets * 100) : 0;
    
    game.userData.availableFunds = availableFunds;
    game.userData.totalAssets = safeTotalAssets;
    game.userData.holdingPercent = Number.isFinite(holdingPercent) ? Math.max(0, Math.min(100, holdingPercent)) : 0;
    game.userData.todayProfit = Number.isFinite(totalProfitLossPercent) ? totalProfitLossPercent : 0;
    game.userData.totalProfitAmount = Number.isFinite(totalProfitLoss) ? totalProfitLoss : 0;
    game.userData.totalProfitPercent = Number.isFinite(totalProfitLossPercent) ? totalProfitLossPercent : 0;
}

// 更新资产显示（总资产等做 NaN 防护，避免界面显示 NaN）
function updateInvestmentAssetsDisplay() {
    const game = player.investmentGame;
    if (!game || !game.userData) return;
    const safeVal = (v, def) => (v != null && Number.isFinite(Number(v)) ? Number(v) : (def || 0));
    const totalAssets = safeVal(game.userData.totalAssets, 0);
    const holdingPercent = safeVal(game.userData.holdingPercent, 0);
    
    const totalAssetsEl = document.getElementById('total-assets');
    if (totalAssetsEl) totalAssetsEl.textContent = totalAssets.toLocaleString(undefined, { minimumFractionDigits: 3, maximumFractionDigits: 3 });
    
    const holdVal = calculateTotalHoldingsValue();
    const totalHoldEl = document.getElementById('total-hold-value');
    if (totalHoldEl) totalHoldEl.textContent = (Number.isFinite(holdVal) ? holdVal : 0).toLocaleString(undefined, { minimumFractionDigits: 3, maximumFractionDigits: 3 });
    
    const holdPctEl = document.getElementById('total-holding-percent');
    if (holdPctEl) holdPctEl.textContent = (Number.isFinite(holdingPercent) ? holdingPercent : 0).toFixed(3) + '%';
    
    // 更新总盈亏
    const profitAmount = calculateTotalProfitAmount();
    const profitAmountEl = document.getElementById('total-profit-amount');
    if (profitAmountEl) profitAmountEl.textContent = (Number.isFinite(profitAmount) ? profitAmount : 0).toLocaleString(undefined, { minimumFractionDigits: 3, maximumFractionDigits: 3 });
    const profitPercentEl = document.getElementById('total-profit-percent');
    if (profitPercentEl) profitPercentEl.textContent = calculateTotalProfitPercent() + '%';
    
    // 更新持仓表格
    document.getElementById('holdings-body').innerHTML = generateHoldingsTable();
    
    // 显示/隐藏无持仓提示
    document.getElementById('no-holdings').style.display = hasHoldings() ? 'none' : 'block';
}

// 显示投资游戏通知
function showInvestmentNotification(message, type) {
    const notification = document.getElementById('investment-notification');
    notification.textContent = message;
    notification.className = `notification ${type}`;
    notification.style.display = 'block';
    
    setTimeout(() => {
        notification.style.display = 'none';
    }, 3000);
}

// 开始价格模拟
function startPriceSimulation() {
    const game = player.investmentGame;
    
    // 初始化随机参数
    if (!game.stocks[0]?.randomParams) {
        game.stocks.forEach((stock, index) => {
            if (!stock.randomParams) {
                stock.randomParams = {
                    baseVolatility: 0.005 + Math.random() * 0.025,
                    trendStrength: (Math.random() - 0.5) * 0.002,
                    eventProbability: 0.001,
                    meanReversion: 0.2 + Math.random() * 0.3,
                    noiseLevel: Math.random() * 0.8 + 0.2,
                    lastChange: 0,
                    priceHistory: []
                };
            }
            if (!stock.basePrice) {
                stock.basePrice = stock.price || 10;
            }
            if (!stock.priceBounds) {
                stock.priceBounds = {
                    min: 0.1,   // 最低0.1元
                    max: 200,   // 最高200元
                    support: Math.max(0.5, stock.basePrice * 0.5), // 支撑位
                    resistance: Math.min(150, stock.basePrice * 1.5) // 阻力位
                };
            }
        });
    }
    
    // 清除之前的定时器
    if (game.priceUpdateTimer) {
        clearInterval(game.priceUpdateTimer);
    }
    if (game.chartUpdateTimer) {
        clearInterval(game.chartUpdateTimer);
    }
    
    // 设置游戏开始时间（只在第一次启动时）
    if (!game.startTime) {
        game.startTime = Date.now();
    }
    
    // 先模拟一次离线价格变化
    simulateOfflinePriceChanges();
    
    let lastMarketEventTime = Date.now();
    let currentMarketMood = 0;
    let lastUpdateTime = Date.now();
    
    // 每分钟更新一次价格
    game.priceUpdateTimer = registerInterval(() => {
        const updateTime = Date.now();
        const minutesSinceStart = Math.floor((updateTime - game.startTime) / 60000);
        
        // 每5分钟可能更新市场情绪
        if (minutesSinceStart % 5 === 0) {
            if (Math.random() < 0.3) {
                currentMarketMood += (Math.random() - 0.5) * 0.4;
                currentMarketMood = Math.max(-1, Math.min(1, currentMarketMood));
            }
        }
        
        // 检查市场事件
        let marketEffect = 0;
        const timeSinceLastEvent = updateTime - lastMarketEventTime;
        
        if (timeSinceLastEvent > 5 * 60 * 1000) {
            const eventRoll = Math.random();
            if (eventRoll < 0.0005) {
                marketEffect = (Math.random() - 0.5) * 0.08;
                lastMarketEventTime = updateTime;
                logAction(`市场发生重大事件！影响: ${(marketEffect * 100).toFixed(2)}%`, 'market');
            } else if (eventRoll < 0.005) {
                marketEffect = (Math.random() - 0.5) * 0.02;
                lastMarketEventTime = updateTime;
            }
        }
        
        // 为所有股票更新价格（修复版）：新号无 params/bounds 会算出 NaN，必须先补全并保证 price 有效
        game.stocks.forEach((stock, index) => {
            const basePrice = Math.max(0.0001, Number(stock.basePrice) || Number(stock.price) || 10);
            if (!Number.isFinite(stock.price) || stock.price <= 0) stock.price = roundInvestmentPrice(basePrice);
            if (!stock.randomParams) {
                stock.randomParams = {
                    baseVolatility: 0.005 + Math.random() * 0.025,
                    trendStrength: (Math.random() - 0.5) * 0.002,
                    meanReversion: 0.2 + Math.random() * 0.3,
                    lastChange: 0,
                    priceHistory: [],
                    eventProbability: 0.01
                };
            } else {
                if (typeof stock.randomParams.trendStrength !== 'number') stock.randomParams.trendStrength = (Math.random() - 0.5) * 0.002;
                if (typeof stock.randomParams.baseVolatility !== 'number') stock.randomParams.baseVolatility = 0.005 + Math.random() * 0.025;
                if (typeof stock.randomParams.meanReversion !== 'number') stock.randomParams.meanReversion = 0.2 + Math.random() * 0.3;
                if (typeof stock.randomParams.lastChange !== 'number') stock.randomParams.lastChange = 0;
                if (typeof stock.randomParams.eventProbability !== 'number') stock.randomParams.eventProbability = 0.01;
                if (!Array.isArray(stock.randomParams.priceHistory)) stock.randomParams.priceHistory = [];
            }
            if (!stock.priceBounds) {
                stock.priceBounds = {
                    min: 0.1,
                    max: 200,
                    support: Math.max(0.5, basePrice * 0.5),
                    resistance: Math.min(150, basePrice * 1.5)
                };
            }
            const params = stock.randomParams;
            const bounds = stock.priceBounds;
            if (typeof bounds.min !== 'number' || bounds.min <= 0) bounds.min = 0.1;
            if (typeof bounds.max !== 'number' || bounds.max < bounds.min) bounds.max = Math.max(200, bounds.min * 2);
            
            // 计算自上次更新以来的时间间隔
            const timeDiff = updateTime - lastUpdateTime;
            const timeFactor = Math.min(timeDiff / 60000, 5);
            
            // 1. 基础趋势
            const trendChange = params.trendStrength * timeFactor;
            
            // 2. 生成随机因子
            const timeBasedRand = Math.sin(updateTime * 0.0001 + index) * 0.5 + 0.5;
            const normalRand = (Math.random() + Math.random() + Math.random() - 1.5) * 2;
            
            // 3. 波动率（动态调整）
            let currentVolatility = params.baseVolatility;
            
            // 价格越低，波动率相对越高
            if (stock.price < 5) {
                currentVolatility *= 1.5;
            }
            // 价格接近边界时降低波动率
            if (stock.price < bounds.min * 1.5) {
                currentVolatility *= 0.7;
            }
            if (stock.price > bounds.max * 0.8) {
                currentVolatility *= 0.7;
            }
            
            // 时间波动
            currentVolatility *= (0.9 + Math.sin(updateTime * 0.00005) * 0.2);
            
            // 4. 随机事件
            if (Math.random() < params.eventProbability * timeFactor) {
                const eventMagnitude = 1 + Math.random() * 3;
                currentVolatility *= eventMagnitude;
            }
            
            // 5. 均值回归（使用前面已算好的 basePrice）
            const deviationFromMean = (stock.price - basePrice) / basePrice;
            let reversionForce = -deviationFromMean * params.meanReversion * 0.003 * timeFactor;
            
            // 6. 边界效应（更平滑的处理）
            const distanceToMin = (stock.price - bounds.min) / bounds.min;
            const distanceToMax = (bounds.max - stock.price) / bounds.max;
            
            // 接近下限时增加反弹概率
            if (distanceToMin < 0.5) {
                const bounceProbability = 1 - (distanceToMin * 2);
                if (Math.random() < bounceProbability * 0.1) {
                    reversionForce += Math.abs(reversionForce) * 0.5;
                }
            }
            
            // 接近上限时增加回调概率
            if (distanceToMax < 0.5) {
                const pullbackProbability = 1 - (distanceToMax * 2);
                if (Math.random() < pullbackProbability * 0.1) {
                    reversionForce -= Math.abs(reversionForce) * 0.5;
                }
            }
            
            // 7. 动量效应
            const momentumEffect = params.lastChange * 0.15;
            
            // 8. 计算价格变化
            const modelIndex = minutesSinceStart % 6;
            let priceChange = 0;
            
            switch (modelIndex) {
                case 0:
                    priceChange = normalRand * currentVolatility * timeFactor;
                    break;
                case 1:
                    priceChange = (normalRand * currentVolatility + momentumEffect) * timeFactor;
                    break;
                case 2:
                    priceChange = (normalRand * currentVolatility * 0.7 + reversionForce) * timeFactor;
                    break;
                case 3:
                    priceChange = normalRand * currentVolatility * 1.5 * timeFactor;
                    break;
                case 4:
                    priceChange = normalRand * currentVolatility * 0.5 * timeFactor;
                    break;
                default:
                    priceChange = (normalRand + timeBasedRand - 0.5) * currentVolatility * timeFactor;
            }
            
            // 添加趋势和市场情绪
            priceChange += trendChange;
            priceChange += currentMarketMood * 0.002 * timeFactor;
            
            // 市场事件影响
            if (marketEffect !== 0) {
                const stockSensitivity = 0.5 + Math.random() * 0.5;
                priceChange += marketEffect * stockSensitivity;
            }
            
            // 板块效应
            if (index % 3 === minutesSinceStart % 3) {
                priceChange += (Math.random() - 0.5) * 0.002;
            }
            if (!Number.isFinite(priceChange)) priceChange = 0;
            
            // 记录历史变化（只存2位小数）
            params.lastChange = priceChange;
            params.priceHistory = params.priceHistory || [];
            params.priceHistory.push(roundInvestmentPrice(stock.price));
            if (params.priceHistory.length > 100) {
                params.priceHistory.shift();
            }
            
            // 应用价格变化（修复版）
            const oldPrice = stock.price;
            
            // 计算新价格
            let newPrice = stock.price * (1 + priceChange);
            
            // 更智能的边界处理
            if (newPrice < bounds.min) {
                // 在极低价时，随机决定是反弹还是继续下跌
                if (Math.random() < 0.7) {
                    // 70%概率反弹
                    const bounceStrength = 0.05 + Math.random() * 0.1;
                    newPrice = stock.price * (1 + bounceStrength);
                } else {
                    // 30%概率继续下跌，但有最小限制
                    newPrice = Math.max(bounds.min * 0.9, newPrice);
                }
            }
            
            if (newPrice > bounds.max) {
                // 在极高价时，随机决定是回调还是继续上涨
                if (Math.random() < 0.7) {
                    // 70%概率回调
                    const pullbackStrength = 0.05 + Math.random() * 0.1;
                    newPrice = stock.price * (1 - pullbackStrength);
                } else {
                    // 30%概率继续上涨，但有最大限制
                    newPrice = Math.min(bounds.max * 1.1, newPrice);
                }
            }
            
            // 防止价格停滞
            if (Number.isFinite(newPrice) && Math.abs(newPrice - oldPrice) < 0.001) {
                const microChange = (Math.random() - 0.5) * 0.005;
                newPrice = stock.price * (1 + microChange);
            }
            if (!Number.isFinite(priceChange)) priceChange = 0;
            
            // 只接受有效正数，避免新号或异常时把 NaN 写入 stock.price；存档只保留2位小数
            stock.price = roundInvestmentPrice((Number.isFinite(newPrice) && newPrice > 0) ? newPrice : oldPrice);
            
            // 更新涨跌幅（安全计算，避免 NaN）
            stock.change = safeChangePercent(stock.price, basePrice);
            
            // 记录最高/最低价
            if (!stock.highestPrice || stock.price > stock.highestPrice) {
                stock.highestPrice = roundInvestmentPrice(stock.price);
            }
            if (!stock.lowestPrice || stock.price < stock.lowestPrice) {
                stock.lowestPrice = roundInvestmentPrice(stock.price);
            }
            
            // 动态调整阻力位和支撑位
            const avgPrice = params.priceHistory.length > 0 ?
                params.priceHistory.reduce((a, b) => a + b, 0) / params.priceHistory.length :
                basePrice;
            
            stock.priceBounds.support = roundInvestmentPrice(Math.max(bounds.min, avgPrice * 0.7));
            stock.priceBounds.resistance = roundInvestmentPrice(Math.min(bounds.max, avgPrice * 1.3));
              params.priceHistory = params.priceHistory || [];
params.priceHistory.push(roundInvestmentPrice(stock.price));

// 只保留最近50个价格记录
if (params.priceHistory.length > 50) {
    params.priceHistory.shift();
}

// 同时更新stock对象的价格历史
stock.priceHistory = stock.priceHistory || [];
stock.priceHistory.push(roundInvestmentPrice(stock.price));
if (stock.priceHistory.length > 50) {
    stock.priceHistory.shift();
}
if (stock._changeCache) {
    delete stock._changeCache;
}
        });

        // 更新最后更新时间
        lastUpdateTime = updateTime;
        
        // 如果游戏界面打开，先按新股价重算总资产再更新显示，避免总资产变 NaN
        if (document.getElementById('investmentGameUI')?.style.display === 'block') {
            updateInvestmentTotalAssets();
            updateInvestmentStockDisplay();
            updateInvestmentTradeInfo();
            updateInvestmentHoldingsInfo();
            updateInvestmentAssetsDisplay();
            
            const timeElement = document.getElementById('update-time');
            if (timeElement) {
                timeElement.textContent = `股价更新时间：${new Date().toLocaleTimeString()}`;
            }
        }
        
        // 每5分钟记录一次日志
        if (minutesSinceStart % 5 === 0) {
            const avgChange = game.stocks.reduce((sum, s) => sum + (Number.isFinite(s.change) ? s.change : 0), 0) / game.stocks.length;
            console.log(`实时模拟: 平均涨跌幅 ${Number.isFinite(avgChange) ? avgChange.toFixed(2) : '0.00'}%, 市场情绪: ${currentMarketMood.toFixed(2)}`);
        }
        
    }, 60000); // 每分钟更新一次
    
    // 图表更新频率更快
    game.chartUpdateTimer = registerInterval(() => {
        if (document.getElementById('investmentGameUI')?.style.display === 'block') {
            updateInvestmentStockDisplay();
            updateInvestmentChartFromCache(100);
        }
    }, 10000);
    
    logAction('股票价格实时模拟已启动', 'system');
}

// 模拟投资：价格只保留小数点后3位，避免存档中价格走势图数据过长
function roundInvestmentPrice(v) {
    var n = Number(v);
    return Number.isFinite(n) ? Math.round(n * 1000) / 1000 : (typeof v === 'number' ? v : 0);
}
function normalizeInvestmentGamePrices() {
    try {
        if (!player || !player.investmentGame || !Array.isArray(player.investmentGame.stocks)) return;
        player.investmentGame.stocks.forEach(function(stock) {
            if (!stock || typeof stock !== 'object') return;
            stock.price = roundInvestmentPrice(stock.price);
            if (stock.basePrice != null) stock.basePrice = roundInvestmentPrice(stock.basePrice);
            if (stock.highestPrice != null) stock.highestPrice = roundInvestmentPrice(stock.highestPrice);
            if (stock.lowestPrice != null) stock.lowestPrice = roundInvestmentPrice(stock.lowestPrice);
            if (stock.costPrice != null) stock.costPrice = roundInvestmentPrice(stock.costPrice);
            if (Array.isArray(stock.priceHistory)) stock.priceHistory = stock.priceHistory.map(roundInvestmentPrice);
            if (stock.randomParams && stock.randomParams !== null && Array.isArray(stock.randomParams.priceHistory)) stock.randomParams.priceHistory = stock.randomParams.priceHistory.map(roundInvestmentPrice);
            if (stock.priceBounds && typeof stock.priceBounds === 'object') {
                stock.priceBounds.min = roundInvestmentPrice(stock.priceBounds.min);
                stock.priceBounds.max = roundInvestmentPrice(stock.priceBounds.max);
                stock.priceBounds.support = roundInvestmentPrice(stock.priceBounds.support);
                stock.priceBounds.resistance = roundInvestmentPrice(stock.priceBounds.resistance);
            }
        });
        // chartHistoryCache 不参与存档，加载时已清空，此处不再处理
    } catch (e) {
        console.warn('normalizeInvestmentGamePrices 执行异常，已跳过:', e);
    }
}

// 初始化投资游戏
function initInvestmentGame() {
    if (!player.investmentGame) {
        player.investmentGame = {
            stocks: [
                {code: "zj0001", name: "鱼鱼基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0002", name: "闫闫基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},           
                {code: "zj0003", name: "茶茶金股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0004", name: "麒麟企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0005", name: "云南白药", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0006", name: "黑三逢源", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0007", name: "乐途企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0008", name: "PDD企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0009", name: "空白控股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0010", name: "慢手企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0011", name: "斗音公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0012", name: "阿里妈妈", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0013", name: "淘宝宝", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0014", name: "千达有限", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0015", name: "通元房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0016", name: "预言鱼塘", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0017", name: "新股长虹", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0018", name: "萩萩萩萩音乐", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0019", name: "盛通快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0020", name: "十鼎洗浴", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0021", name: "九鼎红楼", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0022", name: "星巴克", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0023", name: "大吴疆土", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0024", name: "九转仙股", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0025", name: "乌龟科技", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0026", name: "阿斯塔特", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0027", name: "万里药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0028", name: "万里证券", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0029", name: "顶峰相见", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0030", name: "顺封快递", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0031", name: "晋商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0032", name: "爆涨房产", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0033", name: "书法银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0034", name: "阳城银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},            
                {code: "zj0035", name: "程羽银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0036", name: "中铁银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0037", name: "工商银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0038", name: "明港基金", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0039", name: "东坑企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0040", name: "黑龙银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0041", name: "韵达银行", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0042", name: "巴士企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0043", name: "京东公司", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0044", name: "科技企业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0045", name: "羊同药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0046", name: "风雪药业", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0047", name: "霸王别姬", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0048", name: "一点点奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0049", name: "古茗奶茶", price: 10.00, change: 0, holdings: 0, costPrice: 0},
                {code: "zj0050", name: "蜜雪冰城", price: 10.00, change: 0, holdings: 0, costPrice: 0}
            ].map(stock => {
                // 为每只股票添加完整的初始数据
                const basePrice = stock.price;
                return {
                    ...stock,
                    basePrice: basePrice,  // 基础价格
                    priceBounds: {         // 价格边界
                        min: 0.1,          // 最低价 0.1元
                        max: 200,          // 最高价 200元
                        support: Math.max(0.5, basePrice * 0.5),   // 支撑位
                        resistance: Math.min(150, basePrice * 1.5) // 阻力位
                    },
                    randomParams: null,    // 随机参数（运行时生成）
                    highestPrice: basePrice, // 历史最高价
                    lowestPrice: basePrice,  // 历史最低价
                    priceHistory: [],        // 价格历史记录
                    tradeHistory: []         // 交易历史记录
                };
            }),
            
            // 用户数据
            userData: {
                availableFunds: 1000.00,        // 可用资金
                totalAssets: 1000.00,           // 总资产
                holdingPercent: 0.00,           // 持仓占比
                todayProfit: 0.00,              // 今日盈亏比例
                totalProfitAmount: 0.00,        // 总盈亏金额
                totalProfitPercent: 0.00,       // 总盈亏比例
                tradeCount: 16,                 // 交易次数
                initialFunds: 1000.00,          // 初始资金
                lastUpdateTime: Date.now(),     // 最后更新时间
                totalTrades: 0,                 // 总交易次数
                totalVolume: 0,                 // 总交易量
                totalCommission: 0              // 总手续费
            },
            
            // 当前选中的股票
            currentStockIndex: 0,
            
            // 交易数据
            tradeData: {
                quantity: 0,                    // 交易数量
                type: "buy",                    // 交易类型：buy/sell
                feeRate: 0.0048                 // 手续费率 0.48%
            },
            
            // 图表缓存
            chartHistoryCache: {},
            
            // 定时器
            priceUpdateTimer: null,
            chartUpdateTimer: null,
            
            // 离线数据
            offlineData: {
                lastOfflineUpdate: Date.now()
            },
            
            // 游戏状态
            gameState: {
                startTime: Date.now(),          // 游戏开始时间
                marketMood: 0,                  // 市场情绪 (-1 到 1)
                lastMarketEvent: Date.now(),    // 上次市场事件时间
                totalMarketEvents: 0,           // 总市场事件数
                marketTrend: 0                  // 市场趋势
            },
            
            // 统计信息
            statistics: {
                totalBuyOrders: 0,              // 总买入订单
                totalSellOrders: 0,             // 总卖出订单
                totalProfit: 0,                 // 总盈利
                totalLoss: 0,                   // 总亏损
                bestTrade: {                    // 最佳交易
                    stockCode: "",
                    profit: 0,
                    date: 0
                },
                worstTrade: {                   // 最差交易
                    stockCode: "",
                    loss: 0,
                    date: 0
                }
            },
            
            // 设置选项
            settings: {
                autoUpdateChart: true,          // 自动更新图表
                showPriceBounds: true,          // 显示价格边界
                notificationEnabled: true,      // 启用通知
                chartPoints: 100,               // 图表点数
                refreshInterval: 10000          // 刷新间隔（毫秒）
            }
        };
    } else {
        // 确保现有股票数据的完整性
        player.investmentGame.stocks = player.investmentGame.stocks.map(stock => {
            // 如果股票数据不完整，补充缺失字段
            const basePrice = stock.basePrice || stock.price || 10;
            
            return {
                code: stock.code || `zj${(player.investmentGame.stocks.indexOf(stock) + 1).toString().padStart(4, '0')}`,
                name: stock.name || "未知股票",
                price: stock.price || 10.00,
                change: stock.change || 0,
                holdings: stock.holdings || 0,
                costPrice: stock.costPrice || 0,
                basePrice: basePrice,
                priceBounds: stock.priceBounds || {
                    min: 0.1,
                    max: 200,
                    support: Math.max(0.5, basePrice * 0.5),
                    resistance: Math.min(150, basePrice * 1.5)
                },
                randomParams: stock.randomParams || null,
                highestPrice: stock.highestPrice || basePrice,
                lowestPrice: stock.lowestPrice || basePrice,
                priceHistory: stock.priceHistory || [],
                tradeHistory: stock.tradeHistory || []
            };
        });
        
        // 确保用户数据完整性
        player.investmentGame.userData = {
            availableFunds: player.investmentGame.userData?.availableFunds || 1000.00,
            totalAssets: player.investmentGame.userData?.totalAssets || 1000.00,
            holdingPercent: player.investmentGame.userData?.holdingPercent || 0.00,
            todayProfit: player.investmentGame.userData?.todayProfit || 0.00,
            totalProfitAmount: player.investmentGame.userData?.totalProfitAmount || 0.00,
            totalProfitPercent: player.investmentGame.userData?.totalProfitPercent || 0.00,
            tradeCount: player.investmentGame.userData?.tradeCount || 16,
            initialFunds: player.investmentGame.userData?.initialFunds || 1000.00,
            lastUpdateTime: player.investmentGame.userData?.lastUpdateTime || Date.now(),
            totalTrades: player.investmentGame.userData?.totalTrades || 0,
            totalVolume: player.investmentGame.userData?.totalVolume || 0,
            totalCommission: player.investmentGame.userData?.totalCommission || 0
        };
        
        // 确保交易数据完整性
        player.investmentGame.tradeData = {
            quantity: player.investmentGame.tradeData?.quantity || 0,
            type: player.investmentGame.tradeData?.type || "buy",
            feeRate: player.investmentGame.tradeData?.feeRate || 0.0048
        };
        
        // 确保游戏状态完整性
        player.investmentGame.gameState = {
            startTime: player.investmentGame.gameState?.startTime || Date.now(),
            marketMood: player.investmentGame.gameState?.marketMood || 0,
            lastMarketEvent: player.investmentGame.gameState?.lastMarketEvent || Date.now(),
            totalMarketEvents: player.investmentGame.gameState?.totalMarketEvents || 0,
            marketTrend: player.investmentGame.gameState?.marketTrend || 0
        };
        
        // 确保统计信息完整性
        player.investmentGame.statistics = {
            totalBuyOrders: player.investmentGame.statistics?.totalBuyOrders || 0,
            totalSellOrders: player.investmentGame.statistics?.totalSellOrders || 0,
            totalProfit: player.investmentGame.statistics?.totalProfit || 0,
            totalLoss: player.investmentGame.statistics?.totalLoss || 0,
            bestTrade: player.investmentGame.statistics?.bestTrade || {
                stockCode: "",
                profit: 0,
                date: 0
            },
            worstTrade: player.investmentGame.statistics?.worstTrade || {
                stockCode: "",
                loss: 0,
                date: 0
            }
        };
        
        // 确保设置选项完整性
        player.investmentGame.settings = {
            autoUpdateChart: player.investmentGame.settings?.autoUpdateChart !== false,
            showPriceBounds: player.investmentGame.settings?.showPriceBounds !== false,
            notificationEnabled: player.investmentGame.settings?.notificationEnabled !== false,
            chartPoints: player.investmentGame.settings?.chartPoints || 100,
            refreshInterval: player.investmentGame.settings?.refreshInterval || 10000
        };
        
        // 确保其他数据完整性
        player.investmentGame.chartHistoryCache = player.investmentGame.chartHistoryCache || {};
        player.investmentGame.offlineData = player.investmentGame.offlineData || {
            lastOfflineUpdate: Date.now()
        };
        
        // 初始化价格边界并修复 NaN/异常价格（新号或坏档）
        player.investmentGame.stocks.forEach(stock => {
            const basePrice = Math.max(0.0001, Number(stock.basePrice) || Number(stock.price) || 10);
            if (!Number.isFinite(stock.price) || stock.price <= 0) stock.price = roundInvestmentPrice(basePrice);
            if (!stock.priceBounds) {
                stock.priceBounds = {
                    min: 0.1,
                    max: 200,
                    support: Math.max(0.5, basePrice * 0.5),
                    resistance: Math.min(150, basePrice * 1.5)
                };
            }
            if (stock.price < stock.priceBounds.min) stock.price = roundInvestmentPrice(stock.priceBounds.min * (1 + Math.random() * 0.5));
            if (stock.price > stock.priceBounds.max) stock.price = roundInvestmentPrice(stock.priceBounds.max * (0.8 + Math.random() * 0.2));
            stock.change = safeChangePercent(stock.price, basePrice);
        });
    }
    
    // 验证价格合理性
    validateStockPrices();
    initPriceHistory();
    logAction('投资游戏数据初始化完成', 'system');
}

// 在游戏加载时初始化投资游戏数据
function initInvestmentGameOnLoad() {
    if (!player.investmentGame) {
        initInvestmentGame();
    }
}

// 在页面加载时调用
window.addEventListener('load', function() {
    // 确保在游戏加载后初始化投资游戏
    if (player) {
        initInvestmentGameOnLoad();
    }
});

// 在游戏保存时包含投资游戏数据
function saveInvestmentGameData() {
    // 投资游戏数据已经包含在player对象中
    // 保存时会自动保存
}

// 在游戏加载时恢复投资游戏数据
// 读档或打开前修复所有股票的 price/change 为有效数，避免 NaN 导致坏档或界面异常
function repairInvestmentGameStockChanges() {
    const game = player.investmentGame;
    if (!game || !Array.isArray(game.stocks)) return;
    game.stocks.forEach(stock => {
        const base = Math.max(0.0001, Number(stock.basePrice) || Number(stock.price) || 10);
        if (!Number.isFinite(stock.price) || stock.price <= 0) stock.price = roundInvestmentPrice(base);
        if (stock.change != null && !Number.isFinite(stock.change)) stock.change = safeChangePercent(stock.price, base);
    });
}
function loadInvestmentGameData() {
    if (player.investmentGame) {
        repairInvestmentGameStockChanges();
        if (document.getElementById('investmentGameUI') && document.getElementById('investmentGameUI').style.display === 'block') {
            startPriceSimulation();
        }
    }
}
  // 房屋配置
        const houseTypes = [
            { id: 1, name: "茅草屋", rarity: 1, baseCost: 10000, income: 10, description: "简陋的茅草屋，提供基本住所" },
            { id: 2, name: "木屋", rarity: 2, baseCost: 50000, income: 50, description: "简单的木屋，比茅草屋舒适" },
            { id: 3, name: "石屋", rarity: 3, baseCost: 100000, income: 100, description: "坚固的石屋，能抵御风雨" },
            { id: 4, name: "砖房", rarity: 4, baseCost: 500000, income: 500, description: "砖砌房屋，更加耐用" },
            { id: 5, name: "别墅", rarity: 5, baseCost: 1000000, income: 1000, description: "豪华别墅，舒适宜居" },
            { id: 6, name: "庄园", rarity: 6, baseCost: 5000000, income: 5000, description: "广阔庄园，带有花园" },
            { id: 7, name: "城堡", rarity: 7, baseCost: 10000000, income: 10000, description: "宏伟城堡，彰显地位" },
            { id: 8, name: "宫殿", rarity: 8, baseCost: 50000000, income: 50000, description: "皇家宫殿，极尽奢华" },
            { id: 9, name: "天空之城", rarity: 9, baseCost: 100000000, income: 100000, description: "悬浮在空中的神奇城市" },
            { id: 10, name: "海底宫殿", rarity: 10, baseCost: 500000000, income: 500000, description: "深海中的神秘宫殿" },
            { id: 11, name: "星际堡垒", rarity: 11, baseCost: 1000000000, income: 1000000, description: "跨越星际的军事堡垒" },
            { id: 12, name: "时间之屋", rarity: 12, baseCost: 5000000000, income: 5000000, description: "能操控时间的奇异房屋" },
            { id: 13, name: "维度别墅", rarity: 13, baseCost: 10000000000, income: 10000000, description: "存在于多个维度的别墅" },
            { id: 14, name: "创世神殿", rarity: 14, baseCost: 50000000000, income: 50000000, description: "创世神居住的神圣殿堂" },
            { id: 15, name: "永恒居所", rarity: 15, baseCost: 100000000000, income: 100000000, description: "超越时间与空间的永恒住所" },
            { id: 16, name: "宇宙宫殿", rarity: 16, baseCost: 1000000000000, income: 250000000, description: "连接多个宇宙的神秘圣殿" },
            { id: 17, name: "星系府邸", rarity: 17, baseCost: 10000000000000, income: 500000000, description: "统领整个星系的宏伟宫殿" },
            { id: 18, name: "无限领域", rarity: 18, baseCost: 100000000000000, income: 750000000, description: "涵盖无限可能性的领域" },
            { id: 19, name: "终极天堂", rarity: 19, baseCost: 1000000000000000, income: 1000000000, description: "超越一切存在的终极居所" },
            { id: 20, name: "起源圣所", rarity: 20, baseCost: 10000000000000000, income: 1250000000, description: "宇宙基本法则的具现化殿堂" },
            { id: 21, name: "法则圣殿", rarity: 21, baseCost: 100000000000000000, income: 1500000000, description: "涵盖无限可能性的领域" },   
            { id: 22, name: "概念之居", rarity: 22, baseCost: 1000000000000000000, income: 1750000000, description: "超越现实与想象的概念住所" },
            { id: 23, name: "真理圣域", rarity: 23, baseCost: 10000000000000000000, income: 2000000000, description: "容纳宇宙终极真理的绝对领域" },
            { id: 24, name: "存在之源", rarity: 24, baseCost: 100000000000000000000, income: 5000000000, description: "一切存在与非存在的最终源头" }          
        ];

        // 初始化房屋系统数据
        function initHouseData() {
            if (!player.houses) {
                player.houses = {
                    level: 1,
                    exp: 0,
                    maxHouses: 5,
                    ownedHouses: [],
                    rentedHouses: [],
                    lastUpdate: Date.now(),
                    totalIncome: 0
                };
            }
        }

        // 切换房屋系统界面
        function toggleHouseSystem() {
            if (player.reincarnationCount < 200) {
                alert("需要达到200转才能开启房屋系统！");
                return;
            }
            
            const ui = document.getElementById('houseSystemUI');
            const overlay = document.getElementById('houseSystemOverlay');
            
            if (ui.style.display === 'block') {
                ui.style.display = 'none';
                overlay.style.display = 'none';
            } else {
                initHouseData();
                ui.style.display = 'block';
                overlay.style.display = 'block';
                updateHouseUI();
            }
        }

        function closeHouseSystem() {
            document.getElementById('houseSystemUI').style.display = 'none';
            document.getElementById('houseSystemOverlay').style.display = 'none';
        }

        // 更新房屋界面
        function updateHouseUI() {
            // 更新基本信息
            document.getElementById('houseLevel').textContent = player.houses.level;
            document.getElementById('houseCount').textContent = player.houses.rentedHouses.length;
            document.getElementById('maxHouses').textContent = player.houses.maxHouses;
            document.getElementById('houseExp').textContent = player.houses.exp.toFixed(1);
            document.getElementById('houseExpNext').textContent = getNextHouseLevelExp();
            document.getElementById('totalHouseIncome').textContent = player.houses.totalIncome.toExponential(1);
            document.getElementById('totalHouseIncoma').textContent = player.investmentGame.userData.availableFunds.toFixed(0);
            // 更新房屋商店
            updateHouseStore();
            
            // 更新房屋列表
            updateHouseList();
            
            // 更新房屋槽位显示
            updateHouseSlots();
            
            // 更新分解界面
            updateDecomposeHouseUI();
        }

        // 获取下一级所需经验
        function getNextHouseLevelExp() {
            const expRequirements = [100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000, 50000000, 100000000, 500000000, 1000000000, 5000000000, 10000000000, 50000000000, 100000000000, 1000000000000000000];
            const currentLevel = Math.min(player.houses.level, expRequirements.length);
            return expRequirements[currentLevel - 1] || expRequirements[expRequirements.length - 1];
        }

        // 更新房屋商店
        function updateHouseStore() {
            const container = document.getElementById('houseStore');
            container.innerHTML = '';
            
            houseTypes.forEach(houseType => {
                const houseCard = document.createElement('div');
                houseCard.className = `house-card house-${getHouseRarityClass(houseType.rarity)}`;
                
                houseCard.innerHTML = `
                    <div style="font-weight: bold;">${houseType.name}</div>
                    <div style="font-size: 0.8em; margin: 5px 0;">${houseType.description}</div>
                    <div style="font-size: 0.8em;">稀有度: ${houseType.rarity}</div>
                    <div style="font-size: 0.8em; color: #FFD700;">收益: ${houseType.income}/小时</div>
                    <div style="font-size: 0.8em; color: #32CD32;">价格: ${houseType.baseCost.toLocaleString()} 资金</div>
                    <button onclick="buyHouse(${houseType.id})" style="margin-top: 10px; background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; width: 100%;">购买</button>
                `;
                
                container.appendChild(houseCard);
            });
        }

        // 根据稀有度获取CSS类名
        function getHouseRarityClass(rarity) {
            if (rarity <= 3) return 'common';
            if (rarity <= 6) return 'rare';
            if (rarity <= 9) return 'epic';
            if (rarity <= 12) return 'legendary';
            return 'mythic';
        }

        // 购买房屋
        function buyHouse(houseId) {
            const houseType = houseTypes.find(h => h.id === houseId);
            
            if (!houseType) {
                logAction("无效的房屋类型", "error");
                return;
            }
            
            if (player.investmentGame.userData.availableFunds < houseType.baseCost) {
                logAction(`资金不足！需要 ${houseType.baseCost.toLocaleString()} 资金`, "error");
                return;
            }
            
            // 扣除转生币
            player.investmentGame.userData.availableFunds -= houseType.baseCost;
            
            // 创建房屋实例
            const newHouse = {
                id: 'house_' + Date.now(),
                type: houseType.id,
                name: houseType.name,
                rarity: houseType.rarity,
                baseIncome: houseType.income,
                rentTime: 0,
                isRented: false
            };
            
            // 添加到拥有的房屋列表
            player.houses.ownedHouses.push(newHouse);
            
            logAction(`成功购买了 ${houseType.name}！`, "success");
            updateHouseUI();
            updateDisplay();
            saveGame();
        }

        // 更新房屋列表
        function updateHouseList() {
            const container = document.getElementById('houseList');
            container.innerHTML = '';
            
            if (player.houses.ownedHouses.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">尚未购买任何房屋</div>';
                return;
            }
            
            player.houses.ownedHouses.forEach((house, index) => {
                const houseCard = document.createElement('div');
                houseCard.className = `house-card house-${getHouseRarityClass(house.rarity)}`;
                houseCard.style.cursor = 'pointer';
                houseCard.dataset.index = index;
                
                houseCard.innerHTML = `
                    <div style="font-weight: bold;">${house.name}</div>
                    <div style="font-size: 0.8em; margin: 5px 0;">稀有度: ${house.rarity}</div>
                    <div style="font-size: 0.8em; color: #FFD700;">收益: ${house.baseIncome}/小时</div>
                    <div style="font-size: 0.8em; color: ${house.isRented ? '#4CAF50' : '#f44336'};">${house.isRented ? '已出租' : '未出租'}</div>
                `;
                
                // 点击房屋进行出租操作
                houseCard.onclick = function() {
                    rentHouse(index);
                };
                
                container.appendChild(houseCard);
            });
        }

        // 出租房屋
        function rentHouse(houseIndex) {
            // 检查是否有空闲房屋槽位
            if (player.houses.rentedHouses.length >= player.houses.maxHouses) {
                logAction("没有空闲房屋槽位了！", "error");
                return;
            }
            
            const house = player.houses.ownedHouses[houseIndex];
            
            // 将房屋移动到出租列表
            player.houses.rentedHouses.push({
                ...house,
                rentTime: Date.now(),
                isRented: true
            });
            
            // 从拥有列表中移除
            player.houses.ownedHouses.splice(houseIndex, 1);
            
            logAction(`已将 ${house.name} 出租`, "success");
            updateHouseUI();
            saveGame();
        }

        // 更新房屋槽位显示
        function updateHouseSlots() {
            const container = document.getElementById('houseSlotsContainer');
            container.innerHTML = '';
            
            // 创建房屋槽位卡片
            for (let i = 0; i < player.houses.maxHouses; i++) {
                const slotCard = document.createElement('div');
                slotCard.className = 'house-slot';
                slotCard.style.border = '1px solid #ddd';
                slotCard.style.padding = '10px';
                slotCard.style.borderRadius = '5px';
                slotCard.style.textAlign = 'center';
                
                if (i < player.houses.rentedHouses.length) {
                    const house = player.houses.rentedHouses[i];
                    slotCard.innerHTML = `
                        <div style="font-weight: bold;">${house.name}</div>
                        <div>收益: ${calculateHouseIncome(house)} 资金</div>
                        <div>经验: ${calculateHouseIncome(house) / 1000} 经验值</div>
                        <button onclick="stopRentingHouse(${i})" style="margin-top: 10px; background: #ff9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">停止出租</button>
                    `;
                } else {
                    slotCard.innerHTML = '<div>空闲房屋槽位</div>';
                }
                
                container.appendChild(slotCard);
            }
        }

        // 计算房屋收益
        function calculateHouseIncome(house) {
            // 收益 = 房屋基础收益 * 出租时间(小时)
            const hoursRented = (Date.now() - house.rentTime) / (1000 * 60 * 60);
            return Math.floor(house.baseIncome * hoursRented);
        }

        // 停止出租房屋
        function stopRentingHouse(slotIndex) {
            if (slotIndex >= player.houses.rentedHouses.length) return;
            
            // 获取房屋信息
            const house = player.houses.rentedHouses[slotIndex];
            
            // 将房屋移回拥有列表
            player.houses.ownedHouses.push({
                ...house,
                isRented: false
            });
            
            // 从出租列表移除
            player.houses.rentedHouses.splice(slotIndex, 1);
            
            // 计算并收取收益
            const income = calculateHouseIncome(house);
            player.investmentGame.userData.availableFunds += income;
            player.houses.totalIncome += income;
            player.houses.exp += income / 1000;
            
            logAction(`停止出租: ${house.name}, 获得收益 ${income} 资金`, 'success');
            updateHouseUI();
            updateDisplay();
            saveGame();
        }

        // 一键出租
        function rentAllHouses() {
            // 计算可出租数量
            const availableSlots = player.houses.maxHouses - player.houses.rentedHouses.length;
            const housesToRent = Math.min(availableSlots, player.houses.ownedHouses.length);
            
            if (housesToRent === 0) {
                logAction("没有可出租的房屋或没有空闲槽位", "info");
                return;
            }
            
            // 出租操作
            for (let i = 0; i < housesToRent; i++) {
                const house = player.houses.ownedHouses[0];
                player.houses.rentedHouses.push({
                    ...house,
                    rentTime: Date.now(),
                    isRented: true
                });
                player.houses.ownedHouses.shift();
            }
            
            logAction(`已自动出租 ${housesToRent} 间房屋`, "success");
            updateHouseUI();
            saveGame();
        }

        // 收取所有房屋收益
        function collectAllHouseIncome() {
            let totalIncome = 0;
            
            player.houses.rentedHouses.forEach(house => {
                const income = calculateHouseIncome(house);
                totalIncome += income;
                
                // 添加房屋经验
                player.houses.exp += income / 1000;
                
                // 重置出租时间
                house.rentTime = Date.now();
            });
            
            // 添加收益
            player.investmentGame.userData.availableFunds += totalIncome;
            player.houses.totalIncome += totalIncome;
            
            logAction(`收取了所有房屋收益: ${totalIncome} 资金`, "success");
            updateHouseUI();
            updateDisplay();
            saveGame();
        }

        // 房屋分解功能
        function updateDecomposeHouseUI() {
            const container = document.getElementById('decomposeHouseContainer');
            container.innerHTML = '';
            
            if (player.houses.ownedHouses.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">没有可分解的房屋</div>';
                return;
            }
            
            // 添加拥有的房屋
            player.houses.ownedHouses.forEach((house, index) => {
                const houseDiv = document.createElement('div');
                houseDiv.className = `decompose-house-item house-${getHouseRarityClass(house.rarity)}`;
                houseDiv.style.display = 'flex';
                houseDiv.style.alignItems = 'center';
                houseDiv.style.justifyContent = 'space-between';
                houseDiv.style.marginBottom = '10px';
                houseDiv.style.padding = '10px';
                houseDiv.style.background = '#444';
                houseDiv.style.borderRadius = '5px';
                
                const decomposeValue = house.rarity * 5000;
                
                houseDiv.innerHTML = `
                    <div style="display: flex; align-items: center; flex: 1;">
                        <input type="checkbox" id="houseCheckbox${index}" 
                               style="margin-right: 10px; width: 16px; height: 16px;">
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 14px;">
                                ${house.name}
                            </div>
                            <div style="font-size: 12px; color: #ccc;">
                                稀有度: ${house.rarity}
                            </div>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 12px; color: #FFD700;">
                            价值: ${decomposeValue.toLocaleString()}
                        </div>
                        <div style="font-size: 10px; color: #888;">
                            资金
                        </div>
                    </div>
                `;
                
                container.appendChild(houseDiv);
            });
        }

        // 按稀有度批量选择房屋
        function selectHousesByRarity(maxRarity) {
            player.houses.ownedHouses.forEach((house, index) => {
                const checkbox = document.getElementById(`houseCheckbox${index}`);
                if (checkbox) {
                    checkbox.checked = house.rarity <= maxRarity;
                }
            });
            logAction(`已选择稀有度${maxRarity}及以下的房屋`, "info");
        }

        // 全选房屋
        function selectAllHouses() {
            player.houses.ownedHouses.forEach((house, index) => {
                const checkbox = document.getElementById(`houseCheckbox${index}`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            logAction("已选择所有房屋", "info");
        }

        // 取消全选
        function deselectAllHouses() {
            player.houses.ownedHouses.forEach((house, index) => {
                const checkbox = document.getElementById(`houseCheckbox${index}`);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            logAction("已取消选择所有房屋", "info");
        }

        // 分解选中房屋
        function decomposeSelectedHouse() {
            const housesToDecompose = [];
            
            // 收集选中的房屋
            player.houses.ownedHouses.forEach((house, index) => {
                const checkbox = document.getElementById(`houseCheckbox${index}`);
                if (checkbox && checkbox.checked) {
                    housesToDecompose.push({
                        index,
                        house
                    });
                }
            });
            
            if (housesToDecompose.length === 0) {
                logAction("请选择要分解的房屋", "error");
                return;
            }
            
            // 计算总收益和显示信息
            let totalValue = 0;
            let houseList = "";
            
            housesToDecompose.forEach(item => {
                totalValue += item.house.rarity * 5000;
                houseList += `\n${item.house.name} (稀有度${item.house.rarity})`;
            });
            
            // 显示确认对话框
            showCustomConfirm(`确定要分解以下 ${housesToDecompose.length} 间房屋吗？${houseList}\n\n总计可获得: ${totalValue.toLocaleString()} 资金`,
                (confirmed) => {
                    if (confirmed) {
                        // 从高索引到低索引删除，避免索引变化问题
                        housesToDecompose.sort((a, b) => b.index - a.index);
                        housesToDecompose.forEach(item => {
                            player.houses.ownedHouses.splice(item.index, 1);
                        });
                        
                        // 添加收益
                        player.investmentGame.userData.availableFunds += totalValue;
                        
                        logAction(`分解了 ${housesToDecompose.length} 间房屋，获得 ${totalValue.toLocaleString()} 资金`, "success");
                        updateHouseUI();
                        updateDisplay();
                        saveGame();
                    }
                }
            );
        }

        // 升级房屋系统
        function upgradeHouseSystem() {
            const requiredExp = getNextHouseLevelExp();
            
            if (player.houses.exp < requiredExp) {
                logAction(`经验不足！需要 ${requiredExp} 经验`, "error");
                return;
            }
            
            // 扣除经验
            player.houses.exp -= requiredExp;
            
            // 升级
            player.houses.level++;
            player.houses.maxHouses++;
            
            logAction(`房屋系统升级到 ${player.houses.level} 级！最大房屋槽位增加到 ${player.houses.maxHouses}`, "success");
            updateHouseUI();
            saveGame();
        }

        // 计算离线房屋收益
        function calculateOfflineHouseIncome() {
            if (!player.houses || !player.houses.rentedHouses) return;
            
            const now = Date.now();
            const elapsed = now - player.houses.lastUpdate;
            
            player.houses.rentedHouses.forEach(house => {
                const income = house.baseIncome * (elapsed / (1000 * 60 * 60)); // 每小时收益
                player.houses.totalIncome += income;
                player.houses.exp += income / 1000;
            });
            
            player.houses.lastUpdate = now;
        }

        // 在游戏加载时初始化房屋数据
        function initHouseSystemOnLoad() {
            if (!player.houses) {
                player.houses = {
                    level: 1,
                    exp: 0,
                    maxHouses: 5,
                    ownedHouses: [],
                    rentedHouses: [],
                    lastUpdate: Date.now(),
                    totalIncome: 0
                };
            } else {
                // 计算离线收益
                calculateOfflineHouseIncome();
            }
        }
 function addHouseSystemToGameLoop() {
            // 在现有的游戏循环中添加房屋收益计算
            registerInterval(() => {
                if (player.houses && player.houses.rentedHouses.length > 0) {
                    // 每秒计算一次收益（实际收益按小时计算，这里只是累加）
                    const incomePerSecond = player.houses.rentedHouses.reduce((sum, house) => 
                        sum + house.baseIncome / 3600, 0
                    );
                    
                    player.investmentGame.userData.availableFunds += incomePerSecond;
                    player.houses.totalIncome += incomePerSecond;
                    player.houses.exp += incomePerSecond / 1000;
                    
                    // 每10秒更新一次UI（避免过于频繁的更新）
                    if (Math.floor(Date.now() / 1000) % 10 === 0) {
                        updateHouseUI();
                    }
                }
            }, 1000);
        }
function initMarriageData() {
    if (!player.marriage) {
        player.marriage = {
            isMarried: false,
            spouseName: "",
            spouseGender: "female",
            marriageDate: null,
            loveLevel: 1,
            loveExp: 0,
            totalGifts: 0,
            totalTimeSpent: 0,
           totalAimeSpent: 0,
            marriageBonuses: {
                gpsMultiplier: 1.0,
                clickMultiplier: 1.0,
                critRateBonus: 0,
                critDamageBonus: 0
            }
        };
    }
}

// 切换结婚系统界面
function toggleMarriageSystem() {
    if (player.investmentGame.userData.totalAssets < 50000) {
        alert("需要资金总额达到5W才能开启结婚系统！");
        return;
    }
    
    const ui = document.getElementById('marriageSystemUI');
    const overlay = document.getElementById('marriageSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initMarriageData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateMarriageUI();
    }
}

function closeMarriageSystem() {
    document.getElementById('marriageSystemUI').style.display = 'none';
    document.getElementById('marriageSystemOverlay').style.display = 'none';
}

// 更新结婚系统UI
function updateMarriageUI() {
    const marriage = player.marriage;
    
    // 更新配偶信息
    if (marriage.isMarried) {
        document.getElementById('spouseInfo').innerHTML = `
            <div>配偶: ${marriage.spouseName}</div>
            <div>性别: ${marriage.spouseGender === 'male' ? '男性' : '女性'}</div>
            <div>结婚日期: ${new Date(marriage.marriageDate).toLocaleDateString()}</div>
            <div>恩爱等级: ${marriage.loveLevel}${marriage.loveLevel >= 999 ? " (MAX)" : ""}</div>
            <div>恩爱经验: ${marriage.loveExp}/${getLoveExpRequired(marriage.loveLevel)}</div>
            <div>赠送礼物次数: ${marriage.totalGifts}</div>
            <div>共度时光次数: ${marriage.totalTimeSpent}</div>
            <div>全国旅行次数: ${marriage.totalAimeSpent}</div>
        `;
        
        // 隐藏求婚界面，显示互动界面
        document.getElementById('proposalSection').style.display = 'none';
        document.getElementById('marriageInteraction').style.display = 'block';
    } else {
        document.getElementById('spouseInfo').innerHTML = '<div>当前单身</div>';
        document.getElementById('proposalSection').style.display = 'block';
        document.getElementById('marriageInteraction').style.display = 'none';
    }
    
    // 更新加成信息
    updateMarriageBonuses();
}

// 求婚功能
function proposeMarriage() {
    const spouseName = document.getElementById('spouseNameInput').value.trim();
    const spouseGender = document.getElementById('spouseGenderSelect').value;
    
    if (!spouseName) {
        logAction("请输入伴侣名字", "error");
        return;
    }
    
    if (spouseName.length > 10) {
        logAction("伴侣名字不能超过10个字符", "error");
        return;
    }
    
    if (player.investmentGame.userData.availableFunds < 388888) {
        logAction("资金不足！需要38.8888W元彩礼", "error");
        return;
    }
    
    // 扣除转生币
    player.investmentGame.userData.availableFunds -= 388888;
    
    // 设置婚姻状态
    player.marriage.isMarried = true;
    player.marriage.spouseName = spouseName;
    player.marriage.spouseGender = spouseGender;
    player.marriage.marriageDate = Date.now();
    player.marriage.loveLevel = 1;
    player.marriage.loveExp = 0;
    
    logAction(`恭喜！您与 ${spouseName} 结婚了！`, "success");
    updateMarriageUI();
    updateDisplay();
    saveGame();
}

// 赠送礼物
function giveGiftToSpouse() {
    if (!player.marriage.isMarried) return;
    
    // 检查等级上限
    if (player.marriage.loveLevel >= 999) {
        logAction("恩爱等级已达上限(999级)，无法继续提升", "info");
        return;
    }
    
    if (player.investmentGame.userData.availableFunds < 1314) {
        logAction("资金不足！需要1314元", "error");
        return;
    }
    
    // 扣除资金
    player.investmentGame.userData.availableFunds -= 1314;
    
    // 增加恩爱经验
    const expGain = 100;
    player.marriage.loveExp += expGain;
    player.marriage.totalGifts++;
    
    // 检查是否升级
    checkLoveLevelUp();
    
    logAction(`您向 ${player.marriage.spouseName} 赠送了礼物，恩爱经验+${expGain}`, "success");
    updateMarriageUI();
    updateDisplay();
    saveGame();
}

// 共度时光
function spendTimeWithSpouse() {
    if (!player.marriage.isMarried) return;
    
    // 检查等级上限
    if (player.marriage.loveLevel >= 999) {
        logAction("恩爱等级已达上限(999级)，无法继续提升", "info");
        return;
    }
    
    if (player.investmentGame.userData.availableFunds < 99999) {
        logAction("资金不足！需要99999元", "error");
        return;
    }
    
    // 扣除转生币
    player.investmentGame.userData.availableFunds -= 99999;
    
    // 增加恩爱经验
    const expGain = 7000;
    player.marriage.loveExp += expGain;
    player.marriage.totalTimeSpent++;
    
    // 检查是否升级
    checkLoveLevelUp();
    
    logAction(`您与 ${player.marriage.spouseName} 共度了美好时光，恩爱经验+${expGain}`, "success");
    updateMarriageUI();
    updateDisplay();
    saveGame();
}

// 全国旅行
function spendAimeWithSpouse() {
    if (!player.marriage.isMarried) return;
    
    // 检查等级上限
    if (player.marriage.loveLevel >= 999) {
        logAction("恩爱等级已达上限(999级)，无法继续提升", "info");
        return;
    }
    
    if (player.marriage.loveLevel < 20) {
        alert("需要结婚等级20级！");
        return;
    }
    
    if (player.investmentGame.userData.availableFunds < 5201314) {
        logAction("资金不足！需要5201314元", "error");
        return;
    }
    
    // 扣除转生币
    player.investmentGame.userData.availableFunds -= 5201314;
    
    // 增加恩爱经验
    const expGain = 370000;
    player.marriage.loveExp += expGain;
    player.marriage.totalAimeSpent++;
    
    // 检查是否升级
    checkLoveLevelUp();
    
    logAction(`您与 ${player.marriage.spouseName} 全国旅行，恩爱经验+${expGain}`, "success");
    updateMarriageUI();
    updateDisplay();
    saveGame();
}

// 离婚
function divorce() {
    if (!player.marriage.isMarried) return;
    
    showCustomConfirm(`确定要与 ${player.marriage.spouseName} 离婚吗？这将失去所有婚姻加成！`, (confirmed) => {
        if (confirmed) {
            const spouseName = player.marriage.spouseName;
            
            // 重置婚姻状态
            player.marriage.isMarried = false;
            player.marriage.spouseName = "";
            player.marriage.marriageDate = null;
            player.marriage.loveLevel = 1;
            player.marriage.loveExp = 0;
            player.marriage.totalGifts = 0;
            player.marriage.totalTimeSpent = 0;
            player.marriage.totalAimeSpent = 0;
            logAction(`您与 ${spouseName} 离婚了`, "info");
            updateMarriageUI();
            updateDisplay();
            saveGame();
        }
    });
}

// 重命名伴侣
function renameSpouse() {
    if (!player.marriage.isMarried) return;
    
    showCustomPrompt(`请输入新的伴侣名字（当前: ${player.marriage.spouseName}）:`, (newName) => {
        if (newName && newName.trim()) {
            const oldName = player.marriage.spouseName;
            player.marriage.spouseName = newName.trim();
            
            logAction(`已将伴侣名字从 ${oldName} 改为 ${newName}`, "success");
            updateMarriageUI();
            saveGame();
        }
    });
}

// 恩爱等级系统
function getLoveExpRequired(level) {
    // 999级为上限
    if (level >= 999) {
        return "∞";
    }
    
    // 动态经验公式：每级需求逐渐增加
    const baseExp = 1000;
    const growthFactor = 1.1; // 每级增加10%需求
    return Math.floor(baseExp * Math.pow(growthFactor, level - 1));
}

function checkLoveLevelUp() {
    const marriage = player.marriage;
    
    // 检查是否已达上限
    if (marriage.loveLevel >= 999) {
        marriage.loveExp = 0;
        return;
    }
    
    let expRequired = getLoveExpRequired(marriage.loveLevel);
    
    while (marriage.loveExp >= expRequired && marriage.loveLevel < 9999) {
        marriage.loveExp -= expRequired;
        marriage.loveLevel++;
        
        logAction(`恩爱等级提升到 ${marriage.loveLevel} 级！`, "success");
        
        // 达到上限时提示
        if (marriage.loveLevel >= 999) {
            logAction("恭喜！恩爱等级已达上限(999级)！", "success");
            marriage.loveExp = 0;
            break;
        }
        
        expRequired = getLoveExpRequired(marriage.loveLevel);
        
        // 更新婚姻加成
        updateMarriageBonuses();
    }
}

// 更新婚姻加成
function updateMarriageBonuses() {
    const marriage = player.marriage;
    const level = marriage.loveLevel;
    
    // 根据恩爱等级计算加成
    marriage.marriageBonuses = {
        gpsMultiplier: 1 + (level * 1), // 每级增加100% GPS
        clickMultiplier: 1 + (level * 0.5), // 每级增加50% 点击
        critRateBonus: 1 + (level * 1), // 每级增加100% 生命
        critDamageBonus: 1 + (level * 0.5) // 每级增加50% 爆伤
    };
    
    // 更新UI显示
    const bonusInfo = document.getElementById('bonusInfo');
    if (bonusInfo) {
        const isMaxLevel = level >= 999;
        bonusInfo.innerHTML = `
            <div>GPS加成: +${((marriage.marriageBonuses.gpsMultiplier - 1) * 100).toFixed(1)}%${isMaxLevel ? " (MAX)" : ""}</div>
            <div>点击加成: +${((marriage.marriageBonuses.clickMultiplier - 1) * 100).toFixed(1)}%${isMaxLevel ? " (MAX)" : ""}</div>
            <div>生命: +${(marriage.marriageBonuses.critRateBonus * 100).toFixed(2)}%${isMaxLevel ? " (MAX)" : ""}</div>
            <div>爆伤: +${(marriage.marriageBonuses.critDamageBonus * 100).toFixed(1)}%${isMaxLevel ? " (MAX)" : ""}</div>
        `;
    }
}

function addMarriageSystemToGameLoop() {
    registerInterval(() => {
        if (player.marriage && player.marriage.isMarried) {
            // 每分钟自动增加少量恩爱经验（离线收益）
            const now = Date.now();
            const lastUpdate = player.marriage.lastUpdate || now;
            const minutesPassed = Math.floor((now - lastUpdate) / (1000 * 60));
            
            if (minutesPassed > 0) {
                // 达到上限时不增加经验
                if (player.marriage.loveLevel < 999) {
                    player.marriage.loveExp += minutesPassed * player.marriage.loveLevel;
                    player.marriage.lastUpdate = now;
                    
                    // 检查是否升级
                    checkLoveLevelUp();
                    
                    // 每10分钟保存一次
                    if (minutesPassed % 10 === 0) {
                        saveGame();
                    }
                }
            }
            
            // 检查成就
            checkMarriageAchievements();
        }
    }, 60000); // 每分钟检查一次
}

function initMarriageSystem() {
    if (!player.marriage) {
        player.marriage = {
            isMarried: false,
            spouseName: "",
            spouseGender: "female",
            marriageDate: null,
            loveLevel: 1,
            loveExp: 0,
            totalGifts: 0,
            totalTimeSpent: 0,
            totalAimeSpent: 0,
            lastUpdate: Date.now(),
            marriageBonuses: {
                gpsMultiplier: 1.0,
                clickMultiplier: 1.0,
                critRateBonus: 0,
                critDamageBonus: 0,
                multiAttackBonus: 0
            }
        };
    }
    
    // 启动婚姻系统循环
    addMarriageSystemToGameLoop();
}

// 新增：检查是否达到等级上限的函数
function isMaxLoveLevel() {
    return player.marriage && player.marriage.isMarried && player.marriage.loveLevel >= 999;
}
// 宝物配置
const treasureConfig = [
    { id: 1, name: "青铜古剑", rarity: 1, baseValue: 200, description: "古老的青铜剑，散发着历史的气息", color: "#CD7F32" },
    { id: 2, name: "翡翠玉佩", rarity: 2, baseValue: 5000, description: "晶莹剔透的翡翠，蕴含着神秘力量", color: "#32CD32" },
    { id: 3, name: "夜明珠", rarity: 3, baseValue: 50000, description: "夜晚能发出柔和光芒的宝珠", color: "#87CEEB" },
    { id: 4, name: "龙纹宝鼎", rarity: 4, baseValue: 100000, description: "刻有龙纹的神秘宝鼎，传说能炼化万物", color: "#FF4500" },
    { id: 5, name: "凤凰羽扇", rarity: 5, baseValue: 1000000, description: "用凤凰羽毛制成的扇子，轻轻一扇可呼风唤雨", color: "#FF1493" },
    { id: 6, name: "麒麟角", rarity: 6, baseValue: 5000000, description: "神兽麒麟的角，蕴含着强大的生命力量", color: "#9400D3" },
    { id: 7, name: "玄武甲", rarity: 7, baseValue: 10000000, description: "神兽玄武的甲壳，坚不可摧", color: "#008080" },
    { id: 8, name: "白虎牙", rarity: 8, baseValue: 50000000, description: "神兽白虎的牙齿，锋利无比", color: "#F5F5F5" },
    { id: 9, name: "朱雀羽", rarity: 9, baseValue: 100000000, description: "神兽朱雀的羽毛，燃烧着永恒火焰", color: "#DC143C" },
    { id: 10, name: "青龙鳞", rarity: 10, baseValue: 5201314, description: "彩礼青龙鳞，象征爱情结晶", color: "#1E90FF" }
];

// 初始化宝物数据
function initTreasureData() {
    if (!player.treasures) {
        player.treasures = {
            inventory: [],
            totalFound: 0,
            totalSold: 0,
            foundCount: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 确保10个元素的数组
            soldCount: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        };
    } else {
        // 确保数组长度正确
        if (!player.treasures.foundCount || player.treasures.foundCount.length < 10) {
            player.treasures.foundCount = new Array(10).fill(0);
        }
        if (!player.treasures.soldCount || player.treasures.soldCount.length < 10) {
            player.treasures.soldCount = new Array(10).fill(0);
        }
        if (!player.treasures.inventory) {
            player.treasures.inventory = [];
        }
    }
}

// 切换宝物系统界面
function toggleTreasureSystem() {
    const ui = document.getElementById('treasureSystemUI');
    const overlay = document.getElementById('treasureSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initTreasureData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateTreasureUI();
    }
}

function closeTreasureSystem() {
    document.getElementById('treasureSystemUI').style.display = 'none';
    document.getElementById('treasureSystemOverlay').style.display = 'none';
}

// 挖矿时有1%几率获得宝物
function checkTreasureDrop() {
    try {
        // 确保宝物系统已初始化
        if (!player.treasures) {
            initTreasureData();
        }
        
        // 1%几率获得宝物
        if (Math.random() < 0.01) {
            const treasure = getRandomTreasure();
            if (treasure) {
                addTreasureToInventory(treasure.id);
                logAction(`🎉 挖矿时发现了宝物：${treasure.name}！`, "success");
                return true; // 成功获得宝物
            }
        }
        return false; // 未获得宝物
    } catch (error) {
        console.error('宝物掉落错误详情:', error);
        logAction("宝物掉落出现错误，请检查控制台", "error");
        return false;
    }
}

// 获取随机宝物（稀有度越高的宝物几率越低）
function getRandomTreasure() {
    try {
        const rand = Math.random();
        let rarity;
        
        // 根据概率分布确定稀有度
    if (rand < 0.85) rarity = 1;        // 85% 几率获得1级宝物
else if (rand < 0.954) rarity = 2;  // 10.4% 几率获得2级宝物
else if (rand < 0.9893) rarity = 3; // 3.53% 几率获得3级宝物
else if (rand < 0.9993334) rarity = 4; // 1.0034% 几率获得4级宝物
else if (rand < 0.9993834) rarity = 5; // 0.05% 几率获得5级宝物
else if (rand < 0.9993934) rarity = 6; // 0.01% 几率获得6级宝物
else if (rand < 0.9993984) rarity = 7; // 0.005% 几率获得7级宝物
else if (rand < 0.9993994) rarity = 8; // 0.001% 几率获得8级宝物
else if (rand < 0.9993999) rarity = 9; // 0.0005% 几率获得9级宝物
else rarity = 10;                     // 0.0001% 几率获得10级宝物                 
        
        // 获取该稀有度的所有宝物
        const availableTreasures = treasureConfig.filter(t => t.rarity === rarity);
        
        if (availableTreasures.length === 0) {
            console.warn(`没有找到稀有度为 ${rarity} 的宝物`);
            // 如果该稀有度没有宝物，返回最低稀有度的宝物
            return treasureConfig[0];
        }
        
        const selectedTreasure = availableTreasures[Math.floor(Math.random() * availableTreasures.length)];
        console.log(`获得宝物: ${selectedTreasure.name}, 稀有度: ${selectedTreasure.rarity}`);
        return selectedTreasure;
        
    } catch (error) {
        console.error('获取随机宝物错误:', error);
        // 出错时返回默认的第一个宝物
        return treasureConfig[0];
    }
}
// 添加宝物到库存
function addTreasureToInventory(treasureId) {
    try {
        // 验证宝物ID
        if (!treasureId || treasureId < 1 || treasureId > 10) {
            console.error('无效的宝物ID:', treasureId);
            return false;
        }
        
        const treasure = treasureConfig.find(t => t.id === treasureId);
        if (!treasure) {
            console.error('未找到ID为', treasureId, '的宝物');
            return false;
        }
        
        // 确保inventory数组存在
        if (!player.treasures.inventory) {
            player.treasures.inventory = [];
        }
        
        // 检查是否已拥有该宝物
        let existingTreasure = null;
        for (let i = 0; i < player.treasures.inventory.length; i++) {
            if (player.treasures.inventory[i].id === treasureId) {
                existingTreasure = player.treasures.inventory[i];
                break;
            }
        }
        
        if (existingTreasure) {
            // 增加数量
            existingTreasure.quantity = (existingTreasure.quantity || 0) + 1;
        } else {
            // 添加新宝物
            player.treasures.inventory.push({
                id: treasureId,
                quantity: 1,
                foundDate: Date.now()
            });
        }
        
        // 更新统计
        player.treasures.totalFound = (player.treasures.totalFound || 0) + 1;
        
        // 确保统计数组存在
        if (!player.treasures.foundCount) {
            player.treasures.foundCount = new Array(10).fill(0);
        }
        if (!player.treasures.soldCount) {
            player.treasures.soldCount = new Array(10).fill(0);
        }
        
        // 更新找到次数统计
        player.treasures.foundCount[treasureId - 1] = (player.treasures.foundCount[treasureId - 1] || 0) + 1;
        
    
        
        // 保存游戏
        saveGame();
        
        // 更新UI
        updateTreasureUI();
        
        return true;
        
    } catch (error) {
        console.error('添加宝物到库存错误:', error);
        logAction("添加宝物失败", "error");
        return false;
    }
}
function showTreasureNotification() {
    try {
        // 简单的视觉反馈
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: black;
            padding: 20px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            z-index: 10000;
            animation: treasurePop 0.5s ease-out;
        `;
        notification.innerHTML = '🎉 发现宝物！';
        
        document.body.appendChild(notification);
        
        // 添加动画
        const style = document.createElement('style');
        style.textContent = `
            @keyframes treasurePop {
                0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                70% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
        `;
        document.head.appendChild(style);
        
        // 2秒后移除通知
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
            if (style.parentNode) {
                style.parentNode.removeChild(style);
            }
        }, 1000);
        
    } catch (error) {
        console.error('显示宝物通知错误:', error);
    }
}

// 更新宝物系统UI
function updateTreasureUI() {
    // 安全初始化数据
    if (!player.treasures) {
        initTreasureData();
    }
    
    // 更新统计信息
    const totalTreasures = player.treasures.inventory ? 
        player.treasures.inventory.reduce((sum, t) => sum + (t.quantity || 0), 0) : 0;
    
    const totalValue = player.treasures.inventory ? 
        player.treasures.inventory.reduce((sum, t) => {
            const treasure = treasureConfig.find(tc => tc.id === t.id);
            return sum + (treasure ? treasure.baseValue * (t.quantity || 0) : 0);
        }, 0) : 0;
    
    document.getElementById('totalTreasures').textContent = formatNumber(totalTreasures);
    document.getElementById('totalTreasureValue').textContent = formatNumber(totalValue);
    document.getElementById('totalSoldValue').textContent = formatNumber(player.treasures.totalSold || 0);
    
    // 更新各个显示区域
    updateTreasureCollection();
    updateSellList();
    updateTreasureEncyclopedia();
    
    // 更新按钮状态
    updateTreasureButtons();
}
function updateTreasureButtons() {
    const hasTreasures = player.treasures.inventory && 
        player.treasures.inventory.some(t => t.quantity > 0);
    
    const sellAllBtn = document.querySelector('button[onclick="sellAllTreasures()"]');
    const selectAllBtn = document.querySelector('button[onclick="selectAllTreasures()"]');
    const deselectAllBtn = document.querySelector('button[onclick="deselectAllTreasures()"]');
    
    if (sellAllBtn) {
        sellAllBtn.disabled = !hasTreasures;
        sellAllBtn.style.opacity = hasTreasures ? '1' : '0.5';
    }
    
    if (selectAllBtn) {
        selectAllBtn.disabled = !hasTreasures;
        selectAllBtn.style.opacity = hasTreasures ? '1' : '0.5';
    }
    
    if (deselectAllBtn) {
        deselectAllBtn.disabled = !hasTreasures;
        deselectAllBtn.style.opacity = hasTreasures ? '1' : '0.5';
    }
}
// 更新宝物收藏显示
function updateTreasureCollection() {
    const container = document.getElementById('treasureCollection');
    container.innerHTML = '';
    
    // 检查是否有宝物
    if (!player.treasures || !player.treasures.inventory || player.treasures.inventory.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px; font-size: 14px;">尚未发现任何宝物<br><small>继续挖矿有几率获得宝物</small></div>';
        return;
    }
    
    // 过滤掉数量为0的宝物
    const validTreasures = player.treasures.inventory.filter(t => t.quantity > 0);
    
    if (validTreasures.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px; font-size: 14px;">宝物已售罄<br><small>继续挖矿可以获得更多宝物</small></div>';
        return;
    }
    
    validTreasures.forEach(treasureItem => {
        const treasure = treasureConfig.find(t => t.id === treasureItem.id);
        if (!treasure) return;
        
        const treasureCard = document.createElement('div');
        treasureCard.className = 'treasure-card';
        treasureCard.style.background = '#444';
        treasureCard.style.border = `2px solid ${treasure.color}`;
        treasureCard.style.borderRadius = '5px';
        treasureCard.style.padding = '10px';
        treasureCard.style.textAlign = 'center';
        treasureCard.style.minHeight = '80px';
        
        treasureCard.innerHTML = `
            <div style="font-weight: bold; color: ${treasure.color}; font-size: 14px; margin-bottom: 5px;">${treasure.name}</div>
            <div style="font-size: 12px; color: #ccc; margin-bottom: 3px;">稀有度: ${treasure.rarity}</div>
            <div style="font-size: 12px; color: #FFD700; margin-bottom: 3px;">价值: ${formatNumber(treasure.baseValue)}</div>
            <div style="font-size: 12px; color: #32CD32; margin-bottom: 5px;">数量: ${treasureItem.quantity}</div>
            <div style="font-size: 10px; color: #888;">${treasure.description}</div>
        `;
        
        container.appendChild(treasureCard);
    });
}

// 更新出售列表
function updateSellList() {
    const container = document.getElementById('treasureSellList');
    if (!container) return;
    
    container.innerHTML = '';
    
    // 检查是否有可出售的宝物
    if (!player.treasures || !player.treasures.inventory || player.treasures.inventory.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">没有可出售的宝物</div>';
        return;
    }
    
    // 过滤掉数量为0的宝物
    const validTreasures = player.treasures.inventory.filter(t => t.quantity > 0);
    
    if (validTreasures.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">所有宝物已售出</div>';
        return;
    }
    
    validTreasures.forEach((treasureItem, index) => {
        const treasure = treasureConfig.find(t => t.id === treasureItem.id);
        if (!treasure) return;
        
        const sellItem = document.createElement('div');
        sellItem.className = 'sell-item';
        sellItem.style.display = 'flex';
        sellItem.style.alignItems = 'center';
        sellItem.style.justifyContent = 'space-between';
        sellItem.style.padding = '8px';
        sellItem.style.background = '#555';
        sellItem.style.borderRadius = '3px';
        sellItem.style.borderLeft = `3px solid ${treasure.color}`;
        sellItem.style.marginBottom = '5px';
        
        sellItem.innerHTML = `
            <div style="display: flex; align-items: center; flex: 1;">
                <input type="checkbox" id="treasureCheckbox${index}" 
                       style="margin-right: 10px; width: 16px; height: 16px;">
                <div style="flex: 1;">
                    <div style="font-weight: bold; color: ${treasure.color}; font-size: 12px;">
                        ${treasure.name}
                    </div>
                    <div style="font-size: 10px; color: #ccc;">
                        数量: ${treasureItem.quantity} | 稀有度: ${treasure.rarity}
                    </div>
                </div>
            </div>
            <div style="text-align: right;">
                <div style="font-size: 11px; color: #FFD700;">
                    ${formatNumber(treasure.baseValue)}
                </div>
                <div style="font-size: 9px; color: #888;">
                    资金/个
                </div>
            </div>
        `;
        
        container.appendChild(sellItem);
    });
}

// 更新宝物图鉴
function updateTreasureEncyclopedia() {
    const container = document.getElementById('treasureEncyclopedia');
    if (!container) return;
    
    container.innerHTML = '';
    
    treasureConfig.forEach(treasure => {
        // 安全获取统计数据
        const foundCount = (player.treasures && player.treasures.foundCount) ? 
            (player.treasures.foundCount[treasure.id - 1] || 0) : 0;
        const soldCount = (player.treasures && player.treasures.soldCount) ? 
            (player.treasures.soldCount[treasure.id - 1] || 0) : 0;
        
        // 安全获取拥有数量
        let ownedCount = 0;
        if (player.treasures && player.treasures.inventory) {
            const treasureItem = player.treasures.inventory.find(t => t.id === treasure.id);
            ownedCount = treasureItem ? treasureItem.quantity : 0;
        }
        
        const isDiscovered = foundCount > 0;
        
        const encyclopediaItem = document.createElement('div');
        encyclopediaItem.className = 'encyclopedia-item';
        encyclopediaItem.style.background = isDiscovered ? '#2a2a2a' : '#1a1a1a';
        encyclopediaItem.style.border = `1px solid ${isDiscovered ? treasure.color : '#555'}`;
        encyclopediaItem.style.borderRadius = '5px';
        encyclopediaItem.style.padding = '10px';
        encyclopediaItem.style.marginBottom = '10px';
        
        encyclopediaItem.innerHTML = `
            <div style="font-weight: bold; color: ${isDiscovered ? treasure.color : '#888'}; font-size: 14px; margin-bottom: 5px;">
                ${isDiscovered ? treasure.name : '未发现的宝物'} 
                ${isDiscovered ? '✓' : '?'}
            </div>
            <div style="font-size: 11px; color: ${isDiscovered ? '#ccc' : '#666'}; margin-bottom: 5px;">
                ${isDiscovered ? treasure.description : '继续挖矿来发现这个宝物'}
            </div>
            <div style="font-size: 10px; color: ${isDiscovered ? '#FFD700' : '#666'};">稀有度: ${treasure.rarity}</div>
            <div style="font-size: 10px; color: ${isDiscovered ? '#32CD32' : '#666'};">价值: ${formatNumber(treasure.baseValue)} 资金</div>
            ${isDiscovered ? `
                <div style="font-size: 9px; color: #87CEEB; margin-top: 5px;">
                    发现: ${foundCount}次 | 拥有: ${ownedCount}个 | 出售: ${soldCount}个
                </div>
            ` : ''}
        `;
        
        container.appendChild(encyclopediaItem);
    });
}
// 全选宝物
function selectAllTreasures() {
    player.treasures.inventory.forEach((treasure, index) => {
        const checkbox = document.getElementById(`treasureCheckbox${index}`);
        if (checkbox) {
            checkbox.checked = true;
        }
    });
}

// 全不选宝物
function deselectAllTreasures() {
    player.treasures.inventory.forEach((treasure, index) => {
        const checkbox = document.getElementById(`treasureCheckbox${index}`);
        if (checkbox) {
            checkbox.checked = false;
        }
    });
}

// 出售选中宝物
function sellSelectedTreasures() {
    const sellAmount = parseInt(document.getElementById('sellAmount').value) || 1;
    let totalEarned = 0;
    let soldTreasures = [];
    
    // 从后往前遍历，避免索引变化
    for (let i = player.treasures.inventory.length - 1; i >= 0; i--) {
        const checkbox = document.getElementById(`treasureCheckbox${i}`);
        if (checkbox && checkbox.checked) {
            const treasureItem = player.treasures.inventory[i];
            const treasure = treasureConfig.find(t => t.id === treasureItem.id);
            
            if (treasure) {
                const sellCount = Math.min(sellAmount, treasureItem.quantity);
                const earned = treasure.baseValue * sellCount;
                
                totalEarned += earned;
                treasureItem.quantity -= sellCount;
                
                // 更新统计
                player.treasures.totalSold += earned;
                player.treasures.soldCount[treasure.id - 1] += sellCount;
                
                soldTreasures.push({
                    name: treasure.name,
                    count: sellCount,
                    earned: earned
                });
                
                // 如果数量为0，移除该宝物
                if (treasureItem.quantity <= 0) {
                    player.treasures.inventory.splice(i, 1);
                }
            }
        }
    }
    
    if (totalEarned > 0) {
        // 添加金币
        player.investmentGame.userData.availableFunds += totalEarned;
        
        // 显示出售结果
        const soldText = soldTreasures.map(t => `${t.name} x${t.count}`).join(', ');
        logAction(`出售宝物获得 ${formatNumber(totalEarned)} 资金！ (${soldText})`, "success");
        
        updateTreasureUI();
        updateDisplay();
        saveGame();
    } else {
        logAction("请选择要出售的宝物", "error");
    }
}

// 一键出售所有宝物
function sellAllTreasures() {
    // 检查是否有可出售的宝物
    const hasTreasures = player.treasures.inventory && 
        player.treasures.inventory.some(t => t.quantity > 0);
    
    if (!hasTreasures) {
        logAction("没有可出售的宝物", "error");
        return;
    }
    
    // 计算总价值
    const totalValue = player.treasures.inventory.reduce((sum, treasureItem) => {
        const treasure = treasureConfig.find(t => t.id === treasureItem.id);
        return sum + (treasure ? treasure.baseValue * treasureItem.quantity : 0);
    }, 0);
    
    showCustomConfirm(`确定要一键出售所有宝物吗？\n总计可获得 ${formatNumber(totalValue)} 资金`, (confirmed) => {
        if (confirmed) {
            let totalEarned = 0;
            let soldCount = 0;
            
            // 计算总价值和数量
            player.treasures.inventory.forEach(treasureItem => {
                const treasure = treasureConfig.find(t => t.id === treasureItem.id);
                if (treasure) {
                    const earned = treasure.baseValue * treasureItem.quantity;
                    totalEarned += earned;
                    soldCount += treasureItem.quantity;
                    
                    // 更新统计
                    player.treasures.soldCount[treasure.id - 1] += treasureItem.quantity;
                }
            });
            
            // 添加金币
            player.investmentGame.userData.availableFunds += totalEarned;
            player.treasures.totalSold += totalEarned;
            
            // 清空库存
            player.treasures.inventory = [];
            
            logAction(`一键出售了 ${soldCount} 个宝物，获得 ${formatNumber(totalEarned)} 资金！`, "success");
            
            updateTreasureUI();
            updateDisplay();
            saveGame();
        }
    });
}


// 数字格式化函数
function formatNumber(num) {
    if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
    return num.toString();
}
const childConfig = {
    // 怀孕配置
    pregnancy: {
        duration: 24 * 60 * 60 * 1000, // 怀孕时间：24小时
        cost: 52013.14, // 怀孕消耗
        maxChildren: 10 // 最大孩子数量
    },
    
    // 孩子成长阶段
    growthStages: [
        { name: "婴儿", age: 0, duration: 1 * 24 * 60 * 60 * 1000 }, // 婴儿期：1天
        { name: "幼儿", age: 1, duration: 2 * 24 * 60 * 60 * 1000 }, // 幼儿期：2天
        { name: "儿童", age: 2, duration: 3 * 24 * 60 * 60 * 1000 }, // 儿童期：3年
        { name: "少年", age: 3, duration: 7 * 24 * 60 * 60 * 1000 }, // 少年期：7年
        { name: "青年", age: 4, duration: Infinity } // 青年期：永久
    ],
    
    // 培养类型
   trainingTypes: [
        { id: "education", name: "教育", cost: 13145, effect: "intelligence", description: "提高孩子的智力属性" },
        { id: "sports", name: "体育", cost: 52100, effect: "physique", description: "提高孩子的体质属性" },
        { id: "arts", name: "艺术", cost: 131400, effect: "charm", description: "提高孩子的魅力属性" },
        { id: "business", name: "商业", cost: 52100, effect: "business", description: "提高孩子的商业能力" }
    ],
    
    // 孩子属性加成
    attributeBonuses: {
        intelligence: { gps: 1, description: "每点智力增加100% GPS" },
        physique: { click: 1, description: "每点体质增加100% 点击" },
        charm: { critRate: 1, description: "每点魅力增加100% 生命" },
        business: { gold: 1, description: "每点商业增加100% 攻击" }
    }
};

// 初始化孩子系统数据
function initChildData() {
    if (!player.children) {
        player.children = {
            isPregnant: false,
            pregnancyStart: 0,
            pregnancyProgress: 0,
            children: [],
            totalChildren: 0,
            trainingHistory: [],
            childBonuses: {
                gpsMultiplier: 1.0,
                clickMultiplier: 1.0,
                critRateBonus: 1.0,
                goldMultiplier: 1.0
            }
        };
    }
}

// 切换孩子系统界面
function toggleChildSystem() {
    if (!player.marriage || !player.marriage.isMarried) {
        alert("需要先结婚才能生小孩！");
        return;
    }
    if (player.marriage.loveLevel < 25) {
        alert("需要结婚恩爱等级25级！");
        return;
    }
    
    const ui = document.getElementById('childSystemUI');
    const overlay = document.getElementById('childSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        initChildData();
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateChildSystemUI();
    }
}

function closeChildSystem() {
    document.getElementById('childSystemUI').style.display = 'none';
    document.getElementById('childSystemOverlay').style.display = 'none';
}

// 更新孩子系统UI
function updateChildSystemUI() {
    updateFamilyStatus();
    updatePregnancyStatus();
    updateChildrenList(); // 这个现在包含成长倒计时
    updateTrainingSection();
   updateChildWorkSystem(); // 新增：更新工作系统
    updateChildInteractionSystem(); // 新增：更新互动系统
    updateChildBonuses();
    updateConceptionButton();
    addWorkAndInteractionSections();
    // 确保成长概览区域存在
    if (!document.getElementById('growthOverview')) {
        const familyStatus = document.getElementById('familyStatus');
        const growthOverview = document.createElement('div');
        growthOverview.id = 'growthOverview';
        growthOverview.style.cssText = 'grid-column: 1 / -1; background: #444; padding: 10px; border-radius: 5px; margin-top: 10px;';
        familyStatus.appendChild(growthOverview);
    }
    updateGrowthOverview();
}
function addWorkAndInteractionSections() {
    const ui = document.getElementById('childSystemUI');
    
    // 检查是否已存在工作和互动区域
    if (!document.getElementById('childWorkSystem')) {
        const workSection = document.createElement('div');
        workSection.id = 'childWorkSystem';
        workSection.style.cssText = 'margin-bottom: 20px; background: #333; padding: 15px; border-radius: 8px;';
        ui.appendChild(workSection);
    }
    
    if (!document.getElementById('childInteractionSystem')) {
        const interactionSection = document.createElement('div');
        interactionSection.id = 'childInteractionSystem';
        interactionSection.style.cssText = 'background: #333; padding: 15px; border-radius: 8px;';
        ui.appendChild(interactionSection);
    }
    
    // 更新内容
    updateChildWorkSystem();
    updateChildInteractionSystem();
}

function startGrowthCountdownTimer() {
    registerInterval(() => {
        if (document.getElementById('childSystemUI').style.display === 'block') {
            updateChildrenList(); // 每分钟更新一次倒计时
            updateGrowthOverview();
        }
    }, 60000); // 每分钟更新一次
}


function showTrainingStrategy() {
    const strategies = [
        { id: 'balanced', name: '均衡发展', description: '所有属性平均发展' },
        { id: 'intelligence', name: '智力优先', description: '优先发展智力属性' },
        { id: 'physique', name: '体质优先', description: '优先发展体质属性' },
        { id: 'charm', name: '魅力优先', description: '优先发展魅力属性' },
        { id: 'business', name: '商业优先', description: '优先发展商业属性' }
    ];
    
    let message = '选择培养策略：\n\n';
    strategies.forEach(strategy => {
        message += `${strategy.name}: ${strategy.description}\n`;
    });
    
    showCustomPrompt(message, (selected) => {
        if (selected) {
            const strategy = strategies.find(s => selected.includes(s.name));
            if (strategy) {
                player.children.trainingStrategy = strategy.id;
                logAction(`已设置为${strategy.name}策略`, "success");
            }
        }
    });
}
function trainWithStrategy(childIndex) {
    const strategy = player.children.trainingStrategy || 'balanced';
    let trainingType;
    
    switch(strategy) {
        case 'intelligence':
            trainingType = 'education';
            break;
        case 'physique':
            trainingType = 'sports';
            break;
        case 'charm':
            trainingType = 'arts';
            break;
        case 'business':
            trainingType = 'business';
            break;
        default: // balanced
            // 均衡发展：选择最弱的属性
            const child = player.children.children[childIndex];
            const attributes = child.attributes;
            const weakestAttribute = Object.keys(attributes).reduce((weakest, attr) => {
                return attributes[attr] < attributes[weakest] ? attr : weakest;
            });
            
            trainingType = childConfig.trainingTypes.find(t => t.effect === weakestAttribute)?.id || 'education';
            break;
    }
    
    trainChild(childIndex, trainingType);
}

// 更新家庭状态
function updateFamilyStatus() {
    const container = document.getElementById('familyStatus');
    const children = player.children.children || [];
    const pregnant = player.children.isPregnant;
    
    // 计算可培养的孩子数量
    const now = Date.now();
    const availableChildren = children.filter(child => {
        const lastTraining = child.lastTraining || 0;
        return (now - lastTraining) >= 60 * 60 * 1000;
    }).length;
    
    container.innerHTML = `
        <div>配偶: ${player.marriage.spouseName}</div>
        <div>孩子数量: ${children.length}/${childConfig.pregnancy.maxChildren}</div>
        <div>怀孕状态: ${pregnant ? '是' : '否'}</div>
        <div>可培养: <span style="color: ${availableChildren > 0 ? '#4CAF50' : '#FF6B6B'}">${availableChildren}/${children.length}</span></div>
        <div>家庭幸福度: ${calculateFamilyHappiness()}%</div>
    `;
    
 
}
function initChildSystem() {
    initChildData();
    startChildCooldownTimer();
    
    startGrowthCountdownTimer(); // 添加成长倒计时计时器
}
// 更新怀孕状态
function updatePregnancyStatus() {
    const pregnancySection = document.getElementById('pregnancySection');
    const pregnancyInfo = document.getElementById('pregnancyInfo');
    
    if (player.children.isPregnant) {
        pregnancySection.style.display = 'block';
        
        const progress = calculatePregnancyProgress();
        const remainingTime = Math.max(0, childConfig.pregnancy.duration - (Date.now() - player.children.pregnancyStart));
        const hoursRemaining = Math.ceil(remainingTime / (60 * 60 * 1000));
        const minutesRemaining = Math.ceil(remainingTime / (60 * 1000));
        
        // 检查是否应该分娩
        if (progress >= 100) {
            pregnancyInfo.innerHTML = `
                <div style="color: #4CAF50; font-weight: bold;">怀孕完成！准备分娩</div>
                <div style="color: #ccc;">孩子即将出生...</div>
                <button onclick="giveBirth()" style="margin-top: 10px; background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; width: 100%;">
                    🎉 立即分娩 🎉
                </button>
                <div style="margin-top: 10px; font-size: 12px; color: #888;">
                    如果分娩没有自动触发，请点击上方按钮
                </div>
            `;
            
            // 自动触发分娩（延迟1秒确保UI更新）
            setTimeout(() => {
                if (player.children.isPregnant) {
                    console.log('自动触发分娩...');
                    giveBirth();
                }
            }, 1000);
            
        } else {
            pregnancyInfo.innerHTML = `
                <div>怀孕进度: ${progress.toFixed(1)}%</div>
                <div>剩余时间: ${hoursRemaining} 小时 ${minutesRemaining % 60} 分钟</div>
                <div>预计出生: ${new Date(player.children.pregnancyStart + childConfig.pregnancy.duration).toLocaleString()}</div>
                <div style="margin-top: 10px;">
                    <div style="background: #555; border-radius: 5px; height: 20px; margin: 5px 0; position: relative;">
                        <div style="background: linear-gradient(90deg, #FF69B4, #FF1493); height: 100%; border-radius: 5px; width: ${progress}%; transition: width 0.3s;"></div>
                        <div style="position: absolute; top: 0; left: 0; right: 0; text-align: center; color: white; font-size: 12px; line-height: 20px;">
                            ${progress.toFixed(1)}%
                        </div>
                    </div>
                </div>
                <button onclick="giveBirthNow()" style="margin-top: 10px; background: #FF9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">
                    95.1%以上立即分娩 (消耗 88888 元)
                </button>
            `;
        }
    } else {
        pregnancySection.style.display = 'none';
    }
}


// 计算怀孕进度
function calculatePregnancyProgress() {
    if (!player.children.isPregnant || !player.children.pregnancyStart) {
        return 0;
    }
    
    const elapsed = Date.now() - player.children.pregnancyStart;
    const progress = Math.min(100, (elapsed / childConfig.pregnancy.duration) * 100);
    
    console.log('怀孕进度计算:', {
        startTime: new Date(player.children.pregnancyStart).toLocaleString(),
        currentTime: new Date().toLocaleString(),
        elapsed: Math.round(elapsed / 1000 / 60) + '分钟',
        totalDuration: Math.round(childConfig.pregnancy.duration / 1000 / 60) + '分钟',
        progress: progress.toFixed(1) + '%'
    });
    
    return progress;
}

// 怀孕功能
function conceiveChild() {
    if (!player.marriage.isMarried) {
        logAction("需要先结婚才能怀孕", "error");
        return;
    }
    
    if (player.children.isPregnant) {
        logAction("已经怀孕了，请等待分娩", "error");
        return;
    }
    
    if (player.children.children.length >= childConfig.pregnancy.maxChildren) {
        logAction(`最多只能有 ${childConfig.pregnancy.maxChildren} 个孩子`, "error");
        return;
    }
    
    const childName = document.getElementById('childNameInput').value.trim();
    const childGender = document.getElementById('childGenderSelect').value;
    
    if (!childName) {
        logAction("请输入孩子名字", "error");
        return;
    }
    
    if (childName.length > 10) {
        logAction("孩子名字不能超过10个字符", "error");
        return;
    }
    
    if (player.investmentGame.userData.availableFunds < childConfig.pregnancy.cost) {
        logAction(`资金不足！需要 ${childConfig.pregnancy.cost} 元`, "error");
        return;
    }
    
    // 扣除转生币
    player.investmentGame.userData.availableFunds -= childConfig.pregnancy.cost;
    
    // 开始怀孕
    player.children.isPregnant = true;
    player.children.pregnancyStart = Date.now();
    player.children.pregnancyProgress = 0;
    player.children.expectedChild = {
        name: childName,
        gender: childGender
    };
    
    const expectedBirthTime = new Date(Date.now() + childConfig.pregnancy.duration);
    logAction(`恭喜！您怀孕了！孩子预计在 ${expectedBirthTime.toLocaleString()} 出生`, "success");
    
    updateChildSystemUI();
    updateDisplay();
    saveGame();
    
    // 启动怀孕计时器
    startPregnancyTimer();
}

// 开始怀孕计时器
function startPregnancyTimer() {
    if (player.children.pregnancyTimer) {
        clearInterval(player.children.pregnancyTimer);
    }
    
    player.children.pregnancyTimer = registerInterval(() => {
        if (player.children.isPregnant) {
            const progress = calculatePregnancyProgress();
            player.children.pregnancyProgress = progress;
            
            console.log('怀孕计时器检查，进度:', progress.toFixed(1) + '%');
            
            // 更新UI
            updatePregnancyStatus();
            
            // 当进度达到100%时触发分娩
            if (progress >= 100) {
                console.log('怀孕完成，触发分娩...');
                giveBirth();
            }
        } else {
            // 怀孕结束，清除计时器
            clearInterval(player.children.pregnancyTimer);
            player.children.pregnancyTimer = null;
        }
    }, 30000); // 每30秒检查一次（更频繁的检查）
}

// 分娩
function giveBirth() {
    try {
        console.log('开始分娩检查...');
        console.log('怀孕状态:', player.children.isPregnant);
        console.log('预期孩子:', player.children.expectedChild);
        
        if (!player.children.isPregnant) {
            logAction("当前没有怀孕", "error");
            return;
        }
        
        if (!player.children.expectedChild) {
            logAction("怀孕数据异常，无法分娩", "error");
            // 重置怀孕状态
            player.children.isPregnant = false;
            player.children.pregnancyStart = 0;
            player.children.pregnancyProgress = 0;
            updateChildSystemUI();
            saveGame();
            return;
        }
        
        const progress = calculatePregnancyProgress();
        console.log('当前怀孕进度:', progress + '%');
        
        // 即使进度未满100%也允许分娩（容错处理）
        if (progress < 95) {
            logAction(`怀孕进度不足 (${progress.toFixed(1)}%)，还不能分娩`, "error");
            return;
        }
        
        console.log('创建新孩子...');
        const child = createNewChild(
            player.children.expectedChild.name,
            player.children.expectedChild.gender
        );
        
        // 添加到孩子列表
        player.children.children.push(child);
        player.children.totalChildren = (player.children.totalChildren || 0) + 1;
        
        // 重置怀孕状态
        player.children.isPregnant = false;
        player.children.pregnancyStart = 0;
        player.children.pregnancyProgress = 0;
        delete player.children.expectedChild;
        
        // 清除计时器
        if (player.children.pregnancyTimer) {
            clearInterval(player.children.pregnancyTimer);
            player.children.pregnancyTimer = null;
        }
        
        const genderText = child.gender === 'boy' ? '男孩' : '女孩';
        logAction(`🎉 恭喜！您生下了一个${genderText}：${child.name}！`, "success");
        
 
        
        
        updateChildSystemUI();
        updateDisplay();
        saveGame();
        
        console.log('分娩完成，当前孩子数量:', player.children.children.length);
        
    } catch (error) {
        console.error('分娩过程中发生错误:', error);
        logAction("分娩过程中出现错误，已重置怀孕状态", "error");
        
        // 错误恢复：重置怀孕状态
        player.children.isPregnant = false;
        player.children.pregnancyStart = 0;
        player.children.pregnancyProgress = 0;
        delete player.children.expectedChild;
        
        updateChildSystemUI();
        saveGame();
    }
}


// 立即分娩
function giveBirthNow() {
    if (!player.children.isPregnant) {
        logAction("当前没有怀孕", "error");
        return;
    }
    
    if (player.investmentGame.userData.availableFunds < 88888) {
        logAction("资金不足！需要88888元", "error");
        return;
    }
    
    showCustomConfirm("确定要立即分娩吗？消耗88888元", (confirmed) => {
        if (confirmed) {
            player.investmentGame.userData.availableFunds -= 88888;
            giveBirth();
        }
    });
}

// 更新孩子列表
function updateChildrenList() {
    const container = document.getElementById('childrenList');
    const children = player.children.children || [];
    
    if (children.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">还没有孩子</div>';
        return;
    }
    
    container.innerHTML = '';
    
    children.forEach((child, index) => {
        // 确保属性正确初始化
        const safeChild = ensureChildAttributes(child);
        const currentStage = childConfig.growthStages[safeChild.growthStage];
        const nextStage = childConfig.growthStages[safeChild.growthStage + 1];
         const isAdult = safeChild.isAdult || safeChild.growthStage >= childConfig.growthStages.length - 1;
        
        // 更新成年状态（确保一致性）
        if (isAdult && !safeChild.isAdult) {
            safeChild.isAdult = true;
        }
        // 计算成长倒计时
        const growthInfo = calculateGrowthCountdown(safeChild);
        
        const childCard = document.createElement('div');
        childCard.className = 'child-card';
        childCard.style.background = '#444';
        childCard.style.border = '2px solid #FF69B4';
        childCard.style.borderRadius = '5px';
        childCard.style.padding = '10px';
        childCard.style.textAlign = 'center';
        childCard.style.position = 'relative';
         const adultBadge = isAdult ? '<div style="position: absolute; top: 5px; right: 5px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; font-size: 8px;">成年</div>' : '';
        // 计算培养冷却时间
        const now = Date.now();
        const lastTraining = safeChild.lastTraining || 0;
        const cooldown = 60 * 60 * 1000;
        const remainingTime = Math.max(0, cooldown - (now - lastTraining));
        const isOnCooldown = remainingTime > 0;
        const minutesRemaining = Math.ceil(remainingTime / (60 * 1000));
        
        childCard.innerHTML = `
            <div style="font-weight: bold; color: #FF69B4; font-size: 14px;">${safeChild.name}</div>
            <div style="font-size: 12px; color: #ccc;">${safeChild.gender === 'boy' ? '👦 男孩' : '👧 女孩'}</div>
            ${isAdult ? '<div style="font-size: 10px; color: #4CAF50;">✓ 可以工作</div>' : ''}
            <div style="font-size: 11px; color: #87CEEB;">${currentStage.name}</div>
            
            <!-- 成长阶段信息 -->
            <div style="margin: 5px 0; padding: 3px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                ${growthInfo.countdownHtml}
            </div>
            
            <!-- 属性显示 -->
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 2px; font-size: 10px; margin: 5px 0;">
                <div style="color: #32CD32;">智力: ${safeChild.attributes.intelligence}</div>
                <div style="color: #FFA500;">体质: ${safeChild.attributes.physique}</div>
                <div style="color: #FF69B4;">魅力: ${safeChild.attributes.charm}</div>
                <div style="color: #FFD700;">商业: ${safeChild.attributes.business}</div>
            </div>
            
            <!-- 培养冷却状态 -->
            <div style="font-size: 9px; color: ${isOnCooldown ? '#FF6B6B' : '#4CAF50'}; background: rgba(0,0,0,0.7); padding: 2px 5px; border-radius: 3px; margin-top: 3px;">
                ${isOnCooldown ? `培养冷却: ${minutesRemaining}分钟` : '可培养'}
            </div>
            
            <!-- 单独培养按钮 -->
            <div style="margin-top: 5px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 3px;">
                <button onclick="trainChild(${index}, 'education')" 
                        style="background: ${isOnCooldown ? '#888' : '#2196F3'}; color: white; border: none; padding: 2px 4px; border-radius: 2px; cursor: ${isOnCooldown ? 'not-allowed' : 'pointer'}; font-size: 8px;"
                        ${isOnCooldown ? 'disabled' : ''} title="教育培养">
                    教育
                </button>
                <button onclick="trainChild(${index}, 'sports')" 
                        style="background: ${isOnCooldown ? '#888' : '#4CAF50'}; color: white; border: none; padding: 2px 4px; border-radius: 2px; cursor: ${isOnCooldown ? 'not-allowed' : 'pointer'}; font-size: 8px;"
                        ${isOnCooldown ? 'disabled' : ''} title="体育培养">
                    体育
                </button>
                <button onclick="trainChild(${index}, 'arts')" 
                        style="background: ${isOnCooldown ? '#888' : '#9C27B0'}; color: white; border: none; padding: 2px 4px; border-radius: 2px; cursor: ${isOnCooldown ? 'not-allowed' : 'pointer'}; font-size: 8px;"
                        ${isOnCooldown ? 'disabled' : ''} title="艺术培养">
                    艺术
                </button>
                <button onclick="trainChild(${index}, 'business')" 
                        style="background: ${isOnCooldown ? '#888' : '#FF9800'}; color: white; border: none; padding: 2px 4px; border-radius: 2px; cursor: ${isOnCooldown ? 'not-allowed' : 'pointer'}; font-size: 8px;"
                        ${isOnCooldown ? 'disabled' : ''} title="商业培养">
                    商业
                </button>
            </div>
              
            <div style="font-size: 8px; color: #888; margin-top: 2px;">总培养: ${safeChild.totalTraining || 0}次</div>
        `;
        
        container.appendChild(childCard);
    });
}

function calculateGrowthCountdown(child) {
    const currentStage = childConfig.growthStages[child.growthStage];
    const nextStage = childConfig.growthStages[child.growthStage + 1];
    
    // 如果是最后阶段
    if (!nextStage) {
        return {
            countdownHtml: `
                <div style="color: #FFD700; font-size: 9px;">🏆 已达成最高阶段</div>
                <div style="color: #888; font-size: 8px;">${currentStage.name}</div>
            `,
            canGrow: false,
            timeRemaining: 0
        };
    }
    
    // 计算当前阶段已过时间
    const birthDate = child.birthDate || Date.now();
    const now = Date.now();
    const timeInCurrentStage = now - birthDate - childConfig.growthStages.slice(0, child.growthStage).reduce((sum, stage) => sum + stage.duration, 0);
    const timeRequired = currentStage.duration;
    const timeRemaining = Math.max(0, timeRequired - timeInCurrentStage);
    
    // 计算属性需求
    const totalAttributes = Object.values(child.attributes).reduce((a, b) => a + b, 0);
    const attributesRequired = (child.growthStage + 1) * 10; // 每阶段需要10点属性
    const attributesNeeded = Math.max(0, attributesRequired - totalAttributes);
    
    // 计算成长进度
    const timeProgress = Math.min(100, (timeInCurrentStage / timeRequired) * 100);
    const attributeProgress = Math.min(100, (totalAttributes / attributesRequired) * 100);
    const overallProgress = Math.min(timeProgress, attributeProgress);
    
    // 格式化时间
    const hoursRemaining = Math.floor(timeRemaining / (60 * 60 * 1000));
    const minutesRemaining = Math.floor((timeRemaining % (60 * 60 * 1000)) / (60 * 1000));
    
    const canGrow = timeRemaining <= 0 && attributesNeeded <= 0;
    
    let countdownHtml = '';
    
    if (canGrow) {
        countdownHtml = `
            <div style="color: #4CAF50; font-size: 9px;">✨ 可成长到 ${nextStage.name}</div>
            <div style="color: #888; font-size: 8px;">点击培养即可升级</div>
        `;
    } else {
        // 显示时间倒计时
        if (timeRemaining > 0) {
            countdownHtml += `
                <div style="color: #87CEEB; font-size: 8px;">⏰ ${hoursRemaining}小时${minutesRemaining}分钟</div>
            `;
        }
        
        // 显示属性需求
        if (attributesNeeded > 0) {
            countdownHtml += `
                <div style="color: #FFA500; font-size: 8px;">📊 还需${attributesNeeded}点属性</div>
            `;
        }
        
        // 显示进度条
        countdownHtml += `
            <div style="margin-top: 3px;">
                <div style="background: #555; border-radius: 3px; height: 6px; position: relative;">
                    <div style="background: linear-gradient(90deg, #FF69B4, #FF1493); height: 100%; border-radius: 3px; width: ${overallProgress}%;"></div>
                </div>
                <div style="font-size: 7px; color: #ccc;">成长进度: ${overallProgress.toFixed(1)}%</div>
            </div>
        `;
    }
    
    return {
        countdownHtml: countdownHtml,
        canGrow: canGrow,
        timeRemaining: timeRemaining,
        attributesNeeded: attributesNeeded,
        nextStage: nextStage.name
    };
}

// 更新培养区域
function updateTrainingSection() {
    const container = document.getElementById('childTrainingSection');
    container.innerHTML = '';
    
    // 添加冷却时间概览
    const children = player.children.children || [];
    const now = Date.now();
    const availableCount = children.filter(child => {
        const lastTraining = child.lastTraining || 0;
        return (now - lastTraining) >= 60 * 60 * 1000;
    }).length;
    
    const cooldownOverview = document.createElement('div');
    cooldownOverview.style.cssText = 'grid-column: 1 / -1; background: #555; padding: 10px; border-radius: 5px; text-align: center; margin-bottom: 10px;';
    cooldownOverview.innerHTML = `
        <div style="font-size: 12px; color: #ccc;">
            可培养孩子: <span style="color: ${availableCount > 0 ? '#4CAF50' : '#FF6B6B'}">${availableCount}/${children.length}</span>
        </div>
        <div style="font-size: 10px; color: #888;">
            ${availableCount === 0 ? '所有孩子都在冷却中' : '可点击孩子卡片上的按钮进行单独培养'}
        </div>
    `;
    container.appendChild(cooldownOverview);
    
    // 添加批量培养选项
    const batchTrainingTitle = document.createElement('div');
    batchTrainingTitle.style.cssText = 'grid-column: 1 / -1; text-align: center; font-weight: bold; color: #FF69B4; margin: 10px 0;';
    batchTrainingTitle.textContent = '批量培养 (所有可培养的孩子)';
    container.appendChild(batchTrainingTitle);
    
    // 添加培养选项
    childConfig.trainingTypes.forEach(training => {
        const trainingCard = document.createElement('div');
        trainingCard.style.background = '#555';
        trainingCard.style.padding = '10px';
        trainingCard.style.borderRadius = '5px';
        trainingCard.style.textAlign = 'center';
        
        trainingCard.innerHTML = `
            <div style="font-weight: bold; color: ${getTrainingColor(training.id)};">${training.name}</div>
            <div style="font-size: 12px; color: #ccc; margin: 5px 0;">${training.description}</div>
            <div style="font-size: 11px; color: #FFD700;">消耗: ${training.cost} 元/孩子</div>
            <div style="font-size: 10px; color: #87CEEB;">效果: ${getAttributeDisplayName(training.effect)}+1</div>
            <button onclick="trainAllChildren('${training.id}')" 
                    style="margin-top: 5px; background: ${availableCount > 0 ? getTrainingColor(training.id) : '#888'}; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: ${availableCount > 0 ? 'pointer' : 'not-allowed'}; width: 100%;"
                    ${availableCount === 0 ? 'disabled' : ''}>
                全体${training.name} (${availableCount}个)
            </button>
        `;
        
        container.appendChild(trainingCard);
    });
    
    // 添加智能培养选项
    const smartTrainingCard = document.createElement('div');
    smartTrainingCard.style.cssText = 'grid-column: 1 / -1; background: #555; padding: 10px; border-radius: 5px; text-align: center; margin-top: 10px;';
    smartTrainingCard.innerHTML = `
        <div style="font-weight: bold; color: #FF69B4;">智能培养</div>
        <div style="font-size: 12px; color: #ccc; margin: 5px 0;">根据每个孩子的特点进行最优培养</div>
        <button onclick="smartTrainAllChildren()" 
                style="margin-top: 5px; background: ${availableCount > 0 ? '#FF69B4' : '#888'}; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: ${availableCount > 0 ? 'pointer' : 'not-allowed'}; width: 100%;"
                ${availableCount === 0 ? 'disabled' : ''}>
            智能培养 (${availableCount}个)
        </button>
    `;
    container.appendChild(smartTrainingCard);
 

}
function getCurrentStrategyName() {
    const strategies = {
        'balanced': '均衡发展',
        'intelligence': '智力优先',
        'physique': '体质优先',
        'charm': '魅力优先',
        'business': '商业优先'
    };
    return strategies[player.children.trainingStrategy || 'balanced'];
}
function getTrainingColor(trainingType) {
    const colors = {
        'education': '#2196F3',    // 蓝色
        'sports': '#4CAF50',       // 绿色
        'arts': '#9C27B0',         // 紫色
        'business': '#FF9800'      // 橙色
    };
    return colors[trainingType] || '#666';
}
function smartTrainAllChildren() {
    const children = player.children.children || [];
    if (children.length === 0) {
        logAction("没有孩子可以培养", "error");
        return;
    }
    
    const now = Date.now();
    const availableChildren = children.filter(child => {
        const lastTraining = child.lastTraining || 0;
        return (now - lastTraining) >= 60 * 60 * 1000;
    });
    
    if (availableChildren.length === 0) {
        logAction("所有孩子都在培养冷却中", "error");
        return;
    }
    
    let totalCost = 0;
    const trainingPlan = [];
    
    // 为每个孩子选择最优的培养方式
    availableChildren.forEach(child => {
        // 找出孩子最弱的属性
        const attributes = child.attributes;
        const weakestAttribute = Object.keys(attributes).reduce((weakest, attr) => {
            return attributes[attr] < attributes[weakest] ? attr : weakest;
        });
        
        // 找到对应的培养方式
        const bestTraining = childConfig.trainingTypes.find(t => t.effect === weakestAttribute);
        if (bestTraining) {
            totalCost += bestTraining.cost;
            trainingPlan.push({
                childName: child.name,
                training: bestTraining,
                attribute: weakestAttribute,
                currentValue: attributes[weakestAttribute]
            });
        }
    });
    
    if (totalCost === 0) {
        logAction("无法制定培养计划", "error");
        return;
    }
    
    if (player.investmentGame.userData.availableFunds < totalCost) {
        logAction(`资金不足！智能培养需要 ${totalCost} 元`, "error");
        return;
    }
    
    // 显示培养计划
    const planText = trainingPlan.map(plan => 
        `${plan.childName}: ${plan.training.name} (${getAttributeDisplayName(plan.attribute)} ${plan.currentValue}→${plan.currentValue + 1})`
    ).join('\n');
    
    showCustomConfirm(`智能培养计划：\n\n${planText}\n\n总计消耗: ${totalCost} 元`, (confirmed) => {
        if (confirmed) {
            let trainedCount = 0;
            let totalAttributeIncrease = 0;
            
            trainingPlan.forEach(plan => {
                const child = children.find(c => c.name === plan.childName);
                if (child) {
                    const oldValue = child.attributes[plan.attribute];
                    child.attributes[plan.attribute] += 1;
                    child.lastTraining = now;
                    child.totalTraining = (child.totalTraining || 0) + 1;
                    trainedCount++;
                    totalAttributeIncrease += 1;
                    
                    // 检查成长
                    const childIndex = children.indexOf(child);
                    if (childIndex !== -1) {
                        checkChildGrowth(childIndex);
                    }
                }
            });
            
            if (trainedCount > 0) {
                player.investmentGame.userData.availableFunds -= totalCost;
                logAction(`智能培养了 ${trainedCount} 个孩子，总共增加了 ${totalAttributeIncrease} 点属性`, "success");
                
                updateChildSystemUI();
                updateDisplay();
                saveGame();
            }
        }
    });
}
function quickTrainAll() {
    const children = player.children.children || [];
    if (children.length === 0) {
        logAction("没有孩子可以培养", "error");
        return;
    }
    
    const now = Date.now();
    const availableChildren = children.filter(child => {
        const lastTraining = child.lastTraining || 0;
        return (now - lastTraining) >= 60 * 60 * 1000;
    });
    
    if (availableChildren.length === 0) {
        logAction("所有孩子都在培养冷却中", "error");
        return;
    }
    
    // 使用最便宜的教育培养
    const training = childConfig.trainingTypes[0]; // 教育培养
    const totalCost = training.cost * availableChildren.length;
    
    if (player.investmentGame.userData.availableFunds < totalCost) {
        logAction(`资金不足！需要 ${totalCost} 元`, "error");
        return;
    }
    
    showCustomConfirm(`确定要对 ${availableChildren.length} 个孩子进行快速教育培养吗？\n消耗 ${totalCost} 元`, (confirmed) => {
        if (confirmed) {
            let trainedCount = 0;
            
            availableChildren.forEach(child => {
                child.attributes.intelligence += 1;
                child.lastTraining = now;
                child.totalTraining = (child.totalTraining || 0) + 1;
                trainedCount++;
                
                // 检查成长
                const childIndex = children.indexOf(child);
                if (childIndex !== -1) {
                    checkChildGrowth(childIndex);
                }
            });
            
            if (trainedCount > 0) {
                player.investmentGame.userData.availableFunds -= totalCost;
                logAction(`快速培养了 ${trainedCount} 个孩子，智力+${trainedCount}`, "success");
                
                updateChildSystemUI();
                updateDisplay();
                saveGame();
            }
        }
    });
}
// 培养孩子
function trainChild(childIndex, trainingType = null) {
    try {
        console.log('开始培养孩子:', childIndex, '培养类型:', trainingType);
        
        const children = player.children.children;
        if (childIndex >= children.length) {
            logAction("无效的孩子索引", "error");
            return;
        }
        
        const child = children[childIndex];
        console.log('目标孩子:', child);
        
        // 检查培养冷却
        const now = Date.now();
        const lastTraining = child.lastTraining || 0;
        const cooldown = 60 * 60 * 1000; // 1小时冷却
        const remainingTime = cooldown - (now - lastTraining);
        
        if (remainingTime > 0) {
            const minutesRemaining = Math.ceil(remainingTime / (60 * 1000));
            logAction(`${child.name} 培养冷却中，还需等待 ${minutesRemaining} 分钟`, "error");
            return;
        }
        
        // 如果没有指定培养类型，弹出选择框
        if (!trainingType) {
            showTrainingSelection(childIndex);
            return;
        }
        
        const training = childConfig.trainingTypes.find(t => t.id === trainingType);
        if (!training) {
            logAction("无效的培养类型", "error");
            return;
        }
        
        console.log('选择的培养:', training);
        
        if (player.investmentGame.userData.availableFunds < training.cost) {
            logAction(`资金不足！需要 ${training.cost} 元`, "error");
            return;
        }
        
        // 保存旧的属性值用于比较
        const oldAttributeValue = child.attributes[training.effect];
        console.log('培养前属性值:', training.effect, '=', oldAttributeValue);
        
        
        player.investmentGame.userData.availableFunds -= training.cost;
        console.log('扣除资金:', training.cost, '剩余:', player.investmentGame.userData.availableFunds);
        
        // 确保属性对象存在
        if (!child.attributes) {
            child.attributes = {
                intelligence: 1,
                physique: 1,
                charm: 1,
                business: 1
            };
        }
        
        // 增加属性 - 确保使用正确的属性名
        const effectMapping = {
            'education': 'intelligence',
            'sports': 'physique',
            'arts': 'charm',
            'business': 'business'
        };
        
        const actualEffect = effectMapping[trainingType] || training.effect;
        console.log('实际影响的属性:', actualEffect);
        
        if (child.attributes[actualEffect] === undefined) {
            child.attributes[actualEffect] = 1; // 初始化属性
        }
        
        // 增加属性值
        child.attributes[actualEffect] += 1;
        const newAttributeValue = child.attributes[actualEffect];
        console.log('培养后属性值:', actualEffect, '=', newAttributeValue);
        
        // 更新其他数据
        child.lastTraining = now;
        child.totalTraining = (child.totalTraining || 0) + 1;
        
        // 记录培养历史（限制长度防止长时间游戏内存增长）
        if (!player.children.trainingHistory) {
            player.children.trainingHistory = [];
        }
        player.children.trainingHistory.push({
            childName: child.name,
            trainingType: training.name,
            attribute: actualEffect,
            oldValue: oldAttributeValue,
            newValue: newAttributeValue,
            timestamp: now
        });
        if (player.children.trainingHistory.length > 100) {
            player.children.trainingHistory = player.children.trainingHistory.slice(-100);
        }
        
        logAction(`对 ${child.name} 进行了${training.name}培养，${getAttributeDisplayName(actualEffect)}+1 (${oldAttributeValue} → ${newAttributeValue})`, "success");
        
        // 检查成长阶段
        checkChildGrowth(childIndex);
        
        // 强制更新UI
        updateChildSystemUI();
        updateDisplay();
        saveGame();
        
        console.log('培养完成，当前孩子属性:', child.attributes);
        
    } catch (error) {
        console.error('培养孩子时发生错误:', error);
        logAction("培养过程中出现错误", "error");
    }
}


// 全体培养
function trainAllChildren(trainingType) {
    try {
        console.log('开始全体培养，类型:', trainingType);
        
        const children = player.children.children;
        if (children.length === 0) {
            logAction("没有孩子可以培养", "error");
            return;
        }
        
        const training = childConfig.trainingTypes.find(t => t.id === trainingType);
        if (!training) {
            logAction("无效的培养类型", "error");
            return;
        }
        
        // 检查哪些孩子可以培养
        const now = Date.now();
        const availableChildren = children.filter((child, index) => {
            const lastTraining = child.lastTraining || 0;
            const canTrain = (now - lastTraining) >= 60 * 60 * 1000;
            console.log(`孩子 ${child.name} 可培养:`, canTrain);
            return canTrain;
        });
        
        if (availableChildren.length === 0) {
            const cooldownInfo = children.map(child => {
                const lastTraining = child.lastTraining || 0;
                const remainingTime = Math.max(0, 60 * 60 * 1000 - (now - lastTraining));
                const minutesRemaining = Math.ceil(remainingTime / (60 * 1000));
                return `${child.name}: ${minutesRemaining}分钟`;
            }).join(', ');
            
            logAction(`所有孩子都在培养冷却中: ${cooldownInfo}`, "error");
            return;
        }
        
        const totalCost = training.cost * availableChildren.length;
        if (player.investmentGame.userData.availableFunds < totalCost) {
            logAction(`资金不足！需要 ${totalCost} 元`, "error");
            return;
        }
        
        showCustomConfirm(`确定要对 ${availableChildren.length} 个可培养的孩子进行${training.name}培养吗？\n消耗 ${totalCost} 元\n\n效果: ${getAttributeDisplayName(training.effect)}+1/孩子`, (confirmed) => {
            if (confirmed) {
                let trainedCount = 0;
                let totalAttributeIncrease = 0;
                
                availableChildren.forEach((child) => {
                    const childIndex = children.findIndex(c => c.id === child.id);
                    if (childIndex !== -1) {
                        // 保存旧值
                        const oldValue = child.attributes[training.effect] || 1;
                        
                        // 增加属性
                        if (!child.attributes[training.effect]) {
                            child.attributes[training.effect] = 1;
                        }
                        child.attributes[training.effect] += 1;
                        const newValue = child.attributes[training.effect];
                        
                        child.lastTraining = now;
                        child.totalTraining = (child.totalTraining || 0) + 1;
                        trainedCount++;
                        totalAttributeIncrease += (newValue - oldValue);
                        
                        console.log(`孩子 ${child.name} ${training.effect}: ${oldValue} → ${newValue}`);
                        
                        // 检查成长
                        checkChildGrowth(childIndex);
                    }
                });
                
                if (trainedCount > 0) {
                    player.investmentGame.userData.availableFunds -= totalCost;
                    
                    logAction(`对 ${trainedCount} 个孩子进行了${training.name}培养，${getAttributeDisplayName(training.effect)} 总共增加了 ${totalAttributeIncrease} 点`, "success");
                    
                    updateChildSystemUI();
                    updateDisplay();
                    saveGame();
                }
            }
        });
        
    } catch (error) {
        console.error('全体培养时发生错误:', error);
        logAction("全体培养过程中出现错误", "error");
    }
}
function getAttributeDisplayName(attribute) {
    const displayNames = {
        'intelligence': '智力',
        'physique': '体质',
        'charm': '魅力',
        'business': '商业'
    };
    return displayNames[attribute] || attribute;
}

function ensureChildAttributes(child) {
    if (!child.attributes) {
        child.attributes = {
            intelligence: 1,
            physique: 1,
            charm: 1,
            business: 1
        };
    }
    
    // 确保所有属性都存在
    const defaultAttributes = ['intelligence', 'physique', 'charm', 'business'];
    defaultAttributes.forEach(attr => {
        if (child.attributes[attr] === undefined || child.attributes[attr] === null) {
            child.attributes[attr] = 1;
        }
    });
    
    return child;
}
function createNewChild(name, gender) {
    const child = {
        id: 'child_' + Date.now(),
        name: name,
        gender: gender,
        birthDate: Date.now(),
        age: 0,
        growthStage: 0,
        isAdult: false, // 明确标记为非成年
        attributes: {
            intelligence: 1,
            physique: 1,
            charm: 1,
            business: 1
        },
        lastTraining: 0,
        totalTraining: 0,
        lastInteraction: 0,
        totalInteractions: 0,
        intimacy: 0,
        currentJob: null,
        workStartTime: 0
    };
    
    return ensureChildAttributes(child);
}

// 检查孩子成长
function checkChildGrowth(childIndex) {
    const child = player.children.children[childIndex];
    if (!child || child.isAdult) return;
    
    const growthInfo = calculateGrowthCountdown(child);
    
    // 如果满足成长条件，自动成长
    if (growthInfo.canGrow) {
        growChildToNextStage(childIndex);
    }
}
function growChildToNextStage(childIndex) {
    const child = player.children.children[childIndex];
    if (!child) return;
    
    const currentStage = childConfig.growthStages[child.growthStage];
    const nextStage = childConfig.growthStages[child.growthStage + 1];
    
    if (!nextStage) {
        // 到达最后阶段，标记为成年
        child.isAdult = true;
        child.growthStage = childConfig.growthStages.length - 1; // 确保索引正确
        logAction(`🎉 ${child.name} 已经长大成人了！现在可以工作了！`, "success");
    } else {
        // 成长到下一阶段
        const oldStage = currentStage.name;
        child.growthStage++;
        const newStage = nextStage.name;
        
        // 成长奖励
        const growthBonus = calculateGrowthBonus(child);
        applyGrowthBonus(child, growthBonus);
        
        logAction(`🎉 ${child.name} 从 ${oldStage} 成长到了 ${newStage}！`, "success");
        
        // 检查是否到达成年阶段
        if (child.growthStage >= childConfig.growthStages.length - 1) {
            child.isAdult = true;
            logAction(`🎉 ${child.name} 已经长大成人了！现在可以工作了！`, "success");
        }
    }
    
    updateChildSystemUI();
    saveGame();
    
    // 递归检查是否可以继续成长
    setTimeout(() => checkChildGrowth(childIndex), 100);
}


function calculateGrowthBonus(child) {
    const stageMultiplier = child.growthStage * 0.1; // 每阶段增加10%奖励
    
    return {
        intelligence: Math.floor(1 + stageMultiplier),
        physique: Math.floor(1 + stageMultiplier),
        charm: Math.floor(1 + stageMultiplier),
        business: Math.floor(1 + stageMultiplier)
    };
}
// 应用成长奖励
function applyGrowthBonus(child, bonus) {
    Object.keys(bonus).forEach(attribute => {
        child.attributes[attribute] += bonus[attribute];
    });
}
function updateGrowthOverview() {
    const container = document.getElementById('growthOverview');
    if (!container) return;
    
    const children = player.children.children || [];
    if (children.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 10px;">还没有孩子</div>';
        return;
    }
    
    // 统计成长信息
    let totalTimeRemaining = 0;
    let totalAttributesNeeded = 0;
    let canGrowCount = 0;
    let growingChildren = 0;
    
    children.forEach(child => {
        const growthInfo = calculateGrowthCountdown(child);
        if (growthInfo.canGrow) {
            canGrowCount++;
        }
        if (growthInfo.timeRemaining > 0 || growthInfo.attributesNeeded > 0) {
            growingChildren++;
        }
        totalTimeRemaining += growthInfo.timeRemaining;
        totalAttributesNeeded += growthInfo.attributesNeeded;
    });
    
    const avgHoursRemaining = Math.floor(totalTimeRemaining / children.length / (60 * 60 * 1000));
    const avgMinutesRemaining = Math.floor((totalTimeRemaining / children.length % (60 * 60 * 1000)) / (60 * 1000));
    
    container.innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; font-size: 11px;">
            <div style="color: #4CAF50;">可成长: ${canGrowCount}个</div>
            <div style="color: #87CEEB;">成长中: ${growingChildren}个</div>
            <div style="color: #FFA500;">平均时间: ${avgHoursRemaining}h${avgMinutesRemaining}m</div>
        </div>
    `;
}
// 更新孩子加成
function updateChildBonuses() {
    const container = document.getElementById('childBonuses');
    const bonuses = calculateChildBonuses();
    
    container.innerHTML = `
        <div>GPS加成: +${((bonuses.gpsMultiplier - 1) * 100).toFixed(1)}%</div>
        <div>点击加成: +${((bonuses.clickMultiplier - 1) * 100).toFixed(1)}%</div>
        <div>生命值: +${(bonuses.critRateBonus * 100).toFixed(2)}%</div>
        <div>攻击值: +${(bonuses.goldMultiplier * 100).toFixed(2)}%</div>
        <div style="margin-top: 10px; font-size: 12px; color: #ccc;">
            加成来自所有孩子的属性总和
        </div>
    `;
    
    // 更新玩家数据中的加成
    player.children.childBonuses = bonuses;
}
function triggerChildEvents() {
    if (!player.children || !player.children.children.length) return;
    
    const events = [
        {
            name: "孩子生日",
            condition: () => {
                const today = new Date();
                return player.children.children.some(child => {
                    const birthDate = new Date(child.birthDate);
                    return birthDate.getDate() === today.getDate() && 
                           birthDate.getMonth() === today.getMonth();
                });
            },
            effect: () => {
                const birthdayChildren = player.children.children.filter(child => {
                    const birthDate = new Date(child.birthDate);
                    const today = new Date();
                    return birthDate.getDate() === today.getDate() && 
                           birthDate.getMonth() === today.getMonth();
                });
                
                birthdayChildren.forEach(child => {
                    // 生日奖励
                    Object.keys(child.attributes).forEach(attr => {
                        child.attributes[attr]++;
                    });
                    logAction(`${child.name} 过生日，所有属性+1！`, "success");
                });
            }
        },
        {
            name: "家庭聚会",
            condition: () => Math.random() < 0.01, // 1%几率触发
            effect: () => {
                const happinessBonus = 10;
                logAction("举办了家庭聚会，家庭幸福度大幅提升！", "success");
                // 这里可以添加具体的幸福度提升逻辑
            }
        }
    ];
    
    events.forEach(event => {
        if (event.condition()) {
            event.effect();
        }
    });
}

// 孩子互动功能
function interactWithChild(childIndex) {
    const child = player.children.children[childIndex];
    if (!child) return;
    
    const now = Date.now();
    const lastInteraction = child.lastInteraction || 0;
    const interactionCooldown = 3 * 60 * 60 * 1000; // 3小时冷却
    
    if (now - lastInteraction < interactionCooldown) {
        const remainingTime = interactionCooldown - (now - lastInteraction);
        const hoursRemaining = Math.floor(remainingTime / (60 * 60 * 1000));
        const minutesRemaining = Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000));
        logAction(`${child.name} 互动冷却中，还需等待 ${hoursRemaining}小时${minutesRemaining}分钟`, "error");
        return;
    }
    
    if (player.investmentGame.userData.availableFunds < 5000) {
        logAction("资金不足！需要 5000 元", "error");
        return;
    }
    
    // 扣除金币
    player.investmentGame.userData.availableFunds -= 5000;
    
    // 互动效果
    const interactions = [
        { name: "玩耍", effect: "physique", message: "和孩子一起玩耍" },
        { name: "讲故事", effect: "intelligence", message: "给孩子讲故事" },
        { name: "外出", effect: "charm", message: "带孩子外出游玩" },
        { name: "购物", effect: "business", message: "教孩子购物" }
    ];
    
    const interaction = interactions[Math.floor(Math.random() * interactions.length)];
    
    // 增加属性
    child.attributes[interaction.effect] = (child.attributes[interaction.effect] || 0) + 1;
    
    // 增加亲密度
    child.intimacy = (child.intimacy || 0) + 1;
    child.totalInteractions = (child.totalInteractions || 0) + 1;
    child.lastInteraction = now;
    
    // 小几率获得额外奖励
    let bonusMessage = "";
    if (Math.random() < 0.1) { // 10%几率获得额外奖励
        const bonusAttribute = Object.keys(child.attributes)[Math.floor(Math.random() * Object.keys(child.attributes).length)];
        child.attributes[bonusAttribute] += 1;
        bonusMessage = `，并且额外增加了${getAttributeDisplayName(bonusAttribute)}`;
    }
    
    logAction(`${interaction.message}，${child.name} 的${getAttributeDisplayName(interaction.effect)}+1${bonusMessage}，亲密度+1`, "success");
    
    updateChildSystemUI();
    updateDisplay();
    saveGame();
}
function interactWithAllChildren() {
    const children = player.children.children || [];
    const now = Date.now();
    const interactionCooldown = 3 * 60 * 60 * 1000;
    
    const availableChildren = children.filter(child => {
        const lastInteraction = child.lastInteraction || 0;
        return now - lastInteraction >= interactionCooldown;
    });
    
    if (availableChildren.length === 0) {
        logAction("所有孩子都在互动冷却中", "error");
        return;
    }
    
    const totalCost = 5000 * availableChildren.length;
    if (player.investmentGame.userData.availableFunds < totalCost) {
        logAction(`资金不足！需要 ${totalCost} 元`, "error");
        return;
    }
    
    showCustomConfirm(`确定要与 ${availableChildren.length} 个孩子互动吗？\n消耗 ${totalCost} 元`, (confirmed) => {
        if (confirmed) {
            let interactedCount = 0;
            let totalAttributes = 0;
            
            availableChildren.forEach(child => {
                const interactions = [
                    { effect: "physique" }, { effect: "intelligence" }, 
                    { effect: "charm" }, { effect: "business" }
                ];
                const interaction = interactions[Math.floor(Math.random() * interactions.length)];
                
                child.attributes[interaction.effect] += 1;
                child.intimacy = (child.intimacy || 0) + 1;
                child.totalInteractions = (child.totalInteractions || 0) + 1;
                child.lastInteraction = now;
                
                interactedCount++;
                totalAttributes++;
            });
            
            if (interactedCount > 0) {
                player.investmentGame.userData.availableFunds -= totalCost;
                logAction(`与 ${interactedCount} 个孩子互动，总共增加了 ${totalAttributes} 点属性`, "success");
                
                updateChildSystemUI();
                updateDisplay();
                saveGame();
            }
        }
    });
}

// 辅助函数：获取孩子年龄
function getChildAge(child) {
    const birthDate = child.birthDate || Date.now();
    const ageInYears = Math.floor((Date.now() - birthDate) / (1 * 24 * 60 * 60 * 1000));
    return Math.max(0, ageInYears);
}

function updateChildWorkSystem() {
    const container = document.getElementById('childWorkSystem');
    if (!container) return;
    
    const children = player.children.children || [];
    const adultChildren = children.filter(child => {
        // 多重条件检测成年状态
        const isAdultByAge = child.isAdult === true;
        const isAdultByStage = child.growthStage >= childConfig.growthStages.length - 1;
        return isAdultByAge || isAdultByStage;
    });
    
    console.log('工作系统检查:', {
        totalChildren: children.length,
        adultChildren: adultChildren.length,
        adultChildrenList: adultChildren.map(c => ({ name: c.name, isAdult: c.isAdult, growthStage: c.growthStage }))
    });
    
    if (adultChildren.length === 0) {
        container.innerHTML = `
            <h3>孩子工作系统</h3>
            <div style="text-align: center; color: #888; padding: 20px; background: #444; border-radius: 5px;">
                <div>还没有成年孩子可以工作</div>
                <div style="font-size: 12px; margin-top: 10px;">
                    孩子需要成长到青年阶段才能工作
                </div>
                <div style="font-size: 11px; color: #FFA500; margin-top: 5px;">
                    当前成长阶段: ${getGrowthStageInfo(children)}
                </div>
        `;
        return;
    }
    
    container.innerHTML = `
        <h3>孩子工作系统</h3>
        <div style="margin-bottom: 10px; font-size: 12px; color: #ccc;">
            成年孩子可以工作赚取金币 (${adultChildren.length}/${children.length} 个成年)
        </div>
        <div id="workChildrenList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px;">
            <!-- 工作孩子列表会动态生成 -->
        </div>
        <div style="display: flex; gap: 10px;">
            <button onclick="collectAllChildWorkIncome()" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; flex: 1;">收取所有工作收入</button>
            <button onclick="autoAssignAllJobs()" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; flex: 1;">自动分配工作</button>
        </div>
    `;
    
    updateWorkChildrenList();
}
// 获取成长阶段信息
function getGrowthStageInfo(children) {
    if (children.length === 0) return "没有孩子";
    
    const stageCounts = {};
    children.forEach(child => {
        const stage = childConfig.growthStages[child.growthStage]?.name || '未知';
        stageCounts[stage] = (stageCounts[stage] || 0) + 1;
    });
    
    return Object.entries(stageCounts).map(([stage, count]) => `${stage}×${count}`).join(', ');
}
// 更新工作孩子列表
function updateWorkChildrenList() {
    const container = document.getElementById('workChildrenList');
    if (!container) return;
    
    const children = player.children.children || [];
    const adultChildren = children.filter(child => child.isAdult || child.growthStage >= childConfig.growthStages.length - 1);
    
    container.innerHTML = '';
    
    if (adultChildren.length === 0) {
        container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #888; padding: 20px;">没有成年孩子</div>';
        return;
    }
    
    adultChildren.forEach((child, index) => {
        const actualIndex = children.findIndex(c => c.id === child.id);
        if (actualIndex === -1) return;
        
        const workCard = document.createElement('div');
        workCard.style.background = '#555';
        workCard.style.padding = '10px';
        workCard.style.borderRadius = '5px';
        workCard.style.border = '1px solid #666';
        workCard.style.position = 'relative';
        
        const workInfo = getChildWorkInfo(child);
        const growthStage = childConfig.growthStages[child.growthStage];
        
        // 当前工作指示器
        const currentJobIndicator = workInfo.currentJob ? `
            <div style="position: absolute; top: 5px; right: 5px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; font-size: 8px;">
                ${workInfo.currentJob}
            </div>
        ` : '';
        
        workCard.innerHTML = currentJobIndicator + `
            <div style="font-weight: bold; color: #FF69B4;">${child.name}</div>
            <div style="font-size: 12px; color: #ccc;">${child.gender === 'boy' ? '👦' : '👧'} ${growthStage?.name || '成年'}</div>
            
            <div style="margin: 8px 0;">
                ${workInfo.currentJob ? `
                    <div style="font-size: 11px; color: #4CAF50;">职业: ${workInfo.currentJob}</div>
                    <div style="font-size: 10px; color: #FFD700;">时薪: ${formatNumber(workInfo.hourlyIncome)} 元</div>
                    <div style="font-size: 10px; color: #87CEEB;">已工作: ${workInfo.hoursWorked.toFixed(1)} 小时</div>
                    <div style="font-size: 10px; color: #32CD32;">待收: ${formatNumber(workInfo.pendingIncome)} 元</div>
                ` : `
                    <div style="font-size: 11px; color: #FF6B6B;">待业中</div>
                    <div style="font-size: 10px; color: #ccc;">点击开始工作</div>
                `}
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 10px;">
                <div style="color: #2196F3;">智力: ${child.attributes.intelligence}</div>
                <div style="color: #4CAF50;">体质: ${child.attributes.physique}</div>
                <div style="color: #9C27B0;">魅力: ${child.attributes.charm}</div>
                <div style="color: #FF9800;">商业: ${child.attributes.business}</div>
            </div>
            
            <div style="margin-top: 8px; display: flex; gap: 3px;">
                ${!workInfo.currentJob ? `
                    <button onclick="startChildWork(${actualIndex})" style="background: #4CAF50; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 9px; flex: 1;">开始工作</button>
                ` : `
                    <button onclick="stopChildWork(${actualIndex})" style="background: #FF9800; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 9px; flex: 1;">停止工作</button>
                    <button onclick="collectChildWorkIncome(${actualIndex})" style="background: #2196F3; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 9px; flex: 1;">收取</button>
                `}
                <button onclick="showJobSelection(${actualIndex})" style="background: #9C27B0; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 9px; flex: 1;">换工作</button>
            </div>
        `;
        
        container.appendChild(workCard);
    });
}


function getChildWorkInfo(child) {
    const now = Date.now();
    const jobs = {
        "学者": { attribute: "intelligence", baseIncome: 12000 },
        "运动员": { attribute: "physique", baseIncome: 8400 },
        "艺人": { attribute: "charm", baseIncome: 4600 },
        "商人": { attribute: "business", baseIncome: 9500 }
    };
    
    if (!child.currentJob) {
        return { currentJob: null, hourlyIncome: 0, hoursWorked: 0, pendingIncome: 0 };
    }
    
    const job = jobs[child.currentJob];
    if (!job) {
        return { currentJob: null, hourlyIncome: 0, hoursWorked: 0, pendingIncome: 0 };
    }
    
    const workStartTime = child.workStartTime || now;
    const hoursWorked = (now - workStartTime) / (60 * 60 * 1000);
    const hourlyIncome = job.baseIncome * (child.attributes[job.attribute] || 1);
    const pendingIncome = Math.floor(hoursWorked * hourlyIncome);
    
    return {
        currentJob: child.currentJob,
        hourlyIncome: hourlyIncome,
        hoursWorked: hoursWorked,
        pendingIncome: pendingIncome
    };
}

// 孩子工作系统（成年孩子）
function startChildWork(childIndex) {
    const child = player.children.children[childIndex];
    if (!child) {
        logAction("无效的孩子索引", "error");
        return;
    }
    
    // 检查是否成年
    if (!child.isAdult && child.growthStage < childConfig.growthStages.length - 1) {
        const currentStage = childConfig.growthStages[child.growthStage]?.name || '未知';
        logAction(`${child.name} 还是${currentStage}，需要成长到青年阶段才能工作`, "error");
        return;
    }
    
    if (child.currentJob) {
        logAction(`${child.name} 已经在工作了`, "error");
        return;
    }
    
    // 自动选择最适合的工作
    const bestJob = getBestJobForChild(child);
    child.currentJob = bestJob.name;
    child.workStartTime = Date.now();
    
    logAction(`${child.name} 开始从事${bestJob.name}工作，时薪 ${formatNumber(bestJob.hourlyIncome)} 元`, "success");
    updateChildSystemUI();
    saveGame();
}
function collectChildWorkIncome(childIndex) {
    const child = player.children.children[childIndex];
    if (!child || !child.currentJob) {
        logAction("该孩子没有在工作", "error");
        return;
    }
    
    const workInfo = getChildWorkInfo(child);
    if (workInfo.pendingIncome > 0) {
        player.investmentGame.userData.availableFunds += workInfo.pendingIncome;
        child.workStartTime = Date.now(); // 重置工作时间
        
        logAction(`收取 ${child.name} 的工作收入: ${formatNumber(workInfo.pendingIncome)} 元`, "success");
        updateDisplay();
        updateChildSystemUI();
        saveGame();
    } else {
        logAction(`${child.name} 还没有收入可以收取`, "info");
    }
}
function autoAssignAllJobs() {
    const children = player.children.children || [];
    const adultChildren = children.filter(child => child.isAdult && !child.currentJob);
    
    if (adultChildren.length === 0) {
        logAction("没有需要分配工作的孩子", "info");
        return;
    }
    
    let assignedCount = 0;
    adultChildren.forEach(child => {
        const bestJob = getBestJobForChild(child);
        child.currentJob = bestJob.name;
        child.workStartTime = Date.now();
        assignedCount++;
    });
    
    if (assignedCount > 0) {
        logAction(`为 ${assignedCount} 个孩子自动分配了工作`, "success");
        updateChildSystemUI();
        saveGame();
    }
}
function getBestJobForChild(child) {
    const jobs = [
        { name: "学者", attribute: "intelligence", baseIncome: 12000 },
        { name: "运动员", attribute: "physique", baseIncome: 8400 },
        { name: "艺人", attribute: "charm", baseIncome: 5600 },
        { name: "商人", attribute: "business", baseIncome: 9500 }
    ];
    
    // 计算每个工作的时薪
    const jobOptions = jobs.map(job => {
        const hourlyIncome = job.baseIncome * (child.attributes[job.attribute] || 1);
        return { ...job, hourlyIncome: hourlyIncome };
    });
    
    // 选择时薪最高的工作
    return jobOptions.reduce((best, job) => job.hourlyIncome > best.hourlyIncome ? job : best);
}
function showJobSelection(childIndex) {
    const child = player.children.children[childIndex];
    if (!child || !child.isAdult) {
        logAction("只有成年孩子才能工作", "error");
        return;
    }
    
    const jobs = [
        { 
            id: "scholar", 
            name: "学者", 
            attribute: "intelligence", 
            baseIncome: 12000, 
            description: "适合智力高的孩子", 
            color: "#2196F3",
            icon: "📚"
        },
        { 
            id: "athlete", 
            name: "运动员", 
            attribute: "physique", 
            baseIncome: 8400, 
            description: "适合体质高的孩子", 
            color: "#4CAF50",
            icon: "🏃"
        },
        { 
            id: "artist", 
            name: "艺人", 
            attribute: "charm", 
            baseIncome: 5600, 
            description: "适合魅力高的孩子", 
            color: "#9C27B0",
            icon: "🎭"
        },
        { 
            id: "businessman", 
            name: "商人", 
            attribute: "business", 
            baseIncome: 9500, 
            description: "适合商业能力高的孩子", 
            color: "#FF9800",
            icon: "💼"
        }
    ];
    
    // 计算每个工作的时薪
    const jobOptions = jobs.map(job => {
        const hourlyIncome = job.baseIncome * (child.attributes[job.attribute] || 1);
        const currentAttribute = child.attributes[job.attribute] || 1;
        const suitability = calculateJobSuitability(child, job);
        
        return {
            ...job,
            hourlyIncome: hourlyIncome,
            currentAttribute: currentAttribute,
            suitability: suitability,
            isCurrent: child.currentJob === job.name
        };
    });
    
    // 按适合度排序
    jobOptions.sort((a, b) => b.suitability - a.suitability);
    
    // 创建选择对话框
    const dialog = document.createElement('div');
    dialog.id = 'jobSelectionDialog';
    dialog.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #2a2a2a;
        border: 3px solid #FF69B4;
        border-radius: 10px;
        padding: 20px;
        z-index: 1002;
        width: 500px;
        max-width: 90vw;
        max-height: 80vh;
        overflow-y: auto;
        color: white;
    `;
    
    dialog.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #FF69B4; padding-bottom: 10px;">
            <h3 style="color: #FF69B4; margin: 0;">为 ${child.name} 选择职业</h3>
            <button onclick="closeJobSelection()" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">关闭</button>
        </div>
        
        <div style="margin-bottom: 15px; background: #333; padding: 10px; border-radius: 5px;">
            <div style="font-size: 12px; color: #ccc;">当前属性:</div>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-top: 5px;">
                <div style="color: #2196F3;">智力: ${child.attributes.intelligence}</div>
                <div style="color: #4CAF50;">体质: ${child.attributes.physique}</div>
                <div style="color: #9C27B0;">魅力: ${child.attributes.charm}</div>
                <div style="color: #FF9800;">商业: ${child.attributes.business}</div>
            </div>
        </div>
        
        <div id="jobOptionsContainer" style="display: grid; gap: 10px;">
            <!-- 工作选项会动态生成 -->
        </div>
        
        <div style="margin-top: 15px; text-align: center; font-size: 12px; color: #888;">
            点击职业卡片进行选择
        </div>
    `;
    
    // 添加遮罩层
    const overlay = document.createElement('div');
    overlay.id = 'jobSelectionOverlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 1001;
    `;
    
    document.body.appendChild(overlay);
    document.body.appendChild(dialog);
    
    // 生成工作选项
    const container = document.getElementById('jobOptionsContainer');
    container.innerHTML = '';
    
    jobOptions.forEach((job, index) => {
        const jobCard = document.createElement('div');
        jobCard.className = 'job-option';
        jobCard.style.cssText = `
            background: ${job.isCurrent ? '#1a1a1a' : '#333'};
            border: 2px solid ${job.color};
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        `;
        
        if (job.isCurrent) {
            jobCard.innerHTML += `
                <div style="position: absolute; top: 5px; right: 5px; background: ${job.color}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px;">
                    当前职业
                </div>
            `;
        }
        
        jobCard.innerHTML += `
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <div style="font-size: 24px; margin-right: 10px;">${job.icon}</div>
                <div>
                    <div style="font-weight: bold; color: ${job.color}; font-size: 16px;">${job.name}</div>
                    <div style="font-size: 12px; color: #ccc;">适合度: ${job.suitability}%</div>
                </div>
            </div>
            
            <div style="margin-bottom: 10px;">
                <div style="font-size: 12px; color: #ccc;">${job.description}</div>
                <div style="font-size: 11px; color: #FFD700;">时薪: ${formatNumber(job.hourlyIncome)} 金币</div>
                <div style="font-size: 11px; color: ${job.color};">需要: ${getAttributeDisplayName(job.attribute)} ${job.currentAttribute}</div>
            </div>
            
            <div style="background: #444; border-radius: 3px; height: 6px; margin: 5px 0;">
                <div style="background: ${job.color}; height: 100%; border-radius: 3px; width: ${job.suitability}%;"></div>
            </div>
            <div style="font-size: 10px; color: #ccc; text-align: center;">适合度</div>
            
            ${job.isCurrent ? `
                <div style="margin-top: 10px; text-align: center;">
                    <div style="color: #4CAF50; font-size: 11px;">✓ 当前职业</div>
                </div>
            ` : `
                <button onclick="selectJob(${childIndex}, '${job.id}')" 
                        style="margin-top: 10px; background: ${job.color}; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; width: 100%; font-size: 12px;">
                    选择此职业
                </button>
            `}
        `;
        
        // 添加悬停效果
        jobCard.onmouseenter = function() {
            this.style.transform = 'translateY(-2px)';
            this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
        };
        jobCard.onmouseleave = function() {
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = 'none';
        };
        
        container.appendChild(jobCard);
    });
}
function calculateJobSuitability(child, job) {
    const attributeValue = child.attributes[job.attribute] || 1;
    const maxAttribute = Math.max(1, ...Object.values(child.attributes));
    
    // 基础适合度基于属性值
    let suitability = (attributeValue / maxAttribute) * 100;
    
    // 如果这是当前工作，增加适合度
    if (child.currentJob === job.name) {
        suitability += 20;
    }
    
    // 确保在0-100范围内
    return Math.min(100, Math.max(0, Math.round(suitability)));
}
function selectJob(childIndex, jobId) {
    const child = player.children.children[childIndex];
    if (!child) return;
    
    const jobs = {
        "scholar": { name: "学者", attribute: "intelligence", baseIncome: 12000 },
        "athlete": { name: "运动员", attribute: "physique", baseIncome: 8400 },
        "artist": { name: "艺人", attribute: "charm", baseIncome: 5600 },
        "businessman": { name: "商人", attribute: "business", baseIncome: 9500 }
    };
    
    const selectedJob = jobs[jobId];
    if (!selectedJob) return;
    
    // 先收取当前工作收入（如果有）
    if (child.currentJob) {
        collectChildWorkIncome(childIndex);
    }
    
    child.currentJob = selectedJob.name;
    child.workStartTime = Date.now();
    
    logAction(`${child.name} 现在从事${selectedJob.name}工作`, "success");
    
    // 关闭对话框
    closeJobSelection();
    
    updateChildSystemUI();
    saveGame();
}
function closeJobSelection() {
    const dialog = document.getElementById('jobSelectionDialog');
    const overlay = document.getElementById('jobSelectionOverlay');
    
    if (dialog) dialog.remove();
    if (overlay) overlay.remove();
}

function updateChildInteractionSystem() {
    const container = document.getElementById('childInteractionSystem');
    if (!container) return;
    
    const children = player.children.children || [];
    if (children.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">还没有孩子可以互动</div>';
        return;
    }
    
    container.innerHTML = `
        <h3>亲子互动</h3>
        <div style="margin-bottom: 10px; font-size: 12px; color: #ccc;">
            与孩子互动可以增加亲密度和属性
        </div>
        <div id="interactionChildrenList" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px;">
            <!-- 互动孩子列表会动态生成 -->
        </div>
        <button onclick="interactWithAllChildren()" style="background: #FF69B4; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; width: 100%;">与所有孩子互动</button>
    `;
    
    updateInteractionChildrenList();
}
function updateInteractionChildrenList() {
    const container = document.getElementById('interactionChildrenList');
    if (!container) return;
    
    const children = player.children.children || [];
    
    container.innerHTML = '';
    
    children.forEach((child, index) => {
        const interactionCard = document.createElement('div');
        interactionCard.style.background = '#555';
        interactionCard.style.padding = '10px';
        interactionCard.style.borderRadius = '5px';
        interactionCard.style.border = '1px solid #666';
        
        // 计算互动冷却
        const now = Date.now();
        const lastInteraction = child.lastInteraction || 0;
        const interactionCooldown = 3 * 60 * 60 * 1000; // 2小时冷却
        const remainingTime = Math.max(0, interactionCooldown - (now - lastInteraction));
        const canInteract = remainingTime <= 0;
        const hoursRemaining = Math.floor(remainingTime / (60 * 60 * 1000));
        const minutesRemaining = Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000));
        
        interactionCard.innerHTML = `
            <div style="font-weight: bold; color: #FF69B4;">${child.name}</div>
            <div style="font-size: 12px; color: #ccc;">${child.gender === 'boy' ? '👦' : '👧'} ${getChildAge(child)}岁</div>
            
            <div style="margin: 8px 0; font-size: 11px;">
                <div style="color: ${canInteract ? '#4CAF50' : '#FF6B6B'};">
                    ${canInteract ? '可互动' : `冷却中: ${hoursRemaining}时${minutesRemaining}分`}
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px; font-size: 10px;">
                <div style="color: #32CD32;">亲密度: ${child.intimacy || 0}</div>
                <div style="color: #FFD700;">互动: ${child.totalInteractions || 0}次</div>
            </div>
            
            <button onclick="interactWithChild(${index})" 
                    style="margin-top: 8px; background: ${canInteract ? '#FF69B4' : '#888'}; color: white; border: none; padding: 5px; border-radius: 3px; cursor: ${canInteract ? 'pointer' : 'not-allowed'}; font-size: 10px; width: 100%;"
                    ${canInteract ? '' : 'disabled'}>
                ${canInteract ? '互动 (消耗 5000 元)' : '冷却中'}
            </button>
        `;
        
        container.appendChild(interactionCard);
    });
}

function collectAllChildWorkIncome() {
    const children = player.children.children || [];
    let totalIncome = 0;
    let collectedCount = 0;
    
    children.forEach((child, index) => {
        if (child.isAdult && child.currentJob) {
            const workInfo = getChildWorkInfo(child);
            if (workInfo.pendingIncome > 0) {
                player.investmentGame.userData.availableFunds += workInfo.pendingIncome;
                totalIncome += workInfo.pendingIncome;
                child.workStartTime = Date.now();
                collectedCount++;
            }
        }
    });
    
    if (totalIncome > 0) {
        logAction(`收取了 ${collectedCount} 个孩子的工作收入，总计: ${formatNumber(totalIncome)} 元`, "success");
        updateDisplay();
        updateChildSystemUI();
        saveGame();
    } else {
        logAction("没有工作收入可以收取", "info");
    }
}

// 收取孩子工作收入
function collectChildWorkIncome() {
    let totalIncome = 0;
    player.children.children.forEach(child => {
        if (child.isAdult && child.currentJob) {
            const workTime = Date.now() - child.workStartTime;
            const hoursWorked = workTime / (60 * 60 * 1000);
            const job = getJobByAttribute(child.currentJob);
            const income = Math.floor(job.income * hoursWorked);
            
            if (income > 0) {
                player.investmentGame.userData.availableFunds += income;
                totalIncome += income;
                child.workStartTime = Date.now();
            }
        }
    });
    
    if (totalIncome > 0) {
        logAction(`收取孩子工作收入：${formatNumber(totalIncome)} 元`, "success");
        updateDisplay();
        saveGame();
    }
}

function getJobByAttribute(jobName) {
    const jobs = {
        "学者": { attribute: "intelligence", income: 12000 },
        "运动员": { attribute: "physique", income: 8400 },
        "艺人": { attribute: "charm", income: 5600 },
        "商人": { attribute: "business", income: 9500 }
    };
    return jobs[jobName];
}

// 孩子婚姻系统（扩展功能）
function arrangeMarriage(childIndex) {
    const child = player.children.children[childIndex];
    if (!child || !child.isAdult) {
        logAction("只有成年孩子才能结婚", "error");
        return;
    }
    
    const marriageCost = 2000000; // 200万转生币
    if (player.investmentGame.userData.availableFunds < marriageCost) {
        logAction(`资金不足！需要 ${marriageCost} 元`, "error");
        return;
    }
    
    showCustomConfirm(`确定要为 ${child.name} 安排婚姻吗？消耗 ${marriageCost} 元`, (confirmed) => {
        if (confirmed) {
            player.investmentGame.userData.availableFunds -= marriageCost;
            child.isMarried = true;
            child.marriageDate = Date.now();
            
            // 生成配偶
            const spouseGender = child.gender === 'boy' ? 'girl' : 'boy';
            const spouseNames = {
                boy: ['小明', '小强', '小刚', '小勇', '小伟'],
                girl: ['小红', '小芳', '小丽', '小美', '小静']
            };
            child.spouse = {
                name: spouseNames[spouseGender][Math.floor(Math.random() * spouseNames[spouseGender].length)],
                gender: spouseGender
            };
            
            logAction(`为 ${child.name} 安排了婚姻，配偶：${child.spouse.name}`, "success");
            updateChildSystemUI();
            saveGame();
        }
    });
}
// 计算孩子加成
function calculateChildBonuses() {
    const children = player.children.children || [];
    let totalIntelligence = 0;
    let totalPhysique = 0;
    let totalCharm = 0;
    let totalBusiness = 0;
    
    children.forEach(child => {
        totalIntelligence += child.attributes.intelligence;
        totalPhysique += child.attributes.physique;
        totalCharm += child.attributes.charm;
        totalBusiness += child.attributes.business;
    });
    
    return {
        gpsMultiplier: 1 + (totalIntelligence * childConfig.attributeBonuses.intelligence.gps),
        clickMultiplier: 1 + (totalPhysique * childConfig.attributeBonuses.physique.click),
        critRateBonus: 1 + (totalCharm * childConfig.attributeBonuses.charm.critRate),
        goldMultiplier: 1 + (totalBusiness * childConfig.attributeBonuses.business.gold)
    };
}

// 计算家庭幸福度
function calculateFamilyHappiness() {
    const children = player.children.children || [];
    let happiness = 50; // 基础幸福度
    
    // 每个孩子+10点
    happiness += children.length * 10;
    
    // 根据孩子属性增加幸福度
    children.forEach(child => {
        happiness += (child.attributes.charm * 2);
        if (child.isAdult) happiness += 20;
    });
    
    return Math.min(100, happiness);
}

// 更新怀孕按钮状态
function updateConceptionButton() {
    const button = document.getElementById('conceiveBtn');
    if (player.children.isPregnant) {
        button.disabled = true;
        button.textContent = '已怀孕';
        button.style.background = '#888';
    } else {
        button.disabled = false;
        button.textContent = `怀孕 (消耗 ${childConfig.pregnancy.cost} 元)`;
        button.style.background = '#FF69B4';
    }
}
function showTrainingSelection(childIndex) {
    const child = player.children.children[childIndex];
    if (!child) return;
    
    const now = Date.now();
    const lastTraining = child.lastTraining || 0;
    const cooldown = 60 * 60 * 1000;
    const remainingTime = Math.max(0, cooldown - (now - lastTraining));
    const minutesRemaining = Math.ceil(remainingTime / (60 * 1000));
    
    let message = `选择对 ${child.name} 的培养方式：\n\n`;
    
    if (remainingTime > 0) {
        message += `⚠️ 培养冷却中: ${minutesRemaining}分钟后可再次培养\n\n`;
    }
    
    message += childConfig.trainingTypes.map(training => 
        `${training.name} (${training.cost}元) - ${training.description}`
    ).join('\n');
    
    showCustomPrompt(message, (selected) => {
        if (selected) {
            const trainingIndex = childConfig.trainingTypes.findIndex(t => 
                selected.includes(t.name)
            );
            if (trainingIndex !== -1) {
                trainChild(childIndex, childConfig.trainingTypes[trainingIndex].id);
            }
        }
    });
}
function startChildCooldownTimer() {
    registerInterval(() => {
        if (document.getElementById('childSystemUI').style.display === 'block') {
            updateChildrenList(); // 每分钟更新一次冷却时间显示
        }
    }, 60000); // 每分钟更新一次
}

// 在游戏主循环中添加孩子系统检查
function addChildSystemToGameLoop() {
    registerInterval(() => {
        if (player.children) {
            // 检查怀孕状态
            if (player.children.isPregnant) {
                const progress = calculatePregnancyProgress();
                if (progress >= 100) {
                    giveBirth();
                }
            }
            
            // 检查孩子成长
            if (player.children.children) {
                player.children.children.forEach((child, index) => {
                    checkChildGrowth(index);
                });
            }
            
            // 每5分钟更新一次UI
            if (Math.floor(Date.now() / 1000) % 300 === 0) {
                updateChildSystemUI();
            }
            
           
        }
    }, 60000); // 每分钟检查一次
}
document.addEventListener('DOMContentLoaded', function() {
    // 确保孩子系统正确初始化
    initChildData();
     initChildSystem();
    // 启动孩子系统主循环
    addChildSystemToGameLoop();
  if (typeof addReincarnationEquipmentButton === 'function') setTimeout(addReincarnationEquipmentButton, 1000);
});
const reincarnationEquipmentConfig = {
    // 装备部位
    slots: ['helmet', 'chest', 'pants', 'shoes', 'necklace', 'weapon'],
    
    // 装备部位名称
    slotNames: {
        helmet: '头盔',
        chest: '衣服',
        pants: '裤子',
        shoes: '鞋子',
        necklace: '项链',
        weapon: '武器'
    },
    
    // 品质配置
    rarities: {
        'common': { name: '普通', min: 1, max: 20, color: '#FFFFFF', weight: 80 },
        'uncommon': { name: '优秀', min: 5, max: 30, color: '#1EFF00', weight: 8.439 },
        'rare': { name: '精良', min: 10, max: 40, color: '#0070DD', weight: 5 },
        'epic': { name: '史诗', min: 20, max: 50, color: '#A335EE', weight: 3 },
        'legendary': { name: '传说', min: 30, max: 60, color: '#FF8000', weight: 2 },
        'mythic': { name: '神话', min: 40, max: 70, color: '#E6CC80', weight: 1 },
        'supreme': { name: '至尊', min: 50, max: 80, color: '#00CCFF', weight: 0.5 },
        'ancient': { name: '远古', min: 60, max: 90, color: '#FF4040', weight: 0.05 },
        'primordial': { name: '上古', min: 70, max: 100, color: '#FF00FF', weight: 0.01 },
        'eternal': { name: '荒古', min: 100, max: 100, color: '#FFD700', weight: 0.001 }
    },
    
    // 装备等级配置 (T1-T10)
    tiers: {
        1: { name: 'T1', minReincarnation: 1, multiplier: 1, weight: 90 },
        2: { name: 'T2', minReincarnation: 3, multiplier: 3, weight: 8.3339 },
        3: { name: 'T3', minReincarnation: 5, multiplier: 12, weight: 1 },
        4: { name: 'T4', minReincarnation: 8, multiplier: 42, weight: 0.5 },
        5: { name: 'T5', minReincarnation: 10, multiplier: 150, weight: 0.1 },
        6: { name: 'T6', minReincarnation: 12, multiplier: 525, weight: 0.05 },
        7: { name: 'T7', minReincarnation: 15, multiplier: 1840, weight: 0.01 },
        8: { name: 'T8', minReincarnation: 20, multiplier: 6433, weight: 0.005 },
        9: { name: 'T9', minReincarnation: 25, multiplier: 22520, weight: 0.001 },
        10: { name: 'T10', minReincarnation: 30, multiplier: 78880, weight: 0.0001 }
    },
    
    // 属性类型
    stats: ['health', 'attack', 'critRate', 'critDamage'],
    
    // 属性名称
    statNames: {
        health: '生命加成',
        attack: '攻击加成',
        critRate: '暴击率',
        critDamage: '爆伤加成'
    },
    
    // 词条数量概率
    statCountWeights: [80, 8.3334, 4, 2.5, 2, 1.5, 1, 0.5, 0.1, 0.05, 0.01, 0.005, 0.001, 0.0005, 0.0001], // 1-15个词条的概率
    
    // 套装配置
    sets: {
        'warrior': { name: '战士套装', bonuses: { 2: { health: 0.41, attack: 0.11 }, 4: { critRate: 1.05, critDamage: 1.2 }, 6: { health: 0.4, attack: 1.3 } } },
        'mage': { name: '法师套装', bonuses: { 2: { attack: 0.25, critRate: 1.03 }, 4: { critDamage: 0.55 }, 6: { attack: 1.4, critRate: 1.08 } } },
        'assassin': { name: '刺客套装', bonuses: { 2: { critRate: 1.06 }, 4: { critDamage: 0.3 }, 6: { critRate: 1.1, critDamage: 0.9 } } },
        'tank': { name: '坦克套装', bonuses: { 2: { health: 0.5 }, 4: { health: 0.8 }, 6: { health: 1.8 } } },
        'archer': { name: '射手套装', bonuses: { 2: { attack: 0.12, critRate: 1.04 }, 4: { critDamage: 0.28 }, 6: { attack: 1.35, critRate: 1.09 } } },
        'support': { name: '辅助套装', bonuses: { 2: { health: 0.25 }, 4: { health: 0.55, attack: 0.2 }, 6: { health: 0.5, attack: 0.4 } } },
        'suppora': { name: '神话套装', bonuses: { 2: { attack: 0.44 }, 4: { health: 0.45, attack: 0.5 }, 6: { health: 1.9, attack: 1.4 } } },
        'supporb': { name: '侠客套装', bonuses: { 2: { critRate: 1.235 }, 4: { health: 0.35, attack: 0.4 }, 6: { health: 1.6, attack: 0.8 } } },
        'supporc': { name: '拳皇套装', bonuses: { 2: { attack: 0.55 }, 4: { health: 0.21, critDamage: 0.2 }, 6: { health: 0.3, critDamage: 0.7 } } },
        'suppord': { name: '洪荒套装', bonuses: { 2: { health: 1.15 }, 4: { health: 1.25, attack: 1.4 }, 6: { health: 1.2, attack: 1.2, critRate: 1.012, critDamage: 1.3 } } },
       'suppore': { name: '渡劫套装', bonuses: { 2: { attack: 2.22 }, 4: { critDamage: 2.25, attack: 2.21 }, 6: { health: 1.3, critRate: 1.01, attack: 2.4 } } },
        'supporf': { name: '鱼鱼套装', bonuses: { 2: { health: 0.35 }, 4: { health: 0.25, attack: 0.21 }, 6: { health: 1.2, attack: 2.2, critRate: 1.212, critDamage: 0.2 } } },
       'supporaaa': { name: '茶茶套装', bonuses: { 2: { critDamage: 0.31 }, 4: { attack: 0.35, critDamage: 0.15 }, 6: { health: 1.5, attack: 1.8, critRate: 1.022, critDamage: 0.6 } } },
        'supporaaa': { name: '武神套装', bonuses: { 2: { attack: 0.75 }, 4: { health: 0.75, attack: 0.21 }, 6: { health: 2.2, attack: 1.2, critRate: 1.042, critDamage: 0.3 } } },
     'supporaaa': { name: '蚩尤套装', bonuses: { 2: { attack: 0.55 }, 4: { critDamage: 0.55, attack: 0.21 }, 6: { health: 1.00, attack: 2.00, critRate: 0.012, critDamage: 1.2 } } },
      'supporaaa': { name: '弑神套装', bonuses: { 2: { attack: 0.25 }, 4: { health: 0.45, attack: 0.21 }, 6: { health: 1.5, attack: 1.1, critRate: 1.023, critDamage: 0.72 } } },
    'supporaab': { name: '五行套装', bonuses: { 2: { health: 0.1, attack: 0.1, critRate: 0.01, critDamage: 0.10 }, 4: { health: 0.5, attack: 0.5, critRate: 0.05, critDamage: 0.5}, 6: { health: 0.8, attack: 0.8, critRate: 0.08, critDamage: 0.80 } } },
   'supporaac': { name: '八荒套装', bonuses: { 2: { health: 0.2, attack: 0.1, critRate: 0.023, critDamage: 0.22 }, 4: { health: 0.4, attack: 1.0, critRate: 0.023, critDamage: 0.2}, 6: { health: 0.4, attack: 1.0, critRate: 0.021, critDamage: 0.44 } } },
    'supporaad': { name: '圣王套装', bonuses: { 2: { health: 0.55, attack: 0.51 }, 4: { health: 0.85, attack: 0.8 }, 6: { health: 2.5, attack: 0.6, critRate: 1.01, critDamage: 0.22 } } },
      'supporaae': { name: '永恒套装', bonuses: { 2: { health: 0.13, attack: 0.12, critRate: 0.012, critDamage: 0.15 }, 4: { health: 0.5, attack: 0.25, critRate: 1.045, critDamage: 0.40}, 6: { health: 0.98, attack: 0.78, critRate: 1.033, critDamage: 0.92 } } },
      'supporaaf': { name: '地煞套装', bonuses: { 2: { health: 0.25, attack: 0.57 }, 4: { health: 0.35, attack: 0.91 }, 6: { health: 1.2, attack: 1.00, critRate: 1.05, critDamage: 1.72 } } },
    'supporaag': { name: '诸神套装', bonuses: { 2: { critDamage: 0.75 }, 4: { health: 0.25, critDamage: 1.51 }, 6: { health: 1.0,  critRate: 1.03, critDamage: 2.52 } } },
    'supporaah': { name: '不可思议套装', bonuses: { 2: { critRate: 1.1 }, 4: {  health: 1.2 , critDamage: 1.00 }, 6: { critRate: 1.3, critDamage: 4.00 } } },
       'supporg': { name: '闫闫套装', bonuses: { 2: { critRate: 0.015 }, 4: { health: 0.35, attack: 0.22 }, 6: { health: 0.4, attack: 1.6, critRate: 1.013, critDamage: 0.8 } } },
       'supporh': { name: '修罗套装', bonuses: { 2: { attack: 0.45 }, 4: { critDamage: 0.66, attack: 0.66 }, 6: { health: 0.5, attack: 1.1, critRate: 1.011, critDamage: 0.5 } } },
      'suppori': { name: '麒麟套装', bonuses: { 2: { attack: 0.75 }, 4: { health: 0.75, attack: 0.7 }, 6: { health: 1.5, attack: 3.4 } } },
     'suppork': { name: '鬼王套装', bonuses: { 2: { critDamage: 0.75 }, 4: { health: 0.35, critDamage: 1.31 }, 6: { health: 2.5, critDamage: 2.4 } } },
   'supporl': { name: '无极套装', bonuses: { 2: { critDamage: 0.95, attack: 0.4 }, 4: { health: 0.35, critDamage: 0.9 }, 6: { critDamage: 1.9, attack: 0.6 } } },
      'supporz': { name: '紫薇套装', bonuses: { 2: { critDamage: 0.45, attack: 0.37 }, 4: { health: 0.65, attack: 0.62 }, 6: { critRate: 1.15, attack: 1.4 } } },
       'supporx': { name: '地藏套装', bonuses: { 2: { critRate: 1.045 }, 4: { health: 1.05, attack: 1.2 }, 6: { health: 1.2, attack: 2.12 } } },
    'supporv': { name: '儒圣套装', bonuses: { 2: { critRate: 1.032 }, 4: { critRate: 1.055, critDamage: 0.9 }, 6: { critRate: 1.15, critDamage: 0.94 } } },
   'supporn': { name: '玄武套装', bonuses: { 2: { health: 0.80 }, 4: { health: 1.5 }, 6: { health: 2.0 } } },
    'supporm': { name: '青龙套装', bonuses: { 2: { attack: 0.80 }, 4: {  attack: 1.5 }, 6: {  attack: 2.0  } } },
   'supporq': { name: '朱雀套装', bonuses: { 2: { health: 0.45, attack: 0.34 }, 4: { health: 0.55, attack: 0.55 }, 6: { health: 1.2, attack: 1.2 } } },
   'supporw': { name: '白虎套装', bonuses: { 2: { critRate: 1.08 }, 4: { health: 0.75, critDamage: 0.72 }, 6: { attack: 1.1, critDamage: 1.2 } } },
  'supporrqw': { name: '神威套装', bonuses: { 2: { critRate: 1.07 }, 4: { health: 0.35, attack: 0.52 }, 6: { health: 1.5, attack: 0.3 } } },
        'hybrid': { name: '混合套装', bonuses: { 2: { health: 0.28, attack: 0.28 }, 4: { critRate: 1.04, critDamage: 0.15 }, 6: { health: 0.2, attack: 0.2, critRate: 2.06, critDamage: 0.3 } } }
    },
    
    // 霸气名字词库
    namePrefixes: [
        '霸天', '灭世', '混沌', '永恒', '不朽', '至尊', '无敌', '破天', '斩神', '弑魔', 
        '焚天', '冰封', '雷霆', '风暴', '星辰', '日月', '乾坤', '阴阳', '洪荒', '太古',
        '诸神', '万界', '九幽', '轮回', '天命', '造化', '鸿蒙', '太初', '虚无', '创世',
        '天罚', '神威', '魔尊', '帝皇', '圣王', '天尊', '神王', '魔帝', '妖皇', '仙帝',
        '龙魂', '凤血', '麒麟', '玄武', '白虎', '朱雀', '青龙', '饕餮', '穷奇', '梼杌',
        '时空', '命运', '因果', '轮回', '生死', '阴阳', '五行', '八卦', '九宫', '十方',
        '无量', '无极', '太极', '两仪', '四象', '六合', '七星', '八荒', '九天', '十地',
        '天魔', '地煞', '人皇', '鬼王', '神尊', '佛主', '道祖', '儒圣', '武神', '文曲',
        '紫薇', '太微', '天市', '北斗', '南斗', '东皇', '西王', '中天', '北极', '南极',
        '金乌', '玉兔', '麒麟', '凤凰', '真龙', '神龟', '白虎', '朱雀', '玄武', '青龙',
        '盘古', '女娲', '伏羲', '神农', '轩辕', '蚩尤', '共工', '祝融', '后羿', '夸父',
        '如来', '观音', '地藏', '文殊', '普贤', '弥勒', '燃灯', '药师', '阿弥陀', '大势至',
        '三清', '四御', '五老', '六司', '七元', '八极', '九曜', '十都', '百解', '千劫',
        '万法', '亿兆', '兆亿', '京垓', '秭穰', '沟涧', '正载', '极恒', '阿僧', '那由',
        '不可思议', '无量大数', '无边', '无数', '无知', '无想', '无念', '无相', '无我', '无心'
    ],
    
    nameSuffixes: [
        '战盔', '神甲', '圣袍', '魔铠', '灵衣', '帝冠', '皇靴', '王戒', '圣链', '神兵',
        '魔刃', '仙器', '法宝', '圣物', '神器', '魔器', '帝兵', '皇器', '王装', '圣装',
        '战甲', '法袍', '道衣', '佛珠', '儒冠', '武靴', '文佩', '兵刃', '法器', '灵宝',
        '天书', '地卷', '人符', '鬼玺', '神印', '魔纹', '妖丹', '仙草', '佛骨', '道心',
        '龙鳞', '凤羽', '麒麟角', '玄武壳', '白虎牙', '朱雀翎', '青龙爪', '饕餮胃', '穷奇翼', '梼杌骨',
        '时空轮', '命运盘', '因果线', '轮回镜', '生死簿', '阴阳图', '五行旗', '八卦阵', '九宫格', '十方印',
        '无量塔', '无极图', '太极印', '两仪剑', '四象旗', '六合锁', '七星灯', '八荒戟', '九天剑', '十地盾',
        '天魔琴', '地煞刀', '人皇印', '鬼王幡', '神尊冠', '佛主钵', '道祖拂', '儒圣笔', '武神枪', '文曲尺',
        '紫薇斗', '太微仪', '天市秤', '北斗勺', '南斗尺', '东皇钟', '西王簪', '中天镜', '北极星', '南极光',
        '金乌羽', '玉兔耳', '麒麟心', '凤凰胆', '真龙珠', '神龟甲', '白虎皮', '朱雀火', '玄武水', '青龙木',
        '盘古斧', '女娲石', '伏羲琴', '神农鼎', '轩辕剑', '蚩尤旗', '共工柱', '祝融火', '后羿弓', '夸父杖',
        '如来掌', '观音瓶', '地藏珠', '文殊剑', '普贤象', '弥勒袋', '燃灯古', '药师壶', '阿弥陀', '大势至',
        '三清铃', '四御印', '五老冠', '六司簿', '七元灯', '八极图', '九曜珠', '十都符', '百解锁', '千劫链',
        '万法轮', '亿兆镜', '兆亿尺', '京垓秤', '秭穰斗', '沟涧仪', '正载表', '极恒钟', '阿僧数', '那由算',
        '不可思议', '无量大数', '无边海', '无数星', '无知界', '无想天', '无念地', '无相空', '无我境', '无心法'
    ]
};

// 初始化轮回装备系统
function initReincarnationEquipmentSystem() {
    if (!player.reincarnationEquipment) {
        player.reincarnationEquipment = {
            equipped: {
                helmet: null,
                chest: null,
                pants: null,
                shoes: null,
                necklace: null,
                weapon: null
            },
            inventory: [],
            lockedItems: [], // 锁定的装备ID列表
            batchDiscardMode: false, // 批量丢弃模式
            selectedItems: [] // 选中的装备ID列表
        };
    }
}

// 生成随机装备名字
function generateEquipmentName() {
    const config = reincarnationEquipmentConfig;
    
    // 根据装备品质和等级决定名字的霸气程度
    const prefixPool = [...config.namePrefixes];
    const suffixPool = [...config.nameSuffixes];
    
    // 高品质装备使用更霸气的名字
    let prefixIndex, suffixIndex;
    
    if (Math.random() < 0.3) {
        // 30%几率生成三字名字（前缀+中缀+后缀）
        const midfixes = ['·', '之', '的', '', '·', '之', ''];
        const midfix = midfixes[Math.floor(Math.random() * midfixes.length)];
        
        prefixIndex = Math.floor(Math.random() * prefixPool.length);
        suffixIndex = Math.floor(Math.random() * suffixPool.length);
        
        return prefixPool[prefixIndex] + midfix + suffixPool[suffixIndex];
    } else {
        // 70%几率生成四字名字（双前缀或双后缀）
        if (Math.random() < 0.5) {
            // 双前缀+后缀
            const prefix1 = prefixPool[Math.floor(Math.random() * prefixPool.length)];
            let prefix2 = prefixPool[Math.floor(Math.random() * prefixPool.length)];
            // 确保两个前缀不同
            while (prefix2 === prefix1) {
                prefix2 = prefixPool[Math.floor(Math.random() * prefixPool.length)];
            }
            const suffix = suffixPool[Math.floor(Math.random() * suffixPool.length)];
            return prefix1 + prefix2 + suffix;
        } else {
            // 前缀+双后缀
            const prefix = prefixPool[Math.floor(Math.random() * prefixPool.length)];
            const suffix1 = suffixPool[Math.floor(Math.random() * suffixPool.length)];
            let suffix2 = suffixPool[Math.floor(Math.random() * suffixPool.length)];
            // 确保两个后缀不同
            while (suffix2 === suffix1) {
                suffix2 = suffixPool[Math.floor(Math.random() * suffixPool.length)];
            }
            return prefix + suffix1 + suffix2;
        }
    }
}
function generateEquipmentNameWithRarity(rarity, tier) {
    const config = reincarnationEquipmentConfig;
    let name = '';
    
    // 根据品质和等级决定名字的复杂度
    const rarityComplexity = {
        'common': 1, 'uncommon': 1, 'rare': 2, 'epic': 2, 
        'legendary': 3, 'mythic': 3, 'supreme': 4, 
        'ancient': 4, 'primordial': 5, 'eternal': 5
    };
    
    const complexity = rarityComplexity[rarity] || 1;
    const tierBonus = Math.min(tier, 10); // T等级加成
    
    // 高品质高等级装备生成更复杂的名字
    const totalComplexity = complexity + Math.floor(tierBonus / 3);
    
    if (totalComplexity >= 5) {
        // 最高复杂度：四字或五字名字
        name = generateComplexName(3);
    } else if (totalComplexity >= 3) {
        // 中等复杂度：三字或四字名字
        name = Math.random() < 0.7 ? generateComplexName(2) : generateSimpleName();
    } else {
        // 低复杂度：二字或三字名字
        name = Math.random() < 0.3 ? generateComplexName(1) : generateSimpleName();
    }
    
    return name;
}
function generateSimpleName() {
    const config = reincarnationEquipmentConfig;
    const prefix = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
    const suffix = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
    
    if (Math.random() < 0.3) {
        // 30%几率加连接符
        const connectors = ['·', '之', '的', ''];
        const connector = connectors[Math.floor(Math.random() * connectors.length)];
        return prefix + connector + suffix;
    }
    
    return prefix + suffix;
}

// 生成复杂名字
function generateComplexName(complexityLevel) {
    const config = reincarnationEquipmentConfig;
    let name = '';
    
    switch (complexityLevel) {
        case 1: // 三字名字
            const prefix1 = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
            const suffix1 = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
            const midfixes = ['·', '之', '的', ''];
            const midfix = midfixes[Math.floor(Math.random() * midfixes.length)];
            name = prefix1 + midfix + suffix1;
            break;
            
        case 2: // 四字名字（双前缀或双后缀）
            if (Math.random() < 0.5) {
                // 双前缀
                const prefixA = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
                let prefixB = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
                while (prefixB === prefixA) {
                    prefixB = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
                }
                const suffix = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                name = prefixA + prefixB + suffix;
            } else {
                // 双后缀
                const prefix = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
                const suffixA = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                let suffixB = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                while (suffixB === suffixA) {
                    suffixB = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                }
                name = prefix + suffixA + suffixB;
            }
            break;
            
        case 3: // 五字名字（双前缀+双后缀或前缀+中缀+双后缀）
            if (Math.random() < 0.5) {
                // 双前缀+双后缀（取前后各两字）
                const prefixA = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
                let prefixB = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
                while (prefixB === prefixA) {
                    prefixB = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
                }
                const suffixA = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                let suffixB = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                while (suffixB === suffixA) {
                    suffixB = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                }
                name = prefixA + prefixB + suffixA + suffixB;
            } else {
                // 前缀+中缀+双后缀
                const prefix = config.namePrefixes[Math.floor(Math.random() * config.namePrefixes.length)];
                const midfixes = ['·', '之', '的', ''];
                const midfix = midfixes[Math.floor(Math.random() * midfixes.length)];
                const suffixA = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                let suffixB = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                while (suffixB === suffixA) {
                    suffixB = config.nameSuffixes[Math.floor(Math.random() * config.nameSuffixes.length)];
                }
                name = prefix + midfix + suffixA + suffixB;
            }
            break;
    }
    
    return name;
}
// 根据权重随机选择
function weightedRandom(weights) {
    const total = weights.reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * total;
    
    for (let i = 0; i < weights.length; i++) {
        random -= weights[i];
        if (random <= 0) {
            return i + 1; // 返回1-6
        }
    }
    return 1;
}

// 生成轮回装备
function generateReincarnationEquipment(dimensionLevel) {
    if (dimensionLevel < 2) return null; // 次元2以上才掉落
    
    if (Math.random() > 0.001) return null; // 0.1%掉落几率
    
    const config = reincarnationEquipmentConfig;
    
    // 随机选择部位
    const slot = config.slots[Math.floor(Math.random() * config.slots.length)];
    
    // 根据权重随机选择T等级
    const tierWeights = Object.values(config.tiers).map(t => t.weight);
    const tierIndex = weightedRandom(tierWeights) - 1;
    const tier = Object.keys(config.tiers)[tierIndex];
    
    // 根据权重随机选择品质
    const rarityWeights = Object.values(config.rarities).map(r => r.weight);
    const rarityIndex = weightedRandom(rarityWeights) - 1;
    const rarity = Object.keys(config.rarities)[rarityIndex];
    const rarityConfig = config.rarities[rarity];
    
    // 随机选择词条数量
    const statCount = weightedRandom(config.statCountWeights);
    
    // 生成属性
    const stats = {};
    const availableStats = [...config.stats];
    
    for (let i = 0; i < statCount; i++) {
        if (availableStats.length === 0) break;
        
        const statIndex = Math.floor(Math.random() * availableStats.length);
        const stat = availableStats[statIndex];
        const statValue = (Math.random() * (rarityConfig.max - rarityConfig.min) + rarityConfig.min) / 100;
        
        stats[stat] = (stats[stat] || 0) + statValue;
    }
    
    // 检查是否生成套装（神话以上品质有10%几率）
    let setBonus = null;
    if (['mythic', 'supreme', 'ancient', 'primordial', 'eternal'].includes(rarity) && Math.random() < 0.10) {
        const setNames = Object.keys(config.sets);
        setBonus = setNames[Math.floor(Math.random() * setNames.length)];
    }
    // 使用新的名字生成算法
    const equipmentName = generateEquipmentNameWithRarity(rarity, parseInt(tier));
    // 创建装备对象
    const equipment = {
        id: 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: equipmentName,
        slot: slot,
        tier: parseInt(tier),
        rarity: rarity,
        stats: stats,
        setBonus: setBonus,
        owner: player.name,
        dropTime: new Date().toLocaleString('zh-CN'), 
        isLocked: false,
        createdAt: Date.now()
    };
    
    return equipment;
}

// 生成固定T1轮回装备（用于轮回试炼副本等）
function generateT1ReincarnationEquipment() {
    const config = reincarnationEquipmentConfig;
    const slot = config.slots[Math.floor(Math.random() * config.slots.length)];
    const tier = 1;
    const rarityWeights = Object.values(config.rarities).map(r => r.weight);
    const rarityIndex = weightedRandom(rarityWeights) - 1;
    const rarity = Object.keys(config.rarities)[rarityIndex];
    const rarityConfig = config.rarities[rarity];
    const statCount = weightedRandom(config.statCountWeights);
    const stats = {};
    const availableStats = [...config.stats];
    for (let i = 0; i < statCount; i++) {
        if (availableStats.length === 0) break;
        const statIndex = Math.floor(Math.random() * availableStats.length);
        const stat = availableStats[statIndex];
        const statValue = (Math.random() * (rarityConfig.max - rarityConfig.min) + rarityConfig.min) / 100;
        stats[stat] = (stats[stat] || 0) + statValue;
    }
    let setBonus = null;
    if (['mythic', 'supreme', 'ancient', 'primordial', 'eternal'].includes(rarity) && Math.random() < 0.10) {
        const setNames = Object.keys(config.sets);
        setBonus = setNames[Math.floor(Math.random() * setNames.length)];
    }
    const equipmentName = generateEquipmentNameWithRarity(rarity, tier);
    return {
        id: 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: equipmentName,
        slot: slot,
        tier: tier,
        rarity: rarity,
        stats: stats,
        setBonus: setBonus,
        owner: player.name,
        dropTime: new Date().toLocaleString('zh-CN'),
        isLocked: false,
        createdAt: Date.now()
    };
}

// 生成固定T2轮回装备（用于轮回仙岛副本等）
function generateT2ReincarnationEquipment() {
    const config = reincarnationEquipmentConfig;
    const slot = config.slots[Math.floor(Math.random() * config.slots.length)];
    const tier = 2;
    const rarityWeights = Object.values(config.rarities).map(r => r.weight);
    const rarityIndex = weightedRandom(rarityWeights) - 1;
    const rarity = Object.keys(config.rarities)[rarityIndex];
    const rarityConfig = config.rarities[rarity];
    const statCount = weightedRandom(config.statCountWeights);
    const stats = {};
    const availableStats = [...config.stats];
    for (let i = 0; i < statCount; i++) {
        if (availableStats.length === 0) break;
        const statIndex = Math.floor(Math.random() * availableStats.length);
        const stat = availableStats[statIndex];
        const statValue = (Math.random() * (rarityConfig.max - rarityConfig.min) + rarityConfig.min) / 100;
        stats[stat] = (stats[stat] || 0) + statValue;
    }
    let setBonus = null;
    if (['mythic', 'supreme', 'ancient', 'primordial', 'eternal'].includes(rarity) && Math.random() < 0.10) {
        const setNames = Object.keys(config.sets);
        setBonus = setNames[Math.floor(Math.random() * setNames.length)];
    }
    const equipmentName = generateEquipmentNameWithRarity(rarity, tier);
    return {
        id: 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: equipmentName,
        slot: slot,
        tier: tier,
        rarity: rarity,
        stats: stats,
        setBonus: setBonus,
        owner: player.name,
        dropTime: new Date().toLocaleString('zh-CN'),
        isLocked: false,
        createdAt: Date.now()
    };
}

// 计算装备总加成
function calculateEquipmentTotalBonus(equipment) {
    const tierMultiplier = reincarnationEquipmentConfig.tiers[equipment.tier].multiplier;
    let totalBonus = 0;
    
    Object.values(equipment.stats).forEach(value => {
        totalBonus += value * tierMultiplier;
    });
    
    return totalBonus;
}

// 获取装备显示颜色
function getEquipmentColor(equipment) {
    return reincarnationEquipmentConfig.rarities[equipment.rarity].color;
}

// 格式化属性值显示
function formatStatValue(value, statType) {
    if (statType === 'critRate') {
        return (value * 100).toFixed(2) + '%';
    }
    return (value * 100).toFixed(1) + '%';
}
// 切换轮回装备系统界面
function toggleReincarnationEquipmentUI() {
   if (player.level.ascentionCounta < 1) {
        alert("需要达到轮回1转才能开启轮回装备！");
        return;
    }
    const overlay = document.getElementById('reincarnationEquipmentOverlay');
    const ui = document.getElementById('reincarnationEquipmentUI');
    
    if (ui.style.display === 'block') {
        // 退出界面时自动退出批量模式
        if (player.reincarnationEquipment.batchDiscardMode) {
            player.reincarnationEquipment.batchDiscardMode = false;
            player.reincarnationEquipment.selectedItems = [];
        }
        
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateReincarnationEquipmentUI();
    }
}

// 更新轮回装备界面
function updateReincarnationEquipmentUI() {
    updateEquippedEquipmentDisplay();
    updateEquipmentInventoryDisplay();
    updateSetBonusesDisplay();
    updateEquipmentStatsSummary();
}

// 更新已装备的装备显示
function updateEquippedEquipmentDisplay() {
    const container = document.getElementById('equippedEquipmentContainer');
    const config = reincarnationEquipmentConfig;
    
    let html = '<div class="equipment-slots">';
    
    config.slots.forEach(slot => {
        const equipment = player.reincarnationEquipment.equipped[slot];
        const slotName = config.slotNames[slot];
        
        html += `
            <div class="equipment-slot" data-slot="${slot}">
                <div class="slot-name">${slotName}</div>
                <div class="equipment-display" onclick="unequipItem('${slot}')">
                    ${equipment ? `
                        <div style="color: ${getEquipmentColor(equipment)}; font-weight: bold;">
                            ${equipment.name}
                        </div>
                        <div>T${equipment.tier} ${config.rarities[equipment.rarity].name}</div>
                        <div>签名: ${equipment.owner}</div>
                        <div class="equipment-stats">
                            ${Object.entries(equipment.stats).map(([stat, value]) => `
                                <div>${config.statNames[stat]}: +${formatStatValue(value, stat)}</div>
                            `).join('')}
                        </div>
                        ${equipment.setBonus ? `<div style="color: #FFD700;">${config.sets[equipment.setBonus].name}</div>` : ''}
                    ` : '<div style="color: #666;">空</div>'}
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    container.innerHTML = html;
}

// 更新装备仓库显示
function updateEquipmentInventoryDisplay() {
    const container = document.getElementById('equipmentInventoryContainer');
    const config = reincarnationEquipmentConfig;
    
    // 获取筛选条件
    const filterTier = document.getElementById('inventoryFilterTier').value;
    const filterRarity = document.getElementById('inventoryFilterRarity').value;
    const filterSlot = document.getElementById('inventoryFilterSlot').value;
    const filterSet = document.getElementById('inventoryFilterSet').value;
    
    // 筛选装备
    let filteredEquipment = player.reincarnationEquipment.inventory;
    
    if (filterTier !== 'all') {
        filteredEquipment = filteredEquipment.filter(eq => eq.tier === parseInt(filterTier));
    }
    
    if (filterRarity !== 'all') {
        filteredEquipment = filteredEquipment.filter(eq => eq.rarity === filterRarity);
    }
    
    if (filterSlot !== 'all') {
        filteredEquipment = filteredEquipment.filter(eq => eq.slot === filterSlot);
    }
    
    if (filterSet !== 'all') {
        if (filterSet === 'hasSet') {
            filteredEquipment = filteredEquipment.filter(eq => eq.setBonus);
        } else if (filterSet === 'noSet') {
            filteredEquipment = filteredEquipment.filter(eq => !eq.setBonus);
        }
    }
    
    // 批量丢弃模式下的控制面板
    let controlPanel = '';
    if (player.reincarnationEquipment.batchDiscardMode) {
        const selectedCount = player.reincarnationEquipment.selectedItems.length;
        const totalDiscardable = filteredEquipment.filter(eq => isItemDiscardable(eq)).length;
        
        controlPanel = `
            <div style="background: #444; padding: 10px; border-radius: 5px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>批量丢弃模式</strong>
                    <span style="margin-left: 10px;">已选择: ${selectedCount}/${totalDiscardable}</span>
                </div>
                <div>
                    <button onclick="toggleSelectAll()" style="background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">
                        ${selectedCount === totalDiscardable ? '取消全选' : '全选'}
                    </button>
                    <button onclick="executeBatchDiscard()" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; margin-right: 5px;">
                        丢弃选中(${selectedCount})
                    </button>
                    <button onclick="toggleBatchDiscardMode()" style="background: #ff9800; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">
                        退出模式
                    </button>
                </div>
            </div>
        `;
    }
    
    if (filteredEquipment.length === 0) {
        container.innerHTML = controlPanel + '<div style="text-align: center; color: #666; padding: 20px;">仓库为空</div>';
        return;
    }
    
    let html = controlPanel + '<div class="equipment-inventory-grid">';
    
    filteredEquipment.forEach(equipment => {
        const isLocked = player.reincarnationEquipment.lockedItems.includes(equipment.id);
        const isSelected = isItemSelected(equipment.id);
        const isDiscardable = isItemDiscardable(equipment);
        
        html += `
            <div class="equipment-item ${isLocked ? 'locked' : ''} ${isSelected ? 'selected' : ''}" 
                 data-id="${equipment.id}"
                 onclick="${player.reincarnationEquipment.batchDiscardMode ? `toggleSelectItem('${equipment.id}')` : ''}">
                
                ${player.reincarnationEquipment.batchDiscardMode ? `
                    <div class="selection-checkbox">
                        <input type="checkbox" ${isSelected ? 'checked' : ''} 
                               ${!isDiscardable ? 'disabled' : ''} 
                               onclick="event.stopPropagation(); toggleSelectItem('${equipment.id}')">
                    </div>
                ` : ''}
                
                <div class="equipment-header">
                    <span style="color: ${getEquipmentColor(equipment)}; font-weight: bold;">${equipment.name}</span>
                    <div class="equipment-actions">
                        ${!player.reincarnationEquipment.batchDiscardMode ? `
                            <button onclick="event.stopPropagation(); equipItem('${equipment.id}')" 
                                    ${canEquip(equipment) ? '' : 'disabled'}>装备</button>
                            <button onclick="event.stopPropagation(); toggleLockItem('${equipment.id}')" 
                                    style="background: ${isLocked ? '#ff6b6b' : '#51cf66'}">
                                ${isLocked ? '解锁' : '锁定'}
                            </button>
                            <button onclick="event.stopPropagation(); showExportDialog('${equipment.id}')">导出</button>
                            <button onclick="event.stopPropagation(); discardItem('${equipment.id}')" 
                                    style="background: #ff6b6b" ${isLocked ? 'disabled' : ''}>丢弃</button>
                        ` : ''}
                    </div>
                </div>
                <div class="equipment-info">
                    <div>部位: ${config.slotNames[equipment.slot]}</div>
                    <div>品质: ${config.rarities[equipment.rarity].name}</div>
                    <div>等级: T${equipment.tier}</div>
                    <div>要求: 轮回${config.tiers[equipment.tier].minReincarnation}转</div>
                    <div>归属: ${equipment.owner}</div>
                    <div style="color: #aaa; font-size: 0.85em;">掉落: ${equipment.dropTime}</div>
                </div>
                <div class="equipment-stats">
                    ${Object.entries(equipment.stats).map(([stat, value]) => `
                        <div>${config.statNames[stat]}: +${formatStatValue(value, stat)}</div>
                    `).join('')}
                </div>
                ${equipment.setBonus ? `
                    <div class="set-bonus" style="color: #FFD700;">
                        套装: ${config.sets[equipment.setBonus].name}
                    </div>
                ` : ''}
                <div class="equipment-total">
                    总加成: +${(calculateEquipmentTotalBonus(equipment) * 100).toFixed(1)}%
                </div>
                ${!isDiscardable && player.reincarnationEquipment.batchDiscardMode ? `
                    <div style="color: #ff6b6b; font-size: 0.8em; margin-top: 5px;">已锁定</div>
                ` : ''}
            </div>
        `;
    });
    
    html += '</div>';
    container.innerHTML = html;
}
// 更新套装加成显示
function updateSetBonusesDisplay() {
    const container = document.getElementById('setBonusesContainer');
    const config = reincarnationEquipmentConfig;
    
    // 计算当前激活的套装
    const equippedSets = {};
    Object.values(player.reincarnationEquipment.equipped).forEach(equipment => {
        if (equipment && equipment.setBonus) {
            equippedSets[equipment.setBonus] = (equippedSets[equipment.setBonus] || 0) + 1;
        }
    });
    
    let html = '<div class="set-bonuses">';
    
    Object.entries(equippedSets).forEach(([setName, count]) => {
        const setConfig = config.sets[setName];
        html += `<div class="set-info">`;
        html += `<h4>${setConfig.name} (${count}/6)</h4>`;
        
        Object.entries(setConfig.bonuses).forEach(([pieceCount, bonuses]) => {
            const isActive = count >= parseInt(pieceCount);
            html += `<div class="set-bonus ${isActive ? 'active' : 'inactive'}">`;
            html += `<span>${pieceCount}件: </span>`;
            html += Object.entries(bonuses).map(([stat, value]) => 
                `${config.statNames[stat]} +${(value * 100).toFixed(1)}%`
            ).join(', ');
            html += `</div>`;
        });
        
        html += `</div>`;
    });
    
    if (Object.keys(equippedSets).length === 0) {
        html += '<div style="color: #666; text-align: center;">未激活任何套装效果</div>';
    }
    
    html += '</div>';
    container.innerHTML = html;
}

// 更新装备属性总览
function updateEquipmentStatsSummary() {
    const container = document.getElementById('equipmentStatsSummary');
    
    const totalStats = calculateTotalEquipmentStats();
    
    let html = `
        <div class="stats-summary">
            <h4>装备属性总览</h4>
            <div>生命加成: +${(totalStats.health * 100).toFixed(1)}%</div>
            <div>攻击加成: +${(totalStats.attack * 100).toFixed(1)}%</div>
            <div>暴击率: +${(totalStats.critRate * 100).toFixed(2)}%</div>
            <div>爆伤加成: +${(totalStats.critDamage * 100).toFixed(1)}%</div>
        </div>
    `;
    
    container.innerHTML = html;
}
// 检查是否可以装备
function canEquip(equipment) {
    const requiredReincarnation = reincarnationEquipmentConfig.tiers[equipment.tier].minReincarnation;
    return player.level.ascentionCounta >= requiredReincarnation;
}

// 装备物品
function equipItem(equipmentId) {
    const equipment = player.reincarnationEquipment.inventory.find(eq => eq.id === equipmentId);
    if (!equipment) return;
    
    if (!canEquip(equipment)) {
        const required = reincarnationEquipmentConfig.tiers[equipment.tier].minReincarnation;
        logAction(`装备要求轮回${required}转！当前轮回${player.level.ascentionCounta}转`, "error");
        return;
    }
    
    const slot = equipment.slot;
    
    // 如果该部位已有装备，先卸下
    if (player.reincarnationEquipment.equipped[slot]) {
        unequipItem(slot);
    }
    
    // 从仓库移除并装备
    player.reincarnationEquipment.equipped[slot] = equipment;
    player.reincarnationEquipment.inventory = player.reincarnationEquipment.inventory.filter(eq => eq.id !== equipmentId);
    
    logAction(`装备了${reincarnationEquipmentConfig.slotNames[slot]}: ${equipment.name}`, "success");
    updateReincarnationEquipmentUI();
    updatePlayerBattleStats();
}

// 卸下物品
function unequipItem(slot) {
    const equipment = player.reincarnationEquipment.equipped[slot];
    if (!equipment) return;
    
    player.reincarnationEquipment.equipped[slot] = null;
    player.reincarnationEquipment.inventory.push(equipment);
    
    logAction(`卸下了${reincarnationEquipmentConfig.slotNames[slot]}: ${equipment.name}`, "info");
    updateReincarnationEquipmentUI();
    updatePlayerBattleStats();
}

// 切换物品锁定状态
function toggleLockItem(equipmentId) {
    const index = player.reincarnationEquipment.lockedItems.indexOf(equipmentId);
    
    if (index === -1) {
        player.reincarnationEquipment.lockedItems.push(equipmentId);
        logAction("物品已锁定", "info");
    } else {
        player.reincarnationEquipment.lockedItems.splice(index, 1);
        logAction("物品已解锁", "info");
    }
    
    updateReincarnationEquipmentUI();
}

// 丢弃物品
function discardItem(equipmentId) {
    const equipment = player.reincarnationEquipment.inventory.find(eq => eq.id === equipmentId);
    if (!equipment) return;
    
    if (player.reincarnationEquipment.lockedItems.includes(equipmentId)) {
        logAction("物品已锁定，无法丢弃", "error");
        return;
    }
    
    showCustomConfirm(`确定要丢弃 ${equipment.name} 吗？`, (confirmed) => {
        if (confirmed) {
            player.reincarnationEquipment.inventory = player.reincarnationEquipment.inventory.filter(eq => eq.id !== equipmentId);
            logAction(`已丢弃: ${equipment.name}`, "info");
            updateReincarnationEquipmentUI();
        }
    });
}

// 显示导出对话框
function showExportDialog(equipmentId) {
    const equipment = player.reincarnationEquipment.inventory.find(eq => eq.id === equipmentId);
    if (!equipment) return;
    
    // 加密装备数据
    const encryptedData = encryptEquipmentData(equipment);
    const data = decryptEquipmentData(encryptedData); // 解密以获取时间信息
    
    document.getElementById('exportEquipmentData').value = encryptedData;
    document.getElementById('exportTimeInfo').innerHTML = `
        <div style="margin: 10px 0; padding: 10px; background: #444; border-radius: 5px;">
            <div>导出时间: ${new Date(data.exportTime).toLocaleString('zh-CN')}</div>
            <div>过期时间: ${new Date(data.expireTime).toLocaleString('zh-CN')}</div>
            <div id="remainingTime" style="color: #4CAF50; font-weight: bold;">
                剩余时间: ${calculateRemainingTime(data.expireTime)}
            </div>
        </div>
    `;
    
    // 启动倒计时更新
    startExportCountdown(data.expireTime);
    
    document.getElementById('exportDialog').style.display = 'block';
    document.getElementById('exportOverlay').style.display = 'block';
}
function startExportCountdown(expireTime) {
    const countdownElement = document.getElementById('remainingTime');
    
    const countdownInterval = registerInterval(() => {
        const remaining = calculateRemainingTime(expireTime);
        countdownElement.textContent = `剩余时间: ${remaining}`;
        
        if (remaining === '已过期') {
            clearInterval(countdownInterval);
            countdownElement.style.color = '#f44336';
            document.getElementById('copyExportBtn').disabled = true;
        }
    }, 1000);
    
    // 保存interval以便清理
    window.exportCountdownInterval = countdownInterval;
}
// 隐藏导出对话框
function hideExportDialog() {
    if (window.exportCountdownInterval) {
        clearInterval(window.exportCountdownInterval);
        window.exportCountdownInterval = null;
    }
    document.getElementById('exportDialog').style.display = 'none';
    document.getElementById('exportOverlay').style.display = 'none';
}

// 显示导入对话框
function showImportDialog() {
    document.getElementById('importDialog').style.display = 'block';
    document.getElementById('importOverlay').style.display = 'block';
    document.getElementById('importEquipmentData').value = '';
    document.getElementById('importTimeInfo').innerHTML = '';
    document.getElementById('importEquipmentData').focus();
}
function validateImportCode() {
    const encryptedData = document.getElementById('importEquipmentData').value.trim();
    
    if (!encryptedData) {
        document.getElementById('importTimeInfo').innerHTML = '';
        return null;
    }
    
    try {
        const data = decryptEquipmentData(encryptedData);
        if (!data) {
            document.getElementById('importTimeInfo').innerHTML = 
                '<div style="color: #f44336; margin: 10px 0;">无效的装备代码</div>';
            return null;
        }
        
        const remainingTime = calculateRemainingTime(data.expireTime);
        const isExpired = remainingTime === '已过期';
        
        document.getElementById('importTimeInfo').innerHTML = `
            <div style="margin: 10px 0; padding: 10px; background: #444; border-radius: 5px;">
                <div>装备名称: ${data.name}</div>
                <div>品质: ${reincarnationEquipmentConfig.rarities[data.rarity].name}</div>
                <div>等级: T${data.tier}</div>
                <div>导出时间: ${new Date(data.exportTime).toLocaleString('zh-CN')}</div>
                <div>过期时间: ${new Date(data.expireTime).toLocaleString('zh-CN')}</div>
                <div style="color: ${isExpired ? '#f44336' : '#4CAF50'}; font-weight: bold;">
                    剩余时间: ${remainingTime}
                </div>
                ${isExpired ? '<div style="color: #f44336;">⚠️ 该代码已过期，无法导入</div>' : ''}
            </div>
        `;
        
        return { data: data, isValid: !isExpired };
    } catch (error) {
        document.getElementById('importTimeInfo').innerHTML = 
            `<div style="color: #f44336; margin: 10px 0;">${error.message}</div>`;
        return null;
    }
}
// 隐藏导入对话框
function hideImportDialog() {
    document.getElementById('importDialog').style.display = 'none';
    document.getElementById('importOverlay').style.display = 'none';
}

// 加密装备数据
function encryptEquipmentData(equipment) {
    const data = {
        name: equipment.name,
        slot: equipment.slot,
        tier: equipment.tier,
        rarity: equipment.rarity,
        stats: equipment.stats,
        setBonus: equipment.setBonus,
        owner: equipment.owner,
        dropTime: equipment.dropTime,
        createdAt: equipment.createdAt,
        // 添加时间限制信息
        exportTime: Date.now(), // 导出时间
        expireTime: Date.now() + 10 * 60 * 1000, // 10分钟过期时间
        version: '1.0' // 数据版本
    };
    
    const jsonString = JSON.stringify(data);
    return btoa(unescape(encodeURIComponent(jsonString)));
}

// 解密装备数据
function decryptEquipmentData(encryptedData) {
    try {
        const jsonString = decodeURIComponent(escape(atob(encryptedData)));
        const data = JSON.parse(jsonString);
        
        // 验证数据格式
        if (!data.exportTime || !data.expireTime) {
            throw new Error('无效的装备代码：缺少时间信息');
        }
        
        // 检查是否过期
        const currentTime = Date.now();
        if (currentTime > data.expireTime) {
            throw new Error('装备代码已过期（超过10分钟）');
        }
        
        // 检查导出时间是否合理
        if (data.exportTime > currentTime) {
            throw new Error('无效的装备代码：导出时间异常');
        }
        
        return data;
    } catch (error) {
        console.error('解密装备数据失败:', error);
        return null;
    }
}
function calculateRemainingTime(expireTime) {
    const currentTime = Date.now();
    const remaining = expireTime - currentTime;
    
    if (remaining <= 0) {
        return '已过期';
    }
    
    const minutes = Math.floor(remaining / (60 * 1000));
    const seconds = Math.floor((remaining % (60 * 1000)) / 1000);
    
    return `${minutes}分${seconds}秒`;
}

// 导入装备
function importEquipment() {
    const encryptedData = document.getElementById('importEquipmentData').value.trim();
    
    if (!encryptedData) {
        logAction("请输入装备代码", "error");
        return;
    }
    
    const validation = validateImportCode();
    if (!validation || !validation.isValid) {
        logAction("装备代码无效或已过期", "error");
        return;
    }
    
    const equipmentData = validation.data;
    
    // 检查是否已导入过相同的装备（防止重复导入）
    const existingImport = player.reincarnationEquipment.inventory.find(eq => 
        eq.exportSignature === encryptedData
    );
    
    if (existingImport) {
        logAction("该装备代码已被导入过", "error");
        return;
    }
    
    // 创建新的装备对象
    const newEquipment = {
        id: 'req_import_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: equipmentData.name,
        slot: equipmentData.slot,
        tier: equipmentData.tier,
        rarity: equipmentData.rarity,
        stats: equipmentData.stats,
        setBonus: equipmentData.setBonus,
        owner: equipmentData.owner || '导入的装备',
        dropTime: equipmentData.dropTime || new Date().toLocaleString('zh-CN'),
        isLocked: false,
        createdAt: Date.now(),
        // 记录导入信息
        importTime: Date.now(),
        originalExportTime: equipmentData.exportTime,
        exportSignature: encryptedData // 防止重复导入
    };
    
    // 添加到仓库
    player.reincarnationEquipment.inventory.push(newEquipment);
    
    logAction(`成功导入装备: ${newEquipment.name}`, "success");
    hideImportDialog();
    updateReincarnationEquipmentUI();
    
    // 记录导入历史
    recordImportHistory(newEquipment, equipmentData.owner);
}

// 记录导入历史
function recordImportHistory(equipment, originalOwner) {
    if (!player.reincarnationEquipment.importHistory) {
        player.reincarnationEquipment.importHistory = [];
    }
    
    player.reincarnationEquipment.importHistory.push({
        equipmentName: equipment.name,
        originalOwner: originalOwner,
        importTime: Date.now(),
        rarity: equipment.rarity,
        tier: equipment.tier
    });
    
    // 只保留最近10条记录
    if (player.reincarnationEquipment.importHistory.length > 10) {
        player.reincarnationEquipment.importHistory.shift();
    }
}

// 复制导出代码
function copyExportCode() {
    const exportData = document.getElementById('exportEquipmentData');
    exportData.select();
    document.execCommand('copy');
    logAction("装备代码已复制到剪贴板", "success");
}
// 计算总装备属性
function calculateTotalEquipmentStats() {
    const totalStats = {
        health: 0,
        attack: 0,
        critRate: 0,
        critDamage: 0
    };
    
    // 计算单件装备属性
    Object.values(player.reincarnationEquipment.equipped).forEach(equipment => {
        if (equipment) {
            const tierMultiplier = reincarnationEquipmentConfig.tiers[equipment.tier].multiplier;
            
            Object.entries(equipment.stats).forEach(([stat, value]) => {
                totalStats[stat] += value * tierMultiplier;
            });
        }
    });
    
    // 计算套装加成
    const setBonuses = calculateSetBonuses();
    Object.entries(setBonuses).forEach(([stat, value]) => {
        totalStats[stat] += value;
    });
    
    return totalStats;
}

// 计算套装加成
function calculateSetBonuses() {
    const setBonuses = {
        health: 0,
        attack: 0,
        critRate: 0,
        critDamage: 0
    };
    
    const config = reincarnationEquipmentConfig;
    const equippedSets = {};
    
    // 统计各套装件数
    Object.values(player.reincarnationEquipment.equipped).forEach(equipment => {
        if (equipment && equipment.setBonus) {
            equippedSets[equipment.setBonus] = (equippedSets[equipment.setBonus] || 0) + 1;
        }
    });
    
    // 应用套装效果
    Object.entries(equippedSets).forEach(([setName, count]) => {
        const setConfig = config.sets[setName];
        if (!setConfig) return;
        
        Object.entries(setConfig.bonuses).forEach(([pieceCount, bonuses]) => {
            if (count >= parseInt(pieceCount)) {
                Object.entries(bonuses).forEach(([stat, value]) => {
                    // 每轮回1转增加10倍效果
                    const multiplier = 1 + (player.level.ascentionCounta * 10);
                    setBonuses[stat] += value * multiplier;
                });
            }
        });
    });
    
    return setBonuses;
}
function dropReincarnationEquipment() {
    const dimensionLevel = player.dimensionLevel;
    const newEquipment = generateReincarnationEquipment(dimensionLevel);
    
    if (newEquipment) {
        player.reincarnationEquipment.inventory.push(newEquipment);
        logAction(`获得轮回装备: ${newEquipment.name} (${reincarnationEquipmentConfig.rarities[newEquipment.rarity].name}) - ${newEquipment.dropTime}`, 'success');
        updateReincarnationEquipmentUI();
    }
}
function toggleBatchDiscardMode() {
    player.reincarnationEquipment.batchDiscardMode = !player.reincarnationEquipment.batchDiscardMode;
    
    const batchDiscardBtn = document.getElementById('batchDiscardBtn');
    if (player.reincarnationEquipment.batchDiscardMode) {
        batchDiscardBtn.innerHTML = '退出批量丢弃模式';
        batchDiscardBtn.style.background = '#f44336';
        // 初始化选中列表
        player.reincarnationEquipment.selectedItems = [];
        logAction("已进入批量丢弃模式，请勾选要丢弃的装备", "info");
    } else {
        batchDiscardBtn.innerHTML = '批量丢弃';
        batchDiscardBtn.style.background = '#ff9800';
        // 清除选中状态
        player.reincarnationEquipment.selectedItems = [];
        logAction("已退出批量丢弃模式", "info");
    }
    
    updateReincarnationEquipmentUI();
}
function toggleSelectItem(equipmentId) {
    if (!player.reincarnationEquipment.batchDiscardMode) return;
    
    const index = player.reincarnationEquipment.selectedItems.indexOf(equipmentId);
    if (index === -1) {
        player.reincarnationEquipment.selectedItems.push(equipmentId);
    } else {
        player.reincarnationEquipment.selectedItems.splice(index, 1);
    }
    
    updateReincarnationEquipmentUI();
}
function executeBatchDiscard() {
    if (!player.reincarnationEquipment.batchDiscardMode || !player.reincarnationEquipment.selectedItems.length) {
        logAction("请先选择要丢弃的装备", "error");
        return;
    }
    
    const selectedCount = player.reincarnationEquipment.selectedItems.length;
    
    // 检查是否有锁定的装备被选中
    const lockedItems = player.reincarnationEquipment.selectedItems.filter(id => 
        player.reincarnationEquipment.lockedItems.includes(id)
    );
    
    if (lockedItems.length > 0) {
        logAction(`有${lockedItems.length}件装备已锁定，无法丢弃`, "error");
        return;
    }
    
    showCustomConfirm(`确定要丢弃选中的${selectedCount}件装备吗？此操作不可撤销！`, (confirmed) => {
        if (confirmed) {
            let discardedCount = 0;
            let failedCount = 0;
            
            player.reincarnationEquipment.selectedItems.forEach(equipmentId => {
                const equipmentIndex = player.reincarnationEquipment.inventory.findIndex(eq => eq.id === equipmentId);
                if (equipmentIndex !== -1) {
                    const equipment = player.reincarnationEquipment.inventory[equipmentIndex];
                    
                    // 再次检查是否锁定（防止状态变化）
                    if (!player.reincarnationEquipment.lockedItems.includes(equipmentId)) {
                        player.reincarnationEquipment.inventory.splice(equipmentIndex, 1);
                        discardedCount++;
                        logAction(`已丢弃: ${equipment.name}`, "info");
                    } else {
                        failedCount++;
                    }
                }
            });
            
            // 退出批量丢弃模式
            player.reincarnationEquipment.batchDiscardMode = false;
            player.reincarnationEquipment.selectedItems = [];
            
            if (failedCount > 0) {
                logAction(`批量丢弃完成，成功丢弃${discardedCount}件装备，${failedCount}件装备因锁定而无法丢弃`, "warning");
            } else {
                logAction(`批量丢弃完成，成功丢弃${discardedCount}件装备`, "success");
            }
            
            updateReincarnationEquipmentUI();
        }
    });
}
function toggleSelectAll() {
    if (!player.reincarnationEquipment.batchDiscardMode) return;
    
    // 获取当前筛选条件下的所有装备ID（未锁定的）
    const allItems = getFilteredEquipmentIds();
    
    if (player.reincarnationEquipment.selectedItems.length === allItems.length) {
        // 取消全选
        player.reincarnationEquipment.selectedItems = [];
    } else {
        // 全选
        player.reincarnationEquipment.selectedItems = [...allItems];
    }
    
    updateReincarnationEquipmentUI();
}

// 获取筛选后的装备ID列表（只包含未锁定的）
function getFilteredEquipmentIds() {
    const config = reincarnationEquipmentConfig;
    
    // 获取筛选条件
    const filterTier = document.getElementById('inventoryFilterTier').value;
    const filterRarity = document.getElementById('inventoryFilterRarity').value;
    const filterSlot = document.getElementById('inventoryFilterSlot').value;
    const filterSet = document.getElementById('inventoryFilterSet').value;
    
    // 筛选装备
    let filteredEquipment = player.reincarnationEquipment.inventory;
    
    if (filterTier !== 'all') {
        filteredEquipment = filteredEquipment.filter(eq => eq.tier === parseInt(filterTier));
    }
    
    if (filterRarity !== 'all') {
        filteredEquipment = filteredEquipment.filter(eq => eq.rarity === filterRarity);
    }
    
    if (filterSlot !== 'all') {
        filteredEquipment = filteredEquipment.filter(eq => eq.slot === filterSlot);
    }
    
    if (filterSet !== 'all') {
        if (filterSet === 'hasSet') {
            filteredEquipment = filteredEquipment.filter(eq => eq.setBonus);
        } else if (filterSet === 'noSet') {
            filteredEquipment = filteredEquipment.filter(eq => !eq.setBonus);
        }
    }
    
    // 只返回未锁定的装备ID
    return filteredEquipment
        .filter(eq => !player.reincarnationEquipment.lockedItems.includes(eq.id))
        .map(eq => eq.id);
}
function isItemSelected(equipmentId) {
    return player.reincarnationEquipment.batchDiscardMode && 
           player.reincarnationEquipment.selectedItems.includes(equipmentId);
}

// 检查装备是否可丢弃（未锁定）
function isItemDiscardable(equipment) {
    return !player.reincarnationEquipment.lockedItems.includes(equipment.id);
}
function showImportHistory() {
    if (!player.reincarnationEquipment.importHistory || player.reincarnationEquipment.importHistory.length === 0) {
        document.getElementById('importHistoryList').innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">暂无导入历史</div>';
    } else {
        let html = '<div class="import-history-list">';
        player.reincarnationEquipment.importHistory.reverse().forEach((record, index) => {
            const timeAgo = formatTimeAgo(record.importTime);
            html += `
                <div class="import-history-item">
                    <div class="import-info">
                        <strong style="color: ${getRarityColor(record.rarity)}">${record.equipmentName}</strong>
                        <div>来自: ${record.originalOwner || '未知玩家'}</div>
                        <div>品质: ${reincarnationEquipmentConfig.rarities[record.rarity].name}</div>
                        <div>等级: T${record.tier}</div>
                    </div>
                    <div class="import-time">${timeAgo}</div>
                </div>
            `;
        });
        html += '</div>';
        document.getElementById('importHistoryList').innerHTML = html;
    }
    
    document.getElementById('importHistoryDialog').style.display = 'block';
    document.getElementById('importHistoryOverlay').style.display = 'block';
}

// 隐藏导入历史
function hideImportHistory() {
    document.getElementById('importHistoryDialog').style.display = 'none';
    document.getElementById('importHistoryOverlay').style.display = 'none';
}

// 格式化时间显示
function formatTimeAgo(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / (60 * 1000));
    const hours = Math.floor(diff / (60 * 60 * 1000));
    const days = Math.floor(diff / (24 * 60 * 60 * 1000));
    
    if (minutes < 1) return '刚刚';
    if (minutes < 60) return `${minutes}分钟前`;
    if (hours < 24) return `${hours}小时前`;
    return `${days}天前`;
}

// 获取品质颜色
function getRarityColor(rarity) {
    return reincarnationEquipmentConfig.rarities[rarity]?.color || '#FFFFFF';
}

const beastConfig = {
    // S级别配置：所需轮回转生次数、属性加成范围
    sLevels: {
        'S1': { requiredAscention: 1, multiplierRange: [0.01, 1.00] }, 
        'S2': { requiredAscention: 3, multiplierRange: [0.30, 3.00] }, 
        'S3': { requiredAscention: 5, multiplierRange: [1.00, 9.00] },
        'S4': { requiredAscention: 8, multiplierRange: [3.00, 27.00] },
        'S5': { requiredAscention: 10, multiplierRange: [7.00, 81.00] },
        'S6': { requiredAscention: 12, multiplierRange: [25.00, 243.00] },
        'S7': { requiredAscention: 15, multiplierRange: [80.00, 729.00] },
        'S8': { requiredAscention: 20, multiplierRange: [224.50, 2187.00] },
        'S9': { requiredAscention: 25, multiplierRange: [793.50, 6561.00] },
        'S10': { requiredAscention: 30, multiplierRange: [2250.50, 19683.00] }
    },

    // 品质配置：名称、颜色、掉落权重
    rarities: {
        '小宠物': { 
            name: '小宠物', 
            chineseName: '小宠',
            color: '#CCCCCC', // 灰色
            dropWeight: 90, 
            effectMultiplier: 1.0,
            loreWeight: 1, // 背景故事权重
            description: '灵性初开，稚嫩可掬'
        },
        '野兽': { 
            name: '野兽', 
            chineseName: '野兽',
            color: '#1E90FF', // 亮蓝色
            dropWeight: 7.34, 
            effectMultiplier: 1.25,
            loreWeight: 2,
            description: '山林霸主，野性难驯'
        },
        '凶兽': { 
            name: '凶兽', 
            chineseName: '凶兽',
            color: '#8A2BE2', // 紫色
            dropWeight: 1.5, 
            effectMultiplier: 1.5,
            loreWeight: 3,
            description: '嗜血成性，凶威盖世'
        },
        '灵兽': { 
            name: '灵兽', 
            chineseName: '灵兽',
            color: '#00CED1', // 青色
            dropWeight: 1, 
            effectMultiplier: 1.75,
            loreWeight: 4,
            description: '通晓灵性，亲近自然'
        },
        '圣兽': { 
            name: '圣兽', 
            chineseName: '圣兽',
            color: '#FFD700', // 金色
            dropWeight: 0.1, 
            effectMultiplier: 2.0,
            loreWeight: 5,
            description: '祥瑞化身，圣光护体'
        },
        '神兽': { 
            name: '神兽', 
            chineseName: '神兽',
            color: '#FF4500', // 橙红色
            dropWeight: 0.05, 
            effectMultiplier: 2.5,
            loreWeight: 6,
            description: '神威浩荡，镇压一方'
        },
        '炁兽': { 
            name: '炁兽', 
            chineseName: '炁兽',
            color: '#FF1493', // 亮粉色/品红色
            dropWeight: 0.01, 
            effectMultiplier: 3.0,
            loreWeight: 7,
            description: '炁之本源，大道显化'
        }
    },

    // 可获得的属性词条类型
    affixTypes: ['生命加成', '攻击加成', '爆伤加成'],

    // 词条数概率分布
    affixCountProbs: {
        1: 90,
        2: 8.39,
        3: 1,
        4: 0.5,
        5: 0.1,
        6: 0.01
    },

    // S级别掉落概率
    sLevelDropProbs: {
        'S1': 90,
        'S2': 8.3339,
        'S3': 1,
        'S4': 0.5,
        'S5': 0.1,
        'S6': 0.05,
        'S7': 0.01,
        'S8': 0.005,
        'S9': 0.001,
        'S10': 0.0001
    }
};

// 神兽名字词库
const beastNameParts = {
    小宠物: {
        prefixes: ['茸茸', '团团', '豆豆', '球球', '毛毛', '雪雪', '绒绒', '嘟嘟', '咪咪', '波波'],
        suffixes: ['兔', '猫', '狗', '鼠', '雀', '龟', '蛙', '鱼', '狐', '狸']
    },
    
    // 野兽 - 常见、威猛
    野兽: {
        prefixes: ['利爪', '钢牙', '迅影', '铁背', '灰鬃', '棕毛', '赤瞳', '银尾', '铜皮', '金睛'],
        suffixes: ['狼', '虎', '豹', '熊', '狮', '象', '牛', '马', '鹰', '雕']
    },
    
    // 凶兽 - 凶残、暴戾
    凶兽: {
        prefixes: ['血瞳', '噬魂', '裂骨', '撕风', '断金', '碎岩', '吞月', '饮血', '屠城', '灭世'],
        suffixes: ['饕餮', '穷奇', '梼杌', '混沌', '朱厌', '祸斗', '狰', '蛊雕', '九婴', '相柳']
    },
    
    // 灵兽 - 灵性、优雅
    灵兽: {
        prefixes: ['灵瞳', '玉角', '星纹', '月华', '霞光', '云翼', '风痕', '水镜', '雷音', '虹霓'],
        suffixes: ['鹿', '鹤', '鸾', '鸢', '鲲', '鹏', '蛟', '螭', '夔', '虺']
    },
    
    // 圣兽 - 神圣、威严
    圣兽: {
        prefixes: ['圣光', '天威', '神恩', '净世', '守护', '裁决', '福音', '天命', '至理', '永恒'],
        suffixes: ['麒麟', '白泽', '貔貅', '谛听', '当康', '英招', '陆吾', '毕方', '重明', '腓腓']
    },
    
    // 神兽 - 强大、尊贵
    神兽: {
        prefixes: ['天穹', '混沌', '虚空', '轮回', '时空', '造化', '开天', '创世', '主宰', '至尊'],
        suffixes: ['青龙', '白虎', '朱雀', '玄武', '应龙', '烛龙', '腾蛇', '勾陈', '黄龙', '凤凰']
    },
    
    // 炁兽 - 神秘、本源
    炁兽: {
        prefixes: ['太初', '鸿蒙', '元始', '无极', '太易', '太始', '太素', '太极', '两仪', '四象'],
        suffixes: ['炁', '道', '源', '始', '元', '一', '极', '玄', '妙', '真']
    }
};

// 神兽背景故事模板
const beastLoreTemplates = {
    // 小宠物背景 - 平凡、可爱
    小宠物: [
        '只是一只普通的{0}，喜欢在{1}嬉戏玩耍。',
        '{0}族的幼崽，对世界充满好奇，经常{1}。',
        '被主人收养的流浪{0}，虽然弱小但{1}。',
        '在{0}中发现的幼兽，天性{1}惹人怜爱。',
        '这只{0}似乎有着不寻常的{1}天赋。'
    ],
    
    // 野兽背景 - 自然、野生
    野兽: [
        '山林间的{0}霸主，凭借{1}在{2}称王。',
        '曾与猎人周旋多年的{0}，学会了{1}的生存技巧。',
        '从{0}迁徙而来的{1}，适应了这里的{2}环境。',
        '这只{0}的{1}在族群中堪称一绝，{2}。',
        '在{0}的残酷竞争中存活下来的{1}，{2}。'
    ],
    
    // 凶兽背景 - 凶残、危险
    凶兽: [
        '以{0}为食的{1}，所到之处{2}。',
        '被{0}侵蚀心智的{1}，只剩下{2}的本能。',
        '上古{0}的后裔，传承了{1}的凶性，{2}。',
        '这只{0}曾{1}，被列为{2}级危险凶兽。',
        '{0}的化身，每当{1}时便会现身{2}。'
    ],
    
    // 灵兽背景 - 灵性、智慧
    灵兽: [
        '通晓{0}之道的{1}，能{2}。',
        '在{0}中修炼千年的{1}，已初具{2}之能。',
        '这只{0}天生能与{1}沟通，掌握着{2}的秘密。',
        '{0}族的智者，曾{1}，被尊为{2}。',
        '吸收{0}精华而诞生的{1}，拥有{2}的力量。'
    ],
    
    // 圣兽背景 - 神圣、祥瑞
    圣兽: {
        '麒麟': '仁兽麒麟，不践生草，不履生虫，王者有德则现。',
        '白泽': '通晓万物之情，能言人语，祥瑞之兽，辟除人间邪气。',
        '貔貅': '纳食四方之财，吞万物而不泻，招财进宝，镇宅辟邪。',
        '谛听': '能辨世间万物，尤善听人心，坐地听八百，卧耳听三千。',
        '当康': '其鸣自叫，见则天下大穰，丰穰的瑞兽。',
        '英招': '人面马身，身有虎纹，生鸟翼，徇于四海，其音如榴。',
        '陆吾': '司天之九部及帝之囿时，人面虎身九尾，镇守昆仑。',
        '毕方': '见则其邑有讹火，御火之精，不食五谷。',
        '重明': '双睛在背，能搏逐猛兽虎狼，使妖灾群恶不能为害。',
        '腓腓': '养之可以解忧愁，其状如狸，白尾有鬣。'
    },
    
    // 神兽背景 - 强大、古老
    神兽: {
        '青龙': '东方之神，五行主木，司春，为四象之首，万物生发之始。',
        '白虎': '西方之神，五行主金，司秋，杀伐之神，兵戈之主。',
        '朱雀': '南方之神，五行主火，司夏，涅槃之鸟，浴火重生。',
        '玄武': '北方之神，五行主水，司冬，龟蛇合体，司命之神。',
        '应龙': '背生双翼，司云布雨，曾助黄帝战蚩尤，斩夸父。',
        '烛龙': '视为昼，瞑为夜，吹为冬，呼为夏，身长千里，人面龙身。',
        '腾蛇': '能兴云雾而游其中，无足而飞，星宿之精。',
        '勾陈': '天皇大帝，雷神之祖，司权柄，掌兵戎之事。',
        '黄龙': '中央之神，五行主土，轩辕之星，权柄之象。',
        '凤凰': '非梧桐不栖，非竹实不食，非醴泉不饮，见则天下安宁。'
    },
    
    // 炁兽背景 - 本源、大道
    炁兽: [
        '太初{0}所化的{1}，象征着{2}的本源。',
        '鸿蒙未判之时便已存在的{0}，见证过{1}的{2}。',
        '大道{0}的具现化，其{1}便是{2}的体现。',
        '元始{0}凝聚而成的{1}，掌握着{2}的真理。',
        '这并非{0}，而是{1}本身，{2}的源头。'
    ]
};
const beastLoreElements = {
    // 通用元素
    地点: ['山林', '深谷', '秘境', '古地', '遗迹', '洞天', '福地', '绝地', '险境', '渊薮'],
    特征: ['灵敏的嗅觉', '锋利的爪牙', '坚韧的皮毛', '强大的力量', '迅捷的速度', '狡猾的智慧', '顽强的生命力', '特殊的能力', '变异的血脉', '先祖的传承'],
    行为: ['捕猎', '守护领地', '哺育后代', '争夺配偶', '躲避天敌', '寻找食物', '探索未知', '遵循本能', '学习技能', '积累力量'],
    
    // 小宠物特有
    小宠物特征: ['柔软的绒毛', '可爱的叫声', '灵动的眼睛', '娇小的体型', '温顺的性格', '贪吃的习惯', '好奇的天性', '粘人的习性', '活泼好动', '胆小谨慎'],
    
    // 野兽特有
    野兽能力: ['潜伏突袭', '群体狩猎', '追踪痕迹', '辨别方向', '适应环境', '季节性迁徙', '领地标记', '求偶展示', '伪装隐藏', '耐力持久'],
    
    // 凶兽特有
    凶兽行为: ['屠戮生灵', '毁灭村庄', '吞噬修士', '引发灾祸', '制造恐慌', '污染土地', '散播瘟疫', '引发战乱', '破坏平衡', '挑战秩序'],
    凶兽特征: ['嗜血的眼睛', '狰狞的面容', '腐臭的气息', '扭曲的肢体', '疯狂的神智', '无尽的饥饿', '毁灭的欲望', '诅咒的血脉', '痛苦的嘶吼', '邪恶的本能'],
    
    // 灵兽特有
    灵兽能力: ['沟通自然', '预知危险', '治愈伤势', '净化污染', '引导灵气', '点化生灵', '破除幻象', '穿梭空间', '操控元素', '领悟道法'],
    灵兽地点: ['灵脉源头', '月华汇聚之地', '星辰照耀之所', '灵气潮汐之处', '先天福地', '上古道场', '神圣祭坛', '自然圣地', '天地节点', '轮回间隙'],
    
    // 圣兽特有
    圣兽象征: ['祥瑞', '仁德', '守护', '公正', '智慧', '慈悲', '净化', '治愈', '祝福', '指引'],
    圣兽事迹: ['驱散瘟疫', '平息战乱', '指引迷途', '守护苍生', '镇压邪祟', '赐福大地', '启示真理', '平衡自然', '教化生灵', '传播文明'],
    
    // 神兽特有
    神兽权柄: ['司掌四季', '统御元素', '掌管星辰', '主宰生死', '操控时间', '执掌轮回', '镇压气运', '守护天道', '平衡阴阳', '创生万物'],
    神兽传说: ['开天辟地时诞生', '混沌中孕育', '参与创世之战', '定立天地法则', '划分三界六道', '镇压上古灾厄', '封印灭世魔神', '建立秩序纪元', '见证文明兴衰', '守护世界本源'],
    
    // 炁兽特有
    炁兽本质: ['太初之气', '鸿蒙紫气', '混沌元气', '玄黄母气', '阴阳二气', '五行本源', '时空法则', '轮回印记', '因果丝线', '命运轨迹'],
    炁兽形态: ['气的聚合体', '道的显化形', '规则的具现', '概念的载体', '真理的投影', '本源的波动', '大道的涟漪', '存在的证明', '虚空的回响', '无的边界']
};
// 切换轮回神兽系统界面
function toggleBeastSystem() {
     if (player.level.ascentionCounta < 1) {
        alert("需要达到轮回1转才能开启轮回神兽！");
        return;
    }
    const overlay = document.getElementById('beastSystemOverlay');
    const ui = document.getElementById('beastSystemUI');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
       
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateBeastUI();
    }
}

// 在世界地图战斗胜利时，有几率掉落轮回神兽
function tryDropBeastAfterBattle() {
  const dimensionLevel = player.dimensionLevel; 
    if (player.dimensionLevel < 2) return;
    
    // 0.1% 的掉落几率
    if (Math.random() < 0.001) {
        const newBeast = generateRandomBeast();
        player.beasts.inventory.push(newBeast);
        
        logAction(`🎉 恭喜！在世界地图战斗中获得了轮回神兽：${newBeast.name}（${newBeast.rarity}·${newBeast.sLevel}）`, 'legendary');
        updateBeastUI();
    }
}

// ========== 像素玩家系统 ==========
(function() {
    var PIXEL_STAT_KEYS = ['attack', 'health', 'critRate', 'critDamage'];
    var PIXEL_STAT_NAMES = { attack: '攻击力', health: '生命', critRate: '暴击率', critDamage: '爆伤' };
    var PIXEL_SLOTS = ['helmet', 'clothes', 'cloak', 'pants', 'shoes'];
    var PIXEL_SLOT_NAMES = { helmet: '头盔', clothes: '衣服', cloak: '披风', pants: '裤子', shoes: '鞋子' };
    var HELMET_NAMES = ['帽子','头带','护额','头盔','斗笠','王冠','头巾','贝雷帽','军帽','风帽'];
    var CLOTHES_NAMES = ['短袖','长袖','背心','外套','和服','西装','卫衣','铠甲','长袍','马甲'];
    var CLOAK_NAMES = ['短披风','长披风','斗篷','羽织','披肩','罩袍','风衣','披风·赤','披风·青','披风·金'];
    var PANTS_NAMES = ['短裤','长裤','马裤','灯笼裤','牛仔裤','西裤','运动裤','束脚裤','阔腿裤','战裙'];
    var SHOES_NAMES = ['布鞋','皮鞋','短靴','长靴','凉鞋','运动鞋','木屐','草鞋','战靴','高跟鞋'];
    var PIXEL_WEAPON_NAMES = [];
    var WEAPON_TYPE_LIST = ['剑','刀','枪','匕首','弓','斧','锤','戟','镰刀','法杖','鞭','盾','大剑','长矛','弩','飞刀','阔剑','链锤','战戟','魔杖','短剑','战斧','双刃剑','弓弩','巨刃','龙枪','神杖','魔剑','圣斧','邪镰','破军戟','诛仙剑','斩魂刀','霸者之刃'];
    var N_WEAPON_TYPES = WEAPON_TYPE_LIST.length;
    for (var i = 1; i <= 100; i++) {
        PIXEL_WEAPON_NAMES.push('像素' + WEAPON_TYPE_LIST[(i - 1) % N_WEAPON_TYPES] + '·风格' + i);
    }
    function seedRandom(seed) {
        var s = seed;
        return function() {
            s = (s * 1103515245 + 12345) & 0x7fffffff;
            return s / 0x7fffffff;
        };
    }
    var CHAR_SIZE = 16;
    var WEAPON_W = 16, WEAPON_H = 16;
    var WEAPON_CELL_SCALE = 0.72;

    function hslToRgb(h, s, l) {
        h = h % 360; if (h < 0) h += 360;
        s = Math.max(0, Math.min(1, s)); l = Math.max(0, Math.min(1, l));
        var c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = l - c / 2, r = 0, g = 0, b = 0;
        if (h < 60) { r = c; g = x; b = 0; } else if (h < 120) { r = x; g = c; b = 0; } else if (h < 180) { r = 0; g = c; b = x; } else if (h < 240) { r = 0; g = x; b = c; } else if (h < 300) { r = x; g = 0; b = c; } else { r = c; g = 0; b = x; }
        return '#' + [r + m, g + m, b + m].map(function(v) { var hex = Math.round(v * 255).toString(16); return hex.length === 1 ? '0' + hex : hex; }).join('');
    }

    // 与参考图一致：浅桃色皮肤、纯黑发、白底蓝眼、红唇、深紫背景
    var SKIN_TONES = ['#FADAD2', '#F2CCC1', '#EAD6CC', '#F0D4CC', '#F2CCC1', '#EAD6CC', '#F0D4CC'];
    var RAINBOW_BLADE = ['#FFFFFF','#FFEB3B','#FF9800','#F44336','#E91E63','#9C27B0','#2196F3','#1976D2'];
    var WEAPON_COLOR_THEMES = [
        { blade: ['#A8B4C8', '#C8D4E0', '#8898B0', '#D8E0EC'], bladeHi: '#E8EEF4', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#98A8B8', '#B8C8D8', '#788898', '#C8D8E8'], bladeHi: '#E0E8F0', handle: '#3D2916', handleWrap: '#5C4033' },
        { blade: ['#909CA8', '#B0BCC8', '#708090', '#C0CCD8'], bladeHi: '#D8E0E8', handle: '#4A3728', handleWrap: '#6D5348' },
        { blade: ['#B0B8C0', '#D0D8E0', '#9098A0', '#D8DCE4'], bladeHi: '#E8ECF0', handle: '#3D2916', handleWrap: '#5C4033' },
        { blade: ['#8B6914', '#A08020', '#6B4423', '#B09030'], bladeHi: '#C0A040', handle: '#5D4037', handleWrap: '#6D5348' },
        { blade: ['#505860', '#687078', '#404850', '#788088'], bladeHi: '#889098', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#585858', '#707070', '#484848', '#808080'], bladeHi: '#909090', handle: '#4A3728', handleWrap: '#5C4033' },
        { blade: ['#88A0B0', '#A8C0D0', '#688090', '#B8D0E0'], bladeHi: '#D0E4F0', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#607080', '#8090A0', '#506070', '#90A0B0'], bladeHi: '#A0B0C0', handle: '#3D2916', handleWrap: '#5C4033' },
        { blade: ['#6B4423', '#8B6914', '#5A3A1A', '#9B7A2C'], bladeHi: '#B09040', handle: '#5D4037', handleWrap: '#6D5348' },
        { blade: ['#707878', '#909898', '#586068', '#A0A8A8'], bladeHi: '#B0B8B8', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#708090', '#90A0B0', '#607080', '#A0B0C0'], bladeHi: '#B8C4D0', handle: '#4A3728', handleWrap: '#5C4033' },
        { blade: ['#98A8B8', '#B8C8D8', '#788898', '#C8D8E8'], bladeHi: '#D8E4F0', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#88A0B0', '#A8C0D0', '#688090', '#B8D0E0'], bladeHi: '#C8DCE8', handle: '#4A3728', handleWrap: '#6D5348' },
        { blade: ['#A8B4C8', '#C8D4E0', '#8898B0', '#D8E0EC'], bladeHi: '#E8EEF4', handle: '#5D4037', handleWrap: '#6D5348' },
        { blade: ['#B0B8C0', '#D0D8E0', '#9098A0', '#D8DCE4'], bladeHi: '#E8ECF0', handle: '#3D2916', handleWrap: '#5C4033' },
        { blade: ['#505860', '#687078', '#404850', '#788088'], bladeHi: '#889098', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#707878', '#909898', '#586068', '#A0A8A8'], bladeHi: '#B0B8B8', handle: '#4A3728', handleWrap: '#5C4033' },
        { blade: ['#88A0B0', '#A8C0D0', '#688090', '#B8D0E0'], bladeHi: '#C8DCE8', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#6B4423', '#8B6914', '#5A3A1A', '#9B7A2C'], bladeHi: '#B09040', handle: '#5D4037', handleWrap: '#6D5348' },
        { blade: ['#98A8B8', '#B8C8D8', '#788898', '#C8D8E8'], bladeHi: '#D8E4F0', handle: '#3D2916', handleWrap: '#5C4033' },
        { blade: ['#505860', '#687078', '#404850', '#788088'], bladeHi: '#889098', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#A8B4C8', '#C8D4E0', '#8898B0', '#D8E0EC'], bladeHi: '#E8EEF4', handle: '#4A3728', handleWrap: '#6D5348' },
        { blade: ['#8B6914', '#A08020', '#6B4423', '#B09030'], bladeHi: '#C0A040', handle: '#5D4037', handleWrap: '#6D5348' },
        { blade: ['#607080', '#8090A0', '#506070', '#90A0B0'], bladeHi: '#A0B0C0', handle: '#4A3728', handleWrap: '#5C4033' },
        { blade: ['#88A0B0', '#A8C0D0', '#688090', '#B8D0E0'], bladeHi: '#C8DCE8', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#6B4423', '#8B6914', '#5A3A1A', '#9B7A2C'], bladeHi: '#B09040', handle: '#5D4037', handleWrap: '#6D5348' },
        { blade: ['#98A8B8', '#B8C8D8', '#788898', '#C8D8E8'], bladeHi: '#D8E4F0', handle: '#4A3728', handleWrap: '#5C4033' },
        { blade: ['#505860', '#687078', '#404850', '#788088'], bladeHi: '#889098', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#607080', '#8090A0', '#506070', '#90A0B0'], bladeHi: '#A0B0C0', handle: '#4A3728', handleWrap: '#6D5348' },
        { blade: ['#88A0B0', '#A8C0D0', '#688090', '#B8D0E0'], bladeHi: '#C8DCE8', handle: '#3D2916', handleWrap: '#5C4033' },
        { blade: ['#A8B4C8', '#C8D4E0', '#8898B0', '#D8E0EC'], bladeHi: '#E8EEF4', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#98A8B8', '#B8C8D8', '#788898', '#C8D8E8'], bladeHi: '#D8E4F0', handle: '#4A3728', handleWrap: '#6D5348' },
        { blade: ['#607080', '#8090A0', '#506070', '#90A0B0'], bladeHi: '#A0B0C0', handle: '#4A3728', handleWrap: '#5C4033' },
        { blade: ['#505860', '#687078', '#404850', '#788088'], bladeHi: '#889098', handle: '#4A3728', handleWrap: '#5D4037' },
        { blade: ['#88A0B0', '#A8C0D0', '#688090', '#B8D0E0'], bladeHi: '#C8DCE8', handle: '#4A3728', handleWrap: '#5D4037' }
    ];
    function getCharColors(shapeId) {
        shapeId = Math.max(1, Math.min(100, shapeId || 1));
        return {
            head: '#FADAD2',
            body: SKIN_TONES,
            legs: ['#F2CCC1', '#EAD6CC'],
            accent: '#FF8F00',
            hair: '#000000',
            hairHi: '#111111',
            eyeWhite: '#FFFFFF',
            eyePupil: '#0066FF',
            mouth: '#FF0000',
            nose: '#F2CCC1'
        };
    }
    function getSlotColors(slot, shapeId) {
        shapeId = Math.max(1, Math.min(10, shapeId || 1));
        var hue = (shapeId - 1) * 36;
        var h = hslToRgb(hue, 0.5, 0.5);
        var hi = hslToRgb(hue, 0.4, 0.7);
        if (slot === 'helmet') return { main: hslToRgb(hue + 20, 0.5, 0.45), hi: hi };
        if (slot === 'clothes') return { main: hslToRgb(hue, 0.55, 0.45), hi: hi };
        if (slot === 'cloak') return { main: hslToRgb(hue + 30, 0.5, 0.4), hi: hi };
        if (slot === 'pants') return { main: hslToRgb(hue + 15, 0.5, 0.4), hi: hi };
        if (slot === 'shoes') return { main: hslToRgb(hue + 10, 0.45, 0.35), hi: hi };
        return { main: '#888', hi: '#aaa' };
    }

    function getWeaponColors(shapeId) {
        shapeId = Math.max(1, Math.min(100, shapeId || 1));
        var type = (shapeId - 1) % N_WEAPON_TYPES;
        var theme = WEAPON_COLOR_THEMES[type] || WEAPON_COLOR_THEMES[0];
        return {
            bladeStripes: theme.blade,
            bladeHi: theme.bladeHi,
            handle: theme.handle,
            handleWrap: theme.handleWrap,
            outline: '#1a1a1a'
        };
    }
    var BASE_CHAR_TEMPLATE = [
        '.....2222.......',
        '....222222......',
        '...2222221......',
        '...221131.......',
        '...211156.......',
        '....111.........',
        '....11111.......',
        '...111111.......',
        '...11111........',
        '....111.........',
        '.....11.........',
        '.....11.........',
        '.....11.........',
        '.....11.........',
        '.....11.........',
        '....1111........'
    ];
    function parseLayerChar(ch) {
        if (!ch || ch === '.') return 0;
        if (ch === 'a') return 10; if (ch === 'b') return 11; if (ch === 'c') return 12;
        return (ch >= '1' && ch <= '9') ? (ch - '0') * 1 : 0;
    }
    var HELMET_LAYERS = [
        ['.....8888.......', '....888888.......', '...8888........', '...88...........', '...88...........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................'],
        ['....88888.......', '...888888.......', '...8888........', '...88...........', '...88...........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................'],
        ['.....8888.......', '....888888.......', '...88882........', '...88...........', '...88...........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................'],
        ['....888888......', '...888888.......', '...8888........', '...88...........', '...88...........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................'],
        ['888...888.......', '.8888888........', '...8888........', '...88...........', '...88...........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................'],
        ['......888.......', '.....8888........', '....88888.......', '....88.........', '....88.........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................'],
        ['....88888.......', '...888888.......', '...8888........', '...88...........', '...88...........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................'],
        ['.....8888.......', '....88888........', '...8888........', '...88...........', '...88...........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................'],
        ['.....8888.......', '....888888.......', '...8888........', '...88...........', '...88...........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................'],
        ['....888888......', '...888888.......', '...88882........', '...88...........', '...88...........', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................']
    ];
    var CLOTHES_LAYERS = [
        ['................', '................', '................', '................', '................', '....9999........', '...999999.......', '...99999........', '..9999..77.......', '...999...........', '................', '................', '................', '................', '................', '................'],
        ['................', '................', '................', '................', '................', '....9999........', '...999999.......', '...99999........', '..9999..99.......', '...999...........', '................', '................', '................', '................', '................', '................'],
        ['................', '................', '................', '................', '................', '....9999........', '...999999.......', '...99999........', '..9999..77.......', '...999...........', '................', '................', '................', '................', '................', '................'],
        ['................', '................', '................', '................', '................', '...99999........', '..999999........', '.999999.........', '.99999.........', '..999............', '................', '................', '................', '................', '................', '................'],
        ['................', '................', '................', '................', '................', '....9999........', '...999999.......', '...99999........', '..9999..77.......', '...999...........', '................', '................', '................', '................', '................', '................'],
        ['................', '................', '................', '................', '................', '....9999........', '...999999.......', '...99999........', '..9999..77.......', '...999...........', '................', '................', '................', '................', '................', '................'],
        ['................', '................', '................', '................', '................', '...99999........', '..999999........', '.999999.........', '.99999.........', '..999............', '................', '................', '................', '................', '................', '................'],
        ['................', '................', '................', '................', '................', '....9999........', '...999999.......', '...99999........', '..9999..77.......', '...999...........', '................', '................', '................', '................', '................', '................'],
        ['................', '................', '................', '................', '................', '....9999........', '...999999.......', '...99999........', '..9999..77.......', '...999...........', '................', '................', '................', '................', '................', '................'],
        ['................', '................', '................', '................', '................', '....9999........', '...999999.......', '...99999........', '..9999..77.......', '...999...........', '................', '................', '................', '................', '................', '................']
    ];
    var CLOAK_LAYERS = [
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.aa..............', '.a................', '.a................', '.a................', '.a................'],
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.a................', '.a................', '.a................', '.a................', '................'],
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.aa..............', '.a................', '.a................', '.a................', '.a................'],
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.a................', '.a................', '.a................', '.a................', '................'],
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.a................', '.a................', '.a................', '.a................', '................'],
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.a................', '.a................', '.a................', '.a................', '................'],
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.aa..............', '.a................', '.a................', '.a................', '.a................'],
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.a................', '.a................', '.a................', '.a................', '................'],
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.a................', '.a................', '.a................', '.a................', '................'],
        ['................', '................', '................', '................', '................', '..aaa............', '..aaa............', '.aaa............', '.aa.............', '.a...............', '.aaa............', '.aa..............', '.a................', '.a................', '.a................', '.a................']
    ];
    var PANTS_LAYERS = [
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........', '....bbb.........']
    ];
    var SHOES_LAYERS = [
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........'],
        ['................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '................', '....ccc.........', '....cccc........']
    ];
    var LAYER_SETS = { helmet: HELMET_LAYERS, clothes: CLOTHES_LAYERS, cloak: CLOAK_LAYERS, pants: PANTS_LAYERS, shoes: SHOES_LAYERS };
    function parseTemplateToGrid(tpl) {
        var grid = [];
        var rows = tpl.length, cols = tpl[0] ? tpl[0].length : CHAR_SIZE;
        for (var y = 0; y < rows; y++) {
            grid[y] = [];
            for (var x = 0; x < cols; x++) {
                var ch = tpl[y] ? tpl[y].charAt(x) : '.';
                var v = ch === '.' ? 0 : (ch === '2' ? 2 : (ch === '3' ? 3 : (ch === '4' ? 4 : (ch === '5' ? 5 : (ch === '6' ? 6 : (ch === '7' ? 7 : (ch === '8' ? 8 : (ch === '9' ? 9 : 1))))))));
                grid[y][x] = v;
            }
        }
        return grid;
    }
    function parseLayerToGrid(tpl) {
        var grid = [];
        for (var y = 0; y < tpl.length; y++) {
            grid[y] = [];
            var row = tpl[y] || '';
            for (var x = 0; x < CHAR_SIZE; x++) {
                grid[y][x] = parseLayerChar(row.charAt(x));
            }
        }
        return grid;
    }
    function getPixelCharacterShape(equipped) {
        var base = parseTemplateToGrid(BASE_CHAR_TEMPLATE);
        if (!equipped) return base;
        var order = ['pants', 'clothes', 'cloak', 'helmet', 'shoes'];
        for (var s = 0; s < order.length; s++) {
            var slot = order[s];
            var skin = equipped[slot + 'Skin'];
            if (!skin || !skin.shapeId) continue;
            var set = LAYER_SETS[slot];
            var style = Math.max(0, Math.min(9, (skin.shapeId - 1) % 10));
            var layer = set && set[style];
            if (!layer) continue;
            var grid = parseLayerToGrid(layer);
            for (var by = 0; by < base.length; by++) {
                for (var bx = 0; bx < (base[by] && base[by].length) || 0; bx++) {
                    if (grid[by] && grid[by][bx]) base[by][bx] = grid[by][bx];
                }
            }
        }
        return base;
    }

    var WEAPON_TYPE_NAMES = WEAPON_TYPE_LIST;
    function getWeaponType(shapeId) {
        return ((shapeId - 1) % N_WEAPON_TYPES);
    }
    function getPixelWeaponShape(shapeId) {
        shapeId = Math.max(1, Math.min(100, shapeId || 1));
        var rnd = seedRandom(shapeId * 6781 + 100);
        var grid = [];
        var type = getWeaponType(shapeId);
        var cx = 8;
        for (var y = 0; y < WEAPON_H; y++) {
            grid[y] = [];
            for (var x = 0; x < WEAPON_W; x++) grid[y][x] = 0;
        }
        if (type === 0) {
            for (var y = 0; y < 9; y++) { var w = y === 0 ? 0 : (y < 8 ? 1 : 2); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 9; y < 10; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 1) {
            for (var y = 0; y < 10; y++) { var curve = Math.floor(1.2 * (y - 5)); var w = y < 2 ? 0 : (y < 6 ? 1 : 2); for (var x = cx - w + curve; x <= cx + w + curve; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 10; y < 11; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 11; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 2) {
            for (var y = 0; y < 10; y++) { var w = y < 2 ? 1 : 2; for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 3) {
            for (var y = 0; y < 5; y++) { var w = y === 0 ? 0 : (y < 4 ? 1 : 2); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 5; y < 6; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 6; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 4) {
            for (var a = 0; a < 28; a++) { var angle = -0.5 + (a / 28) * 1.4; for (var r = 4; r <= 6; r++) { var bx = Math.round(cx + r * Math.cos(angle)); var by = Math.round(5 + r * Math.sin(angle)); if (by >= 0 && by < WEAPON_H && bx >= 0 && bx < WEAPON_W) grid[by][bx] = 1; } }
            for (var y = 5; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 5) {
            for (var y = 0; y < 6; y++) { var aw = y < 2 ? (y + 1) : (6 - y); for (var x = cx - 4; x <= cx + 4; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) <= aw) grid[y][x] = 1; }
            for (var y = 6; y < 8; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 8; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 6) {
            for (var y = 0; y < 5; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 5; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 7) {
            for (var y = 0; y < 8; y++) { var w = y < 2 ? 1 : (y < 5 ? 2 : 1); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 5; y < 9; y++) for (var x = cx - 3; x <= cx + 3; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) <= 1) grid[y][x] = 1;
            for (var y = 6; y < 8; y++) for (var x = cx + 2; x <= cx + 4; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 8; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 8) {
            for (var y = 0; y < 10; y++) { var curve = Math.floor(2.5 * Math.sin((y - 4) * 0.5)); for (var x = cx - 1 + curve; x <= cx + 1 + curve; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 9) {
            for (var y = 0; y < 4; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) + Math.abs(y - 1) <= 2) grid[y][x] = 1;
            for (var y = 4; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 10) {
            for (var y = 0; y < WEAPON_H; y++) { var sway = Math.floor(1.2 * Math.sin(y * 0.7)); for (var x = cx + sway; x <= cx + sway + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
        } else if (type === 11) {
            for (var y = 2; y < 12; y++) { var w = 4 - Math.floor(Math.abs(y - 7) / 2); if (w < 1) w = 1; for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 12; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 12) {
            for (var y = 0; y < 10; y++) { var w = y === 0 ? 0 : (y < 3 ? 1 : (y < 8 ? 2 : 1)); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 10; y < 11; y++) for (var x = cx - 3; x <= cx + 3; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 11; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 13) {
            for (var y = 0; y < 11; y++) { var w = y < 2 ? 1 : 2; for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 11; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 14) {
            for (var a = 0; a < 24; a++) { var angle = -0.55 + (a / 24) * 1.3; for (var r = 3; r <= 5; r++) { var bx = Math.round(cx + r * Math.cos(angle)); var by = Math.round(4 + r * Math.sin(angle)); if (by >= 0 && by < WEAPON_H && bx >= 0 && bx < WEAPON_W) grid[by][bx] = 1; } }
            for (var y = 3; y < 8; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 8; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 15) {
            for (var y = 0; y < 4; y++) { var w = y === 0 ? 0 : 1; for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 4; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 16) {
            for (var y = 0; y < 9; y++) { var w = y === 0 ? 0 : (y < 3 ? 1 : (y < 7 ? 2 : 1)); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 9; y < 10; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 17) {
            for (var y = 0; y < 4; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 4; y < 7; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) <= 1) grid[y][x] = 1;
            for (var y = 7; y < WEAPON_H; y++) { var sway = Math.floor(1.5 * Math.sin((y - 7) * 0.5)); for (var x = cx - 1 + sway; x <= cx + 1 + sway; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
        } else if (type === 18) {
            for (var y = 0; y < 8; y++) { var w = y < 2 ? 1 : (y < 5 ? 2 : 1); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 5; y < 9; y++) for (var x = cx - 3; x <= cx + 3; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) <= 1) grid[y][x] = 1;
            for (var y = 6; y < 8; y++) for (var x = cx + 2; x <= cx + 4; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 8; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 19) {
            for (var y = 0; y < 3; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) + y <= 2) grid[y][x] = 1;
            for (var y = 3; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 20) {
            for (var y = 0; y < 6; y++) { var w = y === 0 ? 0 : (y < 4 ? 1 : 2); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 6; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 21) {
            for (var y = 0; y < 6; y++) { var aw = y < 2 ? (y + 1) : (6 - y); for (var x = cx - 4; x <= cx + 4; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) <= aw) grid[y][x] = 1; }
            for (var y = 6; y < 8; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 8; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 22) {
            for (var y = 0; y < 9; y++) { var w = y === 0 ? 0 : (y < 3 ? 1 : (y < 7 ? 2 : 1)); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 9; y < 10; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 23) {
            for (var a = 0; a < 26; a++) { var angle = -0.48 + (a / 26) * 1.38; for (var r = 4; r <= 5; r++) { var bx = Math.round(cx + r * Math.cos(angle)); var by = Math.round(5 + r * Math.sin(angle)); if (by >= 0 && by < WEAPON_H && bx >= 0 && bx < WEAPON_W) grid[by][bx] = 1; } }
            for (var y = 5; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 24) {
            for (var y = 0; y < 10; y++) { var w = y === 0 ? 0 : (y < 3 ? 1 : (y < 7 ? 3 : 2)); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 10; y < 11; y++) for (var x = cx - 3; x <= cx + 3; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 11; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 25) {
            for (var y = 0; y < 12; y++) { var w = y < 2 ? 1 : 2; for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 12; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 26) {
            for (var y = 0; y < 4; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) + y <= 2) grid[y][x] = 1;
            for (var y = 4; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 27) {
            for (var y = 0; y < 9; y++) { var w = y === 0 ? 0 : (y < 3 ? 1 : (y < 7 ? 2 : 1)); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 9; y < 10; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 28) {
            for (var y = 0; y < 7; y++) { var aw = y < 2 ? (y + 1) : (7 - y); for (var x = cx - 4; x <= cx + 4; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) <= aw) grid[y][x] = 1; }
            for (var y = 7; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 29) {
            for (var y = 0; y < 10; y++) { var curve = Math.floor(2 * Math.sin((y - 4) * 0.45)); for (var x = cx - 1 + curve; x <= cx + 1 + curve; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 30) {
            for (var y = 0; y < 8; y++) { var w = y < 2 ? 1 : (y < 5 ? 2 : 1); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 5; y < 9; y++) for (var x = cx - 3; x <= cx + 3; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) <= 1) grid[y][x] = 1;
            for (var y = 6; y < 8; y++) for (var x = cx + 2; x <= cx + 4; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 8; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 31) {
            for (var y = 0; y < 9; y++) { var w = y === 0 ? 0 : (y < 3 ? 1 : (y < 7 ? 2 : 1)); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 9; y < 10; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 32) {
            for (var y = 0; y < 10; y++) { var curve = Math.floor(1.2 * (y - 5)); var w = y < 2 ? 0 : (y < 6 ? 1 : 2); for (var x = cx - w + curve; x <= cx + w + curve; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 10; y < 11; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 11; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 33) {
            for (var y = 0; y < 8; y++) { var aw = y < 2 ? (y + 1) : (8 - y); for (var x = cx - 4; x <= cx + 4; x++) if (x >= 0 && x < WEAPON_W && Math.abs(x - cx) <= Math.min(aw, 3)) grid[y][x] = 1; }
            for (var y = 8; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 34) {
            for (var y = 0; y < 9; y++) { var w = y === 0 ? 0 : (y < 3 ? 1 : (y < 6 ? 2 : 1)); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 9; y < 10; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else if (type === 35) {
            for (var y = 0; y < 9; y++) { var w = y === 0 ? 0 : (y < 3 ? 1 : (y < 6 ? 2 : 1)); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 9; y < 10; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        } else {
            for (var y = 0; y < 9; y++) { var w = y === 0 ? 0 : (y < 3 ? 1 : (y < 7 ? 2 : 1)); for (var x = cx - w; x <= cx + w; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1; }
            for (var y = 9; y < 10; y++) for (var x = cx - 2; x <= cx + 2; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
            for (var y = 10; y < WEAPON_H; y++) for (var x = cx - 1; x <= cx + 1; x++) if (x >= 0 && x < WEAPON_W) grid[y][x] = 1;
        }
        return grid;
    }
    function getPixelSkinName(type, shapeId) {
        if (type === 'weapon') return PIXEL_WEAPON_NAMES[Math.max(0, (shapeId - 1) % PIXEL_WEAPON_NAMES.length)];
        var sid = Math.max(0, Math.min(9, (shapeId - 1) % 10));
        if (type === 'helmet') return '头盔·' + HELMET_NAMES[sid];
        if (type === 'clothes') return '衣服·' + CLOTHES_NAMES[sid];
        if (type === 'cloak') return '披风·' + CLOAK_NAMES[sid];
        if (type === 'pants') return '裤子·' + PANTS_NAMES[sid];
        if (type === 'shoes') return '鞋子·' + SHOES_NAMES[sid];
        return type + '·' + shapeId;
    }
    function generatePixelSkin(type, shapeId) {
        var isWeapon = (type === 'weapon');
        shapeId = isWeapon ? Math.max(1, Math.min(100, shapeId || 1)) : Math.max(1, Math.min(10, shapeId || 1));
        var name = getPixelSkinName(type, shapeId);
        var numLines = 1 + Math.floor(Math.random() * 2);
        var stats = {};
        for (var i = 0; i < numLines; i++) {
            var key = PIXEL_STAT_KEYS[Math.floor(Math.random() * PIXEL_STAT_KEYS.length)];
            var val = 1 + Math.floor(Math.random() * 100);
            stats[key] = (stats[key] || 0) + val;
        }
        return { type: type, shapeId: shapeId, name: name, stats: stats, id: Date.now() + '-' + Math.random().toString(36).slice(2) };
    }
    function getPixelPlayerBonus() {
        if (!player.pixelPlayer) return { health: 0, attack: 0, critRate: 0, critDamage: 0 };
        var b = { health: 0, attack: 0, critRate: 0, critDamage: 0 };
        var pp = player.pixelPlayer;
        var allSkins = [pp.helmetSkin, pp.clothesSkin, pp.cloakSkin, pp.pantsSkin, pp.shoesSkin, pp.weaponSkin];
        if (pp.characterSkin) allSkins.push(pp.characterSkin);
        allSkins.forEach(function(s) {
            if (!s || !s.stats) return;
            if (s.stats.health) b.health += s.stats.health / 100;
            if (s.stats.attack) b.attack += s.stats.attack / 100;
            if (s.stats.critRate) b.critRate += s.stats.critRate / 100;
            if (s.stats.critDamage) b.critDamage += s.stats.critDamage / 100;
        });
        return b;
    }
    window.getPixelPlayerBonus = getPixelPlayerBonus;
    window.generatePixelSkin = generatePixelSkin;
    window.getPixelCharacterShape = getPixelCharacterShape;
    window.getPixelWeaponShape = getPixelWeaponShape;

    function tryDropPixelSkinAfterBattle() {
        if (player.dimensionLevel < 1) return;
        if (Math.random() >= 0.001) return;
        if (!player.pixelPlayer) player.pixelPlayer = { helmetSkin: null, clothesSkin: null, cloakSkin: null, pantsSkin: null, shoesSkin: null, weaponSkin: null, inventory: [] };
        var types = ['helmet', 'clothes', 'cloak', 'pants', 'shoes', 'weapon'];
        var type = types[Math.floor(Math.random() * types.length)];
        var shapeId = (type === 'weapon') ? (1 + Math.floor(Math.random() * 100)) : (1 + Math.floor(Math.random() * 10));
        var skin = generatePixelSkin(type, shapeId);
        player.pixelPlayer.inventory.push(skin);
        logAction('像素玩家：获得 ' + skin.name + '（' + (PIXEL_SLOT_NAMES[type] || '武器') + '）', 'legendary');
        if (typeof updatePixelPlayerUI === 'function') updatePixelPlayerUI();
    }
    window.tryDropPixelSkinAfterBattle = tryDropPixelSkinAfterBattle;

    function togglePixelPlayerUI() {
         if (player.reincarnationCount < 100) {
        alert("需要达到100转才能开启抽象时装系统！");
        return;
    }
        if (!player.pixelPlayer) player.pixelPlayer = { helmetSkin: null, clothesSkin: null, cloakSkin: null, pantsSkin: null, shoesSkin: null, weaponSkin: null, inventory: [] };
        var pp = player.pixelPlayer;
        if (pp.characterSkin) { pp.clothesSkin = pp.characterSkin; pp.characterSkin = null; }
        var overlay = document.getElementById('pixelPlayerOverlay');
        var ui = document.getElementById('pixelPlayerUI');
        if (ui && overlay) {
            if (ui.style.display === 'block') {
                ui.style.display = 'none';
                overlay.style.display = 'none';
            } else {
                overlay.style.display = 'block';
                ui.style.display = 'block';
                updatePixelPlayerUI();
            }
        }
    }
    window.togglePixelPlayerUI = togglePixelPlayerUI;

    function updatePixelPlayerUI() {
        if (!player.pixelPlayer) return;
        var pp = player.pixelPlayer;
        if (pp.characterSkin) { pp.clothesSkin = pp.characterSkin; pp.characterSkin = null; }
        var slotIds = ['helmet', 'clothes', 'cloak', 'pants', 'shoes', 'weapon'];
        slotIds.forEach(function(slot) {
            var el = document.getElementById('pixel' + slot.charAt(0).toUpperCase() + slot.slice(1) + 'Slot');
            if (!el) return;
            var skin = pp[slot + 'Skin'];
            if (skin) {
                el.innerHTML = '<div style="margin-bottom:2px;">' + skin.name + '</div><div style="font-size:10px;color:#8dd4e0;">' + formatPixelSkinStats(skin) + '</div><button onclick="unequipPixelSkin(\'' + slot + '\')" style="margin-right:4px;padding:2px 6px;border-radius:4px;background:#2a2a4a;color:#00BCD4;border:1px solid #00BCD4;cursor:pointer;font-size:10px;">卸下</button><button onclick="discardPixelSkin(\'' + slot + '\')" style="padding:2px 6px;border-radius:4px;background:#4a2a2a;color:#ff8888;border:1px solid #ff6666;cursor:pointer;font-size:10px;">丢弃</button>';
            } else el.innerHTML = '未装备';
        });
        var bonusEl = document.getElementById('pixelPlayerBonus');
        var invEl = document.getElementById('pixelPlayerInventory');
        var b = getPixelPlayerBonus();
        if (bonusEl) bonusEl.textContent = '总加成：生命+' + (b.health * 100).toFixed(0) + '% 攻击+' + (b.attack * 100).toFixed(0) + '% 暴击率+' + (b.critRate * 100).toFixed(0) + '% 爆伤+' + (b.critDamage * 100).toFixed(0) + '%';
        var filterEl = document.getElementById('pixelInventoryFilter');
        var filterType = (filterEl && filterEl.value) ? filterEl.value : 'all';
        var batchArea = document.getElementById('pixelBatchDiscardArea');
        if (batchArea) batchArea.style.display = pixelBatchMode ? 'inline' : 'none';
        var batchBtn = document.getElementById('pixelBatchDiscardBtn');
        if (batchBtn) batchBtn.textContent = pixelBatchMode ? '取消选择模式' : '选择批量丢弃';
        if (invEl) {
            invEl.innerHTML = '';
            var list = pp.inventory || [];
            for (var idx = 0; idx < list.length; idx++) {
                var skin = list[idx];
                if (filterType !== 'all' && skin.type !== filterType) continue;
                var card = document.createElement('div');
                var isLocked = !!skin.locked;
                card.style.cssText = 'padding:8px;border-radius:8px;background:#2a2a4a;border:1px solid ' + (isLocked ? '#888' : '#00BCD4') + ';font-size:12px;display:flex;flex-direction:column;gap:4px;min-width:120px;';
                var typeName = (PIXEL_SLOT_NAMES[skin.type] || (skin.type === 'weapon' ? '武器' : skin.type)) || '时装';
                var lockBtnHtml = '<button class="pixel-lock-btn" title="' + (isLocked ? '解锁' : '锁定') + '" style="padding:2px 6px;border-radius:4px;background:' + (isLocked ? '#4a4a6a' : '#2a2a4a') + ';color:' + (isLocked ? '#ffc107' : '#888') + ';border:1px solid ' + (isLocked ? '#ffc107' : '#555') + ';cursor:pointer;font-size:10px;">' + (isLocked ? '🔒' : '🔓') + '</button>';
                var checkHtml = pixelBatchMode ? '<label style="display:inline-flex;align-items:center;gap:4px;font-size:10px;"><input type="checkbox" class="pixel-batch-check" data-idx="' + idx + '">勾选丢弃</label>' : '';
                var discardBtnHtml = (!pixelBatchMode && !isLocked) ? '<button class="pixel-discard-btn" style="padding:4px 8px;border-radius:4px;background:#4a2a2a;color:#f88;border:1px solid #f66;cursor:pointer;font-size:11px;">丢弃</button>' : '';
                card.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:flex-start;"><div style="color:#00BCD4;font-size:11px;">' + skin.name + '</div>' + lockBtnHtml + '</div><div style="font-size:10px;color:#8dd4e0;">' + typeName + ' · ' + formatPixelSkinStats(skin) + '</div><div style="display:flex;gap:4px;flex-wrap:wrap;align-items:center;">' +
                    '<button class="pixel-equip-btn" style="padding:4px 8px;border-radius:4px;background:#2a4a2a;color:#8f8;border:1px solid #6a6;cursor:pointer;font-size:11px;">装备</button>' +
                    checkHtml + discardBtnHtml + '</div>';
                var equipBtn = card.querySelector('.pixel-equip-btn');
                var discardBtn = card.querySelector('.pixel-discard-btn');
                var lockBtn = card.querySelector('.pixel-lock-btn');
                var checkEl = card.querySelector('.pixel-batch-check');
                equipBtn.onclick = (function(s, i) { return function() { equipPixelSkin(s, i); }; })(skin, idx);
                if (discardBtn) discardBtn.onclick = (function(i) { return function() { discardPixelSkin('inventory', i); }; })(idx);
                if (lockBtn) lockBtn.onclick = (function(s) { return function() { s.locked = !s.locked; updatePixelPlayerUI(); }; })(skin);
                if (checkEl) {
                    checkEl.checked = !!pixelSelectedIndices[idx];
                    checkEl.onchange = (function(i) { return function() { pixelSelectedIndices[i] = this.checked; updatePixelPlayerUI(); }; })(idx);
                }
                invEl.appendChild(card);
            }
        }
        drawPixelCanvas();
    }
    window.updatePixelPlayerUI = updatePixelPlayerUI;

    var pixelBatchMode = false;
    var pixelSelectedIndices = {};
    function togglePixelBatchDiscardMode() {
        pixelBatchMode = !pixelBatchMode;
        if (!pixelBatchMode) pixelSelectedIndices = {};
        updatePixelPlayerUI();
    }
    window.togglePixelBatchDiscardMode = togglePixelBatchDiscardMode;

    function confirmPixelBatchDiscard() {
        if (!player.pixelPlayer) return;
        var pp = player.pixelPlayer;
        var list = pp.inventory || [];
        var toRemove = [];
        for (var k in pixelSelectedIndices) if (pixelSelectedIndices[k] && list[parseInt(k, 10)] && !list[parseInt(k, 10)].locked) toRemove.push(parseInt(k, 10));
        toRemove.sort(function(a, b) { return b - a; });
        for (var r = 0; r < toRemove.length; r++) pp.inventory.splice(toRemove[r], 1);
        pixelSelectedIndices = {};
        pixelBatchMode = false;
        updatePixelPlayerUI();
    }
    window.confirmPixelBatchDiscard = confirmPixelBatchDiscard;

    function drawPixelCanvas() {
        var canvas = document.getElementById('pixelCharacterCanvas');
        if (!canvas || !canvas.getContext) return;
        var ctx = canvas.getContext('2d');
        var w = canvas.clientWidth || 512;
        var h = canvas.clientHeight || 512;
        canvas.width = w; canvas.height = h;
        ctx.fillStyle = '#4C2060';
        ctx.fillRect(0, 0, w, h);
        var pp = player.pixelPlayer || {};
        var characterDisplaySize = 384;
        var cell = Math.floor(characterDisplaySize / CHAR_SIZE);
        if (cell < 6) cell = 6;
        var ox = Math.floor((w - CHAR_SIZE * cell) / 2) + Math.floor(w * 0.06);
        var oy = Math.floor((h - CHAR_SIZE * cell) / 2);
        var bodyGrid = getPixelCharacterShape(pp);
        var charColors = getCharColors(1);
        var outlineColor = '#3a1848';
        var wCell = Math.max(4, Math.floor(cell * WEAPON_CELL_SCALE));
        var handCol = 10.6, handRow = 6.3;
        var weaponHandleRow = 11, weaponHandleCol = 8;
        for (var by = 0; by < bodyGrid.length; by++) {
            for (var bx = 0; bx < (bodyGrid[by] && bodyGrid[by].length) || 0; bx++) {
                if (bodyGrid[by][bx] === 0) continue;
                var pad = Math.max(1, Math.floor(cell * 0.2));
                ctx.fillStyle = 'rgba(250,218,210,0.06)';
                ctx.fillRect(ox + bx * cell - pad, oy + by * cell - pad, cell + pad * 2, cell + pad * 2);
            }
        }
        for (var by = 0; by < bodyGrid.length; by++) {
            for (var bx = 0; bx < (bodyGrid[by] && bodyGrid[by].length) || 0; bx++) {
                if (bodyGrid[by][bx] === 0) continue;
                ctx.fillStyle = outlineColor;
                if (bx > 0 && bodyGrid[by][bx - 1] === 0) ctx.fillRect(ox + (bx - 1) * cell, oy + by * cell, cell, cell);
                if (bx < ((bodyGrid[by] && bodyGrid[by].length) - 1) && bodyGrid[by][bx + 1] === 0) ctx.fillRect(ox + (bx + 1) * cell, oy + by * cell, cell, cell);
                if (by > 0 && bodyGrid[by - 1][bx] === 0) ctx.fillRect(ox + bx * cell, oy + (by - 1) * cell, cell, cell);
                if (by < bodyGrid.length - 1 && bodyGrid[by + 1][bx] === 0) ctx.fillRect(ox + bx * cell, oy + (by + 1) * cell, cell, cell);
            }
        }
        if (pp.weaponSkin) {
            var weaponGrid = getPixelWeaponShape(pp.weaponSkin.shapeId);
            var wColors = getWeaponColors(pp.weaponSkin.shapeId);
            var pivotX = ox + handCol * cell;
            var pivotY = oy + handRow * cell;
            var weaponOx = pivotX - weaponHandleCol * wCell;
            var weaponOy = pivotY - weaponHandleRow * wCell;
            var tiltAngle = 0.78;
            var weaponThinScale = 0.46;
            var weaponSizeScale = 1.18;
            ctx.save();
            ctx.translate(pivotX, pivotY);
            ctx.rotate(tiltAngle);
            ctx.scale(weaponThinScale * weaponSizeScale, weaponSizeScale);
            ctx.translate(-pivotX, -pivotY);
            ctx.shadowColor = 'rgba(200,210,220,0.5)';
            ctx.shadowBlur = 12;
            for (var wy = 0; wy < weaponGrid.length; wy++) {
                for (var wx = 0; wx < (weaponGrid[wy] && weaponGrid[wy].length) || 0; wx++) {
                    if (weaponGrid[wy][wx]) {
                        ctx.fillStyle = 'rgba(220,228,235,0.25)';
                        ctx.fillRect(weaponOx + wx * wCell - 5, weaponOy + wy * wCell - 5, wCell + 10, wCell + 10);
                    }
                }
            }
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'rgba(180,190,200,0.4)';
            ctx.shadowBlur = 6;
            for (var wy = 0; wy < weaponGrid.length; wy++) {
                for (var wx = 0; wx < (weaponGrid[wy] && weaponGrid[wy].length) || 0; wx++) {
                    if (weaponGrid[wy][wx]) {
                        ctx.fillStyle = 'rgba(240,245,250,0.2)';
                        ctx.fillRect(weaponOx + wx * wCell - 2, weaponOy + wy * wCell - 2, wCell + 4, wCell + 4);
                    }
                }
            }
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.fillStyle = wColors.outline;
            for (var wy = 0; wy < weaponGrid.length; wy++) {
                for (var wx = 0; wx < (weaponGrid[wy] && weaponGrid[wy].length) || 0; wx++) {
                    if (weaponGrid[wy][wx]) {
                        ctx.fillRect(weaponOx + wx * wCell - 1, weaponOy + wy * wCell, wCell + 2, wCell);
                        ctx.fillRect(weaponOx + wx * wCell, weaponOy + wy * wCell - 1, wCell, wCell + 2);
                    }
                }
            }
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            for (var wy = 0; wy < weaponGrid.length; wy++) {
                for (var wx = 0; wx < (weaponGrid[wy] && weaponGrid[wy].length) || 0; wx++) {
                    if (weaponGrid[wy][wx]) {
                        var pad = Math.max(1, Math.floor(wCell * 0.25));
                        ctx.fillRect(weaponOx + wx * wCell - pad, weaponOy + wy * wCell - pad, wCell + pad * 2, wCell + pad * 2);
                    }
                }
            }
            for (var wy = 0; wy < weaponGrid.length; wy++) {
                for (var wx = 0; wx < (weaponGrid[wy] && weaponGrid[wy].length) || 0; wx++) {
                    if (!weaponGrid[wy][wx]) continue;
                    if (wy >= 12) ctx.fillStyle = (wy % 2 === 0) ? wColors.handle : wColors.handleWrap;
                    else if (wy <= 1) ctx.fillStyle = wColors.bladeHi;
                    else ctx.fillStyle = wColors.bladeStripes[wy % wColors.bladeStripes.length];
                    ctx.fillRect(weaponOx + wx * wCell, weaponOy + wy * wCell, wCell, wCell);
                }
            }
            ctx.restore();
        }
        for (var by = 0; by < bodyGrid.length; by++) {
            for (var bx = 0; bx < (bodyGrid[by] && bodyGrid[by].length) || 0; bx++) {
                var code = bodyGrid[by][bx];
                if (code === 0) continue;
                if (code === 1) {
                    if (by <= 4) ctx.fillStyle = charColors.head;
                    else if (by < 10) {
                        if (by === 5) ctx.fillStyle = charColors.body[1];
                        else if ((by === 7 || by === 8) && bx >= 6) ctx.fillStyle = charColors.body[1];
                        else ctx.fillStyle = charColors.body[(by - 5) % 7];
                    } else if (by < 14) ctx.fillStyle = charColors.legs[0];
                    else ctx.fillStyle = charColors.legs[1];
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                } else if (code === 2) {
                    ctx.fillStyle = (by % 2 === 0 && (bx + by) % 2 === 0) ? charColors.hairHi : charColors.hair;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                } else if (code === 8) {
                    var c = getSlotColors('helmet', pp.helmetSkin && pp.helmetSkin.shapeId);
                    ctx.fillStyle = (by % 2 === 0 && (bx + by) % 2 === 0) ? c.hi : c.main;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                } else if (code === 9) {
                    var c = getSlotColors('clothes', pp.clothesSkin && pp.clothesSkin.shapeId);
                    ctx.fillStyle = (by % 2 === 0 && (bx + by) % 2 === 0) ? c.hi : c.main;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                } else if (code === 10) {
                    var c = getSlotColors('cloak', pp.cloakSkin && pp.cloakSkin.shapeId);
                    ctx.fillStyle = (by % 2 === 0 && (bx + by) % 2 === 0) ? c.hi : c.main;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                } else if (code === 11) {
                    var c = getSlotColors('pants', pp.pantsSkin && pp.pantsSkin.shapeId);
                    ctx.fillStyle = (by % 2 === 0 && (bx + by) % 2 === 0) ? c.hi : c.main;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                } else if (code === 12) {
                    var c = getSlotColors('shoes', pp.shoesSkin && pp.shoesSkin.shapeId);
                    ctx.fillStyle = (by % 2 === 0 && (bx + by) % 2 === 0) ? c.hi : c.main;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                } else if (code === 7) {
                    ctx.fillStyle = charColors.body[0];
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                } else if (code === 3) {
                    ctx.fillStyle = charColors.eyeWhite;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                    ctx.fillStyle = charColors.eyePupil;
                    ctx.fillRect(ox + bx * cell + Math.floor(cell * 0.25), oy + by * cell + Math.floor(cell * 0.25), Math.max(1, Math.floor(cell * 0.5)), Math.max(1, Math.floor(cell * 0.5)));
                } else if (code === 4) {
                    ctx.fillStyle = charColors.eyeWhite;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                    ctx.fillStyle = charColors.eyePupil;
                    ctx.fillRect(ox + bx * cell + Math.floor(cell * 0.25), oy + by * cell + Math.floor(cell * 0.25), Math.max(1, Math.floor(cell * 0.5)), Math.max(1, Math.floor(cell * 0.5)));
                } else if (code === 5) {
                    ctx.fillStyle = charColors.nose;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                } else if (code === 6) {
                    ctx.fillStyle = charColors.mouth;
                    ctx.fillRect(ox + bx * cell, oy + by * cell, cell, cell);
                }
            }
        }
    }

    function equipPixelSkin(skin, inventoryIndex) {
        if (!player.pixelPlayer) player.pixelPlayer = { helmetSkin: null, clothesSkin: null, cloakSkin: null, pantsSkin: null, shoesSkin: null, weaponSkin: null, inventory: [] };
        var pp = player.pixelPlayer;
        var idx = inventoryIndex;
        if (idx < 0 || !pp.inventory[idx] || (skin.id && pp.inventory[idx].id !== skin.id)) {
            idx = -1;
            for (var i = 0; i < pp.inventory.length; i++) { if (pp.inventory[i] === skin || (skin.id && pp.inventory[i].id === skin.id)) { idx = i; break; } }
        }
        if (idx < 0) return;
        var slot = skin.type;
        var slotKey = slot + 'Skin';
        if (slot === 'char') slot = 'clothes';
        if (slotKey === 'charSkin') slotKey = 'clothesSkin';
        if (pp[slotKey]) pp.inventory.push(pp[slotKey]);
        pp[slotKey] = skin;
        pp.inventory.splice(idx, 1);
        updatePixelPlayerUI();
    }
    window.equipPixelSkin = equipPixelSkin;

    function discardPixelSkin(fromSlot, inventoryIndex) {
        if (!player.pixelPlayer) return;
        var pp = player.pixelPlayer;
        if (fromSlot === 'inventory' && inventoryIndex >= 0 && pp.inventory[inventoryIndex]) {
            if (pp.inventory[inventoryIndex].locked) return;
            pp.inventory.splice(inventoryIndex, 1);
        } else if (PIXEL_SLOTS.indexOf(fromSlot) >= 0 || fromSlot === 'weapon') {
            var key = fromSlot + 'Skin';
            if (pp[key]) pp[key] = null;
        } else if (fromSlot === 'char' && pp.characterSkin) {
            pp.characterSkin = null;
        }
        updatePixelPlayerUI();
    }
    window.discardPixelSkin = discardPixelSkin;

    function formatPixelSkinStats(skin) {
        if (!skin || !skin.stats) return '';
        var arr = [];
        if (skin.stats.attack) arr.push('攻击+' + skin.stats.attack + '%');
        if (skin.stats.health) arr.push('生命+' + skin.stats.health + '%');
        if (skin.stats.critRate) arr.push('暴击+' + skin.stats.critRate + '%');
        if (skin.stats.critDamage) arr.push('爆伤+' + skin.stats.critDamage + '%');
        return arr.join(' ');
    }

    function unequipPixelSkin(slot) {
        if (!player.pixelPlayer) return;
        var pp = player.pixelPlayer;
        var key = slot + 'Skin';
        if ((PIXEL_SLOTS.indexOf(slot) >= 0 || slot === 'weapon') && pp[key]) {
            pp.inventory.push(pp[key]);
            pp[key] = null;
        } else if (slot === 'char' && pp.characterSkin) {
            pp.inventory.push(pp.characterSkin);
            pp.characterSkin = null;
        }
        updatePixelPlayerUI();
    }
    window.unequipPixelSkin = unequipPixelSkin;
})();

function enableBeastDragAndDrop() {
    const container = document.getElementById('equippedBeastsList');
    if (!container) return;
    
    let draggedItem = null;
    
    container.querySelectorAll('.equipped-beast-card').forEach(item => {
        item.setAttribute('draggable', 'true');
        
        item.addEventListener('dragstart', function(e) {
            draggedItem = this;
            setTimeout(() => {
                this.style.opacity = '0.4';
            }, 0);
        });
        
        item.addEventListener('dragend', function(e) {
            setTimeout(() => {
                this.style.opacity = '1';
                draggedItem = null;
            }, 0);
        });
        
        item.addEventListener('dragover', function(e) {
            e.preventDefault();
        });
        
        item.addEventListener('drop', function(e) {
            e.preventDefault();
            if (draggedItem !== this) {
                // 重新排序装备的神兽
                reorderEquippedBeasts(draggedItem, this);
            }
        });
    });
}

// 重新排序装备的神兽
function reorderEquippedBeasts(sourceElement, targetElement) {
    // 获取两个神兽的索引
    const sourceIndex = Array.from(sourceElement.parentNode.children).indexOf(sourceElement);
    const targetIndex = Array.from(targetElement.parentNode.children).indexOf(targetElement);
    
    if (sourceIndex < player.beasts.equipped.length && targetIndex < player.beasts.equipped.length) {
        // 交换数组中的位置
        const temp = player.beasts.equipped[sourceIndex];
        player.beasts.equipped[sourceIndex] = player.beasts.equipped[targetIndex];
        player.beasts.equipped[targetIndex] = temp;
        
        // 更新显示
        updateEquippedBeastsDisplay();
        updatePlayerBattleStats();
        logAction("已重新排序装备的神兽", "info");
    }
}
// 生成随机轮回神兽
function generateRandomBeast() {
    // 1. 随机确定S级别（根据概率）
    const sLevel = weightedRandomSelection(beastConfig.sLevelDropProbs);
    
    // 2. 随机确定品质（根据概率）
    const rarityWeights = {};
    Object.keys(beastConfig.rarities).forEach(r => {
        rarityWeights[r] = beastConfig.rarities[r].dropWeight;
    });
    const rarity = weightedRandomSelection(rarityWeights);
    
    // 3. 随机确定词条数量（根据概率）
    const affixCount = weightedRandomSelection(beastConfig.affixCountProbs);
    
    // 4. 生成词条（可以重复）
    const affixes = [];
    for (let i = 0; i < affixCount; i++) {
        const affixType = beastConfig.affixTypes[Math.floor(Math.random() * beastConfig.affixTypes.length)];
        // 计算该词条的加成数值（基于S级别范围和品质倍率）
        const sConfig = beastConfig.sLevels[sLevel];
        const baseMultiplier = Math.random() * (sConfig.multiplierRange[1] - sConfig.multiplierRange[0]) + sConfig.multiplierRange[0];
        const rarityMultiplier = beastConfig.rarities[rarity].effectMultiplier;
        const finalMultiplier = baseMultiplier * rarityMultiplier;
        
        affixes.push({
            type: affixType,
            value: finalMultiplier
        });
    }
    
    // 5. 生成神兽名字和背景故事
   const name = generateBeastName(rarity);
    const lore = generateBeastLore(rarity, name);
    // 6. 创建神兽对象
    const beast = {
        id: 'beast_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: name,
        sLevel: sLevel,
        rarity: rarity,
        chineseName: beastConfig.rarities[rarity].chineseName, // 添加中文名
        description: beastConfig.rarities[rarity].description, // 添加品质描述
        affixes: affixes,
        requiredAscention: beastConfig.sLevels[sLevel].requiredAscention,
        lore: lore,
        owner: player.name, // 掉落者的玩家名字
        dropTime: new Date().toLocaleString('zh-CN'),
        isLocked: false, // 是否锁定
        exportCode: null, // 兑换码
        codeExpiry: null // 兑换码过期时间
    };
    
    return beast;
}

// 生成指定S级别的轮回神兽（用于轮回试炼副本等）
function generateBeastWithSLevel(sLevel) {
    const rarityWeights = {};
    Object.keys(beastConfig.rarities).forEach(r => {
        rarityWeights[r] = beastConfig.rarities[r].dropWeight;
    });
    const rarity = weightedRandomSelection(rarityWeights);
    const affixCount = weightedRandomSelection(beastConfig.affixCountProbs);
    const affixes = [];
    for (let i = 0; i < affixCount; i++) {
        const affixType = beastConfig.affixTypes[Math.floor(Math.random() * beastConfig.affixTypes.length)];
        const sConfig = beastConfig.sLevels[sLevel];
        const baseMultiplier = Math.random() * (sConfig.multiplierRange[1] - sConfig.multiplierRange[0]) + sConfig.multiplierRange[0];
        const rarityMultiplier = beastConfig.rarities[rarity].effectMultiplier;
        affixes.push({ type: affixType, value: baseMultiplier * rarityMultiplier });
    }
    const name = generateBeastName(rarity);
    const lore = generateBeastLore(rarity, name);
    return {
        id: 'beast_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: name,
        sLevel: sLevel,
        rarity: rarity,
        chineseName: beastConfig.rarities[rarity].chineseName,
        description: beastConfig.rarities[rarity].description,
        affixes: affixes,
        requiredAscention: beastConfig.sLevels[sLevel].requiredAscention,
        lore: lore,
        owner: player.name,
        dropTime: new Date().toLocaleString('zh-CN'),
        isLocked: false,
        exportCode: null,
        codeExpiry: null
    };
}

function generateS1Beast() {
    return generateBeastWithSLevel('S1');
}

function generateS2Beast() {
    return generateBeastWithSLevel('S2');
}

// 生成神兽名字
function generateBeastName(rarity) {
    const nameParts = beastNameParts[rarity];
    if (!nameParts) {
        // 备用方案
        const prefix = ['未知'][Math.floor(Math.random() * 1)];
        const suffix = ['兽'][Math.floor(Math.random() * 1)];
        return prefix + suffix;
    }
    
    const prefix = nameParts.prefixes[Math.floor(Math.random() * nameParts.prefixes.length)];
    const suffix = nameParts.suffixes[Math.floor(Math.random() * nameParts.suffixes.length)];
    
    // 炁兽特殊命名规则
    if (rarity === '炁兽') {
        return prefix + suffix; // 例如：太初炁、鸿蒙道
    }
    
    return prefix + suffix;
}


// 生成神兽背景故事
function generateBeastLore(rarity, beastName) {
    const templates = beastLoreTemplates[rarity];
    
    // 如果没有对应的模板，使用通用模板
    if (!templates) {
        return `这是一只神秘的${rarity}，关于它的信息甚少。`;
    }
    
    // 圣兽和神兽有固定的背景故事
    if ((rarity === '圣兽' || rarity === '神兽') && typeof templates === 'object') {
        // 检查是否有这个特定神兽的背景故事
        for (const [key, lore] of Object.entries(templates)) {
            if (beastName.includes(key)) {
                return lore;
            }
        }
        // 如果没有找到对应的，使用随机一个
        const keys = Object.keys(templates);
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        return templates[randomKey];
    }
    
    // 小宠物、野兽、凶兽、灵兽、炁兽使用模板
    if (Array.isArray(templates)) {
        const template = templates[Math.floor(Math.random() * templates.length)];
        
        // 根据品质选择不同的元素填充
        switch(rarity) {
            case '小宠物':
                return template
                    .replace('{0}', randomElement(['小兔', '猫咪', '小狗', '仓鼠', '小鸟']))
                    .replace('{1}', randomElement(beastLoreElements.小宠物特征));
                    
            case '野兽':
                return template
                    .replace('{0}', randomElement(['东部森林', '西部草原', '南部丘陵', '北部雪原']))
                    .replace('{1}', randomElement(beastLoreElements.野兽能力))
                    .replace('{2}', randomElement(['十年之久', '数代传承', '族群领袖']));
                    
            case '凶兽':
                return template
                    .replace('{0}', randomElement(['修士', '凡人', '牲畜', '妖兽']))
                    .replace('{1}', randomElement(['饕餮后裔', '混沌子嗣', '上古凶兽']))
                    .replace('{2}', randomElement(['尸横遍野', '生灵涂炭', '天地变色']));
                    
            case '灵兽':
                return template
                    .replace('{0}', randomElement(['自然', '灵气', '星辰', '月华']))
                    .replace('{1}', randomElement(['灵鹿', '仙鹤', '云鹏', '雷蛟']))
                    .replace('{2}', randomElement(['沟通天地', '点化草木', '净化污秽']));
                    
            case '炁兽':
                return template
                    .replace('{0}', randomElement(beastLoreElements.炁兽本质))
                    .replace('{1}', randomElement(['存在', '概念', '规则', '真理']))
                    .replace('{2}', randomElement(['大道', '法则', '本源', '初始']));
                    
            default:
                return template;
        }
    }
    
    return `关于这只${rarity}的来历，无人知晓。`;
}
function randomElement(array) {
    return array[Math.floor(Math.random() * array.length)];
}
// 加权随机选择函数
function weightedRandomSelection(weightedMap) {
    const totalWeight = Object.values(weightedMap).reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const [key, weight] of Object.entries(weightedMap)) {
        random -= weight;
        if (random <= 0) {
            return key;
        }
    }
    return Object.keys(weightedMap)[0]; // 备用
}

// 更新神兽界面
function updateBeastUI() {
    // 更新玩家信息
    document.getElementById('currentAscentionCounta').textContent = player.level.ascentionCounta;
    
    // 计算可装备的最高S级别
    let maxSLevel = 'S1';
    for (const [sLevel, config] of Object.entries(beastConfig.sLevels)) {
        if (player.level.ascentionCounta >= config.requiredAscention) {
            maxSLevel = sLevel;
        }
    }
    document.getElementById('maxEquipSLevel').textContent = maxSLevel;
    const beastEggs = player.items.shenshou1 || 0;
    document.getElementById('globalBeastEggCount').textContent = beastEggs;
    // 更新总属性显示
     const totalBonus = calculateEquippedBeastBonus();
    const shareLevel = player.beasts.shareLevel.level || 0;
    const shareBonusPercent = (shareLevel * 2).toFixed(1);
    
    document.getElementById('totalBeastBonus').innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
            <div style="text-align: center;">
                <div style="color: #aaa; font-size: 0.8em;">生命加成</div>
                <div style="color: #4CAF50; font-size: 1.1em;">+${((totalBonus.health - 1) * 100).toFixed(1)}%</div>
            </div>
            <div style="text-align: center;">
                <div style="color: #aaa; font-size: 0.8em;">攻击加成</div>
                <div style="color: #4CAF50; font-size: 1.1em;">+${((totalBonus.attack - 1) * 100).toFixed(1)}%</div>
            </div>
            <div style="text-align: center;">
                <div style="color: #aaa; font-size: 0.8em;">爆伤加成</div>
                <div style="color: #4CAF50; font-size: 1.1em;">+${((totalBonus.critDamage - 1) * 100).toFixed(1)}%</div>
            </div>
         <div style="text-align: center;">
                <div style="color: #aaa; font-size: 0.8em;">共享等级</div>
                <div style="color: #FFD700; font-size: 1.1em;">Lv.${shareLevel}</div>
                <div style="color: #4CAF50; font-size: 0.8em;">+${shareBonusPercent}%</div>
            </div>
          <div style="text-align: center;">
                <div style="color: #aaa; font-size: 0.8em;">已装备</div>
                <div style="color: #8A2BE2; font-size: 1.1em;">${player.beasts.equipped.length}/${getMaxBeastSlots()}</div>
            </div>
            
        </div>
    `;
    
    // 更新已装备神兽显示
    updateEquippedBeastsDisplay();
    
    // 更新神兽仓库显示
    updateBeastInventory();
}

// 更新神兽仓库显示
function updateBeastInventory() {
    const container = document.getElementById('beastInventory');
    if (!container) return;
    
    container.innerHTML = '';
    
    // 获取所有筛选条件
    const sLevelFilter = document.getElementById('beastSLevelFilter').value;
    const rarityFilter = document.getElementById('beastRarityFilter').value;
    const equipFilter = document.getElementById('beastEquipFilter').value;
    
    // 筛选神兽
    let filteredBeasts = [...player.beasts.inventory];
    
    // S级别筛选
    if (sLevelFilter !== 'all') {
        filteredBeasts = filteredBeasts.filter(beast => beast.sLevel === sLevelFilter);
    }
    
    // 品质筛选
    if (rarityFilter !== 'all') {
        filteredBeasts = filteredBeasts.filter(beast => beast.rarity === rarityFilter);
    }
    
    // 装备状态筛选
    if (equipFilter !== 'all') {
        filteredBeasts = filteredBeasts.filter(beast => {
            const isEquipped = player.beasts.equipped.includes(beast.id);
            const canEquip = player.level.ascentionCounta >= beast.requiredAscention;
            
            switch(equipFilter) {
                case 'equipped':
                    return isEquipped;
                case 'unequipped':
                    return !isEquipped;
                case 'equippable':
                    return !isEquipped && canEquip;
                case 'unequippable':
                    return !isEquipped && !canEquip;
                default:
                    return true;
            }
        });
    }
    
    // 可选：按装备状态排序（已装备的排前面）
    filteredBeasts.sort((a, b) => {
        const aEquipped = player.beasts.equipped.includes(a.id);
        const bEquipped = player.beasts.equipped.includes(b.id);
        
        if (aEquipped && !bEquipped) return -1;
        if (!aEquipped && bEquipped) return 1;
        return 0;
    });
    
    if (filteredBeasts.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; color: #888; grid-column: 1 / -1; padding: 40px 20px;">
                <div style="font-size: 3em; margin-bottom: 10px; opacity: 0.3;">🔍</div>
                <div style="font-size: 1.1em; margin-bottom: 5px;">未找到符合条件的神兽</div>
                <div style="font-size: 0.9em; color: #666;">
                    当前筛选条件：${getFilterDescription(sLevelFilter, rarityFilter, equipFilter)}
                </div>
                <button onclick="resetAllFilters()" style="margin-top: 15px; background: #8A2BE2; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                    重置所有筛选
                </button>
            </div>
        `;
        return;
    }
    
    // 显示神兽数量统计
    const equippedCount = filteredBeasts.filter(b => player.beasts.equipped.includes(b.id)).length;
    const unequippedCount = filteredBeasts.length - equippedCount;
    
    if (equippedCount > 0) {
        container.innerHTML += `
            <div style="grid-column: 1 / -1; margin-bottom: 10px; padding: 8px 12px; background: rgba(76, 175, 80, 0.1); border-left: 3px solid #4CAF50; border-radius: 4px;">
                <span style="color: #4CAF50; font-weight: bold;">⚡ 已装备 (${equippedCount})</span>
            </div>
        `;
    }
    
    // 显示神兽卡片
    let currentSection = 'equipped';
    filteredBeasts.forEach(beast => {
        const isEquipped = player.beasts.equipped.includes(beast.id);
        
        // 在已装备和未装备之间添加分隔线
        if (!isEquipped && currentSection === 'equipped' && equippedCount > 0) {
            container.innerHTML += `
                <div style="grid-column: 1 / -1; margin: 15px 0; border-top: 1px solid #444; position: relative;">
                    <div style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: #1a1a1a; padding: 0 15px; color: #888; font-size: 0.9em;">
                        未装备 (${unequippedCount})
                    </div>
                </div>
            `;
            currentSection = 'unequipped';
        }
        
        const beastElement = createBeastCard(beast);
        container.appendChild(beastElement);
    });
}
function getFilterDescription(sLevelFilter, rarityFilter, equipFilter) {
    const descriptions = [];
    
    if (sLevelFilter !== 'all') descriptions.push(`S${sLevelFilter.slice(1)}`);
    if (rarityFilter !== 'all') descriptions.push(rarityFilter);
    if (equipFilter !== 'all') {
        const equipNames = {
            'equipped': '已装备',
            'unequipped': '未装备',
            'equippable': '可装备',
            'unequippable': '未达标'
        };
        descriptions.push(equipNames[equipFilter] || equipFilter);
    }
    
    return descriptions.length > 0 ? descriptions.join(' · ') : '无筛选条件';
}

// 重置所有筛选
function resetAllFilters() {
    document.getElementById('beastSLevelFilter').value = 'all';
    document.getElementById('beastRarityFilter').value = 'all';
    document.getElementById('beastEquipFilter').value = 'all';
    filterBeasts();
    logAction("已重置所有筛选条件", "info");
}

// 快速筛选函数
function quickFilterEquipped() {
    document.getElementById('beastEquipFilter').value = 'equipped';
    filterBeasts();
}

function quickFilterUnequipped() {
    document.getElementById('beastEquipFilter').value = 'unequipped';
    filterBeasts();
}

function quickFilterEquippable() {
    document.getElementById('beastEquipFilter').value = 'equippable';
    filterBeasts();
}
// 创建神兽卡片
function createBeastCard(beast) {
    const div = document.createElement('div');
    div.className = 'beast-card';
    div.setAttribute('data-rarity', beast.rarity); // 添加品质属性用于CSS样式
    
    // 检查是否可装备
    const isEquipped = player.beasts.equipped.includes(beast.id);
    const canEquip = player.level.ascentionCounta >= beast.requiredAscention;
    
    // 装备状态显示
    const equipStatus = isEquipped ? 
        '<span style="color: #4CAF50;">✓ 已装备</span>' :
        (canEquip ? 
            '<span style="color: #2196F3;">可装备</span>' : 
            `<span style="color: #FF9800;">需轮回${beast.requiredAscention}转</span>`);
    
    // 品质标签
    const rarityTag = `${beastConfig.rarities[beast.rarity].chineseName || beast.rarity}`;
    
    div.style.cssText = `
        border-radius: 8px;
        padding: 12px;
        border-left: 4px solid ${beastConfig.rarities[beast.rarity].color};
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        position: relative;
        overflow: hidden;
        ${beast.isLocked ? 'border: 2px solid gold; box-shadow: 0 0 10px gold;' : ''}
    `;
    div.onmouseenter = () => {
        div.style.transform = 'translateY(-4px)';
        div.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
    };
    div.onmouseleave = () => {
        div.style.transform = 'translateY(0)';
        div.style.boxShadow = 'none';
    };
    
    div.onclick = (e) => {
    // 如果点击的不是按钮，可以选择是否触发快速预览
    if (!e.target.closest('button')) {
        // 可以添加快速预览功能，或者留空
        // 例如：highlightBeast(beast.id);
    }
};
    
    div.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <div style="color: ${beastConfig.rarities[beast.rarity].color}; font-weight: bold; font-size: 1.1em;">
            ${beast.name} ${isEquipped ? '⚡' : ''}
        </div>
        <div style="font-size: 0.9em; background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 10px;">
            ${beast.sLevel}
        </div>
    </div>
    <div style="font-size: 0.85em; color: #aaa; margin-bottom: 5px;">
        ${rarityTag} · ${beast.description || ''}
    </div>
    <div style="font-size: 0.8em; color: #4CAF50; margin-bottom: 8px;">
        ${equipStatus}
    </div>
    <div style="margin-top: 8px; font-size: 0.85em;">
        ${beast.affixes.map(affix => 
            `<div style="margin-bottom: 3px;">
                <span style="color: #FFD700;">${affix.type}:</span> 
                <span style="color: #4CAF50;">+${(affix.value * 100).toFixed(1)}%</span>
            </div>`
        ).join('')}
    </div>
    <div style="font-size: 0.75em; color: #888; margin-top: 8px; border-top: 1px solid #444; padding-top: 8px;">
        <div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
            来自: ${beast.owner || '未知'}
        </div>
        <div>${beast.dropTime || '未知时间'}</div>
    </div>
    <div style="margin-top: 10px; display: flex; gap: 5px;">
        <button onclick="toggleEquipBeast('${beast.id}', true)" 
                style="${isEquipped ? 'background: #f44336;' : 'background: #4CAF50;'} 
                       color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; flex: 1;">
            ${isEquipped ? '卸下' : '装备'}
        </button>
        <button onclick="openBeastActionModal('${beast.id}')" 
                style="background: #2196F3; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; flex: 1;">
            详细
        </button>
    </div>
`;
    
    return div;
}

// 选择神兽
function openBeastActionModal(beastId) {
    player.beasts.selectedId = beastId;
    
    const modal = document.getElementById('beastActionModal');
    const overlay = document.getElementById('beastActionOverlay');
    
    // 填充神兽信息
    updateSelectedBeastInfo();
    
    // 显示共享升级界面
    document.getElementById('shareUpgradeSection').style.display = 'block';
    updateShareUpgradeUI();
    
    modal.style.display = 'block';
    overlay.style.display = 'block';
}

// 关闭神兽操作弹窗
function closeBeastActionModal() {
    const modal = document.getElementById('beastActionModal');
    const overlay = document.getElementById('beastActionOverlay');
    
    modal.style.display = 'none';
    overlay.style.display = 'none';
    player.beasts.selectedId = null; // 清空选择
    document.getElementById('exportCodeSection').style.display = 'none'; // 隐藏兑换码区域
}

// 更新选中神兽的信息显示
function updateSelectedBeastInfo() {
    if (!player.beasts.selectedId) return;
    
    const beast = player.beasts.inventory.find(b => b.id === player.beasts.selectedId);
    if (!beast) return;
    
    const rarityColor = beastConfig.rarities[beast.rarity].color;
    const rarityName = beastConfig.rarities[beast.rarity].chineseName;
    const isEquipped = player.beasts.equipped.includes(beast.id);
    
    // 生成词条详细显示
    const affixDetails = beast.affixes.map((affix, index) => {
        return `
            <div style="padding: 8px; margin: 5px 0; background: rgba(0,0,0,0.3); border-radius: 4px;">
                <div>
                    <span style="color: #FFD700;">词条${index + 1}: ${affix.type}</span>
                    <span style="color: #4CAF50; float: right;">+${(affix.value * 100).toFixed(1)}%</span>
                </div>
            </div>
        `;
    }).join('');
    
    // 计算总加成
    const totalBonus = {
        '生命加成': 0,
        '攻击加成': 0,
        '爆伤加成': 0
    };
    beast.affixes.forEach(affix => {
        totalBonus[affix.type] += affix.value;
    });
    
    document.getElementById('selectedBeastInfo').innerHTML = `
        <div style="border-left: 4px solid ${rarityColor}; padding-left: 15px; margin-bottom: 15px;">
            <h3 style="color: ${rarityColor}; margin: 0 0 5px 0;">
                ${beast.name} 
                <span style="font-size: 0.8em; color: #aaa;">[${rarityName}·${beast.sLevel}]</span>
                ${isEquipped ? '<span style="color: #4CAF50; font-size: 0.8em;">⚡ 已装备</span>' : ''}
            </h3>
            <div style="color: #aaa; font-size: 0.9em; margin-bottom: 5px;">
                ${beast.description || '暂无描述'} · 需轮回${beast.requiredAscention}转
            </div>
        </div>
        
        <div style="background: rgba(255,215,0,0.1); padding: 15px; border-radius: 5px; margin: 15px 0;">
            <div style="color: #FFD700; font-size: 0.9em; margin-bottom: 8px;">📖 神兽传说</div>
            <div style="color: #aaa; font-style: italic;">${beast.lore || '暂无背景故事'}</div>
        </div>
        
        <div style="margin: 15px 0;">
            <div style="color: #4CAF50; font-size: 0.9em; margin-bottom: 8px;">⚡ 词条属性</div>
            ${affixDetails || '<div style="color: #888; text-align: center;">无词条</div>'}
        </div>
        
        <div style="background: rgba(138, 43, 226, 0.1); padding: 15px; border-radius: 5px; margin: 15px 0;">
            <div style="color: #8A2BE2; font-size: 0.9em; margin-bottom: 8px;">📈 总加成效果</div>
            <div style="display: flex; justify-content: space-around; margin-top: 8px;">
                ${totalBonus['生命加成'] > 0 ? `<div style="text-align: center;"><div style="color: #aaa; font-size: 0.8em;">生命</div><div style="color: #4CAF50; font-size: 1.2em;">+${(totalBonus['生命加成'] * 100).toFixed(1)}%</div></div>` : ''}
                ${totalBonus['攻击加成'] > 0 ? `<div style="text-align: center;"><div style="color: #aaa; font-size: 0.8em;">攻击</div><div style="color: #4CAF50; font-size: 1.2em;">+${(totalBonus['攻击加成'] * 100).toFixed(1)}%</div></div>` : ''}
                ${totalBonus['爆伤加成'] > 0 ? `<div style="text-align: center;"><div style="color: #aaa; font-size: 0.8em;">爆伤</div><div style="color: #4CAF50; font-size: 1.2em;">+${(totalBonus['爆伤加成'] * 100).toFixed(1)}%</div></div>` : ''}
            </div>
        </div>
        
        <div style="font-size: 0.85em; color: #888; border-top: 1px solid #444; padding-top: 15px;">
        <div><span style="color: #aaa;">🏷️ 原始掉落者:</span> ${beast.owner || '未知'}</div>
        <div><span style="color: #aaa;">📅 原始掉落时间:</span> ${beast.dropTime || '未知时间'}</div>
        <div><span style="color: #aaa;">🆔 神兽ID:</span> <span style="font-family: monospace; font-size: 0.8em;">${beast.id}</span></div>
        ${beast.isLocked ? '<div style="color: gold; margin-top: 5px;">🔒 已锁定（无法丢弃）</div>' : ''}
    </div>
`;
    
    // 更新按钮状态
    const lockBtn = document.getElementById('btnLockUnlock');
    lockBtn.textContent = beast.isLocked ? '🔓 解锁' : '🔒 锁定';
    lockBtn.style.background = beast.isLocked ? '#FF9800' : '#4CAF50';
    
    // 更新丢弃按钮状态
    const discardBtn = document.getElementById('btnDiscard');
    discardBtn.disabled = beast.isLocked;
    discardBtn.style.opacity = beast.isLocked ? 0.5 : 1;
    discardBtn.style.cursor = beast.isLocked ? 'not-allowed' : 'pointer';
}

// 更新已装备神兽显示
function updateEquippedBeastsDisplay() {
    const container = document.getElementById('equippedBeastsList');
    const equippedSection = document.getElementById('equippedBeastsSection');
    
    if (!container || !equippedSection) return;
    
    // 更新槽位数量显示
    const maxSlots = getMaxBeastSlots();
    const currentCount = player.beasts.equipped.length;
    
    // 更新标题中的数量
    const titleElement = equippedSection.querySelector('h4');
    if (titleElement) {
        const countSpan = titleElement.querySelector('span:last-child') || 
                         (() => {
                             const span = document.createElement('span');
                             span.style.cssText = 'font-size: 0.8em; background: #8A2BE2; color: white; padding: 2px 8px; border-radius: 10px;';
                             titleElement.appendChild(span);
                             return span;
                         })();
        countSpan.textContent = `${currentCount}/${maxSlots}`;
    }
    
    container.innerHTML = '';
    
    // 显示所有槽位，包括空槽位
    for (let i = 0; i < maxSlots; i++) {
        const slotElement = document.createElement('div');
        
        if (i < player.beasts.equipped.length) {
            // 有神兽的槽位
            const beastId = player.beasts.equipped[i];
            const beast = player.beasts.inventory.find(b => b.id === beastId);
            
            if (beast) {
                const rarityColor = beastConfig.rarities[beast.rarity].color;
                const rarityName = beastConfig.rarities[beast.rarity].chineseName;
                
                // 计算总加成
                const totalBonus = {
                    '生命加成': 0,
                    '攻击加成': 0,
                    '爆伤加成': 0
                };
                beast.affixes.forEach(affix => {
                    totalBonus[affix.type] += affix.value;
                });
                
                slotElement.className = 'equipped-beast-card';
                slotElement.style.borderLeftColor = rarityColor;
                slotElement.innerHTML = `
                    <div class="beast-slots">#${i + 1}</div>
                    <div class="beast-name">
                        <span style="color: ${rarityColor};">${beast.name}</span>
                        <span class="beast-rarity" style="color: ${rarityColor};">${beast.sLevel}</span>
                    </div>
                    <div style="font-size: 0.8em; color: #aaa; margin-bottom: 5px;">
                        ${rarityName}
                    </div>
                    <div class="beast-stats">
                        ${totalBonus['生命加成'] > 0 ? `<div style="margin-bottom: 2px;">生命: +${(totalBonus['生命加成'] * 100).toFixed(1)}%</div>` : ''}
                        ${totalBonus['攻击加成'] > 0 ? `<div style="margin-bottom: 2px;">攻击: +${(totalBonus['攻击加成'] * 100).toFixed(1)}%</div>` : ''}
                        ${totalBonus['爆伤加成'] > 0 ? `<div>爆伤: +${(totalBonus['爆伤加成'] * 100).toFixed(1)}%</div>` : ''}
                    </div>
                `;
                
                slotElement.onclick = (e) => {
                    e.stopPropagation();
                    openBeastActionModal(beast.id);
                };
            }
        } else {
            // 空槽位
            slotElement.className = 'equipped-slot-empty';
            slotElement.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 1.5em; margin-bottom: 5px; opacity: 0.5;">⚡</div>
                    <div>槽位 ${i + 1}</div>
                    <div style="font-size: 0.8em; color: #666;">未装备</div>
                </div>
            `;
            
            // 点击空槽位可以快速装备筛选中的神兽（可选功能）
            slotElement.onclick = (e) => {
                e.stopPropagation();
                // 可以在这里添加快速装备功能
                // quickEquipToSlot(i);
            };
        }
        
        container.appendChild(slotElement);
    }
    
    // 如果没有已装备的神兽，显示提示
    if (currentCount === 0) {
        container.innerHTML = `
            <div style="text-align: center; color: #888; width: 100%; padding: 20px; grid-column: 1 / -1;">
                <div style="font-size: 2em; margin-bottom: 10px; opacity: 0.3;">⚡</div>
                <div>当前没有已装备的神兽</div>
                <div style="font-size: 0.9em; color: #666; margin-top: 5px;">点击仓库中的神兽进行装备</div>
            </div>
        `;
    }
}

// 可选：快速装备到指定槽位
function quickEquipToSlot(slotIndex) {
    // 获取当前筛选的神兽列表
    const sLevelFilter = document.getElementById('beastSLevelFilter').value;
    const rarityFilter = document.getElementById('beastRarityFilter').value;
    
    let filteredBeasts = player.beasts.inventory.filter(beast => {
        const matchSLevel = sLevelFilter === 'all' || beast.sLevel === sLevelFilter;
        const matchRarity = rarityFilter === 'all' || beast.rarity === rarityFilter;
        const isEquipped = player.beasts.equipped.includes(beast.id);
        const canEquip = player.level.ascentionCounta >= beast.requiredAscention;
        
        return matchSLevel && matchRarity && !isEquipped && canEquip;
    });
    
    if (filteredBeasts.length === 0) {
        logAction("没有可装备的筛选神兽", "warning");
        return;
    }
    
    // 选择第一个可装备的神兽
    const beastToEquip = filteredBeasts[0];
    
    // 如果槽位已满，替换该槽位的神兽
    if (slotIndex < player.beasts.equipped.length) {
        const oldBeastId = player.beasts.equipped[slotIndex];
        const oldBeast = player.beasts.inventory.find(b => b.id === oldBeastId);
        
        if (oldBeast) {
            player.beasts.equipped[slotIndex] = beastToEquip.id;
            logAction(`已将【${oldBeast.name}】替换为【${beastToEquip.name}】`, "success");
        }
    } else {
        // 装备到空槽位
        player.beasts.equipped.push(beastToEquip.id);
        logAction(`已装备【${beastToEquip.name}】到槽位${slotIndex + 1}`, "success");
    }
    
    updateBeastUI();
    updateEquippedBeastsDisplay();
    updatePlayerBattleStats();
}


function toggleEquipBeast(beastId, autoUnequip = false, event) {
    if (event) {
        event.stopPropagation();
    }
    
    const beast = player.beasts.inventory.find(b => b.id === beastId);
    if (!beast) return;
    
    // 检查是否可装备
    if (player.level.ascentionCounta < beast.requiredAscention) {
        logAction(`装备需要轮回${beast.requiredAscention}转！当前轮回${player.level.ascentionCounta}转`, "error");
        return;
    }
    
    const isEquipped = player.beasts.equipped.includes(beastId);
    
    if (isEquipped) {
        // 卸下
        player.beasts.equipped = player.beasts.equipped.filter(id => id !== beastId);
        logAction(`已卸下神兽：${beast.name}`, "info");
    } else {
        // 检查装备槽位限制
        const maxSlots = getMaxBeastSlots();
        
        // 如果槽位已满，根据参数决定是否自动卸下
        if (player.beasts.equipped.length >= maxSlots) {
            if (autoUnequip) {
                // 自动卸下第一个已装备的神兽
                const firstEquippedId = player.beasts.equipped[0];
                const firstBeast = player.beasts.inventory.find(b => b.id === firstEquippedId);
                if (firstBeast) {
                    player.beasts.equipped = player.beasts.equipped.filter(id => id !== firstEquippedId);
                    logAction(`自动卸下神兽：${firstBeast.name}`, "info");
                }
            } else {
                logAction(`装备槽位已满（最大${maxSlots}个），请先卸下其他神兽`, "error");
                return;
            }
        }
        
        // 装备新神兽
        player.beasts.equipped.push(beastId);
        logAction(`已装备神兽：${beast.name}`, "success");
    }
    
    updateBeastUI();
    updateEquippedBeastsDisplay(); // 更新已装备显示
    updatePlayerBattleStats();
  // 如果当前筛选的是已装备/未装备状态，更新显示
    const currentEquipFilter = document.getElementById('beastEquipFilter').value;
    if (currentEquipFilter === 'equipped' || currentEquipFilter === 'unequipped' || 
        currentEquipFilter === 'equippable' || currentEquipFilter === 'unequippable') {
        filterBeasts();
    }
}

// 获取最大装备槽位
function getMaxBeastSlots() {
    return Math.min(6, 1 + Math.floor(player.level.ascentionCounta / 5));
}
// 锁定/解锁神兽
function toggleLockBeast() {
    if (!player.beasts.selectedId) return;
    
    const beast = player.beasts.inventory.find(b => b.id === player.beasts.selectedId);
    if (beast) {
        beast.isLocked = !beast.isLocked;
        logAction(`已${beast.isLocked ? '锁定' : '解锁'}神兽：${beast.name}`, 'info');
        updateSelectedBeastInfo(); // 更新弹窗内的信息
        updateBeastUI(); // 更新主界面的神兽卡片
    }
}


// 生成神兽兑换码
function exportBeastCode() {
    if (!player.beasts.selectedId) return;
    
    const beast = player.beasts.inventory.find(b => b.id === player.beasts.selectedId);
    if (beast) {
        // 创建包含完整神兽信息的对象（包括原始ID和所有信息）
        const codeData = {
            version: 2, // 更新版本号
            beastData: {
                // 导出所有字段
                id: beast.id,
                name: beast.name,
                sLevel: beast.sLevel,
                rarity: beast.rarity,
                chineseName: beast.chineseName,
                description: beast.description,
                affixes: beast.affixes,
                requiredAscention: beast.requiredAscention,
                lore: beast.lore,
                owner: beast.owner, // 保留原始掉落者
                dropTime: beast.dropTime, // 保留原始掉落时间
                isLocked: beast.isLocked,
                exportCode: null, // 重置兑换码相关字段
                codeExpiry: null
            },
            generatedTime: Date.now(),
            expiresIn: 10 * 60 * 1000 // 10分钟
        };
        
        // 加密数据
        const encryptedCode = CryptoJS.AES.encrypt(JSON.stringify(codeData), ENCRYPTION_KEY).toString();
        
        // 存储到神兽对象中
        beast.exportCode = encryptedCode;
        beast.codeExpiry = Date.now() + (10 * 60 * 1000);
        
        // 显示兑换码
        const generatedTime = new Date(codeData.generatedTime);
        const expiryTime = new Date(codeData.generatedTime + codeData.expiresIn);
        
        document.getElementById('exportCodeSection').innerHTML = `
            <h4>兑换码分享</h4>
            <p style="color: #aaa; font-size: 0.9em;">
                ⏰ 生成时间: ${generatedTime.toLocaleString('zh-CN')}<br>
                ⏳ 过期时间: ${expiryTime.toLocaleString('zh-CN')}<br>
                🔑 有效期: 10分钟<br>
                👤 掉落者: ${beast.owner}<br>
                📅 掉落时间: ${beast.dropTime}
            </p>
            <p style="color: #FFD700; font-size: 0.9em;">请复制下方代码分享给其他玩家：</p>
            <textarea id="beastCodeOutput" readonly style="width: 100%; height: 60px; background: #333; color: #fff; border: 1px solid #555; padding: 10px; border-radius: 5px; font-family: monospace; margin-bottom: 10px;">${encryptedCode}</textarea>
            <button onclick="copyBeastCode()" style="background: #4CAF50; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; margin-right: 10px;">复制代码</button>
            <button onclick="shareBeastCode()" style="background: #2196F3; color: white; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer;">分享</button>
        `;
        document.getElementById('exportCodeSection').style.display = 'block';
        
        const remainingTime = formatRemainingTime(10 * 60);
        logAction(`已为【${beast.name}】生成兑换码，有效期：${remainingTime}`, 'success');
    }
}
function shareBeastCode() {
    const codeOutput = document.getElementById('beastCodeOutput');
    const code = codeOutput.value;
    
    if (!code) {
        logAction("没有可分享的兑换码", "error");
        return;
    }
    
    const beast = player.beasts.inventory.find(b => b.id === player.beasts.selectedId);
    if (beast) {
        // 解密兑换码以获取时间信息
        try {
            const decrypted = CryptoJS.AES.decrypt(code, ENCRYPTION_KEY);
            const codeData = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
            
            const expiryTime = new Date(codeData.generatedTime + codeData.expiresIn);
            const remainingSeconds = Math.floor((expiryTime - Date.now()) / 1000);
            const remainingTime = formatRemainingTime(remainingSeconds);
            
            const shareText = `分享神兽【${beast.name}（${beast.rarity}·${beast.sLevel}）】\n👤 掉落者：${beast.owner}\n📅 掉落时间：${beast.dropTime}\n⏳ 剩余时间：${remainingTime}\n\n兑换码：\n${code}\n\n有效期10分钟，请尽快兑换！`;
            
            if (navigator.share) {
                navigator.share({
                    title: `${beast.name} - 神兽兑换码`,
                    text: shareText,
                })
                .then(() => logAction("分享成功", "success"))
                .catch(err => {
                    copyBeastCode();
                    logAction("兑换码已复制，请手动分享", "success");
                });
            } else {
                copyBeastCode();
                logAction(`兑换码已复制，请手动分享\n${shareText}`, "success");
            }
        } catch (error) {
            copyBeastCode();
            logAction("兑换码已复制，请手动分享", "success");
        }
    }
}
// 格式化剩余时间
function formatRemainingTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}分${remainingSeconds}秒`;
}

// 兑换神兽码
function redeemBeastCode() {
    const codeInput = document.getElementById('beastCodeInput').value.trim();
    if (!codeInput) {
        logAction("请输入有效的兑换码", "error");
        return;
    }
    
    try {
        // 解密兑换码
        const decrypted = CryptoJS.AES.decrypt(codeInput, ENCRYPTION_KEY);
        const codeData = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
        
        // 检查版本
        if (!codeData.version || (codeData.version !== 1 && codeData.version !== 2)) {
            logAction("兑换码版本不兼容", "error");
            return;
        }
        
        // 检查是否过期
        const currentTime = Date.now();
        const expiryTime = codeData.generatedTime + codeData.expiresIn;
        
        if (currentTime > expiryTime) {
            const expiredMinutes = Math.floor((currentTime - expiryTime) / 1000 / 60);
            logAction(`兑换码已过期${expiredMinutes}分钟！`, "error");
            return;
        }
        
        // 检查是否已经拥有相同ID的神兽
        const existingBeast = player.beasts.inventory.find(b => b.id === codeData.beastData.id);
        if (existingBeast) {
            logAction("你已经拥有这个神兽了！", "error");
            return;
        }
        
        // 完全复制神兽数据（保留所有原始信息）
        let newBeast;
        if (codeData.version === 2) {
            // v2版本：直接使用原始数据
            newBeast = { ...codeData.beastData };
        } else {
            // v1版本兼容：保留原始数据，但需要处理缺失字段
            const originalBeastData = codeData.beastData;
            newBeast = {
                id: originalBeastData.id || 'beast_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                name: originalBeastData.name,
                sLevel: originalBeastData.sLevel,
                rarity: originalBeastData.rarity,
                chineseName: originalBeastData.chineseName,
                description: originalBeastData.description,
                affixes: originalBeastData.affixes,
                requiredAscention: originalBeastData.requiredAscention,
                lore: originalBeastData.lore,
                owner: originalBeastData.owner || '未知',
                dropTime: originalBeastData.dropTime || new Date().toLocaleString('zh-CN'),
                isLocked: false, // 新获得的设为未锁定
                exportCode: null,
                codeExpiry: null
            };
        }
        
        // 添加到仓库
        player.beasts.inventory.push(newBeast);
        
        // 清空输入框
        document.getElementById('beastCodeInput').value = '';
        
        // 计算剩余时间
        const remainingSeconds = Math.floor((expiryTime - currentTime) / 1000);
        const remainingTime = formatRemainingTime(remainingSeconds);
        
        logAction(`🎉 成功兑换神兽：${newBeast.name}（${newBeast.rarity}·${newBeast.sLevel}），剩余有效期：${remainingTime}`, 'legendary');
        
        // 显示详细信息
        logAction(`👤 掉落者：${newBeast.owner} | 📅 掉落时间：${newBeast.dropTime}`, 'info');
        
        updateBeastUI();
        
    } catch (error) {
        logAction("兑换码无效或已损坏", "error");
        console.error("兑换码解析错误:", error);
    }
}

// 其他辅助功能
function copyBeastCode() {
    const codeOutput = document.getElementById('beastCodeOutput');
    codeOutput.select();
    document.execCommand('copy');
    logAction("兑换码已复制到剪贴板", "success");
}
// 显示导入兑换码弹窗
function showImportCodeModal() {
    const modal = document.getElementById('importCodeModal');
    const overlay = document.getElementById('importCodeOverlay');
    const input = document.getElementById('importCodeInput');
    
    input.value = ''; // 清空输入框
    modal.style.display = 'block';
    overlay.style.display = 'block';
    input.focus(); // 自动聚焦
}

// 关闭导入兑换码弹窗
function closeImportCodeModal() {
    const modal = document.getElementById('importCodeModal');
    const overlay = document.getElementById('importCodeOverlay');
    
    modal.style.display = 'none';
    overlay.style.display = 'none';
}
function redeemBeastCodeFromImport() {
    const codeInput = document.getElementById('importCodeInput').value.trim();
    if (!codeInput) {
        logAction("请输入兑换码", "error");
        return;
    }
    
    try {
        // 解密兑换码
        const decrypted = CryptoJS.AES.decrypt(codeInput, ENCRYPTION_KEY);
        const codeData = JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
        
        // 检查版本
        if (!codeData.version || (codeData.version !== 1 && codeData.version !== 2)) {
            logAction("兑换码版本不兼容", "error");
            return;
        }
        
        // 检查是否过期
        const currentTime = Date.now();
        const expiryTime = codeData.generatedTime + codeData.expiresIn;
        
        if (currentTime > expiryTime) {
            const expiredMinutes = Math.floor((currentTime - expiryTime) / 1000 / 60);
            logAction(`兑换码已过期${expiredMinutes}分钟！`, "error");
            return;
        }
        
        // 检查是否已经拥有相同ID的神兽
        const existingBeast = player.beasts.inventory.find(b => b.id === codeData.beastData.id);
        if (existingBeast) {
            logAction("你已经拥有这个神兽了！", "error");
            return;
        }
        
        // 完全复制神兽数据（保留所有原始信息）
        let newBeast;
        if (codeData.version === 2) {
            // v2版本：直接使用原始数据
            newBeast = { ...codeData.beastData };
        } else {
            // v1版本兼容
            const originalBeastData = codeData.beastData;
            newBeast = {
                id: originalBeastData.id || 'beast_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                name: originalBeastData.name,
                sLevel: originalBeastData.sLevel,
                rarity: originalBeastData.rarity,
                chineseName: originalBeastData.chineseName,
                description: originalBeastData.description,
                affixes: originalBeastData.affixes,
                requiredAscention: originalBeastData.requiredAscention,
                lore: originalBeastData.lore,
                owner: originalBeastData.owner || '未知',
                dropTime: originalBeastData.dropTime || new Date().toLocaleString('zh-CN'),
                isLocked: false,
                exportCode: null,
                codeExpiry: null
            };
        }
        
        // 添加到仓库
        player.beasts.inventory.push(newBeast);
        
        // 关闭弹窗
        closeImportCodeModal();
        
        // 计算剩余时间
        const remainingSeconds = Math.floor((expiryTime - currentTime) / 1000);
        const remainingTime = formatRemainingTime(remainingSeconds);
        
        logAction(`🎉 成功导入神兽：${newBeast.name}（${newBeast.rarity}·${newBeast.sLevel}），剩余有效期：${remainingTime}`, 'legendary');
        logAction(`👤 掉落者：${newBeast.owner} | 📅 掉落时间：${newBeast.dropTime}`, 'info');
        
        updateBeastUI();
        
        // 自动选中新导入的神兽
        setTimeout(() => {
            openBeastActionModal(newBeast.id);
        }, 500);
        
    } catch (error) {
        logAction("兑换码无效或已损坏", "error");
        console.error("兑换码解析错误:", error);
    }
}
function discardBeast() {
    if (!player.beasts.selectedId) return;
    
    const beast = player.beasts.inventory.find(b => b.id === player.beasts.selectedId);
    if (!beast) return;
    
    const isEquipped = player.beasts.equipped.includes(beast.id);
    
    if (isEquipped) {
        logAction("无法丢弃已装备的神兽！请先卸下再尝试丢弃。", "error");
        return;
    }
    
    if (beast.isLocked) {
        logAction("请先解锁神兽再进行丢弃操作", "error");
        return;
    }
    
    if (confirm(`确定要丢弃神兽【${beast.name}】吗？此操作不可撤销！`)) {
        player.beasts.inventory = player.beasts.inventory.filter(b => b.id !== player.beasts.selectedId);
        
        logAction(`已丢弃神兽：${beast.name}`, 'warning');
        closeBeastActionModal(); // 关闭弹窗
        updateBeastUI(); // 更新主界面
    }
}

// 批量操作功能
function lockAllFilteredBeasts() {
    const sLevelFilter = document.getElementById('beastSLevelFilter').value;
    const rarityFilter = document.getElementById('beastRarityFilter').value;
    
    let count = 0;
    let equippedCount = 0;
    
    player.beasts.inventory.forEach(beast => {
        // 检查是否满足筛选条件
        const matchSLevel = sLevelFilter === 'all' || beast.sLevel === sLevelFilter;
        const matchRarity = rarityFilter === 'all' || beast.rarity === rarityFilter;
        const isEquipped = player.beasts.equipped.includes(beast.id);
        
        if (matchSLevel && matchRarity) {
            if (!beast.isLocked) {
                beast.isLocked = true;
                count++;
                if (isEquipped) {
                    equippedCount++;
                }
            }
        }
    });
    
    if (count > 0) {
        let message = `已锁定${count}个筛选神兽`;
        if (equippedCount > 0) {
            message += `（包含${equippedCount}个已装备的）`;
        }
        logAction(message, "success");
    } else {
        logAction("没有可锁定的筛选神兽", "info");
    }
    
    // 更新界面
    updateBeastInventory();
    
    // 如果当前选中的神兽在弹窗中，更新弹窗显示
    if (player.beasts.selectedId) {
        const selectedBeast = player.beasts.inventory.find(b => b.id === player.beasts.selectedId);
        if (selectedBeast) {
            updateSelectedBeastInfo();
        }
    }
}
function unlockAllFilteredBeasts() {
    const sLevelFilter = document.getElementById('beastSLevelFilter').value;
    const rarityFilter = document.getElementById('beastRarityFilter').value;
    
    let count = 0;
    let equippedCount = 0;
    
    player.beasts.inventory.forEach(beast => {
        // 检查是否满足筛选条件
        const matchSLevel = sLevelFilter === 'all' || beast.sLevel === sLevelFilter;
        const matchRarity = rarityFilter === 'all' || beast.rarity === rarityFilter;
        const isEquipped = player.beasts.equipped.includes(beast.id);
        
        if (matchSLevel && matchRarity) {
            if (beast.isLocked) {
                beast.isLocked = false;
                count++;
                if (isEquipped) {
                    equippedCount++;
                }
            }
        }
    });
    
    if (count > 0) {
        let message = `已解锁${count}个筛选神兽`;
        if (equippedCount > 0) {
            message += `（包含${equippedCount}个已装备的）`;
        }
        logAction(message, "success");
    } else {
        logAction("没有已锁定的筛选神兽", "info");
    }
    
    // 更新界面
    updateBeastInventory();
    
    // 如果当前选中的神兽在弹窗中，更新弹窗显示
    if (player.beasts.selectedId) {
        const selectedBeast = player.beasts.inventory.find(b => b.id === player.beasts.selectedId);
        if (selectedBeast) {
            updateSelectedBeastInfo();
        }
    }
}
function discardAllUnlockedFilteredBeasts() {
    const sLevelFilter = document.getElementById('beastSLevelFilter').value;
    const rarityFilter = document.getElementById('beastRarityFilter').value;
    
    // 先检查是否有符合条件的未锁定神兽
    let unlockedCount = 0;
    let equippedCount = 0;
    
    player.beasts.inventory.forEach(beast => {
        const matchSLevel = sLevelFilter === 'all' || beast.sLevel === sLevelFilter;
        const matchRarity = rarityFilter === 'all' || beast.rarity === rarityFilter;
        const isEquipped = player.beasts.equipped.includes(beast.id);
        
        if (matchSLevel && matchRarity && !beast.isLocked) {
            unlockedCount++;
            if (isEquipped) {
                equippedCount++;
            }
        }
    });
    
    if (unlockedCount === 0) {
        logAction("没有可丢弃的未锁定筛选神兽", "info");
        return;
    }
    
    // 显示确认信息，包含已装备的警告
    let confirmMessage = `确定要丢弃${unlockedCount}个未锁定的筛选神兽吗？`;
    
    if (equippedCount > 0) {
        confirmMessage = `警告：筛选结果中包含${equippedCount}个已装备的未锁定神兽！\n\n已装备的神兽不会被丢弃。\n\n确定要丢弃${unlockedCount - equippedCount}个未装备的未锁定神兽吗？`;
    }
    
    if (!confirm(confirmMessage)) return;
    
    let discardedCount = 0;
    
    // 创建新数组，只保留不符合丢弃条件的
    const newInventory = [];
    
    player.beasts.inventory.forEach(beast => {
        // 检查是否满足筛选条件
        const matchSLevel = sLevelFilter === 'all' || beast.sLevel === sLevelFilter;
        const matchRarity = rarityFilter === 'all' || beast.rarity === rarityFilter;
        const isEquipped = player.beasts.equipped.includes(beast.id);
        
        // 丢弃条件：筛选条件匹配 + 未锁定 + 未装备
        if (matchSLevel && matchRarity && !beast.isLocked && !isEquipped) {
            // 满足丢弃条件
            discardedCount++;
            // 注意：这里不需要从装备列表中移除，因为本身就不是装备状态
        } else {
            // 不满足丢弃条件，保留
            newInventory.push(beast);
        }
    });
    
    // 更新库存
    player.beasts.inventory = newInventory;
    
    // 如果当前选中的神兽被丢弃了，清空选择
    if (player.beasts.selectedId && !player.beasts.inventory.find(b => b.id === player.beasts.selectedId)) {
        player.beasts.selectedId = null;
        const actionModal = document.getElementById('beastActionModal');
        if (actionModal && actionModal.style.display === 'block') {
            closeBeastActionModal();
        }
    }
    
    let message = `已丢弃${discardedCount}个未锁定未装备的神兽`;
    if (equippedCount > 0) {
        message += `（已跳过${equippedCount}个已装备的未锁定神兽）`;
    }
    
    logAction(message, "warning");
    updateBeastUI();
}

// 筛选神兽
function filterBeasts() {
    updateBeastUI(); // 这会调用 updateBeastInventory() 来更新显示
}

// 计算神兽提供的总加成（在战斗属性计算中调用）
function calculateEquippedBeastBonus() {
    let totalBonus = {
        health: 1, // 生命加成
        attack: 1, // 攻击加成  
        critDamage: 1 // 爆伤加成
    };
    
    // 只计算已装备的神兽
    player.beasts.equipped.forEach(beastId => {
        const beast = player.beasts.inventory.find(b => b.id === beastId);
        if (beast && player.level.ascentionCounta >= beast.requiredAscention) {
            beast.affixes.forEach(affix => {
                const bonusType = getBonusType(affix.type);
                if (totalBonus[bonusType] !== undefined) {
                    totalBonus[bonusType] *= (1 + affix.value);
                }
            });
        }
    });
    
    // 应用共享等级加成
    const shareBonus = player.beasts.shareLevel.bonusMultiplier || 1;
    totalBonus.health *= shareBonus;
    totalBonus.attack *= shareBonus;
    totalBonus.critDamage *= shareBonus;
    
    return totalBonus;
}

// 辅助函数：词条类型映射
function getBonusType(chineseType) {
    const typeMap = {
        '生命加成': 'health',
        '攻击加成': 'attack', 
        '爆伤加成': 'critDamage'
    };
    return typeMap[chineseType] || 'health';
}
function getEggsRequiredForNextLevel(currentLevel) {
    // 每级基础消耗20个，每10级额外增加30个
    const baseCost = 20;
    const extraCost = Math.floor(currentLevel / 10) * 30;
    return baseCost + extraCost;
}

// 计算升级到指定等级所需的总神兽蛋
function getEggsRequiredForLevels(fromLevel, toLevel) {
    let totalEggs = 0;
    for (let level = fromLevel; level < toLevel; level++) {
        totalEggs += getEggsRequiredForNextLevel(level);
    }
    return totalEggs;
}

// 更新共享升级界面
function updateShareUpgradeUI() {
    const shareLevel = player.beasts.shareLevel.level;
    const beastEggs = player.items.shenshou1 || 0;
    
    // 更新显示
    document.getElementById('currentShareLevel').textContent = shareLevel;
    document.getElementById('currentBonusPercent').textContent = (shareLevel * 2).toFixed(1);
    document.getElementById('beastEggCount').textContent = beastEggs;
    
    // 计算下一级信息
    const eggsForNextLevel = getEggsRequiredForNextLevel(shareLevel);
    document.getElementById('nextLevelCost').textContent = eggsForNextLevel;
    
    // 更新进度条（基于当前拥有的蛋）
    const progressPercent = Math.min(100, (beastEggs / eggsForNextLevel) * 100);
    document.getElementById('upgradeProgressBar').style.width = `${progressPercent}%`;
    
    // 更新消耗显示
    document.getElementById('consumedEggs').textContent = Math.min(beastEggs, eggsForNextLevel);
    document.getElementById('totalEggsForNext').textContent = eggsForNextLevel;
    
    // 更新升级按钮状态
    const canUpgrade = beastEggs >= eggsForNextLevel;
    document.querySelectorAll('#shareUpgradeSection button').forEach(btn => {
        if (btn.onclick && btn.onclick.toString().includes('upgradeShareLevel')) {
            btn.disabled = !canUpgrade;
            btn.style.opacity = canUpgrade ? 1 : 0.6;
            btn.style.cursor = canUpgrade ? 'pointer' : 'not-allowed';
        }
    });
}

// 升级共享等级
function upgradeShareLevel(levels) {
    const currentLevel = player.beasts.shareLevel.level;
    const targetLevel = currentLevel + levels;
    
    // 计算所需总神兽蛋
    const eggsNeeded = getEggsRequiredForLevels(currentLevel, targetLevel);
    const currentEggs = player.items.shenshou1 || 0;
    
    if (currentEggs < eggsNeeded) {
        const shortBy = eggsNeeded - currentEggs;
        logAction(`神兽蛋不足！还需要${shortBy}个才能升级${levels}级`, "error");
        return;
    }
    
    // 消耗神兽蛋
    player.items.shenshou1 = Math.max(0, currentEggs - eggsNeeded);
    
    // 升级
    player.beasts.shareLevel.level = targetLevel;
    player.beasts.shareLevel.totalExp += eggsNeeded;
    player.beasts.shareLevel.bonusMultiplier = 1 + (targetLevel * 0.02);
    
    // 更新界面
    updateShareUpgradeUI();
    updateBeastUI(); // 更新总属性显示
    
    logAction(`🎉 共享等级提升 ${levels} 级！当前等级：Lv.${targetLevel}，总属性加成：+${(targetLevel * 2).toFixed(1)}%`, "legendary");
    logAction(`消耗了${eggsNeeded}个神兽蛋，剩余：${player.items.beastEgg}个`, "info");
    
   
}

// 自定义升级
function upgradeShareLevelCustom() {
    const input = document.getElementById('customUpgradeAmount');
    const levels = parseInt(input.value);
    
    if (isNaN(levels) || levels < 1) {
        logAction("请输入有效的升级级数", "error");
        return;
    }
    
    upgradeShareLevel(levels);
}

// 最大升级（根据现有神兽蛋）
function upgradeShareLevelMax() {
    let currentLevel = player.beasts.shareLevel.level;
    let availableEggs = player.items.shenshou1 || 0;
    let maxLevels = 0;
    let totalEggsNeeded = 0;
    
    // 计算最多能升多少级
    while (true) {
        const eggsForNextLevel = getEggsRequiredForNextLevel(currentLevel + maxLevels);
        if (totalEggsNeeded + eggsForNextLevel <= availableEggs) {
            totalEggsNeeded += eggsForNextLevel;
            maxLevels++;
        } else {
            break;
        }
    }
    
    if (maxLevels === 0) {
        const eggsNeeded = getEggsRequiredForNextLevel(currentLevel);
        const shortBy = eggsNeeded - availableEggs;
        logAction(`神兽蛋不足！还需要${shortBy}个才能升级1级`, "error");
        return;
    }
    
    if (confirm(`确定要消耗${totalEggsNeeded}个神兽蛋升级${maxLevels}级吗？`)) {
        upgradeShareLevel(maxLevels);
    }
}
function toggleFiveElementsSystem() {
    const overlay = document.getElementById("fiveElementsOverlay");
    const ui = document.getElementById("fiveElementsUI");
    if (ui.style.display === "block") {
        ui.style.display = "none";
        overlay.style.display = "none";
    } else {
        ui.style.display = "block";
        overlay.style.display = "block";
        updateFiveElementsUI(); // 更新界面显示
    }
}

// 更新五行之力界面
function updateFiveElementsUI() {
    const container = document.getElementById("fiveElementsContainer");
    container.innerHTML = ""; // 清空容器
    
    // 五行元素配置（升级消耗的符文）
    const elementConfig = {
        metal: { soulType: "gold", soulName: "金符文" }, // 金消耗
        wood: { soulType: "wood", soulName: "木符文" },   // 木消耗
        water: { soulType: "water", soulName: "水符文" }, // 水消耗
        fire: { soulType: "fire", soulName: "火符文" },  // 火消耗
        earth: { soulType: "earth", soulName: "土符文" }  // 土消耗
    };
    
    // 遍历五行元素生成界面
    Object.entries(player.fiveElements).forEach(([key, element]) => {
        const config = elementConfig[key];
        const soulCount = player.runes.materials[config.soulType] || 0; // 当前拥有
        const cost = element.cost; // 当前升级成本
        
        const elementDiv = document.createElement("div");
        elementDiv.style.padding = "15px";
        elementDiv.style.background = "#333";
        elementDiv.style.borderRadius = "8px";
        elementDiv.innerHTML = `
            <div style="font-size: 24px; margin-bottom: 5px;">${element.symbol}</div>
            <div style="font-weight: bold; color: #8A2BE2;">${element.name}之力</div>
            <div>等级: ${element.level}</div>
            <div>升级消耗: ${cost}个${config.soulName}</div>
            <div>当前拥有: ${soulCount}个</div>
            <button onclick="upgradeFiveElement('${key}')" 
                    style="margin-top: 10px; padding: 5px 10px; background: ${soulCount >= cost ? '#4CAF50' : '#f44336'}; color: white; border: none; border-radius: 3px; cursor: ${soulCount >= cost ? 'pointer' : 'not-allowed'};" 
                    ${soulCount < cost ? "disabled" : ""}>
                升级
            </button>
        `;
        container.appendChild(elementDiv);
    });
}

// 升级五行元素函数
function upgradeFiveElement(elementKey) {
    const element = player.fiveElements[elementKey];
    const config = {
        metal: { soulType: "gold", soulName: "金符文" },
        wood: { soulType: "wood", soulName: "木符文" },
        water: { soulType: "water", soulName: "水符文" },
        fire: { soulType: "fire", soulName: "火符文" },
        earth: { soulType: "earth", soulName: "土符文" }
    }[elementKey];
    
    const soulType = config.soulType;
    const cost = element.cost;
    
    if ((player.runes.materials[soulType] || 0) >= cost) {
        // 消耗灵魂
        player.runes.materials[soulType] -= cost;
        // 升级元素
        element.level++;
        // 增加下次升级成本（例如每次翻倍）
        element.cost = Math.floor(element.cost * 2
);
        
        logAction(`${element.name}之力提升至 ${element.level} 级！`, "success");
        updateFiveElementsUI(); // 更新界面
        updateItemDisplay();    // 更新道具显示
    } else {
        logAction(`${config.soulName}不足！需要 ${cost} 个`, "error");
    }
}
// 法宝系统配置
const magicToolConfig = {
    // 法宝列表（每个法宝只能获得一个）
    tools: [
        // 初级法宝
     { 
            id: "spirit_gathering_flagaa", 
            name: "青锋剑", 
            description: "<p>后天灵宝<p><p>描述：百炼精钢掺杂微量“青铁”铸成，剑身泛着黯淡的青光，凡俗眼中的神兵利器，但在修士眼中仅是勉强能灌注灵力、比凡铁锋利些的制式兵器。易卷刃，遇强大护体罡气或坚硬妖兽甲壳难以破防。<p><p>神威：①灵力传导：可灌注微薄灵力，使剑身更锋锐、坚固。②青光微闪：夜间舞剑有微弱青光，聊胜于无。<p>",
            bonus: 1.1,
            materials: { spirit_stone: 100, wood: 50, metal_crystal: 5 },
            tier: 1,
            color: "#4CAF50",
            unique: true  // 唯一性标识
        },
     { 
            id: "spirit_gathering_flagab", 
            name: "清心玉佩", 
            description: "<p>后天灵宝<p><p>描述：由普通“静心玉”雕琢而成，长期佩戴能让人心绪稍感平和，对初入打坐者避免杂念有微弱辅助。效果极易被外界干扰或自身强烈情绪覆盖，对心魔几乎无效。<p><p>神威：①微弱宁神：略微提升入定速度。②示警温凉：当佩戴者情绪剧烈波动或遭遇阴邪之气时，玉佩会微微发凉。<p>",
            bonus: 1.1,
            materials: { spirit_stone: 100, water_crystal: 40, yin_stone: 10 },
            tier: 1,
            color: "#4CAF50",
            unique: true  // 唯一性标识
        },
     { 
            id: "spirit_gathering_flagac", 
            name: "避尘袍", 
            description: "<p>后天灵宝<p><p>描述：以“蚕丝蛛网”混织的法袍，刻有最基础的避尘阵法。可自动弹开灰尘、雨水、普通污渍，保持洁净。无任何防御力，穿着舒适，为低阶修士彰显身份的常见服饰。<p><p>神威：①洁净自身：不染尘埃污垢。②微光：在灵力灌注下，衣袍有非常黯淡的流光，外观尚可。<p>",
            bonus: 1.1,
            materials: { spirit_stone: 100, water_crystal: 30, earth_crystal: 15 },
            tier: 1,
            color: "#4CAF50",
            unique: true  // 唯一性标识
        },
        { 
            id: "spirit_gathering_flag", 
            name: "青龙偃月刀", 
            description: "<p>后天灵宝<p><p>描述：关羽神兵，刀身青龙盘绕。刀重八十二斤，挥舞时青龙显化，更可引动忠义之力。<p><p>神威：①青龙显化：召唤青龙助战 ②忠义之力：对不忠不义者伤害翻倍 ③刀气如龙：刀气化青龙攻击<p>",
            bonus: 1.2,
            materials: { spirit_stone: 250, fire_crystal: 50 },
            tier: 1,
            color: "#4CAF50",
            unique: true  // 唯一性标识
        },
      { 
            id: "spirit_gathering_flaga", 
            name: "丈八蛇矛", 
            description: "<p>后天灵宝<p><p>描述：张飞神兵，矛身如蛇扭曲。矛出如毒蛇吐信，诡异刁钻，更可引动狂暴之力。<p><p>神威：①毒蛇之噬：攻击带剧毒 ②狂暴之力：受伤越重威力越强 ③蛇影重重：矛影化万蛇<p>",
            bonus: 1.2,
            materials: { spirit_stone: 50, wood: 100, water_crystal: 30, fire_crystal: 30 },
            tier: 1,
            color: "#4CAF40",
            unique: true  // 唯一性标识
        },
             { 
            id: "spirit_gathering_flagb", 
            name: "龙渊剑", 
            description: "<p>后天灵宝<p><p>描述：欧冶子所铸，剑成引龙渊之灵。剑身如秋水，锋利无双，更可召唤渊龙。<p><p>神威：①龙渊剑气：剑气如水连绵不绝 ②渊龙召唤：召唤渊龙助战 ③剑心通明：持剑时心境澄明<p>",
            bonus: 1.2,
            materials: { spirit_stone: 50, wood: 30, water_crystal: 100, fire_crystal: 200 },
            tier: 1,
            color: "#4CAF60",
            unique: true  // 唯一性标识
        },
        { 
            id: "moonlight_pearl", 
            name: "太阿剑", 
            description: "<p>后天灵宝<p><p>描述：威道之剑，剑气存于天地。剑未出鞘，剑气已至，更可引动天地威压。<p><p>神威：①威道剑气：剑气蕴含天地威严 ②未出先至：剑气先于剑至 ③威压领域：展开领域压制敌人<p>",
            bonus: 1.3,
            materials: { spirit_stone: 300, wood: 200, water_crystal: 140, fire_crystal: 200 },
            tier: 1,
            color: "#2196F5",
            unique: true
        },
        { 
            id: "moonlight_pearla", 
            name: "赤霄剑", 
            description: "<p>后天灵宝<p><p>描述：帝道之剑，剑身赤红如霞。剑出斩白蛇，更可引动帝王紫气。<p><p>神威：①斩白蛇：对妖邪伤害翻倍 ②帝王紫气：紫气护体万邪不侵 ③赤霄剑气：剑气如霞绚烂夺目<p>",
            bonus: 1.3,
            materials: { spirit_stone: 100, wood: 200, water_crystal: 340, fire_crystal: 100 },
            tier: 1,
            color: "#2196F5",
            unique: true
        },
        { 
            id: "moonlight_pearlb", 
            name: "湛卢剑", 
            description: "<p>后天灵宝<p><p>描述：仁道之剑，剑身湛蓝如水。剑出无血，只斩因果，更可引动仁者之力。<p><p>神威：①因果之斩：斩断因果联系 ②仁者无敌：对邪恶者伤害翻倍 ③湛蓝剑气：剑气如水净化一切<p>",
            bonus: 1.3,
            materials: { spirit_stone: 50, wood: 330, water_crystal: 540, fire_crystal: 120 },
            tier: 1,
            color: "#2196F5",
            unique: true
        },
        { 
            id: "moonlight_pearlc", 
            name: "纯钧剑", 
            description: "<p>后天灵宝<p><p>描述：尊贵之剑，剑身尊贵无双。剑出如君子，更可引动贵族气运。<p><p>神威：①尊贵之气：压制一切凡俗兵器 ②君子之剑：剑法堂堂正正 ③贵族气运：持剑者气运提升<p>",
            bonus: 1.2,
            materials: { spirit_stone: 100, wood: 130, water_crystal: 140, fire_crystal: 220 },
            tier: 1,
            color: "#2196F1",
            unique: true
        },
       { 
            id: "moonlight_pearld", 
            name: "鱼肠剑", 
            description: "<p>后天灵宝<p><p>描述：勇绝之剑，剑身短小精悍。专诸刺王僚，更可引动刺客之道。<p><p>神威：①一击必杀：第一击威力提升十倍 ②隐身刺杀：持剑时可隐身 ③勇绝之气：不成功便成仁<p>",
            bonus: 1.3,
            materials: { spirit_stone: 110, wood: 130, water_crystal: 140, fire_crystal: 620 },
            tier: 1,
            color: "#2196F1",
            unique: true
        },
       { 
            id: "moonlight_pearle", 
            name: "承影剑", 
            description: "<p>后天灵宝<p><p>描述：优雅之剑，剑身无形无影。剑出无影，杀人无形，更可引动优雅之道。<p><p>神威：①无形无影：剑身隐形 ②优雅之击：攻击如艺术 ③影遁术：可在影子中穿梭<p>",
            bonus: 1.4,
            materials: { spirit_stone: 510, wood: 530, water_crystal: 540, fire_crystal: 520 },
            tier: 1,
            color: "#2196F1",
            unique: true
        },
       { 
            id: "moonlight_pearlf", 
            name: "七星龙渊", 
            description: "<p>后天灵宝<p><p>描述：诚信之剑，剑身七星龙渊。剑出如龙吟，更可引动诚信之力。<p><p>神威：①龙吟震慑：剑鸣震慑敌人 ②诚信之力：对背信者伤害翻倍 ③七星指引：可指引方向<p>",
            bonus: 1.3,
            materials: { spirit_stone: 810, wood: 230, water_crystal: 240},
            tier: 1,
            color: "#2196F1",
            unique: true
        },
       { 
            id: "moonlight_pearlg", 
            name: "泰阿剑", 
            description: "<p>后天灵宝<p><p>描述：威道之剑，剑气存于天地。剑未出鞘，剑气已至，更可引动天地威压。<p><p>神威：①天地威压：借天地威压攻击 ②剑气自生：剑气自动护主 ③泰阿领域：展开领域压制敌人<p>",
            bonus: 1.4,
            materials: { spirit_stone: 810, wood: 830, water_crystal: 540, fire_crystal: 820 },
            tier: 1,
            color: "#2196F1",
            unique: true
        },
      { 
            id: "moonlight_pearlh", 
            name: "巨阙剑", 
            description: "<p>后天灵宝<p><p>描述:巨剑无锋，大巧不工。剑身厚重，更可引动厚重之力。<p><p>神威：①厚重之力：攻击势大力沉 ②无锋之剑：专破防御 ③巨阙镇压：可镇压敌人<p>",
            bonus: 1.1,
            materials: { spirit_stone: 30, wood: 30, water_crystal: 50, fire_crystal: 20 },
            tier: 1,
            color: "#2196F1",
            unique: true
        },
      { 
            id: "moonlight_pearll", 
            name: "胜邪剑", 
            description: "<p>后天灵宝<p><p>描述：邪恶之剑，剑身邪气凛然。剑出邪恶，更可引动邪恶之力。<p><p>神威：①邪恶之力：攻击带邪恶属性 ②邪气侵蚀：侵蚀敌人心智 ③胜邪领域：展开领域增强邪恶<p>",
            bonus: 1.2,
            materials: { spirit_stone: 110, wood: 210, water_crystal: 110, fire_crystal: 210 },
            tier: 1,
            color: "#2196F2",
            unique: true
        },
      { 
            id: "moonlight_pearlm", 
            name: "工布剑", 
            description: "<p>后天灵宝<p><p>描述：霸道之剑，剑身霸道无双。剑出霸道，更可引动霸道之气。<p><p>神威：①霸道之气：压制一切软弱 ②霸道剑法：剑法霸道无双 ③工布领域：展开领域强制单挑<p>",
            bonus: 1.1,
            materials: { spirit_stone: 50, wood: 50, water_crystal: 50, fire_crystal: 50 },
            tier: 1,
            color: "#2196F2",
            unique: true
        },
      { 
            id: "moonlight_pearln", 
            name: "方天画戟", 
            description: "<p>后天灵宝<p><p>描述：吕布神兵，戟身刻画日月山河。戟重如山，挥舞时天地变色，更可引动山河之力。<p><p>神威：①山河之力：借山河之力攻击 ②无双战意：战意越强威力越强 ③画戟领域：展开领域压制敌人<p>",
            bonus: 1.2,
            materials: { spirit_stone: 150, wood: 150, water_crystal: 250, fire_crystal: 150 },
            tier: 1,
            color: "#2196F6",
            unique: true
        },
      { 
            id: "moonlight_pearlo", 
            name: "龙胆亮银枪", 
            description: "<p>后天灵宝<p><p>描述：赵云佩枪，枪身银白，龙胆为魂。枪出如龙，勇猛无双，更可召唤龙魂助战。<p><p>神威：①龙胆威压：压制一切坐骑 ②枪出如龙：枪法威力倍增 ③龙魂召唤：召唤银龙虚影<p>",
            bonus: 1.2,
            materials: { spirit_stone: 450, wood: 150, water_crystal: 150},
            tier: 1,
            color: "#2196F6",
            unique: true
        },
      { 
            id: "moonlight_pearlp", 
            name: "虎魄刀", 
            description: "<p>后天灵宝<p><p>描述：蚩尤以坐骑战虎魂魄炼制，刀身血红，虎啸阵阵。刀出必饮血，煞气冲天，持之易入魔。<p><p>神威：①虎魄噬魂：吞噬敌人魂魄 ②煞气领域：展开领域削弱敌人 ③战虎召唤：召唤战虎虚影助战<p>",
            bonus: 1.3,
            materials: { spirit_stone: 450, wood: 880},
            tier: 1,
            color: "#2196F6",
            unique: true
        },
      { 
            id: "moonlight_pearlq", 
            name: "画影剑", 
            description: "<p>后天灵宝<p><p>描述：影之剑，剑出如画。剑招优美如画，更可引动画中世界。<p><p>神威：①画中世界：可将敌人摄入画中 ②画影剑气：剑气如画绚丽 ③影遁术：可在画影中穿梭<p>",
            bonus: 1.3,
            materials: { spirit_stone: 250,fire_crystal: 880},
            tier: 1,
            color: "#2196F6",
            unique: true
        },
     { 
            id: "moonlight_pearlr", 
            name: "宵练剑", 
            description: "<p>后天灵宝<p><p>描述：光之剑，剑出如光。剑速如光，更可引动光之力。<p><p>神威：①光速剑：剑速达到光速 ②光之剑：剑身发光耀眼 ③宵练领域：展开领域加速一切<p>",
            bonus: 1.2,
            materials: { spirit_stone: 250,fire_crystal: 180},
            tier: 1,
            color: "#2196F2",
            unique: true
        },
     { 
            id: "moonlight_pearls", 
            name: "含光剑", 
            description: "<p>后天灵宝<p><p>描述：无形之剑，剑身无形。剑出无形，更可引动无形之力。<p><p>神威：①无形剑：剑身完全隐形 ②无形剑气：剑气无形 ③含光领域：展开领域隐藏一切<p>",
            bonus: 1.3,
            materials: { wood: 150, water_crystal: 250, fire_crystal: 1050},
            tier: 1,
            color: "#2196F2",
            unique: true
        },
     { 
            id: "moonlight_pearlt", 
            name: "龙雀刀", 
            description: "<p>后天灵宝<p><p>描述：刀身龙雀交缠，刀出龙雀齐鸣。刀法霸道，更可召唤龙雀。<p><p>神威：①龙雀齐鸣：刀鸣震慑敌人 ②龙雀召唤：召唤龙雀虚影 ③霸道刀法：刀法霸道无双<p>",
            bonus: 1.1,
            materials: { wood: 50, water_crystal: 50, fire_crystal: 110},
            tier: 1,
            color: "#2196F1",
            unique: true
        },
     { 
            id: "moonlight_pearlu", 
            name: "落宝金钱", 
            description: "<p>后天灵宝<p><p>描述：金钱有翅，可落宝物。专落先天至宝之下一切宝物，但无法落兵器。<p><p>神威：①落宝：可落一切法宝 ②金钱领域：展开领域禁止使用法宝 ③财运加持：持之财运亨通<p>",
            bonus: 1.4,
            materials: { wood: 1500, water_crystal: 530, fire_crystal: 110},
            tier: 1,
            color: "#2196F1",
            unique: true
        },
     { 
            id: "moonlight_pearlv", 
            name: "钉头七箭书", 
            description: "<p>后天灵宝<p><p>描述：诅咒至宝，书草人，射七箭。拜射草人，可咒杀大罗金仙，但需付出巨大代价。<p><p>神威：①咒杀：拜射二十一日可咒杀敌人 ②诅咒转移：可转移自身诅咒 ③钉头七箭：七箭齐发威力倍增<p>",
            bonus: 1.4,
            materials: { wood: 1500, water_crystal: 530, fire_crystal: 110},
            tier: 1,
            color: "#2196F1",
            unique: true
        },
        { 
            id: "flame_ringaa", 
            name: "化血神刀", 
            description: "<p>后天灵宝<p><p>描述：中者立时化为脓血，歹毒无比。刀出必饮血，更可诅咒敌人。<p><p>神威：①化血神刀：中刀即化血 ②血咒：刀带诅咒 ③饮血增强：饮血越多威力越强<p>",
            bonus: 1.1,
            materials: { spirit_stone: 100, fire_crystal: 300 },
            tier: 1,
            color: "#FF5732",
            unique: true
        },
        
        // 中级法宝
        { 
            id: "yin_yang_mirror", 
            name: "戮魂幡", 
            description: "<p>先天灵宝<p><p>描述：魔道至宝，摇动可收人魂魄。防不胜防，更可炼制魂兵。<p><p>神威：①收人魂魄：摇动即收魂 ②魂兵炼制：用魂魄炼制魂兵 ③戮魂领域：展开领域削弱神魂<p>",
            bonus: 1.5,
            materials: { spirit_stone: 2000, yin_stone: 100, yang_stone: 100 },
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
        { 
            id: "yin_yang_mirrora", 
            name: "火尖枪", 
            description: "<p>先天灵宝<p><p>描述：双轮转动，风火之势。上天入地，速度无双，更可释放风火攻击。<p><p>神威：①风火轮速：速度冠绝三界 ②风火攻击：释放风火 ③轮影重重：化出无数轮影<p>",
            bonus: 1.5,
            materials: { spirit_stone: 1500, fire_crystal: 500, yang_stone: 100 },
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
        { 
            id: "yin_yang_mirrorb", 
            name: "风火轮", 
            description: "<p>先天灵宝<p><p>描述：双轮转动，风火之势。上天入地，速度无双，更可释放风火攻击。<p><p>神威：①风火轮速：速度冠绝三界 ②风火攻击：释放风火 ③轮影重重：化出无数轮影<p>",
            bonus: 1.5,
            materials: { water_crystal: 1500, fire_crystal: 500, yang_stone: 88 },
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
        { 
            id: "yin_yang_mirrorc", 
            name: "六魂幡", 
            description: "<p>先天灵宝<p><p>描述：魔道至宝，幡有六尾。摇动可伤圣人，但需以自身魂魄为引。<p><p>神威：①伤圣：可伤圣人魂魄 ②六魂幡动：摇动即攻击 ③魂魄献祭：献祭魂魄增强威力<p>",
            bonus: 1.5,
            materials: { metal_crystal: 200, yin_stone: 200},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
        { 
            id: "yin_yang_mirrord", 
            name: "斩仙飞刀", 
            description: "<p>先天灵宝<p><p>描述：陆压道人法宝，葫芦内有一线毫光。白光一转，取人首级，连元神都逃不掉。<p><p>神威：①斩仙：专斩仙人 ②飞刀必中：必中要害 ③元神锁定：锁定敌人元神<p>",
            bonus: 1.6,
            materials: { metal_crystal: 200, yang_stone: 300, fire_crystal: 1200, spirit_stone: 2000},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
        { 
            id: "yin_yang_mirrore", 
            name: "干将莫邪", 
            description: "<p>先天灵宝<p><p>描述：挚情之剑，雌雄双生。干将炽热如火，莫邪清冷如冰。双剑合璧，引动天地至情之力，威力倍增<p><p>神威：①双剑合璧：威力提升十倍 ②至情之力：情感越深威力越强 ③心意相通：双剑之主可心灵感应<p>",
            bonus: 1.7,
            materials: { yin_stone: 500, yang_stone: 400, fire_crystal: 2200, spirit_stone: 2000},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
        { 
            id: "yin_yang_mirrorf", 
            name: "金灵珠", 
            description: "<p>先天灵宝<p><p>描述：先天金灵凝聚，持之可操控金属。可强化金属宝物，更可召唤金灵。<p><p>神威：①金属操控：操控一切金属 ②宝物强化：强化金属宝物 ③金灵召唤：可召唤金灵助战<p>",
            bonus: 1.5,
            materials: { spirit_stone: 1200, metal_crystal: 200, yang_stone: 200},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
        { 
            id: "yin_yang_mirrorj", 
            name: "土灵珠", 
            description: "<p>先天灵宝<p><p>描述：先天土灵凝聚，持之可操控大地。可召唤地震，更可召唤土灵。<p><p>神威：①大地操控：操控地形地貌 ②地震术：召唤地震攻击 ③土灵召唤：可召唤土灵助战<p>",
            bonus: 1.5,
            materials: { spirit_stone: 1200, wood_crystal: 200, yin_stone: 200},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
        { 
            id: "yin_yang_mirrorh", 
            name: "火灵珠", 
            description: "<p>先天灵宝<p><p>描述：先天火灵凝聚，持之可操控火焰。可召唤天火，更可召唤火灵。<p><p>神威：①火焰操控：操控一切火焰 ②天火降临：召唤天火攻击 ③火灵召唤：可召唤火灵助战<p>",
            bonus: 1.5,
            materials: { water_crystal: 2000, yang_stone: 300, yin_stone: 200},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorg", 
            name: "水灵珠", 
            description: "<p>先天灵宝<p><p>描述：先天水灵凝聚，持之可操控水流。可召唤降雨，更可召唤水灵。<p><p>神威：①水流操控：操控一切水流 ②呼风唤雨：召唤降雨 ③水灵召唤：可召唤水灵助战<p>",
            bonus: 1.5,
            materials: { water_crystal: 2000, spirit_stone: 3000, yin_stone: 100},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorm", 
            name: "木灵珠", 
            description: "<p>先天灵宝<p><p>描述：先天木灵凝聚，持之可操控植物。可加速植物生长，更可召唤木灵。<p><p>神威：①植物操控：操控一切植物 ②生长加速：加速灵植生长 ③木灵召唤：可召唤木灵助战<p>",
            bonus: 1.5,
            materials: { wood: 2000, wood_crystal: 300, yin_stone: 150},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorl", 
            name: "芭蕉扇", 
            description: "<p>先天灵宝<p><p>描述：昆仑山先天灵根芭蕉叶所化，分阴阳二扇。阳扇扇出火，阴扇扇出风，更可扇飞敌人。<p><p>神威：①煽风点火：阳扇出火，阴扇出风 ②扇飞敌人：一扇将人扇飞八万四千里 ③灭火克风：可灭天下火，定天下风<p>",
            bonus: 1.7,
            materials: { wood: 1500, metal_crystal: 500, yin_stone: 150},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirroro", 
            name: "金刚琢", 
            description: "<p>先天灵宝<p><p>描述：太上老君锟钢炼成，被还丹点成，善能变化。可套取天下万物，水火不侵。<p><p>神威：①套取万物：可套一切宝物兵器 ②变化大小：大小如意 ③金刚不坏：坚硬无比<p>",
            bonus: 1.7,
            materials: { spirit_stone: 1500, metal_crystal: 300, yang_stone: 250},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorp", 
            name: "羊脂玉净瓶", 
            description: "<p>先天灵宝<p><p>描述：观音菩萨另一法宝，瓶插杨柳枝。内盛三光神水，更可收人宝物，妙用无穷。<p><p>神威：①收人宝物：可收一切宝物 ②杨柳回春：柳枝有疗伤奇效 ③瓶中世界：内蕴小千世界<p>",
            bonus: 1.6,
            materials: { wood: 2500, water_crystal: 2300, wood_crystal: 200},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorpa", 
            name: "摄心铃", 
            description: "<p>先天灵宝<p><p>描述：一只银色铃铛，摇动时发出清脆铃声。铃声可扰乱敌人心神，制造幻听，对心志不坚者甚至可短暂操控其行动。但对神识强大者效果甚微。<p><p>神威：①心神扰乱：干扰敌人注意力与施法 ②幻听制造：制造虚假的声音指令 ③短暂操控：操控低阶或心神失守的敌人<p>",
            bonus: 1.6,
            materials: { wood: 2000, water_crystal: 3000, wood_crystal: 150},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorpb", 
            name: "养魂木", 
            description: "<p>先天灵宝<p><p>描述：一段温润如玉的黑色神木，可温养魂魄，治疗神魂创伤。将残魂寄养其中，有几率使其逐渐恢复，甚至重聚魂体。对鬼修、魂体而言是无上至宝。<p><p>神威：①神魂疗愈：加速神魂伤势恢复 ②魂体滋养：增强魂体强度 ③避劫之所：可助神魂躲避天劫、风劫<p>",
            bonus: 1.6,
            materials: { wood: 2000, water_crystal: 3000, wood_crystal: 150, yin_stone: 200},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorpc", 
            name: "北斗七星剑", 
            description: "<p>先天灵宝<p><p>描述：七剑一套，对应天枢至摇光七星。布成剑阵，引动北斗星力，杀伐无双，更可借星力续命延寿。<p><p>神威：①七星连珠：七剑合一，威力暴增 ②北斗续命：逆转生死，续命延寿 ③星陨剑阵：引动星辰坠落攻击<p>",
            bonus: 1.6,
            materials: { spirit_stone: 2000, fire_crystal: 3000, yang_stone: 150, metal_crystal: 200},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorpd", 
            name: "万魂棺", 
            description: "<p>先天灵宝<p><p>描述：一具以养魂木为主材打造的棺椁。活人躺入可滋养神魂，治疗魂伤；将敌人封印其中，可缓慢炼化其神魂；也可作为鬼修的本命法宝，修行事半功倍。<p><p>神威：①炼魂化魄：炼化棺内敌人的魂魄 ②养魂圣地：加速神魂修炼与恢复 ③鬼域空间：棺内自成小型鬼域<p>",
            bonus: 1.7,
            materials: { spirit_stone: 2000, wood: 2000, wood_crystal: 450, yin_stone: 500},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorq", 
            name: "九宫图", 
            description: "<p>先天灵宝<p><p>描述：图分九宫，演化天地。布九宫大阵，困杀一体，更可推演天机。<p><p>神威：①九宫大阵：困杀非圣人修士 ②天机推演：推演阵法变化 ③九宫遁术：可在阵内瞬移<p>",
            bonus: 1.8,
            materials: { wood: 1500, yin_stone: 200, yang_stone: 200, metal_crystal: 300, wood_crystal: 200, earth_crystal: 300},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorr", 
            name: "万兽谱", 
            description: "<p>先天灵宝<p><p>描述：一本金色典籍，可收录妖兽精魄。收录后，可消耗法力召唤其精魄虚影助战，虚影拥有本体部分实力与天赋神通。收录的妖兽越强、血脉越高，召唤消耗越大。<p><p>神威：①万兽召唤：召唤收录妖兽的精魄 ②血脉压制：对兽类敌人产生威压 ③兽魂融合：暂时与某兽魂融合，获得其特性<p>",
            bonus: 1.6,
            materials: { yin_stone: 200, yang_stone: 300, wood_crystal: 200, earth_crystal: 300},
            tier: 2,
            color: "#9C27B2",
            unique: true
        },
       { 
            id: "yin_yang_mirrors", 
            name: "摄魂幡", 
            description: "<p>先天灵宝<p><p>描述：一杆漆黑魂幡，摇动时可摄取无主游魂或重伤敌人的魂魄。魂幡内自成空间，可炼化魂魄为魂力补充自身，或炼制为幡中阴兵。<p><p>神威：①摄魂夺魄：摄取魂魄 ②阴兵借道：驱使幡中阴兵作战 ③魂力吞噬：炼化魂魄补充神识消耗<p>",
            bonus: 1.7,
            materials: { yin_stone: 600, wood: 3000},
            tier: 2,
            color: "#9C27B1",
            unique: true
        },
       { 
            id: "yin_yang_mirrort", 
            name: "同心蛊", 
            description: "<p>先天灵宝<p><p>描述：一对子母奇蛊，分别植入两人体内（通常为道侣或生死兄弟）。双方可模糊感知对方情绪、方位与安危，一方重伤时另一方可分担部分伤害，距离过远时感应减弱。<p><p>神威：①心灵感应：模糊感知对方状态 ②伤害分担：分担部分伤害 ③同心协力：联手时默契度大增<p>",
            bonus: 1.7,
            materials: { yin_stone: 600, yang_stone: 600},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirroru", 
            name: "百灵朝凤簪", 
            description: "<p>先天灵宝<p><p>描述：一支凤首玉簪，对一切禽类妖兽有天然的统御力。佩戴者所过之处，百鸟来朝，可命禽类妖兽为己所用，但对凤凰、金乌等顶级神禽效果有限。<p><p>神威：①百鸟听令：统御普通禽类妖兽 ②凤威震慑：对禽类产生血脉压制 ③翱翔九天：大幅提升飞行速度与能力<p>",
            bonus: 1.6,
            materials: { wood: 3000, spirit_stone: 3000},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
       { 
            id: "yin_yang_mirrorv", 
            name: "命运赌桌", 
            description: "<p>先天灵宝<p><p>描述：一张虚幻的赌桌，可邀请一位敌人进行“命运赌局”。赌注可以是修为、寿元、气运、法宝等。赌局形式随机（猜拳、掷骰、比大小等），结果由冥冥中的命运裁定，作弊无效。<p><p>神威：①强制赌局：邀请敌人进行赌斗 ②命运裁决：结果公正，实力无法影响 ③高风险高回报：可能瞬间获得巨大收益或损失<p>",
            bonus: 1.8,
            materials: { wood: 3000, wood_crystal: 1000},
            tier: 2,
            color: "#9C27B0",
            unique: true
        },
        { 
            id: "five_elements_pan", 
            name: "五行炉", 
            description: "<p>先天灵宝<p><p>描述：内蕴五行之火，可炼化万物。炼丹炼器，更可炼化敌人。<p><p>神威：①五行炼化：可炼化一切 ②炼丹炼器：提升成功率 ③炉火攻击：释放五行之火<p>",
            bonus: 1.6,
            materials: { metal_crystal: 300, wood_crystal: 300, water_crystal: 300, fire_crystal: 300, earth_crystal: 300 },
            tier: 2,
            color: "#FFD700",
            unique: true
        },
        
        // 高级法宝
        { 
            id: "immortal_fan", 
            name: "阴阳二气瓶", 
            description: "<p>通天灵宝​<p><p>描述：内蕴阴阳二气，瓶收万物。收入瓶中，一时三刻化为脓水，更可炼化万物。<p><p>神威：①收人炼化：收入即炼化 ②阴阳二气：可化阴阳攻击 ③瓶内世界：内蕴小千世界<p>",
            bonus: 1.8,
            materials: { yin_stone: 300, yang_stone: 301, chaos_fragment: 150, time_sand: 50  },
            tier: 2,
            color: "#00BCD4",
            unique: true
        },
        { 
            id: "immortal_fana", 
            name: "八卦炉", 
            description: "<p>通天灵宝​<p><p>描述：太上老君炼丹炉，内蕴六丁神火。可炼九转金丹，更可炼化万物。<p><p>神威：①炼化万物：六丁神火炼化一切 ②九转金丹：可炼九转金丹 ③炉内世界：内蕴八卦空间<p>",
            bonus: 1.8,
            materials: { spirit_stone: 5000, fire_crystal: 5000, yang_stone: 350, immortal_feather: 150  },
            tier: 2,
            color: "#00BCD4",
            unique: true
        },
        { 
            id: "immortal_fanb", 
            name: "清净琉璃瓶", 
            description: "<p>通天灵宝​<p><p>描述：观音菩萨法宝，瓶内盛甘露水。洒出可活死人肉白骨，更可净化一切邪祟。<p><p>神威：①起死回生：可复活死亡不超过七日者 ②净化魔气：净化一切魔道修士 ③甘露疗伤：治疗一切伤势<p>",
            bonus: 1.9,
            materials: { water_crystal: 5000, fire_crystal: 5000, space_stone: 250, immortal_feather: 250  },
            tier: 2,
            color: "#00BCD4",
            unique: true
        },
        { 
            id: "immortal_fanc", 
            name: "乾坤鼎", 
            description: "<p>通天灵宝​<p><p>描述：太上老君炼丹至宝，可返本归元，转化后天为先天。炼丹炼器，成功率百分之百，更可提升宝物品质。<p><p>神威：①后天返先天：转化后天宝物为先天 ②百分成功：炼丹炼器必成 ③鼎镇乾坤：可镇压一方世界<p>",
            bonus: 1.9,
            materials: { spirit_stone: 5000, fire_crystal: 3000, metal_crystal: 550, time_sand: 50, space_stone: 50, chaos_fragment: 50},
            tier: 2,
            color: "#00BCD4",
            unique: true
        },
        { 
            id: "immortal_fand", 
            name: "阴阳生死镜", 
            description: "<p>通天灵宝​<p><p>描述：镜分阴阳两面，阴面照死，阳面照生。照人神魂，判人生死，更可逆转阴阳，颠倒生死。<p><p>神威：①判人生死：照之即定生死 ②逆转阴阳：短暂逆转生死规则 ③阴阳领域：展开领域压制敌人<p>",
            bonus: 1.9,
            materials: { spirit_stone: 5000, yin_stone: 500, yang_stone: 550, space_stone: 100, chaos_fragment: 50},
            tier: 2,
            color: "#00BCD4",
            unique: true
        },
        { 
            id: "immortal_fane", 
            name: "五色神光扇", 
            description: "<p>通天灵宝​<p><p>描述：孔宣本命神通所化，扇分青、黄、赤、黑、白五色。一扇之下，五行之内无物不刷，无宝不落。<p><p>神威：①五行归元：刷落一切五行宝物 ②五色护体：五行攻击无效 ③神光遁术：五行之内任意穿梭<p>",
            bonus: 2,
            materials: { water_crystal: 5000, fire_crystal: 5000, metal_crystal: 500, wood_crystal: 500, earth_crystal: 500},
            tier: 2,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fanf", 
            name: "通灵宝玉", 
            description: "<p>玄天灵宝​​<p><p>描述：一块天生有灵性的美玉，长期佩戴可与万物之灵（山灵、水灵、草木之精等）进行简单沟通，更容易获得天地精灵的好感与帮助。<p><p>神威：①万物通灵：与非人灵体沟通 ②自然亲和：提升在自然环境中运气 ③精灵召唤：召唤附近弱小的自然精灵<p>",
            bonus: 2.1,
            materials: { spirit_stone: 5000, wood: 5000, wood_crystal: 500, chaos_fragment: 200, immortal_feather: 200},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fanfa", 
            name: "时空涟漪琴", 
            description: "<p>玄天灵宝​​<p><p>描述：一架古琴，弹奏时琴音会引起微小时空涟漪。熟练者可通过琴音轻微干扰局部时间流速，或制造空间褶皱隐藏自身，琴道至高者可拨动“世界之弦”。<p><p>神威：①涟漪干扰：干扰敌人时空感知 ②褶皱隐身：藏身于空间褶皱 ③弦音共振：与天地法则短暂共振<p>",
            bonus: 2.2,
            materials: { spirit_stone: 4000, wood: 6000, wood_crystal: 700, celestial_silk: 400, immortal_feather: 300},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fanfb", 
            name: "岁月长河图卷", 
            description: "<p>玄天灵宝​​<p><p>描述：图卷展开，可见一条奔流不息的光阴长河虚影。持之可短暂跳出现有时间线，窥探过去未来片段，但每次使用都会损耗自身寿元，且可能迷失在时间乱流中。<p><p>神威：①时间跳跃：短暂前往过去或未来 ②光阴回溯：让局部区域时间倒流 ③因果显化：可看见事物间的因果连线<p>",
            bonus: 2.1,
            materials: { yang_stone: 1000, yin_stone: 1000, space_stone: 600, time_sand: 300, immortal_feather: 400},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fanfe", 
            name: "番天印", 
            description: "<p>玄天灵宝​​<p><p>描述：元始天尊取半截不周山炼制。一印压下，犹如不周山倒，威力无穷。<p><p>神威：①不周山压：如山压顶 ②番天印法：印法威力巨大 ③印镇乾坤：可镇压敌人<p>",
            bonus: 2.0,
            materials: { yang_stone: 1000, yin_stone: 1000, space_stone: 300, time_sand: 200, chaos_fragment: 200},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanfo", 
            name: "九龙神火罩", 
            description: "<p>玄天灵宝​​<p><p>描述：内藏九条火龙，放出三昧真火。焚烧一切，更可困敌炼化。<p><p>神威：①九龙神火：九条火龙喷火 ②神火罩体：困敌炼化 ③三昧真火：火焰为三昧真火<p>",
            bonus: 2.2,
            materials: { water_crystal: 5000, yang_stone: 2000, space_stone: 500, chaos_fragment: 500},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanfp", 
            name: "星陨铁重剑", 
            description: "<p>玄天灵宝​​<p><p>描述：天外陨铁炼制，重达十万八千斤。剑身刻有星辰符文，挥动时引动星辰重力，一剑出，星辰陨。<p><p>神威：①星辰重力：可改变局部重力 ②陨星坠落：召唤陨石攻击 ③破法特性：克制一切法术防御<p>",
            bonus: 2.1,
            materials: { water_crystal: 5000, metal_crystal: 2500, time_sand: 500, star_dust: 50},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanfq", 
            name: "彗尾拂尘", 
            description: "<p>玄天灵宝​​<p><p>描述：彗星之尾炼制，尘丝银白。挥动时彗尾扫过，净化邪祟，更可借彗星之力推演天机。<p><p>神威：①净化万物：可净化一切污秽 ②彗星预警：彗星现世前会有感应 ③扫尘除垢：拂去心魔尘埃<p>",
            bonus: 2.3,
            materials: { wood: 10000, yang_stone: 2500,celestial_silk: 500, immortal_feather: 500, space_stone: 500, star_dust: 50},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanfu", 
            name: "星辰棋盘", 
            description: "<p>玄天灵宝​​<p><p>描述：棋盘如星空，棋子为星辰。对弈可推演天机，布阵困敌，更可将敌人摄入棋盘世界。<p><p>神威：①星空棋局：布阵困杀敌人 ②天机推演：对弈推演未来 ③棋子化星：棋子可化为真实星辰攻击<p>",
            bonus: 2.3,
            materials: { yang_stone: 2500, yang_stone: 2500,chaos_fragment: 500, space_stone: 500, law_crystal: 50, star_dust: 50},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanfv", 
            name: "日冕神冠", 
            description: "<p>玄天灵宝​​<p><p>描述：日冕精华凝聚，冠冕璀璨。戴之可得太阳星眷顾，化身大日神君，执掌太阳真火。<p><p>神威：①大日化身：短暂化身大日金乌 ②真火领域：展开领域，焚烧一切 ③日冕护体：免疫火系攻击<p>",
            bonus: 2.4,
            materials: { fire_crystal: 5000,yang_stone: 2500, yang_stone: 2500,chaos_fragment: 500, space_stone: 800, law_crystal: 100, destiny_fragment: 50},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanfw", 
            name: "月宫桂树杖", 
            description: "<p>玄天灵宝​​<p><p>描述：月宫桂树枝干炼制，清香扑鼻。杖出时月桂飘香，令人沉醉，更可沟通太阴星力，施展月宫秘法。<p><p>神威：①月桂飘香：香气有迷魂之效 ②太阴召唤：召唤月宫投影 ③不死特性：如月宫桂树般难以摧毁<p>",
            bonus: 2.5,
            materials: { wood: 10000,wood_crystal: 5000, yang_stone: 5000,immortal_feather: 1000, chaos_fragment: 1000, law_crystal: 50, destiny_fragment: 50},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanfs", 
            name: "流星逐日弓", 
            description: "<p>玄天灵宝​​<p><p>描述：弓身如流星，弓弦为日光凝聚。箭出如流星逐日，速度冠绝三界，可射日诛神。<p><p>神威：①逐日之速：箭速超越光速 ②诛神之威：对神道修士伤害翻倍 ③流星雨：可一次性射出万箭<p>",
            bonus: 2.6,
            materials: { spirit_stone: 10000,metal_crystal: 5000, yang_stone: 5000,immortal_feather: 800, chaos_fragment: 1200, law_crystal: 100, destiny_fragment: 100},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanfy", 
            name: "九曜星宫灯", 
            description: "<p>玄天灵宝​​<p><p>描述：九盏宫灯，对应九曜星君。点燃后星光璀璨，布成九曜大阵，困杀一体，更可借星光推演天机。<p><p>神威：①九曜困杀：九灯成阵，非大罗不可破 ②星光推演：借星光推演吉凶 ③星君投影：短暂召唤星君分身助战<p>",
            bonus: 2.5,
            materials: { spirit_stone: 8000,metal_crystal: 4000, yang_stone: 5000,time_sand: 300, chaos_fragment: 1100, star_dust: 100, destiny_fragment: 100},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanfz", 
            name: "紫微帝印", 
            description: "<p>玄天灵宝​​<p><p>描述：紫微星核炼制，帝气缭绕。执掌此印，可得紫微帝星认可，掌帝王命格，镇压国运气数。<p><p>神威：①帝王威压：压制一切非帝王命格者 ②国运加持：借一国气运修炼 ③紫微护体：帝星投影，万法不侵<p>",
            bonus: 2.5,
            materials: { spirit_stone: 8000,earth_crystal: 9000, yang_stone: 3000,time_sand: 900, chaos_fragment: 700, star_dust: 50, destiny_fragment: 150},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fang", 
            name: "龙之逆鳞", 
            description: "<p>玄天灵宝​​<p><p>描述：一片真正巨龙颈下最珍贵的逆鳞。持之可获得真龙的部分威压与气运，对水族有绝对命令权，但也会吸引龙族敌视与追杀。<p><p>神威：①真龙威压：散发龙威震慑万灵 ②统御水族：命令一切水中妖族 ③龙气护体：获得一丝真龙气运加持<p>",
            bonus: 2.1,
            materials: { chaos_fragment: 1000},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fanh", 
            name: "涅槃羽", 
            description: "<p>玄天灵宝​​<p><p>描述：一根真正的凤凰涅槃后遗留的本命真羽。蕴含一丝涅槃法则，持有者在濒死时，羽毛会自动燃烧，为其争取一次涅槃重生的机会。<p><p>神威：①涅槃重生：提供一次复活机会 ②凤凰真火：可释放一缕真火护体或攻敌 ③百鸟朝宗：对飞禽吸引力大增<p>",
            bonus: 2.1,
            materials: { immortal_feather: 1000},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fanm", 
            name: "因果反噬甲", 
            description: "<p>玄天灵宝​​<p><p>描述：一件半透明的铠甲，由因果丝线编织而成。当敌人对穿戴者发动攻击时，铠甲会自动记录攻击所蕴含的“因”，并在之后将其部分“果”反弹给攻击者。<p><p>神威：①伤害记录：记录攻击来源与强度 ②因果反弹：将部分伤害/负面效果返还 ③业力屏蔽：削弱业力带来的影响<p>",
            bonus: 2.2,
            materials: { yin_stone: 1000, yang_stone: 1000, chaos_fragment: 200, immortal_feather: 200, celestial_silk: 200},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fanl", 
            name: "弑神枪", 
            description: "<p>玄天灵宝​​<p><p>描述：魔祖罗睺伴生至宝，混沌青莲根茎所化。可伤圣人元神，杀伐无双。<p><p>神威：①伤圣：可伤圣人 ②杀伐之气：杀气冲天 ③弑神枪法：枪法专为杀戮<p>",
            bonus: 2.3,
            materials: { yin_stone: 1000, yang_stone: 1000, chaos_fragment: 300, immortal_feather: 300, metal_crystal: 1000},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fann", 
            name: "量天尺", 
            description: "<p>玄天灵宝​​<p><p>描述：后天功德至宝，可丈量天地。攻击无双，更可度量因果。<p><p>神威：①丈量天地：可测量一切 ②功德攻击：攻击带功德之力 ③量天尺法：尺法威力巨大<p>",
            bonus: 2.0,
            materials: { wood: 10000, yang_stone: 1000, metal_crystal: 1000, chaos_fragment: 300},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fano", 
            name: "清净竹", 
            description: "<p>玄天灵宝​​<p><p>描述：六根清净竹，可打人元神。令人昏迷，更可净化心灵。<p><p>神威：①打人元神：专打神魂 ②清净之力：净化心灵 ③竹影重重：化出无数竹影<p>",
            bonus: 2.2,
            materials: { wood: 10000, water_crystal: 10000, wood_crystal: 10000, chaos_fragment: 500},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "immortal_fanp", 
            name: "诛仙四剑", 
            description: "<p>玄天灵宝​​<p><p>描述：诛仙剑、戮仙剑、陷仙剑、绝仙剑，每一把都是先天杀伐至宝。诛仙利，戮仙亡，陷仙四处起红光，绝仙变化无穷妙。<p><p>神威：①诛仙斩神：对神道修士伤害翻倍 ②戮仙灭魂：专斩神魂 ③陷仙困敌：剑气成阵困敌 ④绝仙变化：剑气千变万化<p>",
            bonus: 2.4,
            materials: { space_stone: 1000, time_sand: 1000, destiny_fragment: 100, star_dust: 100},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanq", 
            name: "轩辕剑", 
            description: "<p>玄天灵宝​​<p><p>描述：圣道之剑，剑身一面刻日月星辰，一面刻山川草木；剑柄一面书农耕畜养之术，一面书四海一统之策。金色剑光，帝王之气。<p><p>神威：①圣道威压：压制一切邪魔外道 ②人道之剑：对人族伤害翻倍 ③轩辕剑气：剑气蕴含人道气运<p>",
            bonus: 2.5,
            materials: { chaos_fragment: 1000, destiny_fragment: 100, law_crystal: 100, star_dust: 200},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanr", 
            name: "星辰羽衣", 
            description: "<p>玄天灵宝​​<p><p>描述：以星辰之光织就，衣上星辰流转。穿之可隐身星空，更可借星辰之力防御。<p><p>神威：①星空隐身：在星空下完全隐身 ②星辰护体：星光自动防御 ③星移斗转：可短距离瞬移<p>",
            bonus: 2.6,
            materials: {  yang_stone: 1500, chaos_fragment: 300, space_stone: 300, time_sand: 300, star_dust: 300},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fans", 
            name: "周天星辰图", 
            description: "<p>玄天灵宝​​<p><p>描述：图卷展开，三百六十五颗主星、一万四千八百辅星具现，演化周天星斗大阵。持图者可借星辰之力，改天换地。<p><p>神威：①星力灌注：借周天星辰之力修炼 ②星辰坠落：召唤星辰虚影攻击 ③星空领域：展开领域，压制一切非星辰法则<p>",
            bonus: 2.7,
            materials: {  chaos_fragment: 600, space_stone: 600, destiny_fragment: 300, law_crystal: 500, star_dust: 300},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fant", 
            name: "河图洛书", 
            description: "<p>玄天灵宝​​<p><p>描述：帝俊、伏羲推演至宝，内含周天星斗大阵与混元河洛大阵奥秘。推演天机，阵法极致，包罗万象。<p><p>神威：①周天星斗：可布天道第一杀阵 ②混元河洛：演化洪荒山川地理 ③天机推演：圣人之下推演第一<p>",
            bonus: 2.8,
            materials: {  chaos_fragment: 1000, time_sand: 500, space_stone: 500, destiny_fragment: 400, law_crystal: 800, star_dust: 200},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanta", 
            name: "太阴灭绝神轮", 
            description: "<p>玄天灵宝​​<p><p>描述：月华凝聚，呈银白色轮盘。转动时太阴神光洒落，冻结时空，灭绝生机。月圆之夜威力倍增。<p><p>神威：①时空冻结：神光所及，时空凝滞 ②生机灭绝：剥夺敌人生命本源 ③月华灌注：吸收月华无限续航<p>",
            bonus: 2.9,
            materials: {  chaos_fragment: 1500, time_sand: 900, space_stone: 600, destiny_fragment: 800, law_crystal: 800, star_dust: 200, law_crystal: 200},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fantb", 
            name: "银河九天带", 
            description: "<p>玄天灵宝​​<p><p>描述：九天银河炼制，银光璀璨，柔软如绸。展开可化银河天堑，困敌防御，更可引动星辰之力。<p><p>神威：①银河天堑：化出银河阻挡一切 ②星辰锁链：可捆缚大罗金仙 ③星光疗愈：星光有疗伤奇效<p>",
            bonus: 3.1,
            materials: {  chaos_fragment: 1500, time_sand: 1500, space_stone: 1500, destiny_fragment: 1000, law_crystal: 1000, star_dust: 200, law_crystal: 300},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanu", 
            name: "十二品业火红莲", 
            description: "<p>玄天灵宝​​<p><p>描述：冥河老祖伴生至宝，莲台血红，业火熊熊。端坐莲台，防御无双，更可焚烧业力，业力越深，焚烧越烈。<p><p>神威：①业火焚身：引动敌人业力焚烧 ②红莲护体：免疫一切火系攻击 ③血海不枯：连接血海，法力无尽<p>",
            bonus: 2.9,
            materials: {  fire_crystal: 10000, yang_stone: 2000, space_stone: 600, destiny_fragment: 500, law_crystal: 500},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanv", 
            name: "七宝妙树", 
            description: "<p>玄天灵宝​​<p><p>描述：准提道人证道之宝，乃菩提树所化。树上悬七宝：金、银、琉璃、玻瓈、砗磲、赤珠、玛瑙。七彩光华，无物不刷。<p><p>神威：①万宝归宗：可刷落一切法宝 ②菩提悟道：树下悟道速度千倍 ③七宝护体：七色光华防御无双<p>",
            bonus: 2.9,
            materials: {  wood: 10000, wood_crystal: 2000, chaos_fragment: 500, star_dust: 300, law_crystal: 700},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanw", 
            name: "盘古幡", 
            description: "<p>玄天灵宝​​<p><p>描述：元始天尊至宝，幡面混沌色，挥动时撕裂鸿蒙，粉碎时空。拥有开辟天地之能，为一切防御法宝克星。<p><p>神威：①混沌剑气：撕裂一切防御 ②开天辟地：可短暂开辟小千世界 ③定地水火风：平息一切能量暴动<p>",
            bonus: 3.1,
            materials: {  yang_stone: 3000, chaos_fragment: 700, space_stone: 700, destiny_fragment: 500, law_crystal: 1000},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fany", 
            name: "混沌珠", 
            description: "<p>玄天灵宝​​<p><p>描述：内含一方未开混沌，可遮掩天机，躲避天道探查。更可借混沌之气修炼，为无上悟道之宝。<p><p>神威：①混沌世界：内蕴完整世界雏形 ②遮掩天机：圣人难算 ③混沌之气：可转化一切能量<p>",
            bonus: 3.3,
            materials: {  spirit_stone: 20000, chaos_fragment: 5000, destiny_fragment: 2000},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
       { 
            id: "immortal_fanz", 
            name: "山河社稷图", 
            description: "<p>玄天灵宝​​<p><p>描述：女娲圣人之宝，图内自生大千寰宇，山川河岳。一图一世界，生灵无尽，可因生因灭，尽在掌中。<p><p>神威：①世界囚笼：将敌人摄入图中世界 ②造化生灵：图内可演化真实生灵 ③山河镇压：借图中世界之力镇压敌人<p>",
            bonus: 3.2,
            materials: {  chaos_fragment: 5000, star_dust: 1000, law_crystal: 1000, destiny_fragment: 1000},
            tier: 3,
            color: "#00BCD1",
            unique: true
        },
        { 
            id: "chaos_cauldron", 
            name: "天地玄黄玲珑塔", 
            description: "<p>玄天灵宝​​<p><p>描述：开天功德玄黄之气凝聚，后天第一功德至宝。立于头顶则先天不败，玄黄之气垂落，万法不侵，立于不败之地。<p><p>神威：①功德护体：玄黄之气免疫一切攻击 ②镇压气运：可保一方势力气运不衰 ③万法不侵：圣人之下攻击无效<p>",
            bonus: 3.4,
            materials: { chaos_fragment: 3000, yang_stone: 6000, eternity_core: 50, law_crystal: 1200, destiny_fragment: 1000},
            tier: 3,
            color: "#E91E63",
            unique: true
        },
        
        // 传说法宝
        { 
            id: "yin_yang_mirrorbaab", 
            name: "驱年爆竹", 
            description: "<p>年俗圣物(绝版)<p><p>描述：以朱砂、赤铜与雷音木炼制而成，专为驱逐年兽所造。燃放时声震百里，红光冲天，对年兽有极强的克制之效。<p><p>神威：① 爆竹惊邪：巨响与红光对年兽造成巨额伤害与恐惧 ② 红绸漫天：释放范围红光，削弱邪祟 ③ 爆竹齐鸣：可连环引爆，造成大范围爆炸伤害<p>",
            bonus: 1.6,
            materials: { water_crystal: 999999, fire_crystal: 999999, yang_stone: 999999, space_crystal: 999999 },
            tier: 4,
            color: "#FF0000",
            unique: true
        },
        { 
            id: "heavens_will_compass", 
            name: "东皇钟", 
            description: "<p>混沌灵宝​​<p><p>描述：东皇太一伴生至宝，钟体呈混沌玄黄色，钟身刻日月星辰、地水火风。钟响时时空凝固，镇压鸿蒙，演化天道玄机。内蕴一方混沌世界，可演化万物。<p><p>神威：①时空禁锢：钟声所及，时间停滞，空间冻结 ②镇压鸿蒙：可镇压一方世界气运 ③演化混沌：钟内自成世界，可困圣人<p>",
            bonus: 3.7,
            materials: { chaos_fragment: 2000, space_stone: 2000, destiny_fragment: 500, time_essence: 200, eternity_core: 200},
            tier: 4,
            color: "#8A2BE2",
            unique: true
        },
        { 
            id: "heavens_will_compassa", 
            name: "鸿蒙量天尺", 
            description: "<p>混沌灵宝<p><p>描述：开天功德凝聚，与天地玄黄玲珑塔一攻一防。尺量天地，划分阴阳，一尺之下可丈量因果，削人气运。通体紫金，刻有鸿蒙符文，挥动时引动混沌之气，有开天辟地之威。<p><p>神威：①丈量天地：可测量空间距离，破除一切空间禁制 ②削运斩命：直接攻击敌人气运与寿命 ③功德护体：万邪不侵，因果不沾<p>",
            bonus: 3.6,
            materials: { chaos_fragment: 1500, space_stone: 1500, destiny_fragment: 500, law_crystal: 500, eternity_core: 500},
            tier: 4,
            color: "#8A2BE2",
            unique: true
        },
        { 
            id: "heavens_will_compassb", 
            name: "造化笔", 
            description: "<p>混沌灵宝<p><p>描述：可书写法则，画虚为实。一笔出，法则现，天地从。但每书写一字，消耗万年寿元。<p><p>神威：①言出法随：书写即成法则 ②造化生灵：可创造真实生灵 ③修改现实：短暂修改局部天道规则<p>",
            bonus: 3.8,
            materials: { star_dust: 1500, law_crystal: 1500, eternity_core: 600, time_essence: 700, space_crystal: 400},
            tier: 4,
            color: "#8A2BE2",
            unique: true
        },
        { 
            id: "heavens_will_compassc", 
            name: "黑洞之瞳", 
            description: "<p>混沌灵宝<p><p>描述：模拟黑洞炼制，呈纯黑色球体。催动可产生吞噬之力，吞噬万物，连光都无法逃脱。<p><p>神威：①万物吞噬：可吞噬一切攻击 ②空间扭曲：扭曲周围空间 ③引力奇点：产生超强引力场<p>",
            bonus: 3.9,
            materials: { yin_stone: 5000, space_stone: 2500, star_dust: 1500, law_crystal: 1500,  time_essence: 300, space_crystal: 1000},
            tier: 4,
            color: "#8A2BE2",
            unique: true
        },
        { 
            id: "heavens_will_compassd", 
            name: "平行世界门扉", 
            description: "<p>混沌灵宝<p><p>描述：一扇看似普通的木门，打开后可能连接其他平行世界。门后世界随机，可能富饶，可能危险，可能相似，可能截然不同。每次开门消耗巨大，且无法控制目的地。<p><p>神威：①世界穿越：随机进入平行世界 ②资源获取：从其他世界获取特有资源 ③危机转嫁：将强敌引入危险世界<p>",
            bonus: 4.2,
            materials: { chaos_fragment: 4000, space_stone: 4000, star_dust: 1500, law_crystal: 1500,  eternity_core: 1000, space_crystal: 1400},
            tier: 4,
            color: "#8A2BE2",
            unique: true
        },
        { 
            id: "heavens_will_compasse", 
            name: "因果轮回盘", 
            description: "<p>混沌灵宝<p><p>描述：盘分六道，缓缓旋转。可追查一切因果来源，将自身业力暂时转移，或将敌人打入畜生道虚影受百世轮回之苦。<p><p>神威：①因果追溯：查找事件根源 ②业力转移：转移部分业力 ③六道轮回：精神层面施加轮回折磨<p>",
            bonus: 4.4,
            materials: { yang_stone: 10000, chaos_fragment: 4000, time_sand: 5000, destiny_fragment: 3000,  eternity_core: 3000},
            tier: 4,
            color: "#8A2BE2",
            unique: true
        },
        { 
            id: "heavens_will_compassf", 
            name: "虚空古镜", 
            description: "<p>混沌灵宝<p><p>描述：镜面漆黑如深渊，可映照诸天万界任意地点。持镜者可穿透空间阻隔，观察亿万里外景象，更可开辟临时空间通道。<p><p>神威：①万界洞察：观察任意已知坐标地点 ②虚空通道：开辟临时空间门 ③镜面反射：反弹空间类攻击<p>",
            bonus: 4,
            materials: { spirit_stone: 20000, chaos_fragment: 2000, space_stone: 2000, star_dust: 3000,  space_crystal: 500},
            tier: 4,
            color: "#8A2BE2",
            unique: true
        },
        { 
            id: "heavens_will_compassg", 
            name: "大道之种", 
            description: "<p>混沌灵宝<p><p>描述：开天辟地前，鸿蒙中孕育的第一粒“概念”。无形无质，存在于真实与虚幻之间。它不是法宝，而是一粒包含“道”之终极可能的种子。<p><p>神威：①道之起源：可于体内或身外开辟一条从未存在过的“道”的雏形。②规则定义：在自身“道”的覆盖范围内，可暂时重写或否定现有天地法则。③概念化身：自身存在逐渐升华为一种“概念”，难以被任何形式的攻击彻底抹除。<p>",
            bonus: 4.5,
            materials: { chaos_fragment: 5000, space_stone: 4000, law_crystal: 1000, eternity_core: 2000, time_essence: 3000,  space_crystal: 5000},
            tier: 4,
            color: "#8A2BE2",
            unique: true
        },
        { 
            id: "heavens_will_compassga", 
            name: "诸果之因", 
            description: "<p>混沌灵宝<p><p>描述：一株生长于因果长河源头的虚无之树，其上每一片叶子都是一段“起因”，而每一条根须都连接着一个“结果”。它不决定因果，而是因果本身的一种“具象化投影”。<p><p>神威：①因果洞察：看穿万物（包括圣人）的因果线。②因果嫁接：在微小事件上，替换或添加一个有利于自己的“因”，从而改变“果”。③因果绝缘：短暂将自身或某物从当前因果网中“摘除”，避开基于因果的推演、诅咒或攻击。<p>",
            bonus: 4.6,
            materials: { chaos_fragment: 8000, space_stone: 7000, law_crystal: 1500, eternity_core: 3000, time_essence: 1500,  space_crystal: 5000},
            tier: 4,
            color: "#8A2BE2",
            unique: true
        },
        { 
            id: "eternity_pagoda", 
            name: "万物归零剑", 
            description: "<p>混沌灵宝<p><p>描述：并非一把剑，而是一个“将万物归于虚无”的终极指令的具象化。它没有剑招，没有剑气，只有“斩出”这个动作。被其“斩中”的概念（如生命、时间、空间、法则），将从根源上被判定为“从未存在过”。<p><p>神威：①概念抹杀：指定一个“概念”进行斩杀，该概念将从当前宇宙信息中被彻底删除。②存在否定：使一个目标（无论其实力多强）的“存在”本身被暂时否定，陷入“非有非无”的彻底静止状态。<p>",
            bonus: 5.0,
            materials: { law_crystal: 10000, destiny_fragment: 10000,eternity_core: 5000, time_essence: 5000, space_crystal: 5000 },
            tier: 4,
            color: "#FF9800",
            unique: true
        }
    ],
    
    // 材料列表
    materials: [
        // 常见材料 - 70%几率
        { id: "spirit_stone", name: "灵石", color: "#4CAF50", dropChance: 0.80, tier: 1 },
        { id: "wood", name: "灵木", color: "#8BC34A", dropChance: 0.80, tier: 1 },
        { id: "water_crystal", name: "水晶", color: "#2196F3", dropChance: 0.80, tier: 1 },
        { id: "fire_crystal", name: "火晶", color: "#FF5722", dropChance: 0.80, tier: 1 },
        
        // 稀有材料 - 5%几率
        { id: "metal_crystal", name: "金晶", color: "#FFD700", dropChance: 0.05, tier: 2 },
        { id: "wood_crystal", name: "木晶", color: "#8BC34A", dropChance: 0.05, tier: 2 },
        { id: "earth_crystal", name: "土晶", color: "#795548", dropChance: 0.05, tier: 2 },
        { id: "yin_stone", name: "阴石", color: "#9C27B0", dropChance: 0.05, tier: 2 },
        { id: "yang_stone", name: "阳石", color: "#FF9800", dropChance: 0.05, tier: 2 },
        
        // 珍贵材料 - 1%几率
        { id: "immortal_feather", name: "仙羽", color: "#00BCD4", dropChance: 0.01, tier: 3 },
        { id: "celestial_silk", name: "天蚕丝", color: "#E91E63", dropChance: 0.01, tier: 3 },
        { id: "chaos_fragment", name: "混沌碎片", color: "#673AB7", dropChance: 0.01, tier: 3 },
        { id: "space_stone", name: "空间石", color: "#3F51B5", dropChance: 0.01, tier: 3 },
        { id: "time_sand", name: "时光砂", color: "#009688", dropChance: 0.01, tier: 3 },
        
        // 传奇材料 - 0.1%几率
        { id: "destiny_fragment", name: "命运碎片", color: "#8A2BE2", dropChance: 0.001, tier: 4 },
        { id: "star_dust", name: "星辰尘", color: "#FFD700", dropChance: 0.001, tier: 4 },
        { id: "law_crystal", name: "法则水晶", color: "#4CAF50", dropChance: 0.001, tier: 4 },
        
        // 神话材料 - 0.01%几率
        { id: "eternity_core", name: "永恒核心", color: "#FF5722", dropChance: 0.0001, tier: 5 },
        { id: "time_essence", name: "时光精华", color: "#2196F3", dropChance: 0.0001, tier: 5 },
        { id: "space_crystal", name: "空间水晶", color: "#9C27B0", dropChance: 0.0001, tier: 5 }
    ],
    
    
    baseDropChance: 0.02 
};

// 初始化法宝系统
function initMagicToolSystem() {
    if (!player.magicTools) {
        player.magicTools = {
            equipped: null,
            inventory: [],
            materials: {}
        };
        
        // 初始化所有材料为0
        magicToolConfig.materials.forEach(material => {
            player.magicTools.materials[material.id] = 0;
        });
    }
    
    // 更新UI后显示可合成的法宝
    setTimeout(() => {
        updateMagicToolUI();
        // 默认显示可合成的法宝
        showAllCraftableTools();
    }, 100);
}
function showCollectionBonusInfo() {
    const ownedCount = player.magicTools?.inventory?.length || 0;
    const collectionBonus = 1 + (ownedCount * 0.02);
    
    const info = document.createElement('div');
    info.style.position = 'fixed';
    info.style.top = '100px';
    info.style.right = '20px';
    info.style.background = 'linear-gradient(145deg, #4CAF5040, #4CAF5020)';
    info.style.color = 'white';
    info.style.padding = '15px';
    info.style.borderRadius = '10px';
    info.style.borderLeft = '5px solid #4CAF50';
    info.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
    info.style.zIndex = '9999';
    info.style.minWidth = '200px';
    info.style.maxWidth = '250px';
    info.style.transform = 'translateX(400px)';
    info.style.transition = 'transform 0.5s ease-out';
    
    info.innerHTML = `
        <div style="font-weight: bold; color: #4CAF50; margin-bottom: 10px;">法宝收集加成</div>
        <div style="font-size: 18px; font-weight: bold; color: #FFD700; margin-bottom: 5px;">+${ownedCount}%</div>
        <div style="font-size: 12px; color: #aaa;">已收集: ${ownedCount}/${magicToolConfig.tools.length} 个法宝</div>
        <div style="font-size: 11px; color: #666; margin-top: 10px;">每收集一个法宝额外提升1%修炼速度</div>
    `;
    
    document.body.appendChild(info);
    
    // 动画显示
    setTimeout(() => {
        info.style.transform = 'translateX(0)';
    }, 10);
    
    // 动画隐藏
    setTimeout(() => {
        info.style.transform = 'translateX(400px)';
        setTimeout(() => {
            if (info.parentNode) {
                document.body.removeChild(info);
            }
        }, 500);
    }, 3000);
}

// 当获得新法宝时调用显示收集加成
function onNewMagicToolObtained(toolId) {
    // 显示合成成功提示后，再显示收集加成
    setTimeout(showCollectionBonusInfo, 3500);
}
// 打开法宝系统
function openMagicToolSystem() {
    initMagicToolSystem();
    
    const ui = document.getElementById('magicToolUI');
    const overlay = document.getElementById('magicToolOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updateMagicToolUI();
    }
}

// 关闭法宝系统
function closeMagicToolSystem() {
    document.getElementById('magicToolUI').style.display = 'none';
    document.getElementById('magicToolOverlay').style.display = 'none';
}

// 更新法宝系统界面
function updateMagicToolUI() {
    updateEquippedTool();
    updateMaterialsDisplay();
    updateMagicToolInventory();
    
    // 初始化时清空选择
    if (!selectedToolForCrafting) {
        const previewDiv = document.getElementById('magicToolPreview');
        if (previewDiv && previewDiv.innerHTML.includes("法宝合成工坊")) {
            // 已经初始化了，不需要重复设置
        } else {
            clearSelection();
        }
    }
    
    // 更新收集加成显示
    updateCultivationExpUI(0, 1, 1);
}
function showAllCraftableTools() {
    const recipesDiv = document.getElementById('craftingRecipes');
    
    // 查找所有可合成且未拥有的法宝
    const craftableTools = magicToolConfig.tools.filter(tool => 
        checkCanCraftTool(tool.id) && 
        !player.magicTools.inventory.includes(tool.id)  // 不显示已拥有的
    );
    
    if (craftableTools.length === 0) {
        // 检查是否有已经拥有的法宝
        const ownedToolsCount = player.magicTools.inventory.length;
        const totalToolsCount = magicToolConfig.tools.length;
        
        if (ownedToolsCount >= totalToolsCount) {
            recipesDiv.innerHTML = `
                <div style="text-align: center; padding: 30px; color: #4CAF50;">
                    <div style="font-size: 36px; margin-bottom: 20px;">🎉</div>
                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">恭喜！</div>
                    <div style="font-size: 14px; margin-bottom: 5px;">你已经收集了所有法宝！</div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 10px;">
                        获得 ${ownedToolsCount}% 的永久修炼加成
                    </div>
                </div>
            `;
        } else {
            recipesDiv.innerHTML = `
                <div style="text-align: center; padding: 20px; color: #666;">
                    <div style="font-size: 24px; margin-bottom: 10px;">⏳</div>
                    <div style="font-size: 14px; margin-bottom: 5px;">当前没有可合成的法宝</div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 10px;">
                        已收集: ${ownedToolsCount}/${totalToolsCount} 个法宝
                        <div style="height: 4px; background: #444; border-radius: 2px; margin-top: 5px; overflow: hidden;">
                            <div style="height: 100%; width: ${(ownedToolsCount / totalToolsCount) * 100}%; background: #4CAF50;"></div>
                        </div>
                    </div>
                </div>
            `;
        }
        return;
    }
    
    let recipesHTML = `
        <div style="margin-bottom: 10px; font-size: 12px; color: #4CAF50; font-weight: bold;">
            可合成的法宝 (${craftableTools.length}个):
        </div>
    `;
    
    craftableTools.forEach(tool => {
        recipesHTML += `
            <div style="background: rgba(76, 175, 80, 0.1); padding: 10px; border-radius: 6px; margin-bottom: 8px; border-left: 3px solid #4CAF50; cursor: pointer;"
                 onclick="selectToolForCrafting('${tool.id}')"
                 onmouseenter="this.style.background='rgba(76,175,80,0.2)'"
                 onmouseleave="this.style.background='rgba(76,175,80,0.1)'">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 14px; font-weight: bold; color: ${tool.color};">${tool.name}</div>
                        <div style="font-size: 11px; color: #aaa; margin-top: 2px;">T${tool.tier} 法宝 • ${tool.bonus.toFixed(1)}倍加成</div>
                    </div>
                    <div style="font-size: 20px; color: #4CAF50;">➜</div>
                </div>
            </div>
        `;
    });
    
    // 添加收集进度信息
    const ownedToolsCount = player.magicTools.inventory.length;
    const totalToolsCount = magicToolConfig.tools.length;
    const remainingTools = totalToolsCount - ownedToolsCount;
    
    recipesHTML += `
        <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; font-size: 11px; color: #aaa;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                <span>收集进度:</span>
                <span>${ownedToolsCount}/${totalToolsCount}</span>
            </div>
            <div style="height: 4px; background: #444; border-radius: 2px; overflow: hidden; margin-bottom: 5px;">
                <div style="height: 100%; width: ${(ownedToolsCount / totalToolsCount) * 100}%; background: #4CAF50;"></div>
            </div>
            <div style="text-align: center;">
                剩余可合成: <span style="color: #FFD700;">${remainingTools}</span> 个法宝
            </div>
        </div>
    `;
    
    recipesDiv.innerHTML = recipesHTML;
}

// 显示所有法宝配方
function showAllRecipes() {
    const recipesDiv = document.getElementById('craftingRecipes');
    
    const ownedToolsCount = player.magicTools.inventory.length;
    const totalToolsCount = magicToolConfig.tools.length;
    const unownedTools = magicToolConfig.tools.filter(tool => 
        !player.magicTools.inventory.includes(tool.id)
    );
    
    if (unownedTools.length === 0) {
        recipesDiv.innerHTML = `
            <div style="text-align: center; padding: 30px; color: #4CAF50;">
                <div style="font-size: 36px; margin-bottom: 20px;">🏆</div>
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px;">全收集达成！</div>
                <div style="font-size: 14px; margin-bottom: 5px;">你已经获得了所有法宝</div>
                <div style="font-size: 12px; color: #aaa; margin-top: 15px;">
                    享受 ${ownedToolsCount}% 的永久修炼加成吧！
                </div>
            </div>
        `;
        return;
    }
    
    let recipesHTML = `
        <div style="margin-bottom: 10px; font-size: 12px; color: #FFD700; font-weight: bold;">
            未获得的法宝配方 (${unownedTools.length}/${totalToolsCount}):
        </div>
    `;
    
    // 按品级分组
    const toolsByTier = {};
    unownedTools.forEach(tool => {
        if (!toolsByTier[tool.tier]) {
            toolsByTier[tool.tier] = [];
        }
        toolsByTier[tool.tier].push(tool);
    });
    
    Object.keys(toolsByTier).sort((a, b) => a - b).forEach(tier => {
        const tierColor = getTierColor(tier);
        recipesHTML += `
            <div style="margin-bottom: 10px;">
                <div style="font-size: 11px; color: ${tierColor}; margin-bottom: 5px; padding-bottom: 3px; border-bottom: 1px solid ${tierColor}40; display: flex; justify-content: space-between;">
                    <span>T${tier} 法宝</span>
                    <span>${toolsByTier[tier].length}个</span>
                </div>
        `;
        
        toolsByTier[tier].forEach(tool => {
            const canCraft = checkCanCraftTool(tool.id);
            const missingMaterials = getMissingMaterials(tool.id);
            
            recipesHTML += `
                <div style="background: rgba(255,255,255,0.05); padding: 8px; border-radius: 5px; margin-bottom: 5px; cursor: pointer;"
                     onclick="selectToolForCrafting('${tool.id}')"
                     onmouseenter="this.style.background='rgba(255,255,255,0.1)'"
                     onmouseleave="this.style.background='rgba(255,255,255,0.05)'">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="color: ${tool.color}; font-size: 12px; font-weight: bold;">${tool.name}</div>
                            <div style="font-size: 9px; color: ${canCraft ? '#4CAF50' : '#666'}; background: ${canCraft ? 'rgba(76,175,80,0.2)' : 'rgba(102,102,102,0.2)'}; padding: 1px 4px; border-radius: 2px;">
                                ${canCraft ? '可合成' : '材料不足'}
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #FFD700; font-weight: bold;">${tool.bonus.toFixed(1)}×</div>
                    </div>
                    ${missingMaterials.length > 0 ? `
                        <div style="font-size: 9px; color: #666; margin-top: 3px;">
                            缺少: ${missingMaterials.map(m => `<span style="color: ${m.color};">${m.name}</span>`).join(', ')}
                        </div>
                    ` : ''}
                </div>
            `;
        });
        
        recipesHTML += `</div>`;
    });
    
    // 添加收集进度
    recipesHTML += `
        <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px;">
            <div style="display: flex; justify-content: space-between; font-size: 11px; color: #aaa; margin-bottom: 5px;">
                <span>法宝收集进度</span>
                <span>${ownedToolsCount}/${totalToolsCount}</span>
            </div>
            <div style="height: 6px; background: #444; border-radius: 3px; overflow: hidden; margin-bottom: 8px;">
                <div style="height: 100%; width: ${(ownedToolsCount / totalToolsCount) * 100}%; background: linear-gradient(90deg, #4CAF50, #8BC34A);"></div>
            </div>
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666;">
                <span>加成: ${ownedToolsCount}%</span>
                <span>剩余: ${unownedTools.length}个</span>
            </div>
        </div>
    `;
    
    // 添加快捷按钮
    recipesHTML += `
        <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
            <button onclick="showAllCraftableTools()" style="background: rgba(76,175,80,0.2); color: #4CAF50; border: 1px solid #4CAF50; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 10px;">
                只看可合成
            </button>
            <button onclick="clearSelection()" style="background: rgba(255,255,255,0.1); color: #aaa; border: 1px solid #666; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 10px;">
                清空选择
            </button>
        </div>
    `;
    
    recipesDiv.innerHTML = recipesHTML;
}
function getMissingMaterials(toolId) {
    const tool = magicToolConfig.tools.find(t => t.id === toolId);
    if (!tool) return [];
    
    const missing = [];
    for (const [materialId, required] of Object.entries(tool.materials)) {
        const have = player.magicTools.materials[materialId] || 0;
        if (have < required) {
            const material = magicToolConfig.materials.find(m => m.id === materialId);
            missing.push({
                id: materialId,
                name: material.name,
                color: material.color,
                have: have,
                need: required
            });
        }
    }
    
    return missing;
}
// 更新装备的法宝显示
function updateEquippedTool() {
    const equippedDiv = document.getElementById('equippedMagicTool');
    const bonusInfo = document.getElementById('magicToolBonusInfo');
    const multiplier = document.getElementById('magicToolMultiplier');
    
    if (player.magicTools.equipped) {
        const tool = magicToolConfig.tools.find(t => t.id === player.magicTools.equipped);
        if (tool) {
            equippedDiv.innerHTML = `
                <div style="width: 100%;">
                    <div style="font-size: 20px; font-weight: bold; color: ${tool.color}; margin-bottom: 5px;">${tool.name}</div>
                    <div style="color: #aaa; margin-bottom: 10px;">${tool.description}</div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span>加成: <span style="color: #FFD700; font-weight: bold;">${tool.bonus * 100}%</span></span>
                        <button onclick="unequipMagicTool()" style="background: #f44336; color: white; border: none; padding: 5px 15px; border-radius: 5px; cursor: pointer;">卸下</button>
                    </div>
                </div>
            `;
            
            multiplier.textContent = tool.bonus.toFixed(1);
        }
    } else {
        equippedDiv.innerHTML = `
            <div style="text-align: center; width: 100%;">
                <div style="font-size: 18px; color: #aaa; margin-bottom: 10px;">未装备任何法宝</div>
                <div style="color: #666;">装备法宝可提升修炼速度</div>
            </div>
        `;
        multiplier.textContent = "1";
    }
    
    // 更新主界面的法宝信息
    const mainToolInfo = document.getElementById('currentMagicToolInfo');
    if (player.magicTools.equipped) {
        const tool = magicToolConfig.tools.find(t => t.id === player.magicTools.equipped);
        mainToolInfo.innerHTML = `
            <div style="color: ${tool.color}; font-weight: bold;">${tool.name}</div>
            <div style="font-size: 12px; color: #aaa;">${tool.bonus.toFixed(1)}倍修炼</div>
        `;
    } else {
        mainToolInfo.textContent = "无装备法宝";
    }
}
// 添加全局变量来跟踪选择
let selectedToolForCrafting = null; // 当前选择的要合成的法宝ID
let selectedMaterialsForPreview = {}; // 用于预览的材料选择
// 更新材料显示
function updateMaterialsDisplay() {
    const materialsDiv = document.getElementById('magicMaterials');
    materialsDiv.innerHTML = '';
    
    // 计算每个材料相关的未获得法宝数量
    const materialToolCounts = {};
    magicToolConfig.materials.forEach(material => {
        const unownedToolsUsingMaterial = magicToolConfig.tools.filter(tool => 
            Object.keys(tool.materials).includes(material.id) && 
            !player.magicTools.inventory.includes(tool.id)
        );
        materialToolCounts[material.id] = unownedToolsUsingMaterial.length;
    });
    
    // 按品级分组显示
    const tiers = {};
    magicToolConfig.materials.forEach(material => {
        if (!tiers[material.tier]) {
            tiers[material.tier] = [];
        }
        tiers[material.tier].push(material);
    });
    
    // 按品级从低到高显示
    Object.keys(tiers).sort((a, b) => a - b).forEach(tier => {
        // 添加品级标题
        const tierHeader = document.createElement('div');
        tierHeader.style.gridColumn = '1 / -1';
        tierHeader.style.color = getTierColor(tier);
        tierHeader.style.fontSize = '14px';
        tierHeader.style.fontWeight = 'bold';
        tierHeader.style.marginTop = tier > 1 ? '10px' : '0';
        tierHeader.style.marginBottom = '8px';
        tierHeader.style.paddingBottom = '5px';
        tierHeader.style.borderBottom = `1px solid ${getTierColor(tier)}40`;
        tierHeader.textContent = getTierName(tier);
        materialsDiv.appendChild(tierHeader);
        
        // 显示该品级的材料
        tiers[tier].forEach(material => {
            const count = player.magicTools.materials[material.id] || 0;
            const toolCount = materialToolCounts[material.id] || 0;
            const materialDiv = document.createElement('div');
            materialDiv.style.padding = '10px';
            materialDiv.style.background = 'rgba(255,255,255,0.05)';
            materialDiv.style.borderRadius = '6px';
            materialDiv.style.textAlign = 'center';
            materialDiv.style.border = `2px solid ${material.color}`;
            materialDiv.style.cursor = 'pointer';
            materialDiv.style.position = 'relative';
            materialDiv.style.overflow = 'hidden';
            materialDiv.style.transition = 'all 0.2s';
            
            // 如果该材料没有未获得的配方，变灰显示
            if (toolCount === 0) {
                materialDiv.style.opacity = '0.6';
                materialDiv.style.filter = 'grayscale(0.3)';
            }
            
            // 悬停效果
            materialDiv.onmouseenter = () => {
                if (toolCount > 0) {
                    materialDiv.style.transform = 'translateY(-2px)';
                    materialDiv.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
                }
            };
            materialDiv.onmouseleave = () => {
                materialDiv.style.transform = 'translateY(0)';
                materialDiv.style.boxShadow = 'none';
            };
            
            // 点击查看可合成的法宝
            materialDiv.onclick = () => {
                if (toolCount > 0) {
                    showRecipesForMaterial(material.id);
                }
            };
            
            // 添加材料品级背景
            const tierIndicator = document.createElement('div');
            tierIndicator.style.position = 'absolute';
            tierIndicator.style.top = '0';
            tierIndicator.style.right = '0';
            tierIndicator.style.width = '0';
            tierIndicator.style.height = '0';
            tierIndicator.style.borderLeft = '15px solid transparent';
            tierIndicator.style.borderRight = '15px solid transparent';
            tierIndicator.style.borderBottom = `15px solid ${material.color}`;
            tierIndicator.style.transform = 'rotate(45deg)';
            tierIndicator.style.opacity = '0.3';
            materialDiv.appendChild(tierIndicator);
            
            // 添加配方数量提示
            if (toolCount > 0) {
                const recipeCount = document.createElement('div');
                recipeCount.style.position = 'absolute';
                recipeCount.style.top = '3px';
                recipeCount.style.left = '3px';
                recipeCount.style.fontSize = '9px';
                recipeCount.style.color = '#4CAF50';
                recipeCount.style.background = 'rgba(0,0,0,0.5)';
                recipeCount.style.padding = '1px 4px';
                recipeCount.style.borderRadius = '3px';
                recipeCount.style.fontWeight = 'bold';
                recipeCount.textContent = `${toolCount}配方`;
                materialDiv.appendChild(recipeCount);
            }
            
            materialDiv.innerHTML += `
                <div style="font-size: 12px; color: ${material.color}; margin-bottom: 3px; position: relative; z-index: 1;">${material.name}</div>
                <div style="font-size: 18px; font-weight: bold; color: ${count > 0 ? '#FFD700' : '#666'}; position: relative; z-index: 1;">${count}</div>
                <div style="font-size: 10px; color: #666; position: relative; z-index: 1; margin-top: 2px;">${(material.dropChance * 100).toFixed(2)}%</div>
                ${toolCount === 0 ? 
                    '<div style="font-size: 9px; color: #4CAF50; position: relative; z-index: 1; margin-top: 3px; background: rgba(76,175,80,0.2); padding: 1px 4px; border-radius: 3px;">已全部获得</div>' : 
                    ''
                }
            `;
            materialsDiv.appendChild(materialDiv);
        });
    });
    
    // 添加统计信息
    const statsDiv = document.createElement('div');
    statsDiv.style.gridColumn = '1 / -1';
    statsDiv.style.marginTop = '15px';
    statsDiv.style.padding = '10px';
    statsDiv.style.background = 'rgba(255,255,255,0.05)';
    statsDiv.style.borderRadius = '8px';
    statsDiv.style.fontSize = '11px';
    statsDiv.style.color = '#aaa';
    
    const ownedToolsCount = player.magicTools.inventory.length;
    const totalToolsCount = magicToolConfig.tools.length;
    const remainingTools = totalToolsCount - ownedToolsCount;
    
    statsDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <span>法宝收集:</span>
            <span><span style="color: #4CAF50;">${ownedToolsCount}</span>/${totalToolsCount}</span>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span>剩余可合成:</span>
            <span style="color: ${remainingTools > 0 ? '#FFD700' : '#4CAF50'}">${remainingTools}个</span>
        </div>
    `;
    
    materialsDiv.appendChild(statsDiv);
    
    // 在材料显示底部添加按钮
    const buttonsDiv = document.createElement('div');
    buttonsDiv.style.gridColumn = '1 / -1';
    buttonsDiv.style.display = 'flex';
    buttonsDiv.style.gap = '10px';
    buttonsDiv.style.marginTop = '10px';
    buttonsDiv.style.justifyContent = 'center';
    
    buttonsDiv.innerHTML = `
        <button onclick="showAllCraftableTools()" style="background: linear-gradient(45deg, #4CAF50, #2E7D32); color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold; flex: 1;">
            可合成法宝
        </button>
        <button onclick="showAllRecipes()" style="background: rgba(255,255,255,0.1); color: #aaa; border: 1px solid #666; padding: 8px 15px; border-radius: 6px; cursor: pointer; font-size: 12px; flex: 1;">
            所有配方
        </button>
    `;
    
    materialsDiv.appendChild(buttonsDiv);
}
// 获取品级颜色
function getTierColor(tier) {
    const colors = {
        1: '#4CAF50', // 绿色 - 常见
        2: '#2196F3', // 蓝色 - 稀有
        3: '#9C27B0', // 紫色 - 珍贵
        4: '#FF9800', // 橙色 - 传奇
        5: '#FF5722'  // 红色 - 神话
    };
    return colors[tier] || '#FFFFFF';
}

// 获取品级名称
function getTierName(tier) {
    const names = {
        1: '常见材料 (80%掉落几率)',
        2: '稀有材料 (5%掉落几率)',
        3: '珍贵材料 (1%掉落几率)',
        4: '传奇材料 (0.1%掉落几率)',
        5: '神话材料 (0.01%掉落几率)'
    };
    return names[tier] || `品级 ${tier}`;
}

function showRecipesForMaterial(materialId) {
    const recipesDiv = document.getElementById('craftingRecipes');
    const material = magicToolConfig.materials.find(m => m.id === materialId);
    
    if (!material) return;
    
    // 查找使用该材料且未拥有的法宝
    const toolsUsingMaterial = magicToolConfig.tools.filter(tool => 
        Object.keys(tool.materials).includes(materialId) && 
        !player.magicTools.inventory.includes(tool.id)  // 不显示已拥有的
    );
    
    if (toolsUsingMaterial.length === 0) {
        recipesDiv.innerHTML = `
            <div style="text-align: center; padding: 20px; color: #666;">
                <div style="font-size: 24px; margin-bottom: 10px;">📭</div>
                <div style="font-size: 14px; margin-bottom: 5px;">没有新的配方</div>
                <div style="font-size: 12px; color: #aaa;">
                    使用 <span style="color: ${material.color};">${material.name}</span> 的法宝已经全部获得了
                </div>
            </div>
        `;
        return;
    }
    
    // 显示配方列表
    let recipesHTML = `
        <div style="margin-bottom: 10px; font-size: 12px; color: #aaa;">
            使用 <span style="color: ${material.color}; font-weight: bold;">${material.name}</span> 的配方 (${toolsUsingMaterial.length}个):
        </div>
    `;
    
    toolsUsingMaterial.forEach(tool => {
        const requiredCount = tool.materials[materialId];
        const hasCount = player.magicTools.materials[materialId] || 0;
        const canCraft = checkCanCraftTool(tool.id);
        
        recipesHTML += `
            <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; margin-bottom: 8px; border-left: 3px solid ${tool.color}; cursor: pointer;"
                 onclick="selectToolForCrafting('${tool.id}')"
                 onmouseenter="this.style.background='rgba(255,255,255,0.1)'"
                 onmouseleave="this.style.background='rgba(255,255,255,0.05)'">
                <div style="display: flex; justify-content: space-between; align-items: start;">
                    <div>
                        <div style="font-size: 14px; font-weight: bold; color: ${tool.color};">${tool.name}</div>
                        <div style="font-size: 11px; color: #aaa; margin-top: 2px;">${tool.description}</div>
                    </div>
                    <div style="font-size: 10px; color: ${canCraft ? '#4CAF50' : '#f44336'}; background: ${canCraft ? 'rgba(76,175,80,0.2)' : 'rgba(244,67,54,0.2)'}; padding: 2px 6px; border-radius: 3px;">
                        ${canCraft ? '可合成' : '材料不足'}
                    </div>
                </div>
                <div style="margin-top: 8px;">
                    <div style="font-size: 11px; color: #666; margin-bottom: 4px;">需要${material.name}:</div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="color: ${hasCount >= requiredCount ? '#4CAF50' : '#f44336'}; font-weight: bold;">
                            ${hasCount}/${requiredCount}
                        </div>
                        <div style="flex: 1; height: 4px; background: #444; border-radius: 2px; overflow: hidden;">
                            <div style="height: 100%; width: ${Math.min(100, (hasCount / requiredCount) * 100)}%; background: ${hasCount >= requiredCount ? '#4CAF50' : '#f44336'};"></div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    });
    
    recipesDiv.innerHTML = recipesHTML;
    
    // 默认选择第一个可合成的法宝
    const firstCraftableTool = toolsUsingMaterial.find(tool => checkCanCraftTool(tool.id));
    if (firstCraftableTool) {
        selectToolForCrafting(firstCraftableTool.id);
    } else if (toolsUsingMaterial.length > 0) {
        // 如果没有可合成的，至少显示第一个
        selectToolForCrafting(toolsUsingMaterial[0].id);
    }
}
function checkCanCraftTool(toolId) {
    const tool = magicToolConfig.tools.find(t => t.id === toolId);
    if (!tool) return false;
    
    // 检查是否已经拥有（如果已拥有，不能合成）
    if (player.magicTools.inventory.includes(toolId)) {
        return false;
    }
    
    // 检查材料是否足够
    for (const [materialId, required] of Object.entries(tool.materials)) {
        const have = player.magicTools.materials[materialId] || 0;
        if (have < required) {
            return false;
        }
    }
    
    return true;
}
function selectToolForCrafting(toolId) {
    selectedToolForCrafting = toolId;
    const tool = magicToolConfig.tools.find(t => t.id === toolId);
    
    if (!tool) return;
    
    // 更新预览显示
    updateToolPreview(tool);
    
    // 更新材料选择信息
    updateSelectedMaterialsInfo(tool);
    
    // 更新合成按钮状态
    updateCraftButton(tool);
}
// 更新法宝预览
function updateToolPreview(tool) {
    const previewDiv = document.getElementById('magicToolPreview');
    const alreadyOwned = player.magicTools.inventory.includes(tool.id);
    const canCraft = checkCanCraftTool(tool.id);
    const tierColor = getTierColor(tool.tier);
    
    // 如果已拥有，显示不同的预览
    if (alreadyOwned) {
        previewDiv.innerHTML = `
            <div style="width: 100%;">
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                    <div style="font-size: 40px; color: #4CAF50;">✅</div>
                    <div>
                        <div style="font-size: 24px; font-weight: bold; color: ${tool.color};">${tool.name}</div>
                        <div style="font-size: 12px; color: ${tierColor}; background: ${tierColor}20; padding: 2px 10px; border-radius: 10px; display: inline-block; margin-top: 5px;">已拥有 • T${tool.tier} 法宝</div>
                    </div>
                </div>
                
                <div style="color: #aaa; margin-bottom: 15px; font-size: 14px; line-height: 1.4;">${tool.description}</div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: rgba(255, 215, 0, 0.1); padding: 10px; border-radius: 8px;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 5px;">基础加成</div>
                        <div style="font-size: 20px; color: #FFD700; font-weight: bold;">${tool.bonus.toFixed(1)}倍</div>
                    </div>
                    <div style="background: rgba(76, 175, 80, 0.1); padding: 10px; border-radius: 8px;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 5px;">收集加成</div>
                        <div style="font-size: 20px; color: #4CAF50; font-weight: bold;">+1%</div>
                    </div>
                </div>
                
                <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #4CAF50;">
                    <div style="font-size: 14px; color: #4CAF50; font-weight: bold; margin-bottom: 5px;">已添加到法宝库</div>
                    <div style="font-size: 12px; color: #aaa;">这个法宝正在为你的修炼提供加成</div>
                </div>
            </div>
        `;
        
        // 如果已拥有，禁用合成按钮
        const craftButton = document.getElementById('craftButton');
        craftButton.disabled = true;
        craftButton.style.background = '#666';
        craftButton.style.color = '#aaa';
        craftButton.textContent = '已拥有';
        
        return;
    }
    
    // 未拥有的法宝预览
    const missingMaterials = getMissingMaterials(tool.id);
    
    previewDiv.innerHTML = `
        <div style="width: 100%;">
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                <div style="font-size: 40px;">${canCraft ? '🔮' : '⏳'}</div>
                <div>
                    <div style="font-size: 24px; font-weight: bold; color: ${tool.color};">${tool.name}</div>
                    <div style="font-size: 12px; color: ${tierColor}; background: ${tierColor}20; padding: 2px 10px; border-radius: 10px; display: inline-block; margin-top: 5px;">T${tool.tier} 法宝</div>
                </div>
            </div>
            
            <div style="color: #aaa; margin-bottom: 15px; font-size: 14px; line-height: 1.4;">${tool.description}</div>
            
            ${missingMaterials.length > 0 ? `
                <div style="color: #f44336; margin-bottom: 15px; font-size: 14px; background: rgba(244, 67, 54, 0.1); padding: 10px; border-radius: 8px; border-left: 3px solid #f44336;">
                    <div style="font-weight: bold; margin-bottom: 5px;">缺少材料:</div>
                    ${missingMaterials.map(m => `
                        <div style="display: flex; justify-content: space-between; align-items: center; font-size: 12px; margin-bottom: 3px;">
                            <span style="color: ${m.color};">${m.name}</span>
                            <span>${m.have}/${m.need}</span>
                        </div>
                    `).join('')}
                </div>
            ` : ''}
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div style="background: rgba(255, 215, 0, 0.1); padding: 10px; border-radius: 8px;">
                    <div style="font-size: 12px; color: #666; margin-bottom: 5px;">修炼加成</div>
                    <div style="font-size: 20px; color: #FFD700; font-weight: bold;">${tool.bonus.toFixed(1)}倍</div>
                </div>
                <div style="background: rgba(76, 175, 80, 0.1); padding: 10px; border-radius: 8px;">
                    <div style="font-size: 12px; color: #666; margin-bottom: 5px;">收集加成</div>
                    <div style="font-size: 20px; color: #4CAF50; font-weight: bold;">+1%</div>
                </div>
            </div>
            
            <div style="margin-top: 15px;">
                <div style="font-size: 12px; color: #666; margin-bottom: 8px;">合成状态:</div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="font-size: 14px; color: ${canCraft ? '#4CAF50' : '#f44336'}; font-weight: bold;">
                        ${canCraft ? '可合成' : '材料不足'}
                    </div>
                    ${canCraft ? 
                        '<div style="font-size: 12px; color: #4CAF50; background: rgba(76,175,80,0.2); padding: 2px 8px; border-radius: 3px;">✓ 材料充足</div>' : 
                        '<div style="font-size: 12px; color: #f44336; background: rgba(244,67,54,0.2); padding: 2px 8px; border-radius: 3px;">✗ 缺少材料</div>'
                    }
                </div>
            </div>
        </div>
    `;
}
function updateSelectedMaterialsInfo(tool) {
    const infoDiv = document.getElementById('selectedMaterialsInfo');
    
    if (!tool) {
        infoDiv.innerHTML = "未选择法宝";
        return;
    }
    
    let materialsHTML = `
        <div style="font-size: 12px; color: #aaa; margin-bottom: 5px;">合成 ${tool.name} 所需材料:</div>
    `;
    
    let allMaterialsAvailable = true;
    let totalRequired = 0;
    let totalHave = 0;
    
    for (const [materialId, required] of Object.entries(tool.materials)) {
        const material = magicToolConfig.materials.find(m => m.id === materialId);
        const have = player.magicTools.materials[materialId] || 0;
        const isAvailable = have >= required;
        
        if (!isAvailable) allMaterialsAvailable = false;
        
        totalRequired += required;
        totalHave += Math.min(have, required);
        
        materialsHTML += `
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 3px; font-size: 11px;">
                <span style="color: ${material.color};">${material.name}</span>
                <span style="color: ${isAvailable ? '#4CAF50' : '#f44336'}; font-weight: bold;">
                    ${have}/${required}
                </span>
            </div>
        `;
    }
    
    // 添加进度条
    const progressPercent = totalRequired > 0 ? (totalHave / totalRequired) * 100 : 0;
    materialsHTML += `
        <div style="margin-top: 8px;">
            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-bottom: 3px;">
                <span>材料收集进度</span>
                <span>${totalHave}/${totalRequired}</span>
            </div>
            <div style="height: 4px; background: #444; border-radius: 2px; overflow: hidden;">
                <div style="height: 100%; width: ${progressPercent}%; background: ${allMaterialsAvailable ? '#4CAF50' : '#f44336'};"></div>
            </div>
        </div>
    `;
    
    infoDiv.innerHTML = materialsHTML;
}
function updateCraftButton(tool) {
    const craftButton = document.getElementById('craftButton');
    const alreadyOwned = player.magicTools.inventory.includes(tool.id);
    const canCraft = checkCanCraftTool(tool.id);
    
    if (alreadyOwned) {
        craftButton.disabled = true;
        craftButton.style.background = '#666';
        craftButton.style.color = '#aaa';
        craftButton.textContent = '已拥有该法宝';
    } else if (canCraft) {
        craftButton.disabled = false;
        craftButton.style.background = `linear-gradient(45deg, ${tool.color}, ${tool.color}80)`;
        craftButton.style.color = 'white';
        craftButton.textContent = `合成 ${tool.name}`;
        craftButton.onclick = () => craftSelectedTool();
    } else {
        craftButton.disabled = true;
        craftButton.style.background = '#555';
        craftButton.style.color = '#888';
        craftButton.textContent = '材料不足';
    }
}
function craftSelectedTool() {
    if (!selectedToolForCrafting) {
        logAction("请先选择要合成的法宝", "error");
        return;
    }
    
    craftMagicTool(selectedToolForCrafting);
}
function clearSelection() {
    selectedToolForCrafting = null;
    selectedMaterialsForPreview = {};
    
    // 重置显示
    const previewDiv = document.getElementById('magicToolPreview');
    previewDiv.innerHTML = `
        <div style="width: 100%;">
            <div style="font-size: 48px; margin-bottom: 20px;">🔮</div>
            <div style="font-size: 18px; color: #aaa; margin-bottom: 10px;">法宝合成工坊</div>
            <div style="color: #666; font-size: 14px;">点击材料查看配方或使用下方按钮</div>
        </div>
    `;
    
    document.getElementById('selectedMaterialsInfo').innerHTML = "未选择材料";
    
    // 默认显示可合成的法宝
    showAllCraftableTools();
    
    const craftButton = document.getElementById('craftButton');
    craftButton.disabled = true;
    craftButton.style.background = '#555';
    craftButton.style.color = '#888';
    craftButton.textContent = '请选择要合成的法宝';
}

// 更新法宝库存显示
function updateMagicToolInventory() {
    const inventoryDiv = document.getElementById('magicToolInventory');
    inventoryDiv.innerHTML = '';
    
    if (player.magicTools.inventory.length === 0) {
        inventoryDiv.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; padding: 30px; color: #666;">
                <div style="font-size: 48px; margin-bottom: 20px;">📦</div>
                <div style="font-size: 18px; margin-bottom: 10px;">法宝库空空如也</div>
                <div style="color: #aaa;">快去合成你的第一个法宝吧！</div>
            </div>
        `;
        return;
    }
    
    // 添加收集进度条
    const progressContainer = document.createElement('div');
    progressContainer.style.gridColumn = '1 / -1';
    progressContainer.style.marginBottom = '20px';
    progressContainer.id = 'magicToolCollectionProgress';
    inventoryDiv.appendChild(progressContainer);
    
    // 更新收集进度
    updateCollectionProgress();
    
    // 按品级排序显示法宝
    const sortedTools = [...player.magicTools.inventory]
        .map(id => magicToolConfig.tools.find(t => t.id === id))
        .filter(tool => tool) // 过滤掉可能为null的值
        .sort((a, b) => a.tier - b.tier); // 按品级排序
    
    sortedTools.forEach(tool => {
        const isEquipped = player.magicTools.equipped === tool.id;
        const toolDiv = document.createElement('div');
        toolDiv.style.padding = '15px';
        toolDiv.style.background = isEquipped 
            ? `linear-gradient(145deg, ${tool.color}40, ${tool.color}20)` 
            : 'rgba(255,255,255,0.05)';
        toolDiv.style.borderRadius = '8px';
        toolDiv.style.border = `2px solid ${tool.color}`;
        toolDiv.style.position = 'relative';
        toolDiv.style.overflow = 'hidden';
        
        // 添加品级角标
        const tierBadge = document.createElement('div');
        tierBadge.style.position = 'absolute';
        tierBadge.style.top = '5px';
        tierBadge.style.right = '5px';
        tierBadge.style.background = tool.color;
        tierBadge.style.color = 'white';
        tierBadge.style.fontSize = '10px';
        tierBadge.style.padding = '2px 6px';
        tierBadge.style.borderRadius = '3px';
        tierBadge.style.fontWeight = 'bold';
        tierBadge.textContent = `T${tool.tier}`;
        toolDiv.appendChild(tierBadge);
        
        toolDiv.innerHTML += `
            <div style="font-size: 16px; font-weight: bold; color: ${tool.color}; margin-bottom: 5px; padding-right: 30px;">${tool.name}</div>
            <div style="font-size: 12px; color: #aaa; margin-bottom: 10px; min-height: 40px;">${tool.description}</div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <span style="color: #FFD700; font-weight: bold;">${tool.bonus.toFixed(1)}倍</span>
                <span style="font-size: 12px; color: #666;">
                    <span style="color: #4CAF50;">+1%</span> 收集加成
                </span>
            </div>
            ${isEquipped 
                ? '<button style="width: 100%; background: #f44336; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;" onclick="unequipMagicTool()">卸下</button>'
                : '<button style="width: 100%; background: #4CAF50; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer;" onclick="equipMagicTool(\'' + tool.id + '\')">装备</button>'
            }
        `;
        inventoryDiv.appendChild(toolDiv);
    });
}
// 选择材料（用于合成预览）
let selectedMagicMaterials = {};

function selectMagicMaterial(materialId) {
    const material = magicToolConfig.materials.find(m => m.id === materialId);
    if (!material) return;
    
    if (!selectedMagicMaterials[materialId]) {
        selectedMagicMaterials[materialId] = 0;
    }
    selectedMagicMaterials[materialId]++;
    
    updateMagicToolPreview();
}


// 更新合成预览
function updateMagicToolPreview() {
    const previewDiv = document.getElementById('magicToolPreview');
    const materialsInfo = document.getElementById('selectedMaterialsInfo');
    const craftButton = document.getElementById('craftButton');
    
    // 清空预览
    previewDiv.innerHTML = "选择材料查看可合成的法宝";
    craftButton.disabled = true;
    craftButton.style.background = '#555';
    craftButton.style.color = '#888';
    craftButton.textContent = '选择材料';
    
    if (Object.keys(selectedMagicMaterials).length === 0) {
        materialsInfo.textContent = "未选择材料";
        return;
    }
    
    // 显示已选择的材料
    let materialsText = "已选择材料: ";
    for (const [materialId, count] of Object.entries(selectedMagicMaterials)) {
        const material = magicToolConfig.materials.find(m => m.id === materialId);
        if (material) {
            const tierColor = getTierColor(material.tier);
            materialsText += `<span style="color: ${tierColor}">${material.name}×${count}</span> `;
        }
    }
    materialsInfo.innerHTML = materialsText;
    
    // 检查可以合成的法宝
    for (const tool of magicToolConfig.tools) {
        let canCraft = true;
        
        // 检查材料是否足够
        for (const [materialId, required] of Object.entries(tool.materials)) {
            const have = selectedMagicMaterials[materialId] || 0;
            if (have < required) {
                canCraft = false;
                break;
            }
        }
        
        if (canCraft) {
            // 检查是否已经拥有该法宝
            const alreadyOwned = player.magicTools.inventory.includes(tool.id);
            
            // 显示可以合成的法宝
            const tierColor = getTierColor(tool.tier);
            previewDiv.innerHTML = `
                <div style="width: 100%;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <div style="font-size: 30px;">${alreadyOwned ? '✅' : '🔮'}</div>
                        <div>
                            <div style="font-size: 22px; font-weight: bold; color: ${tool.color};">${alreadyOwned ? '已拥有' : '可以合成'}: ${tool.name}</div>
                            <div style="font-size: 12px; color: ${tierColor}; background: ${tierColor}20; padding: 2px 8px; border-radius: 10px; display: inline-block;">T${tool.tier} 法宝</div>
                        </div>
                    </div>
                    ${alreadyOwned ? 
                        '<div style="color: #f44336; margin-bottom: 15px; font-size: 14px; background: rgba(244, 67, 54, 0.1); padding: 8px; border-radius: 5px;">⚠️ 已拥有该法宝，无法重复获得</div>' : 
                        `<div style="color: #aaa; margin-bottom: 15px; font-size: 14px;">${tool.description}</div>`
                    }
                    <div style="color: #FFD700; font-weight: bold; font-size: 18px; margin-bottom: 10px;">修炼加成: ${tool.bonus.toFixed(1)}倍</div>
                    <div style="color: #4CAF50; font-size: 14px; margin-bottom: 15px;">收集加成: +1% 修炼速度</div>
                    <div style="margin-top: 10px;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 5px;">所需材料:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 5px;">${Object.entries(tool.materials).map(([id, required]) => {
                            const material = magicToolConfig.materials.find(m => m.id === id);
                            const hasMaterial = (player.magicTools.materials[id] || 0) >= required;
                            const isSelected = (selectedMagicMaterials[id] || 0) >= required;
                            return `<div style="background: ${isSelected ? (hasMaterial ? '#4CAF5040' : '#f4433640') : '#555'}; 
                                    color: ${isSelected ? (hasMaterial ? '#4CAF50' : '#f44336') : '#888'}; 
                                    padding: 3px 8px; border-radius: 5px; font-size: 11px;">
                                    ${material?.name}×${required} ${!hasMaterial ? '❌' : '✅'}
                                </div>`;
                        }).join('')}</div>
                    </div>
                </div>
            `;
            
            // 检查玩家是否已有足够材料且未拥有该法宝
            let hasAllMaterials = true;
            if (!alreadyOwned) {
                for (const [materialId, required] of Object.entries(tool.materials)) {
                    const have = player.magicTools.materials[materialId] || 0;
                    if (have < required) {
                        hasAllMaterials = false;
                        break;
                    }
                }
            }
            
            if (!alreadyOwned && hasAllMaterials) {
                craftButton.disabled = false;
                craftButton.style.background = `linear-gradient(45deg, ${tool.color}, ${tool.color}80)`;
                craftButton.style.color = 'white';
                craftButton.textContent = `合成 ${tool.name}`;
                craftButton.onclick = () => craftMagicTool(tool.id);
            } else if (alreadyOwned) {
                craftButton.textContent = '已拥有';
                craftButton.style.background = '#666';
                craftButton.style.color = '#aaa';
            } else {
                craftButton.textContent = '材料不足';
                craftButton.style.background = '#555';
                craftButton.style.color = '#888';
            }
            
            return;
        }
    }
    
    // 如果没有找到可合成的法宝
    previewDiv.innerHTML = `
        <div style="text-align: center; width: 100%;">
            <div style="font-size: 24px; margin-bottom: 10px;">❓</div>
            <div style="font-size: 18px; color: #aaa; margin-bottom: 10px;">无法合成法宝</div>
            <div style="color: #666; font-size: 14px;">当前材料组合无法合成任何法宝</div>
            <div style="color: #aaa; font-size: 12px; margin-top: 15px;">请尝试不同的材料组合</div>
        </div>
    `;
}


// 合成法宝
function craftMagicTool(toolId) {
    const tool = magicToolConfig.tools.find(t => t.id === toolId);
    if (!tool) return;
    
    // 检查是否已经拥有该法宝
    if (player.magicTools.inventory.includes(toolId)) {
        const errorMsg = `你已经拥有${tool.name}了！每个法宝只能获得一个。`;
        logAction(errorMsg, "error");
        showAlreadyOwnedNotification(tool);
        return;
    }
    
    // 检查材料是否足够
    let missingMaterials = [];
    for (const [materialId, required] of Object.entries(tool.materials)) {
        const have = player.magicTools.materials[materialId] || 0;
        if (have < required) {
            const material = magicToolConfig.materials.find(m => m.id === materialId);
            missingMaterials.push(`${material.name} (需要${required}个，只有${have}个)`);
        }
    }
    
    if (missingMaterials.length > 0) {
        const errorMsg = `材料不足！缺少: ${missingMaterials.join(', ')}`;
        logAction(errorMsg, "error");
        alert(`合成失败！\n\n缺少以下材料:\n${missingMaterials.join('\n')}`);
        return;
    }
    
    // 扣除材料
    for (const [materialId, required] of Object.entries(tool.materials)) {
        player.magicTools.materials[materialId] -= required;
    }
    
    // 添加法宝到库存
    player.magicTools.inventory.push(toolId);
    
    // 显示合成成功提示
    showCraftSuccessNotification(tool);
    
    // 更新收集加成显示
    updateCollectionProgress();
    
    // 重置选择
    clearSelection();
    
    logAction(`成功合成法宝: ${tool.name}！`, "success");
    updateMagicToolUI();
    updateDisplay();
    
    // 延迟显示收集加成信息
    setTimeout(showCollectionBonusInfo, 3500);
}
function showCraftSuccessNotification(tool) {
    const notification = document.createElement('div');
    notification.style.position = 'fixed';
    notification.style.top = '50%';
    notification.style.left = '50%';
    notification.style.transform = 'translate(-50%, -50%) scale(0.5)';
    notification.style.background = `linear-gradient(145deg, ${tool.color}40, ${tool.color}20)`;
    notification.style.color = 'white';
    notification.style.padding = '30px';
    notification.style.borderRadius = '20px';
    notification.style.border = `3px solid ${tool.color}`;
    notification.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
    notification.style.zIndex = '10000';
    notification.style.minWidth = '300px';
    notification.style.maxWidth = '400px';
    notification.style.textAlign = 'center';
    notification.style.opacity = '0';
    notification.style.transition = 'all 0.5s ease-out';
    
    notification.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 20px;">✨</div>
        <div style="font-size: 28px; font-weight: bold; color: ${tool.color}; margin-bottom: 10px;">合成成功！</div>
        <div style="font-size: 22px; font-weight: bold; margin-bottom: 15px;">${tool.name}</div>
        <div style="color: #aaa; margin-bottom: 20px;">${tool.description}</div>
        <div style="background: rgba(255, 215, 0, 0.2); padding: 10px; border-radius: 10px; margin-bottom: 20px;">
            <div style="font-size: 18px; color: #FFD700;">修炼加成: ${tool.bonus.toFixed(1)}倍</div>
        </div>
        <div style="color: #666; font-size: 14px;">该法宝已添加到你的法宝库中</div>
    `;
    
    document.body.appendChild(notification);
    
    // 动画显示
    setTimeout(() => {
        notification.style.opacity = '1';
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
    }, 10);
    
    // 动画隐藏
    setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translate(-50%, -50%) scale(0.5)';
        setTimeout(() => {
            if (notification.parentNode) {
                document.body.removeChild(notification);
            }
        }, 500);
    }, 3000);
}
function showAlreadyOwnedNotification(tool) {
    const notification = document.createElement('div');
    notification.style.position = 'fixed';
    notification.style.top = '50%';
    notification.style.left = '50%';
    notification.style.transform = 'translate(-50%, -50%) scale(0.5)';
    notification.style.background = `linear-gradient(145deg, #f4433640, #f4433620)`;
    notification.style.color = 'white';
    notification.style.padding = '30px';
    notification.style.borderRadius = '20px';
    notification.style.border = `3px solid #f44336`;
    notification.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
    notification.style.zIndex = '10000';
    notification.style.minWidth = '300px';
    notification.style.maxWidth = '400px';
    notification.style.textAlign = 'center';
    notification.style.opacity = '0';
    notification.style.transition = 'all 0.5s ease-out';
    
    notification.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 20px;">⚠️</div>
        <div style="font-size: 28px; font-weight: bold; color: #f44336; margin-bottom: 10px;">已拥有该法宝</div>
        <div style="font-size: 22px; font-weight: bold; margin-bottom: 15px;">${tool.name}</div>
        <div style="color: #aaa; margin-bottom: 20px;">每个法宝只能拥有一个</div>
        <div style="background: rgba(244, 67, 54, 0.2); padding: 10px; border-radius: 10px; margin-bottom: 20px;">
            <div style="font-size: 16px; color: #FFD700;">法宝收集加成已生效: +1%修炼速度</div>
        </div>
        <div style="color: #666; font-size: 14px;">继续收集其他法宝来获得更多加成！</div>
    `;
    
    document.body.appendChild(notification);
    
    // 动画显示
    setTimeout(() => {
        notification.style.opacity = '1';
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
    }, 10);
    
    // 动画隐藏
    setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translate(-50%, -50%) scale(0.5)';
        setTimeout(() => {
            if (notification.parentNode) {
                document.body.removeChild(notification);
            }
        }, 500);
    }, 3000);
}
function updateCollectionProgress() {
    const totalTools = magicToolConfig.tools.length;
    const ownedTools = player.magicTools.inventory.length;
    const progress = totalTools > 0 ? (ownedTools / totalTools) * 100 : 0;
    
    // 更新法宝收集进度显示
    const collectionProgressElement = document.getElementById('magicToolCollectionProgress');
    if (collectionProgressElement) {
        collectionProgressElement.innerHTML = `
            <div style="margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span style="color: #FFD700;">法宝收集进度</span>
                    <span style="color: #4CAF50;">${ownedTools}/${totalTools}</span>
                </div>
                <div style="background: #444; height: 10px; border-radius: 5px; overflow: hidden;">
                    <div style="height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); width: ${progress}%; transition: width 0.5s;"></div>
                </div>
            </div>
            <div style="color: #aaa; font-size: 12px; text-align: center;">
                每收集一个法宝获得1%修炼加成，当前加成: <span style="color: #FFD700;">${ownedTools}%</span>
            </div>
        `;
    }
}
// 装备法宝
function equipMagicTool(toolId) {
    if (!player.magicTools.inventory.includes(toolId)) {
        logAction("未拥有该法宝", "error");
        return;
    }
    
    player.magicTools.equipped = toolId;
    
    const tool = magicToolConfig.tools.find(t => t.id === toolId);
    if (tool) {
        logAction(`装备法宝: ${tool.name}`, "success");
    }
    
    updateMagicToolUI();
    updateCultivationExpUI(0, 1, 1); // 更新加成显示
}



// 卸下法宝
function unequipMagicTool() {
    player.magicTools.equipped = null;
    logAction("已卸下法宝", "info");
    updateMagicToolUI();
    updateCultivationExpUI(0, 1, 1); // 更新加成显示
}

// 材料掉落函数（在其他地方调用，掉落几率为1%）
function dropMagicMaterial() {
    // 基础掉落判定
    if (Math.random() > magicToolConfig.baseDropChance) {
        return false;
    }
    
    // 计算总权重
    let totalWeight = 0;
    magicToolConfig.materials.forEach(material => {
        totalWeight += material.dropChance;
    });
    
    // 随机选择材料
    let random = Math.random() * totalWeight;
    let selectedMaterial = null;
    
    for (const material of magicToolConfig.materials) {
        random -= material.dropChance;
        if (random <= 0) {
            selectedMaterial = material;
            break;
        }
    }
    
    if (selectedMaterial) {
        // 获得材料
        player.magicTools.materials[selectedMaterial.id] = (player.magicTools.materials[selectedMaterial.id] || 0) + 1;
        
        // 显示掉落提示
        showMaterialDropNotification(selectedMaterial);
        
        // 更新显示
        updateMagicToolUI();
        updateDisplay();
        
        return true;
    }
    
    return false;
}
function showMaterialDropNotification(material) {
    // 创建掉落提示元素
    const notification = document.createElement('div');
    notification.style.position = 'fixed';
    notification.style.top = '20px';
    notification.style.right = '20px';
    notification.style.background = `linear-gradient(145deg, ${material.color}40, ${material.color}20)`;
    notification.style.color = 'white';
    notification.style.padding = '15px 20px';
    notification.style.borderRadius = '10px';
    notification.style.borderLeft = `5px solid ${material.color}`;
    notification.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
    notification.style.zIndex = '9999';
    notification.style.minWidth = '200px';
    notification.style.maxWidth = '300px';
    notification.style.transform = 'translateX(400px)';
    notification.style.transition = 'transform 0.5s ease-out';
    notification.style.display = 'flex';
    notification.style.alignItems = 'center';
    notification.style.gap = '10px';
    
    // 添加图标
    const icon = document.createElement('div');
    icon.style.fontSize = '24px';
    icon.textContent = '✨';
    notification.appendChild(icon);
    
    // 添加内容
    const content = document.createElement('div');
    content.innerHTML = `
        <div style="font-weight: bold; color: ${material.color}; margin-bottom: 5px;">获得材料</div>
        <div style="font-size: 18px; font-weight: bold;">${material.name}</div>
        <div style="font-size: 12px; color: #FFD700; margin-top: 5px;">掉落几率: ${(material.dropChance * 100).toFixed(1)}%</div>
    `;
    notification.appendChild(content);
    
    // 添加到页面
    document.body.appendChild(notification);
    
    // 动画显示
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
    }, 10);
    
    // 动画隐藏
    setTimeout(() => {
        notification.style.transform = 'translateX(400px)';
        setTimeout(() => {
            if (notification.parentNode) {
                document.body.removeChild(notification);
            }
        }, 500);
    }, 3000);
    
    // 同时记录到日志
    logAction(`获得材料: ${material.name} (${(material.dropChance * 100).toFixed(1)}%几率)`, "success");
}
function initGambleStone() {
    if (!player.gambleStone) {
        player.gambleStone = {
            // 用户数据
            userData: {
                balance: 1000.00,                    // 赌石专用余额
                totalBet: 0,                         // 总下注金额
                totalWon: 0,                         // 总赢得金额
                totalLost: 0,                        // 总输掉金额
                winRate: 0,                          // 胜率
                streak: 0,                           // 当前连胜/连败
                maxStreak: 0,                        // 最大连胜
                minStreak: 0,                        // 最大连败
                gamesPlayed: 0,                      // 总游戏次数
                lastGameTime: 0,                     // 上次游戏时间
                luckyLevel: 1                        // 幸运等级
            },
            
            // 石头数据
           stones: [
                // 等级1：普通石头
                {
                    id: 1,
                    name: "普通原石",
                    cost: 100,
                    color: "#94a3b8",
                    quality: "普通",
                    minReward: 50,
                    maxReward: 300,
                    winChance: 0.25,      //25%胜率
                    jackpotChance: 0.01, // 1%大奖
                    description: "普通的石头，风险较低但回报有限"
                },
                // 等级2：中等石头
                {
                    id: 2,
                    name: "翡翠原石",
                    cost: 500,
                    color: "#10b981",
                    quality: "良好",
                    minReward: 200,
                    maxReward: 1500,
                    winChance: 0.20,      // 20%胜率
                    jackpotChance: 0.02, // 2%大奖
                    description: "有翡翠纹理的石头，中等风险"
                },
                // 等级3：高级石头
                {
                    id: 3,
                    name: "玛瑙原石",
                    cost: 2000,
                    color: "#8b5cf6",
                    quality: "优秀",
                    minReward: 800,
                    maxReward: 8000,
                    winChance: 0.15,     // 15%胜率
                    jackpotChance: 0.03, // 3%大奖
                    description: "色泽鲜艳的玛瑙原石，高风险高回报"
                },
                // 等级4：稀有石头
                {
                    id: 4,
                    name: "帝王翡翠",
                    cost: 10000,
                    color: "#f59e0b",
                    quality: "稀有",
                    minReward: 4000,
                    maxReward: 50000,
                    winChance: 0.13,     // 13%胜率
                    jackpotChance: 0.04, // 4%大奖
                    description: "帝王级别的翡翠，一刀天堂一刀地狱"
                },
                // 等级5：传说石头
                {
                    id: 5,
                    name: "龙血石",
                    cost: 50000,
                    color: "#ef4444",
                    quality: "传说",
                    minReward: 20000,
                    maxReward: 500000,
                    winChance: 0.07,     // 7%胜率
                    jackpotChance: 0.05, // 5%大奖
                    description: "传说中的龙血石，沾染龙血的神秘宝石"
                }
            ],
            
            // 当前选择的石头
            currentStoneId: 1,
            
            // 游戏状态
            gameState: {
                isCutting: false,
                lastResult: null,
                animationStep: 0,
                cutHistory: []
            },
            
            // 统计信息
            statistics: {
                biggestWin: 0,
                biggestLoss: 0,
                dailyBest: 0,
                luckyStones: [],
                unluckyStones: []
            },
            
            // 成就系统
            achievements: {
                firstCut: false,
                firstWin: false,
                firstJackpot: false,
                streak5: false,
                streak10: false,
                millionaire: false
            },
            
            // 设置
            settings: {
                soundEnabled: true,
                animationEnabled: true,
                autoCut: false,
                confirmCut: true
            }
        };
    }

    // 强制使用最新赌石配置（每次打开界面都会覆盖存档里的石头概率）
    if (player.gambleStone && Array.isArray(player.gambleStone.stones)) {
        player.gambleStone.stones.forEach(stone => {
            switch (stone.id) {
                case 1:
                    // 普通原石：胜率30% 大奖1%
                    stone.winChance = 0.30;
                    stone.jackpotChance = 0.01;
                    break;
                case 2:
                    // 翡翠原石：胜率25% 大奖2%
                    stone.winChance = 0.25;
                    stone.jackpotChance = 0.02;
                    break;
                case 3:
                    // 玛瑙原石：胜率20% 大奖3%
                    stone.winChance = 0.20;
                    stone.jackpotChance = 0.03;
                    break;
                case 4:
                    // 帝王翡翠：胜率15% 大奖4%
                    stone.winChance = 0.15;
                    stone.jackpotChance = 0.04;
                    break;
                case 5:
                    // 龙血石：胜率8% 大奖5%
                    stone.winChance = 0.08;
                    stone.jackpotChance = 0.05;
                    break;
            }
        });
    }
}
// 切换赌石界面
function toggleGambleStone() {
    if (player.investmentGame.userData.totalAssets < 5000) {
        alert("需要在投资游戏中拥有至少5000元资产才能开启赌石系统！");
        return;
    }
    
    const ui = document.getElementById('gambleStoneUI');
    if (ui.style.display === 'none') {
        // 初始化数据
        initGambleStone();
        
        // 同步资金
        syncGambleBalance();
        
        // 生成界面
        renderGambleStone();
        ui.style.display = 'block';
    } else {
        closeGambleStone();
    }
}

// 关闭赌石系统
function closeGambleStone() {
    const ui = document.getElementById('gambleStoneUI');
    ui.style.display = 'none';
    saveGame();
}

// 同步资金
function syncGambleBalance() {
    const gamble = player.gambleStone;
    if (!gamble) return;
    
    // 可以从投资游戏转移资金
    if (gamble.userData.balance < 100) {
        const transfer = Math.min(1000, player.investmentGame.userData.availableFunds * 0.1);
        if (transfer > 10) {
            player.investmentGame.userData.availableFunds -= transfer;
            gamble.userData.balance += transfer;
            showGambleNotification(`从投资账户转入 ${transfer.toFixed(2)} 元`, 'info');
        }
    }
}

// 渲染赌石界面
function renderGambleStone() {
    const content = document.getElementById('gambleStoneContent');
    const gamble = player.gambleStone;
    const currentStone = gamble.stones.find(s => s.id === gamble.currentStoneId);
    
    content.innerHTML = `
        <style>
            .gamble-stone * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            }
            
            .gamble-stone {
                background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
                color: #e2e8f0;
                min-height: 100%;
                padding: 20px;
            }
            
            .gamble-header {
                text-align: center;
                margin-bottom: 30px;
                padding-bottom: 20px;
                border-bottom: 2px solid #334155;
                position: relative;
            }
            
            .gamble-header h1 {
                color: #fbbf24;
                font-size: 2.5rem;
                margin-bottom: 10px;
                text-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
            }
            
            .gamble-header .subtitle {
                color: #94a3b8;
                font-size: 1.1rem;
            }
            
            .balance-section {
                background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
                border-radius: 15px;
                padding: 25px;
                margin-bottom: 30px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                border: 1px solid #475569;
            }
            
            .balance-stats {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 20px;
                margin-top: 15px;
            }
            
            .balance-item {
                text-align: center;
                padding: 15px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                border: 1px solid #475569;
            }
            
            .balance-label {
                color: #94a3b8;
                font-size: 0.9rem;
                margin-bottom: 5px;
            }
            
            .balance-value {
                color: #f8fafc;
                font-size: 1.5rem;
                font-weight: bold;
            }
            
            .balance-value.positive {
                color: #10b981;
            }
            
            .balance-value.negative {
                color: #ef4444;
            }
            
            .stones-selection {
                margin-bottom: 30px;
            }
            
            .stones-title {
                color: #f8fafc;
                font-size: 1.3rem;
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                gap: 10px;
            }
            
            .stones-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 20px;
            }
            
            .stone-card {
                background: linear-gradient(135deg, var(--stone-color)20, #1e293b);
                border: 2px solid var(--stone-color);
                border-radius: 12px;
                padding: 20px;
                cursor: pointer;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }
            
            .stone-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 10px 20px rgba(var(--stone-rgb), 0.3);
            }
            
            .stone-card.selected {
                background: linear-gradient(135deg, var(--stone-color)40, #1e293b);
                box-shadow: 0 0 20px rgba(var(--stone-rgb), 0.5);
            }
            
            .stone-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }
            
            .stone-name {
                font-size: 1.2rem;
                font-weight: bold;
                color: var(--stone-color);
            }
            
            .stone-quality {
                padding: 4px 12px;
                background: rgba(var(--stone-rgb), 0.2);
                border-radius: 20px;
                font-size: 0.8rem;
                font-weight: bold;
                color: var(--stone-color);
            }
            
            .stone-cost {
                color: #fbbf24;
                font-size: 1.3rem;
                font-weight: bold;
                margin-bottom: 10px;
            }
            
            .stone-info {
                color: #cbd5e1;
                font-size: 0.9rem;
                margin-bottom: 15px;
            }
            
            .stone-chance {
                display: flex;
                justify-content: space-between;
                margin-top: 10px;
                font-size: 0.85rem;
                color: #94a3b8;
            }
            
            .stone-chance-item span {
                color: #f8fafc;
                font-weight: bold;
            }
            
            .game-section {
                background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
                border-radius: 15px;
                padding: 25px;
                margin-bottom: 30px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                border: 1px solid #475569;
                text-align: center;
            }
            
            .stone-display {
                width: 200px;
                height: 200px;
                margin: 0 auto 30px;
                background: linear-gradient(45deg, var(--stone-color)30, #1e293b);
                border: 3px solid var(--stone-color);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 3rem;
                color: var(--stone-color);
                box-shadow: 0 0 30px rgba(var(--stone-rgb), 0.5);
                transition: all 0.5s ease;
                position: relative;
                overflow: hidden;
            }
            
            .stone-display.cutting {
                animation: pulse 1s infinite;
            }
            
            .stone-display.result-win {
                animation: winPulse 1s 3;
            }
            
            .stone-display.result-lose {
                animation: losePulse 1s 3;
            }
            
            @keyframes pulse {
                0% { box-shadow: 0 0 20px rgba(var(--stone-rgb), 0.5); }
                50% { box-shadow: 0 0 40px rgba(var(--stone-rgb), 0.8); }
                100% { box-shadow: 0 0 20px rgba(var(--stone-rgb), 0.5); }
            }
            
            @keyframes winPulse {
                0% { box-shadow: 0 0 20px #10b981; }
                50% { box-shadow: 0 0 60px #10b981; }
                100% { box-shadow: 0 0 20px #10b981; }
            }
            
            @keyframes losePulse {
                0% { box-shadow: 0 0 20px #ef4444; }
                50% { box-shadow: 0 0 60px #ef4444; }
                100% { box-shadow: 0 0 20px #ef4444; }
            }
            
            .cut-btn {
                background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
                color: white;
                border: none;
                padding: 18px 50px;
                border-radius: 12px;
                font-size: 1.3rem;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 5px 15px rgba(245, 158, 11, 0.4);
                margin: 20px 0;
            }
            
            .cut-btn:hover:not(:disabled) {
                transform: translateY(-3px);
                box-shadow: 0 8px 20px rgba(245, 158, 11, 0.6);
            }
            
            .cut-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            
            .result-display {
                margin-top: 30px;
                padding: 20px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 12px;
                border: 1px solid #475569;
                display: none;
            }
            
            .result-title {
                font-size: 1.5rem;
                font-weight: bold;
                margin-bottom: 15px;
            }
            
            .result-amount {
                font-size: 2.5rem;
                font-weight: bold;
                margin: 10px 0;
            }
            
            .result-amount.win {
                color: #10b981;
            }
            
            .result-amount.lose {
                color: #ef4444;
            }
            
            .result-message {
                color: #cbd5e1;
                margin: 10px 0;
            }
            
            .history-section {
                margin-top: 40px;
                padding-top: 20px;
                border-top: 1px solid #334155;
            }
            
            .history-title {
                color: #f8fafc;
                font-size: 1.3rem;
                margin-bottom: 20px;
            }
            
            .history-list {
                max-height: 200px;
                overflow-y: auto;
            }
            
            .history-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 15px;
                margin-bottom: 8px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 8px;
                border-left: 4px solid var(--history-color);
            }
            
            .history-stone {
                font-weight: bold;
                color: var(--history-color);
            }
            
            .history-result {
                font-weight: bold;
            }
            
            .history-result.win {
                color: #10b981;
            }
            
            .history-result.lose {
                color: #ef4444;
            }
            
            .transfer-section {
                display: flex;
                gap: 15px;
                margin-top: 20px;
            }
            
            .transfer-input {
                flex: 1;
                padding: 12px 15px;
                background: #1e293b;
                border: 1px solid #475569;
                border-radius: 8px;
                color: #f8fafc;
                font-size: 1rem;
            }
            
            .transfer-btn {
                padding: 12px 25px;
                background: #3b82f6;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
            }
            
            .transfer-btn:hover {
                background: #2563eb;
            }
            
            @media (max-width: 768px) {
                .balance-stats {
                    grid-template-columns: 1fr;
                }
                
                .stones-grid {
                    grid-template-columns: 1fr;
                }
                
                .transfer-section {
                    flex-direction: column;
                }
            .transfer-in {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
}

.transfer-out {
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
}

.transfer-in:hover {
    background: linear-gradient(135deg, #34d399 0%, #10b981 100%);
}

.transfer-out:hover {
    background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
}

.transfer-buttons {
    display: flex;
    gap: 10px;
}

.transfer-info {
    margin-top: 10px;
    padding: 10px;
    border-radius: 6px;
    font-size: 0.9rem;
    display: none;
}

.transfer-info.success {
    background: rgba(16, 185, 129, 0.2);
    border: 1px solid #10b981;
    color: #10b981;
}

.transfer-info.error {
    background: rgba(239, 68, 68, 0.2);
    border: 1px solid #ef4444;
    color: #ef4444;
}

.transfer-info.info {
    background: rgba(59, 130, 246, 0.2);
    border: 1px solid #3b82f6;
    color: #3b82f6;
}
            }
        </style>
        
        <div class="gamble-stone">
            <div class="gamble-header">
                <h1><i class="fas fa-gem"></i> 赌石系统</h1>
                <p class="subtitle">一刀穷，一刀富，一刀穿麻布</p>
            </div>
            
            <div class="balance-section">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: #94a3b8; font-size: 0.9rem;">当前余额</div>
                        <div class="balance-value" style="font-size: 2.5rem; color: #fbbf24;">
                            ¥ ${gamble.userData.balance.toLocaleString(undefined, {minimumFractionDigits: 2})}
                        </div>
                    </div>
                    <div class="transfer-section">
    <input type="number" id="transfer-amount" class="transfer-input" placeholder="转账金额" 
           min="0" max="${Math.max(player.investmentGame.userData.availableFunds, gamble.userData.balance)}">
    <div style="display: flex; gap: 10px;">
        <button class="transfer-btn transfer-in" id="transfer-from-invest">
            <i class="fas fa-arrow-right"></i> 转入
        </button>
        <button class="transfer-btn transfer-out" id="transfer-to-invest">
            <i class="fas fa-arrow-left"></i> 转出
        </button>
    </div>
</div>

<!-- 添加提示信息 -->
<div id="transfer-info" style="margin-top: 10px; font-size: 0.9rem; color: #94a3b8; display: none;">
    <!-- 转账提示信息 -->
</div>
   </div>             
                <div class="balance-stats">
                    <div class="balance-item">
                        <div class="balance-label">总盈亏</div>
                        <div class="balance-value ${gamble.userData.totalWon - gamble.userData.totalLost >= 0 ? 'positive' : 'negative'}">
                            ${(gamble.userData.totalWon - gamble.userData.totalLost).toLocaleString(undefined, {minimumFractionDigits: 2})}
                        </div>
                    </div>
                    <div class="balance-item">
                        <div class="balance-label">胜率</div>
                        <div class="balance-value">
                            ${gamble.userData.gamesPlayed > 0 ? (gamble.userData.winRate * 100).toFixed(1) : 0}%
                        </div>
                    </div>
                    <div class="balance-item">
                        <div class="balance-label">当前连胜</div>
                        <div class="balance-value ${gamble.userData.streak >= 0 ? 'positive' : 'negative'}">
                            ${gamble.userData.streak >= 0 ? '+' : ''}${gamble.userData.streak}
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="stones-selection">
                <div class="stones-title">
                    <i class="fas fa-dice"></i> 选择原石
                </div>
                <div class="stones-grid">
                    ${gamble.stones.map(stone => `
                        <div class="stone-card ${gamble.currentStoneId === stone.id ? 'selected' : ''}" 
                             data-id="${stone.id}"
                             style="--stone-color: ${stone.color}; --stone-rgb: ${hexToRgb(stone.color)};">
                            <div class="stone-header">
                                <div class="stone-name">${stone.name}</div>
                                <div class="stone-quality">${stone.quality}</div>
                            </div>
                            <div class="stone-cost">¥ ${stone.cost.toLocaleString()}</div>
                            <div class="stone-info">${stone.description}</div>
                            <div class="stone-chance">
                                <div class="stone-chance-item">
                                    胜率: <span>${(stone.winChance * 100).toFixed(1)}%</span>
                                </div>
                                <div class="stone-chance-item">
                                    大奖: <span>${(stone.jackpotChance * 100).toFixed(1)}%</span>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <div class="game-section">
                <div class="stone-display" id="stone-display" 
                     style="--stone-color: ${currentStone.color}; --stone-rgb: ${hexToRgb(currentStone.color)};">
                    <i class="fas fa-gem"></i>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 1.2rem; color: #f8fafc; margin-bottom: 10px;">
                        ${currentStone.name}
                    </div>
                    <div style="color: #94a3b8; margin-bottom: 20px;">
                        花费: <span style="color: #fbbf24; font-weight: bold;">¥ ${currentStone.cost.toLocaleString()}</span>
                    </div>
                </div>
                
                <button class="cut-btn" id="cut-btn" ${gamble.userData.balance < currentStone.cost ? 'disabled' : ''}>
                    <i class="fas fa-cut"></i> 开始切割
                </button>
                
                <div class="result-display" id="result-display">
                    <!-- 结果将通过JS动态显示 -->
                </div>
            </div>
            
            <div class="history-section">
                <div class="history-title">
                    <i class="fas fa-history"></i> 切割记录
                </div>
                <div class="history-list" id="history-list">
                    ${renderHistoryList()}
                </div>
            </div>
            
            <!-- 通知 -->
            <div class="gamble-notification" id="gamble-notification"></div>
        </div>
    `;
    
    // 初始化事件监听
    initGambleEventListeners();
}
// 将十六进制颜色转为RGB
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? 
        `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
        '150, 150, 150';
}

// 渲染历史记录
function renderHistoryList() {
    const gamble = player.gambleStone;
    const history = gamble.gameState.cutHistory.slice(-10).reverse(); // 只显示最近10条
    
    if (history.length === 0) {
        return '<div style="color: #64748b; text-align: center; padding: 20px;">暂无切割记录</div>';
    }
    
    return history.map(record => {
        const stone = gamble.stones.find(s => s.id === record.stoneId);
        const isWin = record.result > 0;
        const resultClass = isWin ? 'win' : 'lose';
        const resultSign = isWin ? '+' : '';
        
        return `
            <div class="history-item" style="--history-color: ${stone.color}">
                <div class="history-stone">${stone.name}</div>
                <div class="history-result ${resultClass}">
                    ${resultSign}¥ ${record.result.toLocaleString()}
                </div>
            </div>
        `;
    }).join('');
}
// 切割石头的主要函数
function cutStone() {
    const gamble = player.gambleStone;
    const stone = gamble.stones.find(s => s.id === gamble.currentStoneId);
    
    // 检查余额
    if (gamble.userData.balance < stone.cost) {
        showGambleNotification('余额不足！', 'error');
        return;
    }
    
    // 设置切割状态
    gamble.gameState.isCutting = true;
    
    // 扣除费用
    gamble.userData.balance -= stone.cost;
    gamble.userData.totalBet += stone.cost;
    
    // 更新按钮状态
    const cutBtn = document.getElementById('cut-btn');
    const stoneDisplay = document.getElementById('stone-display');
    const resultDisplay = document.getElementById('result-display');
    
    cutBtn.disabled = true;
    cutBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 切割中...';
    stoneDisplay.classList.add('cutting');
    resultDisplay.style.display = 'none';
    
    // 模拟切割过程
    setTimeout(() => {
        // 计算结果
        const result = calculateStoneResult(stone);
        
        // 显示结果
        showCutResult(result, stone);
        
        // 更新用户数据
        updateUserAfterCut(result, stone);
        
        // 重置切割状态
        gamble.gameState.isCutting = false;
        cutBtn.disabled = gamble.userData.balance < stone.cost;
        cutBtn.innerHTML = '<i class="fas fa-cut"></i> 开始切割';
        stoneDisplay.classList.remove('cutting');
        
        // 保存游戏
        saveGame();
        
    }, 2000); // 2秒切割动画
}

// 计算结果
function calculateStoneResult(stone) {
    const gamble = player.gambleStone;
    const random = Math.random();
    
    // 计算幸运修正（幸运等级会影响结果）
    const luckyBonus = (gamble.userData.luckyLevel - 1) * 0.02;
    
    if (random < stone.jackpotChance + luckyBonus) {
        // 大奖！
        const jackpotMultiplier = 5 + Math.random() * 10; // 5-15倍
        return {
            type: 'jackpot',
            amount: stone.cost * jackpotMultiplier,
            multiplier: jackpotMultiplier,
            message: '🎉 恭喜！开出绝世珍宝！'
        };
    } else if (random < stone.winChance + stone.jackpotChance + luckyBonus) {
        // 普通胜利
        const winMultiplier = 1.5 + Math.random() * 2.5; // 1.5-4倍
        return {
            type: 'win',
            amount: stone.cost * winMultiplier,
            multiplier: winMultiplier,
            message: '🎊 恭喜！开出了好料！'
        };
    } else {
        // 失败
        const loseMultiplier = Math.random() * 0.5; // 0-0.5倍（可能挽回部分损失）
        return {
            type: 'lose',
            amount: stone.cost * loseMultiplier,
            multiplier: loseMultiplier,
            message: '😢 可惜，石头内部是空的...'
        };
    }
}

// 显示切割结果
function showCutResult(result, stone) {
    const resultDisplay = document.getElementById('result-display');
    const stoneDisplay = document.getElementById('stone-display');
    
    // 添加结果动画
    if (result.type === 'win' || result.type === 'jackpot') {
        stoneDisplay.classList.add('result-win');
    } else {
        stoneDisplay.classList.add('result-lose');
    }
    
    // 显示结果信息
    resultDisplay.innerHTML = `
        <div class="result-title">${result.type === 'jackpot' ? '🎉 头奖！' : result.type === 'win' ? '🎊 胜利！' : '😢 失败'}</div>
        <div class="result-amount ${result.type === 'lose' ? 'lose' : 'win'}">
            ${result.type === 'lose' ? '-' : '+'}¥ ${result.amount.toLocaleString(undefined, {minimumFractionDigits: 2})}
        </div>
        <div class="result-message">
            ${result.message}
        </div>
        <div style="color: #94a3b8; font-size: 0.9rem; margin-top: 10px;">
            倍率: ${result.multiplier.toFixed(2)}x | 
            石头: ${stone.name}
        </div>
    `;
    
    resultDisplay.style.display = 'block';
    
    // 移除动画
    setTimeout(() => {
        stoneDisplay.classList.remove('result-win', 'result-lose');
    }, 3000);
}

// 更新用户数据
function updateUserAfterCut(result, stone) {
    const gamble = player.gambleStone;
    
    // 更新余额
    gamble.userData.balance += result.amount;
    
    // 更新统计
    if (result.type === 'lose') {
        gamble.userData.totalLost += stone.cost;
        
        // 更新连胜
        if (gamble.userData.streak > 0) gamble.userData.streak = 0;
        gamble.userData.streak--;
        gamble.userData.minStreak = Math.min(gamble.userData.minStreak, gamble.userData.streak);
    } else {
        gamble.userData.totalWon += result.amount;
        
        // 更新连胜
        if (gamble.userData.streak < 0) gamble.userData.streak = 0;
        gamble.userData.streak++;
        gamble.userData.maxStreak = Math.max(gamble.userData.maxStreak, gamble.userData.streak);
        
        // 检查大奖
        if (result.type === 'jackpot') {
            checkAchievement('firstJackpot');
            gamble.statistics.biggestWin = Math.max(gamble.statistics.biggestWin, result.amount);
        }
    }
    
    // 更新总游戏次数和胜率
    gamble.userData.gamesPlayed++;
    gamble.userData.winRate = (gamble.userData.gamesPlayed - 
        Math.floor((gamble.userData.streak < 0 ? -gamble.userData.streak : 0))) / 
        gamble.userData.gamesPlayed;
    
    // 记录历史
    gamble.gameState.cutHistory.push({
        stoneId: stone.id,
        stoneName: stone.name,
        cost: stone.cost,
        result: result.type === 'lose' ? -stone.cost + result.amount : result.amount,
        type: result.type,
        time: Date.now()
    });
    
    // 只保留最近10条记录
    if (gamble.gameState.cutHistory.length > 10) {
        gamble.gameState.cutHistory.shift();
    }
    
    // 更新界面
    updateGambleStatsDisplay();
    updateHistoryList();
    
  
}
// 初始化赌石事件监听
function initGambleEventListeners() {
    // 选择石头卡片
    document.querySelectorAll('.stone-card').forEach(card => {
        card.addEventListener('click', function() {
            const stoneId = parseInt(this.getAttribute('data-id'));
            player.gambleStone.currentStoneId = stoneId;
            
            // 更新选中状态
            document.querySelectorAll('.stone-card').forEach(c => {
                c.classList.remove('selected');
            });
            this.classList.add('selected');
            
            // 更新石头显示
            const stone = player.gambleStone.stones.find(s => s.id === stoneId);
            const stoneDisplay = document.getElementById('stone-display');
            stoneDisplay.style.setProperty('--stone-color', stone.color);
            stoneDisplay.style.setProperty('--stone-rgb', hexToRgb(stone.color));
            
            // 更新按钮状态
            const cutBtn = document.getElementById('cut-btn');
            cutBtn.disabled = player.gambleStone.userData.balance < stone.cost;
            
            // 更新显示
            const gameSection = document.querySelector('.game-section');
            const nameElement = gameSection.querySelector('.stone-display').nextElementSibling;
            if (nameElement) {
                nameElement.innerHTML = `
                    <div style="font-size: 1.2rem; color: #f8fafc; margin-bottom: 10px;">
                        ${stone.name}
                    </div>
                    <div style="color: #94a3b8; margin-bottom: 20px;">
                        花费: <span style="color: #fbbf24; font-weight: bold;">¥ ${stone.cost.toLocaleString()}</span>
                    </div>
                `;
            }
        });
    });
     // 切割按钮
    const cutBtn = document.getElementById('cut-btn');
    if (cutBtn) {
        cutBtn.addEventListener('click', cutStone);
    }
  
    
    // 转账按钮
const transferInBtn = document.getElementById('transfer-from-invest');
const transferOutBtn = document.getElementById('transfer-to-invest');
const transferInput = document.getElementById('transfer-amount');
const transferInfo = document.getElementById('transfer-info');

// 从投资转入赌石（原有的）
if (transferInBtn && transferInput) {
    transferInBtn.addEventListener('click', function() {
        transferFunds('in');
    });
}

// 从赌石转出到投资（新增的）
if (transferOutBtn && transferInput) {
    transferOutBtn.addEventListener('click', function() {
        transferFunds('out');
    });
}

// 输入框监听，实时更新最大可转金额
if (transferInput) {
    transferInput.addEventListener('input', updateTransferLimits);
}
}
function transferFunds(direction) {
    const gamble = player.gambleStone;
    const investment = player.investmentGame;
    const amountInput = document.getElementById('transfer-amount');
    const amount = parseFloat(amountInput.value);
    
    // 验证输入
    if (!amount || amount <= 0) {
        showTransferInfo('请输入有效金额', 'error');
        return;
    }
    
    // 根据方向进行转账
    if (direction === 'in') {
        // 从投资转入赌石
        if (amount > investment.userData.availableFunds) {
            showTransferInfo('投资账户余额不足', 'error');
            return;
        }
        
        if (amount > 1000000) {
            showTransferInfo('单次转账不能超过100W元', 'error');
            return;
        }
        
        // 执行转账
        investment.userData.availableFunds -= amount;
        gamble.userData.balance += amount;
        
        showTransferInfo(`成功转入 ¥${amount.toLocaleString()} 到赌石账户`, 'success');
        
    } else if (direction === 'out') {
        // 从赌石转出到投资
        if (amount > gamble.userData.balance) {
            showTransferInfo('赌石账户余额不足', 'error');
            return;
        }
        
        if (amount > 1000000) {
            showTransferInfo('单次转账不能超过100W元', 'error');
            return;
        }
        
        
        // 执行转账
        gamble.userData.balance -= amount;
        investment.userData.availableFunds += amount;
        
        showTransferInfo(`成功转出 ¥${amount.toLocaleString()} 到投资账户`, 'success');
    }
    
    // 更新显示
    updateTransferLimits();
    updateGambleStatsDisplay();
    
    // 更新切割按钮状态
    const cutBtn = document.getElementById('cut-btn');
    if (cutBtn) {
        const stone = gamble.stones.find(s => s.id === gamble.currentStoneId);
        cutBtn.disabled = gamble.userData.balance < stone.cost;
    }
    
    // 重置输入框
    amountInput.value = '';
    
    // 保存游戏
    saveGame();
}
function showTransferInfo(message, type) {
    const infoElement = document.getElementById('transfer-info');
    if (!infoElement) return;
    
    infoElement.textContent = message;
    infoElement.className = `transfer-info ${type}`;
    infoElement.style.display = 'block';
    
    // 3秒后隐藏
    setTimeout(() => {
        infoElement.style.display = 'none';
    }, 3000);
}

// 更新转账限制和显示
function updateTransferLimits() {
    const gamble = player.gambleStone;
    const investment = player.investmentGame;
    const amountInput = document.getElementById('transfer-amount');
    const transferInfo = document.getElementById('transfer-info');
    
    if (!amountInput) return;
    
    // 获取当前余额
    const investBalance = investment.userData.availableFunds;
    const gambleBalance = gamble.userData.balance;
    
    // 更新输入框的最大值
    amountInput.max = Math.max(investBalance, gambleBalance);
    
    // 实时显示可转金额提示
    const amount = parseFloat(amountInput.value) || 0;
    
    if (amount > 0) {
        if (amount > 100000) {
            showTransferInfo('⚠️ 单次转账限额100,000元', 'error');
        } else if (amount > investBalance && amount > gambleBalance) {
            showTransferInfo('❌ 两个账户余额都不足', 'error');
        } else if (amount > investBalance) {
            showTransferInfo(`⚠️ 投资账户余额不足，最多可转 ¥${investBalance.toLocaleString()}`, 'error');
        } else if (amount > gambleBalance) {
            showTransferInfo(`⚠️ 赌石账户余额不足，最多可转 ¥${gambleBalance.toLocaleString()}`, 'error');
        } else {
            showTransferInfo(`✅ 可转金额: 转入最大 ¥${investBalance.toLocaleString()} | 转出最大 ¥${gambleBalance.toLocaleString()}`, 'info');
        }
    }
}
// 更新统计显示
function updateGambleStatsDisplay() {
    const gamble = player.gambleStone;
    const balanceValue = document.querySelector('.balance-value');
    const totalWinLoss = document.querySelector('.balance-stats .balance-item:nth-child(1) .balance-value');
    const winRate = document.querySelector('.balance-stats .balance-item:nth-child(2) .balance-value');
    const streak = document.querySelector('.balance-stats .balance-item:nth-child(3) .balance-value');
    
    if (balanceValue) {
        balanceValue.textContent = `¥ ${gamble.userData.balance.toLocaleString(undefined, {minimumFractionDigits: 2})}`;
    }
    
    if (totalWinLoss) {
        const net = gamble.userData.totalWon - gamble.userData.totalLost;
        totalWinLoss.textContent = net.toLocaleString(undefined, {minimumFractionDigits: 2});
        totalWinLoss.className = `balance-value ${net >= 0 ? 'positive' : 'negative'}`;
    }
    
    if (winRate) {
        winRate.textContent = `${(gamble.userData.winRate * 100).toFixed(1)}%`;
    }
    
    if (streak) {
        streak.textContent = `${gamble.userData.streak >= 0 ? '+' : ''}${gamble.userData.streak}`;
        streak.className = `balance-value ${gamble.userData.streak >= 0 ? 'positive' : 'negative'}`;
    }
}

// 更新历史记录
function updateHistoryList() {
    const historyList = document.getElementById('history-list');
    if (historyList) {
        historyList.innerHTML = renderHistoryList();
    }
}

// 显示赌石通知
function showGambleNotification(message, type) {
    let notification = document.getElementById('gamble-notification');
    if (!notification) {
        notification = document.createElement('div');
        notification.id = 'gamble-notification';
        notification.className = 'gamble-notification';
        document.querySelector('.gamble-stone').appendChild(notification);
    }
    
    notification.textContent = message;
    notification.className = `gamble-notification ${type}`;
    notification.style.display = 'block';
    
    // 添加通知样式
    if (!document.querySelector('#gamble-notification-style')) {
        const style = document.createElement('style');
        style.id = 'gamble-notification-style';
        style.textContent = `
            .gamble-notification {
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                color: white;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
                display: none;
                z-index: 1004;
                animation: gambleSlideIn 0.3s ease;
                font-weight: bold;
            }
            
            .gamble-notification.success {
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                border: 2px solid #34d399;
            }
            
            .gamble-notification.error {
                background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                border: 2px solid #fca5a5;
            }
            
            .gamble-notification.info {
                background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
                border: 2px solid #93c5fd;
            }
            
            @keyframes gambleSlideIn {
                from {transform: translateX(100%); opacity: 0;}
                to {transform: translateX(0); opacity: 1;}
            }
        `;
        document.head.appendChild(style);
    }
    
    setTimeout(() => {
        notification.style.display = 'none';
    }, 3000);
}
// 年兽副本全局变量
let nianBeastGame = {
    isInBattle: false,
    playerHp: 0,
    playerMaxHp: 0,
    playerAtk: 0,
    playerCrit: 0,
    playerCritRate: 0.3,
    
    beastLevel: 1,
    beastMaxHp: 1e5,
    beastCurrentHp: 1e5,
    beastAtk: 1e2,
    beastReviveCount: 3,
    beastDefense: 50000,
    beastMultiplier: 1,
    
    isDefending: false,
    hasTokenCost: false,
    
    // 年兽技能相关
   lastSkill: '',
    skillCombo: 0,
    lastComboSkill: '',
    skillTriggeredDeath: false,
    totalDamageDealt: 0
};
function hasChaosCauldron() {
    if (!player.magicTools || !player.magicTools.equipped) {
        return false;
    }
    
   
    return player.magicTools.equipped === 'yin_yang_mirrorbaab';
}

function getChaosCauldronBonus() {
    return hasChaosCauldron() ? 20 : 1; 
}
// 年兽技能配置
let nianBeastSkills = [
    {
        name: '普通爪击',
        description: '普通的攻击',
        multiplier: 1.0,
        chance: 0.40, // 40%几率
        message: '🐅 年兽挥爪攻击',
        color: '#aaa',
        icon: '🐾'
    },
    {
        name: '愤怒咆哮',
        description: '发出震耳欲聋的咆哮',
        multiplier: 1.2,
        chance: 0.25, // 25%几率
        message: '😤 年兽愤怒咆哮！造成1.2倍伤害',
        color: '#FF9800',
        icon: '😤'
    },
    {
        name: '猛虎扑击',
        description: '全力扑向敌人',
        multiplier: 1.5,
        chance: 0.20, // 20%几率
        message: '🐯 年兽猛虎扑击！造成1.5倍伤害',
        color: '#FF5722',
        icon: '🐯'
    },
    {
        name: '年兽冲撞',
        description: '以身体猛烈冲撞',
        multiplier: 2.0,
        chance: 0.10, // 10%几率
        message: '💥 年兽冲撞！造成2倍伤害',
        color: '#f44336',
        icon: '💥'
    },
    {
        name: '除夕灾厄',
        description: '传说中的年兽最强技能',
        multiplier: 5.0,
        chance: 0.05, // 5%几率
        message: '🌪️ 除夕灾厄！！！造成5倍毁灭性打击',
        color: '#FFD700',
        icon: '🌪️'
    }
];

// 基础技能配置（用于重置）
const baseNianBeastSkills = [
    {
        name: '普通爪击',
        description: '普通的攻击',
        multiplier: 1.0,
        chance: 0.40,
        message: '🐅 年兽挥爪攻击',
        color: '#aaa',
        icon: '🐾'
    },
    {
        name: '愤怒咆哮',
        description: '发出震耳欲聋的咆哮',
        multiplier: 1.2,
        chance: 0.25,
        message: '😤 年兽愤怒咆哮！造成1.2倍伤害',
        color: '#FF9800',
        icon: '😤'
    },
    {
        name: '猛虎扑击',
        description: '全力扑向敌人',
        multiplier: 1.5,
        chance: 0.20,
        message: '🐯 年兽猛虎扑击！造成1.5倍伤害',
        color: '#FF5722',
        icon: '🐯'
    },
    {
        name: '年兽冲撞',
        description: '以身体猛烈冲撞',
        multiplier: 2.0,
        chance: 0.10,
        message: '💥 年兽冲撞！造成2倍伤害',
        color: '#f44336',
        icon: '💥'
    },
    {
        name: '除夕灾厄',
        description: '传说中的年兽最强技能',
        multiplier: 5.0,
        chance: 0.05,
        message: '🌪️ 除夕灾厄！！！造成5倍毁灭性打击',
        color: '#FFD700',
        icon: '🌪️'
    }
];

// 年兽特殊状态技能（低血量时触发）
const nianBeastSpecialSkills = [
    {
        name: '垂死挣扎',
        description: '濒死时的疯狂反击',
        multiplier: 3.0,
        hpThreshold: 0.20, // 血量低于20%触发
        message: '⚡ 年兽垂死挣扎！造成3倍伤害',
        color: '#9C27B0',
        icon: '⚡'
    },
    {
        name: '新年祝福',
        description: '吸收新年气息恢复力量',
        multiplier: 0.5, // 伤害减半
        hpThreshold: 0.50, // 血量低于50%概率触发
        chance: 0.15, // 15%几率触发
        message: '🧧 年兽吸收新年气息，伤害减半',
        color: '#4CAF50',
        icon: '🧧'
    }
];
function resetNianBeastSkills() {
    // 深拷贝基础技能配置
    nianBeastSkills = JSON.parse(JSON.stringify(baseNianBeastSkills));
    
    // 重置技能相关变量
    nianBeastGame.skillTriggeredDeath = false;
    nianBeastGame.lastComboSkill = '';
    nianBeastGame.skillCombo = 0;
    nianBeastGame.lastSkill = '';
    
    console.log('年兽技能已重置到初始状态');
}

// 初始化年兽副本系统
function initNianBeastSystem() {
    if (!player.nianBeast) {
        player.nianBeast = {
            dungeonToken: 0, // 副本令牌
            highestLevel: 0, // 最高通关层数
            totalKills: 0, // 总击杀次数
            rewardsCollected: 0 // 总奖励数量
        };
    }
}
const artifactCritConfig = {
    // 法宝加成区间对应的触发几率和倍率
    thresholds: [
        { maxBonus: 1.1, chance: 0.05, multiplier: 1, message: '💫 法宝共鸣！造成1倍额外伤害' },
        { maxBonus: 1.3, chance: 0.05, multiplier: 2, message: '⚡ 法宝觉醒！造成2倍暴伤' },
        { maxBonus: 1.4, chance: 0.05, multiplier: 3, message: '✨ 法宝通灵！造成3倍毁灭打击' },
        { maxBonus: 1.5, chance: 0.05, multiplier: 4, message: '🌟 法宝化形！造成4倍天道之力' },
        { maxBonus: 1.6, chance: 0.05, multiplier: 5, message: '🌪️ 法宝混沌！造成5倍洪荒之力' },
        { maxBonus: 1.8, chance: 0.10, multiplier: 6, message: '🔥 法宝焚天！造成6倍寂灭之威' },
        { maxBonus: 2.0, chance: 0.10, multiplier: 7, message: '❄️ 法宝冰封！造成7倍时空冻结' },
        { maxBonus: 2.5, chance: 0.10, multiplier: 8, message: '⚡ 法宝雷动！造成8倍天劫之力' },
        { maxBonus: 3.0, chance: 0.10, multiplier: 9, message: '🌌 法宝虚空！造成9倍混沌之怒' },
        { maxBonus: 3.5, chance: 0.15, multiplier: 10, message: '👑 法宝帝王！造成10倍君临天下' },
        { maxBonus: 4.0, chance: 0.15, multiplier: 15, message: '🐉 法宝神龙！造成15倍龙威震天' },
        { maxBonus: 4.5, chance: 0.15, multiplier: 20, message: '🌍 法宝创世！造成20倍开天辟地' },
        { maxBonus: 5.0, chance: 0.15, multiplier: 25, message: '☯️ 法宝大道！造成25倍道法自然' },
        { maxBonus: Infinity, chance: 0.20, multiplier: 30, message: '∞ 法宝永恒！造成30倍无尽轮回' }
    ],
    
    // 霸气语录（根据不同倍数触发不同台词）
    quotes: {
        1: [
            '「区区年兽，也敢放肆！」',
            '「看我的法宝神威！」',
            '「这一击，只是开胃菜！」',
            '「法宝初显，年兽受死！」'
        ],
        2: [
            '「二倍之力，破你防御！」',
            '「法宝觉醒，年兽颤栗！」',
            '「这一击，让你知道厉害！」',
            '「年兽，尝尝法宝的厉害！」'
        ],
        3: [
            '「三界震动，法宝显圣！」',
            '「年兽，还不伏诛！」',
            '「法宝通灵，诛杀邪祟！」',
            '「这一击，送你归西！」'
        ],
        4: [
            '「四海之内，法宝为尊！」',
            '「年兽，你的死期到了！」',
            '「四倍暴击，荡平年兽！」',
            '「法宝化形，毁天灭地！」'
        ],
        5: [
            '「五雷轰顶，法宝天威！」',
            '「年兽，还不束手就擒！」',
            '「五倍之力，横扫千军！」',
            '「法宝混沌，破碎虚空！」'
        ],
        6: [
            '「六道轮回，法宝超度！」',
            '「年兽，让你魂飞魄散！」',
            '「六倍暴击，诛杀年兽！」',
            '「法宝焚天，烧尽邪魔！」'
        ],
        7: [
            '「七星伴月，法宝无敌！」',
            '「年兽，这一击送你上路！」',
            '「七倍之力，天地变色！」',
            '「法宝冰封，冻结时空！」'
        ],
        8: [
            '「八方来朝，法宝称尊！」',
            '「年兽，受死吧！」',
            '「八倍暴击，毁天灭地！」',
            '「法宝雷动，天劫降临！」'
        ],
        9: [
            '「九霄云外，法宝纵横！」',
            '「年兽，让你永世不得超生！」',
            '「九倍之力，破碎虚空！」',
            '「法宝虚空，吞噬一切！」'
        ],
        10: [
            '「十方俱灭，法宝无敌！」',
            '「年兽，见识真正的力量！」',
            '「十倍暴击，君临天下！」',
            '「法宝帝王，统御万界！」'
        ],
        15: [
            '「十五倍龙威，年兽颤栗！」',
            '「神龙降世，诛杀年兽！」',
            '「法宝神龙，毁天灭地！」',
            '「龙威震天，年兽伏诛！」'
        ],
        20: [
            '「二十倍创世，开天辟地！」',
            '「法宝创世，重演混沌！」',
            '「创世之力，年兽化为虚无！」',
            '「开天辟地，年兽湮灭！」'
        ],
        25: [
            '「二十五倍大道，道法自然！」',
            '「大道至简，一击必杀！」',
            '「法宝大道，年兽超度！」',
            '「道法自然，年兽归西！」'
        ],
        30: [
            '「三十倍永恒，无尽轮回！」',
            '「永恒法宝，超越时空！」',
            '「无尽轮回，年兽永世不得超生！」',
            '「法宝永恒，与天地同寿！」'
        ]
    },
// 特殊触发台词（极低概率触发）
    specialQuotes: [
        { chance: 0.001, quote: '👑 「吾之法宝，可破苍穹！」' },
        { chance: 0.001, quote: '🌌 「这一击，蕴含宇宙真理！」' },
        { chance: 0.001, quote: '⚡ 「天大地大，法宝最大！」' },
        { chance: 0.001, quote: '🔥 「年兽，不过如此！」' },
        { chance: 0.001, quote: '❄️ 「法宝一出，谁与争锋！」' },
        { chance: 0.001, quote: '💫 「让你见识真正的法宝之力！」' }
    ]
};
function getEquippedArtifactBonus() {
    if (!player.magicTools || !player.magicTools.equipped) {
        return 1.0; // 没有装备法宝，基础加成1.0
    }
    
    const tool = magicToolConfig.tools.find(t => t.id === player.magicTools.equipped);
    return tool ? tool.bonus : 1.0;
}
function triggerArtifactCrit() {
    const artifactBonus = getEquippedArtifactBonus();
    
    // 找到对应的加成区间
    let config = artifactCritConfig.thresholds.find(t => artifactBonus <= t.maxBonus);
    if (!config) {
        config = artifactCritConfig.thresholds[artifactCritConfig.thresholds.length - 1];
    }
    
    // 5%几率触发
    if (Math.random() < config.chance) {
        // 随机选择霸气语录
        let quotes = artifactCritConfig.quotes[config.multiplier] || artifactCritConfig.quotes[1];
        let quote = quotes[Math.floor(Math.random() * quotes.length)];
        
        // 极低概率触发特殊台词
        for (let special of artifactCritConfig.specialQuotes) {
            if (Math.random() < special.chance) {
                quote = special.quote;
                break;
            }
        }
        
        return {
            triggered: true,
            multiplier: config.multiplier,
            quote: quote,
            message: config.message
        };
    }
    
    return { triggered: false };
}
function updateArtifactCritPreview() {
    const artifactBonus = getEquippedArtifactBonus();
    const config = artifactCritConfig.thresholds.find(t => artifactBonus <= t.maxBonus) || artifactCritConfig.thresholds[0];
    
    const previewSpan = document.getElementById('currentArtifactBonus');
    const multiplierSpan = document.getElementById('currentArtifactMultiplier');
    const previewDiv = document.getElementById('artifactCritPreview');
    
    if (previewSpan) previewSpan.innerHTML = artifactBonus.toFixed(2);
    if (multiplierSpan) multiplierSpan.innerHTML = config.multiplier;
    
    if (previewDiv) {
        previewDiv.innerHTML = `当前法宝加成: ${artifactBonus.toFixed(2)}倍 → 触发 ${config.multiplier}倍暴伤 `;
    }
}

// 打开年兽副本
function openNianBeastDungeon() {
   if (player.cultivation.stage < 20) {
        alert("需要达到修仙20级才能开启新年年兽副本！");
        return;
    }

    initNianBeastSystem();
    toggleAutoBuyShopb();
    // 计算玩家属性
    updateNianPlayerStats();
    
    // 重置BOSS状态
    resetNianBeastBattle();
    
    // 显示UI
    document.getElementById('nianBeastOverlay').style.display = 'block';
    document.getElementById('nianBeastUI').style.display = 'block';
    
    // 禁用攻击、防御、逃跑按钮，直到消耗令牌
    document.getElementById('nianAttackBtn').disabled = true;
    document.getElementById('nianAttackBtn').style.background = '#666';
    document.getElementById('nianAttackBtn').style.cursor = 'not-allowed';
    document.getElementById('nianDefendBtn').disabled = true;
    document.getElementById('nianDefendBtn').style.background = '#666';
    document.getElementById('nianDefendBtn').style.cursor = 'not-allowed';
    document.getElementById('nianEscapeBtn').disabled = true;
    document.getElementById('nianEscapeBtn').style.background = '#666';
    document.getElementById('nianEscapeBtn').style.cursor = 'not-allowed';
    
    // 启用挑战按钮
    document.getElementById('challengeNianBtn').disabled = false;
    document.getElementById('challengeNianBtn').style.background = 'linear-gradient(145deg, #FFD700, #FFA500)';
    document.getElementById('challengeNianBtn').style.cursor = 'pointer';
  const hasChaos = hasChaosCauldron();
    if (hasChaos) {
        addNianBattleLog('🧨 检测到驱年爆竹！对年兽造成20倍克制伤害！', 'artifact', '#FF4500');
    }
     addNianBattleLog('🧧 欢迎来到年兽副本！', 'success');
    addNianBattleLog('🎫 消耗1个令牌开始挑战', 'info');
    addNianBattleLog('📢 第一层是试炼阶段，无奖励', 'info');
    addNianBattleLog('🎯 从第二层开始才有丰厚奖励！', 'warning');
    addNianBattleLog('🐅 年兽拥有多种强力技能', 'warning');
    addNianBattleLog('⚡ 击败年兽获得丰厚奖励', 'skill', '#FFD700');
    addNianBattleLog('🏃 逃跑按钮可立即结束战斗并结算奖励', 'info', '#f44336');
    addNianBattleLog('════════════ 年兽技能 ════════════', 'skill', '#FFD700');
    
    const sortedSkills = [...nianBeastSkills].sort((a, b) => b.chance - a.chance);
    sortedSkills.forEach(skill => {
        if (skill.chance > 0) {
            addNianBattleLog(`${skill.icon} ${skill.name}: ${(skill.chance * 100).toFixed(0)}%几率 | ${skill.multiplier}倍伤害`, 'skill', skill.color);
        }
    });
    
    addNianBattleLog('══════════════════════════════', 'skill', '#FFD700');
    
    // 更新显示
    updateNianBeastUI();
}

// 关闭年兽副本
function closeNianBeastDungeon() {
    // 如果正在战斗中，不重置令牌消耗状态，但可以关闭界面
    document.getElementById('nianBeastOverlay').style.display = 'none';
    document.getElementById('nianBeastUI').style.display = 'none';
}

// 计算玩家属性（转生数*10000）*当前灵根*当前血脉，宗门藏经阁传承加成修仙副本属性
function updateNianPlayerStats() {
    const sectLib = typeof getSectLibraryBonus === 'function' ? getSectLibraryBonus() : {};
    const libHealth = 1 + (sectLib.dungeonHealth || 0);
    const libAttack = 1 + (sectLib.dungeonAttack || 0);
    const libCritRate = sectLib.dungeonCritRate || 0;
    const libCritDmg = 1 + (sectLib.dungeonCritDamage || 0);
    if (!player.cultivation || !player.cultivation.root || !player.cultivation.bloodline) {
        nianBeastGame.playerMaxHp = player.reincarnationCount * 10000 * libHealth;
        nianBeastGame.playerHp = nianBeastGame.playerMaxHp;
        nianBeastGame.playerAtk = player.reincarnationCount * 100 * libAttack;
        nianBeastGame.playerCritRate = 0.3 + libCritRate;
        nianBeastGame.playerCrit = 1.5 * libCritDmg;
    } else {
        // 生命值 = (转生数 * 10000) * 灵根加成 * 血脉加成 * 藏经阁
        nianBeastGame.playerMaxHp = player.reincarnationCount * 10000 * 
                                    (player.cultivation.root.bonus || 1) * 
                                    (player.cultivation.bloodline.bonus || 1) * (1+player.fiveElements.metal.level * 0.2) * libHealth;
        nianBeastGame.playerHp = nianBeastGame.playerMaxHp;
        
        // 攻击力 = 阶段加成 * 装备法宝加成 * 藏经阁
        let stageMultiplier = 1;
        if (player.cultivation && player.cultivation.bonus) {
            stageMultiplier = player.cultivation.bonus;
        }
        
        let toolBonus = 1;
        if (player.magicTools && player.magicTools.equipped) {
            const tool = magicToolConfig.tools.find(t => t.id === player.magicTools.equipped);
            if (tool) toolBonus = tool.bonus;
        }
        
        nianBeastGame.playerAtk = stageMultiplier * toolBonus * 1000 * (1+player.fiveElements.wood.level * 0.05) * (1+player.fiveElements.earth.level * 0.05) * libAttack;
        
        // 爆伤 = 当前境界等级 * 藏经阁
        nianBeastGame.playerCrit = ((player.cultivation.stage || 0) * 0.5 * (1+player.fiveElements.water.level * 0.05) * (1+player.fiveElements.fire.level * 0.05) + 1.5) * libCritDmg;
        nianBeastGame.playerCritRate = 0.3 + libCritRate;
    }
 const chaosTipDiv = document.getElementById('yin_yang_mirrorbaab');
    if (chaosTipDiv) {
        const hasChaos = hasChaosCauldron();
        if (hasChaos) {
            chaosTipDiv.style.display = 'block';
            chaosTipDiv.innerHTML = `
                <div style="background: linear-gradient(145deg, #FF4500, #8B0000); padding: 10px; border-radius: 10px; margin-top: 10px; border: 2px solid #FFD700; animation: pulse-orange 2s infinite;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 24px;">🧨</span>
                        <div>
                            <div style="color: #FFD700; font-weight: bold; font-size: 16px;">驱年爆竹觉醒！</div>
                            <div style="color: white; font-size: 14px;">对年兽造成 <span style="color: #FFD700; font-weight: bold;">20倍</span> 克制伤害</div>
                        </div>
                    </div>
                </div>
            `;
        } else {
            chaosTipDiv.style.display = 'none';
        }
    }
updateArtifactCritPreview();
}

// 重置年兽战斗
function resetNianBeastBattle() {
    nianBeastGame.beastLevel = 1;
    nianBeastGame.beastMultiplier = 1;
    nianBeastGame.beastMaxHp = 1e5;
    nianBeastGame.beastCurrentHp = 1e5;
    nianBeastGame.beastAtk = 1e2;
    nianBeastGame.beastReviveCount = 2;
    nianBeastGame.isDefending = false;
    nianBeastGame.isInBattle = false;
    nianBeastGame.hasTokenCost = false;
    
    // 重置技能状态
    nianBeastGame.lastSkill = '';
    nianBeastGame.skillCombo = 0;
    nianBeastGame.lastComboSkill = '';
    nianBeastGame.skillTriggeredDeath = false;
    nianBeastGame.totalDamageDealt = 0;
     resetNianBeastSkills();
    // 清空战斗日志
    clearNianBattleLog();
}

// 更新年兽UI
function updateNianBeastUI() {
    // 更新玩家属性显示
    document.getElementById('nianPlayerHp').innerHTML = formatNumber(nianBeastGame.playerMaxHp);
    document.getElementById('nianPlayerAtk').innerHTML = formatNumber(nianBeastGame.playerAtk);
    document.getElementById('nianPlayerCrit').innerHTML = (nianBeastGame.playerCrit * 100 - 100).toFixed(0) + '%';
    document.getElementById('nianPlayerCritRate').innerHTML = '30%';
    
    // 更新BOSS信息
    document.getElementById('nianBeastLevel').innerHTML = nianBeastGame.beastLevel;
    document.getElementById('nianBeastReviveCount').innerHTML = nianBeastGame.beastReviveCount;
    document.getElementById('nianBeastHpText').innerHTML = formatNumber(nianBeastGame.beastCurrentHp) + ' / ' + formatNumber(nianBeastGame.beastMaxHp);
    document.getElementById('nianBeastAtk').innerHTML = formatNumber(nianBeastGame.beastAtk);
    document.getElementById('nianBeastMultiplier').innerHTML = nianBeastGame.beastMultiplier.toFixed(0) + '倍';
    
    // 更新血条
    let hpPercent = (nianBeastGame.beastCurrentHp / nianBeastGame.beastMaxHp) * 100;
    document.getElementById('nianBeastHpBar').style.width = hpPercent + '%';
    
    // 更新战斗中的玩家血条
    document.getElementById('nianBattlePlayerHp').innerHTML = formatNumber(nianBeastGame.playerHp) + ' / ' + formatNumber(nianBeastGame.playerMaxHp);
    let playerHpPercent = (nianBeastGame.playerHp / nianBeastGame.playerMaxHp) * 100;
    document.getElementById('nianBattlePlayerHpBar').style.width = playerHpPercent + '%';
    
    // 更新令牌显示
    document.getElementById('nianDungeonToken').innerHTML = player.nianBeast?.dungeonToken || 0;
     // 更新令牌显示
    const tokenDisplay = document.getElementById('nianTokenDisplay');
    if (tokenDisplay) {
        tokenDisplay.innerHTML = player.nianBeast?.dungeonToken || 0;
    }
    
    // 更新按钮状态
    const challengeBtn = document.getElementById('challengeNianBtn');
    if (challengeBtn) {
        if (nianBeastGame.isInBattle) {
            challengeBtn.disabled = true;
            challengeBtn.style.background = '#666';
            challengeBtn.style.cursor = 'not-allowed';
        } else {
            challengeBtn.disabled = false;
            challengeBtn.style.background = 'linear-gradient(145deg, #FFD700, #FFA500)';
            challengeBtn.style.cursor = 'pointer';
        }
    }
 let skillInfoDiv = document.getElementById('nianBeastSkillInfo');
    if (!skillInfoDiv) {
        // 在BOSS信息区域添加技能显示
        const bossInfoDiv = document.querySelector('#nianBeastUI [style*="background: linear-gradient(145deg, #C41E3A, #8B0000)"]');
        if (bossInfoDiv) {
            skillInfoDiv = document.createElement('div');
            skillInfoDiv.id = 'nianBeastSkillInfo';
            skillInfoDiv.style.marginTop = '15px';
            skillInfoDiv.style.padding = '10px';
            skillInfoDiv.style.background = 'rgba(0,0,0,0.5)';
            skillInfoDiv.style.borderRadius = '15px';
            skillInfoDiv.style.border = '1px solid #FFD700';
            bossInfoDiv.appendChild(skillInfoDiv);
        }
    }
    
    if (skillInfoDiv) {
        let lastSkill = nianBeastGame.lastSkill || '无';
        let combo = nianBeastGame.skillCombo || 0;
        
        // 随机显示一个技能预览
        const randomSkill = nianBeastSkills[Math.floor(Math.random() * nianBeastSkills.length)];
        
        skillInfoDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <span style="color: #FFD700; font-size: 14px; font-weight: bold;">🎯 年兽技能</span>
                <span style="color: #aaa; font-size: 12px;">连击: ${combo}x</span>
            </div>
            <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                <div style="background: rgba(255,215,0,0.2); padding: 3px 8px; border-radius: 12px; font-size: 11px; color: #FFD700;">
                    上次: ${lastSkill}
                </div>
                <div style="background: rgba(156,39,176,0.2); padding: 3px 8px; border-radius: 12px; font-size: 11px; color: #9C27B0;">
                    预览: ${randomSkill.name} (${randomSkill.multiplier}x)
                </div>
            </div>
            <div style="margin-top: 8px;">
                <div style="font-size: 11px; color: #aaa; margin-bottom: 3px;">技能几率:</div>
                <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                    ${nianBeastSkills.map(skill => `
                        <div style="display: flex; align-items: center; gap: 2px;">
                            <span style="color: ${skill.color};">${skill.icon}</span>
                            <span style="color: #aaa; font-size: 10px;">${(skill.chance * 100).toFixed(0)}%</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }
 const hasChaos = hasChaosCauldron();
    
    // 在玩家信息区域添加驱年爆竹提示
    const chaosTipDiv = document.getElementById('chaosCauldronTip');
    if (chaosTipDiv) {
        if (hasChaos) {
            chaosTipDiv.style.display = 'block';
            chaosTipDiv.innerHTML = `
                <div style="background: linear-gradient(145deg, #FF4500, #8B0000); padding: 10px; border-radius: 10px; margin-top: 10px; border: 2px solid #FFD700; animation: pulse-orange 2s infinite;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 24px;">🧨</span>
                        <div>
                            <div style="color: #FFD700; font-weight: bold; font-size: 16px;">驱年爆竹觉醒！</div>
                            <div style="color: white; font-size: 14px;">对年兽造成 <span style="color: #FFD700; font-weight: bold;">20倍</span> 克制伤害</div>
                        </div>
                    </div>
                </div>
            `;
        } else {
            chaosTipDiv.style.display = 'none';
        }
    }
    
    // 更新法宝暴伤预览
    updateArtifactCritPreview();
    // 更新奖励预览
    updateRewardPreview();
}

// 更新奖励预览
function updateRewardPreview() {
    let level = nianBeastGame.beastLevel;
    document.getElementById('previewRewardLevel').innerHTML = level;
    
    const previewContainer = document.getElementById('rewardPreviewContent');
    if (!previewContainer) return;
    
    let previewHtml = '';
    
    // 奖励配置
    const rewardConfig = [
        { key: 'danyao1', name: '蕴灵筑基丹', min: 1, max: 8, unlock: 1, color: '#4CAF50', icon: '💊' },
        { key: 'danyao2', name: '凝元固窍丹', min: 1, max: 6, unlock: 4, color: '#2196F3', icon: '💊' },
        { key: 'rootDetector', name: '灵根检测器', min: 1, max: 2, unlock: 6, color: '#9C27B0', icon: '🌿' },
        { key: 'danyao3', name: '渡厄金还丹', min: 1, max: 4, unlock: 8, color: '#FF5722', icon: '💊' },
        { key: 'bloodlineDetector', name: '血脉检测剂', min: 1, max: 2, unlock: 10, color: '#FFD700', icon: '💉' },
        { key: 'danyao4', name: '九转轮回丹', min: 1, max: 3, unlock: 12, color: '#673AB7', icon: '💊' },
        { key: 'advanceStone', name: '进阶神石', min: 1, max: 2, unlock: 15, color: '#00BCD4', icon: '🌑' },
        { key: 'danyao5', name: '混元道果丹', min: 1, max: 2, unlock: 20, color: '#E91E63', icon: '💊' }
    ];
    
    rewardConfig.forEach(config => {
        if (level >= config.unlock) {
            previewHtml += `
                <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 10px; border-left: 5px solid ${config.color};">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="font-size: 16px;">${config.icon}</span>
                        <span style="color: #aaa; font-size: 11px; flex: 1;">${config.name}</span>
                        <span style="color: #FFD700; font-weight: bold;">${config.min * level}-${config.max * level}</span>
                    </div>
                    <div style="font-size: 9px; color: ${config.color}; margin-top: 2px;">第${config.unlock}层解锁 ✓</div>
                </div>
            `;
        } else {
            previewHtml += `
                <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 10px; border-left: 5px solid #666; opacity: 0.5;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span style="font-size: 16px;">❓</span>
                        <span style="color: #666; font-size: 11px; flex: 1;">${config.name}</span>
                        <span style="color: #666;">???</span>
                    </div>
                    <div style="font-size: 9px; color: #666; margin-top: 2px;">第${config.unlock}层解锁</div>
                </div>
            `;
        }
    });
    
    previewContainer.innerHTML = previewHtml;
    
    // 更新试炼提示
    const tipDiv = document.getElementById('firstLevelTip');
    if (tipDiv) {
        if (level <= 1) {
            tipDiv.style.display = 'block';
            tipDiv.innerHTML = `
                <span style="color: #FF6B6B; font-weight: bold;">⚠️ 试炼阶段</span>
                <span style="color: #aaa; font-size: 12px; margin-left: 10px;">第一层只有蕴灵筑基丹</span>
            `;
        } else {
            tipDiv.style.display = 'none';
        }
    }
}
function buyNianToken() {
    if (!player.nianBeast) initNianBeastSystem();
    
    // 检查宝藏金币是否足够
    if (player.items && player.items.primaryGemq >= 3) {
        player.items.primaryGemq -= 3;
        player.nianBeast.dungeonToken = (player.nianBeast.dungeonToken || 0) + 1;
        
        updateNianBeastUI();
        addNianBattleLog('🎫 成功购买1个修仙令牌！消耗3枚宝藏金币', 'success');
    } else {
        addNianBattleLog('❌ 宝藏金币不足！需要3枚宝藏金币', 'error');
    }
}



// 挑战年兽（消耗令牌）
function challengeNianBeast() {
    initNianBeastSystem();
    
    // 检查令牌数量
    if (player.nianBeast.dungeonToken < 1) {
        addNianBattleLog('❌ 修仙令牌不足！', 'error');
        return;
    }
    
    // 消耗令牌
    player.nianBeast.dungeonToken--;
    nianBeastGame.hasTokenCost = true;
    nianBeastGame.isInBattle = true;
    
    // 重置战斗状态
    resetNianBeastBattle();
    nianBeastGame.isInBattle = true;
    nianBeastGame.hasTokenCost = true;
    
    // 更新玩家属性
    updateNianPlayerStats();
    nianBeastGame.playerHp = nianBeastGame.playerMaxHp;
    
    // 启用攻击按钮
    document.getElementById('nianAttackBtn').disabled = false;
    document.getElementById('nianAttackBtn').style.background = 'linear-gradient(145deg, #FFD700, #FFA500)';
    document.getElementById('nianAttackBtn').style.cursor = 'pointer';
    document.getElementById('nianDefendBtn').disabled = false;
    document.getElementById('nianDefendBtn').style.background = 'linear-gradient(145deg, #4CAF50, #2E7D32)';
    document.getElementById('nianDefendBtn').style.cursor = 'pointer';
    document.getElementById('nianEscapeBtn').disabled = false;
    document.getElementById('nianEscapeBtn').style.background = 'linear-gradient(145deg, #f44336, #c62828)';
    document.getElementById('nianEscapeBtn').style.cursor = 'pointer';
    
    // 禁用挑战按钮
    document.getElementById('challengeNianBtn').disabled = true;
    document.getElementById('challengeNianBtn').style.background = '#666';
    document.getElementById('challengeNianBtn').style.cursor = 'not-allowed';
    
    // 清空战斗日志
    clearNianBattleLog();
    
    addNianBattleLog('🎫 消耗1个修仙令牌，开始讨伐年兽！', 'success');
    addNianBattleLog('🐅 新年年兽 Lv.1 出现了！', 'warning');
   const hasChaos = hasChaosCauldron();
    if (hasChaos) {
        addNianBattleLog('🧨 驱年爆竹觉醒！对年兽造成20倍克制伤害！', 'artifact', '#FF4500');
        addNianBattleLog('⚡ 这将是一场碾压级的战斗！', 'artifact', '#FFD700');
    }
    addNianBattleLog('📢 第一层是试炼阶段，无奖励', 'info');
    addNianBattleLog('🎯 从第二层开始才有丰厚奖励！', 'warning');
    addNianBattleLog('📊 年兽拥有多种技能，小心它的强力攻击！', 'skill', '#9C27B0');
    
    // 显示技能列表
     addNianBattleLog('════════════ 年兽技能 ════════════', 'skill', '#FFD700');
    
    const sortedSkills = [...nianBeastSkills].sort((a, b) => b.chance - a.chance);
    sortedSkills.forEach(skill => {
        if (skill.chance > 0) {
            addNianBattleLog(`${skill.icon} ${skill.name}: ${(skill.chance * 100).toFixed(0)}%几率 | ${skill.multiplier}倍伤害`, 'skill', skill.color);
        }
    });
    
    addNianBattleLog('══════════════════════════════', 'skill', '#FFD700');
    
    updateNianBeastUI();
}


// 攻击年兽
function nianBeastAttack() {
    // 检查是否在战斗中且已消耗令牌
    if (!nianBeastGame.isInBattle) {
        addNianBattleLog('请先消耗令牌挑战年兽！', 'error');
        return;
    }
    
    if (!nianBeastGame.hasTokenCost) {
        addNianBattleLog('需要消耗1个修仙令牌才能攻击！', 'error');
        return;
    }
    
    if (nianBeastGame.playerHp <= 0) {
        addNianBattleLog('你已战败，战斗结束', 'error');
        endNianBeastBattle(false);
        return;
    }
    
    
    const hasChaos = hasChaosCauldron();
    let damage = nianBeastGame.playerAtk;
    let isCrit = Math.random() < nianBeastGame.playerCritRate;
    let critMultiplier = 1;
    let artifactEffect = null;
    let chaosBonus = 1;
    
   
    if (hasChaos) {
        chaosBonus = 20;
        addNianBattleLog('🧨 驱年爆竹感应到年兽气息！', 'artifact', '#FF6B6B');
        addNianBattleLog('⚡ 驱年爆竹对年兽造成20倍克制伤害！', 'artifact', '#FFD700');
    }
    
    // 暴击判定
    if (isCrit) {
        critMultiplier = nianBeastGame.playerCrit;
        addNianBattleLog(`⚡ 基础暴击！造成 ${(critMultiplier * 100 - 100).toFixed(0)}% 伤害`, 'crit');
    }
    
    // 触发法宝暴伤效果（5%几率）
    artifactEffect = triggerArtifactCrit();
    
    if (artifactEffect.triggered) {
        // 应用法宝暴伤倍率
        let totalMultiplier = critMultiplier * artifactEffect.multiplier * chaosBonus;
        damage = Math.floor(damage * totalMultiplier);
        
        // 霸气语录显示
        addNianBattleLog(`🌟 ${artifactEffect.quote}`, 'skill', '#FFD700');
        addNianBattleLog(`💫 ${artifactEffect.message} (${artifactEffect.multiplier}倍)`, 'artifact', '#FF6B6B');
        
        if (hasChaos) {
            addNianBattleLog(`🧨 驱年爆竹额外加成: 20倍`, 'artifact', '#FF4500');
        }
        
        addNianBattleLog(`⚔️ 总伤害倍率: ${critMultiplier.toFixed(1)} × ${artifactEffect.multiplier} × ${chaosBonus} = ${totalMultiplier.toFixed(1)}倍`, 'info', '#4CAF50');
    } else {
        
        damage = Math.floor(damage * critMultiplier * chaosBonus);
        
        if (hasChaos && !isCrit) {
            addNianBattleLog(`🧨 驱年爆竹造成 ${chaosBonus}倍克制伤害！`, 'artifact', '#FF4500');
            addNianBattleLog(`⚔️ 总伤害倍率: 1 × ${chaosBonus} = ${chaosBonus}倍`, 'info', '#4CAF50');
        } else if (hasChaos && isCrit) {
            addNianBattleLog(`⚔️ 总伤害倍率: ${critMultiplier.toFixed(1)} × ${chaosBonus} = ${(critMultiplier * chaosBonus).toFixed(1)}倍`, 'info', '#4CAF50');
        }
    }
    
    // 显示最终伤害
    if (artifactEffect.triggered) {
        addNianBattleLog(`💥 法宝神威！造成 ${formatNumber(damage)} 点伤害！`, 'crit');
    } else if (hasChaos) {
        addNianBattleLog(`🧨 驱年爆竹之力！造成 ${formatNumber(damage)} 点伤害！`, 'crit');
    } else if (isCrit) {
        addNianBattleLog(`⚔️ 暴击造成 ${formatNumber(damage)} 点伤害`, 'crit');
    } else {
        addNianBattleLog(`⚔️ 造成 ${formatNumber(damage)} 点伤害`, 'normal');
    }
    
    // 减少BOSS血量
    nianBeastGame.beastCurrentHp -= damage;
    
    // 检查BOSS是否死亡
    if (nianBeastGame.beastCurrentHp <= 0) {
        handleNianBeastDeath();
    } else {
        // BOSS反击
        nianBeastCounterAttack();
    }
    
    updateNianBeastUI();
}

// 防御
function nianBeastDefend() {
    // 检查是否在战斗中且已消耗令牌
    if (!nianBeastGame.isInBattle) {
        addNianBattleLog('请先消耗令牌挑战年兽！', 'error');
        return;
    }
    
    if (!nianBeastGame.hasTokenCost) {
        addNianBattleLog('需要消耗1个修仙令牌才能防御！', 'error');
        return;
    }
    
    if (nianBeastGame.playerHp <= 0) {
        addNianBattleLog('你已战败，战斗结束', 'error');
        endNianBeastBattle(false);
        return;
    }
    
    nianBeastGame.isDefending = true;
    addNianBattleLog('🛡️ 进入防御状态，受到的伤害减半', 'defend');
    
    // BOSS攻击，但伤害减半
    nianBeastCounterAttack(true);
}

function nianBeastEscape() {
    // 检查是否在战斗中
    if (!nianBeastGame.isInBattle) {
        addNianBattleLog('❌ 现在无法逃跑！', 'error');
        return;
    }
    
    if (!nianBeastGame.hasTokenCost) {
        addNianBattleLog('❌ 请先消耗令牌挑战年兽！', 'error');
        return;
    }
    
    // 更新当前层数显示
    document.getElementById('escapeCurrentLevel').innerHTML = nianBeastGame.beastLevel;
    
    // 显示确认弹窗
    document.getElementById('escapeConfirmOverlay').style.display = 'block';
    document.getElementById('escapeConfirmDialog').style.display = 'block';
}

// 确认逃跑
function confirmEscape() {
    // 关闭弹窗
    closeEscapeDialog();
    
    // 添加逃跑日志
    addNianBattleLog('🏃 你选择了逃跑！', 'warning');
    addNianBattleLog('💀 逃跑导致战败...', 'error');
    
    // 记录当前层数用于奖励结算
    const escapeLevel = nianBeastGame.beastLevel;
    
    // 设置玩家血量为0（死亡）
    nianBeastGame.playerHp = 0;
    
    // 更新UI显示
    updateNianBeastUI();
    
    // 结束战斗（死亡结算）
    setTimeout(() => {
        endNianBeastBattle(false);
        
        // 添加逃跑特殊提示
        if (escapeLevel > 1) {
            addNianBattleLog(`🏃 你在第 ${escapeLevel} 层选择了逃跑`, 'info');
            addNianBattleLog(`💰 获得第 ${escapeLevel} 层奖励`, 'success');
        } else {
            addNianBattleLog('📢 第一层逃跑无奖励', 'info');
        }
    }, 500);
}

// 取消逃跑
function cancelEscape() {
    closeEscapeDialog();
    addNianBattleLog('✨ 继续战斗！', 'success');
}

// 关闭逃跑弹窗
function closeEscapeDialog() {
    document.getElementById('escapeConfirmOverlay').style.display = 'none';
    document.getElementById('escapeConfirmDialog').style.display = 'none';
}
// BOSS反击
function nianBeastCounterAttack(isDefending = false) {
    if (nianBeastGame.beastCurrentHp <= 0) return;
    
    // 基础伤害
    let bossDamage = nianBeastGame.beastAtk;
    let skillMultiplier = 1.0;
    let skillName = '普通攻击';
    let skillMessage = '';
    let skillColor = '#aaa';
    let skillIcon = '🐾';
    
    // 随机选择技能
    const rand = Math.random();
    let cumulativeChance = 0;
    
    // 先检查是否触发特殊技能
    let isSpecialSkill = false;
    let hpPercent = nianBeastGame.beastCurrentHp / nianBeastGame.beastMaxHp;
    
    // 垂死挣扎 - 血量低于20%时必触发一次
    if (hpPercent < 0.2 && !nianBeastGame.skillTriggeredDeath) {
        nianBeastGame.skillTriggeredDeath = true;
        skillMultiplier = 3.0;
        skillName = '垂死挣扎';
        skillMessage = '⚡ 年兽垂死挣扎！造成3倍毁灭性打击！';
        skillColor = '#9C27B0';
        skillIcon = '⚡';
        isSpecialSkill = true;
        addNianBattleLog(`💀 年兽进入濒死状态！发动垂死挣扎！`, 'warning');
    }
    // 新年祝福 - 血量低于50%且有15%几率触发
    else if (hpPercent < 0.5 && Math.random() < 0.15) {
        skillMultiplier = 0.5;
        skillName = '新年祝福';
        skillMessage = '🧧 年兽吸收新年气息，攻击伤害减半！';
        skillColor = '#4CAF50';
        skillIcon = '🧧';
        isSpecialSkill = true;
    }
    // 普通技能随机
    else {
        for (const skill of nianBeastSkills) {
            cumulativeChance += skill.chance;
            if (rand < cumulativeChance) {
                skillMultiplier = skill.multiplier;
                skillName = skill.name;
                skillMessage = skill.message;
                skillColor = skill.color;
                skillIcon = skill.icon;
                break;
            }
        }
    }
    
    // 应用技能倍率
    bossDamage = Math.floor(bossDamage * skillMultiplier);
    
    // 记录本次技能
    nianBeastGame.lastSkill = skillName;
    
    // 连击系统 - 连续使用相同技能增加伤害
    if (nianBeastGame.lastComboSkill === skillName) {
        nianBeastGame.skillCombo++;
        if (nianBeastGame.skillCombo > 1) {
            let comboBonus = 1 + (nianBeastGame.skillCombo * 0.1);
            bossDamage = Math.floor(bossDamage * comboBonus);
            skillMessage += ` 🔥 连击x${nianBeastGame.skillCombo}！伤害提升${(comboBonus * 100 - 100).toFixed(0)}%`;
        }
    } else {
        nianBeastGame.lastComboSkill = skillName;
        nianBeastGame.skillCombo = 1;
    }
    
    // 防御减伤
    if (isDefending || nianBeastGame.isDefending) {
        bossDamage = Math.floor(bossDamage / 2);
        nianBeastGame.isDefending = false;
        addNianBattleLog(`🛡️ 防御成功！`, 'defend');
    }
    
    // 显示技能信息
    addNianBattleLog(`${skillIcon} ${skillMessage}`, 'skill', skillColor);
    addNianBattleLog(`💢 受到 ${formatNumber(bossDamage)} 点伤害`, 'damage');
    
    // 减少玩家血量
    nianBeastGame.playerHp -= bossDamage;
    nianBeastGame.totalDamageDealt += bossDamage;
    
    // 检查玩家是否死亡
    if (nianBeastGame.playerHp <= 0) {
        nianBeastGame.playerHp = 0;
        addNianBattleLog('💀 你被年兽击败了...', 'error');
        endNianBeastBattle(false);
    }
}

// 处理年兽死亡
function handleNianBeastDeath() {
    nianBeastGame.beastReviveCount--;
    
    if (nianBeastGame.beastReviveCount > 0) {
        // 复活，属性提升1.25倍
        nianBeastGame.beastMaxHp *= 1.25;
        nianBeastGame.beastCurrentHp = nianBeastGame.beastMaxHp;
        nianBeastGame.beastAtk *= 1.25;
        nianBeastGame.beastMultiplier *= 1.25;
        
        // 重置技能状态
        nianBeastGame.skillTriggeredDeath = false;
        nianBeastGame.lastComboSkill = '';
        nianBeastGame.skillCombo = 0;
        
        // 随机获得一个复活技能
        const reviveSkills = [
            { name: '怨念重生', multiplier: 1.5, message: '👻 年兽带着怨念复活，攻击提升50%' },
            { name: '新春复苏', multiplier: 1.2, message: '🌸 年兽吸收新春气息复活，攻击提升20%' },
            { name: '狂暴觉醒', multiplier: 2.0, message: '🔥 年兽狂暴觉醒！攻击提升100%' }
        ];
        
        const reviveSkill = reviveSkills[Math.floor(Math.random() * reviveSkills.length)];
        nianBeastGame.beastAtk *= reviveSkill.multiplier;
        
        addNianBattleLog(`✨ 年兽复活！剩余复活次数: ${nianBeastGame.beastReviveCount}`, 'warning');
        addNianBattleLog(`${reviveSkill.message}`, 'skill', '#FFD700');
        addNianBattleLog(`⚡ 年兽属性提升${(reviveSkill.multiplier * 2 * 100).toFixed(0)}%！`, 'warning');
        
        // 复活后立即发动一次攻击
        setTimeout(() => {
            if (nianBeastGame.isInBattle) {
                addNianBattleLog(`⚠️ 复活后的年兽立即发动攻击！`, 'warning');
                nianBeastCounterAttack();
            }
        }, 100);
        
    } else {
        // 没有复活次数了，进入下一级
        nianBeastGame.beastReviveCount = 2;
        nianBeastGame.beastLevel++;
        
        // 每级提升：血量1e5倍，攻击1e6倍
         nianBeastGame.beastMultiplier = Math.pow(5, nianBeastGame.beastLevel - 1);
        nianBeastGame.beastMaxHp = 1e5 * Math.pow(6, nianBeastGame.beastLevel - 1);
        nianBeastGame.beastCurrentHp = nianBeastGame.beastMaxHp;
        nianBeastGame.beastAtk = 1e2 * Math.pow(3, nianBeastGame.beastLevel - 1);
        
        // 重置技能状态
        nianBeastGame.skillTriggeredDeath = false;
        nianBeastGame.lastComboSkill = '';
        nianBeastGame.skillCombo = 0;
        
        // 每2级解锁新技能
        if (nianBeastGame.beastLevel % 2 === 0) {
            unlockNianBeastSkill(nianBeastGame.beastLevel);
        }
        
        addNianBattleLog(`🎉 成功击败年兽！进入第 ${nianBeastGame.beastLevel} 级！`, 'success');
        
        // 第一层进入第二层时的特殊提示
        if (nianBeastGame.beastLevel === 2) {
            addNianBattleLog(`🎯 恭喜通过试炼！从第2层开始有丰厚奖励！`, 'success');
            addNianBattleLog(`💰 奖励预览已更新！`, 'warning');
        }
        
        // 每2级提示
        if (nianBeastGame.beastLevel % 2 === 0) {
            addNianBattleLog(`🌟 年兽学习了新的技能！`, 'skill', '#FFD700');
        }
        
        // 给予少量回血奖励
        nianBeastGame.playerHp = Math.min(nianBeastGame.playerHp + nianBeastGame.playerMaxHp * 0.5, nianBeastGame.playerMaxHp);
        addNianBattleLog(`❤️ 恢复50%生命值`, 'heal');
    }
}
function unlockNianBeastSkill(level) {
    const newSkills = [
        { level: 2, name: '雷霆一击', multiplier: 5.0, chance: 0.03, message: '⚡ 年兽领悟雷霆一击！5.0倍伤害', color: '#8A2BE2', icon: '⚡' },
        { level: 4, name: '地震践踏', multiplier: 7.5, chance: 0.03, message: '🌋 年兽领悟地震践踏！7.5倍伤害', color: '#8A2BE2', icon: '🌋' },
        { level: 6, name: '冰霜吐息', multiplier: 10.0, chance: 0.03, message: '❄️ 年兽领悟冰霜吐息！10倍伤害', color: '#8A2BE2', icon: '❄️' },
        { level: 8, name: '烈火焚天', multiplier: 12.5, chance: 0.03, message: '🔥 年兽领悟烈火焚天！12.5倍伤害', color: '#8A2BE2', icon: '🔥' },
        { level: 10, name: '时空撕裂', multiplier: 15.0, chance: 0.03, message: '⏰ 年兽领悟时空撕裂！15倍伤害', color: '#8A2BE2', icon: '⏰' },
        { level: 12, name: '混沌灾厄', multiplier: 20.0, chance: 0.03, message: '🌪️ 年兽领悟混沌灾厄！20倍伤害', color: '#8A2BE2', icon: '🌪️' },
        { level: 14, name: '神兽降临', multiplier: 30.0, chance: 0.03, message: '🐉 年兽领悟神兽降临！30倍伤害', color: '#8A2BE2', icon: '🐉' },
        { level: 16, name: '天道制裁', multiplier: 40.0, chance: 0.03, message: '⚖️ 年兽领悟天道制裁！40倍伤害', color: '#8A2BE2', icon: '⚖️' },
        { level: 18, name: '洪荒之力', multiplier: 50.0, chance: 0.03, message: '🌍 年兽领悟洪荒之力！50倍伤害', color: '#8A2BE2', icon: '🌍' },
        { level: 20, name: '创世毁灭', multiplier: 100.0, chance: 0.03, message: '💫 年兽领悟创世毁灭！100倍毁灭打击', color: '#8A2BE2', icon: '💫' }
    ];
    
   const unlockedSkill = newSkills.find(skill => skill.level === level);
    if (unlockedSkill) {
        // 添加到当前战斗的技能池（不修改基础配置）
        nianBeastSkills.push({
            name: unlockedSkill.name,
            description: `Lv.${level}解锁的强力技能`,
            multiplier: unlockedSkill.multiplier,
            chance: unlockedSkill.chance,
            message: unlockedSkill.message,
            color: unlockedSkill.color,
            icon: unlockedSkill.icon
        });
        
        addNianBattleLog(`🎯 年兽解锁新技能: ${unlockedSkill.name}！`, 'skill', '#8A2BE2');
    }
}


// 结束战斗
function endNianBeastBattle(isVictory) {
    nianBeastGame.isInBattle = false;
    nianBeastGame.hasTokenCost = false;
    
    // 启用挑战按钮
    document.getElementById('challengeNianBtn').disabled = false;
    document.getElementById('challengeNianBtn').style.background = 'linear-gradient(145deg, #FFD700, #FFA500)';
    document.getElementById('challengeNianBtn').style.cursor = 'pointer';
    
    // 禁用攻击、防御、逃跑按钮
    document.getElementById('nianAttackBtn').disabled = true;
    document.getElementById('nianAttackBtn').style.background = '#666';
    document.getElementById('nianAttackBtn').style.cursor = 'not-allowed';
    document.getElementById('nianDefendBtn').disabled = true;
    document.getElementById('nianDefendBtn').style.background = '#666';
    document.getElementById('nianDefendBtn').style.cursor = 'not-allowed';
    document.getElementById('nianEscapeBtn').disabled = true;
    document.getElementById('nianEscapeBtn').style.background = '#666';
    document.getElementById('nianEscapeBtn').style.cursor = 'not-allowed';
    
    // 战斗结束后不立即重置技能，等待下次挑战时重置
    
    if (!isVictory) {
        // 玩家死亡或逃跑，结算奖励
        let defeatedLevel = nianBeastGame.beastLevel;
        
        // 更新最高记录
        if (defeatedLevel > (player.nianBeast.highestLevel || 0)) {
            player.nianBeast.highestLevel = defeatedLevel;
        }
        
        player.nianBeast.totalKills++;
        
        // 第一层没有奖励提示
        if (defeatedLevel <= 1) {
            addNianBattleLog('📢 第一层试炼结束，无奖励', 'info');
            addNianBattleLog('🎯 继续挑战第二层获取奖励！', 'warning');
            
            // 自动关闭副本（可选）
            setTimeout(() => {
                closeNianBeastDungeon();
            }, 2000);
        } else {
            // 显示奖励弹窗
            showNianRewards(defeatedLevel);
        }
    }
}

// 显示奖励弹窗
function showNianRewards(level) {
    // 第一层没有奖励
    if (level <= 1) {
        closeNianBeastDungeon();
        alert('🎯 第一层是试炼阶段，从第二层开始才有奖励！\n\n继续挑战吧！');
        addNianBattleLog('📢 第一层是试炼阶段，无奖励', 'info');
        addNianBattleLog('🎯 从第二层开始才有丰厚奖励！', 'warning');
        return;
    }
    
    // 生成奖励
    let rewards = generateNianRewards(level);
    
    document.getElementById('rewardBeastLevel').innerHTML = level;
    
    // 添加解锁层数显示
    let unlockInfo = '';
    if (level >= 20) unlockInfo = '✨ 全部奖励已解锁！';
    else if (level >= 15) unlockInfo = '🔓 下一解锁: 混元道果丹(20层)';
    else if (level >= 12) unlockInfo = '🔓 下一解锁: 进阶神石(15层)';
    else if (level >= 10) unlockInfo = '🔓 下一解锁: 九转轮回丹(12层)';
    else if (level >= 8) unlockInfo = '🔓 下一解锁: 血脉检测剂(10层)';
    else if (level >= 6) unlockInfo = '🔓 下一解锁: 渡厄金还丹(8层)';
    else if (level >= 4) unlockInfo = '🔓 下一解锁: 灵根检测器(6层)';
    else if (level >= 1) unlockInfo = '🔓 下一解锁: 凝元固窍丹(4层)';
    
    let rewardsHtml = `
        <div style="margin-bottom: 15px; padding: 8px; background: rgba(255,215,0,0.2); border-radius: 10px; text-align: center; color: #FFD700; font-size: 13px;">
            ${unlockInfo}
        </div>
    `;
    
    // 奖励名称映射
    const rewardNames = {
        'danyao1': '蕴灵筑基丹',
        'danyao2': '凝元固窍丹',
        'danyao3': '渡厄金还丹',
        'danyao4': '九转轮回丹',
        'danyao5': '混元道果丹',
        'rootDetector': '灵根检测器',
        'bloodlineDetector': '血脉检测剂',
        'advanceStone': '进阶神石'
    };
    
    // 奖励图标映射
    const rewardIcons = {
        'danyao1': '💊',
        'danyao2': '💊',
        'danyao3': '💊',
        'danyao4': '💊',
        'danyao5': '💊',
        'advanceStone': '🌑',
        'bloodlineDetector': '💉',
        'rootDetector': '🌿'
    };
    
    // 奖励颜色映射
    const rewardColors = {
        'danyao1': '#4CAF50',
        'danyao2': '#2196F3',
        'rootDetector': '#9C27B0',
        'danyao3': '#FF5722',
        'bloodlineDetector': '#FFD700',
        'danyao4': '#673AB7',
        'advanceStone': '#00BCD4',
        'danyao5': '#E91E63'
    };
    
    for (let [itemKey, amount] of Object.entries(rewards)) {
        let name = rewardNames[itemKey] || itemKey;
        let icon = rewardIcons[itemKey] || '🎁';
        let color = rewardColors[itemKey] || '#FFD700';
        
        rewardsHtml += `
            <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 15px; display: flex; align-items: center; gap: 10px; border-left: 5px solid ${color};">
                <span style="font-size: 24px;">${icon}</span>
                <div style="flex: 1;">
                    <div style="font-size: 14px; color: #FFD700;">${name}</div>
                    <div style="font-size: 20px; font-weight: bold; color: white;">+${amount}</div>
                </div>
            </div>
        `;
    }
    
    document.getElementById('nianRewardItems').innerHTML = rewardsHtml;
    
    // 显示奖励弹窗
    document.getElementById('nianRewardOverlay').style.display = 'block';
    document.getElementById('nianRewardUI').style.display = 'block';
    
    // 保存当前奖励到临时变量，等待领取
    window.currentNianRewards = rewards;
}

// 生成年兽奖励
function generateNianRewards(level) {
    let rewards = {};
    
 
    if (level >= 1) {
        rewards['danyao1'] = Math.floor(Math.random() * (8 * level - 3 * level + 1) + 3 * level);
    }
    
    
    if (level >= 4) {
        rewards['danyao2'] = Math.floor(Math.random() * (6 * level - 3 * level + 1) + 3 * level);
    }
    
   
    if (level >= 6) {
        rewards['rootDetector'] = Math.floor(Math.random() * (2 * level - 1 * level + 1) + 1 * level);
    }
    
    
    if (level >= 8) {
        rewards['danyao3'] = Math.floor(Math.random() * (4 * level - 1 * level + 1) + 1 * level);
    }
    

    if (level >= 10) {

        rewards['bloodlineDetector'] = Math.floor(Math.random() * (2 * level - 1 * level + 1) + 1 * level);
    }
    

    if (level >= 12) {

        rewards['danyao4'] = Math.floor(Math.random() * (3 * level - 1 * level + 1) + 1 * level);
    }
    

    if (level >= 15) {

        rewards['advanceStone'] = Math.floor(Math.random() * (2 * level - 1 * level + 1) + 1 * level);
    }
    

    if (level >= 20) {

        rewards['danyao5'] = Math.floor(Math.random() * (2 * level - 1 * level + 1) + 1 * level);
    }
    
    return rewards;
}


// 领取奖励
function claimNianRewards() {
    if (!window.currentNianRewards) {
        alert('没有可领取的奖励！');
        return;
    }
    
    // 确保items对象存在
    if (!player.items) {
        player.items = {};
    }
    
    // 添加奖励到玩家背包
    for (let [itemKey, amount] of Object.entries(window.currentNianRewards)) {
        player.items[itemKey] = (player.items[itemKey] || 0) + amount;
    }
    
    // 更新记录
    player.nianBeast.rewardsCollected += Object.values(window.currentNianRewards).reduce((a,b) => a + b, 0);
    
    // 关闭奖励弹窗
    closeNianRewards();
    
    // 显示成功提示
    alert(`🎉 成功领取讨伐奖励！`);
    
    // 更新显示
    updateDisplay();
    if (typeof updatePillSystemUI === 'function') {
        updatePillSystemUI();
    }
}

// 关闭奖励弹窗
function closeNianRewards() {
    document.getElementById('nianRewardOverlay').style.display = 'none';
    document.getElementById('nianRewardUI').style.display = 'none';
}


// 添加战斗日志
function addNianBattleLog(message, type = 'normal', color = null) {
    let logDiv = document.getElementById('nianBattleLog');
    let newLog = document.createElement('div');
    
    let textColor = '#aaa';
    let prefix = '•';
    
    switch(type) {
        case 'success': 
            textColor = '#4CAF50'; 
            prefix = '✅'; 
            break;
        case 'error': 
            textColor = '#f44336'; 
            prefix = '❌'; 
            break;
        case 'warning': 
            textColor = '#FFD700'; 
            prefix = '⚠️'; 
            break;
        case 'crit': 
            textColor = '#FFD700'; 
            prefix = '⚡'; 
            break;
        case 'damage': 
            textColor = '#FF6B6B'; 
            prefix = '💢'; 
            break;
        case 'defend': 
            textColor = '#4CAF50'; 
            prefix = '🛡️'; 
            break;
        case 'heal': 
            textColor = '#4CAF50'; 
            prefix = '❤️'; 
            break;
        case 'skill': 
            textColor = color || '#9C27B0'; 
            prefix = '🎯'; 
            break;
        case 'artifact':
            textColor = '#FF6B6B';
            prefix = '🌟';
            break;
        case 'info':
            textColor = '#aaa';
            prefix = '📌';
            break;
        case 'quote':
            textColor = '#FFD700';
            prefix = '💬';
            break;
    }
    
    // 添加时间戳
    let timestamp = new Date().toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    
    newLog.style.marginBottom = '4px';
    newLog.style.padding = '4px 0';
    newLog.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
    newLog.style.fontSize = '12px';
    newLog.style.display = 'flex';
    newLog.style.alignItems = 'center';
    newLog.style.gap = '5px';
    newLog.style.animation = 'fadeIn 0.3s';
    
    newLog.innerHTML = `
        <span style="color: #666; font-size: 10px; min-width: 55px;">[${timestamp}]</span>
        <span style="color: ${textColor}; font-weight: ${type === 'skill' || type === 'artifact' ? 'bold' : 'normal'}; min-width: 20px;">${prefix}</span>
        <span style="color: ${textColor}; flex: 1;">${message}</span>
    `;
    
    // 将新日志插入到最前面
    logDiv.insertBefore(newLog, logDiv.firstChild);
    
    // 限制日志条数
    while (logDiv.children.length > 50) {
        logDiv.removeChild(logDiv.lastChild);
    }
}

function clearNianBattleLog() {
    let logDiv = document.getElementById('nianBattleLog');
    logDiv.innerHTML = '';
    
    // 添加默认提示信息
    let defaultLog = document.createElement('div');
    defaultLog.style.marginBottom = '4px';
    defaultLog.style.padding = '4px 0';
    defaultLog.style.fontSize = '12px';
    defaultLog.style.color = '#666';
    defaultLog.style.textAlign = 'center';
    defaultLog.style.width = '100%';
    defaultLog.innerHTML = '✨ 战斗即将开始...';
    logDiv.appendChild(defaultLog);
}

// 更新战斗UI
function updateNianBattleUI() {
    // 更新令牌
    if (document.getElementById('nianDungeonToken')) {
        document.getElementById('nianDungeonToken').innerHTML = player.nianBeast?.dungeonToken || 0;
    }
}

// 获取奖励图标
function getRewardIcon(item) {
    const icons = {
        '蕴灵筑基丹': '💊',
        '凝元固窍丹': '💊',
        '渡厄金还丹': '💊',
        '九转轮回丹': '💊',
        '混元道果丹': '💊',
        '灵根检测器': '🌿',
        '血脉检测剂': '💉',
        '进阶神石': '🌑'
    };
    return icons[item] || '🎁';
}

// 获取奖励颜色
function getRewardColor(item) {
    const colors = {
        '蕴灵筑基丹': '#4CAF50',
        '凝元固窍丹': '#2196F3',
        '灵根检测器': '#9C27B0',
        '渡厄金还丹': '#FF5722',
        '血脉检测剂': '#FFD700',
        '九转轮回丹': '#673AB7',
        '进阶神石': '#00BCD4',
        '混元道果丹': '#E91E63'
    };
    return colors[item] || '#FFD700';
}

// 格式化数字
function formatNumber(num) {
    if (num >= 1e12) return (num / 1e12).toFixed(2) + '兆';
    if (num >= 1e9) return (num / 1e9).toFixed(2) + '亿';
    if (num >= 1e6) return (num / 1e6).toFixed(2) + '百万';
    if (num >= 1e4) return (num / 1e4).toFixed(2) + '万';
    return num.toFixed(0);
}
const pillConfig = {
    danyao1: {
        name: '蕴灵筑基丹',
        exp: 10000,
        color: '#4CAF50',
        icon: '💊',
        itemKey: 'danyao1'
    },
    danyao2: {
        name: '凝元固窍丹',
        exp: 100000,
        color: '#2196F3',
        icon: '💊',
        itemKey: 'danyao2'
    },
    danyao3: {
        name: '渡厄金还丹',
        exp: 1000000,
        color: '#9C27B0',
        icon: '💊',
        itemKey: 'danyao3'
    },
    danyao4: {
        name: '九转轮回丹',
        exp: 10000000,
        color: '#FF5722',
        icon: '💊',
        itemKey: 'danyao4'
    },
    danyao5: {
        name: '混元道果丹',
        exp: 100000000,
        color: '#FFD700',
        icon: '💊',
        itemKey: 'danyao5'
    }
};

// 切换丹药系统界面
function togglePillSystem() {
    const ui = document.getElementById('pillSystemUI');
    const overlay = document.getElementById('pillSystemOverlay');
    
    if (ui.style.display === 'block') {
        ui.style.display = 'none';
        overlay.style.display = 'none';
    } else {
        ui.style.display = 'block';
        overlay.style.display = 'block';
        updatePillSystemUI();
    }
}

// 更新丹药系统UI
function updatePillSystemUI() {
    if (!player.items) player.items = {};
    
    // 更新经验显示
    if (player.cultivation) {
        document.getElementById('pillCurrentExp').textContent = formatNumber(player.cultivation.exp);
        
        const nextStage = cultivationStages[player.cultivation.stage + 1];
        if (nextStage) {
            document.getElementById('pillNextExp').textContent = formatNumber(nextStage.expRequired);
            
            const progress = Math.min(100, (player.cultivation.exp / nextStage.expRequired) * 100);
            document.getElementById('pillExpProgress').style.width = `${progress}%`;
        }
    }
    
    // 更新各道具数量
    document.getElementById('pillSoulCount').textContent = player.items['danyao1'] || 0;
    document.getElementById('pillGemCount').textContent = player.items['danyao2'] || 0;
    document.getElementById('pillPillCount').textContent = player.items['danyao3'] || 0;
    document.getElementById('pillPouchCount').textContent = player.items['danyao4'] || 0;
    document.getElementById('pillStarBillCount').textContent = player.items['danyao5'] || 0;
    
    // 更新按钮状态
    updatePillButtons();
}


// 更新按钮状态
function updatePillButtons() {
    const buttons = [
        { id: 'useSoulBtn', count: player.items['danyao1'] || 0 },
        { id: 'useGemBtn', count: player.items['danyao2'] || 0 },
        { id: 'usePillBtn', count: player.items['danyao3'] || 0 },
        { id: 'usePouchBtn', count: player.items['danyao4'] || 0 },
        { id: 'useStarBillBtn', count: player.items['danyao5'] || 0 },
        { id: 'useSoulMaxBtn', count: player.items['danyao1'] || 0 },
        { id: 'useGemMaxBtn', count: player.items['danyao2'] || 0 },
        { id: 'usePillMaxBtn', count: player.items['danyao3'] || 0 },
        { id: 'usePouchMaxBtn', count: player.items['danyao4'] || 0 },
        { id: 'useStarBillMaxBtn', count: player.items['danyao5'] || 0 }
    ];
    
    buttons.forEach(btn => {
        const element = document.getElementById(btn.id);
        if (element) {
            if (btn.count <= 0) {
                element.disabled = true;
                element.style.background = '#666';
                element.style.cursor = 'not-allowed';
                element.style.opacity = '0.5';
            } else {
                element.disabled = false;
                element.style.opacity = '1';
                // 恢复原来的渐变背景
                if (btn.id.includes('Max')) {
                    element.style.background = 'linear-gradient(45deg, #FF69B4, #C71585)';
                } else if (btn.id.includes('Soul')) {
                    element.style.background = 'linear-gradient(45deg, #4CAF50, #2E7D32)';
                } else if (btn.id.includes('Gem')) {
                    element.style.background = 'linear-gradient(45deg, #2196F3, #0D47A1)';
                } else if (btn.id.includes('Pill')) {
                    element.style.background = 'linear-gradient(45deg, #9C27B0, #6A1B9A)';
                } else if (btn.id.includes('Pouch')) {
                    element.style.background = 'linear-gradient(45deg, #FF5722, #D84315)';
                } else if (btn.id.includes('StarBill')) {
                    element.style.background = 'linear-gradient(45deg, #FFD700, #FFA500)';
                }
                element.style.cursor = 'pointer';
            }
        }
    });
}

// 使用丹药
function usePill(type, amount) {
    if (!player.items) player.items = {};
    if (!player.cultivation) {
        alert('请先开启修仙系统！');
        return;
    }
    
    const config = pillConfig[type];
    if (!config) return;
    
    let count = player.items[config.itemKey] || 0;
    
    if (count <= 0) {
        alert(`❌ 没有足够的${config.name}！`);
        return;
    }
    
    let useCount = amount === 'max' ? count : Math.min(amount, count);
    
    // 计算获得经验（洞府聚灵阵加成）
    const grottoBonus = typeof getGrottoCultivationExpBonus === 'function' ? getGrottoCultivationExpBonus() : 1;
    let expGain = useCount * config.exp * grottoBonus;
    
    // 扣除道具
    player.items[config.itemKey] -= useCount;
    
    // 增加修仙经验
    player.cultivation.exp += expGain;
    
    // 显示成功信息
    let message = `✨ 使用 ${useCount} 个${config.name}，获得 ${formatNumber(expGain)} 点修仙经验！`;
    showPillNotification(message, config.color);
    
    // 更新显示
    updatePillSystemUI();
    updateCultivationUI();
    updateDisplay();
}


// 一键使用所有丹药
function useAllPills() {
    if (!player.items) player.items = {};
    if (!player.cultivation) {
        alert('请先开启修仙系统！');
        return;
    }
    
    let totalExp = 0;
    let usedItems = [];
    
    // 洞府聚灵阵加成
    const grottoBonus = typeof getGrottoCultivationExpBonus === 'function' ? getGrottoCultivationExpBonus() : 1;
    // 检查每种道具
    for (let [type, config] of Object.entries(pillConfig)) {
        let count = player.items[config.itemKey] || 0;
        if (count > 0) {
            let expGain = count * config.exp * grottoBonus;
            totalExp += expGain;
            usedItems.push(`${config.name}×${count}`);
            
            // 扣除道具
            player.items[config.itemKey] = 0;
        }
    }
    
    if (totalExp > 0) {
        // 增加修仙经验
        player.cultivation.exp += totalExp;
        
        // 显示成功信息
        let message = `✨ 一键使用: ${usedItems.join('、')}\n获得 ${formatNumber(totalExp)} 点修仙经验！`;
        showPillNotification(message, '#FF69B4');
        
        // 更新显示
        updatePillSystemUI();
        updateCultivationUI();
        updateDisplay();
    } else {
        alert('❌ 没有可使用的丹药！');
    }
}


// 显示丹药使用提示
function showPillNotification(message, color) {
    const notification = document.createElement('div');
    notification.style.position = 'fixed';
    notification.style.top = '20px';
    notification.style.right = '20px';
    notification.style.background = `linear-gradient(145deg, ${color}40, ${color}20)`;
    notification.style.color = 'white';
    notification.style.padding = '20px';
    notification.style.borderRadius = '15px';
    notification.style.borderLeft = `5px solid ${color}`;
    notification.style.boxShadow = '0 5px 20px rgba(0,0,0,0.3)';
    notification.style.zIndex = '9999';
    notification.style.minWidth = '250px';
    notification.style.maxWidth = '350px';
    notification.style.transform = 'translateX(400px)';
    notification.style.transition = 'transform 0.5s ease-out';
    notification.style.fontSize = '14px';
    notification.style.lineHeight = '1.5';
    notification.style.whiteSpace = 'pre-line';
    
    notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
            <span style="font-size: 24px;">💊</span>
            <div>
                <div style="font-weight: bold; color: ${color}; margin-bottom: 5px;">丹药使用成功</div>
                <div style="color: #FFD700;">${message}</div>
            </div>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
    }, 10);
    
    setTimeout(() => {
        notification.style.transform = 'translateX(400px)';
        setTimeout(() => {
            if (notification.parentNode) {
                document.body.removeChild(notification);
            }
        }, 500);
    }, 5000);
}

// 在打开修仙系统时确保丹药系统数据存在
function initCultivationSystem() {
    if (!player.cultivation) {
        player.cultivation = {
            stage: 0,
            exp: 0,
            root: null,
            bloodline: null,
            bonus: 1
        };
    }
    
    // 确保物品系统存在
    if (!player.items) {
        player.items = {};
    }
}
const trialMonsterSkills = [
    {
        name: '普通攻击',
        multiplier: 1.0,
        chance: 0.40, // 40%几率
        message: '👾 怪物普通攻击',
        color: '#aaa',
        icon: '👾'
    },
    {
        name: '重击',
        multiplier: 1.5,
        chance: 0.25, // 25%几率
        message: '💪 怪物发动重击！造成1.5倍伤害',
        color: '#FF9800',
        icon: '💪'
    },
    {
        name: '狂暴一击',
        multiplier: 2.0,
        chance: 0.15, // 15%几率
        message: '⚡ 怪物狂暴一击！造成2倍伤害',
        color: '#FF5722',
        icon: '⚡'
    },
    {
        name: '致命连击',
        multiplier: 2.5,
        chance: 0.10, // 10%几率
        message: '💥 怪物致命连击！造成2.5倍伤害',
        color: '#f44336',
        icon: '💥'
    },
    {
        name: '毁灭打击',
        multiplier: 3.0,
        chance: 0.05, // 5%几率
        message: '🌋 怪物毁灭打击！造成3倍伤害',
        color: '#9C27B0',
        icon: '🌋'
    },
    {
        name: '末日审判',
        multiplier: 4.0,
        chance: 0.03, // 3%几率
        message: '🔥 末日审判！造成5倍毁灭性伤害',
        color: '#FFD700',
        icon: '🔥'
    },
    {
        name: '时空撕裂',
        multiplier: 5.0,
        chance: 0.015, // 1.5%几率
        message: '⏰ 时空撕裂！造成5倍伤害',
        color: '#00BCD4',
        icon: '⏰'
    },
    {
        name: '混沌降临',
        multiplier: 10.0,
        chance: 0.005, // 0.5%几率
        message: '🌌 混沌降临！造成10倍毁灭打击',
        color: '#8A2BE2',
        icon: '🌌'
    }
];
let trialTowerGame = {
    currentFloor: 1,
    highestFloor: 0,
    totalChallenges: 0,
    totalWins: 0,
    
    playerHp: 0,
    playerMaxHp: 0,
    playerAtk: 0,
    playerCrit: 0,
    playerCritRate: 0.3,
    
    monsterHp: 0,
    monsterMaxHp: 0,
    monsterAtk: 0,
    
    isDefending: false,
    isInBattle: false,
   lastMonsterSkill: '',
    monsterSkillCombo: 0,
    lastComboSkill: '',
    totalDamageTaken: 0,
  defenseHealCount: 0, 
    defenseTotalHeal: 0, 
  artifactCritCount: 0,
    artifactTotalBonus: 0  
};
const trialArtifactCritConfig = {
    thresholds: [
        { maxBonus: 1.1, chance: 0.05, multiplier: 1, message: '💫 法宝共鸣！造成1倍额外伤害' },
        { maxBonus: 1.3, chance: 0.05, multiplier: 2, message: '⚡ 法宝觉醒！造成2倍暴伤' },
        { maxBonus: 1.4, chance: 0.05, multiplier: 3, message: '✨ 法宝通灵！造成3倍毁灭打击' },
        { maxBonus: 1.5, chance: 0.05, multiplier: 4, message: '🌟 法宝化形！造成4倍天道之力' },
        { maxBonus: 1.6, chance: 0.06, multiplier: 5, message: '🌪️ 法宝混沌！造成5倍洪荒之力' },
        { maxBonus: 1.8, chance: 0.07, multiplier: 6, message: '🔥 法宝焚天！造成6倍寂灭之威' },
        { maxBonus: 2.0, chance: 0.08, multiplier: 7, message: '❄️ 法宝冰封！造成7倍时空冻结' },
        { maxBonus: 2.5, chance: 0.09, multiplier: 8, message: '⚡ 法宝雷动！造成8倍天劫之力' },
        { maxBonus: 3.0, chance: 0.10, multiplier: 9, message: '🌌 法宝虚空！造成9倍混沌之怒' },
        { maxBonus: 3.5, chance: 0.11, multiplier: 10, message: '👑 法宝帝王！造成10倍君临天下' },
        { maxBonus: 4.0, chance: 0.12, multiplier: 15, message: '🐉 法宝神龙！造成15倍龙威震天' },
        { maxBonus: 4.5, chance: 0.13, multiplier: 20, message: '🌍 法宝创世！造成20倍开天辟地' },
        { maxBonus: 5.0, chance: 0.14, multiplier: 25, message: '☯️ 法宝大道！造成25倍道法自然' },
        { maxBonus: Infinity, chance: 0.15, multiplier: 30, message: '∞ 法宝永恒！造成30倍无尽轮回' }
    ],
    
    quotes: {
        1: [
            '「区区怪物，也敢放肆！」',
            '「看我的法宝神威！」',
            '「这一击，只是开胃菜！」',
            '「法宝初显，怪物受死！」'
        ],
        2: [
            '「二倍之力，破你防御！」',
            '「法宝觉醒，怪物颤栗！」',
            '「这一击，让你知道厉害！」',
            '「怪物，尝尝法宝的厉害！」'
        ],
        3: [
            '「三界震动，法宝显圣！」',
            '「怪物，还不伏诛！」',
            '「法宝通灵，诛杀邪祟！」',
            '「这一击，送你归西！」'
        ],
        4: [
            '「四海之内，法宝为尊！」',
            '「怪物，你的死期到了！」',
            '「四倍暴击，荡平怪物！」',
            '「法宝化形，毁天灭地！」'
        ],
        5: [
            '「五雷轰顶，法宝天威！」',
            '「怪物，还不束手就擒！」',
            '「五倍之力，横扫千军！」',
            '「法宝混沌，破碎虚空！」'
        ],
        6: [
            '「六道轮回，法宝超度！」',
            '「怪物，让你魂飞魄散！」',
            '「六倍暴击，诛杀怪物！」',
            '「法宝焚天，烧尽邪魔！」'
        ],
        7: [
            '「七星伴月，法宝无敌！」',
            '「怪物，这一击送你上路！」',
            '「七倍之力，天地变色！」',
            '「法宝冰封，冻结时空！」'
        ],
        8: [
            '「八方来朝，法宝称尊！」',
            '「怪物，受死吧！」',
            '「八倍暴击，毁天灭地！」',
            '「法宝雷动，天劫降临！」'
        ],
        9: [
            '「九霄云外，法宝纵横！」',
            '「怪物，让你永世不得超生！」',
            '「九倍之力，破碎虚空！」',
            '「法宝虚空，吞噬一切！」'
        ],
        10: [
            '「十方俱灭，法宝无敌！」',
            '「怪物，见识真正的力量！」',
            '「十倍暴击，君临天下！」',
            '「法宝帝王，统御万界！」'
        ],
        15: [
            '「十五倍龙威，怪物颤栗！」',
            '「神龙降世，诛杀怪物！」',
            '「法宝神龙，毁天灭地！」',
            '「龙威震天，怪物伏诛！」'
        ],
        20: [
            '「二十倍创世，开天辟地！」',
            '「法宝创世，重演混沌！」',
            '「创世之力，怪物化为虚无！」',
            '「开天辟地，怪物湮灭！」'
        ],
        25: [
            '「二十五倍大道，道法自然！」',
            '「大道至简，一击必杀！」',
            '「法宝大道，怪物超度！」',
            '「道法自然，怪物归西！」'
        ],
        30: [
            '「三十倍永恒，无尽轮回！」',
            '「永恒法宝，超越时空！」',
            '「无尽轮回，怪物永世不得超生！」',
            '「法宝永恒，与天地同寿！」'
        ]
    },
    
    specialQuotes: [
        { chance: 0.001, quote: '👑 「吾之法宝，可破苍穹！」' },
        { chance: 0.001, quote: '🌌 「这一击，蕴含宇宙真理！」' },
        { chance: 0.001, quote: '⚡ 「天大地大，法宝最大！」' },
        { chance: 0.001, quote: '🔥 「怪物，不过如此！」' },
        { chance: 0.001, quote: '❄️ 「法宝一出，谁与争锋！」' },
        { chance: 0.001, quote: '💫 「让你见识真正的法宝之力！」' }
    ]
};
function getTrialEquippedArtifactBonus() {
    if (!player.magicTools || !player.magicTools.equipped) {
        return 1.0;
    }
    
    const tool = magicToolConfig.tools.find(t => t.id === player.magicTools.equipped);
    return tool ? tool.bonus : 1.0;
}
function triggerTrialArtifactCrit() {
    const artifactBonus = getTrialEquippedArtifactBonus();
    
    // 找到对应的加成区间
    let config = trialArtifactCritConfig.thresholds.find(t => artifactBonus <= t.maxBonus);
    if (!config) {
        config = trialArtifactCritConfig.thresholds[trialArtifactCritConfig.thresholds.length - 1];
    }
    
    // 5%几率触发
    if (Math.random() < config.chance) {
        // 随机选择霸气语录
        let quotes = trialArtifactCritConfig.quotes[config.multiplier] || trialArtifactCritConfig.quotes[1];
        let quote = quotes[Math.floor(Math.random() * quotes.length)];
        
        // 极低概率触发特殊台词
        for (let special of trialArtifactCritConfig.specialQuotes) {
            if (Math.random() < special.chance) {
                quote = special.quote;
                break;
            }
        }
        
        return {
            triggered: true,
            multiplier: config.multiplier,
            quote: quote,
            message: config.message
        };
    }
    
    return { triggered: false };
}

function getMonsterSkillsForFloor(floor) {
    let skills = JSON.parse(JSON.stringify(trialMonsterSkills));
    
    // 根据层数调整技能几率
    if (floor >= 60) {
        
        skills[4].chance = 0.08; // 毁灭打击 8%
        skills[5].chance = 0.05; // 末日审判 5%
    }
    if (floor >= 120) {
        skills[5].chance = 0.07; // 末日审判 7%
        skills[6].chance = 0.03; // 时空撕裂 3%
    }
    if (floor >= 200) {
        skills[6].chance = 0.05; // 时空撕裂 5%
        skills[7].chance = 0.02; // 混沌降临 2%
    }
    if (floor >= 300) {
        skills[7].chance = 0.05; // 混沌降临 5%
    }
    if (floor >= 400) {        
        skills.forEach(skill => {
            if (skill.multiplier >= 3.0) {
                skill.chance = Math.min(skill.chance * 1.5, 0.15);
            }
        });
    }
    
    return skills;
}
// 初始化试练塔系统
function initTrialTower() {
    if (!player.trialTower) {
        player.trialTower = {
            currentFloor: 1,
            highestFloor: 0,
            totalChallenges: 0,
            totalWins: 0
        };
    }
    
    // 同步玩家数据
    trialTowerGame.currentFloor = player.trialTower.currentFloor || 1;
    trialTowerGame.highestFloor = player.trialTower.highestFloor || 0;
    trialTowerGame.totalChallenges = player.trialTower.totalChallenges || 0;
    trialTowerGame.totalWins = player.trialTower.totalWins || 0;
}

// 计算怪物属性（每层提升）
function calculateMonsterStats(floor) {
    // 基础属性
    let baseHp = 100000; // 10万基础血量
    let baseAtk = 5000;   // 5000基础攻击
    
    // 每层提升：血量增加10%，攻击增加10%
    let hpMultiplier = Math.pow(1.1, floor - 1);
    let atkMultiplier = Math.pow(1.05, floor - 1);
    
    return {
        hp: Math.floor(baseHp * hpMultiplier),
        atk: Math.floor(baseAtk * atkMultiplier)
    };
}

// 获取怪物名称
function getMonsterName(floor) {
    const names = [
        '试练守卫', '暗影战士', '火焰魔像', '冰霜巨人', '雷霆使者',
        '地狱守卫', '天使战士', '恶魔领主', '混沌魔龙', '虚空吞噬者',
        '时空主宰', '命运编织者', '永恒守护者', '创世神使', '毁灭使者'
    ];
    
    if (floor <= 15) {
        return names[floor - 1] || `试练怪物·${floor}层`;
    } else {
        return `试练尊者·${floor}层`;
    }
}

// 打开试练塔
function openTrialTower() {
     if (player.cultivation.stage < 10) {
        alert("需要达到修仙10级才能开启试练塔！");
        return;
    }
    initTrialTower();
    toggleAutoBuyShopb();
    // 计算玩家属性
    updateTrialPlayerStats();
    
    // 重置当前怪物
    resetTrialMonster();
    
    // 设置战斗状态
    trialTowerGame.isInBattle = true;
    trialTowerGame.isDefending = false;
    
    // 重置技能相关
    trialTowerGame.monsterSkillCombo = 0;
    trialTowerGame.lastComboSkill = '';
    trialTowerGame.lastMonsterSkill = '';
    
    // 重置防御回复统计
    trialTowerGame.defenseHealCount = 0;
    trialTowerGame.defenseTotalHeal = 0;
    
    // 重置法宝暴伤统计
    trialTowerGame.artifactCritCount = 0;
    trialTowerGame.artifactTotalBonus = 0;
    
    // 显示UI
    document.getElementById('trialTowerOverlay').style.display = 'block';
    document.getElementById('trialTowerUI').style.display = 'block';
    
    // 启用攻击防御按钮
    document.getElementById('trialAttackBtn').disabled = false;
    document.getElementById('trialDefendBtn').disabled = false;
    document.getElementById('trialRestartBtn').disabled = false;
    
    // 更新显示（会同时更新奖励预览）
    updateTrialTowerUI();
    
    // 清空并添加欢迎日志
    clearTrialBattleLog();
    addTrialBattleLog('🗼 欢迎来到无限试练塔！', 'success');
    addTrialBattleLog(`📊 当前第 ${trialTowerGame.currentFloor} 层`, 'info');
    addTrialBattleLog(`👾 怪物: ${getMonsterName(trialTowerGame.currentFloor)}`, 'warning');
    addTrialBattleLog('🛡️ 防御有20%几率回复25%生命值', 'info', '#4CAF50');
    
    // 检查是否有法宝
    const artifactBonus = getTrialEquippedArtifactBonus();
    if (artifactBonus > 1.0) {
        const config = trialArtifactCritConfig.thresholds.find(t => artifactBonus <= t.maxBonus) || trialArtifactCritConfig.thresholds[0];
        addTrialBattleLog(`🌟 法宝暴伤: ${(config.chance * 100).toFixed(0)}%几率触发${config.multiplier}倍伤害`, 'info', '#FF6B6B');
    }
    
    // 显示怪物技能信息
    const skills = getMonsterSkillsForFloor(trialTowerGame.currentFloor);
    addTrialBattleLog('════════ 怪物技能 ════════', 'info', '#9C27B0');
    skills.forEach(skill => {
        if (skill.chance > 0.01) {
            addTrialBattleLog(`${skill.icon} ${skill.name}: ${(skill.chance * 100).toFixed(1)}% | ${skill.multiplier}倍`, 'info', skill.color);
        }
    });
    addTrialBattleLog('════════════════════════', 'info', '#9C27B0');
    
    // 显示当前层奖励信息
    let currentReward = getRewardForFloor(trialTowerGame.currentFloor);
    if (currentReward.amount > 0) {
        addTrialBattleLog(`🎁 当前层奖励: ${currentReward.name}×${currentReward.amount}`, 'success');
    }
}
function updateRewardDescriptions() {
    let floor1 = parseInt(document.getElementById('trialNextRewardFloor').innerHTML);
    let floor2 = parseInt(document.getElementById('trialNextRewardFloor2').innerHTML);
    
    let reward1 = getRewardForFloor(floor1);
    let reward2 = getRewardForFloor(floor2);
    
    document.getElementById('trialNextRewardDesc1').innerHTML = reward1.amount > 0 ? `${reward1.name}×${reward1.amount}` : '无奖励';
    document.getElementById('trialNextRewardDesc2').innerHTML = reward2.amount > 0 ? `${reward2.name}×${reward2.amount}` : '无奖励';
}
// 关闭试练塔
function closeTrialTower() {
    document.getElementById('trialTowerOverlay').style.display = 'none';
    document.getElementById('trialTowerUI').style.display = 'none';
}

// 计算玩家属性，宗门藏经阁传承加成修仙副本属性
function updateTrialPlayerStats() {
    const sectLib = typeof getSectLibraryBonus === 'function' ? getSectLibraryBonus() : {};
    const libHealth = 1 + (sectLib.dungeonHealth || 0);
    const libAttack = 1 + (sectLib.dungeonAttack || 0);
    const libCritRate = sectLib.dungeonCritRate || 0;
    const libCritDmg = 1 + (sectLib.dungeonCritDamage || 0);
    if (!player.cultivation || !player.cultivation.root || !player.cultivation.bloodline) {
        trialTowerGame.playerMaxHp = player.reincarnationCount * 10000 * libHealth;
        trialTowerGame.playerHp = trialTowerGame.playerMaxHp;
        trialTowerGame.playerAtk = player.reincarnationCount * 1000 * libAttack;
        trialTowerGame.playerCritRate = 0.3 + libCritRate;
        trialTowerGame.playerCrit = 1.5 * libCritDmg;
    } else {
        // 生命值 = (转生数 * 10000) * 灵根加成 * 血脉加成 * 藏经阁
        trialTowerGame.playerMaxHp = player.reincarnationCount * 10000 * 
                                    (player.cultivation.root.bonus || 1) * 
                                    (player.cultivation.bloodline.bonus || 1) * (1+player.fiveElements.metal.level * 0.2) * libHealth;
        trialTowerGame.playerHp = trialTowerGame.playerMaxHp;
        
        // 攻击力 = 阶段加成 * 装备法宝加成 * 藏经阁
        let stageMultiplier = 1;
        if (player.cultivation && player.cultivation.bonus) {
            stageMultiplier = player.cultivation.bonus;
        }
        
        let toolBonus = 1;
        if (player.magicTools && player.magicTools.equipped) {
            const tool = magicToolConfig.tools.find(t => t.id === player.magicTools.equipped);
            if (tool) toolBonus = tool.bonus;
        }
        
        trialTowerGame.playerAtk = stageMultiplier * toolBonus * 1000 * (1+player.fiveElements.wood.level * 0.05) * (1+player.fiveElements.earth.level * 0.05) * libAttack;
        
        // 爆伤 = 当前境界等级 * 藏经阁
        trialTowerGame.playerCrit = ((player.cultivation.stage || 0) * 0.5 * (1+player.fiveElements.water.level * 0.05) * (1+player.fiveElements.fire.level * 0.05) + 1.5) * libCritDmg;
        trialTowerGame.playerCritRate = 0.3 + libCritRate;
    }
}

// 重置当前层怪物
function resetTrialMonster() {
    const stats = calculateMonsterStats(trialTowerGame.currentFloor);
    trialTowerGame.monsterMaxHp = stats.hp;
    trialTowerGame.monsterHp = stats.hp;
    trialTowerGame.monsterAtk = stats.atk;
}

// 更新试练塔UI
function updateTrialTowerUI() {
    // 更新玩家信息
    document.getElementById('trialPlayerHp').innerHTML = formatNumber(trialTowerGame.playerMaxHp);
    document.getElementById('trialPlayerAtk').innerHTML = formatNumber(trialTowerGame.playerAtk);
    document.getElementById('trialPlayerCrit').innerHTML = ((trialTowerGame.playerCrit - 1) * 100).toFixed(0) + '%';
    
    // 更新怪物信息
    document.getElementById('trialMonsterName').innerHTML = getMonsterName(trialTowerGame.currentFloor);
    document.getElementById('trialMonsterHp').innerHTML = formatNumber(trialTowerGame.monsterMaxHp);
    document.getElementById('trialMonsterAtk').innerHTML = formatNumber(trialTowerGame.monsterAtk);
    document.getElementById('trialMonsterHpText').innerHTML = `${formatNumber(trialTowerGame.monsterHp)} / ${formatNumber(trialTowerGame.monsterMaxHp)}`;
    
    // 更新血条
    let hpPercent = (trialTowerGame.monsterHp / trialTowerGame.monsterMaxHp) * 100;
    document.getElementById('trialMonsterHpBar').style.width = hpPercent + '%';
    
    // 更新战斗中的玩家血条
    document.getElementById('trialBattlePlayerHp').innerHTML = `${formatNumber(trialTowerGame.playerHp)} / ${formatNumber(trialTowerGame.playerMaxHp)}`;
    let playerHpPercent = (trialTowerGame.playerHp / trialTowerGame.playerMaxHp) * 100;
    document.getElementById('trialBattlePlayerHpBar').style.width = playerHpPercent + '%';
    
    // 更新层数信息
    document.getElementById('trialCurrentFloor').innerHTML = trialTowerGame.currentFloor;
    document.getElementById('trialFloorDisplay').innerHTML = trialTowerGame.currentFloor;
    document.getElementById('trialHighestFloor').innerHTML = trialTowerGame.highestFloor;
    document.getElementById('trialTotalChallenges').innerHTML = trialTowerGame.totalChallenges;
    document.getElementById('trialTotalWins').innerHTML = trialTowerGame.totalWins;
    
   updateTrialRewardPreview();
    let nextReward = Math.ceil(trialTowerGame.currentFloor / 10) * 10;
    document.getElementById('trialNextRewardFloor').innerHTML = nextReward;
    document.getElementById('trialNextRewardFloor2').innerHTML = nextReward + 10;
  let skillInfoDiv = document.getElementById('trialMonsterSkillInfo');
    if (!skillInfoDiv) {
        const monsterInfoDiv = document.getElementById('trialMonsterInfo');
        if (monsterInfoDiv) {
            skillInfoDiv = document.createElement('div');
            skillInfoDiv.id = 'trialMonsterSkillInfo';
            skillInfoDiv.style.marginTop = '15px';
            skillInfoDiv.style.padding = '10px';
            skillInfoDiv.style.background = 'rgba(0,0,0,0.3)';
            skillInfoDiv.style.borderRadius = '10px';
            skillInfoDiv.style.border = '1px solid #9C27B0';
            monsterInfoDiv.appendChild(skillInfoDiv);
        }
    }
    if (skillInfoDiv) {
        const skills = getMonsterSkillsForFloor(trialTowerGame.currentFloor);
        const lastSkill = trialTowerGame.lastMonsterSkill || '无';
        const combo = trialTowerGame.monsterSkillCombo || 0;
        
        // 获取最高倍率技能
        const maxSkill = skills.reduce((max, skill) => skill.multiplier > max.multiplier ? skill : max, skills[0]);
        
        skillInfoDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <span style="color: #9C27B0; font-size: 14px; font-weight: bold;">🎯 怪物技能</span>
                <span style="color: #aaa; font-size: 12px;">连击: ${combo}x</span>
            </div>
            <div style="display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 8px;">
                <div style="background: rgba(156,39,176,0.2); padding: 3px 8px; border-radius: 12px; font-size: 11px; color: #FFD700;">
                    上次: ${lastSkill}
                </div>
                <div style="background: rgba(244,67,54,0.2); padding: 3px 8px; border-radius: 12px; font-size: 11px; color: #f44336;">
                    最高: ${maxSkill.name} (${maxSkill.multiplier}x)
                </div>
            </div>
            <div style="font-size: 11px; color: #aaa; margin-top: 5px;">
                技能几率: ${skills.map(s => `${s.icon} ${(s.chance * 100).toFixed(0)}%`).join(' ')}
            </div>
        `;
    }
 let defenseStatsDiv = document.getElementById('trialDefenseStats');
    if (!defenseStatsDiv) {
        const playerInfoDiv = document.querySelector('#trialTowerUI [style*="background: rgba(156,39,176,0.1)"]');
        if (playerInfoDiv) {
            defenseStatsDiv = document.createElement('div');
            defenseStatsDiv.id = 'trialDefenseStats';
            defenseStatsDiv.style.marginTop = '15px';
            defenseStatsDiv.style.padding = '10px';
            defenseStatsDiv.style.background = 'rgba(76,175,80,0.1)';
            defenseStatsDiv.style.borderRadius = '10px';
            defenseStatsDiv.style.border = '1px solid #4CAF50';
            playerInfoDiv.appendChild(defenseStatsDiv);
        }
    }
    
    if (defenseStatsDiv) {
        defenseStatsDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                <span style="font-size: 18px;">🛡️</span>
                <span style="color: #4CAF50; font-weight: bold;">防御回复效果</span>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 12px;">
                <div>
                    <div style="color: #aaa;">触发几率</div>
                    <div style="color: #FFD700; font-weight: bold;">20%</div>
                </div>
                <div>
                    <div style="color: #aaa;">回复量</div>
                    <div style="color: #4CAF50; font-weight: bold;">15%</div>
                </div>
                <div>
                    <div style="color: #aaa;">触发次数</div>
                    <div style="color: #FFD700; font-weight: bold;">${trialTowerGame.defenseHealCount}</div>
                </div>
                <div>
                    <div style="color: #aaa;">总回复量</div>
                    <div style="color: #4CAF50; font-weight: bold;">${formatNumber(trialTowerGame.defenseTotalHeal)}</div>
                </div>
            </div>
        `;
    }
 let artifactStatsDiv = document.getElementById('trialArtifactStats');
    if (!artifactStatsDiv) {
        const playerInfoDiv = document.querySelector('#trialTowerUI [style*="background: rgba(156,39,176,0.1)"]');
        if (playerInfoDiv) {
            artifactStatsDiv = document.createElement('div');
            artifactStatsDiv.id = 'trialArtifactStats';
            artifactStatsDiv.style.marginTop = '15px';
            artifactStatsDiv.style.padding = '10px';
            artifactStatsDiv.style.background = 'rgba(255,107,107,0.1)';
            artifactStatsDiv.style.borderRadius = '10px';
            artifactStatsDiv.style.border = '1px solid #FF6B6B';
            playerInfoDiv.appendChild(artifactStatsDiv);
        }
    }
    
    if (artifactStatsDiv) {
        const artifactBonus = getTrialEquippedArtifactBonus();
        const config = trialArtifactCritConfig.thresholds.find(t => artifactBonus <= t.maxBonus) || trialArtifactCritConfig.thresholds[0];
        
        artifactStatsDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                <span style="font-size: 18px;">🌟</span>
                <span style="color: #FF6B6B; font-weight: bold;">法宝暴伤效果</span>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 12px;">
                <div>
                    <div style="color: #aaa;">当前法宝加成</div>
                    <div style="color: #FFD700; font-weight: bold;">${artifactBonus.toFixed(2)}倍</div>
                </div>
                <div>
                    <div style="color: #aaa;">触发倍率</div>
                    <div style="color: #4CAF50; font-weight: bold;">${config.multiplier}倍</div>
                </div>
                <div>
                    <div style="color: #aaa;">触发几率</div>
                    <div style="color: #FFD700; font-weight: bold;">${(config.chance * 100).toFixed(0)}%</div>
                </div>
                <div>
                    <div style="color: #aaa;">触发次数</div>
                    <div style="color: #FF6B6B; font-weight: bold;">${trialTowerGame.artifactCritCount}</div>
                </div>
            </div>
        `;
    }
}
function updateTrialRewardPreview() {
    let currentFloor = trialTowerGame.currentFloor;
    
    // 计算下一个10层奖励
    let nextReward10 = Math.ceil(currentFloor / 10) * 10;
    let nextReward20 = nextReward10 + 10;
    
    // 根据层数显示不同的奖励内容
    let reward10 = getRewardForFloor(nextReward10);
    let reward20 = getRewardForFloor(nextReward20);
    
    // 更新显示
    document.getElementById('trialNextRewardFloor').innerHTML = nextReward10;
    document.getElementById('trialNextRewardFloor2').innerHTML = nextReward20;
    document.getElementById('trialNextRewardDesc1').innerHTML = reward10.amount > 0 ? `${reward10.name}×${reward10.amount}` : '无奖励';
    document.getElementById('trialNextRewardDesc2').innerHTML = reward20.amount > 0 ? `${reward20.name}×${reward20.amount}` : '无奖励';
    
    // 更新详细奖励预览
    let detailDiv = document.getElementById('trialRewardDetail');
    if (detailDiv) {
        let detailHtml = '<div style="font-size: 13px; color: #FFD700; margin-bottom: 8px;">📋 详细奖励预览</div>';
        
        // 显示最近3个10层奖励
        for (let i = 1; i <= 50; i++) {
            let floor = i * 10;
            if (floor >= currentFloor - 10 && floor <= currentFloor + 20) {
                let reward = getRewardForFloor(floor);
                let status = floor < currentFloor ? '✅' : (floor === currentFloor ? '🎯 当前' : '🔜');
                let color = floor <= currentFloor ? '#4CAF50' : '#FFD700';
                
                if (reward.amount > 0) {
                    detailHtml += `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; padding: 5px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                            <div>
                                <span style="color: ${color};">第${floor}层</span>
                                <span style="color: #aaa; margin-left: 10px;">${reward.name}×${reward.amount}</span>
                            </div>
                            <span style="color: ${color};">${status}</span>
                        </div>
                    `;
                }
            }
        }
        
        detailDiv.innerHTML = detailHtml;
    }
}
function getRewardForFloor(floor) {
    let reward = { name: '', amount: 0 };
    
    if (floor === 10) {
        reward = { name: '伴侣钥匙', amount: 10, itemKey: 'companionKey' };
    } else if (floor === 20) {
        reward = { name: '鱼饵', amount: 100, itemKey: 'baitCount' };
    } else if (floor === 30) {
        reward = { name: '宇宙晶体发票', amount: 1000, itemKey: 'yuzhou3' };
    } else if (floor === 40) {
        reward = { name: '神器碎片发票', amount: 200, itemKey: 'yuzhou4' };
    } else if (floor === 50) {
        reward = { name: '普通伴侣灵魂', amount: 1000, itemKey: 'banlv1' };
    } else if (floor === 60) {
        reward = { name: '蕴灵筑基丹', amount: 1000, itemKey: 'danyao1' };
    } else if (floor === 70) {
        reward = { name: '宝藏金币', amount: 10, itemKey: 'primaryGemq' };
    } else if (floor === 80) {
        reward = { name: '灵根检测器', amount: 100, itemKey: 'rootDetector' };
    } else if (floor === 90) {
        reward = { name: '血脉检测剂', amount: 100, itemKey: 'bloodlineDetector' };
    } else if (floor === 100) {
        reward = { name: '进阶神石', amount: 20, itemKey: 'advanceStone' };
    } else if (floor === 110) {
        reward = { name: '神器碎片发票', amount: 1000, itemKey: 'yuzhou4' };
    } else if (floor === 120) {
        reward = { name: '黑龙王翅膀', amount: 100, itemKey: 'chiban1' };
    } else if (floor === 130) {
        reward = { name: '远古圣兽精魄', amount: 100, itemKey: 'zuoqi1' };
    } else if (floor === 140) {
        reward = { name: '宝藏金币', amount: 20, itemKey: 'primaryGemq' };
    } else if (floor === 150) {
        reward = { name: '秘法符文', amount: 100, itemKey: 'fuwen1' };
    } else if (floor === 160) {
        reward = { name: '神兽蛋', amount: 100, itemKey: 'shenshou1' };
    } else if (floor === 170) {
        reward = { name: 'VIP能力值', amount: 50000, itemKey: 'vipPower' };
    } else if (floor === 180) {
        reward = { name: '普通伴侣灵魂', amount: 5000, itemKey: 'banlv1' };
    } else if (floor === 190) {
        reward = { name: '凝元固窍丹', amount: 10000, itemKey: 'danyao2' };
    } else if (floor === 200) {
        reward = { name: '灵根检测器', amount: 200, itemKey: 'rootDetector' };
    } else if (floor === 210) {
        reward = { name: '血脉检测剂', amount: 200, itemKey: 'bloodlineDetector' };
    } else if (floor === 220) {
        reward = { name: '进阶神石', amount: 30, itemKey: 'advanceStone' };
    } else if (floor === 230) {
        reward = { name: '宝藏金币', amount: 50, itemKey: 'primaryGemq' };
    } else if (floor === 240) {
        reward = { name: '鱼饵', amount: 1000, itemKey: 'baitCount' };
    } else if (floor === 250) {
        reward = { name: '宇宙晶体发票', amount: 10000, itemKey: 'yuzhou3' };
    } else if (floor === 260) {
        reward = { name: '神器碎片发票', amount: 2000, itemKey: 'yuzhou4' };
    } else if (floor === 270) {
        reward = { name: '普通伴侣灵魂', amount: 10000, itemKey: 'banlv1' };
    } else if (floor === 280) {
        reward = { name: '黑龙王翅膀', amount: 200, itemKey: 'chiban1' };
    } else if (floor === 290) {
        reward = { name: '远古圣兽精魄', amount: 200, itemKey: 'zuoqi1' };
    } else if (floor === 300) {
        reward = { name: '神兽蛋', amount: 200, itemKey: 'shenshou1' };
    } else if (floor === 310) {
        reward = { name: '秘法符文', amount: 200, itemKey: 'fuwen1' };
    } else if (floor === 320) {
        reward = { name: '宝藏金币', amount: 100, itemKey: 'primaryGemq' };
    } else if (floor === 330) {
        reward = { name: '灵根检测器', amount: 300, itemKey: 'rootDetector' };
    } else if (floor === 340) {
        reward = { name: '血脉检测剂', amount: 300, itemKey: 'bloodlineDetector' };
    } else if (floor === 350) {
        reward = { name: '进阶神石', amount: 50, itemKey: 'advanceStone' };
    } else if (floor === 360) {
        reward = { name: '渡厄金还丹', amount: 10000, itemKey: 'danyao3' };
    } else if (floor === 370) {
        reward = { name: '副本令牌', amount: 50, itemKey: 'fuben1' };
    } else if (floor === 380) {
        reward = { name: '黑龙王翅膀', amount: 300, itemKey: 'chiban1' };
    } else if (floor === 390) {
        reward = { name: '远古圣兽精魄', amount: 300, itemKey: 'zuoqi1' };
    } else if (floor === 400) {
        reward = { name: '神兽蛋', amount: 300, itemKey: 'shenshou1' };
    } else if (floor === 410) {
        reward = { name: '秘法符文', amount: 300, itemKey: 'fuwen1' };
    } else if (floor === 420) {
        reward = { name: '宝藏金币', amount: 100, itemKey: 'primaryGemq' };
    } else if (floor === 430) {
        reward = { name: '普通伴侣灵魂', amount: 20000, itemKey: 'banlv1' };
    } else if (floor === 440) {
        reward = { name: '宇宙晶体发票', amount: 100000, itemKey: 'yuzhou3' };
    } else if (floor === 450) {
        reward = { name: '神器碎片发票', amount: 10000, itemKey: 'yuzhou4' };
    } else if (floor === 460) {
        reward = { name: '灵根检测器', amount: 400, itemKey: 'rootDetector' };
    } else if (floor === 470) {
        reward = { name: '血脉检测剂', amount: 400, itemKey: 'bloodlineDetector' };
    } else if (floor === 480) {
        reward = { name: '宝藏金币', amount: 200, itemKey: 'primaryGemq' };
    } else if (floor === 490) {
        reward = { name: '进阶神石', amount: 100, itemKey: 'advanceStone' };
    } else if (floor === 500) {
        reward = { name: '九转轮回丹', amount: 10000, itemKey: 'danyao4' };
    } else if (floor % 10 === 0) {
        // 其他10的倍数层给递增奖励
        let multiplier = Math.floor(floor / 10);
        reward = { name: '蕴灵筑基丹', amount: 10 * multiplier, itemKey: 'danyao1' };
    }
    
    return reward;
}
function resetTrialTowerState() {
    trialTowerGame.playerHp = trialTowerGame.playerMaxHp;
    trialTowerGame.isDefending = false;
    trialTowerGame.monsterSkillCombo = 0;
    trialTowerGame.lastComboSkill = '';
    trialTowerGame.lastMonsterSkill = '';
    trialTowerGame.defenseHealCount = 0;
    trialTowerGame.defenseTotalHeal = 0;
    trialTowerGame.artifactCritCount = 0;
    trialTowerGame.artifactTotalBonus = 0;
}
// 攻击怪物
function trialTowerAttack() {
    if (!trialTowerGame.isInBattle) {
        addTrialBattleLog('❌ 战斗已结束，请重新挑战', 'error');
        return;
    }
    
    if (trialTowerGame.playerHp <= 0) {
        addTrialBattleLog('💀 你已经死亡，请重新挑战', 'error');
        return;
    }
    
    // 计算玩家基础伤害
    let damage = trialTowerGame.playerAtk;
    let isCrit = Math.random() < trialTowerGame.playerCritRate;
    let critMultiplier = 1;
    let artifactEffect = null;
    
    // 暴击判定
    if (isCrit) {
        critMultiplier = trialTowerGame.playerCrit;
        addTrialBattleLog(`⚡ 基础暴击！造成 ${(critMultiplier * 100 - 100).toFixed(0)}% 伤害`, 'crit');
    }
    
    // 触发法宝暴伤效果（5%几率）
    artifactEffect = triggerTrialArtifactCrit();
    
    if (artifactEffect.triggered) {
        // 应用法宝暴伤倍率
        let totalMultiplier = critMultiplier * artifactEffect.multiplier;
        damage = Math.floor(damage * totalMultiplier);
        
        // 霸气语录显示
        addTrialBattleLog(`🌟 ${artifactEffect.quote}`, 'skill', '#FFD700');
        addTrialBattleLog(`💫 ${artifactEffect.message} (${artifactEffect.multiplier}倍)`, 'artifact', '#FF6B6B');
        addTrialBattleLog(`⚔️ 总伤害倍率: ${critMultiplier.toFixed(1)} × ${artifactEffect.multiplier} = ${totalMultiplier.toFixed(1)}倍`, 'info', '#4CAF50');
        
        // 统计
        trialTowerGame.artifactCritCount++;
        trialTowerGame.artifactTotalBonus += artifactEffect.multiplier;
    } else {
        // 只有基础暴击
        damage = Math.floor(damage * critMultiplier);
    }
    
    // 显示最终伤害
    if (artifactEffect.triggered) {
        addTrialBattleLog(`💥 法宝神威！造成 ${formatNumber(damage)} 点伤害！`, 'crit');
    } else if (isCrit) {
        addTrialBattleLog(`⚔️ 暴击造成 ${formatNumber(damage)} 点伤害`, 'crit');
    } else {
        addTrialBattleLog(`⚔️ 造成 ${formatNumber(damage)} 点伤害`, 'normal');
    }
    
    // 减少怪物血量
    trialTowerGame.monsterHp -= damage;
    
    // 检查怪物是否死亡
    if (trialTowerGame.monsterHp <= 0) {
        handleTrialMonsterDeath();
    } else {
        // 怪物反击
        trialTowerCounterAttack();
    }
    
    updateTrialTowerUI();
}

// 防御
function trialTowerDefend() {
    if (!trialTowerGame.isInBattle) {
        addTrialBattleLog('❌ 战斗已结束，请重新挑战', 'error');
        return;
    }
    
    if (trialTowerGame.playerHp <= 0) {
        addTrialBattleLog('💀 你已经死亡，请重新挑战', 'error');
        return;
    }
    
    // 进入防御状态
    trialTowerGame.isDefending = true;
    addTrialBattleLog('🛡️ 进入防御状态，受到的伤害减半', 'defend');
    
    // 20%几率触发回复效果
    if (Math.random() < 0.2) {
        let healAmount = Math.floor(trialTowerGame.playerMaxHp * 0.15);
        let oldHp = trialTowerGame.playerHp;
        trialTowerGame.playerHp = Math.min(trialTowerGame.playerHp + healAmount, trialTowerGame.playerMaxHp);
        let actualHeal = trialTowerGame.playerHp - oldHp;
        
        // 记录统计
        trialTowerGame.defenseHealCount++;
        trialTowerGame.defenseTotalHeal += actualHeal;
        
        // 显示回复效果
        addTrialBattleLog(`✨ 防御触发回复效果！恢复15%生命值 (+${formatNumber(actualHeal)})`, 'heal');
        addTrialBattleLog(`❤️ 当前生命值: ${formatNumber(trialTowerGame.playerHp)}/${formatNumber(trialTowerGame.playerMaxHp)}`, 'heal');
        
        // 添加特效提示
        showDefenseHealEffect(actualHeal);
    }
    
    // 怪物反击（带技能，但防御减伤）
    trialTowerCounterAttack(true);
    
    updateTrialTowerUI();
}
function showDefenseHealEffect(healAmount) {
    // 创建浮动文字效果
    const effect = document.createElement('div');
    effect.style.position = 'fixed';
    effect.style.top = '50%';
    effect.style.left = '50%';
    effect.style.transform = 'translate(-50%, -50%)';
    effect.style.color = '#4CAF50';
    effect.style.fontSize = '48px';
    effect.style.fontWeight = 'bold';
    effect.style.textShadow = '0 0 20px #4CAF50';
    effect.style.zIndex = '10000';
    effect.style.animation = 'healFloat 1.5s ease-out';
    effect.style.pointerEvents = 'none';
    effect.innerHTML = `❤️ +${formatNumber(healAmount)}`;
    
    document.body.appendChild(effect);
    
    setTimeout(() => {
        if (effect.parentNode) {
            effect.parentNode.removeChild(effect);
        }
    }, 1500);
}
// 怪物反击
function trialTowerCounterAttack(isDefending = false) {
    if (trialTowerGame.monsterHp <= 0) return;
    
    // 获取当前层数的技能配置
    const skills = getMonsterSkillsForFloor(trialTowerGame.currentFloor);
    
    // 随机选择技能
    const rand = Math.random();
    let cumulativeChance = 0;
    let selectedSkill = skills[0]; // 默认普通攻击
    
    for (const skill of skills) {
        cumulativeChance += skill.chance;
        if (rand < cumulativeChance) {
            selectedSkill = skill;
            break;
        }
    }
    
    // 计算伤害（基础攻击 × 技能倍率）
    let damage = Math.floor(trialTowerGame.monsterAtk * selectedSkill.multiplier);
    
    // 连击系统 - 连续使用相同技能增加伤害
    if (trialTowerGame.lastComboSkill === selectedSkill.name) {
        trialTowerGame.monsterSkillCombo++;
        let comboBonus = 1 + (trialTowerGame.monsterSkillCombo * 0.1); // 每连击一次增加10%伤害
        damage = Math.floor(damage * comboBonus);
    } else {
        trialTowerGame.lastComboSkill = selectedSkill.name;
        trialTowerGame.monsterSkillCombo = 1;
    }
    
    // 记录本次技能
    trialTowerGame.lastMonsterSkill = selectedSkill.name;
    
    // 防御减伤
    if (isDefending || trialTowerGame.isDefending) {
        damage = Math.floor(damage / 2);
        trialTowerGame.isDefending = false;
        addTrialBattleLog(`🛡️ 防御成功！`, 'defend');
    }
    
    // 显示技能信息
    let skillMessage = selectedSkill.message;
    if (trialTowerGame.monsterSkillCombo > 1) {
        skillMessage += ` 🔥 连击x${trialTowerGame.monsterSkillCombo}！`;
    }
    addTrialBattleLog(`${selectedSkill.icon} ${skillMessage}`, 'skill', selectedSkill.color);
    addTrialBattleLog(`💢 受到 ${formatNumber(damage)} 点伤害`, 'damage');
    
    // 减少玩家血量
    trialTowerGame.playerHp -= damage;
    trialTowerGame.totalDamageTaken += damage;
    
    // 检查玩家是否死亡
    if (trialTowerGame.playerHp <= 0) {
        trialTowerGame.playerHp = 0;
        addTrialBattleLog('💀 你被击败了...', 'error');
        handleTrialPlayerDeath();
    }
}


// 处理怪物死亡
function handleTrialMonsterDeath() {
    trialTowerGame.totalWins++;
    trialTowerGame.totalChallenges++;
    
    // 更新最高层数
    if (trialTowerGame.currentFloor > trialTowerGame.highestFloor) {
        trialTowerGame.highestFloor = trialTowerGame.currentFloor;
    }
    
    // 显示击败信息
    addTrialBattleLog(`🎉 恭喜！击败第 ${trialTowerGame.currentFloor} 层怪物！`, 'success');
    
    // 根据层数显示特殊信息
    if (trialTowerGame.currentFloor % 10 === 0) {
        addTrialBattleLog(`🌟 达到第 ${trialTowerGame.currentFloor} 层！获得特殊奖励！`, 'skill', '#FFD700');
        giveTrialTowerReward(trialTowerGame.currentFloor);
    }
    
    // 进入下一层
    trialTowerGame.currentFloor++;
    
    // 重置怪物
    resetTrialMonster();
    
    // 重置技能连击
    trialTowerGame.monsterSkillCombo = 0;
    trialTowerGame.lastComboSkill = '';
    
    // 恢复部分生命值（胜利奖励）
    let healAmount = Math.floor(trialTowerGame.playerMaxHp * 0.3);
    trialTowerGame.playerHp = Math.min(trialTowerGame.playerHp + healAmount, trialTowerGame.playerMaxHp);
    addTrialBattleLog(`❤️ 进入第 ${trialTowerGame.currentFloor} 层，恢复30%生命值 (+${formatNumber(healAmount)})`, 'heal');
    
    // 显示下一层怪物信息
    const nextMonsterSkills = getMonsterSkillsForFloor(trialTowerGame.currentFloor);
    const highSkills = nextMonsterSkills.filter(s => s.multiplier >= 3.0);
    if (highSkills.length > 0) {
        addTrialBattleLog(`⚠️ 第 ${trialTowerGame.currentFloor} 层怪物拥有 ${highSkills.length} 种强力技能！`, 'warning');
    }
    
    // 保存进度
    saveTrialTowerProgress();
    
    updateTrialTowerUI();
}

// 处理玩家死亡
function handleTrialPlayerDeath() {
    trialTowerGame.isInBattle = false;
    trialTowerGame.totalChallenges++;
    
    addTrialBattleLog('💀 挑战失败！', 'error');
    addTrialBattleLog(`📊 当前停留在第 ${trialTowerGame.currentFloor} 层`, 'info');
    
    // 禁用攻击防御按钮
    document.getElementById('trialAttackBtn').disabled = true;
    document.getElementById('trialDefendBtn').disabled = true;
    
    // 保存进度
    saveTrialTowerProgress();
    
    updateTrialTowerUI();
}

// 重新挑战当前层
function trialTowerRestart() {
    // 重置玩家血量
    trialTowerGame.playerHp = trialTowerGame.playerMaxHp;
    
    // 重置当前层怪物
    resetTrialMonster();
    
    // 重置战斗状态
    trialTowerGame.isInBattle = true;
    trialTowerGame.isDefending = false;
    
    // 重置技能相关
    trialTowerGame.monsterSkillCombo = 0;
    trialTowerGame.lastComboSkill = '';
    trialTowerGame.lastMonsterSkill = '';
    trialTowerGame.defenseHealCount = 0;
    trialTowerGame.defenseTotalHeal = 0;
    trialTowerGame.artifactCritCount = 0;
    trialTowerGame.artifactTotalBonus = 0;
    // 启用攻击防御按钮
    document.getElementById('trialAttackBtn').disabled = false;
    document.getElementById('trialDefendBtn').disabled = false;
    
    // 清空日志
    clearTrialBattleLog();
    
    addTrialBattleLog('🔄 重新挑战当前层！', 'warning');
    addTrialBattleLog(`👾 第 ${trialTowerGame.currentFloor} 层怪物重生`, 'info');
     addTrialBattleLog('🛡️ 防御有20%几率回复15%生命值', 'info', '#4CAF50');
    // 显示当前层怪物技能信息
    const skills = getMonsterSkillsForFloor(trialTowerGame.currentFloor);
    const powerfulSkills = skills.filter(s => s.multiplier >= 2.0);
    addTrialBattleLog(`📊 怪物拥有 ${powerfulSkills.length} 种强力技能`, 'info', '#9C27B0');
    
    updateTrialTowerUI();
}

// 给予试练塔奖励
function giveTrialTowerReward(floor) {
    let reward = getRewardForFloor(floor);
    
    if (reward.amount > 0) {
        // 添加奖励到玩家背包
        if (!player.items) player.items = {};
        player.items[reward.itemKey] = (player.items[reward.itemKey] || 0) + reward.amount;
        
        addTrialBattleLog(`🎁 第${floor}层奖励: ${reward.name}×${reward.amount}`, 'success');
    } else {
        // 其他层数给少量随机奖励
        let randomReward = Math.floor(floor / 5);
        if (randomReward > 0) {
            player.items['danyao1'] = (player.items['danyao1'] || 0) + randomReward;
            addTrialBattleLog(`🎁 第${floor}层奖励: 蕴灵筑基丹×${randomReward}`, 'success');
        }
    }
}

// 保存试练塔进度
function saveTrialTowerProgress() {
    if (!player.trialTower) {
        player.trialTower = {};
    }
    
    player.trialTower.currentFloor = trialTowerGame.currentFloor;
    player.trialTower.highestFloor = trialTowerGame.highestFloor;
    player.trialTower.totalChallenges = trialTowerGame.totalChallenges;
    player.trialTower.totalWins = trialTowerGame.totalWins;
}

// 添加试练塔战斗日志
function addTrialBattleLog(message, type = 'normal', color = null) {
    let logDiv = document.getElementById('trialBattleLog');
    let newLog = document.createElement('div');
    
    let textColor = '#aaa';
    let prefix = '•';
    
    switch(type) {
        case 'success': textColor = '#4CAF50'; prefix = '✅'; break;
        case 'error': textColor = '#f44336'; prefix = '❌'; break;
        case 'warning': textColor = '#FFD700'; prefix = '⚠️'; break;
        case 'crit': textColor = '#FFD700'; prefix = '⚡'; break;
        case 'damage': textColor = '#FF6B6B'; prefix = '💢'; break;
        case 'defend': textColor = '#4CAF50'; prefix = '🛡️'; break;
        case 'heal': textColor = '#4CAF50'; prefix = '❤️'; break;
        case 'skill': textColor = color || '#9C27B0'; prefix = '🎯'; break;
        case 'info': textColor = '#9C27B0'; prefix = '📌'; break;
    }
    
    let timestamp = new Date().toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    
    newLog.style.marginBottom = '4px';
    newLog.style.padding = '4px 0';
    newLog.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
    newLog.style.fontSize = '12px';
    newLog.style.display = 'flex';
    newLog.style.alignItems = 'center';
    newLog.style.gap = '5px';
    newLog.style.animation = 'fadeIn 0.3s';
    
    newLog.innerHTML = `
        <span style="color: #666; font-size: 10px;">[${timestamp}]</span>
        <span style="color: ${textColor}; font-weight: ${type === 'skill' ? 'bold' : 'normal'};">${prefix}</span>
        <span style="color: ${textColor};">${message}</span>
    `;
    
    logDiv.insertBefore(newLog, logDiv.firstChild);
    
    while (logDiv.children.length > 50) {
        logDiv.removeChild(logDiv.lastChild);
    }
}

// 清空试练塔战斗日志
function clearTrialBattleLog() {
    document.getElementById('trialBattleLog').innerHTML = '';
}

// ==================== 无限深渊系统 ====================
var abyssRun = null;
var abyssSelectedClass = 'warrior';

var ABYSS_CLASSES = [
    { id: 'warrior', name: '战士', desc: '攻击+18，生命+320，防御+18；力量、体力转化收益+20%', bonus: { atk: 18, hp: 320, def: 18 }, strConversionMult: 1.2, staConversionMult: 1.2 },
    { id: 'mage', name: '法师', desc: '攻击+16，生命+280，防御+12，技能伤害+24%；智力转化技能伤害+35%', bonus: { atk: 16, hp: 280, def: 12, skillDmg: 24 }, intToSkillDmgMult: 1.35 },
    { id: 'archer', name: '射手', desc: '攻击+20，生命+260，防御+12，暴击率+10%，闪避+8%；敏捷转化暴击/闪避+30%', bonus: { atk: 20, hp: 260, def: 12, critRate: 10, dodge: 8 }, agiMult: 1.3 }
];
// 每职业1转通用称号，2~4转按分支（共4个分支）
var ABYSS_ZHUAN_TITLES = {
    warrior: { 1: '战士', branchA: { 2: '破军·战将', 3: '破军·战神', 4: '破军·武帝' }, branchB: { 2: '铁壁·战将', 3: '铁壁·战神', 4: '铁壁·武帝' }, branchC: { 2: '狂战·战将', 3: '狂战·战神', 4: '狂战·武帝' }, branchD: { 2: '控场·战将', 3: '控场·战神', 4: '控场·武帝' } },
    mage: { 1: '法师', branchA: { 2: '元素·魔导师', 3: '元素·大魔导', 4: '元素·法圣' }, branchB: { 2: '虚空·魔导师', 3: '虚空·大魔导', 4: '虚空·法圣' }, branchC: { 2: '圣愈·魔导师', 3: '圣愈·大魔导', 4: '圣愈·法圣' }, branchD: { 2: '诅咒·魔导师', 3: '诅咒·大魔导', 4: '诅咒·法圣' } },
    archer: { 1: '射手', branchA: { 2: '狩魂·神射', 3: '狩魂·箭神', 4: '狩魂·狩天' }, branchB: { 2: '神射·神射', 3: '神射·箭神', 4: '神射·狩天' }, branchC: { 2: '陷阱·神射', 3: '陷阱·箭神', 4: '陷阱·狩天' }, branchD: { 2: '疾风·神射', 3: '疾风·箭神', 4: '疾风·狩天' } }
};
// 二转分支名称与描述（用于选择弹窗，共4个分支）
var ABYSS_BRANCH_INFO = {
    warrior: { branchA: { name: '破军', desc: '偏爆发与破甲，单体高伤、破防与吸血' }, branchB: { name: '铁壁', desc: '偏生存与反伤，减伤、反伤与群体控场' }, branchC: { name: '狂战', desc: '偏嗜血与连击，高攻、吸血与多段打击' }, branchD: { name: '控场', desc: '偏眩晕与群体，控场、AOE与减速' } },
    mage: { branchA: { name: '元素', desc: '偏元素与AOE，群体伤害、控制与护盾' }, branchB: { name: '虚空', desc: '偏虚空与穿透，无视魔抗、单体爆发' }, branchC: { name: '圣愈', desc: '偏治疗与护盾，回复、增益与生存' }, branchD: { name: '诅咒', desc: '偏减益与持续伤害，虚弱、侵蚀与削弱' } },
    archer: { branchA: { name: '狩魂', desc: '偏召唤与多目标，召唤兽、箭雨与持续输出' }, branchB: { name: '神射', desc: '偏暴击与单体，必暴、穿甲与斩杀' }, branchC: { name: '陷阱', desc: '偏陷阱与控场，定身、眩晕与持续伤' }, branchD: { name: '疾风', desc: '偏连击与闪避，多段、疾射与身法' } }
};
function abyssZhuanTitle(classId, zhuan, branch) {
    var t = ABYSS_ZHUAN_TITLES[classId || 'warrior'];
    if (!t) return zhuan + '转';
    if (zhuan === 1) return (t[1] || '') + '·1转';
    var b = (branch && t[branch]) ? t[branch] : null;
    return (b && b[zhuan]) ? b[zhuan] + '·' + zhuan + '转' : (zhuan + '转');
}

var ABYSS_TALENTS = [
    { id: 'tal_hp', name: '生命强化', maxLevel: 8, effect: { hp: 130 }, parent: null },
    { id: 'tal_atk', name: '攻击强化', maxLevel: 8, effect: { atk: 24 }, parent: null },
    { id: 'tal_def', name: '护甲强化', maxLevel: 8, effect: { def: 16 }, parent: null },
    { id: 'tal_crit', name: '致命一击', maxLevel: 5, effect: { critRate: 3, critDmg: 12 }, parent: 'tal_atk' },
    { id: 'tal_skill', name: '法术精通', maxLevel: 6, effect: { skillDmg: 8 }, parent: null },
    { id: 'tal_dodge', name: '身轻如燕', maxLevel: 6, effect: { dodge: 5 }, parent: null },
    { id: 'tal_life', name: '吸血', maxLevel: 5, effect: { lifesteal: 2.5 }, parent: 'tal_hp' },
    { id: 'tal_combo', name: '连击', maxLevel: 5, effect: { combo: 3.5 }, parent: 'tal_dodge' },
    { id: 'tal_armor', name: '破甲', maxLevel: 5, effect: { reduceMonsterDef: 5 }, parent: 'tal_atk' },
    { id: 'tal_str', name: '力量专精', maxLevel: 4, effect: { atk: 14 }, parent: 'tal_atk' },
    { id: 'tal_int', name: '智力专精', maxLevel: 4, effect: { skillDmg: 6 }, parent: 'tal_skill' },
    { id: 'tal_agi', name: '敏捷专精', maxLevel: 4, effect: { critRate: 2.5, dodge: 2 }, parent: 'tal_dodge' },
    { id: 'tal_sta', name: '体力专精', maxLevel: 4, effect: { hp: 70, def: 5 }, parent: 'tal_hp' }
];

function abyssZhuan(level) {
    if (level >= 100) return 4;
    if (level >= 50) return 3;
    if (level >= 20) return 2;
    return 1;
}
function abyssMaxMpForLevel(runLevel) {
    var z = abyssZhuan(runLevel || 0);
    return 60 + (runLevel || 0) * 2.5 + z * 30;
}
function abyssMpRegenForLevel(runLevel) {
    var z = abyssZhuan(runLevel || 0);
    return 6 + z * 4;
}

// 射手召唤物场上总上限（任意召唤技能共用）
var ABYSS_ARCHER_SUMMON_CAP = 4;
// 技能：1转通用；2转选择分支后解锁 branchA/B/C/D 的 2/3/4 转技能
function abyssGetSkillList(classId, branch) {
    var c = ABYSS_CLASS_SKILLS[classId];
    if (!c) return [];
    if (Array.isArray(c)) return c;
    var list = (c.base || []).slice();
    if (branch && c[branch]) { for (var i = 0; i < c[branch].length; i++) list.push(c[branch][i]); }
    return list;
}
var ABYSS_CLASS_SKILLS = {
    warrior: {
        base: [
            { id: 'war_heavy', name: '重击', desc: '本次伤害170%', cooldown: 2, dmgMult: 1.7, mpCost: 14, zhuan: 1 },
            { id: 'war_armorBreak', name: '破甲一击', desc: '本次无视怪物50%防御', cooldown: 3, ignoreDefPct: 50, mpCost: 18, zhuan: 1 },
            { id: 'war_roar', name: '战吼', desc: '本次伤害130%，2回合攻击+25%', cooldown: 4, dmgMult: 1.3, buffAtkPct: 25, buffRounds: 2, mpCost: 22, zhuan: 1 },
            { id: 'war_slam', name: '猛击', desc: '本次伤害200%', cooldown: 5, dmgMult: 2, mpCost: 26, zhuan: 1 },
            { id: 'war_iron', name: '铁壁', desc: '本回合受到伤害减少40%', cooldown: 4, reduceDmgPct: 40, mpCost: 20, zhuan: 1 },
            { id: 'war_blood', name: '嗜血斩', desc: '本次伤害150%，回复30%伤害生命', cooldown: 3, dmgMult: 1.5, lifestealPct: 0.3, mpCost: 16, zhuan: 1 },
            { id: 'war_cleave', name: '裂地斩', desc: '群体70%伤害', cooldown: 4, aoe: true, aoePct: 0.7, mpCost: 24, zhuan: 1 }
        ],
        // 破军：爆发/破甲/单体高伤
        branchA: [
            { id: 'war_quake', name: '震地波', desc: '2转·群体85%伤害', cooldown: 5, aoe: true, aoePct: 0.85, mpCost: 30, zhuan: 2 },
            { id: 'war_berserk', name: '狂暴', desc: '2转·本次伤害240%', cooldown: 6, dmgMult: 2.4, mpCost: 34, zhuan: 2 },
            { id: 'war_battlewill', name: '战意燃烧', desc: '2转·本回合攻击+40%', cooldown: 4, buffAtkPct: 40, buffRounds: 1, mpCost: 24, zhuan: 2 },
            { id: 'war_sunderarmor', name: '裂甲', desc: '2转·本次伤害165%，无视25%防御', cooldown: 4, dmgMult: 1.65, ignoreDefPct: 25, mpCost: 28, zhuan: 2 },
            { id: 'war_bloodthirst', name: '破军·嗜血', desc: '2转·伤害190%，回复40%伤害生命', cooldown: 3, dmgMult: 1.9, lifestealPct: 0.4, mpCost: 26, zhuan: 2 },
            { id: 'war_crush', name: '破军·碎骨', desc: '2转·本次伤害210%，无视20%防御', cooldown: 4, dmgMult: 2.1, ignoreDefPct: 20, mpCost: 28, zhuan: 2 },
            { id: 'war_onslaught', name: '破军·冲锋', desc: '2转·本次伤害200%，下回合攻击+30%', cooldown: 5, dmgMult: 2, buffAtkPct: 30, buffRounds: 1, mpCost: 30, zhuan: 2 },
            { id: 'war_skyfall', name: '天崩斩', desc: '3转·本次伤害280%', cooldown: 6, dmgMult: 2.8, mpCost: 38, zhuan: 3 },
            { id: 'war_sunder', name: '破灭斩', desc: '3转·无视70%防御，伤害200%', cooldown: 5, ignoreDefPct: 70, dmgMult: 2, mpCost: 36, zhuan: 3 },
            { id: 'war_bloodlust', name: '血怒', desc: '3转·伤害180%，回复50%伤害生命', cooldown: 4, dmgMult: 1.8, lifestealPct: 0.5, mpCost: 30, zhuan: 3 },
            { id: 'war_warlord', name: '战神附体', desc: '3转·3回合攻击+35%、减伤15%', cooldown: 8, buffAtkPct: 35, buffRounds: 3, reduceDmgPct: 15, mpCost: 42, zhuan: 3 },
            { id: 'war_warspirit', name: '战魂', desc: '3转·4回合暴击率+10%、爆伤+20%', cooldown: 7, buffCritRate: 10, buffCritDmg: 20, buffRounds: 4, mpCost: 40, zhuan: 3 },
            { id: 'war_break', name: '破军', desc: '3转·本次伤害220%，目标生命>70%时额外+25%', cooldown: 5, dmgMult: 2.2, mpCost: 36, zhuan: 3 },
            { id: 'war_bloodbath', name: '浴血', desc: '3转·本次伤害200%，自身生命低于50%时伤害+40%', cooldown: 5, dmgMult: 2, mpCost: 38, zhuan: 3 },
            { id: 'war_apocalypse', name: '末日审判', desc: '4转·群体120%伤害', cooldown: 7, aoe: true, aoePct: 1.2, mpCost: 48, zhuan: 4 },
            { id: 'war_titan', name: '泰坦之握', desc: '4转·本次伤害350%', cooldown: 8, dmgMult: 3.5, mpCost: 52, zhuan: 4 },
            { id: 'war_immortal', name: '不灭战意', desc: '4转·5回合攻击+20%、减伤25%', cooldown: 10, buffAtkPct: 20, buffRounds: 5, reduceDmgPct: 25, mpCost: 50, zhuan: 4 },
            { id: 'war_heaven', name: '天罚', desc: '4转·群体100%伤害', cooldown: 7, aoe: true, aoePct: 1, dmgMult: 1, mpCost: 46, zhuan: 4 },
            { id: 'war_fortress', name: '霸体', desc: '4转·本回合免疫眩晕且减伤20%', cooldown: 6, reduceDmgPct: 20, immuneStun: true, mpCost: 44, zhuan: 4 },
            { id: 'war_doomsday', name: '灭世斩', desc: '4转·本次伤害400%', cooldown: 10, dmgMult: 4, mpCost: 58, zhuan: 4 }
        ],
        // 铁壁：生存/反伤/群体减伤
        branchB: [
            { id: 'war_guard', name: '不屈', desc: '2转·本回合减伤60%', cooldown: 5, reduceDmgPct: 60, mpCost: 26, zhuan: 2 },
            { id: 'war_revenge', name: '反击架势', desc: '2转·本回合受击反弹30%伤害', cooldown: 5, counterPct: 30, mpCost: 28, zhuan: 2 },
            { id: 'war_stomp', name: '践踏', desc: '2转·群体60%伤害，35%眩晕1回合', cooldown: 5, aoe: true, aoePct: 0.6, stunChance: 0.35, stunTurns: 1, mpCost: 30, zhuan: 2 },
            { id: 'war_ironwall', name: '铁壁·铜墙', desc: '2转·本回合减伤50%，反伤15%', cooldown: 5, reduceDmgPct: 50, counterPct: 15, mpCost: 28, zhuan: 2 },
            { id: 'war_taunt', name: '铁壁·嘲讽', desc: '2转·本回合减伤35%，受击反伤25%', cooldown: 4, reduceDmgPct: 35, counterPct: 25, mpCost: 24, zhuan: 2 },
            { id: 'war_groundslam', name: '铁壁·地动', desc: '2转·群体55%伤害，40%眩晕1回合', cooldown: 5, aoe: true, aoePct: 0.55, stunChance: 0.4, stunTurns: 1, mpCost: 32, zhuan: 2 },
            { id: 'war_endure', name: '铁壁·坚韧', desc: '2转·2回合减伤30%', cooldown: 6, reduceDmgPct: 30, buffRounds: 2, mpCost: 26, zhuan: 2 },
            { id: 'war_bulwark', name: '铁壁·壁垒', desc: '3转·本回合减伤70%，反伤20%', cooldown: 6, reduceDmgPct: 70, counterPct: 20, mpCost: 36, zhuan: 3 },
            { id: 'war_thorns', name: '荆棘反甲', desc: '3转·3回合受击反弹35%伤害', cooldown: 8, counterPct: 35, buffRounds: 3, mpCost: 40, zhuan: 3 },
            { id: 'war_quake2', name: '铁壁·震波', desc: '3转·群体75%伤害，50%眩晕1回合', cooldown: 6, aoe: true, aoePct: 0.75, stunChance: 0.5, stunTurns: 1, mpCost: 38, zhuan: 3 },
            { id: 'war_steadfast', name: '岿然不动', desc: '3转·本回合免疫眩晕，减伤45%', cooldown: 5, reduceDmgPct: 45, immuneStun: true, mpCost: 34, zhuan: 3 },
            { id: 'war_legion', name: '铁壁·军阵', desc: '3转·2回合减伤40%、攻击+20%', cooldown: 7, reduceDmgPct: 40, buffAtkPct: 20, buffRounds: 2, mpCost: 42, zhuan: 3 },
            { id: 'war_rampart', name: '铁壁·城垣', desc: '3转·获得生命上限25%护盾', cooldown: 5, shieldPct: 0.25, mpCost: 32, zhuan: 3 },
            { id: 'war_laststand', name: '背水一战', desc: '3转·生命低于40%时本回合减伤50%、反伤30%', cooldown: 6, reduceDmgPct: 50, counterPct: 30, mpCost: 40, zhuan: 3 },
            { id: 'war_immortalwall', name: '不破壁垒', desc: '4转·本回合减伤80%，反伤40%', cooldown: 8, reduceDmgPct: 80, counterPct: 40, mpCost: 50, zhuan: 4 },
            { id: 'war_judgment', name: '铁壁·天谴', desc: '4转·群体90%伤害，眩晕目标受伤+30%', cooldown: 7, aoe: true, aoePct: 0.9, mpCost: 48, zhuan: 4 },
            { id: 'war_eternalguard', name: '永恒守护', desc: '4转·4回合减伤35%、反伤25%', cooldown: 10, reduceDmgPct: 35, counterPct: 25, buffRounds: 4, mpCost: 54, zhuan: 4 },
            { id: 'war_colossus', name: '泰坦壁垒', desc: '4转·获得40%生命护盾，本回合减伤30%', cooldown: 8, shieldPct: 0.4, reduceDmgPct: 30, mpCost: 52, zhuan: 4 },
            { id: 'war_worldshield', name: '世界之壁', desc: '4转·本回合免疫眩晕且减伤60%', cooldown: 9, reduceDmgPct: 60, immuneStun: true, mpCost: 56, zhuan: 4 },
            { id: 'war_apocalypse_b', name: '铁壁·末日', desc: '4转·群体100%伤害，50%眩晕1回合', cooldown: 8, aoe: true, aoePct: 1, stunChance: 0.5, stunTurns: 1, mpCost: 58, zhuan: 4 }
        ],
        branchC: [
            { id: 'war_frenzy_c1', name: '狂战·狂怒', desc: '2转·本次伤害220%，回复35%伤害生命', cooldown: 3, dmgMult: 2.2, lifestealPct: 0.35, mpCost: 26, zhuan: 2 },
            { id: 'war_frenzy_c2', name: '狂战·连斩', desc: '2转·2次100%伤害', cooldown: 4, multiHit: 2, multiHitPct: 1, mpCost: 28, zhuan: 2 },
            { id: 'war_frenzy_c3', name: '狂战·嗜血', desc: '2转·伤害190%，回复45%伤害生命', cooldown: 3, dmgMult: 1.9, lifestealPct: 0.45, mpCost: 24, zhuan: 2 },
            { id: 'war_frenzy_c4', name: '狂战·暴走', desc: '2转·本回合攻击+50%', cooldown: 5, buffAtkPct: 50, buffRounds: 1, mpCost: 30, zhuan: 2 },
            { id: 'war_frenzy_c5', name: '狂战·血刃', desc: '2转·伤害200%，吸血40%', cooldown: 4, dmgMult: 2, lifestealPct: 0.4, mpCost: 32, zhuan: 2 },
            { id: 'war_frenzy_c6', name: '狂战·三连', desc: '2转·3次75%伤害', cooldown: 4, multiHit: 3, multiHitPct: 0.75, mpCost: 30, zhuan: 2 },
            { id: 'war_frenzy_c7', name: '狂战·渴血', desc: '2转·伤害180%，回复50%伤害生命', cooldown: 3, dmgMult: 1.8, lifestealPct: 0.5, mpCost: 28, zhuan: 2 },
            { id: 'war_frenzy_c8', name: '狂战·血性', desc: '3转·4回合攻击+25%、吸血+15%', cooldown: 8, buffAtkPct: 25, buffRounds: 4, mpCost: 42, zhuan: 3 },
            { id: 'war_frenzy_c9', name: '狂战·裂魂', desc: '3转·伤害260%，回复50%伤害生命', cooldown: 5, dmgMult: 2.6, lifestealPct: 0.5, mpCost: 40, zhuan: 3 },
            { id: 'war_frenzy_c10', name: '狂战·四连', desc: '3转·4次80%伤害', cooldown: 5, multiHit: 4, multiHitPct: 0.8, mpCost: 38, zhuan: 3 },
            { id: 'war_frenzy_c11', name: '狂战·血祭', desc: '3转·伤害240%，吸血55%', cooldown: 5, dmgMult: 2.4, lifestealPct: 0.55, mpCost: 44, zhuan: 3 },
            { id: 'war_frenzy_c12', name: '狂战·战狂', desc: '3转·本回合攻击+60%、连击+20%', cooldown: 6, buffAtkPct: 60, buffRounds: 1, mpCost: 42, zhuan: 3 },
            { id: 'war_frenzy_c13', name: '狂战·饮血', desc: '3转·伤害220%，回复60%伤害生命', cooldown: 4, dmgMult: 2.2, lifestealPct: 0.6, mpCost: 40, zhuan: 3 },
            { id: 'war_frenzy_c14', name: '狂战·五连', desc: '3转·5次70%伤害', cooldown: 6, multiHit: 5, multiHitPct: 0.7, mpCost: 46, zhuan: 3 },
            { id: 'war_frenzy_c15', name: '狂战·血神', desc: '4转·伤害380%，回复70%伤害生命', cooldown: 9, dmgMult: 3.8, lifestealPct: 0.7, mpCost: 56, zhuan: 4 },
            { id: 'war_frenzy_c16', name: '狂战·灭魂', desc: '4转·6次65%伤害', cooldown: 8, multiHit: 6, multiHitPct: 0.65, mpCost: 54, zhuan: 4 },
            { id: 'war_frenzy_c17', name: '狂战·天嗜', desc: '4转·5回合攻击+30%、吸血+20%', cooldown: 10, buffAtkPct: 30, buffRounds: 5, mpCost: 58, zhuan: 4 },
            { id: 'war_frenzy_c18', name: '狂战·血海', desc: '4转·伤害350%，回复65%伤害生命', cooldown: 8, dmgMult: 3.5, lifestealPct: 0.65, mpCost: 52, zhuan: 4 },
            { id: 'war_frenzy_c19', name: '狂战·弑神', desc: '4转·本次伤害420%', cooldown: 10, dmgMult: 4.2, mpCost: 60, zhuan: 4 },
            { id: 'war_frenzy_c20', name: '狂战·无尽', desc: '4转·群体90%伤害，回复30%伤害生命', cooldown: 8, aoe: true, aoePct: 0.9, lifestealPct: 0.3, mpCost: 55, zhuan: 4 }
        ],
        branchD: [
            { id: 'war_cc_d1', name: '控场·震击', desc: '2转·群体65%伤害，40%眩晕1回合', cooldown: 4, aoe: true, aoePct: 0.65, stunChance: 0.4, stunTurns: 1, mpCost: 28, zhuan: 2 },
            { id: 'war_cc_d2', name: '控场·践踏', desc: '2转·群体60%伤害，35%眩晕1回合', cooldown: 5, aoe: true, aoePct: 0.6, stunChance: 0.35, stunTurns: 1, mpCost: 30, zhuan: 2 },
            { id: 'war_cc_d3', name: '控场·怒吼', desc: '2转·群体55%伤害，50%眩晕1回合', cooldown: 5, aoe: true, aoePct: 0.55, stunChance: 0.5, stunTurns: 1, mpCost: 32, zhuan: 2 },
            { id: 'war_cc_d4', name: '控场·震慑', desc: '2转·本次伤害160%，60%眩晕1回合', cooldown: 4, dmgMult: 1.6, stunChance: 0.6, stunTurns: 1, mpCost: 26, zhuan: 2 },
            { id: 'war_cc_d5', name: '控场·地裂', desc: '2转·群体70%伤害，30%眩晕2回合', cooldown: 5, aoe: true, aoePct: 0.7, stunChance: 0.3, stunTurns: 2, mpCost: 34, zhuan: 2 },
            { id: 'war_cc_d6', name: '控场·压制', desc: '2转·伤害180%，45%眩晕1回合', cooldown: 4, dmgMult: 1.8, stunChance: 0.45, stunTurns: 1, mpCost: 28, zhuan: 2 },
            { id: 'war_cc_d7', name: '控场·锁足', desc: '2转·群体50%伤害，55%眩晕1回合', cooldown: 5, aoe: true, aoePct: 0.5, stunChance: 0.55, stunTurns: 1, mpCost: 30, zhuan: 2 },
            { id: 'war_cc_d8', name: '控场·天崩', desc: '3转·群体85%伤害，50%眩晕1回合', cooldown: 6, aoe: true, aoePct: 0.85, stunChance: 0.5, stunTurns: 1, mpCost: 40, zhuan: 3 },
            { id: 'war_cc_d9', name: '控场·山崩', desc: '3转·群体80%伤害，60%眩晕1回合', cooldown: 6, aoe: true, aoePct: 0.8, stunChance: 0.6, stunTurns: 1, mpCost: 42, zhuan: 3 },
            { id: 'war_cc_d10', name: '控场·定身', desc: '3转·伤害220%，70%眩晕2回合', cooldown: 5, dmgMult: 2.2, stunChance: 0.7, stunTurns: 2, mpCost: 38, zhuan: 3 },
            { id: 'war_cc_d11', name: '控场·震晕', desc: '3转·群体75%伤害，65%眩晕1回合', cooldown: 6, aoe: true, aoePct: 0.75, stunChance: 0.65, stunTurns: 1, mpCost: 44, zhuan: 3 },
            { id: 'war_cc_d12', name: '控场·镇压', desc: '3转·伤害200%，55%眩晕2回合', cooldown: 5, dmgMult: 2, stunChance: 0.55, stunTurns: 2, mpCost: 40, zhuan: 3 },
            { id: 'war_cc_d13', name: '控场·崩裂', desc: '3转·群体90%伤害，40%眩晕2回合', cooldown: 7, aoe: true, aoePct: 0.9, stunChance: 0.4, stunTurns: 2, mpCost: 46, zhuan: 3 },
            { id: 'war_cc_d14', name: '控场·囚笼', desc: '3转·本次伤害250%，80%眩晕1回合', cooldown: 6, dmgMult: 2.5, stunChance: 0.8, stunTurns: 1, mpCost: 42, zhuan: 3 },
            { id: 'war_cc_d15', name: '控场·末日波', desc: '4转·群体110%伤害，60%眩晕1回合', cooldown: 8, aoe: true, aoePct: 1.1, stunChance: 0.6, stunTurns: 1, mpCost: 52, zhuan: 4 },
            { id: 'war_cc_d16', name: '控场·天罚波', desc: '4转·群体100%伤害，70%眩晕2回合', cooldown: 8, aoe: true, aoePct: 1, stunChance: 0.7, stunTurns: 2, mpCost: 54, zhuan: 4 },
            { id: 'war_cc_d17', name: '控场·永锢', desc: '4转·伤害300%，90%眩晕2回合', cooldown: 9, dmgMult: 3, stunChance: 0.9, stunTurns: 2, mpCost: 56, zhuan: 4 },
            { id: 'war_cc_d18', name: '控场·灭世波', desc: '4转·群体120%伤害，50%眩晕2回合', cooldown: 9, aoe: true, aoePct: 1.2, stunChance: 0.5, stunTurns: 2, mpCost: 58, zhuan: 4 },
            { id: 'war_cc_d19', name: '控场·神罚', desc: '4转·群体95%伤害，75%眩晕2回合', cooldown: 8, aoe: true, aoePct: 0.95, stunChance: 0.75, stunTurns: 2, mpCost: 55, zhuan: 4 },
            { id: 'war_cc_d20', name: '控场·终焉', desc: '4转·群体130%伤害，65%眩晕1回合', cooldown: 10, aoe: true, aoePct: 1.3, stunChance: 0.65, stunTurns: 1, mpCost: 60, zhuan: 4 }
        ]
    },
    mage: {
        base: [
            { id: 'mage_fireball', name: '火球术', desc: '本次伤害215%（受技能伤害加成）', cooldown: 3, dmgMult: 2.15, useSkillDmg: true, mpCost: 16, zhuan: 1 },
            { id: 'mage_ice', name: '冰锥', desc: '本次伤害140%，50%眩晕1回合', cooldown: 3, dmgMult: 1.4, stunChance: 0.5, stunTurns: 1, mpCost: 14, zhuan: 1 },
            { id: 'mage_arcane', name: '奥术涌动', desc: '本次伤害170%，技能伤害+40%', cooldown: 4, dmgMult: 1.7, skillDmgBonus: 40, mpCost: 24, zhuan: 1 },
            { id: 'mage_meteor', name: '陨石', desc: '本次伤害250%', cooldown: 5, dmgMult: 2.5, mpCost: 30, zhuan: 1 },
            { id: 'mage_shield', name: '法力护盾', desc: '获得生命上限20%护盾', cooldown: 4, shieldPct: 0.2, mpCost: 22, zhuan: 1 },
            { id: 'mage_drain', name: '生命汲取', desc: '本次伤害120%，回复50%伤害生命', cooldown: 3, dmgMult: 1.2, lifestealPct: 0.5, mpCost: 20, zhuan: 1 },
            { id: 'mage_blizzard', name: '暴风雪', desc: '群体65%伤害', cooldown: 5, aoe: true, aoePct: 0.65, mpCost: 28, zhuan: 1 }
        ],
        branchA: [
            { id: 'mage_chain', name: '闪电链', desc: '2转·群体90%伤害', cooldown: 4, aoe: true, aoePct: 0.9, mpCost: 28, zhuan: 2 },
            { id: 'mage_tide', name: '法力潮汐', desc: '2转·回复30%最大魔法，2回合技能伤害+25%', cooldown: 6, mpRegenPct: 0.3, skillDmgBonus: 25, mpCost: 8, zhuan: 2 },
            { id: 'mage_frost', name: '极寒新星', desc: '2转·伤害200%，80%眩晕1回合', cooldown: 5, dmgMult: 2, stunChance: 0.8, stunTurns: 1, mpCost: 32, zhuan: 2 },
            { id: 'mage_flamewave', name: '元素·烈焰波', desc: '2转·群体75%伤害', cooldown: 4, aoe: true, aoePct: 0.75, mpCost: 26, zhuan: 2 },
            { id: 'mage_icebind', name: '元素·冰缚', desc: '2转·伤害180%，70%眩晕1回合', cooldown: 4, dmgMult: 1.8, stunChance: 0.7, stunTurns: 1, mpCost: 28, zhuan: 2 },
            { id: 'mage_arcaneburst', name: '元素·奥术爆发', desc: '2转·伤害190%，技能伤害+30%', cooldown: 5, dmgMult: 1.9, skillDmgBonus: 30, mpCost: 30, zhuan: 2 },
            { id: 'mage_manashield', name: '元素·法力护壁', desc: '2转·获得25%生命护盾', cooldown: 5, shieldPct: 0.25, mpCost: 24, zhuan: 2 },
            { id: 'mage_golem', name: '奥术傀儡', desc: '3转·召唤傀儡(15%属性)协助作战，最多1个', cooldown: 10, summonBeast: true, summonPct: 0.15, summonMax: 1, summonName: '奥术傀儡', mpCost: 42, zhuan: 3 },
            { id: 'mage_inferno', name: '炼狱火', desc: '3转·群体80%伤害', cooldown: 6, aoe: true, aoePct: 0.8, dmgMult: 1.2, mpCost: 40, zhuan: 3 },
            { id: 'mage_mana', name: '奥术洪流', desc: '3转·伤害300%，技能伤害+50%', cooldown: 5, dmgMult: 3, skillDmgBonus: 50, mpCost: 38, zhuan: 3 },
            { id: 'mage_barrier', name: '元素护盾', desc: '3转·获得30%生命护盾', cooldown: 5, shieldPct: 0.3, mpCost: 32, zhuan: 3 },
            { id: 'mage_beam', name: '奥术光束', desc: '3转·本次伤害270%，无视20%魔抗', cooldown: 5, dmgMult: 2.7, ignoreDefPct: 20, mpCost: 40, zhuan: 3 },
            { id: 'mage_curse', name: '虚弱诅咒', desc: '3转·本次伤害150%，目标下回合受到伤害+20%', cooldown: 6, dmgMult: 1.5, mpCost: 34, zhuan: 3 },
            { id: 'mage_icewall', name: '冰墙', desc: '3转·获得25%生命护盾，50%眩晕攻击者1回合', cooldown: 6, shieldPct: 0.25, mpCost: 36, zhuan: 3 },
            { id: 'mage_nexus', name: '虚空裂隙', desc: '4转·群体130%伤害，50%眩晕1回合', cooldown: 8, aoe: true, aoePct: 1.3, stunChance: 0.5, stunTurns: 1, mpCost: 56, zhuan: 4 },
            { id: 'mage_blackhole', name: '黑洞', desc: '4转·群体110%伤害', cooldown: 8, aoe: true, aoePct: 1.1, dmgMult: 1.2, mpCost: 52, zhuan: 4 },
            { id: 'mage_world', name: '世界终结', desc: '4转·本次伤害400%', cooldown: 9, dmgMult: 4, mpCost: 58, zhuan: 4 },
            { id: 'mage_starfall', name: '星陨', desc: '4转·群体95%伤害，每命中一目标回复5%最大魔法', cooldown: 7, aoe: true, aoePct: 0.95, mpRegenPct: 0.05, mpCost: 50, zhuan: 4 },
            { id: 'mage_voidburst', name: '虚空爆裂', desc: '4转·本次伤害350%，无视40%魔抗', cooldown: 8, dmgMult: 3.5, ignoreDefPct: 40, mpCost: 54, zhuan: 4 },
            { id: 'mage_timestop', name: '时停', desc: '4转·群体80%伤害，70%眩晕2回合', cooldown: 9, aoe: true, aoePct: 0.8, stunChance: 0.7, stunTurns: 2, mpCost: 56, zhuan: 4 }
        ],
        branchB: [
            { id: 'mage_void', name: '虚空箭', desc: '2转·无视30%魔抗，伤害260%', cooldown: 4, dmgMult: 2.6, ignoreDefPct: 30, mpCost: 30, zhuan: 2 },
            { id: 'mage_missile', name: '奥术飞弹', desc: '2转·3次50%伤害', cooldown: 4, multiHit: 3, multiHitPct: 0.5, mpCost: 26, zhuan: 2 },
            { id: 'mage_flux', name: '奥术脉动', desc: '2转·本次伤害160%，下回合魔法回复+15点', cooldown: 5, dmgMult: 1.6, mpRegenFlat: 15, mpCost: 24, zhuan: 2 },
            { id: 'mage_voidtouch', name: '虚空·触须', desc: '2转·无视25%魔抗，伤害240%', cooldown: 4, dmgMult: 2.4, ignoreDefPct: 25, mpCost: 28, zhuan: 2 },
            { id: 'mage_abyssbolt', name: '虚空·深渊箭', desc: '2转·本次伤害220%，无视20%魔抗', cooldown: 3, dmgMult: 2.2, ignoreDefPct: 20, mpCost: 26, zhuan: 2 },
            { id: 'mage_rupture', name: '虚空·裂隙', desc: '2转·伤害200%，无视15%魔抗', cooldown: 4, dmgMult: 2, ignoreDefPct: 15, mpCost: 30, zhuan: 2 },
            { id: 'mage_darkbeam', name: '虚空·暗束', desc: '2转·本次伤害280%', cooldown: 5, dmgMult: 2.8, mpCost: 34, zhuan: 2 },
            { id: 'mage_voidgrasp', name: '虚空·握杀', desc: '3转·无视40%魔抗，伤害320%', cooldown: 5, dmgMult: 3.2, ignoreDefPct: 40, mpCost: 42, zhuan: 3 },
            { id: 'mage_oblivion', name: '虚空·湮灭', desc: '3转·本次伤害350%', cooldown: 6, dmgMult: 3.5, mpCost: 44, zhuan: 3 },
            { id: 'mage_entropy', name: '虚空·熵增', desc: '3转·伤害270%，无视35%魔抗', cooldown: 5, dmgMult: 2.7, ignoreDefPct: 35, mpCost: 40, zhuan: 3 },
            { id: 'mage_consumption', name: '虚空·吞噬', desc: '3转·伤害250%，回复40%伤害生命', cooldown: 5, dmgMult: 2.5, lifestealPct: 0.4, mpCost: 38, zhuan: 3 },
            { id: 'mage_nullify', name: '虚空·虚无', desc: '3转·本次伤害300%，技能伤害+40%', cooldown: 6, dmgMult: 3, skillDmgBonus: 40, mpCost: 46, zhuan: 3 },
            { id: 'mage_voidshield', name: '虚空·护膜', desc: '3转·获得20%生命护盾，下回合技能伤害+30%', cooldown: 6, shieldPct: 0.2, mpCost: 36, zhuan: 3 },
            { id: 'mage_collapse', name: '虚空·坍缩', desc: '3转·无视50%魔抗，伤害290%', cooldown: 6, dmgMult: 2.9, ignoreDefPct: 50, mpCost: 48, zhuan: 3 },
            { id: 'mage_voidend', name: '虚空终结', desc: '4转·本次伤害420%，无视45%魔抗', cooldown: 9, dmgMult: 4.2, ignoreDefPct: 45, mpCost: 60, zhuan: 4 },
            { id: 'mage_abyssal', name: '虚空·深渊', desc: '4转·伤害380%，无视50%魔抗', cooldown: 8, dmgMult: 3.8, ignoreDefPct: 50, mpCost: 56, zhuan: 4 },
            { id: 'mage_antimatter', name: '虚空·反物质', desc: '4转·本次伤害400%', cooldown: 9, dmgMult: 4, mpCost: 58, zhuan: 4 },
            { id: 'mage_voidstorm', name: '虚空风暴', desc: '4转·群体70%伤害，无视30%魔抗', cooldown: 8, aoe: true, aoePct: 0.7, ignoreDefPct: 30, mpCost: 54, zhuan: 4 },
            { id: 'mage_rift', name: '虚空·裂界', desc: '4转·本次伤害360%，无视55%魔抗', cooldown: 8, dmgMult: 3.6, ignoreDefPct: 55, mpCost: 52, zhuan: 4 },
            { id: 'mage_zeropoint', name: '虚空·奇点', desc: '4转·本次伤害450%', cooldown: 10, dmgMult: 4.5, mpCost: 62, zhuan: 4 }
        ],
        branchC: [
            { id: 'mage_heal_c1', name: '圣愈·治愈', desc: '2转·回复生命上限25%', cooldown: 4, healPct: 0.25, mpCost: 22, zhuan: 2 },
            { id: 'mage_heal_c2', name: '圣愈·护盾', desc: '2转·获得30%生命护盾', cooldown: 5, shieldPct: 0.3, mpCost: 26, zhuan: 2 },
            { id: 'mage_heal_c3', name: '圣愈·祝福', desc: '2转·2回合技能伤害+30%', cooldown: 6, skillDmgBonus: 30, buffRounds: 2, mpCost: 20, zhuan: 2 },
            { id: 'mage_heal_c4', name: '圣愈·疗伤', desc: '2转·伤害150%，回复40%伤害生命', cooldown: 4, dmgMult: 1.5, lifestealPct: 0.4, mpCost: 28, zhuan: 2 },
            { id: 'mage_heal_c5', name: '圣愈·圣盾', desc: '2转·获得28%生命护盾', cooldown: 4, shieldPct: 0.28, mpCost: 24, zhuan: 2 },
            { id: 'mage_heal_c6', name: '圣愈·复苏', desc: '2转·回复生命上限20%，2回合减伤15%', cooldown: 6, healPct: 0.2, reduceDmgPct: 15, buffRounds: 2, mpCost: 30, zhuan: 2 },
            { id: 'mage_heal_c7', name: '圣愈·光辉', desc: '2转·本次伤害170%，获得15%护盾', cooldown: 4, dmgMult: 1.7, shieldPct: 0.15, mpCost: 26, zhuan: 2 },
            { id: 'mage_heal_c8', name: '圣愈·大疗', desc: '3转·回复生命上限35%', cooldown: 6, healPct: 0.35, mpCost: 38, zhuan: 3 },
            { id: 'mage_heal_c9', name: '圣愈·圣域', desc: '3转·获得40%生命护盾', cooldown: 6, shieldPct: 0.4, mpCost: 42, zhuan: 3 },
            { id: 'mage_heal_c10', name: '圣愈·神恩', desc: '3转·3回合技能伤害+40%', cooldown: 8, skillDmgBonus: 40, buffRounds: 3, mpCost: 36, zhuan: 3 },
            { id: 'mage_heal_c11', name: '圣愈·救赎', desc: '3转·伤害200%，回复50%伤害生命', cooldown: 5, dmgMult: 2, lifestealPct: 0.5, mpCost: 40, zhuan: 3 },
            { id: 'mage_heal_c12', name: '圣愈·天护', desc: '3转·获得35%护盾，本回合减伤20%', cooldown: 6, shieldPct: 0.35, reduceDmgPct: 20, mpCost: 44, zhuan: 3 },
            { id: 'mage_heal_c13', name: '圣愈·圣光', desc: '3转·回复30%生命，2回合攻击+20%', cooldown: 7, healPct: 0.3, buffAtkPct: 20, buffRounds: 2, mpCost: 42, zhuan: 3 },
            { id: 'mage_heal_c14', name: '圣愈·庇佑', desc: '3转·获得38%生命护盾', cooldown: 5, shieldPct: 0.38, mpCost: 40, zhuan: 3 },
            { id: 'mage_heal_c15', name: '圣愈·神愈', desc: '4转·回复生命上限50%', cooldown: 9, healPct: 0.5, mpCost: 54, zhuan: 4 },
            { id: 'mage_heal_c16', name: '圣愈·神盾', desc: '4转·获得50%生命护盾', cooldown: 9, shieldPct: 0.5, mpCost: 56, zhuan: 4 },
            { id: 'mage_heal_c17', name: '圣愈·天恩', desc: '4转·4回合技能伤害+50%', cooldown: 10, skillDmgBonus: 50, buffRounds: 4, mpCost: 52, zhuan: 4 },
            { id: 'mage_heal_c18', name: '圣愈·涅槃', desc: '4转·伤害280%，回复60%伤害生命', cooldown: 8, dmgMult: 2.8, lifestealPct: 0.6, mpCost: 58, zhuan: 4 },
            { id: 'mage_heal_c19', name: '圣愈·永恒', desc: '4转·获得45%护盾，3回合减伤25%', cooldown: 10, shieldPct: 0.45, reduceDmgPct: 25, buffRounds: 3, mpCost: 60, zhuan: 4 },
            { id: 'mage_heal_c20', name: '圣愈·神迹', desc: '4转·回复45%生命并获得30%护盾', cooldown: 10, healPct: 0.45, shieldPct: 0.3, mpCost: 62, zhuan: 4 }
        ],
        branchD: [
            { id: 'mage_curse_d1', name: '诅咒·虚弱', desc: '2转·伤害170%，目标下回合受伤+25%', cooldown: 4, dmgMult: 1.7, mpCost: 26, zhuan: 2 },
            { id: 'mage_curse_d2', name: '诅咒·侵蚀', desc: '2转·伤害180%，无视20%魔抗', cooldown: 4, dmgMult: 1.8, ignoreDefPct: 20, mpCost: 28, zhuan: 2 },
            { id: 'mage_curse_d3', name: '诅咒·腐化', desc: '2转·伤害160%，目标受伤+20%', cooldown: 5, dmgMult: 1.6, mpCost: 24, zhuan: 2 },
            { id: 'mage_curse_d4', name: '诅咒·噬魂', desc: '2转·伤害200%，回复30%伤害生命', cooldown: 4, dmgMult: 2, lifestealPct: 0.3, mpCost: 30, zhuan: 2 },
            { id: 'mage_curse_d5', name: '诅咒·破魔', desc: '2转·无视25%魔抗，伤害220%', cooldown: 4, dmgMult: 2.2, ignoreDefPct: 25, mpCost: 32, zhuan: 2 },
            { id: 'mage_curse_d6', name: '诅咒·凋零', desc: '2转·伤害190%，目标受伤+15%', cooldown: 5, dmgMult: 1.9, mpCost: 28, zhuan: 2 },
            { id: 'mage_curse_d7', name: '诅咒·暗蚀', desc: '2转·群体60%伤害', cooldown: 5, aoe: true, aoePct: 0.6, mpCost: 30, zhuan: 2 },
            { id: 'mage_curse_d8', name: '诅咒·魂灭', desc: '3转·伤害260%，目标受伤+25%', cooldown: 5, dmgMult: 2.6, mpCost: 40, zhuan: 3 },
            { id: 'mage_curse_d9', name: '诅咒·破抗', desc: '3转·无视40%魔抗，伤害280%', cooldown: 5, dmgMult: 2.8, ignoreDefPct: 40, mpCost: 42, zhuan: 3 },
            { id: 'mage_curse_d10', name: '诅咒·噬灵', desc: '3转·伤害240%，回复45%伤害生命', cooldown: 5, dmgMult: 2.4, lifestealPct: 0.45, mpCost: 44, zhuan: 3 },
            { id: 'mage_curse_d11', name: '诅咒·群蚀', desc: '3转·群体75%伤害', cooldown: 6, aoe: true, aoePct: 0.75, mpCost: 38, zhuan: 3 },
            { id: 'mage_curse_d12', name: '诅咒·崩解', desc: '3转·伤害270%，无视35%魔抗', cooldown: 6, dmgMult: 2.7, ignoreDefPct: 35, mpCost: 46, zhuan: 3 },
            { id: 'mage_curse_d13', name: '诅咒·死咒', desc: '3转·伤害250%，目标受伤+30%', cooldown: 6, dmgMult: 2.5, mpCost: 42, zhuan: 3 },
            { id: 'mage_curse_d14', name: '诅咒·暗潮', desc: '3转·群体70%伤害，无视15%魔抗', cooldown: 6, aoe: true, aoePct: 0.7, ignoreDefPct: 15, mpCost: 40, zhuan: 3 },
            { id: 'mage_curse_d15', name: '诅咒·灭魂', desc: '4转·伤害350%，目标受伤+35%', cooldown: 8, dmgMult: 3.5, mpCost: 56, zhuan: 4 },
            { id: 'mage_curse_d16', name: '诅咒·破界', desc: '4转·无视50%魔抗，伤害320%', cooldown: 8, dmgMult: 3.2, ignoreDefPct: 50, mpCost: 58, zhuan: 4 },
            { id: 'mage_curse_d17', name: '诅咒·终焉', desc: '4转·群体90%伤害', cooldown: 8, aoe: true, aoePct: 0.9, mpCost: 54, zhuan: 4 },
            { id: 'mage_curse_d18', name: '诅咒·噬神', desc: '4转·伤害380%，回复50%伤害生命', cooldown: 9, dmgMult: 3.8, lifestealPct: 0.5, mpCost: 60, zhuan: 4 },
            { id: 'mage_curse_d19', name: '诅咒·虚空蚀', desc: '4转·无视55%魔抗，伤害340%', cooldown: 9, dmgMult: 3.4, ignoreDefPct: 55, mpCost: 62, zhuan: 4 },
            { id: 'mage_curse_d20', name: '诅咒·灭世', desc: '4转·群体100%伤害，无视30%魔抗', cooldown: 10, aoe: true, aoePct: 1, ignoreDefPct: 30, mpCost: 60, zhuan: 4 }
        ]
    },
    archer: {
        base: [
            { id: 'archer_precise', name: '精准射击', desc: '必暴击，本次伤害140%', cooldown: 2, forceCrit: true, dmgMult: 1.4, mpCost: 12, zhuan: 1 },
            { id: 'archer_multi', name: '多重箭', desc: '2次85%伤害（独立暴击/连击）', cooldown: 3, multiHit: 2, multiHitPct: 0.85, mpCost: 18, zhuan: 1 },
            { id: 'archer_wind', name: '疾风步', desc: '本回合闪避+30%', cooldown: 4, dodgeBonus: 30, mpCost: 20, zhuan: 1 },
            { id: 'archer_poison', name: '毒箭', desc: '本次伤害130%，50%眩晕1回合', cooldown: 3, dmgMult: 1.3, stunChance: 0.5, stunTurns: 1, mpCost: 16, zhuan: 1 },
            { id: 'archer_rain', name: '箭雨', desc: '3次60%伤害', cooldown: 4, multiHit: 3, multiHitPct: 0.6, mpCost: 24, zhuan: 1 },
            { id: 'archer_aim', name: '弱点射击', desc: '必暴击，本次伤害180%', cooldown: 5, forceCrit: true, dmgMult: 1.8, mpCost: 28, zhuan: 1 },
            { id: 'archer_scatter', name: '散射', desc: '群体60%伤害', cooldown: 4, aoe: true, aoePct: 0.6, mpCost: 22, zhuan: 1 },
            { id: 'archer_wolf', name: '召唤·狩魂灵狼', desc: '1转·召唤灵狼(22%属性)，场上召唤物最多4只', cooldown: 4, summonBeast: true, summonPct: 0.22, summonName: '狩魂灵狼', archerSummon: true, mpCost: 20, zhuan: 1 }
        ],
        branchA: [
            { id: 'archer_storm', name: '风暴箭', desc: '2转·群体75%伤害', cooldown: 5, aoe: true, aoePct: 0.75, mpCost: 28, zhuan: 2 },
            { id: 'archer_pierce', name: '穿透箭', desc: '2转·无视50%防御，伤害160%', cooldown: 4, ignoreDefPct: 50, dmgMult: 1.6, mpCost: 26, zhuan: 2 },
            { id: 'archer_shadow', name: '暗影步', desc: '2转·本回合闪避+50%', cooldown: 5, dodgeBonus: 50, mpCost: 26, zhuan: 2 },
            { id: 'archer_beast', name: '召唤·幽冥战兽', desc: '2转·召唤战兽(28%属性)，场上最多4只', cooldown: 5, summonBeast: true, summonPct: 0.28, summonName: '幽冥战兽', archerSummon: true, mpCost: 30, zhuan: 2 },
            { id: 'archer_windarrow', name: '风之箭', desc: '2转·群体65%伤害，本回合闪避+15%', cooldown: 5, aoe: true, aoePct: 0.65, dodgeBonus: 15, mpCost: 28, zhuan: 2 },
            { id: 'archer_ambush', name: '伏击', desc: '2转·本次伤害190%，50%眩晕1回合', cooldown: 4, dmgMult: 1.9, stunChance: 0.5, stunTurns: 1, mpCost: 30, zhuan: 2 },
            { id: 'archer_soularrow', name: '狩魂·魂箭', desc: '2转·群体70%伤害', cooldown: 4, aoe: true, aoePct: 0.7, mpCost: 26, zhuan: 2 },
            { id: 'archer_snipe', name: '狙杀', desc: '3转·必暴击，伤害250%', cooldown: 6, forceCrit: true, dmgMult: 2.5, mpCost: 38, zhuan: 3 },
            { id: 'archer_barrage', name: '弹幕', desc: '3转·4次70%伤害', cooldown: 5, multiHit: 4, multiHitPct: 0.7, mpCost: 36, zhuan: 3 },
            { id: 'archer_trap', name: '冰霜陷阱', desc: '3转·伤害180%，70%眩晕2回合', cooldown: 5, dmgMult: 1.8, stunChance: 0.7, stunTurns: 2, mpCost: 34, zhuan: 3 },
            { id: 'archer_phantom', name: '召唤·寂灭影狩', desc: '3转·召唤影狩(35%属性)，场上最多4只', cooldown: 6, summonBeast: true, summonPct: 0.35, summonName: '寂灭影狩', archerSummon: true, mpCost: 38, zhuan: 3 },
            { id: 'archer_heartseeker', name: '穿心', desc: '3转·无视40%防御，伤害230%', cooldown: 5, ignoreDefPct: 40, dmgMult: 2.3, mpCost: 40, zhuan: 3 },
            { id: 'archer_ghost', name: '鬼步', desc: '3转·本回合闪避+60%', cooldown: 6, dodgeBonus: 60, mpCost: 32, zhuan: 3 },
            { id: 'archer_rapid', name: '疾射', desc: '3转·5次55%伤害', cooldown: 5, multiHit: 5, multiHitPct: 0.55, mpCost: 38, zhuan: 3 },
            { id: 'archer_rainstorm', name: '箭雨风暴', desc: '4转·群体100%伤害', cooldown: 7, aoe: true, aoePct: 1, dmgMult: 1.1, mpCost: 46, zhuan: 4 },
            { id: 'archer_death', name: '死亡标记', desc: '4转·必暴击，伤害320%', cooldown: 8, forceCrit: true, dmgMult: 3.2, mpCost: 50, zhuan: 4 },
            { id: 'archer_eternal', name: '召唤·万兽朝宗', desc: '4转·召唤至尊兽灵(42%属性)，场上最多4只', cooldown: 8, summonBeast: true, summonPct: 0.42, summonName: '万兽朝宗', archerSummon: true, mpCost: 48, zhuan: 4 },
            { id: 'archer_typhoon', name: '飓风箭', desc: '4转·群体110%伤害', cooldown: 7, aoe: true, aoePct: 1.1, dmgMult: 1, mpCost: 48, zhuan: 4 },
            { id: 'archer_phantomrain', name: '幻影箭雨', desc: '4转·6次55%伤害', cooldown: 8, multiHit: 6, multiHitPct: 0.55, mpCost: 52, zhuan: 4 }
        ],
        branchB: [
            { id: 'archer_marksman', name: '神射', desc: '2转·必暴击，本次伤害200%', cooldown: 5, forceCrit: true, dmgMult: 2, mpCost: 30, zhuan: 2 },
            { id: 'archer_precision', name: '神射·精准', desc: '2转·必暴击，伤害185%', cooldown: 4, forceCrit: true, dmgMult: 1.85, mpCost: 26, zhuan: 2 },
            { id: 'archer_armorbreak', name: '神射·破甲', desc: '2转·无视40%防御，伤害170%', cooldown: 4, ignoreDefPct: 40, dmgMult: 1.7, mpCost: 28, zhuan: 2 },
            { id: 'archer_critstrike', name: '神射·致命', desc: '2转·必暴击，伤害210%', cooldown: 5, forceCrit: true, dmgMult: 2.1, mpCost: 32, zhuan: 2 },
            { id: 'archer_steady', name: '神射·稳射', desc: '2转·本次伤害195%，无视25%防御', cooldown: 4, dmgMult: 1.95, ignoreDefPct: 25, mpCost: 28, zhuan: 2 },
            { id: 'archer_quickdraw', name: '神射·快拔', desc: '2转·必暴击，伤害175%', cooldown: 3, forceCrit: true, dmgMult: 1.75, mpCost: 24, zhuan: 2 },
            { id: 'archer_piercing', name: '神射·贯穿', desc: '2转·无视35%防御，伤害190%', cooldown: 4, ignoreDefPct: 35, dmgMult: 1.9, mpCost: 30, zhuan: 2 },
            { id: 'archer_headshot', name: '神射·爆头', desc: '3转·必暴击，伤害280%', cooldown: 6, forceCrit: true, dmgMult: 2.8, mpCost: 40, zhuan: 3 },
            { id: 'archer_sunder', name: '神射·裂甲', desc: '3转·无视55%防御，伤害250%', cooldown: 5, ignoreDefPct: 55, dmgMult: 2.5, mpCost: 42, zhuan: 3 },
            { id: 'archer_truehit', name: '神射·真击', desc: '3转·必暴击，伤害260%', cooldown: 5, forceCrit: true, dmgMult: 2.6, mpCost: 38, zhuan: 3 },
            { id: 'archer_weakpoint', name: '神射·弱点', desc: '3转·无视45%防御，伤害270%', cooldown: 6, ignoreDefPct: 45, dmgMult: 2.7, mpCost: 44, zhuan: 3 },
            { id: 'archer_deadeye', name: '神射·死眼', desc: '3转·必暴击，伤害290%', cooldown: 6, forceCrit: true, dmgMult: 2.9, mpCost: 46, zhuan: 3 },
            { id: 'archer_penetrate', name: '神射·穿透', desc: '3转·无视50%防御，伤害240%', cooldown: 5, ignoreDefPct: 50, dmgMult: 2.4, mpCost: 40, zhuan: 3 },
            { id: 'archer_finisher', name: '神射·终结', desc: '3转·必暴击，目标生命低于50%时伤害+30%', cooldown: 6, forceCrit: true, dmgMult: 2.5, mpCost: 44, zhuan: 3 },
            { id: 'archer_execute', name: '处决', desc: '4转·必暴击，伤害360%，目标生命低于30%时+50%', cooldown: 9, forceCrit: true, dmgMult: 3.6, mpCost: 54, zhuan: 4 },
            { id: 'archer_apocalypse', name: '神射·天罚', desc: '4转·必暴击，伤害340%', cooldown: 8, forceCrit: true, dmgMult: 3.4, mpCost: 52, zhuan: 4 },
            { id: 'archer_armorshatter', name: '神射·碎甲', desc: '4转·无视60%防御，伤害320%', cooldown: 8, ignoreDefPct: 60, dmgMult: 3.2, mpCost: 54, zhuan: 4 },
            { id: 'archer_judgment', name: '神射·审判', desc: '4转·必暴击，伤害380%', cooldown: 9, forceCrit: true, dmgMult: 3.8, mpCost: 58, zhuan: 4 },
            { id: 'archer_obliterate', name: '神射·湮灭', desc: '4转·无视65%防御，伤害350%', cooldown: 9, ignoreDefPct: 65, dmgMult: 3.5, mpCost: 56, zhuan: 4 },
            { id: 'archer_godshot', name: '神射·天诛', desc: '4转·必暴击，伤害400%', cooldown: 10, forceCrit: true, dmgMult: 4, mpCost: 60, zhuan: 4 }
        ],
        branchC: [
            { id: 'archer_trap_c1', name: '陷阱·冰刺', desc: '2转·伤害170%，65%眩晕1回合', cooldown: 4, dmgMult: 1.7, stunChance: 0.65, stunTurns: 1, mpCost: 26, zhuan: 2 },
            { id: 'archer_trap_c2', name: '陷阱·毒', desc: '2转·伤害160%，60%眩晕1回合', cooldown: 4, dmgMult: 1.6, stunChance: 0.6, stunTurns: 1, mpCost: 24, zhuan: 2 },
            { id: 'archer_trap_c3', name: '陷阱·雷', desc: '2转·伤害180%，55%眩晕2回合', cooldown: 5, dmgMult: 1.8, stunChance: 0.55, stunTurns: 2, mpCost: 30, zhuan: 2 },
            { id: 'archer_trap_c4', name: '陷阱·定身', desc: '2转·伤害150%，70%眩晕1回合', cooldown: 4, dmgMult: 1.5, stunChance: 0.7, stunTurns: 1, mpCost: 28, zhuan: 2 },
            { id: 'archer_trap_c5', name: '陷阱·缚足', desc: '2转·群体55%伤害，40%眩晕1回合', cooldown: 5, aoe: true, aoePct: 0.55, stunChance: 0.4, stunTurns: 1, mpCost: 32, zhuan: 2 },
            { id: 'archer_trap_c6', name: '陷阱·麻痹', desc: '2转·伤害190%，50%眩晕2回合', cooldown: 5, dmgMult: 1.9, stunChance: 0.5, stunTurns: 2, mpCost: 34, zhuan: 2 },
            { id: 'archer_trap_c7', name: '陷阱·刺网', desc: '2转·群体60%伤害，35%眩晕1回合', cooldown: 5, aoe: true, aoePct: 0.6, stunChance: 0.35, stunTurns: 1, mpCost: 30, zhuan: 2 },
            { id: 'archer_trap_c8', name: '陷阱·冰牢', desc: '3转·伤害220%，75%眩晕2回合', cooldown: 6, dmgMult: 2.2, stunChance: 0.75, stunTurns: 2, mpCost: 40, zhuan: 3 },
            { id: 'archer_trap_c9', name: '陷阱·毒沼', desc: '3转·群体70%伤害，50%眩晕1回合', cooldown: 6, aoe: true, aoePct: 0.7, stunChance: 0.5, stunTurns: 1, mpCost: 42, zhuan: 3 },
            { id: 'archer_trap_c10', name: '陷阱·雷域', desc: '3转·伤害200%，65%眩晕2回合', cooldown: 6, dmgMult: 2, stunChance: 0.65, stunTurns: 2, mpCost: 44, zhuan: 3 },
            { id: 'archer_trap_c11', name: '陷阱·锁魂', desc: '3转·伤害230%，70%眩晕1回合', cooldown: 5, dmgMult: 2.3, stunChance: 0.7, stunTurns: 1, mpCost: 46, zhuan: 3 },
            { id: 'archer_trap_c12', name: '陷阱·冰霜', desc: '3转·群体65%伤害，55%眩晕1回合', cooldown: 6, aoe: true, aoePct: 0.65, stunChance: 0.55, stunTurns: 1, mpCost: 40, zhuan: 3 },
            { id: 'archer_trap_c13', name: '陷阱·缚灵', desc: '3转·伤害210%，60%眩晕2回合', cooldown: 6, dmgMult: 2.1, stunChance: 0.6, stunTurns: 2, mpCost: 42, zhuan: 3 },
            { id: 'archer_trap_c14', name: '陷阱·震爆', desc: '3转·群体80%伤害，45%眩晕2回合', cooldown: 7, aoe: true, aoePct: 0.8, stunChance: 0.45, stunTurns: 2, mpCost: 48, zhuan: 3 },
            { id: 'archer_trap_c15', name: '陷阱·永冻', desc: '4转·伤害280%，80%眩晕2回合', cooldown: 8, dmgMult: 2.8, stunChance: 0.8, stunTurns: 2, mpCost: 54, zhuan: 4 },
            { id: 'archer_trap_c16', name: '陷阱·天罗', desc: '4转·群体90%伤害，60%眩晕1回合', cooldown: 8, aoe: true, aoePct: 0.9, stunChance: 0.6, stunTurns: 1, mpCost: 56, zhuan: 4 },
            { id: 'archer_trap_c17', name: '陷阱·灭魂', desc: '4转·伤害300%，75%眩晕2回合', cooldown: 9, dmgMult: 3, stunChance: 0.75, stunTurns: 2, mpCost: 58, zhuan: 4 },
            { id: 'archer_trap_c18', name: '陷阱·神缚', desc: '4转·群体85%伤害，70%眩晕2回合', cooldown: 9, aoe: true, aoePct: 0.85, stunChance: 0.7, stunTurns: 2, mpCost: 60, zhuan: 4 },
            { id: 'archer_trap_c19', name: '陷阱·绝境', desc: '4转·伤害260%，85%眩晕2回合', cooldown: 8, dmgMult: 2.6, stunChance: 0.85, stunTurns: 2, mpCost: 55, zhuan: 4 },
            { id: 'archer_trap_c20', name: '陷阱·终焉', desc: '4转·群体100%伤害，65%眩晕2回合', cooldown: 10, aoe: true, aoePct: 1, stunChance: 0.65, stunTurns: 2, mpCost: 62, zhuan: 4 }
        ],
        branchD: [
            { id: 'archer_wind_d1', name: '疾风·双箭', desc: '2转·2次90%伤害', cooldown: 3, multiHit: 2, multiHitPct: 0.9, mpCost: 22, zhuan: 2 },
            { id: 'archer_wind_d2', name: '疾风·闪避', desc: '2转·本回合闪避+45%', cooldown: 4, dodgeBonus: 45, mpCost: 24, zhuan: 2 },
            { id: 'archer_wind_d3', name: '疾风·三连', desc: '2转·3次70%伤害', cooldown: 4, multiHit: 3, multiHitPct: 0.7, mpCost: 26, zhuan: 2 },
            { id: 'archer_wind_d4', name: '疾风·影步', desc: '2转·本回合闪避+55%', cooldown: 5, dodgeBonus: 55, mpCost: 28, zhuan: 2 },
            { id: 'archer_wind_d5', name: '疾风·四连', desc: '2转·4次65%伤害', cooldown: 5, multiHit: 4, multiHitPct: 0.65, mpCost: 30, zhuan: 2 },
            { id: 'archer_wind_d6', name: '疾风·瞬射', desc: '2转·2次95%伤害', cooldown: 3, multiHit: 2, multiHitPct: 0.95, mpCost: 28, zhuan: 2 },
            { id: 'archer_wind_d7', name: '疾风·风步', desc: '2转·本回合闪避+50%，下次攻击+15%', cooldown: 5, dodgeBonus: 50, mpCost: 26, zhuan: 2 },
            { id: 'archer_wind_d8', name: '疾风·五连', desc: '3转·5次60%伤害', cooldown: 5, multiHit: 5, multiHitPct: 0.6, mpCost: 38, zhuan: 3 },
            { id: 'archer_wind_d9', name: '疾风·幻步', desc: '3转·本回合闪避+65%', cooldown: 6, dodgeBonus: 65, mpCost: 36, zhuan: 3 },
            { id: 'archer_wind_d10', name: '疾风·六连', desc: '3转·6次55%伤害', cooldown: 6, multiHit: 6, multiHitPct: 0.55, mpCost: 42, zhuan: 3 },
            { id: 'archer_wind_d11', name: '疾风·神行', desc: '3转·本回合闪避+70%', cooldown: 6, dodgeBonus: 70, mpCost: 40, zhuan: 3 },
            { id: 'archer_wind_d12', name: '疾风·七连', desc: '3转·7次50%伤害', cooldown: 6, multiHit: 7, multiHitPct: 0.5, mpCost: 44, zhuan: 3 },
            { id: 'archer_wind_d13', name: '疾风·无影', desc: '3转·3次85%伤害', cooldown: 4, multiHit: 3, multiHitPct: 0.85, mpCost: 40, zhuan: 3 },
            { id: 'archer_wind_d14', name: '疾风·鬼步', desc: '3转·本回合闪避+75%', cooldown: 7, dodgeBonus: 75, mpCost: 46, zhuan: 3 },
            { id: 'archer_wind_d15', name: '疾风·八连', desc: '4转·8次55%伤害', cooldown: 8, multiHit: 8, multiHitPct: 0.55, mpCost: 52, zhuan: 4 },
            { id: 'archer_wind_d16', name: '疾风·九天', desc: '4转·本回合闪避+80%', cooldown: 8, dodgeBonus: 80, mpCost: 50, zhuan: 4 },
            { id: 'archer_wind_d17', name: '疾风·十连', desc: '4转·10次45%伤害', cooldown: 9, multiHit: 10, multiHitPct: 0.45, mpCost: 56, zhuan: 4 },
            { id: 'archer_wind_d18', name: '疾风·神影', desc: '4转·本回合闪避+85%', cooldown: 9, dodgeBonus: 85, mpCost: 54, zhuan: 4 },
            { id: 'archer_wind_d19', name: '疾风·万箭', desc: '4转·群体80%伤害', cooldown: 8, aoe: true, aoePct: 0.8, mpCost: 55, zhuan: 4 },
            { id: 'archer_wind_d20', name: '疾风·无极', desc: '4转·12次40%伤害', cooldown: 10, multiHit: 12, multiHitPct: 0.4, mpCost: 60, zhuan: 4 }
        ]
    }
};
function abyssGetSkillById(classId, skillId) {
    var branch = (abyssRun && abyssRun.active) ? abyssRun.classBranch : null;
    var list = abyssGetSkillList(classId, branch);
    if (!list) return null;
    for (var i = 0; i < list.length; i++) if (list[i].id === skillId) return list[i];
    return null;
}

var ABYSS_QUALITIES = ['灰', '绿', '蓝', '紫', '橙'];
var ABYSS_QUALITY_COLOR = { 0: '#888', 1: '#4caf50', 2: '#2196f3', 3: '#9c27b0', 4: '#ff9800' };
// 五行：金木水火土，克制关系 金克木、木克土、土克水、水克火、火克金
var ABYSS_ELEMENTS = ['metal', 'wood', 'water', 'fire', 'earth'];
var ABYSS_ELEMENT_NAMES = { metal: '金', wood: '木', water: '水', fire: '火', earth: '土' };
var ABYSS_ELEMENT_COLORS = { metal: '#ffd700', wood: '#228b22', water: '#1e90ff', fire: '#ff4500', earth: '#8b4513' };
var ABYSS_ELEMENT_RESTRAIN = { metal: 'wood', wood: 'earth', earth: 'water', water: 'fire', fire: 'metal' };
var ABYSS_ELEMENT_RESTRAINED_BY = { metal: 'fire', wood: 'metal', earth: 'wood', water: 'earth', fire: 'water' };
function abyssElementRestrainMultiplier(attackerElement, defenderElement) {
    if (!attackerElement || !defenderElement) return 1;
    if (ABYSS_ELEMENT_RESTRAIN[attackerElement] === defenderElement) return 1.35;
    if (ABYSS_ELEMENT_RESTRAINED_BY[attackerElement] === defenderElement) return 0.7;
    return 1;
}
function abyssFmt1(v) {
    var n = Number(v);
    if (isNaN(n)) return '0';
    return (Math.floor(n * 10) / 10).toFixed(1);
}
var ABYSS_SLOTS = ['helmet','chest','pants','shoes','necklace','ring','weapon'];
var ABYSS_SLOT_NAMES = { helmet:'头盔', chest:'衣服', pants:'裤子', shoes:'鞋子', necklace:'项链', ring:'戒指', weapon:'武器' };
var ABYSS_SET_NAMES = ['无', '勇者', '暗影', '龙心', '虚空', '永恒', '修罗', '天罡', '幽冥', '神罚', '破灭'];
var ABYSS_EQUIP_NAMES = {
    helmet: ['龙鳞盔','荆棘冠','暗影帽','冰霜头箍','炎魔角','雷霆冠','幽魂面甲','圣光护额','噬魂帽','破军盔'],
    chest: ['龙心甲','影舞衣','寒铁胸甲','烈焰袍','雷纹战衣','幽影长袍','圣裁外衣','血怒战甲','虚空法袍','不屈之铠'],
    pants: ['龙鳞护腿','暗流腿甲','霜冻护腿','炎魔腿甲','雷鸣护腿','幽步长裤','圣行护腿','噬魂腿甲','破军护腿','虚空步甲'],
    shoes: ['龙行靴','暗影步靴','冰霜履','烈焰之足','雷霆战靴','幽魂靴','圣光之履','血行靴','虚空步靴','不屈战靴'],
    necklace: ['龙魂链','暗影之坠','冰心项链','炎玉坠','雷神链','幽魂吊坠','圣光护符','噬魂链','破军坠','虚空之眼'],
    ring: ['龙炎戒','暗影指环','冰霜戒','烈焰戒','雷霆戒','幽魂戒','圣光戒','噬魂指环','破军戒','虚空戒'],
    weapon: ['龙牙刃','暗影之锋','冰霜斩','烈焰裁决','雷霆之怒','幽魂镰','圣裁剑','噬魂刃','破军枪','虚空杖']
};
var ABYSS_EQUIP_SKILLS = [
    { id: 'eq1', name: '破甲', effect: { atk: 24, reduceMonsterDef: 8 } },
    { id: 'eq2', name: '致命', effect: { critRate: 5, critDmg: 38 } },
    { id: 'eq3', name: '嗜血', effect: { lifesteal: 5, atk: 16 } },
    { id: 'eq4', name: '神速', effect: { combo: 10, dodge: 5 } },
    { id: 'eq5', name: '强击', effect: { atk: 36, skillDmg: 14 } },
    { id: 'eq6', name: '铁壁', effect: { def: 45, hp: 240 } },
    { id: 'eq7', name: '穿云', effect: { reduceMonsterDef: 12, critDmg: 26 } },
    { id: 'eq8', name: '狂战', effect: { atk: 28, critRate: 7 } },
    { id: 'eq9', name: '灵巧', effect: { dodge: 10, combo: 8 } },
    { id: 'eq10', name: '法能', effect: { skillDmg: 30, atk: 12 } },
    { id: 'eq11', name: '坚韧', effect: { hp: 360, def: 24 } },
    { id: 'eq12', name: '碎甲', effect: { reduceMonsterDef: 15, atk: 18 } },
    { id: 'eq13', name: '暴虐', effect: { critDmg: 50, critRate: 3 } },
    { id: 'eq14', name: '吸血', effect: { lifesteal: 10, hp: 150 } },
    { id: 'eq15', name: '连打', effect: { combo: 15, atk: 12 } },
    { id: 'eq16', name: '奥术', effect: { skillDmg: 38 } },
    { id: 'eq17', name: '洞察', effect: { reduceMonsterDef: 10, critRate: 5 } },
    { id: 'eq18', name: '战意', effect: { atk: 45, hp: 180 } },
    { id: 'eq19', name: '幻步', effect: { dodge: 12, lifesteal: 3 } },
    { id: 'eq20', name: '毁灭', effect: { skillDmg: 20, critDmg: 45, reduceMonsterDef: 6 } },
    { id: 'eq21', name: '晕击', effect: { stunChance: 0.04, stunTurns: 1 } },
    { id: 'eq22', name: '重晕', effect: { stunChance: 0.1, stunTurns: 1 } },
    { id: 'eq23', name: '护盾术', effect: { shieldChance: 0.04, shieldPct: 0.18 } },
    { id: 'eq24', name: '坚甲', effect: { damageReduction: 0.1 } },
    { id: 'eq25', name: '破势', effect: { reduceMonsterDef: 24 } },
    { id: 'eq26', name: '冰封', effect: { stunChance: 0.06, stunTurns: 1 } },
    { id: 'eq27', name: '神佑', effect: { shieldChance: 0.1, shieldPct: 0.2 } },
    { id: 'eq28', name: '铁躯', effect: { damageReduction: 0.15 } },
    { id: 'eq29', name: '穿甲', effect: { reduceMonsterDef: 28 } },
    { id: 'eq30', name: '雷击', effect: { stunChance: 0.15, stunTurns: 1 } },
    { id: 'eq31', name: '灵盾', effect: { shieldChance: 0.05, shieldPct: 0.35 } },
    { id: 'eq32', name: '韧体', effect: { damageReduction: 0.08 } },
    { id: 'eq33', name: '卸甲', effect: { reduceMonsterDef: 20 } },
    { id: 'eq34', name: '震击', effect: { stunChance: 0.08, stunTurns: 1 } },
    { id: 'eq35', name: '壁垒', effect: { shieldChance: 0.06, shieldPct: 0.28 } },
    { id: 'eq36', name: '御敌', effect: { damageReduction: 0.18 } },
    { id: 'eq37', name: '碎防', effect: { reduceMonsterDef: 36 } },
    { id: 'eq38', name: '回春', effect: { healChance: 0.06, healPct: 0.1 } },
    { id: 'eq39', name: '噬魂', effect: { extraDmgChance: 0.1, extraDmgPct: 0.22 } },
    { id: 'eq40', name: '凝神', effect: { damageReduction: 0.05, shieldChance: 0.04, shieldPct: 0.12 } },
    { id: 'eq41', name: '防反', effect: { extraDmgFromDef: 0.22 } },
    { id: 'eq42', name: '生命打击', effect: { extraDmgFromMaxHp: 0.05 } },
    { id: 'eq43', name: '夺命', effect: { directPctMonsterHp: 0.025 } },
    { id: 'eq44', name: '铁壁击', effect: { extraDmgFromDef: 0.28 } },
    { id: 'eq45', name: '血气', effect: { extraDmgFromMaxHp: 0.07 } },
    { id: 'eq46', name: '斩魂', effect: { directPctMonsterHp: 0.05 } },
    { id: 'eq47', name: '破军', effect: { extraDmgFromAtk: 0.12 } },
    { id: 'eq48', name: '重甲', effect: { extraDmgFromDef: 0.38 } },
    { id: 'eq49', name: '生命燃烧', effect: { extraDmgFromMaxHp: 0.12 } },
    { id: 'eq50', name: '诛心', effect: { directPctMonsterHp: 0.07 } },
    { id: 'eq51', name: '锋芒', effect: { atk: 52, critRate: 5 } },
    { id: 'eq52', name: '固守', effect: { def: 72, hp: 300 } },
    { id: 'eq53', name: '疾风', effect: { dodge: 14, combo: 12 } },
    { id: 'eq54', name: '破军斩', effect: { reduceMonsterDef: 18, atk: 26 } },
    { id: 'eq55', name: '爆裂', effect: { critDmg: 62, skillDmg: 20 } },
    { id: 'eq56', name: '血怒', effect: { lifesteal: 8, atk: 20 } },
    { id: 'eq57', name: '洞察', effect: { reduceMonsterDef: 22, critRate: 7 } },
    { id: 'eq58', name: '雷霆', effect: { stunChance: 0.08, stunTurns: 1 } },
    { id: 'eq59', name: '神盾', effect: { shieldChance: 0.08, shieldPct: 0.28 } },
    { id: 'eq60', name: '金刚', effect: { damageReduction: 0.14 } },
    { id: 'eq61', name: '裂甲', effect: { extraDmgFromDef: 0.28 } },
    { id: 'eq62', name: '夺魂', effect: { directPctMonsterHp: 0.04 } },
    { id: 'eq63', name: '狂潮', effect: { extraDmgFromMaxHp: 0.06 } },
    { id: 'eq64', name: '战吼', effect: { atk: 42, hp: 240 } },
    { id: 'eq65', name: '鬼步', effect: { dodge: 16, lifesteal: 5 } },
    { id: 'eq66', name: '破魔', effect: { skillDmg: 45, reduceMonsterDef: 10 } },
    { id: 'eq67', name: '崩山', effect: { extraDmgFromAtk: 0.18 } },
    { id: 'eq68', name: '冰棘', effect: { stunChance: 0.12, stunTurns: 1 } },
    { id: 'eq69', name: '圣盾', effect: { shieldChance: 0.12, shieldPct: 0.38 } },
    { id: 'eq70', name: '不灭', effect: { damageReduction: 0.1, healChance: 0.05, healPct: 0.1 } },
    { id: 'eq71', name: '穿心', effect: { directPctMonsterHp: 0.06 } },
    { id: 'eq72', name: '铁骨', effect: { extraDmgFromDef: 0.38 } },
    { id: 'eq73', name: '血沸', effect: { extraDmgFromMaxHp: 0.1 } },
    { id: 'eq74', name: '暴风', effect: { combo: 20, atk: 18 } },
    { id: 'eq75', name: '魔能', effect: { skillDmg: 50, critDmg: 30 } },
    { id: 'eq76', name: '震魂', effect: { stunChance: 0.14, stunTurns: 1 } },
    { id: 'eq77', name: '龙鳞', effect: { shieldChance: 0.08, shieldPct: 0.45 } },
    { id: 'eq78', name: '坚毅', effect: { damageReduction: 0.16 } },
    { id: 'eq79', name: '碎魂', effect: { extraDmgChance: 0.16, extraDmgPct: 0.35 } },
    { id: 'eq80', name: '回生', effect: { healChance: 0.1, healPct: 0.18 } },
    { id: 'eq81', name: '斩龙', effect: { directPctMonsterMaxHp: 0.025 } },
    { id: 'eq82', name: '破势', effect: { reduceMonsterDef: 26, critDmg: 38 } },
    { id: 'eq83', name: '战魂', effect: { atk: 58, critRate: 10 } },
    { id: 'eq84', name: '玄甲', effect: { def: 100, damageReduction: 0.08 } },
    { id: 'eq85', name: '噬血', effect: { lifesteal: 12, hp: 180 } },
    { id: 'eq86', name: '雷域', effect: { stunChance: 0.18, stunTurns: 1 } },
    { id: 'eq87', name: '天护', effect: { shieldChance: 0.16, shieldPct: 0.35 } },
    { id: 'eq88', name: '崩防', effect: { extraDmgFromDef: 0.48 } },
    { id: 'eq89', name: '诛邪', effect: { directPctMonsterHp: 0.08 } },
    { id: 'eq90', name: '焚心', effect: { extraDmgFromMaxHp: 0.14 } },
    { id: 'eq91', name: '无双', effect: { atk: 64, combo: 10 } },
    { id: 'eq92', name: '神行', effect: { dodge: 20, combo: 18 } },
    { id: 'eq93', name: '破界', effect: { skillDmg: 55, reduceMonsterDef: 20 } },
    { id: 'eq94', name: '天罚', effect: { extraDmgFromAtk: 0.28 } },
    { id: 'eq95', name: '冰狱', effect: { stunChance: 0.2, stunTurns: 2 } },
    { id: 'eq96', name: '神佑', effect: { shieldChance: 0.2, shieldPct: 0.4 } },
    { id: 'eq97', name: '霸体', effect: { damageReduction: 0.24 } },
    { id: 'eq98', name: '噬魂', effect: { extraDmgChance: 0.24, extraDmgPct: 0.4 } },
    { id: 'eq99', name: '涅槃', effect: { healChance: 0.16, healPct: 0.22 } },
    { id: 'eq100', name: '灭世', effect: { directPctMonsterMaxHp: 0.05, extraDmgFromAtk: 0.24 } },
    { id: 'eq101', name: '分裂·微光', effect: { splitChance: 0.08, splitPct: 0.15 } },
    { id: 'eq102', name: '分裂·涟漪', effect: { splitChance: 0.1, splitPct: 0.18 } },
    { id: 'eq103', name: '分裂·溅射', effect: { splitChance: 0.12, splitPct: 0.22 } },
    { id: 'eq104', name: '分裂·扩散', effect: { splitChance: 0.14, splitPct: 0.26 } },
    { id: 'eq105', name: '分裂·震荡', effect: { splitChance: 0.16, splitPct: 0.3 } },
    { id: 'eq106', name: '分裂·冲击波', effect: { splitChance: 0.18, splitPct: 0.35 } },
    { id: 'eq107', name: '分裂·余波', effect: { splitChance: 0.2, splitPct: 0.4 } },
    { id: 'eq108', name: '分裂·崩裂', effect: { splitChance: 0.22, splitPct: 0.45 } },
    { id: 'eq109', name: '分裂·天崩', effect: { splitChance: 0.25, splitPct: 0.5 } },
    { id: 'eq110', name: '分裂·灭世', effect: { splitChance: 0.28, splitPct: 0.55 } },
    { id: 'eq111', name: '灵宠·攻', effect: { petAtk: 42 } },
    { id: 'eq112', name: '灵宠·守', effect: { petDef: 36, petHp: 280 } },
    { id: 'eq113', name: '灵宠·命', effect: { petHp: 480 } },
    { id: 'eq114', name: '灵宠·嗜', effect: { petLifesteal: 6, petAtk: 22 } },
    { id: 'eq115', name: '灵宠·闪', effect: { petDodge: 9 } },
    { id: 'eq116', name: '灵宠·暴', effect: { petCritRate: 7, petCritDmg: 35 } },
    { id: 'eq117', name: '灵宠·韧', effect: { petDamageReduction: 0.11, petHp: 260 } },
    { id: 'eq118', name: '灵宠·锋', effect: { petAtk: 68, petCritRate: 5 } },
    { id: 'eq119', name: '灵宠·甲', effect: { petDef: 62, petDamageReduction: 0.07 } },
    { id: 'eq120', name: '灵宠·血', effect: { petHp: 680, petLifesteal: 5 } },
    { id: 'eq121', name: '灵宠·影', effect: { petDodge: 14, petAtk: 28 } },
    { id: 'eq122', name: '灵宠·狂', effect: { petCritRate: 11, petCritDmg: 55 } },
    { id: 'eq123', name: '灵宠·壁', effect: { petDef: 82, petHp: 420, petDamageReduction: 0.09 } },
    { id: 'eq124', name: '灵宠·噬', effect: { petLifesteal: 9, petAtk: 48, petHp: 280 } },
    { id: 'eq125', name: '灵宠·幻', effect: { petDodge: 19, petCritRate: 6 } },
    { id: 'eq126', name: '灵宠·戮', effect: { petAtk: 95, petCritDmg: 68 } },
    { id: 'eq127', name: '灵宠·圣', effect: { petHp: 950, petDamageReduction: 0.14, petLifesteal: 6 } },
    { id: 'eq128', name: '灵宠·神行', effect: { petDodge: 24, petAtk: 55, petDef: 42 } },
    { id: 'eq129', name: '灵宠·战神', effect: { petAtk: 120, petCritRate: 14, petCritDmg: 82 } },
    { id: 'eq130', name: '灵宠·至尊', effect: { petAtk: 82, petDef: 68, petHp: 820, petLifesteal: 7, petDodge: 16, petCritRate: 8, petCritDmg: 48, petDamageReduction: 0.16 } },
    { id: 'eq131', name: '灵宠·分裂·微', effect: { petSplitChance: 0.1, petSplitPct: 0.18 } },
    { id: 'eq132', name: '灵宠·分裂·波', effect: { petSplitChance: 0.14, petSplitPct: 0.25 } },
    { id: 'eq133', name: '灵宠·分裂·震', effect: { petSplitChance: 0.18, petSplitPct: 0.32 } },
    { id: 'eq134', name: '灵宠·分裂·灭', effect: { petSplitChance: 0.22, petSplitPct: 0.4 } },
    { id: 'eq135', name: '灵宠·吸血·噬', effect: { petLifesteal: 10, petAtk: 20 } },
    { id: 'eq136', name: '灵宠·吸血·渴', effect: { petLifesteal: 14, petHp: 250 } },
    { id: 'eq137', name: '灵宠·吸血·魂', effect: { petLifesteal: 18, petAtk: 30, petHp: 200 } },
    { id: 'eq138', name: '灵宠·吸血·王', effect: { petLifesteal: 22, petAtk: 40, petHp: 400 } }
];

// 无限深渊-装备符文（每件装备最多2个符文槽）
var ABYSS_RUNES = [
    { id: 'rune_atk', name: '攻击符文', effect: { atk: 38 } },
    { id: 'rune_hp', name: '生命符文', effect: { hp: 320 } },
    { id: 'rune_def', name: '护甲符文', effect: { def: 26 } },
    { id: 'rune_crit', name: '暴击符文', effect: { critRate: 3, critDmg: 20 } },
    { id: 'rune_dodge', name: '闪避符文', effect: { dodge: 4 } },
    { id: 'rune_life', name: '吸血符文', effect: { lifesteal: 7 } },
    { id: 'rune_combo', name: '连击符文', effect: { combo: 5 } },
    { id: 'rune_skill', name: '法强符文', effect: { skillDmg: 12 } },
    { id: 'rune_break', name: '破甲符文', effect: { reduceMonsterDef: 6 } },
    { id: 'rune_str', name: '力量符文', effect: { str: 9 } },
    { id: 'rune_agi', name: '敏捷符文', effect: { agi: 9 } },
    { id: 'rune_int', name: '智力符文', effect: { int: 9 } },
    { id: 'rune_sta', name: '体力符文', effect: { sta: 9 } },
    { id: 'rune_fire', name: '火攻符文', effect: { fireAtk: 8 } },
    { id: 'rune_ice', name: '冰攻符文', effect: { waterAtk: 8 } },
    { id: 'rune_metal', name: '金攻符文', effect: { metalAtk: 8 } }
];
var ABYSS_MAX_RUNE_SLOTS = 2;

// 无限深渊-装备宝石（每件装备最多3个宝石槽）
var ABYSS_GEMS = [
    { id: 'gem_hp', name: '生命宝石', effect: { hp: 260 } },
    { id: 'gem_atk', name: '攻击宝石', effect: { atk: 32 } },
    { id: 'gem_def', name: '防御宝石', effect: { def: 22 } },
    { id: 'gem_crit', name: '暴击宝石', effect: { critRate: 2, critDmg: 15 } },
    { id: 'gem_dodge', name: '闪避宝石', effect: { dodge: 6 } },
    { id: 'gem_life', name: '吸血宝石', effect: { lifesteal: 5 } },
    { id: 'gem_combo', name: '连击宝石', effect: { combo: 4 } },
    { id: 'gem_skill', name: '法强宝石', effect: { skillDmg: 10 } },
    { id: 'gem_break', name: '破甲宝石', effect: { reduceMonsterDef: 5 } },
    { id: 'gem_str', name: '力量宝石', effect: { str: 7 } },
    { id: 'gem_agi', name: '敏捷宝石', effect: { agi: 7 } },
    { id: 'gem_int', name: '智力宝石', effect: { int: 7 } },
    { id: 'gem_sta', name: '体力宝石', effect: { sta: 7 } },
    { id: 'gem_exp', name: '经验宝石', effect: { expGainPct: 5 } },
    { id: 'gem_gold', name: '金币宝石', effect: { goldGainPct: 5 } }
];
var ABYSS_MAX_GEM_SLOTS = 3;

// 深渊装备（符文+宝石）提供的经验/金币获得加成（百分比），以及升级选择的加成
function abyssGetExpGoldBonus() {
    var expPct = 0, goldPct = 0;
    if (!abyssRun) return { expPct: expPct, goldPct: goldPct };
    if (abyssRun.equipped) {
        for (var ek in abyssRun.equipped) {
            var eq = abyssRun.equipped[ek];
            if (!eq) continue;
            var runes = eq.runes || [];
            for (var ri = 0; ri < runes.length; ri++) {
                var r = runes[ri] ? getAbyssRuneById(runes[ri]) : null;
                if (r && r.effect) { expPct += r.effect.expGainPct || 0; goldPct += r.effect.goldGainPct || 0; }
            }
            var gems = eq.gems || [];
            for (var gi = 0; gi < gems.length; gi++) {
                var g = gems[gi] ? getAbyssGemById(gems[gi]) : null;
                if (g && g.effect) { expPct += g.effect.expGainPct || 0; goldPct += g.effect.goldGainPct || 0; }
            }
        }
    }
    if (abyssRun.buffs) {
        expPct += abyssRun.buffs.expPct || 0;
        goldPct += abyssRun.buffs.goldPct || 0;
    }
    if (abyssRun.curseRounds > 0 && abyssRun.rewardEffects) {
        expPct += abyssRun.rewardEffects.expPct || 0;
        goldPct += abyssRun.rewardEffects.goldPct || 0;
    }
    return { expPct: expPct, goldPct: goldPct };
}
function abyssApplyExpGoldBonus(baseExp, baseGold) {
    var b = abyssGetExpGoldBonus();
    return {
        exp: Math.floor((baseExp || 0) * (1 + (b.expPct || 0) / 100)),
        gold: Math.floor((baseGold || 0) * (1 + (b.goldPct || 0) / 100))
    };
}

function getAbyssRuneById(runeId) {
    for (var i = 0; i < ABYSS_RUNES.length; i++) if (ABYSS_RUNES[i].id === runeId) return ABYSS_RUNES[i];
    return null;
}
function getAbyssGemById(gemId) {
    for (var i = 0; i < ABYSS_GEMS.length; i++) if (ABYSS_GEMS[i].id === gemId) return ABYSS_GEMS[i];
    return null;
}
// 掉落时随机符文槽数量：80%为0个，15%为1个，5%为2个
function abyssRollRuneSlotCount() {
    var r = Math.random();
    if (r < 0.80) return 0;
    if (r < 0.95) return 1;
    return 2;
}
// 掉落时随机宝石槽数量：75%为0个，15%为1个，5%为2个，5%为3个
function abyssRollGemSlotCount() {
    var r = Math.random();
    if (r < 0.75) return 0;
    if (r < 0.90) return 1;
    if (r < 0.95) return 2;
    return 3;
}

function getAbyssTower() {
    if (!player.abyssTower) {
        player.abyssTower = { exclusiveCurrency: 0, bestFloor: 0, level: 0, startGearCount: 0, startGearPurchaseCount: 0, startGoldBonus: 0, startPetCount: 0, deployedSlotsPurchases: 0, permanentBonuses: { hp: 0, atk: 0, def: 0, critRate: 0, critDmg: 0, dodge: 0, lifesteal: 0, combo: 0 }, abyssVault: {} };
    }
    if (!player.abyssTower.abyssVault) player.abyssTower.abyssVault = {};
    return player.abyssTower;
}

function toggleAbyssTower() {
      if (player.reincarnationCount < 2500) {
        alert("需要达到2500转才能开启无限深渊！");
        return;
    }
    var overlay = document.getElementById('abyssTowerOverlay');
    var ui = document.getElementById('abyssTowerUI');
    if (overlay.style.display === 'none' || !overlay.style.display) {
        overlay.style.display = 'block';
        ui.style.display = 'block';
        refreshAbyssTowerUI();
    } else {
        overlay.style.display = 'none';
        ui.style.display = 'none';
    }
}

function closeAbyssTower() {
    document.getElementById('abyssTowerOverlay').style.display = 'none';
    document.getElementById('abyssTowerUI').style.display = 'none';
}

function refreshAbyssTowerUI() {
    var at = getAbyssTower();
    document.getElementById('abyssExclusiveCurrency').textContent = (at.exclusiveCurrency || 0);
    document.getElementById('abyssBestFloor').textContent = (at.bestFloor || 0);
    var sgEl = document.getElementById('abyssStartGearCount');
    if (sgEl) sgEl.textContent = Math.min(20, at.startGearCount || 0);
    var pName = (typeof player !== 'undefined' && player && player.name) ? player.name : '勇者';
    var pAvatar = (typeof player !== 'undefined' && player && player.avatar) ? player.avatar : '';
    var nameEl = document.getElementById('abyssPlayerName');
    var avatarEl = document.getElementById('abyssPlayerAvatar');
    var placeholderEl = document.getElementById('abyssPlayerAvatarPlaceholder');
    if (nameEl) nameEl.textContent = pName;
    if (avatarEl && placeholderEl) {
        if (pAvatar) {
            avatarEl.src = pAvatar;
            avatarEl.style.display = '';
            placeholderEl.style.display = 'none';
        } else {
            avatarEl.src = '';
            avatarEl.style.display = 'none';
            placeholderEl.style.display = 'flex';
            placeholderEl.textContent = (pName && pName.length > 0) ? pName.charAt(0) : '?';
        }
    }
    var running = abyssRun && abyssRun.active;
    document.getElementById('abyssStartPanel').style.display = running ? 'none' : 'block';
    document.getElementById('abyssRunPanel').style.display = running ? 'block' : 'none';
    var escapeBtn = document.getElementById('abyssEscapeBtn');
    if (escapeBtn) escapeBtn.style.display = running ? 'inline-block' : 'none';
    if (!running) abyssSelectClass(abyssSelectedClass || 'warrior');
    if (running) {
        updateAbyssRunUI();
    }
}

function abyssSelectClass(classId) {
    abyssSelectedClass = classId;
    var descEl = document.getElementById('abyssClassDesc');
    if (descEl) {
        var c = ABYSS_CLASSES.find(function(x) { return x.id === classId; });
        descEl.textContent = c ? c.desc : '';
    }
    var ids = ['Warrior','Mage','Archer'];
    var map = { warrior: 'Warrior', mage: 'Mage', archer: 'Archer' };
    ids.forEach(function(cap) {
        var btn = document.getElementById('abyssClass' + cap);
        if (btn) {
            var id = cap.toLowerCase();
            btn.style.borderWidth = (id === classId) ? '3px' : '2px';
            btn.style.boxShadow = (id === classId) ? '0 0 12px rgba(255,215,0,0.6)' : 'none';
        }
    });
}

function abyssShowBranchSelection() {
    if (!abyssRun || !abyssRun.active || abyssRun.classBranch) return;
    var classId = abyssRun.playerClass || 'warrior';
    var info = ABYSS_BRANCH_INFO[classId];
    if (!info) return;
    var descEl = document.getElementById('abyssBranchDesc');
    if (descEl) {
        var a = info.branchA ? info.branchA.name + '</b><br/><span style="color:#aaa;">' + info.branchA.desc : '';
        var b = info.branchB ? info.branchB.name + '</b><br/><span style="color:#aaa;">' + info.branchB.desc : '';
        var c = info.branchC ? info.branchC.name + '</b><br/><span style="color:#aaa;">' + info.branchC.desc : '';
        var d = info.branchD ? info.branchD.name + '</b><br/><span style="color:#aaa;">' + info.branchD.desc : '';
        descEl.innerHTML = '<div style="margin-bottom:6px;"><b style="color:#ff6b6b;">分支A · ' + a + '</span></div><div style="margin-bottom:6px;"><b style="color:#42a5f5;">分支B · ' + b + '</span></div><div style="margin-bottom:6px;"><b style="color:#4caf50;">分支C · ' + c + '</span></div><div><b style="color:#9c27b0;">分支D · ' + d + '</span></div>';
    }
    document.getElementById('abyssBranchOverlay').style.display = 'block';
    document.getElementById('abyssBranchUI').style.display = 'block';
    var btnA = document.getElementById('abyssBranchABtn'); var btnB = document.getElementById('abyssBranchBBtn'); var btnC = document.getElementById('abyssBranchCBtn'); var btnD = document.getElementById('abyssBranchDBtn');
    if (btnA) { btnA.onclick = function() { abyssChooseBranch('branchA'); }; btnA.textContent = (info.branchA ? info.branchA.name : '分支A'); }
    if (btnB) { btnB.onclick = function() { abyssChooseBranch('branchB'); }; btnB.textContent = (info.branchB ? info.branchB.name : '分支B'); }
    if (btnC) { btnC.onclick = function() { abyssChooseBranch('branchC'); }; btnC.textContent = (info.branchC ? info.branchC.name : '分支C'); }
    if (btnD) { btnD.onclick = function() { abyssChooseBranch('branchD'); }; btnD.textContent = (info.branchD ? info.branchD.name : '分支D'); }
}
function abyssChooseBranch(branch) {
    if (!abyssRun || !abyssRun.active || abyssRun.classBranch) return;
    abyssRun.classBranch = branch;
    document.getElementById('abyssBranchOverlay').style.display = 'none';
    document.getElementById('abyssBranchUI').style.display = 'none';
    var info = ABYSS_BRANCH_INFO[abyssRun.playerClass] || {};
    var name = (info[branch] && info[branch].name) ? info[branch].name : branch;
    abyssLog('选择职业分支：' + name + '！');
    updateAbyssRunUI();
}

function startAbyssRun() {
     // 检查深渊令牌
    if (!player.items.fubeng1 || player.items.fubeng1 < 1) {
        logAction('深渊令牌不足！', 'error');
        return;
    }
    
    // 消耗副本令牌
    player.items.fubeng1--;

    var at0 = getAbyssTower();
    abyssRun = {
        active: true,
        floor: 1,
        gold: ((at0.startGoldBonus || 0) * 2),
        playerClass: abyssSelectedClass || 'warrior',
        player: {
            hp: 1000, maxHp: 1000, atk: 100, def: 50, critRate: 5, critDmg: 150, dodge: 0, lifesteal: 0, combo: 0,
            shield: 0, mp: 50
        },
        equipped: { helmet: null, chest: null, pants: null, shoes: null, necklace: null, ring: null, weapon: null },
        inventory: [],
        runeInventory: [],
        gemInventory: [],
        materials: { enhanceStone: 0, enchantBook: 0, potion: 0, upgradeStone: 0, petRevivePotion: 0, petSkillBook: 0, runeSlotOpener: 0, gemSlotOpener: 0 },
        tempStats: { hp: 0, atk: 0, def: 0, critRate: 0, critDmg: 0, dodge: 0, lifesteal: 0, combo: 0, skillDmg: 0, reduceMonsterDef: 0 },
        talentPoints: 0,
        talents: {},
        lastGrantedTalentLevel: 0,
        skillCooldowns: {},
        nextSkillId: null,
        buffs: {},
        thisRoundDodgeBonus: 0,
        thisRoundReduceDmg: 0,
        monster: null,
        justKilledBoss: false,
        pendingChoice: false,
        pendingUpgradeChoice: false,
        lastUpgradeChoiceLevel: 0,
        runLevel: 0,
        exp: 0,
        pets: [],
        deployedPetIds: [],
        petGuard: false,
        playerTargetIndex: 0,
        learnedSkillIds: [],
        equippedSkillIds: [null, null, null],
        beastSummons: [],
        classBranch: null
    };
    var at = getAbyssTower();
    var pb = at.permanentBonuses || {};
    abyssRun.player.hp += (pb.hp || 0);
    abyssRun.player.maxHp += (pb.hp || 0);
    abyssRun.player.atk += (pb.atk || 0);
    abyssRun.player.def += (pb.def || 0);
    abyssRun.player.critRate += (pb.critRate || 0);
    abyssRun.player.critDmg += (pb.critDmg || 0);
    abyssRun.player.dodge += (pb.dodge || 0);
    abyssRun.player.lifesteal += (pb.lifesteal || 0);
    abyssRun.player.combo += (pb.combo || 0);
    var cls = ABYSS_CLASSES.find(function(x) { return x.id === (abyssRun.playerClass || 'warrior'); });
    if (cls && cls.bonus) {
        for (var bk in cls.bonus) {
            var v = cls.bonus[bk];
            abyssRun.player[bk] = (abyssRun.player[bk] || 0) + v;
        }
        if (cls.bonus.hp) {
            abyssRun.player.maxHp = (abyssRun.player.maxHp || 0) + cls.bonus.hp;
            abyssRun.player.hp = abyssRun.player.maxHp;
        }
    }
    var vault = at.abyssVault || {};
    var vAtkPct = 0, vHpPct = 0, vDefPct = 0, vCritDmgPct = 0, vAtkFlat = 0, vDefFlat = 0, vHpFlat = 0;
    ABYSS_VAULT_TREASURES.forEach(function(t) {
        var c = vault[t.id] || 0;
        if (c <= 0) return;
        var e = t.effect;
        if (e.type === 'atkVaultPct') vAtkPct += e.value * c; else if (e.type === 'hpVaultPct') vHpPct += e.value * c; else if (e.type === 'defVaultPct') vDefPct += e.value * c; else if (e.type === 'critDmgVaultPct') vCritDmgPct += e.value * c;
        else if (e.type === 'atkVaultFlat') vAtkFlat += e.value * c; else if (e.type === 'defVaultFlat') vDefFlat += e.value * c; else if (e.type === 'hpVaultFlat') vHpFlat += e.value * c;
    });
    abyssRun.player.atk = Math.floor((abyssRun.player.atk + vAtkFlat) * (1 + vAtkPct / 100));
    abyssRun.player.def = Math.floor((abyssRun.player.def + vDefFlat) * (1 + vDefPct / 100));
    abyssRun.player.critDmg = (abyssRun.player.critDmg || 0) + vCritDmgPct;
    var newMaxHp = Math.floor((abyssRun.player.maxHp + vHpFlat) * (1 + vHpPct / 100));
    abyssRun.player.maxHp = newMaxHp;
    abyssRun.player.hp = newMaxHp;
    abyssRun.autoAttack = false;
    stopAbyssAutoAttack();
    giveAbyssStartGearFromShop();
    var at1 = getAbyssTower();
    var startPetCount = Math.min(5, at1.startPetCount || 0);
    for (var spi = 0; spi < startPetCount; spi++) {
        var mName = ABYSS_NORMAL_MONSTER_NAMES[Math.floor(Math.random() * ABYSS_NORMAL_MONSTER_NAMES.length)];
        var newPet = abyssGenPet(mName, 1);
        if (newPet) abyssRun.pets.push(newPet);
    }
    if (startPetCount > 0) abyssLog('开局获得 ' + startPetCount + ' 只宠物。');
    abyssSpawnMonster();
    refreshAbyssTowerUI();
    var at2 = getAbyssTower();
    abyssLog('无限深渊开始！等级' + abyssRun.runLevel + '，开局装备' + (at2.startGearCount || 0) + '件，闯关金币' + (abyssRun.gold || 0) + '。');
}

function giveAbyssStartGearFromShop() {
    var at = getAbyssTower();
    var count = Math.min(20, at.startGearCount || 0);
    for (var i = 0; i < count; i++) {
        var eq = abyssGenEquipment(1, true);
        if (eq) abyssRun.inventory.push(eq);
    }
}

function abyssGenId() { return 'abyss_' + Date.now() + '_' + Math.random().toString(36).slice(2, 9); }

function abyssGenEquipment(floor, forStart, maxQuality, fixedQuality) {
    var quality;
    if (fixedQuality !== undefined && fixedQuality !== null) {
        quality = Math.min(4, Math.max(0, Math.floor(fixedQuality)));
    } else {
        var qMax = (maxQuality !== undefined) ? (maxQuality + 1) : 5;
        quality = forStart ? Math.floor(Math.random() * 3) : Math.floor(Math.random() * qMax);
        if (maxQuality !== undefined && quality > maxQuality) quality = maxQuality;
    }
    var slot = ABYSS_SLOTS[Math.floor(Math.random() * ABYSS_SLOTS.length)];
    var setIdx = quality >= 2 ? Math.floor(Math.random() * (ABYSS_SET_NAMES.length - 1)) + 1 : 0;
    var willHaveEquipSkill = Math.random() < 0.28;
    var baseQualityForStats = (setIdx || willHaveEquipSkill) ? 0 : quality;
    var base = { hp: 0, atk: 0, def: 0, critRate: 0, critDmg: 0, dodge: 0, lifesteal: 0, combo: 0, skillDmg: 0, reduceMonsterDef: 0, str: 0, agi: 0, int: 0, sta: 0, metalAtk: 0, woodAtk: 0, waterAtk: 0, fireAtk: 0, earthAtk: 0, metalRes: 0, woodRes: 0, waterRes: 0, fireRes: 0, earthRes: 0 };
    var f = Math.max(1, floor || 1);
    var scale = Math.floor(Math.sqrt(f * 1.15) * (1 + baseQualityForStats * 0.1));
    var roll = Math.floor(Math.random() * 3) + 1;
    base.hp += Math.floor(scale * 9 * roll);
    base.atk += Math.floor(scale * 2.4 * roll);
    base.def += Math.floor(scale * 1.2 * roll);
    if (Math.random() < 0.3) base.critRate += 1 + baseQualityForStats;
    if (Math.random() < 0.3) base.critDmg += 5 + baseQualityForStats * 5;
    if (Math.random() < 0.2) base.dodge += 0.5 + baseQualityForStats * 0.5;
    if (Math.random() < 0.2) base.lifesteal += 1 + baseQualityForStats;
    if (Math.random() < 0.2) base.combo += 2 + baseQualityForStats;
    if (Math.random() < 0.15) base.skillDmg += 10 + baseQualityForStats * 10;
    if (Math.random() < 0.25) base.str += 2 + baseQualityForStats * 2;
    if (Math.random() < 0.25) base.agi += 2 + baseQualityForStats * 2;
    if (Math.random() < 0.25) base.int += 2 + baseQualityForStats * 2;
    if (Math.random() < 0.25) base.sta += 2 + baseQualityForStats * 2;
    for (var ei = 0; ei < ABYSS_ELEMENTS.length; ei++) {
        var el = ABYSS_ELEMENTS[ei];
        if (Math.random() < 0.22) base[el + 'Atk'] = (base[el + 'Atk'] || 0) + (2 + baseQualityForStats + Math.floor(Math.random() * 5));
        if (Math.random() < 0.22) base[el + 'Res'] = (base[el + 'Res'] || 0) + (1 + baseQualityForStats + Math.floor(Math.random() * 4));
    }
    var equipLevel = forStart ? 1 : (1 + Math.floor((floor || 1) / 5) + Math.floor(Math.random() * 2));
    var names = ABYSS_EQUIP_NAMES[slot] || ['未知'];
    var equipName = names[Math.floor(Math.random() * names.length)];
    var equipSkill = null;
    if (willHaveEquipSkill) {
        var sk = ABYSS_EQUIP_SKILLS[Math.floor(Math.random() * ABYSS_EQUIP_SKILLS.length)];
        equipSkill = { id: sk.id, name: sk.name, effect: JSON.parse(JSON.stringify(sk.effect)) };
    }
    var displayName = ABYSS_QUALITIES[quality] + '·' + equipName + (setIdx ? '(' + ABYSS_SET_NAMES[setIdx] + ')' : '') + (equipSkill ? '[' + equipSkill.name + ']' : '');
    var runeSlots = abyssRollRuneSlotCount();
    var gemSlots = abyssRollGemSlotCount();
    var runesArr = [];
    for (var rs = 0; rs < runeSlots; rs++) runesArr.push(null);
    var gemsArr = [];
    for (var gs = 0; gs < gemSlots; gs++) gemsArr.push(null);
    return {
        id: abyssGenId(), slot: slot, quality: quality, set: ABYSS_SET_NAMES[setIdx], equipLevel: equipLevel, level: 0, enchant: null,
        stats: base, name: displayName, equipSkill: equipSkill,
        runes: runesArr,
        gems: gemsArr
    };
}

function abyssCalcPlayerStats() {
    if (!abyssRun || !abyssRun.active) return null;
    var p = abyssRun.player;
    var t = abyssRun.tempStats;
    var hp = p.maxHp + (t.hp || 0), atk = p.atk + (t.atk || 0), def = p.def + (t.def || 0);
    var critRate = p.critRate + (t.critRate || 0), critDmg = p.critDmg + (t.critDmg || 0);
    var dodge = p.dodge + (t.dodge || 0), lifesteal = p.lifesteal + (t.lifesteal || 0), combo = p.combo + (t.combo || 0);
    var skillDmg = (t.skillDmg || 0);
    var reduceMonsterDef = (t.reduceMonsterDef || 0);
    var totalStr = 0, totalAgi = 0, totalInt = 0, totalSta = 0;
    var elementAtk = { metal: 0, wood: 0, water: 0, fire: 0, earth: 0 };
    var elementRes = { metal: 0, wood: 0, water: 0, fire: 0, earth: 0 };
    var setCount = {};
    for (var k in abyssRun.equipped) {
        var eq = abyssRun.equipped[k];
        if (!eq) continue;
        var s = eq.stats || {};
        var equipLv = eq.equipLevel != null ? eq.equipLevel : (eq.level || 0);
        var enhanceLv = eq.equipLevel != null ? (eq.level || 0) : 0;
        var baseLevelMult = 1 + equipLv * 0.2;
        var enhanceMult = 1 + enhanceLv * 0.05;
        var statMult = 1;
        if (eq.enchant && typeof eq.enchant === 'object' && eq.enchant.statMult) statMult = eq.enchant.statMult;
        else if (eq.enchant === true) statMult = 1.2;
        hp += Math.floor((s.hp || 0) * baseLevelMult * statMult * enhanceMult);
        atk += Math.floor((s.atk || 0) * baseLevelMult * statMult * enhanceMult);
        def += Math.floor((s.def || 0) * baseLevelMult * statMult * enhanceMult);
        critRate += (s.critRate || 0) * baseLevelMult * statMult * enhanceMult;
        critDmg += (s.critDmg || 0) * baseLevelMult * statMult * enhanceMult;
        dodge += (s.dodge || 0) * baseLevelMult * statMult * enhanceMult;
        lifesteal += (s.lifesteal || 0) * baseLevelMult * statMult * enhanceMult;
        combo += (s.combo || 0) * baseLevelMult * statMult * enhanceMult;
        skillDmg += (s.skillDmg || 0) * baseLevelMult * statMult * enhanceMult;
        totalStr += (s.str || 0) * baseLevelMult * statMult * enhanceMult;
        totalAgi += (s.agi || 0) * baseLevelMult * statMult * enhanceMult;
        totalInt += (s.int || 0) * baseLevelMult * statMult * enhanceMult;
        totalSta += (s.sta || 0) * baseLevelMult * statMult * enhanceMult;
        for (var ei = 0; ei < ABYSS_ELEMENTS.length; ei++) {
            var el = ABYSS_ELEMENTS[ei];
            elementAtk[el] += (s[el + 'Atk'] || 0) * baseLevelMult * statMult * enhanceMult;
            elementRes[el] += (s[el + 'Res'] || 0) * baseLevelMult * statMult * enhanceMult;
        }
        var lvMult = 1 + enhanceLv * 0.05;
        var skillMult = (eq.enchant && typeof eq.enchant === 'object' && eq.enchant.skillMult) ? eq.enchant.skillMult : 1;
        if (eq.equipSkill && eq.equipSkill.effect) {
            var eff = eq.equipSkill.effect;
            if (eff.hp) hp += Math.floor((eff.hp || 0) * lvMult * skillMult);
            if (eff.atk) atk += Math.floor((eff.atk || 0) * lvMult * skillMult);
            if (eff.def) def += Math.floor((eff.def || 0) * lvMult * skillMult);
            if (eff.critRate) critRate += (eff.critRate || 0) * lvMult * skillMult;
            if (eff.critDmg) critDmg += (eff.critDmg || 0) * lvMult * skillMult;
            if (eff.dodge) dodge += (eff.dodge || 0) * lvMult * skillMult;
            if (eff.lifesteal) lifesteal += (eff.lifesteal || 0) * lvMult * skillMult;
            if (eff.combo) combo += (eff.combo || 0) * lvMult * skillMult;
            if (eff.skillDmg) skillDmg += Math.floor((eff.skillDmg || 0) * lvMult * (1 + (skillMult - 1) * 0.5) * 1.5);
            if (eff.reduceMonsterDef) reduceMonsterDef += (eff.reduceMonsterDef || 0) * lvMult * skillMult;
        }
        if (eq.enchant && typeof eq.enchant === 'object' && eq.enchant.addedSkill && eq.enchant.addedSkill.effect) {
            var addEff = eq.enchant.addedSkill.effect;
            if (addEff.hp) hp += Math.floor((addEff.hp || 0) * lvMult);
            if (addEff.atk) atk += Math.floor((addEff.atk || 0) * lvMult);
            if (addEff.def) def += Math.floor((addEff.def || 0) * lvMult);
            if (addEff.critRate) critRate += (addEff.critRate || 0) * lvMult;
            if (addEff.critDmg) critDmg += (addEff.critDmg || 0) * lvMult;
            if (addEff.dodge) dodge += (addEff.dodge || 0) * lvMult;
            if (addEff.lifesteal) lifesteal += (addEff.lifesteal || 0) * lvMult;
            if (addEff.combo) combo += (addEff.combo || 0) * lvMult;
            if (addEff.skillDmg) skillDmg += Math.floor((addEff.skillDmg || 0) * lvMult * 1.5 * 0.5);
            if (addEff.reduceMonsterDef) reduceMonsterDef += (addEff.reduceMonsterDef || 0) * lvMult;
        }
        var runes = eq.runes || [];
        for (var ri = 0; ri < runes.length; ri++) {
            var runeId = runes[ri];
            if (!runeId) continue;
            var rune = getAbyssRuneById(runeId);
            if (rune && rune.effect) {
                var re = rune.effect;
                if (re.hp) hp += Math.floor(re.hp * enhanceMult);
                if (re.atk) atk += Math.floor(re.atk * enhanceMult);
                if (re.def) def += Math.floor(re.def * enhanceMult);
                if (re.critRate) critRate += (re.critRate || 0) * enhanceMult;
                if (re.critDmg) critDmg += (re.critDmg || 0) * enhanceMult;
                if (re.dodge) dodge += (re.dodge || 0) * enhanceMult;
                if (re.lifesteal) lifesteal += (re.lifesteal || 0) * enhanceMult;
                if (re.combo) combo += (re.combo || 0) * enhanceMult;
                if (re.skillDmg) skillDmg += (re.skillDmg || 0) * enhanceMult;
                if (re.reduceMonsterDef) reduceMonsterDef += (re.reduceMonsterDef || 0) * enhanceMult;
                if (re.str) totalStr += (re.str || 0) * enhanceMult;
                if (re.agi) totalAgi += (re.agi || 0) * enhanceMult;
                if (re.int) totalInt += (re.int || 0) * enhanceMult;
                if (re.sta) totalSta += (re.sta || 0) * enhanceMult;
                for (var rei = 0; rei < ABYSS_ELEMENTS.length; rei++) {
                    var el = ABYSS_ELEMENTS[rei];
                    if (re[el + 'Atk']) elementAtk[el] += (re[el + 'Atk'] || 0) * enhanceMult;
                }
            }
        }
        var gems = eq.gems || [];
        for (var gi = 0; gi < gems.length; gi++) {
            var gemId = gems[gi];
            if (!gemId) continue;
            var gem = getAbyssGemById(gemId);
            if (gem && gem.effect) {
                var ge = gem.effect;
                if (ge.hp) hp += Math.floor(ge.hp * enhanceMult);
                if (ge.atk) atk += Math.floor(ge.atk * enhanceMult);
                if (ge.def) def += Math.floor(ge.def * enhanceMult);
                if (ge.critRate) critRate += (ge.critRate || 0) * enhanceMult;
                if (ge.critDmg) critDmg += (ge.critDmg || 0) * enhanceMult;
                if (ge.dodge) dodge += (ge.dodge || 0) * enhanceMult;
                if (ge.lifesteal) lifesteal += (ge.lifesteal || 0) * enhanceMult;
                if (ge.combo) combo += (ge.combo || 0) * enhanceMult;
                if (ge.skillDmg) skillDmg += (ge.skillDmg || 0) * enhanceMult;
                if (ge.reduceMonsterDef) reduceMonsterDef += (ge.reduceMonsterDef || 0) * enhanceMult;
                if (ge.str) totalStr += (ge.str || 0) * enhanceMult;
                if (ge.agi) totalAgi += (ge.agi || 0) * enhanceMult;
                if (ge.int) totalInt += (ge.int || 0) * enhanceMult;
                if (ge.sta) totalSta += (ge.sta || 0) * enhanceMult;
            }
        }
        if (eq.set) setCount[eq.set] = (setCount[eq.set] || 0) + 1;
    }
    if (setCount['勇者'] >= 2) { atk += 40; }
    if (setCount['勇者'] >= 4) { atk += 60; critRate += 10; }
    if (setCount['暗影'] >= 2) { dodge += 10; }
    if (setCount['暗影'] >= 4) { critDmg += 55; }
    if (setCount['龙心'] >= 2) { hp += 400; }
    if (setCount['龙心'] >= 4) { lifesteal += 10; hp += 300; }
    if (setCount['虚空'] >= 2) { critRate += 10; }
    if (setCount['虚空'] >= 4) { skillDmg += 45; critRate += 5; }
    if (setCount['永恒'] >= 2) { def += 60; }
    if (setCount['永恒'] >= 4) { hp += 1000; def += 40; }
    if (setCount['修罗'] >= 2) { atk += 35; critDmg += 20; }
    if (setCount['修罗'] >= 4) { atk += 50; critDmg += 40; lifesteal += 5; }
    if (setCount['天罡'] >= 2) { def += 50; hp += 250; }
    if (setCount['天罡'] >= 4) { def += 120; hp += 700; }
    if (setCount['幽冥'] >= 2) { dodge += 8; skillDmg += 15; }
    if (setCount['幽冥'] >= 4) { dodge += 12; skillDmg += 35; critRate += 6; }
    if (setCount['神罚'] >= 2) { skillDmg += 30; critRate += 8; }
    if (setCount['神罚'] >= 4) { skillDmg += 50; critDmg += 40; }
    if (setCount['破灭'] >= 2) { atk += 30; reduceMonsterDef += 8; }
    if (setCount['破灭'] >= 4) { atk += 55; reduceMonsterDef += 15; combo += 8; }
    var lv = (abyssRun.runLevel || 0);
    hp += lv * 25;
    atk += lv * 3;
    def += lv * 2;
    if (abyssRun.buffs) {
        if (abyssRun.buffs.atkPct != null) atk = Math.floor(atk * (1 + abyssRun.buffs.atkPct / 100));
        if (abyssRun.buffs.hpPct != null) hp = Math.floor(hp * (1 + abyssRun.buffs.hpPct / 100));
        if (abyssRun.buffs.defPct != null) def = Math.floor(def * (1 + abyssRun.buffs.defPct / 100));
        if (abyssRun.buffs.lifestealPct != null) lifesteal += abyssRun.buffs.lifestealPct;
        if (abyssRun.buffs.critRatePct != null) critRate += abyssRun.buffs.critRatePct;
        if (abyssRun.buffs.critDmgPct != null) critDmg += abyssRun.buffs.critDmgPct;
        if (abyssRun.buffs.dodgePct != null) dodge += abyssRun.buffs.dodgePct;
        if (abyssRun.buffs.critRate != null) critRate += abyssRun.buffs.critRate;
        if (abyssRun.buffs.critDmg != null) critDmg += abyssRun.buffs.critDmg;
        if (abyssRun.buffs.skillDmg != null) skillDmg += abyssRun.buffs.skillDmg;
    }
    if (abyssRun.curseRounds > 0 && (abyssRun.curseEffects || abyssRun.rewardEffects)) {
        var c = abyssRun.curseEffects || {};
        var r = abyssRun.rewardEffects || {};
        var atkPct = (c.atkPct || 0) + (r.atkPct || 0);
        var hpPct = (c.hpPct || 0) + (r.hpPct || 0);
        var defPct = (c.defPct || 0) + (r.defPct || 0);
        if (atkPct) atk = Math.floor(atk * (1 + atkPct / 100));
        if (hpPct) hp = Math.floor(hp * (1 + hpPct / 100));
        if (defPct) def = Math.floor(def * (1 + defPct / 100));
        lifesteal += (c.lifestealPct || 0) + (r.lifestealPct || 0);
        critRate += (c.critRatePct || 0) + (r.critRatePct || 0);
        critDmg += (c.critDmgPct || 0) + (r.critDmgPct || 0);
        dodge += (c.dodgePct || 0) + (r.dodgePct || 0);
    }
    if (abyssRun.trialId === 'lowHp' && abyssRun.trialRoundsLeft > 0) hp = Math.floor(hp * 0.75);
    critRate += lv * 0.3;
    critDmg += lv * 1;
    dodge += lv * 0.2;
    lifesteal += lv * 0.1;
    skillDmg += lv * 0.5;
    var cls = ABYSS_CLASSES.find(function(x) { return x.id === (abyssRun.playerClass || 'warrior'); });
    var strAtk = Math.floor(totalStr * 2);
    if (cls && cls.strConversionMult) strAtk = Math.floor(strAtk * cls.strConversionMult);
    var agiDodge = totalAgi * 0.3, agiCrit = totalAgi * 0.2, agiCombo = totalAgi * 0.2;
    if (cls && cls.agiMult) { agiDodge *= cls.agiMult; agiCrit *= cls.agiMult; agiCombo *= cls.agiMult; }
    var intSkill = totalInt * 0.5;
    if (cls && cls.intToSkillDmgMult) intSkill *= cls.intToSkillDmgMult;
    var staHp = Math.floor(totalSta * 8), staDef = totalSta * 0.5;
    if (cls && cls.staConversionMult) { staHp = Math.floor(staHp * cls.staConversionMult); staDef *= cls.staConversionMult; }
    atk += strAtk;
    dodge += agiDodge;
    critRate += agiCrit;
    combo += agiCombo;
    skillDmg += intSkill;
    hp += staHp;
    def += Math.floor(staDef);
    var talents = abyssRun.talents || {};
    for (var ti = 0; ti < ABYSS_TALENTS.length; ti++) {
        var tal = ABYSS_TALENTS[ti];
        var lvl = talents[tal.id] || 0;
        if (lvl <= 0 || !tal.effect) continue;
        var eff = tal.effect;
        if (eff.hp) hp += (eff.hp || 0) * lvl;
        if (eff.atk) atk += (eff.atk || 0) * lvl;
        if (eff.def) def += (eff.def || 0) * lvl;
        if (eff.critRate) critRate += (eff.critRate || 0) * lvl;
        if (eff.critDmg) critDmg += (eff.critDmg || 0) * lvl;
        if (eff.dodge) dodge += (eff.dodge || 0) * lvl;
        if (eff.lifesteal) lifesteal += (eff.lifesteal || 0) * lvl;
        if (eff.combo) combo += (eff.combo || 0) * lvl;
        if (eff.skillDmg) skillDmg += (eff.skillDmg || 0) * lvl;
        if (eff.reduceMonsterDef) reduceMonsterDef += (eff.reduceMonsterDef || 0) * lvl;
    }
    var runLv = abyssRun.runLevel != null ? abyssRun.runLevel : Math.floor((abyssRun.exp || 0) / 100);
    var maxMp = abyssMaxMpForLevel(runLv);
    var zhuan = abyssZhuan(runLv);
    /* 出战宠物被动：给玩家增加攻击、防御、体力、魔法值、吸血、爆伤、技能加成、闪避、五行之力（多只出战宠物叠加） */
    var deployedPets = abyssGetDeployedPets();
    for (var dpi = 0; dpi < deployedPets.length; dpi++) {
        var dp = deployedPets[dpi];
        if (!dp || !dp.skills || !dp.skills.length) continue;
        for (var pi = 0; pi < dp.skills.length; pi++) {
            var sk = null;
            for (var sj = 0; sj < ABYSS_PET_SKILLS.length; sj++) {
                if (ABYSS_PET_SKILLS[sj].id === dp.skills[pi].id) { sk = ABYSS_PET_SKILLS[sj]; break; }
            }
            if (sk && sk.playerBonus) {
                var pb = sk.playerBonus;
                if (pb.atk) atk += pb.atk;
                if (pb.def) def += pb.def;
                if (pb.hp) hp += pb.hp;
                if (pb.maxMp) maxMp += pb.maxMp;
                if (pb.critRate) critRate += pb.critRate;
                if (pb.critDmg) critDmg += pb.critDmg;
                if (pb.dodge) dodge += pb.dodge;
                if (pb.lifesteal) lifesteal += pb.lifesteal;
                if (pb.skillDmg) skillDmg += pb.skillDmg;
                if (pb.elementAtk && typeof elementAtk === 'object') {
                    for (var ei = 0; ei < ABYSS_ELEMENTS.length; ei++) {
                        var el = ABYSS_ELEMENTS[ei];
                        elementAtk[el] = (elementAtk[el] || 0) + pb.elementAtk;
                    }
                }
            }
        }
    }
    return { hp: hp, maxHp: hp, atk: atk, def: def, critRate: Math.min(100, critRate), critDmg: critDmg, dodge: Math.min(70, dodge), lifesteal: lifesteal, combo: combo, skillDmg: skillDmg, reduceMonsterDef: reduceMonsterDef, str: Math.floor(totalStr), agi: Math.floor(totalAgi), int: Math.floor(totalInt), sta: Math.floor(totalSta), elementAtk: elementAtk, elementRes: elementRes, maxMp: maxMp, zhuan: zhuan };
}

var ABYSS_NORMAL_MONSTER_NAMES = [
    '深渊守卫', '暗影猎手', '腐化战士', '虚空行者', '噬魂兽', '裂魂者', '幽影刺客', '堕落骑士', '诅咒法师',
    '血爪', '骨魔', '影魔', '怨灵', '深渊蛛魔', '暗裔剑士', '邪眼', '腐尸', '幽魂', '魔化兽', '裂渊兽',
    '虚空猎犬', '暗影仆从', '堕落祭司', '诅咒傀儡', '噬骨者', '幽暗守卫', '深渊蠕虫', '影刃', '魔焰兽',
    '亡魂', '暗蚀兽', '裂心魔', '虚空潜行者', '腐化法师', '血渊兽', '幽影狼', '诅咒剑士', '深渊甲虫', '噬血者',
    '骨灵', '影杀者', '怨念体', '堕落战士', '魔瞳', '虚空幽魂', '腐尸犬', '暗裔法师', '裂魂蛛', '深渊猎手',
    '血魔', '幽暗刺客', '诅咒之爪', '噬魂蛛', '骨战士', '影缚者', '怨毒兽', '堕落猎犬', '魔化剑士', '虚空兽',
    '腐化甲虫', '血渊守卫', '幽影蛇', '诅咒兽', '深渊毒蛛', '噬骨蛛', '骨龙仆从', '影魔仆从', '怨灵法师', '暗裔兽',
    '裂渊蛛', '虚空魔虫', '腐尸战士', '血爪兽', '幽魂法师', '魔焰蛛', '深渊毒兽', '噬魂狼', '骨魔战士', '影刃兽',
    '怨念蛛', '堕落毒蛛', '魔化蛛', '虚空毒虫', '腐化毒兽', '血渊蛛', '幽暗毒兽', '诅咒毒蛛', '深渊魔蛛', '噬骨毒兽',
    '亡魂战士', '暗蚀蛛', '裂心毒兽', '虚空毒蛛', '腐化狼', '血渊狼', '幽影毒兽', '诅咒狼', '深渊狼', '噬血狼',
    '骨灵兽', '影杀蛛', '怨念狼', '堕落狼', '魔瞳兽', '虚空狼', '腐尸蛛', '暗裔狼', '裂魂狼', '深渊毒狼',
    '血魔蛛', '幽暗狼', '诅咒之蛛', '噬魂毒蛛', '骨战士蛛', '影缚蛛', '怨毒蛛', '堕落毒兽', '魔化狼', '虚空毒狼',
    '腐化狼兽', '血渊毒兽', '幽影狼兽', '诅咒毒兽', '深渊狼兽', '噬骨狼', '骨龙兽', '影魔兽', '怨灵兽', '暗裔毒兽',
    '裂渊狼', '虚空魔狼', '腐尸毒兽', '血爪蛛', '幽魂狼', '魔焰狼', '深渊魔狼', '噬魂毒兽', '骨魔蛛', '影刃蛛',
    '怨念毒兽', '堕落魔狼', '魔化毒兽', '虚空怨灵', '腐化怨灵', '血渊怨灵', '幽暗怨灵', '诅咒怨灵', '深渊怨灵', '噬骨怨灵'
];

// 普通怪物前缀词条（共150个）：影响名称与属性
var ABYSS_MONSTER_PREFIXES = [
    { name: '强壮的', hpMult: 1.12, atkMult: 1.18, defMult: 1.0 },
    { name: '凶猛的', hpMult: 0.95, atkMult: 1.22, defMult: 0.92 },
    { name: '坚韧的', hpMult: 1.15, atkMult: 0.95, defMult: 1.25 },
    { name: '虚弱的', hpMult: 0.82, atkMult: 0.88, defMult: 0.85 },
    { name: '分裂的', hpMult: 0.9, atkMult: 1.05, defMult: 0.9, multiHit: 0.12 },
    { name: '吸血的', hpMult: 1.0, atkMult: 1.05, defMult: 1.0, lifesteal: 3 },
    { name: '迅捷的', hpMult: 0.92, atkMult: 1.08, defMult: 0.95, dodge: 4 },
    { name: '笨重的', hpMult: 1.2, atkMult: 0.9, defMult: 1.15, dodge: -3 },
    { name: '暴虐的', hpMult: 1.0, atkMult: 1.2, defMult: 0.9, critRate: 6 },
    { name: '厚皮的', hpMult: 1.18, atkMult: 0.92, defMult: 1.2 },
    { name: '狂化的', hpMult: 0.88, atkMult: 1.28, defMult: 0.88 },
    { name: '腐朽的', hpMult: 0.78, atkMult: 0.92, defMult: 0.8 },
    { name: '嗜血的', hpMult: 1.05, atkMult: 1.15, defMult: 0.95, lifesteal: 4 },
    { name: '石肤的', hpMult: 1.1, atkMult: 0.9, defMult: 1.35 },
    { name: '灵巧的', hpMult: 0.9, atkMult: 1.1, defMult: 0.9, dodge: 6 },
    { name: '重甲的', hpMult: 1.22, atkMult: 0.88, defMult: 1.3 },
    { name: '尖刺的', hpMult: 1.0, atkMult: 1.05, defMult: 1.1, thornsRate: 0.08 },
    { name: '剧毒的', hpMult: 0.95, atkMult: 1.15, defMult: 0.95, venomBonus: 0.1 },
    { name: '燃烧的', hpMult: 0.92, atkMult: 1.18, defMult: 0.9 },
    { name: '冰霜的', hpMult: 1.0, atkMult: 1.05, defMult: 1.08 },
    { name: '暗影的', hpMult: 0.95, atkMult: 1.12, defMult: 0.98, dodge: 3 },
    { name: '狂暴的', hpMult: 1.0, atkMult: 1.25, defMult: 0.85 },
    { name: '再生的', hpMult: 1.2, atkMult: 0.9, defMult: 1.0 },
    { name: '脆弱的', hpMult: 0.75, atkMult: 1.0, defMult: 0.75 },
    { name: '巨力的', hpMult: 1.08, atkMult: 1.28, defMult: 0.95 },
    { name: '铁壁的', hpMult: 1.15, atkMult: 0.85, defMult: 1.4 },
    { name: '双生的', hpMult: 0.85, atkMult: 1.15, defMult: 0.9, multiHit: 0.15 },
    { name: '诅咒的', hpMult: 0.9, atkMult: 1.1, defMult: 0.92 },
    { name: '邪能的', hpMult: 1.05, atkMult: 1.18, defMult: 0.95 },
    { name: '腐化的', hpMult: 0.95, atkMult: 1.12, defMult: 0.9 },
    { name: '精英的', hpMult: 1.2, atkMult: 1.15, defMult: 1.1 },
    { name: '变异的', hpMult: 1.1, atkMult: 1.12, defMult: 1.05 },
    { name: '古老的', hpMult: 1.25, atkMult: 1.05, defMult: 1.15 },
    { name: '幼体的', hpMult: 0.7, atkMult: 0.8, defMult: 0.75 },
    { name: '魁梧的', hpMult: 1.35, atkMult: 1.1, defMult: 1.1 },
    { name: '瘦小的', hpMult: 0.65, atkMult: 0.95, defMult: 0.7 },
    { name: '狡诈的', hpMult: 0.9, atkMult: 1.1, defMult: 0.88, critRate: 8 },
    { name: '无畏的', hpMult: 1.1, atkMult: 1.15, defMult: 1.05 },
    { name: '流亡的', hpMult: 0.92, atkMult: 1.18, defMult: 0.9 },
    { name: '野性的', hpMult: 1.05, atkMult: 1.2, defMult: 0.92 },
    { name: '护甲的', hpMult: 1.08, atkMult: 0.9, defMult: 1.28 },
    { name: '锋利的', hpMult: 0.95, atkMult: 1.22, defMult: 0.9 },
    { name: '顽强的', hpMult: 1.22, atkMult: 0.95, defMult: 1.18 },
    { name: '凶残的', hpMult: 0.98, atkMult: 1.28, defMult: 0.88 },
    { name: '幽灵的', hpMult: 0.85, atkMult: 1.08, defMult: 0.82, dodge: 8 },
    { name: '重击的', hpMult: 1.0, atkMult: 1.2, defMult: 1.0, heavyChance: 0.15 },
    { name: '连打的', hpMult: 0.92, atkMult: 1.1, defMult: 0.9, multiHit: 0.18 },
    { name: '破甲的', hpMult: 0.95, atkMult: 1.15, defMult: 0.95, armorBreak: 0.12 },
    { name: '嗜战的', hpMult: 1.05, atkMult: 1.18, defMult: 0.95, lifesteal: 2 },
    { name: '威压的', hpMult: 1.08, atkMult: 1.05, defMult: 1.15 },
    { name: '不死的', hpMult: 1.15, atkMult: 0.95, defMult: 1.1 },
    /* ========== 新增100个前缀词条 ========== */
    { name: '嗜杀的', hpMult: 0.95, atkMult: 1.2, defMult: 0.9, critRate: 5 },
    { name: '龟甲的', hpMult: 1.2, atkMult: 0.82, defMult: 1.38 },
    { name: '疾风的', hpMult: 0.88, atkMult: 1.12, defMult: 0.88, dodge: 5 },
    { name: '枯朽的', hpMult: 0.72, atkMult: 0.95, defMult: 0.78 },
    { name: '血怒的', hpMult: 1.02, atkMult: 1.22, defMult: 0.88, lifesteal: 2 },
    { name: '岩壳的', hpMult: 1.18, atkMult: 0.88, defMult: 1.32 },
    { name: '鬼步的', hpMult: 0.85, atkMult: 1.05, defMult: 0.85, dodge: 7 },
    { name: '铁骨的', hpMult: 1.25, atkMult: 0.9, defMult: 1.22 },
    { name: '碎颅的', hpMult: 0.98, atkMult: 1.26, defMult: 0.9 },
    { name: '毒腺的', hpMult: 0.92, atkMult: 1.12, defMult: 0.92 },
    { name: '焰心的', hpMult: 0.9, atkMult: 1.2, defMult: 0.88 },
    { name: '霜甲的', hpMult: 1.05, atkMult: 0.95, defMult: 1.2 },
    { name: '幽魂的', hpMult: 0.8, atkMult: 1.1, defMult: 0.8, dodge: 6 },
    { name: '疯魔的', hpMult: 0.9, atkMult: 1.3, defMult: 0.85 },
    { name: '自愈的', hpMult: 1.22, atkMult: 0.92, defMult: 1.05 },
    { name: '薄血的', hpMult: 0.68, atkMult: 1.05, defMult: 0.82 },
    { name: '开山的', hpMult: 1.05, atkMult: 1.3, defMult: 0.95 },
    { name: '铜墙的', hpMult: 1.15, atkMult: 0.8, defMult: 1.45 },
    { name: '三连的', hpMult: 0.88, atkMult: 1.12, defMult: 0.88, multiHit: 0.2 },
    { name: '蚀骨的', hpMult: 0.9, atkMult: 1.15, defMult: 0.88 },
    { name: '魔焰的', hpMult: 0.95, atkMult: 1.2, defMult: 0.9 },
    { name: '寒冰的', hpMult: 1.0, atkMult: 1.08, defMult: 1.12 },
    { name: '潜行的', hpMult: 0.88, atkMult: 1.15, defMult: 0.85, dodge: 5 },
    { name: '癫狂的', hpMult: 0.85, atkMult: 1.32, defMult: 0.82 },
    { name: '回春的', hpMult: 1.28, atkMult: 0.88, defMult: 1.0 },
    { name: '纸糊的', hpMult: 0.6, atkMult: 1.0, defMult: 0.7 },
    { name: '崩山的', hpMult: 1.0, atkMult: 1.28, defMult: 0.95 },
    { name: '钢甲的', hpMult: 1.2, atkMult: 0.85, defMult: 1.35 },
    { name: '乱舞的', hpMult: 0.9, atkMult: 1.08, defMult: 0.9, multiHit: 0.22 },
    { name: '溃烂的', hpMult: 0.78, atkMult: 1.0, defMult: 0.8 },
    { name: '炼狱的', hpMult: 0.92, atkMult: 1.22, defMult: 0.88 },
    { name: '极寒的', hpMult: 1.02, atkMult: 1.05, defMult: 1.15 },
    { name: '幻影的', hpMult: 0.82, atkMult: 1.1, defMult: 0.8, dodge: 9 },
    { name: '入魔的', hpMult: 0.88, atkMult: 1.28, defMult: 0.85 },
    { name: '不息的', hpMult: 1.25, atkMult: 0.9, defMult: 1.08 },
    { name: '易碎的', hpMult: 0.58, atkMult: 0.98, defMult: 0.68 },
    { name: '裂地的', hpMult: 1.02, atkMult: 1.26, defMult: 0.98 },
    { name: '金钟的', hpMult: 1.22, atkMult: 0.82, defMult: 1.4 },
    { name: '疾打的', hpMult: 0.86, atkMult: 1.15, defMult: 0.88, multiHit: 0.18 },
    { name: '噬魂的', hpMult: 0.92, atkMult: 1.18, defMult: 0.9 },
    { name: '邪火的', hpMult: 0.95, atkMult: 1.22, defMult: 0.92 },
    { name: '凛冬的', hpMult: 1.05, atkMult: 1.0, defMult: 1.18 },
    { name: '无踪的', hpMult: 0.8, atkMult: 1.12, defMult: 0.78, dodge: 8 },
    { name: '入煞的', hpMult: 0.9, atkMult: 1.3, defMult: 0.88 },
    { name: '续命的', hpMult: 1.3, atkMult: 0.88, defMult: 1.05 },
    { name: '一碰就碎的', hpMult: 0.52, atkMult: 0.95, defMult: 0.62 },
    { name: '破军的', hpMult: 1.0, atkMult: 1.3, defMult: 0.92 },
    { name: '玄铁的', hpMult: 1.18, atkMult: 0.85, defMult: 1.38 },
    { name: '连环的', hpMult: 0.88, atkMult: 1.1, defMult: 0.9, multiHit: 0.25 },
    { name: '蚀心的', hpMult: 0.88, atkMult: 1.15, defMult: 0.88 },
    { name: '业火的', hpMult: 0.9, atkMult: 1.25, defMult: 0.88 },
    { name: '永冻的', hpMult: 1.08, atkMult: 0.98, defMult: 1.22 },
    { name: '无形的', hpMult: 0.78, atkMult: 1.08, defMult: 0.75, dodge: 10 },
    { name: '煞化的', hpMult: 0.92, atkMult: 1.26, defMult: 0.9 },
    { name: '长生的', hpMult: 1.32, atkMult: 0.85, defMult: 1.1 },
    { name: '豆腐的', hpMult: 0.5, atkMult: 0.9, defMult: 0.6 },
    { name: '斩铁的', hpMult: 0.98, atkMult: 1.28, defMult: 0.95 },
    { name: '龙鳞的', hpMult: 1.2, atkMult: 0.88, defMult: 1.35 },
    { name: '多段的', hpMult: 0.9, atkMult: 1.05, defMult: 0.88, multiHit: 0.28 },
    { name: '摄魂的', hpMult: 0.9, atkMult: 1.2, defMult: 0.9 },
    { name: '魔息的', hpMult: 0.95, atkMult: 1.22, defMult: 0.92 },
    { name: '冰封的', hpMult: 1.1, atkMult: 0.95, defMult: 1.25 },
    { name: '遁形的', hpMult: 0.75, atkMult: 1.1, defMult: 0.72, dodge: 9 },
    { name: '狂煞的', hpMult: 0.88, atkMult: 1.32, defMult: 0.85 },
    { name: '不灭的', hpMult: 1.28, atkMult: 0.9, defMult: 1.12 },
    { name: '泡沫的', hpMult: 0.48, atkMult: 0.88, defMult: 0.58 },
    { name: '碎甲的', hpMult: 0.95, atkMult: 1.25, defMult: 0.92 },
    { name: '神盾的', hpMult: 1.22, atkMult: 0.82, defMult: 1.42 },
    { name: '五连的', hpMult: 0.82, atkMult: 1.08, defMult: 0.85, multiHit: 0.3 },
    { name: '夺魄的', hpMult: 0.88, atkMult: 1.18, defMult: 0.88 },
    { name: '冥炎的', hpMult: 0.92, atkMult: 1.25, defMult: 0.9 },
    { name: '霜魂的', hpMult: 1.05, atkMult: 1.02, defMult: 1.2 },
    { name: '隐身的', hpMult: 0.72, atkMult: 1.12, defMult: 0.7, dodge: 11 },
    { name: '魔煞的', hpMult: 0.9, atkMult: 1.28, defMult: 0.88 },
    { name: '永生的', hpMult: 1.35, atkMult: 0.88, defMult: 1.15 },
    { name: '朽木的', hpMult: 0.45, atkMult: 0.85, defMult: 0.55 },
    { name: '贯甲的', hpMult: 0.96, atkMult: 1.28, defMult: 0.92 },
    { name: '圣盾的', hpMult: 1.25, atkMult: 0.8, defMult: 1.45 },
    { name: '暴风的', hpMult: 0.84, atkMult: 1.12, defMult: 0.86, multiHit: 0.26 },
    { name: '勾魂的', hpMult: 0.86, atkMult: 1.22, defMult: 0.88 },
    { name: '焚天的', hpMult: 0.9, atkMult: 1.28, defMult: 0.88 },
    { name: '冰魄的', hpMult: 1.08, atkMult: 0.98, defMult: 1.28 },
    { name: '鬼隐的', hpMult: 0.7, atkMult: 1.08, defMult: 0.68, dodge: 12 },
    { name: '灭世的', hpMult: 0.86, atkMult: 1.35, defMult: 0.85 },
    { name: '涅槃的', hpMult: 1.32, atkMult: 0.9, defMult: 1.18 },
    { name: '朽败的', hpMult: 0.42, atkMult: 0.82, defMult: 0.52 },
    { name: '破城的', hpMult: 0.98, atkMult: 1.3, defMult: 0.9 },
    { name: '天罡的', hpMult: 1.28, atkMult: 0.82, defMult: 1.42 },
    { name: '骤雨的', hpMult: 0.82, atkMult: 1.1, defMult: 0.84, multiHit: 0.28 },
    { name: '索命的', hpMult: 0.85, atkMult: 1.25, defMult: 0.86 },
    { name: '红莲的', hpMult: 0.88, atkMult: 1.3, defMult: 0.86 },
    { name: '玄冰的', hpMult: 1.12, atkMult: 0.95, defMult: 1.3 },
    { name: '化风的', hpMult: 0.68, atkMult: 1.1, defMult: 0.65, dodge: 13 },
    { name: '灭道的', hpMult: 0.88, atkMult: 1.32, defMult: 0.86 },
    { name: '不死的', hpMult: 1.3, atkMult: 0.92, defMult: 1.2 },
    { name: '风化的', hpMult: 0.4, atkMult: 0.8, defMult: 0.5 },
    { name: '弑神的', hpMult: 0.96, atkMult: 1.32, defMult: 0.9 },
    { name: '金刚的', hpMult: 1.3, atkMult: 0.8, defMult: 1.48 },
    { name: '星落的', hpMult: 0.8, atkMult: 1.15, defMult: 0.82, multiHit: 0.3 },
    { name: '追魂的', hpMult: 0.84, atkMult: 1.28, defMult: 0.85 },
    { name: '天火的', hpMult: 0.86, atkMult: 1.32, defMult: 0.84 },
    { name: '万载寒冰的', hpMult: 1.15, atkMult: 0.92, defMult: 1.32 },
    { name: '虚无的', hpMult: 0.65, atkMult: 1.08, defMult: 0.62, dodge: 14 },
    { name: '劫灭的', hpMult: 0.85, atkMult: 1.35, defMult: 0.84 },
    { name: '不朽的', hpMult: 1.28, atkMult: 0.92, defMult: 1.22 },
    { name: '尘埃的', hpMult: 0.38, atkMult: 0.78, defMult: 0.48 },
    { name: '崩天的', hpMult: 0.94, atkMult: 1.35, defMult: 0.88 },
    { name: '不破的', hpMult: 1.32, atkMult: 0.78, defMult: 1.5 },
    { name: '流星雨的', hpMult: 0.78, atkMult: 1.12, defMult: 0.8, multiHit: 0.32 },
    /* ========== 福利怪前缀（属性-30%，经验与货币×2） ========== */
    { name: '【福利】', hpMult: 0.7, atkMult: 0.7, defMult: 0.7, welfareReward: 2 },
    { name: '【送宝】', hpMult: 0.7, atkMult: 0.7, defMult: 0.7, welfareReward: 2 },
    { name: '【福星】', hpMult: 0.7, atkMult: 0.7, defMult: 0.7, welfareReward: 2 },
    { name: '【财神】', hpMult: 0.7, atkMult: 0.7, defMult: 0.7, welfareReward: 2 },
    { name: '【好运】', hpMult: 0.7, atkMult: 0.7, defMult: 0.7, welfareReward: 2 }
];

var ABYSS_BOSS_NAMES = [
    '灭世魔尊', '深渊主宰', '混沌领主', '虚空君王', '噬界者', '永恒梦魇', '破灭天尊', '万劫魔君', '寂灭帝尊',
    '葬天者', '湮灭之瞳', '深渊帝君', '混沌魔神', '虚空吞噬者', '永劫魔皇', '崩界尊者', '弑神者', '无间狱主',
    '诸界毁灭者', '深渊大君', '虚空暴君', '终焉魔神', '灭道天尊', '噬星之主', '永夜君王'
];

var ABYSS_PET_SKILLS = [
    { id: 'petCombo', name: '连击', chance: 0.2, multi: 2 },
    { id: 'petCrit', name: '必杀', critRate: 15, critDmg: 50 },
    { id: 'petLifesteal', name: '吸血', rate: 0.1 },
    { id: 'petStrong', name: '强力', atkBonus: 0.15 },
    { id: 'petDef', name: '防御', defBonus: 0.2 },
    { id: 'petBless', name: '神佑', reviveChance: 0.1 },
    { id: 'petSneak', name: '偷袭', dmgBonus: 0.1 },
    { id: 'petBreak', name: '破防', reduceDef: 10 },
    { id: 'petRage', name: '狂暴', atkBonus: 0.25, defPenalty: 0.1 },
    { id: 'petSwift', name: '敏捷', speedBonus: 0.2 },
    { id: 'petRebound', name: '反震', reboundChance: 0.2, reboundPct: 0.3 },
    { id: 'petRegen', name: '再生', regenPct: 0.05 },
    { id: 'petMeditate', name: '冥思', regenPct: 0.08 },
    { id: 'petWisdom', name: '慧根', dmgBonus: 0.08 },
    { id: 'petGhost', name: '驱鬼', dmgBonus: 0.2 },
    { id: 'petSoul', name: '鬼魂', reviveChance: 0.15 },
    { id: 'petMiracle', name: '神迹', defBonus: 0.15 },
    { id: 'petFocus', name: '精神集中', critRate: 10, defBonus: 0.1 },
    { id: 'petLucky', name: '幸运', critRate: 20, critDmg: 30 },
    { id: 'petParry', name: '招架', defBonus: 0.25 },
    { id: 'petEternal', name: '永恒', defBonus: 0.12, atkBonus: 0.05 },
    { id: 'petPoison', name: '毒', dmgBonus: 0.12 },
    { id: 'petFlame', name: '烈火', dmgBonus: 0.18 },
    { id: 'petWaterAbs', name: '水吸', defBonus: 0.08 },
    { id: 'petThunderAbs', name: '雷吸', defBonus: 0.08 },
    { id: 'petEarthAbs', name: '土吸', defBonus: 0.08 },
    { id: 'petFireAbs', name: '火吸', defBonus: 0.08 },
    { id: 'petFly', name: '飞行', dmgBonus: 0.1, speedBonus: 0.15 },
    { id: 'petNight', name: '夜战', atkBonus: 0.2 },
    { id: 'petSense', name: '感知', dmgBonus: 0.15 },
    { id: 'petBerserk', name: '舍身击', atkBonus: 0.3, defPenalty: 0.15 },
    { id: 'petAdvCombo', name: '高级连击', chance: 0.35, multi: 2.5 },
    { id: 'petAdvCrit', name: '高级必杀', critRate: 25, critDmg: 80 },
    { id: 'petAdvStrong', name: '高级强力', atkBonus: 0.28 },
    { id: 'petAdvDef', name: '高级防御', defBonus: 0.35 },
    { id: 'petAdvBless', name: '高级神佑', reviveChance: 0.2 },
    { id: 'petAdvSneak', name: '高级偷袭', dmgBonus: 0.2 },
    { id: 'petAdvLifesteal', name: '高级吸血', rate: 0.2 },
    { id: 'petAdvRebound', name: '高级反震', reboundChance: 0.35, reboundPct: 0.4 },
    { id: 'petAdvFly', name: '高级飞行', dmgBonus: 0.2, speedBonus: 0.25 },
    { id: 'petAdvNight', name: '高级夜战', atkBonus: 0.35 },
    { id: 'petAdvSense', name: '高级感知', dmgBonus: 0.25 },
    { id: 'petAdvGhost', name: '高级驱鬼', dmgBonus: 0.35 },
    { id: 'petAdvLucky', name: '高级幸运', critRate: 30, critDmg: 50 },
    { id: 'petAdvParry', name: '高级招架', defBonus: 0.4 },
    { id: 'petAdvPoison', name: '高级毒', dmgBonus: 0.22 },
    { id: 'petAdvFlame', name: '高级烈火', dmgBonus: 0.3 },
    { id: 'petAdvFocus', name: '高级精神集中', critRate: 18, defBonus: 0.2 },
    { id: 'petAdvEternal', name: '高级永恒', defBonus: 0.22, atkBonus: 0.12 },
    { id: 'petAdvRage', name: '高级狂暴', atkBonus: 0.4, defPenalty: 0.12 },
    { id: 'petAdvBerserk', name: '高级舍身击', atkBonus: 0.45, defPenalty: 0.18 },
    { id: 'petAdvWisdom', name: '高级慧根', dmgBonus: 0.18 },
    { id: 'petAdvMiracle', name: '高级神迹', defBonus: 0.28 },
    /* ========== 宠物多目标攻击技能 ========== */
    { id: 'petSweep', name: '横扫', petAoeChance: 0.2, petAoePct: 0.4 },
    { id: 'petSplash', name: '溅射', petAoeChance: 0.25, petAoePct: 0.35 },
    { id: 'petShockwave', name: '震波', petAoeChance: 0.3, petAoePct: 0.3 },
    { id: 'petRift', name: '裂空', petAoeChance: 0.15, petAoePct: 0.55 },
    { id: 'petAdvSweep', name: '高级横扫', petAoeChance: 0.35, petAoePct: 0.5 },
    /* ========== 宠物被动：给玩家加成（低级） ========== */
    { id: 'petPassionWar', name: '战意', playerBonus: { atk: 40 } },
    { id: 'petIronWall', name: '铁壁', playerBonus: { def: 30 } },
    { id: 'petVitality', name: '生机', playerBonus: { hp: 250 } },
    { id: 'petSpiritSource', name: '灵源', playerBonus: { maxMp: 5 } },
    { id: 'petBloodBond', name: '血契', playerBonus: { lifesteal: 0.5 } },
    { id: 'petBreakMomentum', name: '破势', playerBonus: { critDmg: 6 } },
    { id: 'petMindLink', name: '灵犀', playerBonus: { skillDmg: 4 } },
    { id: 'petMistyStep', name: '飘渺', playerBonus: { dodge: 1 } },
    { id: 'petFiveResonance', name: '五行共鸣', playerBonus: { elementAtk: 10 } },
    { id: 'petSharpWill', name: '锐意', playerBonus: { atk: 35 } },
    { id: 'petToughArmor', name: '韧甲', playerBonus: { def: 25 } },
    { id: 'petQiBlood', name: '气血', playerBonus: { hp: 200 } },
    { id: 'petConcentrate', name: '凝神', playerBonus: { maxMp: 4 } },
    { id: 'petBloodThirst', name: '噬血', playerBonus: { lifesteal: 0.4 } },
    { id: 'petSharpEdge', name: '锋芒', playerBonus: { critDmg: 5 } },
    { id: 'petMysticPower', name: '玄通', playerBonus: { skillDmg: 3 } },
    { id: 'petGhostStep', name: '鬼步', playerBonus: { dodge: 0.8 } },
    { id: 'petElementSoul', name: '元灵', playerBonus: { elementAtk: 8 } },
    { id: 'petBerserkWar', name: '狂战', playerBonus: { atk: 50 } },
    { id: 'petSteadfastShield', name: '坚盾', playerBonus: { def: 35 } },
    { id: 'petLifeFlow', name: '生命之息', playerBonus: { hp: 300 } },
    { id: 'petManaWell', name: '法力之井', playerBonus: { maxMp: 6 } },
    /* ========== 宠物被动：给玩家加成（高级） ========== */
    { id: 'petAdvPassionWar', name: '战神祝福', playerBonus: { atk: 120 } },
    { id: 'petAdvIronWall', name: '不破金身', playerBonus: { def: 90 } },
    { id: 'petAdvVitality', name: '生命之泉', playerBonus: { hp: 800 } },
    { id: 'petAdvSpiritSource', name: '奥术洪流', playerBonus: { maxMp: 18 } },
    { id: 'petAdvBloodBond', name: '嗜血契约', playerBonus: { lifesteal: 1.5 } },
    { id: 'petAdvBreakMomentum', name: '毁灭之势', playerBonus: { critDmg: 18 } },
    { id: 'petAdvMindLink', name: '神念', playerBonus: { skillDmg: 12 } },
    { id: 'petAdvMistyStep', name: '幻影步', playerBonus: { dodge: 3 } },
    { id: 'petAdvFiveResonance', name: '五行归一', playerBonus: { elementAtk: 35 } },
    { id: 'petAdvSharpWill', name: '破军', playerBonus: { atk: 100 } },
    { id: 'petAdvToughArmor', name: '玄武护体', playerBonus: { def: 75 } },
    { id: 'petAdvQiBlood', name: '龙象气血', playerBonus: { hp: 600 } },
    { id: 'petAdvConcentrate', name: '天心凝神', playerBonus: { maxMp: 14 } },
    { id: 'petAdvBloodThirst', name: '血魔契约', playerBonus: { lifesteal: 1.2 } },
    { id: 'petAdvSharpEdge', name: '诛神锋芒', playerBonus: { critDmg: 15 } },
    { id: 'petAdvMysticPower', name: '玄天通神', playerBonus: { skillDmg: 10 } },
    { id: 'petAdvGhostStep', name: '幽冥鬼步', playerBonus: { dodge: 2.5 } },
    { id: 'petAdvElementSoul', name: '五行造化', playerBonus: { elementAtk: 28 } },
    { id: 'petAdvBerserkWar', name: '修罗战意', playerBonus: { atk: 110 } },
    { id: 'petAdvSteadfastShield', name: '永恒壁垒', playerBonus: { def: 80 } },
    { id: 'petAdvLifeFlow', name: '涅槃生机', playerBonus: { hp: 700 } },
    { id: 'petAdvManaWell', name: '虚空法源', playerBonus: { maxMp: 16 } }
];

function abyssGenPetId() { return 'pet_' + Date.now() + '_' + Math.random().toString(36).slice(2, 9); }

var ABYSS_PET_TYPES = [
    { id: 'atk', name: '攻击型' },
    { id: 'balance', name: '平衡型' },
    { id: 'def', name: '防御型' },
    { id: 'hp', name: '体力型' }
];

function abyssGenPet(monsterName, floor) {
    var baseName = (monsterName || '未命名').replace(/·\d+层$/, '').trim();
    baseName = baseName.replace(/^【[^】]+】/, '');
    for (var pi = 0; pi < ABYSS_MONSTER_PREFIXES.length; pi++) {
        var pn = ABYSS_MONSTER_PREFIXES[pi].name;
        if (baseName.indexOf(pn) === 0) { baseName = baseName.slice(pn.length).trim(); break; }
    }
    if (!baseName) baseName = '未命名';
    var isVariant = Math.random() < 0.1;
    var f = Math.max(1, floor || 1);
    var bonus = Math.min(800, Math.floor(f * 25));
    var baseMin = 1500;
    var baseMax = 2500;
    var roll = function() { return Math.min(3500, baseMin + Math.floor(Math.random() * (baseMax - baseMin + 1)) + bonus); };
    var growth = {
        atk: roll(),
        def: roll(),
        hp: roll(),
        speed: roll()
    };
    if (isVariant) {
        growth.atk = Math.floor(growth.atk * 1.2);
        growth.def = Math.floor(growth.def * 1.2);
        growth.hp = Math.floor(growth.hp * 1.2);
        growth.speed = Math.floor(growth.speed * 1.2);
    }
    var typeIdx = Math.floor(Math.random() * ABYSS_PET_TYPES.length);
    var petType = ABYSS_PET_TYPES[typeIdx].id;
    if (petType === 'atk') growth.atk = Math.floor(growth.atk * 1.15);
    else if (petType === 'def') growth.def = Math.floor(growth.def * 1.15);
    else if (petType === 'hp') growth.hp = Math.floor(growth.hp * 1.15);
    else if (petType === 'balance') {
        growth.atk = Math.floor(growth.atk * 1.08);
        growth.def = Math.floor(growth.def * 1.08);
        growth.hp = Math.floor(growth.hp * 1.08);
        growth.speed = Math.floor(growth.speed * 1.08);
    }
    var skillCount = isVariant ? (4 + Math.floor(Math.random() * 3)) : (1 + Math.floor(Math.random() * 3));
    var pool = ABYSS_PET_SKILLS.slice();
    var skills = [];
    for (var i = 0; i < skillCount && pool.length > 0; i++) {
        var idx = Math.floor(Math.random() * pool.length);
        skills.push({ id: pool[idx].id, name: pool[idx].name });
        pool.splice(idx, 1);
    }
    var displayName = isVariant ? ('变异' + baseName) : baseName;
    return {
        id: abyssGenPetId(),
        name: displayName,
        type: petType,
        variant: !!isVariant,
        level: 1,
        exp: 0,
        growth: growth,
        skills: skills,
        hp: null,
        maxHp: 0
    };
}

function abyssCalcPetStats(pet) {
    if (!pet) return null;
    var L = pet.level || 1;
    var g = pet.growth || { atk: 1000, def: 1000, hp: 1000, speed: 1000 };
    var atk = Math.floor(L * (g.atk / 1000) * 22);
    var def = Math.floor(L * (g.def / 1000) * 13);
    var maxHp = Math.floor(L * (g.hp / 1000) * 150);
    atk = Math.max(1, atk);
    def = Math.max(0, def);
    maxHp = Math.max(50, maxHp);
    var dodge = Math.min(15, Math.max(0, (g.speed - 1000) / 2000 * 10));
    var p = { atk: atk, def: def, maxHp: maxHp, dodge: dodge, critRate: 0, critDmg: 0, lifesteal: 0, damageReduction: 0 };
    for (var i = 0; i < (pet.skills || []).length; i++) {
        var sk = null;
        for (var j = 0; j < ABYSS_PET_SKILLS.length; j++) {
            if (ABYSS_PET_SKILLS[j].id === pet.skills[i].id) { sk = ABYSS_PET_SKILLS[j]; break; }
        }
        if (sk) {
            if (sk.atkBonus) p.atk = Math.floor(p.atk * (1 + sk.atkBonus));
            if (sk.defBonus) p.def = Math.floor(p.def * (1 + sk.defBonus));
        }
    }
    if (abyssRun && abyssRun.equipped) {
        for (var ek in abyssRun.equipped) {
            var eq = abyssRun.equipped[ek];
            if (!eq || !eq.equipSkill || !eq.equipSkill.effect) continue;
            var e = eq.equipSkill.effect;
            if (e.petAtk) p.atk = (p.atk || 0) + e.petAtk;
            if (e.petDef) p.def = (p.def || 0) + e.petDef;
            if (e.petHp) p.maxHp = (p.maxHp || 0) + e.petHp;
            if (e.petDodge) p.dodge = (p.dodge || 0) + e.petDodge;
            if (e.petCritRate) p.critRate = (p.critRate || 0) + e.petCritRate;
            if (e.petCritDmg) p.critDmg = (p.critDmg || 0) + e.petCritDmg;
            if (e.petLifesteal) p.lifesteal = (p.lifesteal || 0) + e.petLifesteal;
            if (e.petDamageReduction) p.damageReduction = (p.damageReduction || 0) + e.petDamageReduction;
        }
    }
    if (abyssRun && abyssRun.buffs) {
        if (abyssRun.buffs.petAtkPct != null) p.atk = Math.floor(p.atk * (1 + abyssRun.buffs.petAtkPct / 100));
        if (abyssRun.buffs.petDefPct != null) p.def = Math.floor(p.def * (1 + abyssRun.buffs.petDefPct / 100));
        if (abyssRun.buffs.petHpPct != null) p.maxHp = Math.floor(p.maxHp * (1 + abyssRun.buffs.petHpPct / 100));
    }
    var vB = abyssCalcVaultBonuses();
    if (vB.petAtkPct) p.atk = Math.floor(p.atk * (1 + vB.petAtkPct / 100));
    if (vB.petDefPct) p.def = Math.floor(p.def * (1 + vB.petDefPct / 100));
    if (vB.petHpPct) p.maxHp = Math.floor(p.maxHp * (1 + vB.petHpPct / 100));
    var at = getAbyssTower();
    var vault = at.abyssVault || {};
    var petAtkFlat = 0, petDefFlat = 0, petHpFlat = 0;
    ABYSS_VAULT_TREASURES.forEach(function(t) {
        var c = vault[t.id] || 0;
        if (c <= 0) return;
        var e = t.effect;
        if (e.type === 'petAtkVaultFlat') petAtkFlat += e.value * c;
        else if (e.type === 'petDefVaultFlat') petDefFlat += e.value * c;
        else if (e.type === 'petHpVaultFlat') petHpFlat += e.value * c;
    });
    if (petAtkFlat) p.atk = (p.atk || 0) + petAtkFlat;
    if (petDefFlat) p.def = (p.def || 0) + petDefFlat;
    if (petHpFlat) p.maxHp = (p.maxHp || 0) + petHpFlat;
    p.atk = Math.max(1, p.atk);
    p.def = Math.max(0, p.def);
    p.maxHp = Math.max(50, p.maxHp);
    p.dodge = Math.min(75, (p.dodge || 0));
    pet.maxHp = p.maxHp;
    return p;
}

function abyssGetMaxDeployedSlots() {
    var at = getAbyssTower();
    return 1 + Math.min(3, at.deployedSlotsPurchases || 0);
}
function abyssGetDeployedPets() {
    if (!abyssRun) return [];
    if (abyssRun.trialId === 'noPet' && abyssRun.trialRoundsLeft > 0) return [];
    if (!abyssRun.deployedPetIds && abyssRun.deployedPetId) {
        abyssRun.deployedPetIds = [abyssRun.deployedPetId];
    }
    if (!abyssRun.deployedPetIds || !abyssRun.deployedPetIds.length) return [];
    var out = [];
    for (var i = 0; i < abyssRun.deployedPetIds.length; i++) {
        for (var j = 0; j < (abyssRun.pets || []).length; j++) {
            if (abyssRun.pets[j].id === abyssRun.deployedPetIds[i]) { out.push(abyssRun.pets[j]); break; }
        }
    }
    return out;
}
function abyssGetDeployedPet() {
    var list = abyssGetDeployedPets();
    return list.length > 0 ? list[0] : null;
}
function abyssIsPetDeployed(petId) {
    return abyssRun && abyssRun.deployedPetIds && abyssRun.deployedPetIds.indexOf(petId) >= 0;
}

function abyssPetExpToNext(level) { return 50; }

function abyssPetGainExp(exp) {
    var deployedList = abyssGetDeployedPets();
    if (!deployedList.length) return;
    var runLevel = Math.max(1, Math.floor((abyssRun.exp || 0) / 100));
    for (var gi = 0; gi < deployedList.length; gi++) {
        var pet = deployedList[gi];
        pet.exp = (pet.exp || 0) + exp;
        while (pet.exp >= 50 && (pet.level || 1) < runLevel) {
            pet.exp -= 50;
            pet.level = (pet.level || 1) + 1;
            abyssLog('宠物【' + pet.name + '】升级至 Lv.' + pet.level + '！');
        }
        if ((pet.level || 1) >= runLevel && pet.exp > 0) pet.exp = Math.min(pet.exp, 49);
    }
}

var ABYSS_BOSS_SKILLS = [
    { id: 'multiHit', name: '多段攻击', chance: 0.34, multi: 2.2 },
    { id: 'halfDamage', name: '减伤', rate: 0.42, maxRate: 0.72 },
    { id: 'lifesteal', name: '吸血', rate: 0.14 },
    { id: 'rage', name: '狂暴', atkBonus: 0.52 },
    { id: 'armorBreak', name: '破甲', defIgnore: 0.38 },
    { id: 'doubleStrike', name: '二连击', chance: 0.28, multi: 2.2 },
    { id: 'tripleStrike', name: '三连击', chance: 0.18, multi: 3.2 },
    { id: 'execute', name: '处决', lowHpThreshold: 0.3, dmgBonus: 0.65 },
    { id: 'crush', name: '碾压', dmgBonus: 0.32 },
    { id: 'ignite', name: '灼烧', dotRate: 0.07 },
    { id: 'thorns', name: '反伤', reflectRate: 0.14 },
    { id: 'heavyStrike', name: '重击', chance: 0.32, dmgMult: 1.7 },
    { id: 'bloodthirst', name: '嗜血', atkBonusPerMissing: 0.62 },
    { id: 'shield', name: '护盾', shieldPct: 0.26 },
    { id: 'intimidate', name: '威压', dmgReduce: 0.2 },
    { id: 'bleed', name: '流血', extraDmg: 0.07 },
    { id: 'curse', name: '诅咒', defIgnore: 0.14 },
    { id: 'freeze', name: '冰冻', chance: 0.16, multi: 2.2 },
    { id: 'venom', name: '毒液', dmgBonus: 0.14 },
    { id: 'revive', name: '复活', revivePct: 0.3 },
    { id: 'multiHit', name: '连击', chance: 0.28, multi: 2.2 },
    { id: 'armorBreak', name: '碎甲', defIgnore: 0.32 },
    { id: 'rage', name: '狂怒', atkBonus: 0.45 },
    { id: 'doubleStrike', name: '双斩', chance: 0.24, multi: 2.2 },
    { id: 'execute', name: '斩杀', lowHpThreshold: 0.25, dmgBonus: 0.75 },
    { id: 'crush', name: '粉碎', dmgBonus: 0.26 },
    { id: 'thorns', name: '刺甲', reflectRate: 0.16 },
    { id: 'heavyStrike', name: '猛击', chance: 0.28, dmgMult: 1.6 },
    { id: 'bloodthirst', name: '渴血', atkBonusPerMissing: 0.56 },
    { id: 'shield', name: '铁壁', shieldPct: 0.2 },
    { id: 'intimidate', name: '震慑', dmgReduce: 0.16 },
    { id: 'bleed', name: '撕裂', extraDmg: 0.11 },
    { id: 'curse', name: '虚弱', defIgnore: 0.2 },
    { id: 'freeze', name: '寒霜', chance: 0.14, multi: 2.2 },
    { id: 'venom', name: '剧毒', dmgBonus: 0.2 },
    { id: 'tripleStrike', name: '三连斩', chance: 0.14, multi: 3.2 },
    { id: 'multiHit', name: '疾风', chance: 0.3, multi: 2.2 },
    { id: 'armorBreak', name: '穿甲', defIgnore: 0.36 },
    { id: 'execute', name: '终结', lowHpThreshold: 0.35, dmgBonus: 0.58 },
    { id: 'thorns', name: '荆棘', reflectRate: 0.11 },
    { id: 'shield', name: '屏障', shieldPct: 0.24 },
    { id: 'bossSummon', name: '深渊召唤', chance: 0.2, summonCount: 2, summonPct: 0.1 },
    /* ========== 10层+ 进阶技能 ========== */
    { id: 'quadrupleStrike', name: '四连斩', chance: 0.12, multi: 4, minTier: 1 },
    { id: 'execute', name: '裂魂', lowHpThreshold: 0.2, dmgBonus: 0.85, minTier: 1 },
    { id: 'crush', name: '泰坦之握', dmgBonus: 0.4, minTier: 1 },
    { id: 'shield', name: '邪能护甲', shieldPct: 0.3, minTier: 1 },
    { id: 'rage', name: '暴君之怒', atkBonus: 0.6, minTier: 1 },
    { id: 'armorBreak', name: '破城', defIgnore: 0.45, minTier: 1 },
    { id: 'intimidate', name: '深渊凝视', dmgReduce: 0.25, minTier: 1 },
    { id: 'thorns', name: '荆棘王座', reflectRate: 0.2, minTier: 1 },
    { id: 'heavyStrike', name: '崩山', chance: 0.35, dmgMult: 1.85, minTier: 1 },
    { id: 'bloodthirst', name: '噬生', atkBonusPerMissing: 0.7, minTier: 1 },
    { id: 'lifesteal', name: '生命汲取', rate: 0.22, minTier: 1 },
    { id: 'ignite', name: '业火', dotRate: 0.09, minTier: 1 },
    { id: 'bossSummon', name: '召唤仆从', chance: 0.28, summonCount: 2, summonPct: 0.15, minTier: 1 },
    /* ========== 20层+ 高阶技能 ========== */
    { id: 'quadrupleStrike', name: '乱舞', chance: 0.15, multi: 4, minTier: 2 },
    { id: 'execute', name: '死愿', lowHpThreshold: 0.18, dmgBonus: 0.95, minTier: 2 },
    { id: 'halfDamage', name: '霸体', rate: 0.2, maxRate: 0.75, minTier: 2 },
    { id: 'freeze', name: '深渊吐息', chance: 0.2, multi: 2.5, minTier: 2 },
    { id: 'venom', name: '毒心', dmgBonus: 0.28, minTier: 2 },
    { id: 'bleed', name: '裂伤', extraDmg: 0.15, minTier: 2 },
    { id: 'curse', name: '腐化印记', defIgnore: 0.28, minTier: 2 },
    { id: 'doubleStrike', name: '双生斩', chance: 0.32, multi: 2.4, minTier: 2 },
    { id: 'tripleStrike', name: '三劫', chance: 0.2, multi: 3.5, minTier: 2 },
    { id: 'rage', name: '二阶段', atkBonus: 0.55, rageThreshold: 0.5, minTier: 2 },
    { id: 'revive', name: '不灭', revivePct: 0.4, minTier: 2 },
    { id: 'lifesteal', name: '血宴', rate: 0.28, minTier: 2 },
    { id: 'ignite', name: '永燃', dotRate: 0.12, minTier: 2 },
    { id: 'bossSummon', name: '召唤精英', chance: 0.25, summonCount: 2, summonPct: 0.2, minTier: 2 },
    /* ========== 30层+ 深渊专属 ========== */
    { id: 'quadrupleStrike', name: '万象崩灭', chance: 0.18, multi: 4.2, minTier: 3 },
    { id: 'execute', name: '终焉', lowHpThreshold: 0.15, dmgBonus: 1.1, minTier: 3 },
    { id: 'halfDamage', name: '深渊之肤', rate: 0.28, maxRate: 0.78, minTier: 3 },
    { id: 'shield', name: '虚空壁垒', shieldPct: 0.35, minTier: 3 },
    { id: 'intimidate', name: '神威', dmgReduce: 0.3, minTier: 3 },
    { id: 'thorns', name: '反噬', reflectRate: 0.24, minTier: 3 },
    { id: 'armorBreak', name: '碎界', defIgnore: 0.5, minTier: 3 },
    { id: 'heavyStrike', name: '天崩', chance: 0.38, dmgMult: 2, minTier: 3 },
    { id: 'bloodthirst', name: '献祭', atkBonusPerMissing: 0.85, minTier: 3 },
    { id: 'lifesteal', name: '夺魂', rate: 0.35, minTier: 3 },
    { id: 'ignite', name: '炼狱', dotRate: 0.15, minTier: 3 },
    { id: 'freeze', name: '永冻', chance: 0.22, multi: 2.8, minTier: 3 },
    { id: 'revive', name: '轮回', revivePct: 0.5, minTier: 3 },
    { id: 'bossSummon', name: '深渊军团', chance: 0.35, summonCount: 3, summonPct: 0.18, minTier: 3 },
    /* ========== 40层+ 传说技能 ========== */
    { id: 'execute', name: '弑神', lowHpThreshold: 0.12, dmgBonus: 1.25, minTier: 4 },
    { id: 'quadrupleStrike', name: '万剑归宗', chance: 0.2, multi: 4.5, minTier: 4 },
    { id: 'halfDamage', name: '不朽', rate: 0.35, maxRate: 0.8, minTier: 4 },
    { id: 'rage', name: '灭世', atkBonus: 0.75, minTier: 4 },
    { id: 'lifesteal', name: '永生', rate: 0.4, minTier: 4 },
    { id: 'bossSummon', name: '深渊主宰', chance: 0.4, summonCount: 3, summonPct: 0.22, minTier: 4 },
    /* ========== 20个特色技能（与众不同） ========== */
    { id: 'mpSteal', name: '夺魂', mpStealPct: 0.2 },
    { id: 'silence', name: '静默', silenceChance: 0.3, silenceRounds: 1 },
    { id: 'hitAll', name: '崩裂', hitAllPct: 0.55 },
    { id: 'counterStrike', name: '复仇', counterBonus: 0.5 },
    { id: 'phaseAtHp', name: '蜕皮', phaseAtkBonus: 0.4 },
    { id: 'shieldOnHit', name: '噬能护甲', shieldOnHitPct: 0.12 },
    { id: 'firstStrike', name: '先制', firstStrikeMult: 1.6 },
    { id: 'lastStand', name: '死志', lastStandThreshold: 0.15 },
    { id: 'surviveOneDeath', name: '不溃' },
    { id: 'enrageAtRounds', name: '狂乱', enrageRound: 3, enrageMult: 1.5 },
    { id: 'lifesteal', name: '血契', rate: 0.32 },
    { id: 'revive', name: '魂牢', revivePct: 0.45 },
    { id: 'execute', name: '湮灭', lowHpThreshold: 0.12, dmgBonus: 1.0 },
    { id: 'armorBreak', name: '破势', defIgnore: 0.48 },
    { id: 'halfDamage', name: '永劫', rate: 0.25, maxRate: 0.76 },
    { id: 'bloodthirst', name: '噬梦', atkBonusPerMissing: 0.78 },
    { id: 'shield', name: '虚空障壁', shieldPct: 0.32 },
    { id: 'thorns', name: '反噬之触', reflectRate: 0.22 },
    { id: 'intimidate', name: '咒缚', dmgReduce: 0.28 },
    { id: 'revive', name: '终末', revivePct: 0.55 },
    /* ========== 新增20个与众不同的BOSS特色技能 ========== */
    { id: 'timeStop', name: '时空凝滞', chance: 0.22, skipTurns: 1 },
    { id: 'soulDrain', name: '魂噬', dotMaxHpPct: 0.04, dotRounds: 2 },
    { id: 'curseMark', name: '咒印', stackDmgPerHit: 0.06, stackMax: 0.3 },
    { id: 'stealBuff', name: '掠夺', stealBuffChance: 0.35 },
    { id: 'deathAura', name: '死域', healOnAllyHitPct: 0.03 },
    { id: 'healReduce', name: '锁链', healReducePct: 0.35 },
    { id: 'voidTouch', name: '湮灭之触', missingHpDmgPct: 0.25 },
    { id: 'foresight', name: '预知', dodgeBonus: 18 },
    { id: 'deathCurse', name: '怨念', deathDmgMaxHpPct: 0.22 },
    { id: 'mirrorImage', name: '幻身', chance: 0.18, imagePct: 0.2 },
    { id: 'bloodPrice', name: '血偿', selfHpCostPct: 0.08, atkBonus: 0.5 },
    { id: 'entropy', name: '熵增', chaosChance: 0.25 },
    { id: 'soulLink', name: '魂链', damageSharePct: 0.15 },
    { id: 'abyssGaze', name: '深渊凝视', blindChance: 0.2, blindRounds: 1 },
    { id: 'boneArmor', name: '骨甲', armorPerHit: 5, armorCap: 80 },
    { id: 'lifeSwap', name: '生命置换', swapChance: 0.12 },
    { id: 'manaBurn', name: '燃魔', burnPct: 0.18 },
    { id: 'fear', name: '恐惧', fearChance: 0.15, skipAttackChance: 0.5 },
    { id: 'corrupt', name: '腐化', corruptHealPct: 0.2 },
    { id: 'overwhelm', name: '碾压意志', overwhelmDefIgnore: 0.4 },
    /* ========== 10层+ 额外BOSS技能（在必带之外额外池） ========== */
    { id: 'multiHit', name: '裂空斩', chance: 0.32, multi: 2.6, minTier: 1 },
    { id: 'doubleStrike', name: '影袭', chance: 0.3, multi: 2.5, minTier: 1 },
    { id: 'tripleStrike', name: '鬼刃三连', chance: 0.2, multi: 3.4, minTier: 1 },
    { id: 'heavyStrike', name: '碎星', chance: 0.38, dmgMult: 1.9, minTier: 1 },
    { id: 'execute', name: '夺命', lowHpThreshold: 0.22, dmgBonus: 0.8, minTier: 1 },
    { id: 'armorBreak', name: '穿心', defIgnore: 0.48, minTier: 1 },
    { id: 'rage', name: '魔化', atkBonus: 0.58, minTier: 1 },
    { id: 'lifesteal', name: '血祭', rate: 0.24, minTier: 1 },
    { id: 'shield', name: '暗影护体', shieldPct: 0.28, minTier: 1 },
    { id: 'intimidate', name: '魔威', dmgReduce: 0.26, minTier: 1 },
    { id: 'thorns', name: '怨灵反噬', reflectRate: 0.22, minTier: 1 },
    { id: 'ignite', name: '冥炎', dotRate: 0.1, minTier: 1 },
    { id: 'bleed', name: '撕裂', extraDmg: 0.14, minTier: 1 },
    { id: 'curse', name: '衰亡印记', defIgnore: 0.26, minTier: 1 },
    { id: 'freeze', name: '极寒冲击', chance: 0.18, multi: 2.6, minTier: 1 },
    { id: 'venom', name: '蚀骨毒', dmgBonus: 0.26, minTier: 1 },
    { id: 'crush', name: '崩灭', dmgBonus: 0.42, minTier: 1 },
    { id: 'bloodthirst', name: '狂嗜', atkBonusPerMissing: 0.72, minTier: 1 },
    { id: 'revive', name: '亡语', revivePct: 0.35, minTier: 1 },
    { id: 'halfDamage', name: '魔躯', rate: 0.22, maxRate: 0.74, minTier: 1 },
    { id: 'soulDrain', name: '噬魂', dotMaxHpPct: 0.045, dotRounds: 2, minTier: 1 },
    { id: 'voidTouch', name: '虚空侵蚀', missingHpDmgPct: 0.22, minTier: 1 },
    { id: 'boneArmor', name: '骸骨壁垒', armorPerHit: 6, armorCap: 90, minTier: 1 },
    { id: 'fear', name: '战栗', fearChance: 0.18, skipAttackChance: 0.45, minTier: 1 },
    { id: 'entropy', name: '混沌一击', chaosChance: 0.28, minTier: 1 }
];

var ABYSS_NORMAL_MONSTER_SKILLS = [
    { id: 'multiHit', name: '小连击', chance: 0.18, multi: 2.2 },
    { id: 'armorBreak', name: '轻破甲', defIgnore: 0.18 },
    { id: 'rage', name: '微怒', atkBonus: 0.22 },
    { id: 'doubleStrike', name: '二连', chance: 0.15, multi: 2.2 },
    { id: 'execute', name: '补刀', lowHpThreshold: 0.2, dmgBonus: 0.34 },
    { id: 'crush', name: '重压', dmgBonus: 0.14 },
    { id: 'thorns', name: '小反伤', reflectRate: 0.06 },
    { id: 'heavyStrike', name: '敲击', chance: 0.18, dmgMult: 1.4 },
    { id: 'bloodthirst', name: '饥渴', atkBonusPerMissing: 0.28 },
    { id: 'shield', name: '薄盾', shieldPct: 0.12 },
    { id: 'intimidate', name: '威吓', dmgReduce: 0.1 },
    { id: 'bleed', name: '擦伤', extraDmg: 0.03 },
    { id: 'curse', name: '弱咒', defIgnore: 0.08 },
    { id: 'freeze', name: '冷气', chance: 0.1, multi: 2.2 },
    { id: 'venom', name: '微毒', dmgBonus: 0.06 },
    { id: 'multiHit', name: '疾打', chance: 0.15, multi: 2.2 },
    { id: 'armorBreak', name: '裂甲', defIgnore: 0.15 },
    { id: 'rage', name: '躁动', atkBonus: 0.18 },
    { id: 'doubleStrike', name: '双打', chance: 0.12, multi: 2.2 },
    { id: 'execute', name: '收尾', lowHpThreshold: 0.25, dmgBonus: 0.28 },
    { id: 'crush', name: '捶打', dmgBonus: 0.12 },
    { id: 'thorns', name: '尖刺', reflectRate: 0.05 },
    { id: 'heavyStrike', name: '劈砍', chance: 0.15, dmgMult: 1.35 },
    { id: 'bloodthirst', name: '嗜战', atkBonusPerMissing: 0.24 },
    { id: 'shield', name: '护身', shieldPct: 0.1 },
    { id: 'intimidate', name: '瞪视', dmgReduce: 0.08 },
    { id: 'bleed', name: '划伤', extraDmg: 0.045 },
    { id: 'curse', name: '衰败', defIgnore: 0.09 },
    { id: 'freeze', name: '冰触', chance: 0.08, multi: 2.2 },
    { id: 'venom', name: '毒刺', dmgBonus: 0.07 },
    { id: 'multiHit', name: '快攻', chance: 0.08, multi: 2 },
    { id: 'armorBreak', name: '破防', defIgnore: 0.08 },
    { id: 'rage', name: '暴燥', atkBonus: 0.1 },
    { id: 'doubleStrike', name: '连打', chance: 0.07, multi: 2 },
    { id: 'execute', name: '致命', lowHpThreshold: 0.3, dmgBonus: 0.15 },
    { id: 'crush', name: '撞击', dmgBonus: 0.06 },
    { id: 'thorns', name: '反刺', reflectRate: 0.05 },
    { id: 'heavyStrike', name: '猛敲', chance: 0.08, dmgMult: 1.15 },
    { id: 'bloodthirst', name: '血性', atkBonusPerMissing: 0.15 },
    { id: 'shield', name: '气盾', shieldPct: 0.05 },
    { id: 'intimidate', name: '压迫', dmgReduce: 0.04 },
    { id: 'bleed', name: '割裂', extraDmg: 0.025 },
    { id: 'curse', name: '侵蚀', defIgnore: 0.04 },
    { id: 'freeze', name: '霜冻', chance: 0.04, multi: 2 },
    { id: 'venom', name: '毒牙', dmgBonus: 0.03 },
    { id: 'multiHit', name: '乱打', chance: 0.06, multi: 2 },
    { id: 'armorBreak', name: '削甲', defIgnore: 0.06 },
    { id: 'rage', name: '激怒', atkBonus: 0.08 },
    { id: 'doubleStrike', name: '双击', chance: 0.06, multi: 2 },
    { id: 'heavyStrike', name: '硬击', chance: 0.07, dmgMult: 1.12 },
    { id: 'thorns', name: '硬壳', reflectRate: 0.02 },
    { id: 'multiHit', name: '迅爪', chance: 0.09, multi: 2 },
    { id: 'armorBreak', name: '撕咬', defIgnore: 0.07 },
    { id: 'rage', name: '凶性', atkBonus: 0.09 },
    { id: 'doubleStrike', name: '尾扫', chance: 0.065, multi: 2 },
    { id: 'execute', name: '噬喉', lowHpThreshold: 0.22, dmgBonus: 0.18 },
    { id: 'crush', name: '践踏', dmgBonus: 0.07 },
    { id: 'thorns', name: '骨刺', reflectRate: 0.045 },
    { id: 'heavyStrike', name: '头槌', chance: 0.09, dmgMult: 1.18 },
    { id: 'bloodthirst', name: '嗜血', atkBonusPerMissing: 0.12 },
    { id: 'shield', name: '甲壳', shieldPct: 0.055 },
    { id: 'intimidate', name: '咆哮', dmgReduce: 0.045 },
    { id: 'bleed', name: '爪痕', extraDmg: 0.022 },
    { id: 'curse', name: '暗蚀', defIgnore: 0.045 },
    { id: 'freeze', name: '寒息', chance: 0.045, multi: 2 },
    { id: 'venom', name: '毒涎', dmgBonus: 0.035 },
    { id: 'multiHit', name: '乱抓', chance: 0.07, multi: 2 },
    { id: 'armorBreak', name: '凿击', defIgnore: 0.065 },
    { id: 'rage', name: '狂性', atkBonus: 0.07 },
    { id: 'doubleStrike', name: '双尾', chance: 0.055, multi: 2 },
    { id: 'execute', name: '掏心', lowHpThreshold: 0.28, dmgBonus: 0.12 },
    { id: 'crush', name: '压顶', dmgBonus: 0.055 },
    { id: 'thorns', name: '鳞反', reflectRate: 0.035 },
    { id: 'heavyStrike', name: '尾砸', chance: 0.065, dmgMult: 1.14 },
    { id: 'bloodthirst', name: '渴血', atkBonusPerMissing: 0.1 },
    { id: 'shield', name: '岩肤', shieldPct: 0.045 },
    { id: 'intimidate', name: '凝视', dmgReduce: 0.035 },
    { id: 'bleed', name: '撕扯', extraDmg: 0.02 },
    { id: 'curse', name: '腐化', defIgnore: 0.035 },
    { id: 'freeze', name: '冰牙', chance: 0.04, multi: 2 },
    { id: 'venom', name: '毒雾', dmgBonus: 0.025 },
    { id: 'multiHit', name: '连啄', chance: 0.065, multi: 2 },
    { id: 'armorBreak', name: '破皮', defIgnore: 0.055 },
    { id: 'rage', name: '暴走', atkBonus: 0.065 },
    { id: 'doubleStrike', name: '双爪', chance: 0.05, multi: 2 },
    { id: 'heavyStrike', name: '甩尾', chance: 0.06, dmgMult: 1.1 },
    { id: 'thorns', name: '刺毛', reflectRate: 0.025 },
    { id: 'execute', name: '绝杀', lowHpThreshold: 0.35, dmgBonus: 0.1 },
    { id: 'shield', name: '泥甲', shieldPct: 0.04 },
    { id: 'intimidate', name: '威吓', dmgReduce: 0.03 },
    { id: 'bleed', name: '咬伤', extraDmg: 0.018 },
    { id: 'curse', name: '诅咒', defIgnore: 0.03 },
    { id: 'venom', name: '毒液', dmgBonus: 0.02 },
    { id: 'multiHit', name: '扑击', chance: 0.06, multi: 2 },
    { id: 'armorBreak', name: '啃咬', defIgnore: 0.05 },
    { id: 'rage', name: '凶暴', atkBonus: 0.06 },
    { id: 'doubleStrike', name: '二段', chance: 0.048, multi: 2 },
    { id: 'crush', name: '碾压', dmgBonus: 0.05 },
    { id: 'heavyStrike', name: '拍击', chance: 0.055, dmgMult: 1.08 },
    { id: 'bloodthirst', name: '吸血', atkBonusPerMissing: 0.08 },
    { id: 'shield', name: '护膜', shieldPct: 0.035 }
];

function abyssCreateOneMonster(f, isBoss, nameSuffix, baseStats) {
    var baseHp = (baseStats && baseStats.hp) || (500 + f * 78);
    var baseAtk = (baseStats && baseStats.atk) || (30 + f * 6);
    var baseDef = (baseStats && baseStats.def) || (10 + Math.floor(f * 1.9));
    // 普通怪物：基础属性 下浮20% 上浮10%（即 80%～110%）
    if (!isBoss) {
        baseHp *= (0.8 + Math.random() * 0.3);
        baseAtk *= (0.8 + Math.random() * 0.3);
        baseDef *= (0.8 + Math.random() * 0.3);
    }
    var hpPow = 1.068, atkPow = 1.055, defPow = 1.035;
    if (isBoss) {
        baseHp *= 2.4;
        baseAtk *= 1.5;
        baseDef *= 1.2;
        hpPow = 1.05;
        atkPow = 1.042;
        defPow = 1.025;
    }
    var hp = Math.floor(baseHp * Math.pow(hpPow, f - 1));
    var atk = Math.floor(baseAtk * Math.pow(atkPow, f - 1));
    var def = Math.floor(baseDef * Math.pow(defPow, f - 1));
    var prefix = null;
    var prefixes = [];
    var baseName = '';
    var eliteOrChiefScale = 1;
    var rewardMult = 1;
    var tierLabel = '';
    var minSkills = 1;
    if (isBoss) {
        baseName = ABYSS_BOSS_NAMES[Math.floor(Math.random() * ABYSS_BOSS_NAMES.length)] + '·' + f + '层';
    } else {
        var roll = Math.random();
        if (roll < 0.003) {
            tierLabel = '【妖王】';
            eliteOrChiefScale = 1.4;
            rewardMult = 1.5;
            minSkills = 5;
        } else if (roll < 0.008) {
            tierLabel = '【首领】';
            eliteOrChiefScale = 1.35;
            rewardMult = 1.5;
            minSkills = 4;
        } else if (roll < 0.02) {
            tierLabel = '【头目】';
            eliteOrChiefScale = 1.25;
            rewardMult = 1.3;
            minSkills = 3;
        } else if (roll < 0.10) {
            tierLabel = '【精英】';
            eliteOrChiefScale = 1.15;
            rewardMult = 1.3;
            minSkills = 2;
        }
        var pool = ABYSS_MONSTER_PREFIXES.slice();
        prefix = pool[Math.floor(Math.random() * pool.length)];
        prefixes = [prefix];
        baseName = ABYSS_NORMAL_MONSTER_NAMES[Math.floor(Math.random() * ABYSS_NORMAL_MONSTER_NAMES.length)] + '·' + f + '层';
    }
    var monsterName = nameSuffix || (isBoss ? baseName : (tierLabel + (prefix ? prefix.name : '') + baseName));
    var monsterElement = ABYSS_ELEMENTS[Math.floor(Math.random() * ABYSS_ELEMENTS.length)];
    var monsterElementRes = { metal: 0, wood: 0, water: 0, fire: 0, earth: 0 };
    for (var ei = 0; ei < ABYSS_ELEMENTS.length; ei++) {
        var el = ABYSS_ELEMENTS[ei];
        monsterElementRes[el] = Math.min(40, Math.floor(f / 3) + Math.floor(Math.random() * 6));
    }
    var magicRes = isBoss ? Math.min(50, 10 + Math.floor(f / 3) + Math.floor(Math.random() * 13)) : Math.min(40, 5 + Math.floor(f / 4) + Math.floor(Math.random() * 9));
    // 普通怪物：应用前缀词条属性加成（精英/头目再乘额外倍率）
    if (!isBoss && prefix) {
        hp = Math.max(1, Math.floor(hp * (prefix.hpMult || 1) * eliteOrChiefScale));
        atk = Math.max(1, Math.floor(atk * (prefix.atkMult || 1) * eliteOrChiefScale));
        def = Math.max(0, Math.floor(def * (prefix.defMult || 1) * eliteOrChiefScale));
    }
    var baseCrit = 5 + Math.min(25, Math.floor(f / 5));
    var baseDodge = Math.min(15, Math.floor(f / 10));
    var baseLifesteal = Math.min(10, Math.floor(f / 15));
    if (!isBoss && prefix) {
        baseCrit = Math.max(0, baseCrit + (prefix.critRate || 0));
        baseDodge = Math.max(0, Math.min(30, baseDodge + (prefix.dodge || 0)));
        baseLifesteal = Math.max(0, Math.min(25, baseLifesteal + (prefix.lifesteal || 0)));
    }
    var normMultiHit = 0.1;
    if (!isBoss && prefix && prefix.multiHit) normMultiHit += prefix.multiHit;
    var mon = {
        name: monsterName,
        hp: hp, maxHp: hp, atk: atk, def: def, critRate: baseCrit, critDmg: 150, dodge: baseDodge, lifesteal: baseLifesteal, combo: Math.min(15, Math.floor(f / 8)),
        isBoss: isBoss, multiHit: isBoss ? 0.25 : normMultiHit, halfDamage: isBoss ? Math.min(0.65, 0.3 + (f / 10) * 0.02) : 0, skills: [],
        element: monsterElement, elementRes: monsterElementRes, magicRes: magicRes
    };
    if (!isBoss && prefix) {
        if (prefix.welfareReward) mon.welfareReward = prefix.welfareReward;
        if (rewardMult > 1) mon.rewardMult = rewardMult;
    }
    if (isBoss) {
        mon.revived = false;
        mon.summonCount = 0;
        var tier = Math.floor(f / 10);
        var numSkills = Math.min(ABYSS_BOSS_SKILLS.length, 2 + Math.floor(tier / 2) + Math.min(3, Math.floor(tier / 15)));
        if (numSkills < 2) numSkills = 2;
        if (f >= 10 && numSkills < 5) numSkills = 5;
        var pool = ABYSS_BOSS_SKILLS.filter(function(s) { return (s.minTier || 0) <= tier; });
        if (pool.length === 0) pool = ABYSS_BOSS_SKILLS.slice();
        var summonPool = pool.filter(function(s) { return s.id === 'bossSummon'; });
        if (summonPool.length > 0) {
            var summonPick = summonPool[Math.floor(Math.random() * summonPool.length)];
            mon.skills.push(summonPick);
            var idxInPool = pool.indexOf(summonPick);
            if (idxInPool >= 0) pool.splice(idxInPool, 1);
        }
        for (var s = mon.skills.length; s < numSkills && pool.length > 0; s++) {
            var idx = Math.floor(Math.random() * pool.length);
            var picked = pool[idx];
            mon.skills.push(picked);
            pool.splice(idx, 1);
        }
        for (var hdi = 0; hdi < mon.skills.length; hdi++) {
            var hds = mon.skills[hdi];
            if (hds.id === 'halfDamage') {
                mon.halfDamage = Math.min(hds.maxRate != null ? hds.maxRate : 0.8, (mon.halfDamage || 0) + (hds.rate || 0));
                break;
            }
        }
        mon.shield = Math.floor(mon.maxHp * 0.15);
        for (var si = 0; si < mon.skills.length; si++) {
            if (mon.skills[si].id === 'shield' && (mon.skills[si].shieldPct || 0) > 0.15) {
                mon.shield = Math.max(mon.shield, Math.floor(mon.maxHp * (mon.skills[si].shieldPct || 0.2)));
                break;
            }
        }
    } else {
        var numNorm = Math.max(minSkills, 1 + Math.min(5, Math.floor(f / 8)));
        var normPool = ABYSS_NORMAL_MONSTER_SKILLS.slice();
        for (var sn = 0; sn < numNorm && normPool.length > 0; sn++) {
            var nidx = Math.floor(Math.random() * normPool.length);
            var npick = normPool[nidx];
            mon.skills.push(npick);
            normPool.splice(nidx, 1);
        }
        for (var nsi = 0; nsi < mon.skills.length; nsi++) {
            if (mon.skills[nsi].id === 'shield') {
                mon.shield = Math.floor(mon.maxHp * (mon.skills[nsi].shieldPct || 0.08));
                break;
            }
        }
        if (!mon.shield) mon.shield = 0;
    }
    return mon;
}

function abyssSpawnMonster() {
    if (!abyssRun || !abyssRun.active) return;
    var f = abyssRun.floor;
    var isBoss = (f % 10 === 0);
    abyssRun.monsters = [];
    if (isBoss) {
        abyssRun.monsters.push(abyssCreateOneMonster(f, true));
    } else {
        var count = 1 + Math.floor(Math.random() * 4);
        for (var i = 0; i < count; i++) {
            abyssRun.monsters.push(abyssCreateOneMonster(f, false));
        }
    }
    abyssRun.playerTargetIndex = 0;
    abyssRun.monster = abyssRun.monsters[0];
}

function abyssGetAliveMonsters() {
    if (!abyssRun || !abyssRun.monsters) return [];
    return abyssRun.monsters.filter(function(m) { return m && m.hp > 0; });
}

function abyssEnsurePlayerTarget() {
    if (!abyssRun || !abyssRun.monsters) return null;
    var curIdx = abyssRun.playerTargetIndex;
    if (typeof curIdx === 'number' && curIdx >= 0 && curIdx < abyssRun.monsters.length) {
        var m = abyssRun.monsters[curIdx];
        if (m && m.hp > 0) {
            abyssRun.monster = m;
            return abyssRun.monster;
        }
    }
    for (var i = 0; i < abyssRun.monsters.length; i++) {
        if (abyssRun.monsters[i] && abyssRun.monsters[i].hp > 0) {
            abyssRun.playerTargetIndex = i;
            abyssRun.monster = abyssRun.monsters[i];
            return abyssRun.monster;
        }
    }
    return null;
}

function abyssCalcVaultBonuses() {
    var at = getAbyssTower();
    var vault = at.abyssVault || {};
    var v = { atkPct: 0, hpPct: 0, defPct: 0, critRatePct: 0, critDmgPct: 0, dodgePct: 0, lifestealPct: 0, petAtkPct: 0, petDefPct: 0, petHpPct: 0, goldPct: 0, expPct: 0 };
    ABYSS_VAULT_TREASURES.forEach(function(t) {
        var c = vault[t.id] || 0;
        if (c <= 0) return;
        var e = t.effect;
        if (e.type === 'atkVaultPct') v.atkPct += e.value * c;
        else if (e.type === 'hpVaultPct') v.hpPct += e.value * c;
        else if (e.type === 'defVaultPct') v.defPct += e.value * c;
        else if (e.type === 'critDmgVaultPct') v.critDmgPct += e.value * c;
        else if (e.type === 'petAtkVaultPct') v.petAtkPct += e.value * c;
        else if (e.type === 'petHpVaultPct') v.petHpPct += e.value * c;
        else if (e.type === 'petDefVaultPct') v.petDefPct += e.value * c;
    });
    return v;
}

function abyssSetPlayerTarget(index) {
    if (!abyssRun || !abyssRun.monsters || index < 0 || index >= abyssRun.monsters.length) return;
    if (abyssRun.monsters[index].hp <= 0) return;
    abyssRun.playerTargetIndex = index;
    abyssRun.monster = abyssRun.monsters[index];
    updateAbyssRunUI();
}

function updateAbyssRunUI() {
    if (!abyssRun || !abyssRun.active) return;
    abyssRun.runLevel = Math.floor((abyssRun.exp || 0) / 100);
    if (abyssRun.runLevel > (abyssRun.lastGrantedTalentLevel || 0)) {
        var add = abyssRun.runLevel - (abyssRun.lastGrantedTalentLevel || 0);
        abyssRun.talentPoints = (abyssRun.talentPoints || 0) + add;
        abyssRun.lastGrantedTalentLevel = abyssRun.runLevel;
    }
    var runZhuan = abyssZhuan(abyssRun.runLevel || 0);
    if (runZhuan >= 2 && !abyssRun.classBranch) {
        abyssShowBranchSelection();
        return;
    }
    var stats = abyssCalcPlayerStats();
    if (!stats) return;
    abyssEnsurePlayerTarget();
    document.getElementById('abyssCurrentFloor').textContent = abyssRun.floor;
    var levelEl = document.getElementById('abyssPlayerLevel');
    if (levelEl) levelEl.textContent = abyssRun.runLevel || 0;
    document.getElementById('abyssPlayerHp').textContent = formatNumber(abyssRun.player.hp);
    document.getElementById('abyssPlayerMaxHp').textContent = formatNumber(stats.maxHp);
    var shieldVal = abyssRun.player.shield || 0;
    var shieldWrap = document.getElementById('abyssPlayerShieldWrap');
    var shieldEl = document.getElementById('abyssPlayerShield');
    if (shieldWrap && shieldEl) {
        if (shieldVal > 0) { shieldWrap.style.display = ''; shieldEl.textContent = formatNumber(shieldVal); }
        else shieldWrap.style.display = 'none';
    }
    document.getElementById('abyssPlayerAtk').textContent = formatNumber(stats.atk);
    document.getElementById('abyssPlayerDef').textContent = formatNumber(stats.def);
    document.getElementById('abyssPlayerCritRate').textContent = abyssFmt1(stats.critRate) + '%';
    document.getElementById('abyssPlayerCritDmg').textContent = abyssFmt1(stats.critDmg) + '%';
    document.getElementById('abyssPlayerDodge').textContent = abyssFmt1(stats.dodge) + '%';
    document.getElementById('abyssPlayerLifesteal').textContent = abyssFmt1(stats.lifesteal) + '%';
    document.getElementById('abyssPlayerCombo').textContent = abyssFmt1(stats.combo) + '%';
    var skillDmgEl = document.getElementById('abyssPlayerSkillDmg');
    if (skillDmgEl) skillDmgEl.textContent = abyssFmt1(stats.skillDmg || 0) + '%';
    var reduceDefEl = document.getElementById('abyssPlayerReduceDef');
    if (reduceDefEl) reduceDefEl.textContent = abyssFmt1(stats.reduceMonsterDef || 0) + '%';
    var elAtkEl = document.getElementById('abyssPlayerElementAtk');
    if (elAtkEl && stats.elementAtk) {
        var fmt1 = function(v) { return (Math.floor((v || 0) * 10) / 10).toFixed(1); };
        elAtkEl.textContent = fmt1(stats.elementAtk.metal) + '/' + fmt1(stats.elementAtk.wood) + '/' + fmt1(stats.elementAtk.water) + '/' + fmt1(stats.elementAtk.fire) + '/' + fmt1(stats.elementAtk.earth);
    }
    var elResEl = document.getElementById('abyssPlayerElementRes');
    if (elResEl && stats.elementRes) elResEl.textContent = abyssFmt1(stats.elementRes.metal || 0) + '%/' + abyssFmt1(stats.elementRes.wood || 0) + '%/' + abyssFmt1(stats.elementRes.water || 0) + '%/' + abyssFmt1(stats.elementRes.fire || 0) + '%/' + abyssFmt1(stats.elementRes.earth || 0) + '%';
    var strAgiEl = document.getElementById('abyssPlayerStrAgiIntSta');
    if (strAgiEl) strAgiEl.textContent = (stats.str || 0) + '/' + (stats.agi || 0) + '/' + (stats.int || 0) + '/' + (stats.sta || 0);
    var expEl = document.getElementById('abyssPlayerExp');
    if (expEl) expEl.textContent = formatNumber(abyssRun.exp || 0);
    var b = abyssRun.buffs || {};
    var vB = abyssCalcVaultBonuses();
    var setBonus = function(id, v) { var el = document.getElementById(id); if (el) el.textContent = (v != null ? v : 0); };
    setBonus('abyssBonusAtk', (b.atkPct || 0) + vB.atkPct);
    setBonus('abyssBonusHp', (b.hpPct || 0) + vB.hpPct);
    setBonus('abyssBonusDef', (b.defPct || 0) + vB.defPct);
    setBonus('abyssBonusLifesteal', (b.lifestealPct || 0) + vB.lifestealPct);
    setBonus('abyssBonusCritRate', (b.critRatePct || 0) + vB.critRatePct);
    setBonus('abyssBonusCritDmg', (b.critDmgPct || 0) + vB.critDmgPct);
    setBonus('abyssBonusDodge', (b.dodgePct || 0) + vB.dodgePct);
    setBonus('abyssBonusPetAtk', (b.petAtkPct || 0) + vB.petAtkPct);
    setBonus('abyssBonusPetDef', (b.petDefPct || 0) + vB.petDefPct);
    setBonus('abyssBonusPetHp', (b.petHpPct || 0) + vB.petHpPct);
    setBonus('abyssBonusGold', (b.goldPct || 0) + vB.goldPct);
    setBonus('abyssBonusExp', (b.expPct || 0) + vB.expPct);
    var curseTrialEl = document.getElementById('abyssCurseTrialHint');
    if (curseTrialEl) {
        var hints = [];
        if (abyssRun.curseRounds > 0) hints.push('☠诅咒·奖励 剩余' + abyssRun.curseRounds + '层');
        if (abyssRun.trialId && abyssRun.trialRoundsLeft > 0) hints.push('⚔试炼:' + (abyssRun.trialId === 'noPotion' ? '禁药' : abyssRun.trialId === 'normalAtk' ? '纯武' : abyssRun.trialId === 'noPet' ? '孤狼' : '险境') + ' 剩余' + abyssRun.trialRoundsLeft + '层');
        curseTrialEl.textContent = hints.length ? hints.join(' | ') : '';
    }
    var zhuanEl = document.getElementById('abyssPlayerZhuan');
    if (zhuanEl) zhuanEl.textContent = stats.zhuan ? ' (' + abyssZhuanTitle(abyssRun.playerClass, stats.zhuan, abyssRun.classBranch) + ')' : '';
    var maxMp = stats.maxMp != null ? stats.maxMp : abyssMaxMpForLevel(abyssRun.runLevel || 0);
    abyssRun.player.mp = Math.min(maxMp, Math.max(0, abyssRun.player.mp != null ? abyssRun.player.mp : 50));
    var mpEl = document.getElementById('abyssPlayerMp');
    var maxMpEl = document.getElementById('abyssPlayerMaxMp');
    if (mpEl) mpEl.textContent = formatNumber(Math.floor(abyssRun.player.mp));
    if (maxMpEl) maxMpEl.textContent = formatNumber(maxMp);
    var mpPct = maxMp > 0 ? (abyssRun.player.mp / maxMp * 100) : 0;
    var mpBarEl = document.getElementById('abyssPlayerMpBar');
    if (mpBarEl) mpBarEl.style.width = mpPct + '%';
    var hpPct = stats.maxHp > 0 ? (abyssRun.player.hp / stats.maxHp * 100) : 0;
    document.getElementById('abyssPlayerHpBar').style.width = hpPct + '%';
    var container = document.getElementById('abyssMonstersContainer');
    if (container) {
        if (abyssRun.monsters && abyssRun.monsters.length) {
        container.innerHTML = '';
        for (var mi = 0; mi < abyssRun.monsters.length; mi++) {
            var m = abyssRun.monsters[mi];
            var isDead = !m || m.hp <= 0;
            var isTarget = (abyssRun.playerTargetIndex === mi);
            var card = document.createElement('div');
            card.style.cssText = 'min-width:140px;padding:10px;border-radius:10px;border:2px solid ' + (isTarget ? '#ffd700' : '#ff6b6b') + ';background:rgba(255,107,107,' + (isDead ? 0.05 : 0.15) + ');cursor:' + (isDead ? 'default' : 'pointer') + ';opacity:' + (isDead ? 0.6 : 1) + ';';
            card.onclick = (function(idx) { return function() { if (abyssRun.monsters[idx] && abyssRun.monsters[idx].hp > 0) abyssSetPlayerTarget(idx); }; })(mi);
            var nameLine = (m.element ? '[' + (ABYSS_ELEMENT_NAMES[m.element] || m.element) + '] ' : '') + (m.name || '') + (m.isBoss ? ' [BOSS]' : '');
            if (isTarget) nameLine += ' ←目标';
            card.innerHTML = '<div style="color:#ff6b6b;font-weight:bold;font-size:12px;margin-bottom:4px;">' + nameLine + '</div>' +
                '<div style="font-size:11px;">生命: ' + formatNumber(m.hp) + (m.shield > 0 ? ' (盾' + formatNumber(m.shield) + ')' : '') + '/' + formatNumber(m.maxHp) + '</div>' +
                '<div style="height:6px;background:#333;border-radius:3px;margin-top:4px;overflow:hidden;"><div style="height:100%;background:linear-gradient(90deg,#ff6b6b,#ffd700);width:' + (m.maxHp > 0 ? Math.max(0, (m.hp + (m.shield || 0)) / (m.maxHp + (m.shield || 0)) * 100) : 0) + '%;border-radius:3px;"></div></div>' +
                '<div style="margin-top:4px;font-size:10px;color:#aaa;">' + (m.isBoss ? '深渊护盾 ' : '') + (m.skills && m.skills.length ? m.skills.slice(0, 3).map(function(s){return s.name;}).join(' ') : '') + '</div>' +
                (function(){ var res = []; if (m.elementRes) { for (var ei = 0; ei < ABYSS_ELEMENTS.length; ei++) { var el = ABYSS_ELEMENTS[ei]; var v = m.elementRes[el]; if (v > 0) res.push((ABYSS_ELEMENT_NAMES[el] || el) + '抗' + v + '%'); } } if ((m.magicRes || 0) > 0) res.push('魔抗' + m.magicRes + '%'); return res.length ? '<div style="margin-top:2px;font-size:9px;color:#8a8;">' + res.join(' ') + '</div>' : ''; })();
            container.appendChild(card);
        }
        } else {
            container.innerHTML = '';
        }
    }
    var autoStatusEl = document.getElementById('abyssAutoAttackStatus');
    if (autoStatusEl) autoStatusEl.textContent = abyssRun.autoAttack ? '开' : '关';
    var skillRow = document.getElementById('abyssSkillRow');
    if (skillRow) {
        skillRow.innerHTML = '';
        var classId = abyssRun.playerClass || 'warrior';
        var equipped = abyssRun.equippedSkillIds || [null, null, null];
        var learned = abyssRun.learnedSkillIds || [];
        var currentMp = abyssRun.player.mp != null ? abyssRun.player.mp : 50;
        for (var ei = 0; ei < equipped.length; ei++) {
            var sid = equipped[ei];
            if (sid == null || sid === '' || learned.indexOf(sid) < 0) {
                var emptyBtn = document.createElement('button');
                emptyBtn.type = 'button';
                emptyBtn.textContent = '空';
                emptyBtn.style.cssText = 'background:#333;color:#666;border:1px solid #555;padding:8px 14px;border-radius:6px;cursor:default;font-size:12px;';
                emptyBtn.title = '在技能界面学习并装备技能';
                skillRow.appendChild(emptyBtn);
                continue;
            }
            var sk = abyssGetSkillById(classId, sid);
            if (!sk) continue;
            var cd = abyssRun.skillCooldowns && abyssRun.skillCooldowns[sk.id];
            var mpCost = sk.mpCost || 0;
            var ready = (cd === undefined || cd <= 0) && currentMp >= mpCost;
            var btn = document.createElement('button');
            btn.type = 'button';
            btn.title = (sk.desc || '') + (mpCost ? ' 消耗' + mpCost + '魔法' : '');
            btn.textContent = sk.name + (ready ? ' (就绪)' : (cd > 0 ? ' CD' + cd : ' (魔不足)'));
            btn.style.cssText = 'background:' + (ready ? 'linear-gradient(145deg,#6a0dad,#4a0072)' : '#444') + ';color:#fff;border:1px solid #b388ff;padding:8px 14px;border-radius:6px;cursor:' + (ready ? 'pointer' : 'default') + ';font-size:12px;';
            if (ready) btn.onclick = (function(sid) { return function() { abyssRun.nextSkillId = sid; abyssLog('下次攻击将释放技能'); updateAbyssRunUI(); }; })(sk.id);
            skillRow.appendChild(btn);
        }
    }
    document.getElementById('abyssShopBtn').style.display = abyssRun.justKilledBoss ? 'inline-block' : 'none';
    var deployedPetEl = document.getElementById('abyssDeployedPetInfo');
    if (deployedPetEl) {
        var deployedList = abyssGetDeployedPets();
        if (deployedList.length > 0) {
            var parts = [];
            for (var di = 0; di < deployedList.length; di++) {
                var dp = deployedList[di];
                var dps = abyssCalcPetStats(dp);
                var dphp = dp.hp !== null ? Math.max(0, dp.hp) : (dps ? dps.maxHp : 0);
                var dpmax = dps ? dps.maxHp : 0;
                parts.push(dp.name + ' ' + formatNumber(dphp) + '/' + formatNumber(dpmax));
            }
            deployedPetEl.textContent = '出战宠物: ' + parts.join(' | ');
        } else {
            deployedPetEl.textContent = '出战宠物: 无';
        }
    }
    var guardBtn = document.getElementById('abyssPetGuardBtn');
    if (guardBtn) guardBtn.textContent = (abyssRun.petGuard ? '守护: 开' : '守护: 关');
    var guardBtnPanel = document.getElementById('abyssPetGuardBtnPanel');
    if (guardBtnPanel) guardBtnPanel.textContent = (abyssRun.petGuard ? '守护: 开' : '守护: 关');
}
function abyssTogglePetGuard() {
    if (!abyssRun || !abyssRun.active) return;
    abyssRun.petGuard = !abyssRun.petGuard;
    var guardBtn = document.getElementById('abyssPetGuardBtn');
    if (guardBtn) guardBtn.textContent = (abyssRun.petGuard ? '守护: 开' : '守护: 关');
    var guardBtnPanel = document.getElementById('abyssPetGuardBtnPanel');
    if (guardBtnPanel) guardBtnPanel.textContent = (abyssRun.petGuard ? '守护: 开' : '守护: 关');
    abyssLog(abyssRun.petGuard ? '已开启守护：怪物优先攻击宠物' : '已关闭守护：怪物随机攻击');
}

function abyssLog(msg) {
    var el = document.getElementById('abyssBattleLog');
    if (!el) return;
    var div = document.createElement('div');
    div.style.marginBottom = '4px';
    div.style.fontSize = '12px';
    div.style.color = '#ccc';
    div.textContent = msg;
    el.appendChild(div);
    el.scrollTop = el.scrollHeight;
    while (el.children.length > 80) el.removeChild(el.firstChild);
}

var abyssAutoAttackInterval = null;
function toggleAbyssAutoAttack() {
    if (!abyssRun || !abyssRun.active) return;
    abyssRun.autoAttack = !abyssRun.autoAttack;
    var statusEl = document.getElementById('abyssAutoAttackStatus');
    if (statusEl) statusEl.textContent = abyssRun.autoAttack ? '开' : '关';
    if (abyssRun.autoAttack) {
        if (abyssAutoAttackInterval) clearInterval(abyssAutoAttackInterval);
        abyssAutoAttackInterval = registerInterval(function() {
            if (!abyssRun || !abyssRun.active || abyssRun.pendingChoice || abyssRun.pendingUpgradeChoice || !abyssRun.monster) {
                stopAbyssAutoAttack();
                return;
            }
            abyssAttack();
        }, 350);
    } else {
        stopAbyssAutoAttack();
    }
}
function stopAbyssAutoAttack() {
    if (abyssRun) abyssRun.autoAttack = false;
    var statusEl = document.getElementById('abyssAutoAttackStatus');
    if (statusEl) statusEl.textContent = '关';
    if (abyssAutoAttackInterval) {
        clearInterval(abyssAutoAttackInterval);
        abyssAutoAttackInterval = null;
    }
}
function abyssAttack() {
    if (!abyssRun || !abyssRun.active || abyssRun.pendingChoice || abyssRun.pendingUpgradeChoice) return;
    if (!abyssRun.monsters || abyssGetAliveMonsters().length === 0) return;
    abyssEnsurePlayerTarget();
    if (!abyssRun.monster) return;
    var runLevel = Math.floor((abyssRun.exp || 0) / 100);
    var maxMp = abyssMaxMpForLevel(runLevel);
    for (var sid in abyssRun.skillCooldowns) {
        abyssRun.skillCooldowns[sid]--;
        if (abyssRun.skillCooldowns[sid] <= 0) delete abyssRun.skillCooldowns[sid];
    }
    abyssRun.roundCount = (abyssRun.roundCount || 0) + 1;
    if (abyssRun.skipPlayerTurn > 0) { abyssRun.skipPlayerTurn--; abyssRun._skipThisTurn = true; abyssLog('时空凝滞！你本回合无法行动'); }
    abyssRun.thisRoundDodgeBonus = 0;
    abyssRun.thisRoundReduceDmg = 0;
    abyssRun.thisRoundCounterPct = 0;
    if (abyssRun.buffs && abyssRun.buffs.roundsLeft > 0 && abyssRun.buffs.reduceDmgPct != null) abyssRun.thisRoundReduceDmg = abyssRun.buffs.reduceDmgPct;
    var useSkill = null;
    var classId = abyssRun.playerClass || 'warrior';
    var skillList = abyssGetSkillList(classId, abyssRun.classBranch);
    var currentMp = abyssRun.player.mp != null ? abyssRun.player.mp : 50;
    var equipped = abyssRun.equippedSkillIds || [null, null, null];
    var learned = abyssRun.learnedSkillIds || [];
    var nextId = abyssRun.nextSkillId;
    if (abyssRun.playerSilenced > 0) { nextId = null; abyssRun.playerSilenced--; abyssLog('静默中，本回合无法使用技能'); }
    if (abyssRun.trialId === 'normalAtk' && abyssRun.trialRoundsLeft > 0) { nextId = null; if (abyssRun.nextSkillId) { abyssRun.nextSkillId = null; abyssLog('纯武试炼：本回合无法使用技能'); } }
    var isEquipped = nextId && (equipped.indexOf(nextId) >= 0);
    var isLearned = nextId && (learned.indexOf(nextId) >= 0);
    if (abyssRun.nextSkillId && nextId && skillList && isEquipped && isLearned) {
        for (var si = 0; si < skillList.length; si++) {
            if (skillList[si].id === abyssRun.nextSkillId) {
                var sk = skillList[si];
                var cd = abyssRun.skillCooldowns[abyssRun.nextSkillId];
                var mpCost = sk.mpCost || 0;
                if ((cd === undefined || cd <= 0) && currentMp >= mpCost) {
                    useSkill = sk;
                    abyssRun.skillCooldowns[useSkill.id] = useSkill.cooldown;
                    abyssRun.nextSkillId = null;
                    abyssRun.player.mp = Math.max(0, currentMp - mpCost);
                    abyssLog('【' + useSkill.name + '】消耗' + (mpCost || 0) + '魔法');
                    if (useSkill.summonBeast && useSkill.summonPct != null) {
                        var st = abyssCalcPlayerStats();
                        if (st) {
                            abyssRun.beastSummons = abyssRun.beastSummons || [];
                            var cap = (useSkill.archerSummon || classId === 'archer') ? ABYSS_ARCHER_SUMMON_CAP : (useSkill.summonMax || 1);
                            var currentAlive = abyssRun.beastSummons.filter(function(b) { return b && b.hp > 0; }).length;
                            if (currentAlive < cap) {
                                var name_ = useSkill.summonName || '战兽';
                                var pct = useSkill.summonPct || 0.2;
                                abyssRun.beastSummons.push({
                                    name: name_,
                                    hp: Math.max(1, Math.floor(st.maxHp * pct)),
                                    maxHp: Math.max(1, Math.floor(st.maxHp * pct)),
                                    atk: Math.max(1, Math.floor(st.atk * pct)),
                                    def: Math.floor(st.def * pct)
                                });
                                abyssLog('召唤【' + name_ + '】');
                            }
                        }
                    }
                    if (useSkill.mpRegenPct != null) {
                        var maxMp0 = abyssMaxMpForLevel(runLevel);
                        abyssRun.player.mp = Math.min(maxMp0, (abyssRun.player.mp || 0) + Math.floor(maxMp0 * useSkill.mpRegenPct));
                        abyssRun.buffs = abyssRun.buffs || {};
                        abyssRun.buffs.skillDmgBonus = useSkill.skillDmgBonus || 0;
                        abyssRun.buffs.roundsLeft = Math.max(abyssRun.buffs.roundsLeft || 0, 2);
                    }
                    if (useSkill.counterPct != null) abyssRun.thisRoundCounterPct = useSkill.counterPct;
                    if (useSkill.reduceDmgPct != null && useSkill.buffRounds != null) {
                        abyssRun.buffs = abyssRun.buffs || {};
                        abyssRun.buffs.reduceDmgPct = useSkill.reduceDmgPct;
                        abyssRun.buffs.roundsLeft = Math.max(abyssRun.buffs.roundsLeft || 0, useSkill.buffRounds);
                    }
                } else if (currentMp < mpCost) {
                    abyssLog('魔法值不足，需要' + mpCost + '点');
                }
                if (!useSkill) abyssRun.nextSkillId = null;
                break;
            }
        }
    }
    var stats = abyssCalcPlayerStats();
    if (!stats) return;
    if (abyssRun.playerBurning && abyssRun.playerBurning.rounds > 0) {
        var dotDmg = Math.floor(stats.maxHp * (abyssRun.playerBurning.rate || 0.05));
        abyssRun.player.hp = (abyssRun.player.hp || 0) - dotDmg;
        abyssRun.playerBurning.rounds--;
        abyssLog('灼烧造成 ' + formatNumber(dotDmg) + ' 伤害' + (abyssRun.playerBurning.rounds > 0 ? '（剩余' + abyssRun.playerBurning.rounds + '回合）' : ''));
        if (abyssRun.playerBurning.rounds <= 0) abyssRun.playerBurning = null;
        if (abyssRun.player.hp <= 0) { stopAbyssAutoAttack(); abyssOnPlayerDeath(); return; }
    }
    if (abyssRun.playerSoulDrain && abyssRun.playerSoulDrain.rounds > 0) {
        var soulDmg = Math.floor(stats.maxHp * (abyssRun.playerSoulDrain.rate || 0.04));
        abyssRun.player.hp = (abyssRun.player.hp || 0) - soulDmg;
        abyssRun.playerSoulDrain.rounds--;
        abyssLog('魂噬造成 ' + formatNumber(soulDmg) + ' 伤害' + (abyssRun.playerSoulDrain.rounds > 0 ? '（剩余' + abyssRun.playerSoulDrain.rounds + '回合）' : ''));
        if (abyssRun.playerSoulDrain.rounds <= 0) abyssRun.playerSoulDrain = null;
        if (abyssRun.player.hp <= 0) { stopAbyssAutoAttack(); abyssOnPlayerDeath(); return; }
    }
    var m = abyssRun.monster;
    var effDef = m.def * (1 - (stats.reduceMonsterDef || 0) / 100);
    if (useSkill && useSkill.ignoreDefPct) effDef = effDef * (1 - useSkill.ignoreDefPct / 100);
    var baseDmg = abyssRun._skipThisTurn ? (abyssRun._skipThisTurn = false, 0) : Math.max(1, stats.atk - Math.floor(effDef * 0.5));
    var crit = (useSkill && useSkill.forceCrit) || (Math.random() * 100 < stats.critRate);
    if (crit) baseDmg = Math.floor(baseDmg * (1 + stats.critDmg / 100));
    var combo = Math.random() * 100 < stats.combo;
    if (combo) baseDmg = Math.floor(baseDmg * 1.5);
    var skillBonus = 1 + ((stats.skillDmg || 0) + (abyssRun.buffs && abyssRun.buffs.skillDmgBonus ? abyssRun.buffs.skillDmgBonus : 0)) / 100;
    if (useSkill && useSkill.skillDmgBonus) skillBonus = 1 + (stats.skillDmg + useSkill.skillDmgBonus) / 100;
    baseDmg = Math.floor(baseDmg * skillBonus);
    if (useSkill && useSkill.dmgMult && !useSkill.multiHit && !(useSkill.aoe)) baseDmg = Math.floor(baseDmg * useSkill.dmgMult);
    var playerMainElement = null;
    if (stats.elementAtk) {
        var maxAtk = 0;
        for (var ex = 0; ex < ABYSS_ELEMENTS.length; ex++) {
            var el = ABYSS_ELEMENTS[ex];
            if ((stats.elementAtk[el] || 0) > maxAtk) { maxAtk = stats.elementAtk[el]; playerMainElement = el; }
        }
    }
    if (useSkill && useSkill.aoe) {
        if (useSkill.dodgeBonus) abyssRun.thisRoundDodgeBonus = useSkill.dodgeBonus;
        var aoePct = useSkill.aoePct || 0.7;
        if (useSkill.dmgMult) baseDmg = Math.floor(baseDmg * useSkill.dmgMult);
        abyssLog('【' + useSkill.name + '】群体攻击！');
        var aliveAoe = abyssGetAliveMonsters();
        var totalAoeDmg = 0;
        for (var ai = 0; ai < aliveAoe.length; ai++) {
            var tm = aliveAoe[ai];
            var fd = Math.floor(baseDmg * aoePct * (1 - (tm.halfDamage || 0)));
            if (playerMainElement && tm.element) {
                fd = Math.floor(fd * abyssElementRestrainMultiplier(playerMainElement, tm.element));
                var tr = (tm.elementRes && tm.elementRes[playerMainElement]) ? tm.elementRes[playerMainElement] : 0;
                fd = Math.floor(fd * (1 - Math.min(75, tr) / 100));
            }
            fd = Math.max(1, fd);
            if (useSkill && (tm.magicRes || 0) > 0) { fd = Math.floor(fd * (1 - Math.min(75, tm.magicRes) / 100)); fd = Math.max(1, fd); }
            if (tm.skills && tm.skills.length) { for (var si = 0; si < tm.skills.length; si++) { if (tm.skills[si].id === 'intimidate') { fd = Math.floor(fd * (1 - (tm.skills[si].dmgReduce || 0.15))); fd = Math.max(1, fd); break; } } }
            var rem = fd;
            if (tm.shield > 0) { var ts = Math.min(tm.shield, rem); tm.shield -= ts; rem -= ts; }
            if (rem > 0) tm.hp -= rem;
            if (tm.isBoss && tm.hp > 0 && tm.hp < tm.maxHp * 0.5 && !tm.secondPhase) {
                tm.secondPhase = true;
                tm.atk = Math.floor((tm.atk || 0) * 1.28);
                tm.def = Math.floor((tm.def || 0) * 1.22);
                tm.dodge = Math.min(45, (tm.dodge || 0) + 18);
                abyssLog(tm.name + ' 进入第二阶段！实力与闪避大幅提升');
            }
            if (useSkill.stunChance && Math.random() < useSkill.stunChance) { tm.stunned = (tm.stunned || 0) + (useSkill.stunTurns || 1); }
            totalAoeDmg += fd;
        }
        abyssLog('对全部怪物共造成 ' + formatNumber(totalAoeDmg) + ' 伤害');
        for (var di = abyssRun.monsters.length - 1; di >= 0; di--) {
            var dm = abyssRun.monsters[di];
            if (dm && dm.hp <= 0) {
                var usedSurviveAoe = false;
                if (dm.skills && !dm.surviveOneDeathUsed) for (var sod2 = 0; sod2 < dm.skills.length; sod2++) { if (dm.skills[sod2].id === 'surviveOneDeath') { dm.hp = 1; dm.surviveOneDeathUsed = true; usedSurviveAoe = true; abyssLog(dm.name + ' 不溃！保留1点生命'); break; } }
                if (usedSurviveAoe) continue;
                var hasRev = false;
                if (dm.skills && dm.skills.length && !dm.revived) for (var rvi = 0; rvi < dm.skills.length; rvi++) { if (dm.skills[rvi].id === 'revive') { hasRev = true; break; } }
                if (hasRev) { var revSk = null; for (var rvx = 0; rvx < dm.skills.length; rvx++) if (dm.skills[rvx].id === 'revive') { revSk = dm.skills[rvx]; break; } dm.revived = true; dm.hp = Math.floor(dm.maxHp * (revSk && revSk.revivePct != null ? revSk.revivePct : 0.25)); abyssLog(dm.name + ' 发动复活！恢复' + ((revSk && revSk.revivePct != null ? revSk.revivePct : 0.25) * 100).toFixed(0) + '%生命'); }
                else {
                    abyssPetGainExp(dm.isBoss ? 35 : (12 + Math.floor(Math.random() * 5)));
                    if (!dm.isBoss) {
                        var welf = dm.welfareReward || 1;
                        var rewardM = dm.rewardMult || 1;
                        var normExp = (10 + Math.floor(Math.random() * 6)) * welf * rewardM;
                        var normGold = (21 + Math.floor(Math.random() * 11)) * welf * rewardM;
                        var applied = abyssApplyExpGoldBonus(normExp, normGold);
                        abyssRun.exp = (abyssRun.exp || 0) + applied.exp;
                        abyssRun.gold = (abyssRun.gold || 0) + applied.gold;
                        abyssLog('获得经验 ' + applied.exp + '，闯关金币 ' + applied.gold);
                        if (abyssCheckLevelUp()) { if (abyssGetAliveMonsters().length === 0) abyssOnKillMonster(); else abyssRun.monsters.splice(di, 1); return; }
                        if (Math.random() < 0.1) {
                            abyssRun.materials.potion = (abyssRun.materials.potion || 0) + 1;
                            abyssLog('获得生命药剂 x1');
                        }
                        if (Math.random() < 0.1) {
                            abyssRun.materials.upgradeStone = (abyssRun.materials.upgradeStone || 0) + 1;
                            abyssLog('获得升级石 x1');
                        }
                        if (Math.random() < 0.08) {
                            var runeId = ABYSS_RUNES[Math.floor(Math.random() * ABYSS_RUNES.length)].id;
                            abyssRun.runeInventory = abyssRun.runeInventory || [];
                            abyssRun.runeInventory.push(runeId);
                            abyssLog('获得符文【' + (getAbyssRuneById(runeId) || {}).name + '】');
                        }
                        if (Math.random() < 0.08) {
                            var gemId = ABYSS_GEMS[Math.floor(Math.random() * ABYSS_GEMS.length)].id;
                            abyssRun.gemInventory = abyssRun.gemInventory || [];
                            abyssRun.gemInventory.push(gemId);
                            abyssLog('获得宝石【' + (getAbyssGemById(gemId) || {}).name + '】');
                        }
                    }
                    abyssRun.monsters.splice(di, 1);
                }
            }
        }
        if (abyssGetAliveMonsters().length === 0) { stopAbyssAutoAttack(); abyssOnKillMonster(); return; }
        abyssEnsurePlayerTarget();
        if (useSkill.lifestealPct && totalAoeDmg > 0) {
            var aoeHeal = Math.floor(totalAoeDmg * useSkill.lifestealPct);
            abyssRun.player.hp = Math.min(stats.maxHp, abyssRun.player.hp + aoeHeal);
            abyssLog('技能回复 ' + formatNumber(aoeHeal) + ' 生命');
        }
    } else {
    var finalDmg = Math.floor(baseDmg * (1 - m.halfDamage));
    if (playerMainElement && m.element) {
        finalDmg = Math.floor(finalDmg * abyssElementRestrainMultiplier(playerMainElement, m.element));
        var monRes = (m.elementRes && m.elementRes[playerMainElement]) ? m.elementRes[playerMainElement] : 0;
        finalDmg = Math.floor(finalDmg * (1 - Math.min(75, monRes) / 100));
    }
    finalDmg = Math.max(1, finalDmg);
    if (useSkill && useSkill.multiHit) {
        var pct = useSkill.multiHitPct || 0.85;
        var nHit = useSkill.multiHit || 2;
        finalDmg = 0;
        for (var hi = 0; hi < nHit; hi++) {
            var hit = Math.max(1, Math.floor(baseDmg * pct * (1 - m.halfDamage)));
            if (Math.random() * 100 < stats.critRate) hit = Math.floor(hit * (1 + stats.critDmg / 100));
            if (Math.random() * 100 < stats.combo) hit = Math.floor(hit * 1.5);
            finalDmg += hit;
        }
        if (playerMainElement && m.element) {
            finalDmg = Math.floor(finalDmg * abyssElementRestrainMultiplier(playerMainElement, m.element));
            var monResMulti = (m.elementRes && m.elementRes[playerMainElement]) ? m.elementRes[playerMainElement] : 0;
            finalDmg = Math.floor(finalDmg * (1 - Math.min(75, monResMulti) / 100));
        }
        finalDmg = Math.max(1, finalDmg);
    }
    if (m.skills && m.skills.length) {
        for (var si = 0; si < m.skills.length; si++) {
            if (m.skills[si].id === 'intimidate') { finalDmg = Math.floor(finalDmg * (1 - (m.skills[si].dmgReduce || 0.15))); finalDmg = Math.max(1, finalDmg); break; }
        }
    }
    if (useSkill && (m.magicRes || 0) > 0) { finalDmg = Math.floor(finalDmg * (1 - Math.min(75, m.magicRes) / 100)); finalDmg = Math.max(1, finalDmg); }
    for (var _ek in abyssRun.equipped) {
        var _eq = abyssRun.equipped[_ek];
        if (!_eq || !_eq.equipSkill || !_eq.equipSkill.effect) continue;
        var _eff = _eq.equipSkill.effect;
        if (_eff.extraDmgFromDef) finalDmg += Math.floor(stats.def * _eff.extraDmgFromDef);
        if (_eff.extraDmgFromMaxHp) finalDmg += Math.floor(stats.maxHp * _eff.extraDmgFromMaxHp);
        if (_eff.directPctMonsterHp) finalDmg += Math.floor(m.hp * _eff.directPctMonsterHp);
        if (_eff.extraDmgFromAtk) finalDmg += Math.floor(stats.atk * _eff.extraDmgFromAtk);
        if (_eff.directPctMonsterMaxHp) finalDmg += Math.floor(m.maxHp * _eff.directPctMonsterMaxHp);
    }
    finalDmg = Math.max(1, finalDmg);
    if (m.skills && m.skills.length) {
        for (var lssi = 0; lssi < m.skills.length; lssi++) {
            if (m.skills[lssi].id === 'lastStand' && m.hp < m.maxHp * (m.skills[lssi].lastStandThreshold || 0.15)) { finalDmg = Math.floor(finalDmg * 0.5); finalDmg = Math.max(1, finalDmg); break; }
        }
        for (var foi = 0; foi < m.skills.length; foi++) {
            if (m.skills[foi].id === 'foresight' && Math.random() * 100 < (m.skills[foi].dodgeBonus || 0)) { finalDmg = 0; abyssLog(m.name + ' 预知！闪避了攻击'); break; }
        }
    }
    if (finalDmg > 0 && (m.dodge || 0) > 0 && Math.random() * 100 < (m.dodge || 0)) { finalDmg = 0; abyssLog(m.name + ' 闪避了攻击'); }
    if (abyssRun.playerBlinded > 0) { finalDmg = 0; abyssRun.playerBlinded--; abyssLog('致盲中，本回合攻击落空'); }
    var remain = finalDmg;
    if (m.skills && m.skills.length) {
        for (var mii = 0; mii < m.skills.length; mii++) {
            if (m.skills[mii].id === 'mirrorImage' && Math.random() < (m.skills[mii].chance || 0.18)) {
                remain = Math.floor(remain * (1 - (m.skills[mii].imagePct || 0.2)));
                abyssLog(m.name + ' 幻身！减免部分伤害');
                break;
            }
        }
    }
    if (m.shield > 0) {
        var toShield = Math.min(m.shield, remain);
        m.shield -= toShield;
        remain -= toShield;
    }
    if (remain > 0) {
        if (m.skills && m.skills.length) {
            for (var bai = 0; bai < m.skills.length; bai++) {
                if (m.skills[bai].id === 'boneArmor') {
                    var boneRed = Math.min(remain, m.boneArmor || 0);
                    remain -= boneRed;
                    m.boneArmor = Math.max(0, (m.boneArmor || 0) - boneRed);
                    if (boneRed > 0) abyssLog(m.name + ' 骨甲吸收 ' + formatNumber(boneRed) + ' 伤害');
                    break;
                }
            }
        }
        m.hp -= remain;
        if (m.isBoss && m.hp > 0 && m.hp < m.maxHp * 0.5 && !m.secondPhase) {
            m.secondPhase = true;
            m.atk = Math.floor((m.atk || 0) * 1.28);
            m.def = Math.floor((m.def || 0) * 1.22);
            m.dodge = Math.min(45, (m.dodge || 0) + 18);
            abyssLog(m.name + ' 进入第二阶段！实力与闪避大幅提升');
        }
        if (m.skills && m.skills.length && remain > 0) {
            for (var sli = 0; sli < m.skills.length; sli++) {
                if (m.skills[sli].id === 'soulLink') {
                    var sharePct = m.skills[sli].damageSharePct || 0.15;
                    var linkDmg = Math.floor(remain * sharePct);
                    var others = abyssGetAliveMonsters().filter(function(x) { return x !== m && x.hp > 0; });
                    for (var oi = 0; oi < others.length && linkDmg > 0; oi++) {
                        var tm = others[oi];
                        tm.hp = Math.max(0, (tm.hp || 0) - linkDmg);
                        abyssLog(m.name + ' 魂链！' + tm.name + ' 分担 ' + formatNumber(linkDmg) + ' 伤害');
                    }
                    break;
                }
            }
        }
        if ((m.isSummon || (m.name && m.name.indexOf('仆从') >= 0)) && remain > 0) {
            var bossA = abyssGetAliveMonsters().filter(function(x) { return x.isBoss && x !== m && x.hp > 0; })[0];
            if (bossA && bossA.skills) for (var dai = 0; dai < bossA.skills.length; dai++) {
                if (bossA.skills[dai].id === 'deathAura') {
                    var healA = Math.floor(remain * (bossA.skills[dai].healOnAllyHitPct || 0.03));
                    if (healA > 0) { bossA.hp = Math.min(bossA.maxHp, (bossA.hp || 0) + healA); abyssLog(bossA.name + ' 死域！仆从受伤恢复 ' + formatNumber(healA)); }
                    break;
                }
            }
        }
        if (m.skills && m.skills.length) {
            for (var bai2 = 0; bai2 < m.skills.length; bai2++) {
                if (m.skills[bai2].id === 'boneArmor') {
                    var cap = m.skills[bai2].armorCap || 80;
                    m.boneArmor = Math.min(cap, (m.boneArmor || 0) + (m.skills[bai2].armorPerHit || 5));
                    break;
                }
            }
            for (var shi = 0; shi < m.skills.length; shi++) {
                if (m.skills[shi].id === 'shieldOnHit') {
                    var shAdd = Math.floor(remain * (m.skills[shi].shieldOnHitPct || 0.12));
                    if (shAdd > 0) { m.shield = (m.shield || 0) + shAdd; abyssLog(m.name + ' 噬能护甲！获得 ' + formatNumber(shAdd) + ' 护盾'); }
                    break;
                }
            }
            for (var csi = 0; csi < m.skills.length; csi++) {
                if (m.skills[csi].id === 'counterStrike') {
                    var refDmg = Math.floor(finalDmg * (m.skills[csi].counterBonus || 0.5));
                    if (refDmg > 0) { abyssRun.player.hp = Math.max(0, (abyssRun.player.hp || 0) - refDmg); abyssLog(m.name + ' 复仇！反击 ' + formatNumber(refDmg) + ' 伤害'); if (abyssRun.player.hp <= 0) { stopAbyssAutoAttack(); abyssOnPlayerDeath(); return; } }
                    break;
                }
            }
        }
    }
    if (m.skills && m.skills.length) {
        for (var csti = 0; csti < m.skills.length; csti++) { if (m.skills[csti].id === 'counterStrike') { m.counterStrikeNext = true; break; } }
    }
    if (m.skills && m.skills.length && m.hp < m.maxHp * 0.5) {
        for (var phi = 0; phi < m.skills.length; phi++) {
            var phs = m.skills[phi];
            if (phs.id === 'phaseAtHp' && !m.phaseTriggered) { m.phaseTriggered = true; m.atk = Math.floor(m.atk * (1 + (phs.phaseAtkBonus || 0.3))); abyssLog(m.name + ' 蜕皮！进入二阶段，攻击力提升'); break; }
        }
    }
    var logMsg = (crit ? '暴击 ' : '') + (combo ? '连击 ' : '') + '造成 ' + formatNumber(finalDmg) + ' 伤害';
    if (playerMainElement && m.element) {
        var mul = abyssElementRestrainMultiplier(playerMainElement, m.element);
        if (mul > 1) logMsg += ' [属性克制+35%]';
        else if (mul < 1) logMsg += ' [被克制-30%]';
    }
    abyssLog(logMsg);
    if (useSkill && useSkill.stunChance && Math.random() < useSkill.stunChance) {
        m.stunned = (m.stunned || 0) + (useSkill.stunTurns || 1);
        abyssLog('怪物被眩晕 ' + (useSkill.stunTurns || 1) + ' 回合！');
    }
    if (useSkill && useSkill.buffAtkPct) {
        abyssRun.buffs = abyssRun.buffs || {};
        abyssRun.buffs.atkPct = useSkill.buffAtkPct;
        abyssRun.buffs.roundsLeft = Math.max(abyssRun.buffs.roundsLeft || 0, useSkill.buffRounds || 2);
    }
    if (useSkill && (useSkill.buffCritRate != null || useSkill.buffCritDmg != null)) {
        abyssRun.buffs = abyssRun.buffs || {};
        if (useSkill.buffCritRate != null) abyssRun.buffs.critRate = useSkill.buffCritRate;
        if (useSkill.buffCritDmg != null) abyssRun.buffs.critDmg = useSkill.buffCritDmg;
        abyssRun.buffs.roundsLeft = Math.max(abyssRun.buffs.roundsLeft || 0, useSkill.buffRounds || 2);
    }
    if (useSkill && useSkill.dodgeBonus) abyssRun.thisRoundDodgeBonus = useSkill.dodgeBonus;
    if (useSkill && useSkill.reduceDmgPct) abyssRun.thisRoundReduceDmg = useSkill.reduceDmgPct;
    if (useSkill && useSkill.lifestealPct && finalDmg > 0) {
        var healAmt = Math.floor(finalDmg * useSkill.lifestealPct);
        abyssRun.player.hp = Math.min(stats.maxHp, abyssRun.player.hp + healAmt);
        abyssLog('技能回复 ' + formatNumber(healAmt) + ' 生命');
    }
    if (useSkill && useSkill.shieldPct) {
        var sh = Math.floor(stats.maxHp * useSkill.shieldPct);
        abyssRun.player.shield = (abyssRun.player.shield || 0) + sh;
        abyssLog('获得护盾 ' + formatNumber(sh));
    }
    for (var ek in abyssRun.equipped) {
        var eq = abyssRun.equipped[ek];
        if (!eq || !eq.equipSkill || !eq.equipSkill.effect) continue;
        var eff = eq.equipSkill.effect;
        if (eff.stunChance && Math.random() < eff.stunChance) {
            m.stunned = (m.stunned || 0) + (eff.stunTurns || 1);
            abyssLog('【' + eq.equipSkill.name + '】眩晕怪物 ' + (eff.stunTurns || 1) + ' 回合！');
        }
        if (eff.shieldChance && Math.random() < eff.shieldChance) {
            var sh = Math.floor(stats.maxHp * (eff.shieldPct || 0.1));
            abyssRun.player.shield = (abyssRun.player.shield || 0) + sh;
            abyssLog('【' + eq.equipSkill.name + '】获得护盾 ' + formatNumber(sh));
        }
        if (eff.healChance && Math.random() < eff.healChance) {
            var healAmt = Math.floor(stats.maxHp * (eff.healPct || 0.05));
            abyssRun.player.hp = Math.min(stats.maxHp, abyssRun.player.hp + healAmt);
            abyssLog('【' + eq.equipSkill.name + '】回复 ' + formatNumber(healAmt) + ' 生命');
        }
        if (eff.extraDmgChance && Math.random() < eff.extraDmgChance) {
            var extraTotal = Math.max(1, Math.floor(finalDmg * (eff.extraDmgPct || 0.1)));
            var remainExtra = extraTotal;
            if (m.shield > 0) {
                var toSh = Math.min(m.shield, remainExtra);
                m.shield -= toSh;
                remainExtra -= toSh;
            }
            if (remainExtra > 0) m.hp -= remainExtra;
            abyssLog('【' + eq.equipSkill.name + '】额外造成 ' + formatNumber(extraTotal) + ' 伤害');
        }
        if (eff.splitChance != null && eff.splitPct != null && Math.random() < eff.splitChance) {
            var aliveAll = abyssGetAliveMonsters();
            var others = [];
            for (var oi = 0; oi < aliveAll.length; oi++) { if (aliveAll[oi] !== m) others.push(aliveAll[oi]); }
            if (others.length > 0) {
                var splitDmg = Math.max(1, Math.floor(finalDmg * eff.splitPct));
                var splitTotal = 0;
                for (var si = 0; si < others.length; si++) {
                    var tm = others[si];
                    var sd = Math.floor(splitDmg * (1 - (tm.halfDamage || 0)));
                    sd = Math.max(1, sd);
                    var srem = sd;
                    if (tm.shield > 0) { var ts = Math.min(tm.shield, srem); tm.shield -= ts; srem -= ts; }
                    if (srem > 0) tm.hp -= srem;
                    splitTotal += sd;
                }
                abyssLog('【' + eq.equipSkill.name + '】分裂攻击！对其它 ' + others.length + ' 个目标共造成 ' + formatNumber(splitTotal) + ' 伤害');
                for (var di = abyssRun.monsters.length - 1; di >= 0; di--) {
                    var dm = abyssRun.monsters[di];
                    if (!dm || dm.hp > 0 || dm === m) continue;
                    var hasRev = false;
                    if (dm.skills && dm.skills.length && !dm.revived) for (var rvi = 0; rvi < dm.skills.length; rvi++) { if (dm.skills[rvi].id === 'revive') { hasRev = true; break; } }
                    if (hasRev) { var revSk2 = null; for (var rvx2 = 0; rvx2 < dm.skills.length; rvx2++) if (dm.skills[rvx2].id === 'revive') { revSk2 = dm.skills[rvx2]; break; } dm.revived = true; dm.hp = Math.floor(dm.maxHp * (revSk2 && revSk2.revivePct != null ? revSk2.revivePct : 0.25)); abyssLog(dm.name + ' 发动复活！'); }
                    else {
                        abyssPetGainExp(dm.isBoss ? 35 : (12 + Math.floor(Math.random() * 5)));
                        if (!dm.isBoss) {
                            var welf = dm.welfareReward || 1;
                            var rewardM = dm.rewardMult || 1;
                            var normExp = (10 + Math.floor(Math.random() * 6)) * welf * rewardM;
                            var normGold = (21 + Math.floor(Math.random() * 11)) * welf * rewardM;
                            var applied = abyssApplyExpGoldBonus(normExp, normGold);
                            abyssRun.exp = (abyssRun.exp || 0) + applied.exp;
                            abyssRun.gold = (abyssRun.gold || 0) + applied.gold;
                            abyssLog('获得经验 ' + applied.exp + '，闯关金币 ' + applied.gold);
                            if (abyssCheckLevelUp()) { if (abyssGetAliveMonsters().length === 0) abyssOnKillMonster(); else abyssRun.monsters.splice(di, 1); return; }
                            if (Math.random() < 0.1) { abyssRun.materials.potion = (abyssRun.materials.potion || 0) + 1; abyssLog('获得生命药剂 x1'); }
                            if (Math.random() < 0.1) { abyssRun.materials.upgradeStone = (abyssRun.materials.upgradeStone || 0) + 1; abyssLog('获得升级石 x1'); }
                        }
                        abyssRun.monsters.splice(di, 1);
                    }
                }
                if (abyssGetAliveMonsters().length === 0) { stopAbyssAutoAttack(); abyssOnKillMonster(); return; }
                abyssEnsurePlayerTarget();
            }
        }
    }
    var deployedPets = abyssGetDeployedPets();
    for (var pidx = 0; pidx < deployedPets.length && m.hp > 0; pidx++) {
        var pet = deployedPets[pidx];
        if (!pet || (pet.hp !== null && pet.hp <= 0)) continue;
        if (pet.hp === null) {
            var _ps = abyssCalcPetStats(pet);
            if (_ps) pet.hp = _ps.maxHp;
        }
        var pstats = abyssCalcPetStats(pet);
        if (pstats) {
            var petDmg = Math.max(1, pstats.atk - Math.floor(m.def * (1 - (stats.reduceMonsterDef || 0) / 100) * 0.4));
            petDmg = Math.floor(petDmg * (1 - m.halfDamage));
            var critDone = false, comboDone = false;
            for (var psi = 0; psi < (pet.skills || []).length; psi++) {
                var psk = null;
                for (var pk = 0; pk < ABYSS_PET_SKILLS.length; pk++) {
                    if (ABYSS_PET_SKILLS[pk].id === pet.skills[psi].id) { psk = ABYSS_PET_SKILLS[pk]; break; }
                }
                if (!psk) continue;
                if (psk.critRate && !critDone && Math.random() * 100 < psk.critRate) {
                    petDmg = Math.floor(petDmg * (1 + (psk.critDmg || 50) / 100));
                    critDone = true;
                }
                if (psk.chance && !comboDone && Math.random() < psk.chance) {
                    petDmg = Math.floor(petDmg * (psk.multi || 2));
                    comboDone = true;
                }
                if (psk.dmgBonus) petDmg = Math.floor(petDmg * (1 + psk.dmgBonus));
            }
            if (!critDone && (pstats.critRate || 0) > 0 && Math.random() * 100 < (pstats.critRate || 0)) {
                petDmg = Math.floor(petDmg * (1 + (pstats.critDmg || 50) / 100));
                critDone = true;
            }
            petDmg = Math.max(1, petDmg);
            var premain = petDmg;
            if (m.shield > 0) {
                var toPs = Math.min(m.shield, premain);
                m.shield -= toPs;
                premain -= toPs;
            }
            if (m.skills && m.skills.length) { for (var lsp = 0; lsp < m.skills.length; lsp++) { if (m.skills[lsp].id === 'lastStand' && m.hp < m.maxHp * (m.skills[lsp].lastStandThreshold || 0.15)) { premain = Math.floor(premain * 0.5); premain = Math.max(1, premain); break; } } }
            if (premain > 0 && (m.dodge || 0) > 0 && Math.random() * 100 < (m.dodge || 0)) { premain = 0; abyssLog(m.name + ' 闪避了宠物攻击'); }
            if (premain > 0) m.hp -= premain;
            if (m.isBoss && m.hp > 0 && m.hp < m.maxHp * 0.5 && !m.secondPhase) {
                m.secondPhase = true;
                m.atk = Math.floor((m.atk || 0) * 1.28);
                m.def = Math.floor((m.def || 0) * 1.22);
                m.dodge = Math.min(45, (m.dodge || 0) + 18);
                abyssLog(m.name + ' 进入第二阶段！实力与闪避大幅提升');
            }
            if (m.skills) for (var csp = 0; csp < m.skills.length; csp++) { if (m.skills[csp].id === 'counterStrike') { m.counterStrikeNext = true; break; } }
            if ((pstats.lifesteal || 0) > 0 && petDmg > 0) {
                var petHeal = Math.floor(petDmg * (pstats.lifesteal || 0) / 100);
                if (petHeal > 0) {
                    var curHp = pet.hp != null ? pet.hp : pstats.maxHp;
                    pet.hp = Math.min(pstats.maxHp, curHp + petHeal);
                    abyssLog('宠物【' + pet.name + '】吸血回复 ' + formatNumber(petHeal));
                }
            }
            abyssLog('宠物【' + pet.name + '】造成 ' + formatNumber(petDmg) + ' 伤害');
            for (var ek in abyssRun.equipped) {
                var eq = abyssRun.equipped[ek];
                if (!eq || !eq.equipSkill || !eq.equipSkill.effect) continue;
                var eff = eq.equipSkill.effect;
                if (eff.petSplitChance == null || eff.petSplitPct == null || Math.random() >= eff.petSplitChance) continue;
                var aliveAll = abyssGetAliveMonsters();
                var others = [];
                for (var oi = 0; oi < aliveAll.length; oi++) { if (aliveAll[oi] !== m) others.push(aliveAll[oi]); }
                if (others.length > 0) {
                    var petSplitDmg = Math.max(1, Math.floor(petDmg * eff.petSplitPct));
                    var petSplitTotal = 0;
                    for (var si = 0; si < others.length; si++) {
                        var tm = others[si];
                        var sd = Math.floor(petSplitDmg * (1 - (tm.halfDamage || 0)));
                        sd = Math.max(1, sd);
                        var srem = sd;
                        if (tm.shield > 0) { var ts = Math.min(tm.shield, srem); tm.shield -= ts; srem -= ts; }
                        if (srem > 0) tm.hp -= srem;
                        petSplitTotal += sd;
                    }
                    abyssLog('【' + eq.equipSkill.name + '】宠物分裂！对其它 ' + others.length + ' 个目标共造成 ' + formatNumber(petSplitTotal) + ' 伤害');
                    for (var di = abyssRun.monsters.length - 1; di >= 0; di--) {
                        var dm = abyssRun.monsters[di];
                        if (!dm || dm.hp > 0 || dm === m) continue;
                        var hasRev = false;
                        if (dm.skills && dm.skills.length && !dm.revived) for (var rvi = 0; rvi < dm.skills.length; rvi++) { if (dm.skills[rvi].id === 'revive') { hasRev = true; break; } }
                        if (hasRev) { var revSk3 = null; for (var rvx3 = 0; rvx3 < dm.skills.length; rvx3++) if (dm.skills[rvx3].id === 'revive') { revSk3 = dm.skills[rvx3]; break; } dm.revived = true; dm.hp = Math.floor(dm.maxHp * (revSk3 && revSk3.revivePct != null ? revSk3.revivePct : 0.25)); abyssLog(dm.name + ' 发动复活！'); }
                        else {
                            abyssPetGainExp(dm.isBoss ? 35 : (12 + Math.floor(Math.random() * 5)));
                            if (!dm.isBoss) {
                                var welf = dm.welfareReward || 1;
                                var normExp = (10 + Math.floor(Math.random() * 6)) * welf;
                                var normGold = (21 + Math.floor(Math.random() * 11)) * welf;
                                var applied = abyssApplyExpGoldBonus(normExp, normGold);
                                abyssRun.exp = (abyssRun.exp || 0) + applied.exp;
                                abyssRun.gold = (abyssRun.gold || 0) + applied.gold;
                                abyssLog('获得经验 ' + applied.exp + '，闯关金币 ' + applied.gold);
                                if (abyssCheckLevelUp()) { if (abyssGetAliveMonsters().length === 0) abyssOnKillMonster(); else abyssRun.monsters.splice(di, 1); return; }
                                if (Math.random() < 0.1) { abyssRun.materials.potion = (abyssRun.materials.potion || 0) + 1; abyssLog('获得生命药剂 x1'); }
                                if (Math.random() < 0.1) { abyssRun.materials.upgradeStone = (abyssRun.materials.upgradeStone || 0) + 1; abyssLog('获得升级石 x1'); }
                            }
                            abyssRun.monsters.splice(di, 1);
                        }
                    }
                    if (abyssGetAliveMonsters().length === 0) { stopAbyssAutoAttack(); abyssOnKillMonster(); return; }
                    abyssEnsurePlayerTarget();
                }
            }
            // 宠物多目标技能：对其它存活怪物造成额外伤害
            var aliveAll = abyssGetAliveMonsters();
            var others = [];
            for (var oi = 0; oi < aliveAll.length; oi++) { if (aliveAll[oi] !== m) others.push(aliveAll[oi]); }
            if (others.length > 0 && (pet.skills || []).length > 0) {
                for (var aoeSi = 0; aoeSi < pet.skills.length; aoeSi++) {
                    var aoeSk = null;
                    for (var ask = 0; ask < ABYSS_PET_SKILLS.length; ask++) {
                        if (ABYSS_PET_SKILLS[ask].id === pet.skills[aoeSi].id) { aoeSk = ABYSS_PET_SKILLS[ask]; break; }
                    }
                    if (!aoeSk || aoeSk.petAoeChance == null || aoeSk.petAoePct == null || Math.random() >= aoeSk.petAoeChance) continue;
                    var aoeDmg = Math.max(1, Math.floor(petDmg * aoeSk.petAoePct));
                    var aoeTotal = 0;
                    for (var ai = 0; ai < others.length; ai++) {
                        var am = others[ai];
                        if (!am || am.hp <= 0) continue;
                        var ad = Math.floor(aoeDmg * (1 - (am.halfDamage || 0)));
                        ad = Math.max(1, ad);
                        var arem = ad;
                        if (am.shield > 0) { var as = Math.min(am.shield, arem); am.shield -= as; arem -= as; }
                        if (arem > 0) am.hp -= arem;
                        aoeTotal += ad;
                    }
                    if (aoeTotal > 0) abyssLog('宠物【' + pet.name + '】' + aoeSk.name + '！对其它 ' + others.length + ' 个目标共造成 ' + formatNumber(aoeTotal) + ' 伤害');
                }
                for (var di = abyssRun.monsters.length - 1; di >= 0; di--) {
                    var dm = abyssRun.monsters[di];
                    if (!dm || dm.hp > 0 || dm === m) continue;
                    var hasRev = false;
                    if (dm.skills && dm.skills.length && !dm.revived) for (var rvi = 0; rvi < dm.skills.length; rvi++) { if (dm.skills[rvi].id === 'revive') { hasRev = true; break; } }
                    if (hasRev) { var revSk4 = null; for (var rvx4 = 0; rvx4 < dm.skills.length; rvx4++) if (dm.skills[rvx4].id === 'revive') { revSk4 = dm.skills[rvx4]; break; } dm.revived = true; dm.hp = Math.floor(dm.maxHp * (revSk4 && revSk4.revivePct != null ? revSk4.revivePct : 0.25)); abyssLog(dm.name + ' 发动复活！'); }
                    else {
                        abyssPetGainExp(dm.isBoss ? 35 : (12 + Math.floor(Math.random() * 5)));
                        if (!dm.isBoss) {
                            var welf = dm.welfareReward || 1;
                            var rewardM = dm.rewardMult || 1;
                            var normExp = (10 + Math.floor(Math.random() * 6)) * welf * rewardM;
                            var normGold = (21 + Math.floor(Math.random() * 11)) * welf * rewardM;
                            var applied = abyssApplyExpGoldBonus(normExp, normGold);
                            abyssRun.exp = (abyssRun.exp || 0) + applied.exp;
                            abyssRun.gold = (abyssRun.gold || 0) + applied.gold;
                            abyssLog('获得经验 ' + applied.exp + '，闯关金币 ' + applied.gold);
                            if (abyssCheckLevelUp()) { if (abyssGetAliveMonsters().length === 0) abyssOnKillMonster(); else abyssRun.monsters.splice(di, 1); return; }
                            if (Math.random() < 0.1) { abyssRun.materials.potion = (abyssRun.materials.potion || 0) + 1; abyssLog('获得生命药剂 x1'); }
                            if (Math.random() < 0.1) { abyssRun.materials.upgradeStone = (abyssRun.materials.upgradeStone || 0) + 1; abyssLog('获得升级石 x1'); }
                        }
                        abyssRun.monsters.splice(di, 1);
                    }
                }
                if (abyssGetAliveMonsters().length === 0) { stopAbyssAutoAttack(); abyssOnKillMonster(); return; }
                abyssEnsurePlayerTarget();
            }
        }
    }
    var beasts = abyssRun.beastSummons || [];
    for (var bi = 0; bi < beasts.length; bi++) {
        var beast = beasts[bi];
        if (!beast || beast.hp <= 0) continue;
        var beastDmg = Math.max(1, (beast.atk || 0) - Math.floor((m.def || 0) * 0.5));
        beastDmg = Math.floor(beastDmg * (1 - (m.halfDamage || 0)));
        var bremain = beastDmg;
        if (m.shield > 0) {
            var toSh = Math.min(m.shield, bremain);
            m.shield -= toSh;
            bremain -= toSh;
        }
        if (bremain > 0) m.hp -= bremain;
        abyssLog('【' + (beast.name || '战兽') + '】造成 ' + formatNumber(beastDmg) + ' 伤害');
    }
    for (var bj = beasts.length - 1; bj >= 0; bj--) {
        if (beasts[bj] && beasts[bj].hp <= 0) beasts.splice(bj, 1);
    }
    if (m.hp <= 0) {
        var usedSurvive = false;
        if (m.skills && m.skills.length && !m.surviveOneDeathUsed) {
            for (var sodi = 0; sodi < m.skills.length; sodi++) {
                if (m.skills[sodi].id === 'surviveOneDeath') { m.hp = 1; m.surviveOneDeathUsed = true; usedSurvive = true; abyssLog(m.name + ' 不溃！保留1点生命'); break; }
            }
        }
        if (usedSurvive) { /* 本回合不死亡 */ } else if (m.hp <= 0) {
        var hasRevive = false;
        if (m.skills && m.skills.length && !m.revived) {
            for (var si = 0; si < m.skills.length; si++) {
                if (m.skills[si].id === 'revive') { hasRevive = true; break; }
            }
        }
        if (hasRevive) {
            var revSkM = null; for (var rvxm = 0; rvxm < m.skills.length; rvxm++) if (m.skills[rvxm].id === 'revive') { revSkM = m.skills[rvxm]; break; }
            m.revived = true;
            m.hp = Math.floor(m.maxHp * (revSkM && revSkM.revivePct != null ? revSkM.revivePct : 0.25));
            abyssLog('BOSS发动复活！恢复' + ((revSkM && revSkM.revivePct != null ? revSkM.revivePct : 0.25) * 100).toFixed(0) + '%生命');
        } else {
            if (m.skills && m.skills.length) {
                for (var dci = 0; dci < m.skills.length; dci++) {
                    if (m.skills[dci].id === 'deathCurse') {
                        var deathDmg = Math.floor(stats.maxHp * (m.skills[dci].deathDmgMaxHpPct || 0.2));
                        abyssRun.player.hp = Math.max(0, (abyssRun.player.hp || 0) - deathDmg);
                        abyssLog(m.name + ' 怨念！对你造成 ' + formatNumber(deathDmg) + ' 伤害');
                        if (abyssRun.player.hp <= 0) { stopAbyssAutoAttack(); abyssOnPlayerDeath(); return; }
                        break;
                    }
                }
            }
            var expGain = m.isBoss ? 35 : (12 + Math.floor(Math.random() * 5));
            abyssPetGainExp(Math.floor(expGain));
            if (!m.isBoss) {
                var welf = m.welfareReward || 1;
                var rewardM = m.rewardMult || 1;
                var normExp = (10 + Math.floor(Math.random() * 6)) * welf * rewardM;
                var normGold = (21 + Math.floor(Math.random() * 11)) * welf * rewardM;
                var applied = abyssApplyExpGoldBonus(normExp, normGold);
                abyssRun.exp = (abyssRun.exp || 0) + applied.exp;
                abyssRun.gold = (abyssRun.gold || 0) + applied.gold;
                abyssLog('获得经验 ' + applied.exp + '，闯关金币 ' + applied.gold);
                if (abyssCheckLevelUp()) {
                    if (abyssGetAliveMonsters().length === 0) abyssOnKillMonster();
                    else { var deadIdx = abyssRun.monsters.indexOf(m); if (deadIdx >= 0) abyssRun.monsters.splice(deadIdx, 1); }
                    return;
                }
                if (Math.random() < 0.1) {
                    abyssRun.materials.potion = (abyssRun.materials.potion || 0) + 1;
                    abyssLog('获得生命药剂 x1');
                }
                if (Math.random() < 0.1) {
                    abyssRun.materials.upgradeStone = (abyssRun.materials.upgradeStone || 0) + 1;
                    abyssLog('获得升级石 x1');
                }
            }
            abyssLog('击败 ' + (m ? m.name : '') + '！');
            var deadIdx = abyssRun.monsters.indexOf(m);
            if (deadIdx >= 0) abyssRun.monsters.splice(deadIdx, 1);
            if (abyssGetAliveMonsters().length === 0) {
                stopAbyssAutoAttack();
                abyssOnKillMonster();
                return;
            }
            abyssEnsurePlayerTarget();
        }
        }
    }
    if (m.skills && m.skills.length) {
        for (var si = 0; si < m.skills.length; si++) {
            if (m.skills[si].id === 'thorns' && finalDmg > 0) {
                var reflectDmg = Math.floor(finalDmg * (m.skills[si].reflectRate || 0.1));
                abyssRun.player.hp -= reflectDmg;
                abyssLog('反伤受到 ' + formatNumber(reflectDmg) + ' 伤害');
                if (abyssRun.player.hp <= 0) { abyssOnPlayerDeath(); return; }
                break;
            }
        }
    }
    }
    var allMonsters = abyssGetAliveMonsters();
    for (var mi = 0; mi < allMonsters.length; mi++) {
        var m = allMonsters[mi];
        if ((m.stunned || 0) > 0) {
            m.stunned--;
            abyssLog(m.name + ' 被眩晕，本回合无法行动');
            continue;
        }
        if (m.isBoss && m.hp > 0 && m.hp < m.maxHp * 0.1 && Math.random() < 0.12) {
            var healAmt = Math.floor(m.maxHp * 0.1);
            m.hp = Math.min(m.maxHp, m.hp + healAmt);
            abyssLog('「蝼蚁安能伤吾！——回天续命！」' + m.name + ' 恢复10%最大生命 +' + formatNumber(healAmt) + '！');
            continue;
        }
        if (m.skills) for (var fsi = 0; fsi < m.skills.length; fsi++) {
            var fsk = m.skills[fsi];
            if (fsk.id === 'firstStrike' && Math.random() < (fsk.chance || 0.25)) {
                var firstDmg = fsk.firstStrikeMult ? Math.max(1, Math.floor(m.atk * fsk.firstStrikeMult) - Math.floor(stats.def * 0.2)) : Math.max(1, Math.floor(m.atk * (fsk.firstStrikePct || 0.6)) - Math.floor(stats.def * 0.2));
                abyssRun.player.hp = (abyssRun.player.hp || 0) - firstDmg;
                abyssLog(m.name + ' 先制！造成 ' + formatNumber(firstDmg) + ' 伤害');
                if (abyssRun.player.hp <= 0) { stopAbyssAutoAttack(); abyssOnPlayerDeath(); return; }
                break;
            }
        }
        if (m.skills) for (var saci = 0; saci < m.skills.length; saci++) {
            var sask = m.skills[saci];
            if (sask.id === 'sacrifice' && Math.random() < (sask.chance || 0.2)) {
                m.hp = Math.max(1, (m.hp || 0) - Math.floor(m.maxHp * (sask.sacrificeHpPct || 0.1)));
                m._sacrificeDmgBonus = sask.dmgBonus || 0.35;
                abyssLog(m.name + ' 献祭生命，本回合伤害提升！');
                break;
            }
        }
        var monsterAtk = m.atk;
        if (m.skills && m.skills.length) {
            for (var bpi = 0; bpi < m.skills.length; bpi++) {
                if (m.skills[bpi].id === 'bloodPrice' && Math.random() < 0.25) {
                    var cost = Math.floor(m.maxHp * (m.skills[bpi].selfHpCostPct || 0.08));
                    m.hp = Math.max(1, (m.hp || 0) - cost);
                    m._bloodPriceAtk = m.skills[bpi].atkBonus || 0.5;
                    abyssLog(m.name + ' 血偿！消耗生命提升攻击');
                    break;
                }
            }
        }
        var playerDef = stats.def;
        if (m.skills && m.skills.length) {
            for (var si = 0; si < m.skills.length; si++) {
                var sk = m.skills[si];
                if (sk.id === 'armorBreak') playerDef *= (1 - (sk.defIgnore || 0.3));
                if (sk.id === 'curse') playerDef *= (1 - (sk.defIgnore || 0.1));
                if (sk.id === 'overwhelm') playerDef *= (1 - (sk.overwhelmDefIgnore || 0.4));
                if (sk.id === 'rage') { var rageTh = sk.rageThreshold != null ? sk.rageThreshold : 0.4; if (m.hp / m.maxHp < rageTh) monsterAtk = Math.floor(monsterAtk * (1 + (sk.atkBonus || 0.4))); }
                if (sk.id === 'bloodthirst') monsterAtk = Math.floor(monsterAtk * (1 + (1 - m.hp / m.maxHp) * (sk.atkBonusPerMissing || 0.5)));
                if (sk.id === 'enrageTimer' && (m._enrageTurns || 0) >= (sk.turnsToEnrage || 4)) monsterAtk = Math.floor(monsterAtk * (1 + (sk.enrageAtkBonus || 0.3)));
                if (sk.id === 'enrageAtRounds' && (abyssRun.roundCount || 0) >= (sk.enrageRound || 3)) monsterAtk = Math.floor(monsterAtk * (sk.enrageMult || 1.5));
            }
        }
        monsterAtk = Math.max(1, monsterAtk - Math.floor(playerDef * 0.3));
        if (m.element) monsterAtk = Math.floor(monsterAtk * 1.1);
        var multi = 1;
        if (m.skills && m.skills.length) {
            for (var si = 0; si < m.skills.length; si++) {
                var sk = m.skills[si];
                if ((sk.id === 'quadrupleStrike' && Math.random() < (sk.chance || 0.1)) || (sk.id === 'tripleStrike' && Math.random() < (sk.chance || 0.12)) || (sk.id === 'doubleStrike' && Math.random() < (sk.chance || 0.2)) || (sk.id === 'multiHit' && Math.random() < (sk.chance || 0.25)) || (sk.id === 'freeze' && Math.random() < (sk.chance || 0.12))) {
                    var mul = sk.multi || 2;
                    if (mul > multi) multi = mul;
                }
                if (sk.id === 'heavyStrike' && Math.random() < (sk.chance || 0.25)) multi = Math.max(multi, 1.5);
            }
        } else if (Math.random() < m.multiHit) multi = 2;
        if (m._bloodPriceAtk != null) { monsterAtk = Math.floor(monsterAtk * (1 + m._bloodPriceAtk)); m._bloodPriceAtk = null; }
        var taken = Math.floor(monsterAtk * multi);
        if (m._sacrificeDmgBonus != null) { taken = Math.floor(taken * (1 + m._sacrificeDmgBonus)); m._sacrificeDmgBonus = null; }
        if (abyssRun.markedTarget === 'player' && abyssRun.markedByIndex === mi) { taken = Math.floor(taken * (1 + (m.skills && m.skills.length ? (function(){ for (var mki = 0; mki < m.skills.length; mki++) if (m.skills[mki].id === 'mark') return m.skills[mki].markDmgBonus || 0.45; return 0.45; })() : 0.45))); abyssRun.markedTarget = null; abyssRun.markedByIndex = null; abyssLog(m.name + ' 点名命中！'); }
        if (m.skills && m.skills.length) {
            for (var si = 0; si < m.skills.length; si++) {
                var sk = m.skills[si];
                if (sk.id === 'execute' && abyssRun.player.hp / stats.maxHp < (sk.lowHpThreshold || 0.3)) taken = Math.floor(taken * (1 + (sk.dmgBonus || 0.5)));
                if (sk.id === 'crush') taken = Math.floor(taken * (1 + (sk.dmgBonus || 0.25)));
                if (sk.id === 'bleed') taken = Math.floor(taken * (1 + (sk.extraDmg || 0.05)));
                if (sk.id === 'venom') taken = Math.floor(taken * (1 + (sk.dmgBonus || 0.1)));
                if (sk.id === 'voidTouch') { var missingHp = Math.max(0, stats.maxHp - (abyssRun.player.hp || 0)); taken += Math.floor(missingHp * (sk.missingHpDmgPct || 0.2)); }
                if (sk.id === 'curseMark') { m.curseMarkStacks = (m.curseMarkStacks || 0) + 1; var cmBonus = Math.min(sk.stackMax || 0.3, (m.curseMarkStacks || 0) * (sk.stackDmgPerHit || 0.06)); taken = Math.floor(taken * (1 + cmBonus)); }
                if (sk.id === 'entropy' && Math.random() < (sk.chaosChance || 0.25)) taken = Math.floor(taken * (Math.random() < 0.5 ? 1.5 : 0.5));
            }
        }
        var minionCount = 0;
        for (var rci = 0; rci < allMonsters.length; rci++) if (allMonsters[rci].isSummon || (allMonsters[rci].name && allMonsters[rci].name.indexOf('仆从') >= 0)) minionCount++;
        if (m.skills) for (var rsi = 0; rsi < m.skills.length; rsi++) if (m.skills[rsi].id === 'resonance' && minionCount > 0) { taken = Math.floor(taken * (1 + minionCount * (m.skills[rsi].dmgPerMinion || 0.1))); break; }
        var totalDR = 0;
        for (var ek2 in abyssRun.equipped) {
            var eq2 = abyssRun.equipped[ek2];
            if (eq2 && eq2.equipSkill && eq2.equipSkill.effect && eq2.equipSkill.effect.damageReduction)
                totalDR += eq2.equipSkill.effect.damageReduction;
        }
        taken = Math.floor(taken * (1 - Math.min(0.6, totalDR)));
        if (m.element && stats.elementRes && stats.elementRes[m.element]) {
            var myRes = Math.min(75, stats.elementRes[m.element]);
            taken = Math.floor(taken * (1 - myRes / 100));
        }
        taken = Math.max(1, taken);
        if (abyssRun.thisRoundReduceDmg) taken = Math.floor(taken * (1 - (abyssRun.thisRoundReduceDmg || 0) / 100));
        var dodgeCheck = (stats.dodge || 0) + (abyssRun.thisRoundDodgeBonus || 0);
        if (Math.random() * 100 < dodgeCheck) { taken = 0; abyssLog(m.name + ' 攻击被闪避！'); continue; }
        var beasts2 = abyssRun.beastSummons || [];
        var aliveBeasts = beasts2.filter(function(b) { return b && b.hp > 0; });
        var attackBeast = aliveBeasts.length > 0 && (abyssRun.petGuard ? true : Math.random() < 0.5);
        var deployedForHit = abyssGetDeployedPets().filter(function(p) { return p && (p.hp === null || p.hp > 0); });
        var pet2 = deployedForHit.length > 0 ? deployedForHit[Math.floor(Math.random() * deployedForHit.length)] : null;
        var attackPet = !attackBeast && ((abyssRun.petGuard && pet2) || (pet2 && Math.random() < 0.5));
        if (m.skills && pet2) for (var phi = 0; phi < m.skills.length; phi++) if (m.skills[phi].id === 'petHate' && Math.random() < (m.skills[phi].petHateChance || 0.85)) { attackPet = true; attackBeast = false; abyssLog(m.name + ' 仇宠，锁定宠物！'); break; }
        var takenPlayer = (attackBeast || attackPet) ? 0 : taken;
        var takenPet = attackPet ? taken : 0;
        var takenBeast = attackBeast && aliveBeasts.length > 0 ? taken : 0;
        var hitAllUsed = false;
        if (m.skills) for (var hai = 0; hai < m.skills.length; hai++) {
            if (m.skills[hai].id === 'hitAll') {
                var haPct = m.skills[hai].hitAllPct || 0.55;
                var hitAllDmg = Math.max(1, Math.floor(taken * haPct));
                abyssRun.player.hp -= hitAllDmg;
                abyssLog(m.name + ' 崩裂！玩家受到 ' + formatNumber(hitAllDmg) + ' 伤害');
                for (var pi = 0; pi < deployedForHit.length; pi++) {
                    var pt = deployedForHit[pi];
                    if (pt && (pt.hp === null || pt.hp > 0)) {
                        if (pt.hp === null) { var _ps2 = abyssCalcPetStats(pt); if (_ps2) pt.hp = _ps2.maxHp; }
                        pt.hp = Math.max(0, (pt.hp || 0) - hitAllDmg);
                        if (pt.hp < 0) pt.hp = 0;
                        abyssLog(m.name + ' 崩裂！宠物【' + pt.name + '】受到 ' + formatNumber(hitAllDmg) + ' 伤害');
                    }
                }
                for (var bi = 0; bi < aliveBeasts.length; bi++) {
                    aliveBeasts[bi].hp = Math.max(0, (aliveBeasts[bi].hp || 0) - hitAllDmg);
                    abyssLog(m.name + ' 崩裂！【' + (aliveBeasts[bi].name || '战兽') + '】受到 ' + formatNumber(hitAllDmg) + ' 伤害');
                }
                takenPlayer = hitAllDmg; takenPet = 0; takenBeast = 0;
                hitAllUsed = true;
                break;
            }
        }
        if (!hitAllUsed && takenBeast > 0 && aliveBeasts.length > 0) {
            var targBeast = aliveBeasts[0];
            targBeast.hp = Math.max(0, (targBeast.hp || 0) - takenBeast);
            abyssLog(m.name + ' 造成 ' + formatNumber(takenBeast) + ' 伤害 → 【' + (targBeast.name || '战兽') + '】' + (targBeast.hp <= 0 ? ' 已消散' : ''));
            if (abyssRun.thisRoundCounterPct && takenBeast > 0) {
                var refDmg = Math.floor(takenBeast * abyssRun.thisRoundCounterPct / 100);
                m.hp = Math.max(0, (m.hp || 0) - refDmg);
                abyssLog('反击造成 ' + formatNumber(refDmg) + ' 伤害 → ' + m.name);
            }
        }
        if (!hitAllUsed && takenPet > 0 && pet2) {
            if (pet2.hp === null) { var _ps = abyssCalcPetStats(pet2); if (_ps) pet2.hp = _ps.maxHp; }
            var pst = abyssCalcPetStats(pet2);
            if (pst && m.skills) for (var epi = 0; epi < m.skills.length; epi++) if (m.skills[epi].id === 'executePet') { var petHpPct = (pet2.hp != null ? pet2.hp : pst.maxHp) / (pst.maxHp || 1); if (petHpPct < (m.skills[epi].executePetThreshold || 0.35)) { takenPet = Math.floor(takenPet * (1 + (m.skills[epi].executePetBonus || 0.6))); abyssLog(m.name + ' 屠宠！'); } break; }
            if (pst && (pst.dodge || 0) > 0 && Math.random() * 100 < (pst.dodge || 0)) {
                takenPet = 0;
                abyssLog('宠物【' + pet2.name + '】闪避了攻击');
            } else {
                if (pst) takenPet = Math.max(1, takenPet - Math.floor((pst.def || 0) * 0.3));
                if (pst && (pst.damageReduction || 0) > 0) takenPet = Math.max(1, Math.floor(takenPet * (1 - Math.min(0.6, pst.damageReduction))));
                pet2.hp = (pet2.hp || 0) - takenPet;
                if (pet2.hp < 0) pet2.hp = 0;
                abyssLog(m.name + ' 造成 ' + formatNumber(takenPet) + ' 伤害 → 宠物【' + pet2.name + '】' + (pet2.hp <= 0 ? ' 已死亡，可使用复活药水复活' : ''));
            }
        }
        if (!hitAllUsed && takenPlayer > 0) {
            if (abyssRun.player.shield > 0) {
                var toShield = Math.min(abyssRun.player.shield, takenPlayer);
                abyssRun.player.shield -= toShield;
                takenPlayer -= toShield;
            }
            abyssRun.player.hp -= takenPlayer;
            abyssLog(m.name + ' 造成 ' + formatNumber(takenPlayer) + ' 伤害 → 玩家');
            if (abyssRun.thisRoundCounterPct && takenPlayer > 0) {
                var refDmg2 = Math.floor(takenPlayer * abyssRun.thisRoundCounterPct / 100);
                m.hp = Math.max(0, (m.hp || 0) - refDmg2);
                abyssLog('反击造成 ' + formatNumber(refDmg2) + ' 伤害 → ' + m.name);
            }
        }
        var heal = Math.floor((takenPlayer + takenPet) * (stats.lifesteal || 0) / 100);
        if (heal > 0) {
            var healReducePct = 0;
            var aliveForHeal = abyssGetAliveMonsters();
            for (var hri = 0; hri < aliveForHeal.length; hri++) {
                var monHeal = aliveForHeal[hri];
                if (monHeal.skills) for (var hrii = 0; hrii < monHeal.skills.length; hrii++) {
                    if (monHeal.skills[hrii].id === 'healReduce') healReducePct = Math.max(healReducePct, monHeal.skills[hrii].healReducePct || 0);
                    if (monHeal.skills[hrii].id === 'corrupt') healReducePct = Math.max(healReducePct, monHeal.skills[hrii].corruptHealPct || 0);
                }
            }
            heal = Math.floor(heal * (1 - healReducePct));
            if (heal > 0) { abyssRun.player.hp += heal; abyssRun.player.hp = Math.min(abyssRun.player.hp, stats.maxHp); }
        }
        if (m.skills && m.skills.length && (takenPlayer + takenPet) > 0) {
            for (var lsi = 0; lsi < m.skills.length; lsi++) {
                if (m.skills[lsi].id === 'lifesteal') {
                    var healB = Math.floor((takenPlayer + takenPet) * (m.skills[lsi].rate || 0.1));
                    if (healB > 0) { m.hp = Math.min(m.maxHp, (m.hp || 0) + healB); abyssLog(m.name + ' 吸血恢复 ' + formatNumber(healB)); }
                    break;
                }
            }
        }
        if (taken > 0 && m.skills && m.skills.length) {
            for (var igi = 0; igi < m.skills.length; igi++) {
                if (m.skills[igi].id === 'ignite' && Math.random() < 0.5) {
                    abyssRun.playerBurning = { rate: m.skills[igi].dotRate || 0.05, rounds: 3 };
                    abyssLog(m.name + ' 施加灼烧！');
                    break;
                }
            }
            for (var sdi = 0; sdi < m.skills.length; sdi++) {
                if (m.skills[sdi].id === 'soulDrain' && (takenPlayer + takenPet) > 0 && Math.random() < 0.5) {
                    abyssRun.playerSoulDrain = { rate: m.skills[sdi].dotMaxHpPct || 0.04, rounds: m.skills[sdi].dotRounds || 2 };
                    abyssLog(m.name + ' 魂噬！对你施加生命侵蚀');
                    break;
                }
            }
        }
        if (m.skills && m.skills.length && (takenPlayer + takenPet) > 0) {
            for (var sili = 0; sili < m.skills.length; sili++) {
                if (m.skills[sili].id === 'silence' && Math.random() < (m.skills[sili].silenceChance || 0.3)) {
                    abyssRun.playerSilenced = m.skills[sili].silenceRounds || 1;
                    abyssLog(m.name + ' 静默！你' + abyssRun.playerSilenced + '回合无法使用技能');
                    break;
                }
                if (m.skills[sili].id === 'timeStop' && Math.random() < (m.skills[sili].chance || 0.2)) {
                    abyssRun.skipPlayerTurn = m.skills[sili].skipTurns || 1;
                    abyssLog(m.name + ' 时空凝滞！你' + abyssRun.skipPlayerTurn + '回合无法行动');
                    break;
                }
            }
            for (var mpsi = 0; mpsi < m.skills.length; mpsi++) {
                if (m.skills[mpsi].id === 'mpSteal') {
                    var maxMpVal = abyssMaxMpForLevel(runLevel);
                    var stealMp = Math.floor(maxMpVal * (m.skills[mpsi].mpStealPct || 0.2));
                    abyssRun.player.mp = Math.max(0, (abyssRun.player.mp || 0) - stealMp);
                    if (stealMp > 0) abyssLog(m.name + ' 夺魂！失去 ' + stealMp + ' 魔法');
                    break;
                }
                if (m.skills[mpsi].id === 'manaBurn') {
                    var maxMpVal2 = abyssMaxMpForLevel(runLevel);
                    var burnMp = Math.floor(maxMpVal2 * (m.skills[mpsi].burnPct || 0.18));
                    abyssRun.player.mp = Math.max(0, (abyssRun.player.mp || 0) - burnMp);
                    if (burnMp > 0) abyssLog(m.name + ' 燃魔！失去 ' + burnMp + ' 魔法');
                    break;
                }
            }
            for (var sbi = 0; sbi < m.skills.length; sbi++) {
                if (m.skills[sbi].id === 'stealBuff' && Math.random() < (m.skills[sbi].stealBuffChance || 0.35)) {
                    if (abyssRun.buffs && (abyssRun.buffs.roundsLeft > 0 || abyssRun.buffs.atkPct || abyssRun.buffs.reduceDmgPct)) {
                        abyssRun.buffs = {}; abyssRun.thisRoundCounterPct = 0; abyssRun.thisRoundReduceDmg = 0;
                        abyssLog(m.name + ' 掠夺！清除了你的增益');
                    }
                    break;
                }
            }
            for (var abi = 0; abi < m.skills.length; abi++) {
                if (m.skills[abi].id === 'abyssGaze' && Math.random() < (m.skills[abi].blindChance || 0.2)) {
                    abyssRun.playerBlinded = m.skills[abi].blindRounds || 1;
                    abyssLog(m.name + ' 深渊凝视！你被致盲 ' + abyssRun.playerBlinded + ' 回合');
                    break;
                }
            }
            for (var fei = 0; fei < m.skills.length; fei++) {
                if (m.skills[fei].id === 'fear' && Math.random() < (m.skills[fei].fearChance || 0.15) && Math.random() < (m.skills[fei].skipAttackChance || 0.5)) {
                    abyssRun.skipPlayerTurn = 1;
                    abyssLog(m.name + ' 恐惧！你下回合无法行动');
                    break;
                }
            }
            for (var lwi = 0; lwi < m.skills.length; lwi++) {
                if (m.skills[lwi].id === 'lifeSwap' && (takenPlayer + takenPet) > 0 && Math.random() < (m.skills[lwi].swapChance || 0.12)) {
                    var playerHpPct = (abyssRun.player.hp || 0) / (stats.maxHp || 1);
                    var monHpPct = (m.hp || 0) / (m.maxHp || 1);
                    abyssRun.player.hp = Math.floor(stats.maxHp * monHpPct);
                    m.hp = Math.floor(m.maxHp * playerHpPct);
                    abyssLog(m.name + ' 生命置换！与玩家交换了生命');
                    break;
                }
            }
        }
        if (abyssRun.player.hp <= 0) { stopAbyssAutoAttack(); abyssOnPlayerDeath(); return; }
    }
    if (abyssRun.buffs && abyssRun.buffs.roundsLeft) {
        abyssRun.buffs.roundsLeft--;
        if (abyssRun.buffs.roundsLeft <= 0) abyssRun.buffs = {};
    }
    var bossForSummon = abyssGetAliveMonsters().filter(function(x) { return x.isBoss; })[0];
    if (bossForSummon && bossForSummon.hp > 0 && bossForSummon.skills && bossForSummon.skills.length) {
        for (var si = 0; si < bossForSummon.skills.length; si++) {
            var sk = bossForSummon.skills[si];
            var maxSummon = sk.summonCount != null ? sk.summonCount : 2;
            if (sk.id === 'bossSummon' && (bossForSummon.summonCount || 0) < maxSummon && Math.random() < (sk.chance || 0.2)) {
                var toSummon = Math.min(maxSummon - (bossForSummon.summonCount || 0), 1 + Math.floor(Math.random() * Math.min(2, maxSummon)));
                if (toSummon <= 0) break;
                for (var sumi = 0; sumi < toSummon; sumi++) {
                    var minionHp = Math.max(1, Math.floor(bossForSummon.maxHp * (sk.summonPct || 0.1)));
                    var minionAtk = Math.max(1, Math.floor(bossForSummon.atk * (sk.summonPct || 0.1)));
                    var minionDef = Math.max(0, Math.floor(bossForSummon.def * (sk.summonPct || 0.1)));
                    var minion = {
                        name: '深渊仆从·' + bossForSummon.name,
                        hp: minionHp, maxHp: minionHp, atk: minionAtk, def: minionDef,
                        critRate: bossForSummon.critRate, critDmg: bossForSummon.critDmg, dodge: bossForSummon.dodge, lifesteal: bossForSummon.lifesteal, combo: bossForSummon.combo,
                        isBoss: false, multiHit: 0.15, halfDamage: 0, skills: [],
                        element: bossForSummon.element, elementRes: bossForSummon.elementRes ? JSON.parse(JSON.stringify(bossForSummon.elementRes)) : { metal: 0, wood: 0, water: 0, fire: 0, earth: 0 },
                        shield: 0, isSummon: true
                    };
                    abyssRun.monsters.push(minion);
                    bossForSummon.summonCount = (bossForSummon.summonCount || 0) + 1;
                }
                abyssLog('「深渊之力，听吾号令！」' + bossForSummon.name + ' 召唤 ' + toSummon + ' 只仆从！');
                break;
            }
        }
    }
    var regen = abyssMpRegenForLevel(runLevel);
    abyssRun.player.mp = Math.min(maxMp, (abyssRun.player.mp || 0) + regen);
    updateAbyssRunUI();
}

function abyssOnKillMonster() {
    var m = abyssRun.monster;
    var isBoss = (abyssRun.floor % 10 === 0);
    var f = abyssRun.floor;
    if (Math.random() < 0.2) {
        if ((abyssRun.pets || []).length < 10) {
            var newPet = abyssGenPet(m ? m.name : '未知', abyssRun.floor);
            abyssRun.pets.push(newPet);
            var typeName = (ABYSS_PET_TYPES.find(function(t){ return t.id === newPet.type; }) || {}).name || '';
            abyssLog('获得宠物【' + newPet.name + '】' + (newPet.variant ? '变异 ' : '') + typeName + ' 资质 攻' + newPet.growth.atk + ' 防' + newPet.growth.def + ' 体' + newPet.growth.hp + ' 速' + newPet.growth.speed);
        } else {
            abyssLog('宠物已达上限(10只)，未获得新宠物');
        }
    }
    if (Math.random() < 0.2) {
        abyssRun.materials.petSkillBook = (abyssRun.materials.petSkillBook || 0) + 1;
        abyssLog('获得 宠物兽决 x1');
    }
    var stats = abyssCalcPlayerStats();
    if (stats) {
        var healAmt = Math.floor(stats.maxHp * 0.25);
        abyssRun.player.hp = Math.min(stats.maxHp, abyssRun.player.hp + healAmt);
        abyssLog('回复25%生命 +' + formatNumber(healAmt));
    }
    if (isBoss) {
        abyssBossDrops();
        abyssRun.justKilledBoss = true;
        abyssRun.monster = null;
        updateAbyssRunUI();
        openAbyssTempShop();
        return;
    }
    abyssRun.monsters = [];
    abyssNormalDrops();
    if (abyssRun.curseRounds > 0) abyssRun.curseRounds--;
    if (abyssRun.trialRoundsLeft > 0) abyssRun.trialRoundsLeft--;
    abyssRun.floor++;
    abyssRun.monster = null;
    abyssRun.pendingChoice = true;
    if (abyssRun.pendingUpgradeChoice) {
        abyssRun.afterUpgradeDoFloorClear = true;
        abyssRun.needSpawnAfterUpgrade = true;
        return;
    }
    var runLevel = Math.floor((abyssRun.exp || 0) / 100);
    if (runLevel > (abyssRun.lastUpgradeChoiceLevel || 0)) {
        abyssRun.pendingUpgradeChoice = true;
        abyssRun.pendingUpgradeLevel = (abyssRun.lastUpgradeChoiceLevel || 0) + 1;
        abyssShowUpgradeChoice();
        return;
    }
    if (abyssTrySpecialEvents(f)) return;
    if (f % 5 === 0 && Math.random() < ABYSS_ENCOUNTER_CHANCE) {
        abyssLog('奇遇·闫闫出现！');
        abyssShowEncounter();
        return;
    }
    abyssShowChoice();
}

function abyssGenEquipmentQuality(floor, minQuality) {
    var q = minQuality !== undefined ? (minQuality + Math.floor(Math.random() * (5 - minQuality))) : Math.floor(Math.random() * 5);
    if (minQuality !== undefined && q > 4) q = 4;
    var slot = ABYSS_SLOTS[Math.floor(Math.random() * ABYSS_SLOTS.length)];
    var setIdx = q >= 2 ? Math.floor(Math.random() * (ABYSS_SET_NAMES.length - 1)) + 1 : 0;
    var willHaveEquipSkill = Math.random() < 0.28;
    var baseQualityForStats = (setIdx || willHaveEquipSkill) ? 0 : q;
    var base = { hp: 0, atk: 0, def: 0, critRate: 0, critDmg: 0, dodge: 0, lifesteal: 0, combo: 0, skillDmg: 0, reduceMonsterDef: 0, str: 0, agi: 0, int: 0, sta: 0, metalAtk: 0, woodAtk: 0, waterAtk: 0, fireAtk: 0, earthAtk: 0, metalRes: 0, woodRes: 0, waterRes: 0, fireRes: 0, earthRes: 0 };
    var f = Math.max(1, floor || 1);
    var scale = Math.floor(Math.sqrt(f * 1.15) * (1 + baseQualityForStats * 0.1));
    var roll = Math.floor(Math.random() * 3) + 1;
    base.hp += Math.floor(scale * 9 * roll);
    base.atk += Math.floor(scale * 2.4 * roll);
    base.def += Math.floor(scale * 1.2 * roll);
    if (Math.random() < 0.3) base.critRate += 1 + baseQualityForStats;
    if (Math.random() < 0.3) base.critDmg += 5 + baseQualityForStats * 5;
    if (Math.random() < 0.2) base.dodge += 0.5 + baseQualityForStats * 0.5;
    if (Math.random() < 0.2) base.lifesteal += 1 + baseQualityForStats;
    if (Math.random() < 0.2) base.combo += 2 + baseQualityForStats;
    if (Math.random() < 0.15) base.skillDmg += 10 + baseQualityForStats * 10;
    if (Math.random() < 0.25) base.str += 2 + baseQualityForStats * 2;
    if (Math.random() < 0.25) base.agi += 2 + baseQualityForStats * 2;
    if (Math.random() < 0.25) base.int += 2 + baseQualityForStats * 2;
    if (Math.random() < 0.25) base.sta += 2 + baseQualityForStats * 2;
    for (var ei = 0; ei < ABYSS_ELEMENTS.length; ei++) {
        var el = ABYSS_ELEMENTS[ei];
        if (Math.random() < 0.22) base[el + 'Atk'] = (base[el + 'Atk'] || 0) + (2 + baseQualityForStats + Math.floor(Math.random() * 5));
        if (Math.random() < 0.22) base[el + 'Res'] = (base[el + 'Res'] || 0) + (1 + baseQualityForStats + Math.floor(Math.random() * 4));
    }
    var equipLevel = 2 + Math.floor((floor || 1) / 4) + Math.floor(Math.random() * 3);
    var names = ABYSS_EQUIP_NAMES[slot] || ['未知'];
    var equipName = names[Math.floor(Math.random() * names.length)];
    var equipSkill = null;
    if (willHaveEquipSkill) {
        var sk = ABYSS_EQUIP_SKILLS[Math.floor(Math.random() * ABYSS_EQUIP_SKILLS.length)];
        equipSkill = { id: sk.id, name: sk.name, effect: JSON.parse(JSON.stringify(sk.effect)) };
    }
    var displayName = ABYSS_QUALITIES[q] + '·' + equipName + (setIdx ? '(' + ABYSS_SET_NAMES[setIdx] + ')' : '') + (equipSkill ? '[' + equipSkill.name + ']' : '');
    var runeSlotsQ = abyssRollRuneSlotCount();
    var gemSlotsQ = abyssRollGemSlotCount();
    var runesArrQ = [];
    for (var rsq = 0; rsq < runeSlotsQ; rsq++) runesArrQ.push(null);
    var gemsArrQ = [];
    for (var gsq = 0; gsq < gemSlotsQ; gsq++) gemsArrQ.push(null);
    return {
        id: abyssGenId(), slot: slot, quality: q, set: ABYSS_SET_NAMES[setIdx], equipLevel: equipLevel, level: 0, enchant: null,
        stats: base, name: displayName, equipSkill: equipSkill,
        runes: runesArrQ,
        gems: gemsArrQ
    };
}

function abyssBossDrops() {
    var f = abyssRun.floor;
    if (Math.random() < 0.02) {
        var pool = ABYSS_VAULT_TREASURES.filter(function(t) { return f >= t.minFloor; });
        if (pool.length > 0) {
            var t = pool[Math.floor(Math.random() * pool.length)];
            var at = getAbyssTower();
            at.abyssVault[t.id] = (at.abyssVault[t.id] || 0) + 1;
            var eff = t.effect;
            var effText = eff.type === 'atkVaultPct' ? (eff.value + '%攻击总加成') : eff.type === 'hpVaultPct' ? (eff.value + '%生命总加成') : eff.type === 'defVaultPct' ? (eff.value + '%防御总加成') : eff.type === 'critDmgVaultPct' ? (eff.value + '%爆伤总加成') : eff.type === 'atkVaultFlat' ? ('+' + eff.value + '攻击') : eff.type === 'defVaultFlat' ? ('+' + eff.value + '防御') : eff.type === 'hpVaultFlat' ? ('+' + eff.value + '生命') : eff.type === 'petAtkVaultPct' ? (eff.value + '%宠物攻击总加成') : eff.type === 'petHpVaultPct' ? (eff.value + '%宠物生命总加成') : eff.type === 'petDefVaultPct' ? (eff.value + '%宠物防御总加成') : eff.type === 'petAtkVaultFlat' ? ('+' + eff.value + '宠物攻击') : eff.type === 'petDefVaultFlat' ? ('+' + eff.value + '宠物防御') : eff.type === 'petHpVaultFlat' ? ('+' + eff.value + '宠物生命') : '';
            abyssLog('深渊宝库：获得【' + t.name + '】永久' + effText + '！');
            abyssShowTreasureDropPopup(t.name, effText);
        }
    }
    var bossExp = 55 + Math.floor(Math.random() * 25);
    var appliedBoss = abyssApplyExpGoldBonus(bossExp, 220);
    abyssRun.exp = (abyssRun.exp || 0) + appliedBoss.exp;
    abyssRun.gold = (abyssRun.gold || 0) + appliedBoss.gold;
    abyssLog('获得闯关金币 ' + appliedBoss.gold + '，经验 ' + appliedBoss.exp);
    abyssCheckLevelUp();
    var eqCount = 1 + Math.floor(Math.random() * 3);
    for (var i = 0; i < eqCount; i++) {
        var eq = abyssGenEquipmentQuality(f, 3);
        abyssRun.inventory.push(eq);
        abyssLog('获得装备: ' + eq.name);
    }
    abyssRun.materials.enhanceStone += 3;
    abyssRun.materials.enchantBook += 3;
    abyssLog('获得 强化石 x3，附魔书 x3');
    var runeId = ABYSS_RUNES[Math.floor(Math.random() * ABYSS_RUNES.length)].id;
    abyssRun.runeInventory = abyssRun.runeInventory || [];
    abyssRun.runeInventory.push(runeId);
    abyssRun.runeInventory.push(ABYSS_RUNES[Math.floor(Math.random() * ABYSS_RUNES.length)].id);
    abyssLog('获得符文 x2');
    var gemId = ABYSS_GEMS[Math.floor(Math.random() * ABYSS_GEMS.length)].id;
    abyssRun.gemInventory = abyssRun.gemInventory || [];
    abyssRun.gemInventory.push(gemId);
    abyssRun.gemInventory.push(ABYSS_GEMS[Math.floor(Math.random() * ABYSS_GEMS.length)].id);
    abyssLog('获得宝石 x2');
    abyssRun.materials.runeSlotOpener = (abyssRun.materials.runeSlotOpener || 0) + 1;
    abyssRun.materials.gemSlotOpener = (abyssRun.materials.gemSlotOpener || 0) + 1;
    abyssLog('获得 符文开孔器 x1，宝石开孔器 x1');
}

function abyssNormalDrops() {
    // 经验与货币已改为每只普通怪物死亡时掉落(10-18经验、25-30金币)，此处为关卡结算的随机装备掉落
    if (Math.random() < 0.35) {
        var r = Math.random();
        var dropQuality = r < 0.5 ? 0 : (r < 0.75 ? 1 : (r < 0.85 ? 2 : 3));
        var eq = abyssGenEquipment(abyssRun.floor, false, 3, dropQuality);
        abyssRun.inventory.push(eq);
        abyssLog('获得装备: ' + eq.name);
    }
    if (Math.random() < 0.15) {
        abyssRun.materials.enhanceStone++;
        abyssLog('获得 强化石 x1');
    }
    if (Math.random() < 0.08) {
        abyssRun.materials.enchantBook++;
        abyssLog('获得 附魔书 x1');
    }
    if (Math.random() < 0.12) {
        abyssRun.runeInventory = abyssRun.runeInventory || [];
        abyssRun.runeInventory.push(ABYSS_RUNES[Math.floor(Math.random() * ABYSS_RUNES.length)].id);
        abyssLog('获得 符文 x1');
    }
    if (Math.random() < 0.12) {
        abyssRun.gemInventory = abyssRun.gemInventory || [];
        abyssRun.gemInventory.push(ABYSS_GEMS[Math.floor(Math.random() * ABYSS_GEMS.length)].id);
        abyssLog('获得 宝石 x1');
    }
    if (Math.random() < 0.05) {
        abyssRun.materials.runeSlotOpener = (abyssRun.materials.runeSlotOpener || 0) + 1;
        abyssLog('获得 符文开孔器 x1');
    }
    if (Math.random() < 0.05) {
        abyssRun.materials.gemSlotOpener = (abyssRun.materials.gemSlotOpener || 0) + 1;
        abyssLog('获得 宝石开孔器 x1');
    }
}

// 深渊宝库宝物定义：BOSS层(每10关)击败后2%概率掉落，宝物可叠加
var ABYSS_VAULT_TREASURES = [
    { id: 'vault_1', name: '裁决之刃', minFloor: 9, effect: { type: 'atkVaultPct', value: 1 } },
    { id: 'vault_2', name: '星辰之泪', minFloor: 9, effect: { type: 'hpVaultPct', value: 1 } },
    { id: 'vault_3', name: '破晓之矛', minFloor: 9, effect: { type: 'defVaultPct', value: 1 } },
    { id: 'vault_4', name: '永恒之枪', minFloor: 9, effect: { type: 'critDmgVaultPct', value: 1 } },
    { id: 'vault_5', name: '终焉之杖', minFloor: 9, effect: { type: 'atkVaultFlat', value: 10 } },
    { id: 'vault_6', name: '龙魂之牙', minFloor: 9, effect: { type: 'defVaultFlat', value: 5 } },
    { id: 'vault_7', name: '圣光权杖', minFloor: 9, effect: { type: 'hpVaultFlat', value: 50 } },
    { id: 'vault_8', name: '暗影之镰', minFloor: 19, effect: { type: 'atkVaultPct', value: 1.5 } },
    { id: 'vault_9', name: '断钢圣剑', minFloor: 19, effect: { type: 'hpVaultPct', value: 1.5 } },
    { id: 'vault_10', name: '月神之弓', minFloor: 19, effect: { type: 'defVaultPct', value: 1.5 } },
    { id: 'vault_11', name: '雷神之锤', minFloor: 19, effect: { type: 'critDmgVaultPct', value: 1.5 } },
    { id: 'vault_12', name: '霜寒之握', minFloor: 19, effect: { type: 'atkVaultFlat', value: 15 } },
    { id: 'vault_13', name: '烈焰之心', minFloor: 19, effect: { type: 'defVaultFlat', value: 10 } },
    { id: 'vault_14', name: '虚空之眼', minFloor: 19, effect: { type: 'hpVaultFlat', value: 100 } },
    { id: 'vault_15', name: '秩序法典', minFloor: 29, effect: { type: 'atkVaultPct', value: 2 } },
    { id: 'vault_16', name: '混沌之核', minFloor: 29, effect: { type: 'hpVaultPct', value: 2 } },
    { id: 'vault_17', name: '命运纺锤', minFloor: 29, effect: { type: 'defVaultPct', value: 2 } },
    { id: 'vault_18', name: '灵魂收割者', minFloor: 29, effect: { type: 'critDmgVaultPct', value: 2 } },
    { id: 'vault_19', name: '黎明使者', minFloor: 29, effect: { type: 'atkVaultFlat', value: 20 } },
    { id: 'vault_20', name: '黄昏挽歌', minFloor: 29, effect: { type: 'defVaultFlat', value: 15 } },
    { id: 'vault_21', name: '天启之书', minFloor: 29, effect: { type: 'hpVaultFlat', value: 200 } },
    { id: 'vault_22', name: '深渊低语', minFloor: 39, effect: { type: 'atkVaultPct', value: 2.5 } },
    { id: 'vault_23', name: '凤凰之羽', minFloor: 39, effect: { type: 'hpVaultPct', value: 2.5 } },
    { id: 'vault_24', name: '泰坦之拳', minFloor: 39, effect: { type: 'defVaultPct', value: 2.5 } },
    { id: 'vault_25', name: '守护者之盾', minFloor: 39, effect: { type: 'critDmgVaultPct', value: 2.5 } },
    { id: 'vault_26', name: '精灵王冠', minFloor: 39, effect: { type: 'atkVaultFlat', value: 25 } },
    { id: 'vault_27', name: '矮人王斧', minFloor: 39, effect: { type: 'defVaultFlat', value: 20 } },
    { id: 'vault_28', name: '海神三叉戟', minFloor: 39, effect: { type: 'hpVaultFlat', value: 250 } },
    { id: 'vault_29', name: '冥河摆渡', minFloor: 49, effect: { type: 'atkVaultPct', value: 3 } },
    { id: 'vault_30', name: '太阳金轮', minFloor: 49, effect: { type: 'hpVaultPct', value: 3 } },
    { id: 'vault_31', name: '月光碎片', minFloor: 49, effect: { type: 'defVaultPct', value: 3 } },
    { id: 'vault_32', name: '寂静之刃', minFloor: 49, effect: { type: 'critDmgVaultPct', value: 3 } },
    { id: 'vault_33', name: '狂怒战鼓', minFloor: 49, effect: { type: 'atkVaultFlat', value: 30 } },
    { id: 'vault_34', name: '治愈圣杯', minFloor: 49, effect: { type: 'defVaultFlat', value: 25 } },
    { id: 'vault_35', name: '诅咒匕首', minFloor: 49, effect: { type: 'hpVaultFlat', value: 300 } },
    { id: 'vault_36', name: '真理之镜', minFloor: 59, effect: { type: 'atkVaultPct', value: 3.5 } },
    { id: 'vault_37', name: '欺诈面具', minFloor: 59, effect: { type: 'hpVaultPct', value: 3.5 } },
    { id: 'vault_38', name: '破法者之眼', minFloor: 59, effect: { type: 'defVaultPct', value: 3.5 } },
    { id: 'vault_39', name: '时间沙漏', minFloor: 59, effect: { type: 'critDmgVaultPct', value: 3.5 } },
    { id: 'vault_40', name: '空间锚点', minFloor: 59, effect: { type: 'atkVaultFlat', value: 35 } },
    { id: 'vault_41', name: '先知头骨', minFloor: 59, effect: { type: 'defVaultFlat', value: 30 } },
    { id: 'vault_42', name: '圣徒之心', minFloor: 59, effect: { type: 'hpVaultFlat', value: 350 } },
    { id: 'vault_43', name: '巨龙之眼', minFloor: 69, effect: { type: 'atkVaultPct', value: 4 } },
    { id: 'vault_44', name: '天使之羽', minFloor: 69, effect: { type: 'hpVaultPct', value: 4 } },
    { id: 'vault_45', name: '恶魔角杯', minFloor: 69, effect: { type: 'defVaultPct', value: 4 } },
    { id: 'vault_46', name: '不朽者之血', minFloor: 69, effect: { type: 'critDmgVaultPct', value: 4 } },
    { id: 'vault_47', name: '贤者之石', minFloor: 69, effect: { type: 'atkVaultFlat', value: 40 } },
    { id: 'vault_48', name: '创世者指骨', minFloor: 69, effect: { type: 'defVaultFlat', value: 35 } },
    { id: 'vault_49', name: '殉道者裹尸布', minFloor: 69, effect: { type: 'hpVaultFlat', value: 400 } },
    { id: 'vault_50', name: '初代教皇冠冕', minFloor: 79, effect: { type: 'atkVaultPct', value: 4.5 } },
    { id: 'vault_51', name: '凤凰涅槃灰烬', minFloor: 79, effect: { type: 'hpVaultPct', value: 4.5 } },
    { id: 'vault_52', name: '泰坦脊骨', minFloor: 79, effect: { type: 'defVaultPct', value: 4.5 } },
    { id: 'vault_53', name: '古神触须', minFloor: 79, effect: { type: 'critDmgVaultPct', value: 4.5 } },
    { id: 'vault_54', name: '精灵祖树之种', minFloor: 79, effect: { type: 'atkVaultFlat', value: 45 } },
    { id: 'vault_55', name: '矮人先祖之锤', minFloor: 79, effect: { type: 'defVaultFlat', value: 40 } },
    { id: 'vault_56', name: '兽人战神獠牙', minFloor: 79, effect: { type: 'hpVaultFlat', value: 450 } },
    { id: 'vault_57', name: '海妖塞壬之喉', minFloor: 89, effect: { type: 'atkVaultPct', value: 5 } },
    { id: 'vault_58', name: '独角兽断角', minFloor: 89, effect: { type: 'hpVaultPct', value: 5 } },
    { id: 'vault_59', name: '狼人之心', minFloor: 89, effect: { type: 'defVaultPct', value: 5 } },
    { id: 'vault_60', name: '吸血鬼始祖之牙', minFloor: 89, effect: { type: 'critDmgVaultPct', value: 5 } },
    { id: 'vault_61', name: '石像鬼核心', minFloor: 89, effect: { type: 'atkVaultFlat', value: 50 } },
    { id: 'vault_62', name: '元素领主晶核', minFloor: 89, effect: { type: 'defVaultFlat', value: 45 } },
    { id: 'vault_63', name: '深渊魔龙逆鳞', minFloor: 89, effect: { type: 'hpVaultFlat', value: 500 } },
    { id: 'vault_64', name: '光明天使光环', minFloor: 99, effect: { type: 'atkVaultPct', value: 5.5 } },
    { id: 'vault_65', name: '堕天使之翼', minFloor: 99, effect: { type: 'hpVaultPct', value: 5.5 } },
    { id: 'vault_66', name: '冥王哈迪斯头盔', minFloor: 99, effect: { type: 'defVaultPct', value: 5.5 } },
    { id: 'vault_67', name: '宙斯雷霆碎片', minFloor: 99, effect: { type: 'critDmgVaultPct', value: 5.5 } },
    { id: 'vault_68', name: '奥丁独眼', minFloor: 99, effect: { type: 'atkVaultFlat', value: 55 } },
    { id: 'vault_69', name: '洛基的谎言', minFloor: 99, effect: { type: 'defVaultFlat', value: 50 } },
    { id: 'vault_70', name: '雅典娜的猫头鹰', minFloor: 99, effect: { type: 'hpVaultFlat', value: 550 } },
    { id: 'vault_71', name: '阿努比斯的天平', minFloor: 109, effect: { type: 'atkVaultPct', value: 6 } },
    { id: 'vault_72', name: '荷鲁斯之眼', minFloor: 109, effect: { type: 'hpVaultPct', value: 6 } },
    { id: 'vault_73', name: '湿婆的第三只眼', minFloor: 109, effect: { type: 'defVaultPct', value: 6 } },
    { id: 'vault_74', name: '佛陀舍利', minFloor: 109, effect: { type: 'critDmgVaultPct', value: 6 } },
    { id: 'vault_75', name: '传道者手稿', minFloor: 109, effect: { type: 'atkVaultFlat', value: 60 } },
    { id: 'vault_76', name: '异端审判烙印', minFloor: 109, effect: { type: 'defVaultFlat', value: 55 } },
    { id: 'vault_77', name: '圣殿骑士团圣印', minFloor: 109, effect: { type: 'hpVaultFlat', value: 600 } },
    { id: 'vault_78', name: '女巫审判火刑柱', minFloor: 119, effect: { type: 'atkVaultPct', value: 6.5 } },
    { id: 'vault_79', name: '海盗王藏宝图', minFloor: 119, effect: { type: 'hpVaultPct', value: 6.5 } },
    { id: 'vault_80', name: '失落文明石板', minFloor: 119, effect: { type: 'defVaultPct', value: 6.5 } },
    { id: 'vault_81', name: '世界树嫩枝', minFloor: 119, effect: { type: 'critDmgVaultPct', value: 6.5 } },
    { id: 'vault_82', name: '永恒之火', minFloor: 119, effect: { type: 'atkVaultFlat', value: 65 } },
    { id: 'vault_83', name: '不灭之冰', minFloor: 119, effect: { type: 'defVaultFlat', value: 60 } },
    { id: 'vault_84', name: '风暴之眼', minFloor: 119, effect: { type: 'hpVaultFlat', value: 650 } },
    { id: 'vault_85', name: '大地之心', minFloor: 129, effect: { type: 'atkVaultPct', value: 7 } },
    { id: 'vault_86', name: '生命之泉', minFloor: 129, effect: { type: 'hpVaultPct', value: 7 } },
    { id: 'vault_87', name: '死亡之息', minFloor: 129, effect: { type: 'defVaultPct', value: 7 } },
    { id: 'vault_88', name: '虚空裂隙', minFloor: 129, effect: { type: 'critDmgVaultPct', value: 7 } },
    { id: 'vault_89', name: '彩虹桥碎片', minFloor: 129, effect: { type: 'atkVaultFlat', value: 70 } },
    { id: 'vault_90', name: '极光帷幕', minFloor: 129, effect: { type: 'defVaultFlat', value: 65 } },
    { id: 'vault_91', name: '流星泪', minFloor: 129, effect: { type: 'hpVaultFlat', value: 700 } },
    { id: 'vault_92', name: '日曜石', minFloor: 139, effect: { type: 'atkVaultPct', value: 7.5 } },
    { id: 'vault_93', name: '月长石', minFloor: 139, effect: { type: 'hpVaultPct', value: 7.5 } },
    { id: 'vault_94', name: '星辰沙', minFloor: 139, effect: { type: 'defVaultPct', value: 7.5 } },
    { id: 'vault_95', name: '深渊珍珠', minFloor: 139, effect: { type: 'critDmgVaultPct', value: 7.5 } },
    { id: 'vault_96', name: '龙晶', minFloor: 139, effect: { type: 'atkVaultFlat', value: 75 } },
    { id: 'vault_97', name: '凤凰蛋', minFloor: 139, effect: { type: 'defVaultFlat', value: 70 } },
    { id: 'vault_98', name: '元素王冠', minFloor: 139, effect: { type: 'hpVaultFlat', value: 750 } },
    { id: 'vault_99', name: '潮汐宝珠', minFloor: 149, effect: { type: 'atkVaultPct', value: 8 } },
    { id: 'vault_100', name: '熔岩核心', minFloor: 149, effect: { type: 'hpVaultPct', value: 8 } },
    { id: 'vault_101', name: '雷霆之种', minFloor: 149, effect: { type: 'defVaultPct', value: 8 } },
    { id: 'vault_102', name: '暗影之种', minFloor: 149, effect: { type: 'critDmgVaultPct', value: 8 } },
    { id: 'vault_103', name: '光明圣晶', minFloor: 149, effect: { type: 'atkVaultFlat', value: 80 } },
    { id: 'vault_104', name: '混沌原石', minFloor: 149, effect: { type: 'defVaultFlat', value: 75 } },
    { id: 'vault_105', name: '秩序锁链', minFloor: 149, effect: { type: 'hpVaultFlat', value: 800 } },
    { id: 'vault_106', name: '时间之花', minFloor: 159, effect: { type: 'atkVaultPct', value: 8.5 } },
    { id: 'vault_107', name: '空间褶皱', minFloor: 159, effect: { type: 'hpVaultPct', value: 8.5 } },
    { id: 'vault_108', name: '梦境结晶', minFloor: 159, effect: { type: 'defVaultPct', value: 8.5 } },
    { id: 'vault_109', name: '记忆水晶', minFloor: 159, effect: { type: 'critDmgVaultPct', value: 8.5 } },
    { id: 'vault_110', name: '命运丝线', minFloor: 159, effect: { type: 'atkVaultFlat', value: 85 } },
    { id: 'vault_111', name: '希望之光', minFloor: 159, effect: { type: 'defVaultFlat', value: 80 } },
    { id: 'vault_112', name: '绝望之种', minFloor: 159, effect: { type: 'hpVaultFlat', value: 850 } },
    { id: 'vault_113', name: '爱之泪', minFloor: 169, effect: { type: 'atkVaultPct', value: 9 } },
    { id: 'vault_114', name: '恨之血', minFloor: 169, effect: { type: 'hpVaultPct', value: 9 } },
    { id: 'vault_115', name: '智慧果', minFloor: 169, effect: { type: 'defVaultPct', value: 9 } },
    { id: 'vault_116', name: '愚者之金', minFloor: 169, effect: { type: 'critDmgVaultPct', value: 9 } },
    { id: 'vault_117', name: '幸运四叶草', minFloor: 169, effect: { type: 'atkVaultFlat', value: 90 } },
    { id: 'vault_118', name: '厄运黑猫', minFloor: 169, effect: { type: 'defVaultFlat', value: 85 } },
    { id: 'vault_119', name: '丰饶之角', minFloor: 169, effect: { type: 'hpVaultFlat', value: 900 } },
    { id: 'vault_120', name: '饥荒之釜', minFloor: 179, effect: { type: 'atkVaultPct', value: 9.5 } },
    { id: 'vault_121', name: '创世石板', minFloor: 179, effect: { type: 'hpVaultPct', value: 9.5 } },
    { id: 'vault_122', name: '命运之书', minFloor: 179, effect: { type: 'defVaultPct', value: 9.5 } },
    { id: 'vault_123', name: '死海古卷', minFloor: 179, effect: { type: 'critDmgVaultPct', value: 9.5 } },
    { id: 'vault_124', name: '所罗门之钥', minFloor: 179, effect: { type: 'atkVaultFlat', value: 95 } },
    { id: 'vault_125', name: '亡灵黑经', minFloor: 179, effect: { type: 'defVaultFlat', value: 90 } },
    { id: 'vault_126', name: '太阳金经', minFloor: 179, effect: { type: 'hpVaultFlat', value: 950 } },
    { id: 'vault_127', name: '伏尼契手稿', minFloor: 189, effect: { type: 'atkVaultPct', value: 10 } },
    { id: 'vault_128', name: '预言之池', minFloor: 189, effect: { type: 'hpVaultPct', value: 10 } },
    { id: 'vault_129', name: '禁忌法典', minFloor: 189, effect: { type: 'defVaultPct', value: 10 } },
    { id: 'vault_130', name: '恶魔契约', minFloor: 189, effect: { type: 'critDmgVaultPct', value: 10 } },
    { id: 'vault_131', name: '天使盟约', minFloor: 189, effect: { type: 'atkVaultFlat', value: 100 } },
    { id: 'vault_132', name: '神之遗嘱', minFloor: 189, effect: { type: 'defVaultFlat', value: 95 } },
    { id: 'vault_133', name: '龙语卷轴', minFloor: 189, effect: { type: 'hpVaultFlat', value: 1000 } },
    { id: 'vault_134', name: '精灵诗篇', minFloor: 199, effect: { type: 'atkVaultPct', value: 10.5 } },
    { id: 'vault_135', name: '矮人锻造图', minFloor: 199, effect: { type: 'hpVaultPct', value: 10.5 } },
    { id: 'vault_136', name: '航海日志', minFloor: 199, effect: { type: 'defVaultPct', value: 10.5 } },
    { id: 'vault_137', name: '星象图', minFloor: 199, effect: { type: 'critDmgVaultPct', value: 10.5 } },
    { id: 'vault_138', name: '炼金术笔记', minFloor: 199, effect: { type: 'atkVaultFlat', value: 105 } },
    { id: 'vault_139', name: '巫术咒文', minFloor: 199, effect: { type: 'defVaultFlat', value: 100 } },
    { id: 'vault_140', name: '圣歌集', minFloor: 199, effect: { type: 'hpVaultFlat', value: 1050 } },
    { id: 'vault_141', name: '潘多拉魔盒', minFloor: 209, effect: { type: 'atkVaultPct', value: 11 } },
    { id: 'vault_142', name: '该隐的印记', minFloor: 209, effect: { type: 'hpVaultPct', value: 11 } },
    { id: 'vault_143', name: '犹大银币', minFloor: 209, effect: { type: 'defVaultPct', value: 11 } },
    { id: 'vault_144', name: '美杜莎之首', minFloor: 209, effect: { type: 'critDmgVaultPct', value: 11 } },
    { id: 'vault_145', name: '诅咒金币', minFloor: 209, effect: { type: 'atkVaultFlat', value: 110 } },
    { id: 'vault_146', name: '灾厄之壶', minFloor: 209, effect: { type: 'defVaultFlat', value: 105 } },
    { id: 'vault_147', name: '瘟疫之源', minFloor: 209, effect: { type: 'hpVaultFlat', value: 1100 } },
    { id: 'vault_148', name: '战争号角', minFloor: 219, effect: { type: 'atkVaultPct', value: 11.5 } },
    { id: 'vault_149', name: '饥荒之镰', minFloor: 219, effect: { type: 'hpVaultPct', value: 11.5 } },
    { id: 'vault_150', name: '死亡之钟', minFloor: 219, effect: { type: 'defVaultPct', value: 11.5 } },
    { id: 'vault_151', name: '七宗罪面具', minFloor: 219, effect: { type: 'critDmgVaultPct', value: 11.5 } },
    { id: 'vault_152', name: '深渊低语者', minFloor: 219, effect: { type: 'atkVaultFlat', value: 115 } },
    { id: 'vault_153', name: '旧神雕像', minFloor: 219, effect: { type: 'defVaultFlat', value: 110 } },
    { id: 'vault_154', name: '邪神祭坛', minFloor: 219, effect: { type: 'hpVaultFlat', value: 1150 } },
    { id: 'vault_155', name: '血祭匕首', minFloor: 229, effect: { type: 'atkVaultPct', value: 12 } },
    { id: 'vault_156', name: '缚魂瓶', minFloor: 229, effect: { type: 'hpVaultPct', value: 12 } },
    { id: 'vault_157', name: '摄魂怪之吻', minFloor: 229, effect: { type: 'defVaultPct', value: 12 } },
    { id: 'vault_158', name: '永世诅咒的戒指', minFloor: 229, effect: { type: 'critDmgVaultPct', value: 12 } },
    { id: 'vault_159', name: '背叛者之刃', minFloor: 229, effect: { type: 'atkVaultFlat', value: 120 } },
    { id: 'vault_160', name: '虚无之核', minFloor: 229, effect: { type: 'defVaultFlat', value: 115 } },
    { id: 'vault_161', name: '王权之证', minFloor: 229, effect: { type: 'hpVaultFlat', value: 1200 } },
    { id: 'vault_162', name: '神格碎片', minFloor: 239, effect: { type: 'atkVaultPct', value: 12.5 } },
    { id: 'vault_163', name: '人性之锚', minFloor: 239, effect: { type: 'hpVaultPct', value: 12.5 } },
    { id: 'vault_164', name: '自由意志', minFloor: 239, effect: { type: 'defVaultPct', value: 12.5 } },
    { id: 'vault_165', name: '因果律武器', minFloor: 239, effect: { type: 'critDmgVaultPct', value: 12.5 } },
    { id: 'vault_166', name: '存在证明', minFloor: 239, effect: { type: 'atkVaultFlat', value: 125 } },
    { id: 'vault_167', name: '虚无之证', minFloor: 239, effect: { type: 'defVaultFlat', value: 120 } },
    { id: 'vault_168', name: '真理之门', minFloor: 239, effect: { type: 'hpVaultFlat', value: 1250 } },
    { id: 'vault_169', name: '轮回之印', minFloor: 249, effect: { type: 'atkVaultPct', value: 13 } },
    { id: 'vault_170', name: '救赎之证', minFloor: 249, effect: { type: 'hpVaultPct', value: 13 } },
    { id: 'vault_171', name: '原罪之核', minFloor: 249, effect: { type: 'defVaultPct', value: 13 } },
    { id: 'vault_172', name: '美德之冠', minFloor: 249, effect: { type: 'critDmgVaultPct', value: 13 } },
    { id: 'vault_173', name: '信仰结晶', minFloor: 249, effect: { type: 'atkVaultFlat', value: 130 } },
    { id: 'vault_174', name: '希望火种', minFloor: 249, effect: { type: 'defVaultFlat', value: 125 } },
    { id: 'vault_175', name: '绝望之核', minFloor: 249, effect: { type: 'hpVaultFlat', value: 1300 } },
    { id: 'vault_176', name: '爱之契约', minFloor: 259, effect: { type: 'atkVaultPct', value: 13.5 } },
    { id: 'vault_177', name: '恨之根源', minFloor: 259, effect: { type: 'hpVaultPct', value: 13.5 } },
    { id: 'vault_178', name: '记忆宫殿', minFloor: 259, effect: { type: 'defVaultPct', value: 13.5 } },
    { id: 'vault_179', name: '梦境之钥', minFloor: 259, effect: { type: 'critDmgVaultPct', value: 13.5 } },
    { id: 'vault_m1', name: '萌芽兽', minFloor: 9, effect: { type: 'petAtkVaultPct', value: 1 } },
    { id: 'vault_m2', name: '脉冲兽', minFloor: 9, effect: { type: 'petHpVaultPct', value: 1 } },
    { id: 'vault_m3', name: '铠石兽', minFloor: 9, effect: { type: 'petDefVaultPct', value: 1 } },
    { id: 'vault_m4', name: '灵狐兽', minFloor: 9, effect: { type: 'petAtkVaultFlat', value: 10 } },
    { id: 'vault_m5', name: '电光兽', minFloor: 9, effect: { type: 'petDefVaultFlat', value: 5 } },
    { id: 'vault_m6', name: '叶隐兽', minFloor: 9, effect: { type: 'petHpVaultFlat', value: 50 } },
    { id: 'vault_m7', name: '盾甲兽', minFloor: 19, effect: { type: 'petAtkVaultPct', value: 1.5 } },
    { id: 'vault_m8', name: '音波兽', minFloor: 19, effect: { type: 'petHpVaultPct', value: 1.5 } },
    { id: 'vault_m9', name: '浮游兽', minFloor: 19, effect: { type: 'petDefVaultPct', value: 1.5 } },
    { id: 'vault_m10', name: '利爪兽', minFloor: 19, effect: { type: 'petAtkVaultFlat', value: 15 } },
    { id: 'vault_m11', name: '灼眼兽', minFloor: 19, effect: { type: 'petDefVaultFlat', value: 10 } },
    { id: 'vault_m12', name: '寒羽兽', minFloor: 19, effect: { type: 'petHpVaultFlat', value: 100 } },
    { id: 'vault_m13', name: '钢尾兽', minFloor: 29, effect: { type: 'petAtkVaultPct', value: 2 } },
    { id: 'vault_m14', name: '幻影兽', minFloor: 29, effect: { type: 'petHpVaultPct', value: 2 } },
    { id: 'vault_m15', name: '齿轮兽', minFloor: 29, effect: { type: 'petDefVaultPct', value: 2 } },
    { id: 'vault_m16', name: '藤蔓兽', minFloor: 29, effect: { type: 'petAtkVaultFlat', value: 20 } },
    { id: 'vault_m17', name: '爆裂兽', minFloor: 29, effect: { type: 'petDefVaultFlat', value: 15 } },
    { id: 'vault_m18', name: '深潜兽', minFloor: 29, effect: { type: 'petHpVaultFlat', value: 200 } },
    { id: 'vault_m19', name: '夜行兽', minFloor: 39, effect: { type: 'petAtkVaultPct', value: 2.5 } },
    { id: 'vault_m20', name: '晶体兽', minFloor: 39, effect: { type: 'petHpVaultPct', value: 2.5 } },
    { id: 'vault_m21', name: '旋风兽', minFloor: 39, effect: { type: 'petDefVaultPct', value: 2.5 } },
    { id: 'vault_m22', name: '熔核兽', minFloor: 39, effect: { type: 'petAtkVaultFlat', value: 25 } },
    { id: 'vault_m23', name: '磁力兽', minFloor: 39, effect: { type: 'petDefVaultFlat', value: 20 } },
    { id: 'vault_m24', name: '雾影兽', minFloor: 39, effect: { type: 'petHpVaultFlat', value: 250 } },
    { id: 'vault_m25', name: '铁喙兽', minFloor: 49, effect: { type: 'petAtkVaultPct', value: 3 } },
    { id: 'vault_m26', name: '念力兽', minFloor: 49, effect: { type: 'petHpVaultPct', value: 3 } },
    { id: 'vault_m27', name: '迅雷兽', minFloor: 49, effect: { type: 'petDefVaultPct', value: 3 } },
    { id: 'vault_m28', name: '珊瑚兽', minFloor: 49, effect: { type: 'petAtkVaultFlat', value: 30 } },
    { id: 'vault_m29', name: '孢子兽', minFloor: 49, effect: { type: 'petDefVaultFlat', value: 25 } },
    { id: 'vault_m30', name: '光刃兽', minFloor: 49, effect: { type: 'petHpVaultFlat', value: 300 } },
    { id: 'vault_m31', name: '圣剑骑士兽', minFloor: 59, effect: { type: 'petAtkVaultPct', value: 3.5 } },
    { id: 'vault_m32', name: '暗影巫师兽', minFloor: 59, effect: { type: 'petHpVaultPct', value: 3.5 } },
    { id: 'vault_m33', name: '天翔羽蛇兽', minFloor: 59, effect: { type: 'petDefVaultPct', value: 3.5 } },
    { id: 'vault_m34', name: '雷霆狮鹫兽', minFloor: 59, effect: { type: 'petAtkVaultFlat', value: 35 } },
    { id: 'vault_m35', name: '寒霜剑齿兽', minFloor: 59, effect: { type: 'petDefVaultFlat', value: 30 } },
    { id: 'vault_m36', name: '炽焰武神兽', minFloor: 59, effect: { type: 'petHpVaultFlat', value: 350 } },
    { id: 'vault_m37', name: '岩铁巨像兽', minFloor: 69, effect: { type: 'petAtkVaultPct', value: 4 } },
    { id: 'vault_m38', name: '深渊海龙兽', minFloor: 69, effect: { type: 'petHpVaultPct', value: 4 } },
    { id: 'vault_m39', name: '幻光蝶兽', minFloor: 69, effect: { type: 'petDefVaultPct', value: 4 } },
    { id: 'vault_m40', name: '脉冲星兽', minFloor: 69, effect: { type: 'petAtkVaultFlat', value: 40 } },
    { id: 'vault_m41', name: '荆棘女王兽', minFloor: 69, effect: { type: 'petDefVaultFlat', value: 35 } },
    { id: 'vault_m42', name: '合金猛犸兽', minFloor: 69, effect: { type: 'petHpVaultFlat', value: 400 } },
    { id: 'vault_m43', name: '虚空猎手兽', minFloor: 79, effect: { type: 'petAtkVaultPct', value: 4.5 } },
    { id: 'vault_m44', name: '圣光独角兽', minFloor: 79, effect: { type: 'petHpVaultPct', value: 4.5 } },
    { id: 'vault_m45', name: '剧毒狼蛛兽', minFloor: 79, effect: { type: 'petDefVaultPct', value: 4.5 } },
    { id: 'vault_m46', name: '风暴鹰身兽', minFloor: 79, effect: { type: 'petAtkVaultFlat', value: 45 } },
    { id: 'vault_m47', name: '冥府判官兽', minFloor: 79, effect: { type: 'petDefVaultFlat', value: 40 } },
    { id: 'vault_m48', name: '数据守卫兽', minFloor: 79, effect: { type: 'petHpVaultFlat', value: 450 } },
    { id: 'vault_m49', name: '破城犀甲兽', minFloor: 89, effect: { type: 'petAtkVaultPct', value: 5 } },
    { id: 'vault_m50', name: '潮汐领主兽', minFloor: 89, effect: { type: 'petHpVaultPct', value: 5 } },
    { id: 'vault_m51', name: '电磁公爵兽', minFloor: 89, effect: { type: 'petDefVaultPct', value: 5 } },
    { id: 'vault_m52', name: '森之贤者兽', minFloor: 89, effect: { type: 'petAtkVaultFlat', value: 50 } },
    { id: 'vault_m53', name: '爆岩金刚兽', minFloor: 89, effect: { type: 'petDefVaultFlat', value: 45 } },
    { id: 'vault_m54', name: '影舞忍者兽', minFloor: 89, effect: { type: 'petHpVaultFlat', value: 500 } },
    { id: 'vault_m55', name: '光棱圣堂兽', minFloor: 99, effect: { type: 'petAtkVaultPct', value: 5.5 } },
    { id: 'vault_m56', name: '蚀刻魔像兽', minFloor: 99, effect: { type: 'petHpVaultPct', value: 5.5 } },
    { id: 'vault_m57', name: '啸天战狼兽', minFloor: 99, effect: { type: 'petDefVaultPct', value: 5.5 } },
    { id: 'vault_m58', name: '等离子凤凰兽', minFloor: 99, effect: { type: 'petAtkVaultFlat', value: 55 } },
    { id: 'vault_m59', name: '陨铁霸王龙兽', minFloor: 99, effect: { type: 'petDefVaultFlat', value: 50 } },
    { id: 'vault_m60', name: '梦境编织兽', minFloor: 99, effect: { type: 'petHpVaultFlat', value: 550 } },
    { id: 'vault_m61', name: '要塞龟兽', minFloor: 109, effect: { type: 'petAtkVaultPct', value: 6 } },
    { id: 'vault_m62', name: '逐日天马兽', minFloor: 109, effect: { type: 'petHpVaultPct', value: 6 } },
    { id: 'vault_m63', name: '裂地鳌钳兽', minFloor: 109, effect: { type: 'petDefVaultPct', value: 6 } },
    { id: 'vault_m64', name: '诡术幻影兽', minFloor: 109, effect: { type: 'petAtkVaultFlat', value: 60 } },
    { id: 'vault_m65', name: '治愈灵鹿兽', minFloor: 109, effect: { type: 'petDefVaultFlat', value: 55 } },
    { id: 'vault_m66', name: '水晶蝎王兽', minFloor: 109, effect: { type: 'petHpVaultFlat', value: 600 } },
    { id: 'vault_m67', name: '咒文祭祀兽', minFloor: 119, effect: { type: 'petAtkVaultPct', value: 6.5 } },
    { id: 'vault_m68', name: '裁决天使兽', minFloor: 119, effect: { type: 'petHpVaultPct', value: 6.5 } },
    { id: 'vault_m69', name: '湮灭魔龙兽', minFloor: 119, effect: { type: 'petDefVaultPct', value: 6.5 } },
    { id: 'vault_m70', name: '永恒圣枪兽', minFloor: 119, effect: { type: 'petAtkVaultFlat', value: 65 } },
    { id: 'vault_m71', name: '混沌领主兽', minFloor: 119, effect: { type: 'petDefVaultFlat', value: 60 } },
    { id: 'vault_m72', name: '银河骑士兽', minFloor: 119, effect: { type: 'petHpVaultFlat', value: 650 } },
    { id: 'vault_m73', name: '深渊吞噬兽', minFloor: 129, effect: { type: 'petAtkVaultPct', value: 7 } },
    { id: 'vault_m74', name: '神罚雷霆兽', minFloor: 129, effect: { type: 'petHpVaultPct', value: 7 } },
    { id: 'vault_m75', name: '不朽战神兽', minFloor: 129, effect: { type: 'petDefVaultPct', value: 7 } },
    { id: 'vault_m76', name: '虚空观测者兽', minFloor: 129, effect: { type: 'petAtkVaultFlat', value: 70 } },
    { id: 'vault_m77', name: '元素统御者兽', minFloor: 129, effect: { type: 'petDefVaultFlat', value: 65 } },
    { id: 'vault_m78', name: '太阳神翼神龙兽', minFloor: 129, effect: { type: 'petHpVaultFlat', value: 700 } },
    { id: 'vault_m79', name: '月神阿尔忒弥斯兽', minFloor: 139, effect: { type: 'petAtkVaultPct', value: 7.5 } },
    { id: 'vault_m80', name: '冥王哈迪斯兽', minFloor: 139, effect: { type: 'petHpVaultPct', value: 7.5 } },
    { id: 'vault_m81', name: '海皇波塞冬兽', minFloor: 139, effect: { type: 'petDefVaultPct', value: 7.5 } },
    { id: 'vault_m82', name: '智慧雅典娜兽', minFloor: 139, effect: { type: 'petAtkVaultFlat', value: 75 } },
    { id: 'vault_m83', name: '战神阿瑞斯兽', minFloor: 139, effect: { type: 'petDefVaultFlat', value: 70 } },
    { id: 'vault_m84', name: '泰坦巨神兽', minFloor: 139, effect: { type: 'petHpVaultFlat', value: 750 } },
    { id: 'vault_m85', name: '世界树守护兽', minFloor: 149, effect: { type: 'petAtkVaultPct', value: 8 } },
    { id: 'vault_m86', name: '方舟诺亚兽', minFloor: 149, effect: { type: 'petHpVaultPct', value: 8 } },
    { id: 'vault_m87', name: '魔神巴尔兽', minFloor: 149, effect: { type: 'petDefVaultPct', value: 8 } },
    { id: 'vault_m88', name: '圣凰涅槃兽', minFloor: 149, effect: { type: 'petAtkVaultFlat', value: 80 } },
    { id: 'vault_m89', name: '暗黑邪神兽', minFloor: 149, effect: { type: 'petDefVaultFlat', value: 75 } },
    { id: 'vault_m90', name: '机械降神兽', minFloor: 149, effect: { type: 'petHpVaultFlat', value: 800 } },
    { id: 'vault_m91', name: '基因原体兽', minFloor: 159, effect: { type: 'atkVaultPct', value: 8.5 } },
    { id: 'vault_m92', name: '时空巡警兽', minFloor: 159, effect: { type: 'hpVaultPct', value: 8.5 } },
    { id: 'vault_m93', name: '因果律兵器兽', minFloor: 159, effect: { type: 'defVaultPct', value: 8.5 } },
    { id: 'vault_m94', name: '宇宙大帝兽', minFloor: 159, effect: { type: 'atkVaultFlat', value: 85 } },
    { id: 'vault_m95', name: '数据删除者兽', minFloor: 159, effect: { type: 'defVaultFlat', value: 80 } },
    { id: 'vault_m96', name: '网络防火墙兽', minFloor: 159, effect: { type: 'hpVaultFlat', value: 850 } },
    { id: 'vault_m97', name: '量子幽灵兽', minFloor: 169, effect: { type: 'atkVaultPct', value: 9 } },
    { id: 'vault_m98', name: '模因感染源兽', minFloor: 169, effect: { type: 'petHpVaultPct', value: 9 } },
    { id: 'vault_m99', name: '集体潜意识兽', minFloor: 169, effect: { type: 'petDefVaultPct', value: 9 } },
    { id: 'vault_m100', name: '文明观测者兽', minFloor: 169, effect: { type: 'petAtkVaultFlat', value: 90 } },
    { id: 'vault_m101', name: '生态化身盖亚兽', minFloor: 169, effect: { type: 'petDefVaultFlat', value: 85 } },
    { id: 'vault_m102', name: '熵增终结者兽', minFloor: 169, effect: { type: 'petHpVaultFlat', value: 900 } },
    { id: 'vault_m103', name: '维度旅行者兽', minFloor: 179, effect: { type: 'petAtkVaultPct', value: 9.5 } },
    { id: 'vault_m104', name: '符文君王兽', minFloor: 179, effect: { type: 'petHpVaultPct', value: 9.5 } },
    { id: 'vault_m105', name: '咒缚之王兽', minFloor: 179, effect: { type: 'petDefVaultPct', value: 9.5 } },
    { id: 'vault_m106', name: '英灵殿战神兽', minFloor: 179, effect: { type: 'petAtkVaultFlat', value: 95 } },
    { id: 'vault_m107', name: '至高天神兽', minFloor: 179, effect: { type: 'petDefVaultFlat', value: 90 } },
    { id: 'vault_m108', name: '终焉灭世魔兽', minFloor: 179, effect: { type: 'petHpVaultFlat', value: 950 } },
    { id: 'vault_m109', name: '归零虚无兽', minFloor: 189, effect: { type: 'petAtkVaultPct', value: 10 } },
    { id: 'vault_m110', name: '起源圣皇兽', minFloor: 189, effect: { type: 'petHpVaultPct', value: 10 } },
    { id: 'vault_m111', name: '永恒轮回兽', minFloor: 189, effect: { type: 'petDefVaultPct', value: 10 } },
    { id: 'vault_m112', name: '超脱次元兽', minFloor: 189, effect: { type: 'petAtkVaultFlat', value: 100 } },
    { id: 'vault_m113', name: '万象记录者兽', minFloor: 189, effect: { type: 'petDefVaultFlat', value: 95 } },
    { id: 'vault_m114', name: '可能性收束者兽', minFloor: 189, effect: { type: 'petHpVaultFlat', value: 1000 } },
    { id: 'vault_m115', name: '龙帝艾可萨兽', minFloor: 199, effect: { type: 'petAtkVaultPct', value: 10.5 } },
    { id: 'vault_m116', name: '奥米加兽·慈悲形态', minFloor: 199, effect: { type: 'petHpVaultPct', value: 10.5 } },
    { id: 'vault_m117', name: '阿尔法兽·起源裁决', minFloor: 199, effect: { type: 'petDefVaultPct', value: 10.5 } },
    { id: 'vault_m118', name: '红莲骑士兽·真红莲', minFloor: 199, effect: { type: 'petAtkVaultFlat', value: 105 } },
    { id: 'vault_m119', name: '公爵兽·深红形态', minFloor: 199, effect: { type: 'petDefVaultFlat', value: 100 } },
    { id: 'vault_m120', name: '金甲龙兽·光辉壁垒', minFloor: 199, effect: { type: 'petHpVaultFlat', value: 1050 } },
    { id: 'vault_m121', name: '八足马兽·神速', minFloor: 209, effect: { type: 'petAtkVaultPct', value: 11 } },
    { id: 'vault_m122', name: '剑皇兽·决意', minFloor: 209, effect: { type: 'petHpVaultPct', value: 11 } },
    { id: 'vault_m123', name: '杜纳斯兽·天龙', minFloor: 209, effect: { type: 'petDefVaultPct', value: 11 } },
    { id: 'vault_m124', name: '蔷薇兽·绽放', minFloor: 209, effect: { type: 'petAtkVaultFlat', value: 110 } },
    { id: 'vault_m125', name: '芳香兽·静谧', minFloor: 209, effect: { type: 'petDefVaultFlat', value: 105 } },
    { id: 'vault_m126', name: '领主骑士兽·王权', minFloor: 209, effect: { type: 'petHpVaultFlat', value: 1100 } },
    { id: 'vault_m127', name: '颅骨兽·铁壁', minFloor: 219, effect: { type: 'petAtkVaultPct', value: 11.5 } },
    { id: 'vault_m128', name: '斯雷普兽·驰骋', minFloor: 219, effect: { type: 'petHpVaultPct', value: 11.5 } },
    { id: 'vault_m129', name: '艾可萨兽·龙魂', minFloor: 219, effect: { type: 'petDefVaultPct', value: 11.5 } },
    { id: 'vault_m130', name: '顽固兽·锻冶', minFloor: 219, effect: { type: 'petAtkVaultFlat', value: 115 } },
    { id: 'vault_m131', name: '优雅新星兽', minFloor: 219, effect: { type: 'petDefVaultFlat', value: 110 } },
    { id: 'vault_m132', name: '闪光暴龙兽·爆裂', minFloor: 219, effect: { type: 'petHpVaultFlat', value: 1150 } },
    { id: 'vault_m133', name: '幻影加奥加兽', minFloor: 229, effect: { type: 'petAtkVaultPct', value: 12 } },
    { id: 'vault_m134', name: '渡鸦兽·暮光', minFloor: 229, effect: { type: 'petHpVaultPct', value: 12 } },
    { id: 'vault_m135', name: '咲耶兽·巫女', minFloor: 229, effect: { type: 'petDefVaultPct', value: 12 } },
    { id: 'vault_m136', name: '海天使兽·圣歌', minFloor: 229, effect: { type: 'petAtkVaultFlat', value: 120 } },
    { id: 'vault_m137', name: '神圣天女兽·圣弓', minFloor: 229, effect: { type: 'petDefVaultFlat', value: 115 } },
    { id: 'vault_m138', name: '神圣天使兽·神启', minFloor: 229, effect: { type: 'petHpVaultFlat', value: 1200 } },
    { id: 'vault_m139', name: '丧尸撒旦兽·绝望', minFloor: 239, effect: { type: 'petAtkVaultPct', value: 12.5 } },
    { id: 'vault_m140', name: '黑暗战斗暴龙兽', minFloor: 239, effect: { type: 'petHpVaultPct', value: 12.5 } },
    { id: 'vault_m141', name: '法老王兽·魂石', minFloor: 239, effect: { type: 'petDefVaultPct', value: 12.5 } },
    { id: 'vault_m142', name: '贝尔斯塔兽·慈悲', minFloor: 239, effect: { type: 'petAtkVaultFlat', value: 125 } },
    { id: 'vault_m143', name: '弩炮兽·要塞', minFloor: 239, effect: { type: 'petDefVaultFlat', value: 120 } },
    { id: 'vault_m144', name: '高吼兽·交响', minFloor: 239, effect: { type: 'petHpVaultFlat', value: 1250 } },
    { id: 'vault_m145', name: '杰斯兽·青锋', minFloor: 249, effect: { type: 'petAtkVaultPct', value: 13 } },
    { id: 'vault_m146', name: '超弦编织者兽', minFloor: 249, effect: { type: 'petHpVaultPct', value: 13 } },
    { id: 'vault_m147', name: '逻辑天道兽', minFloor: 249, effect: { type: 'petDefVaultPct', value: 13 } },
    { id: 'vault_m148', name: '叙事层观测者兽', minFloor: 249, effect: { type: 'petAtkVaultFlat', value: 130 } },
    { id: 'vault_m149', name: '大寂静化身兽', minFloor: 249, effect: { type: 'petDefVaultFlat', value: 125 } },
    { id: 'vault_m150', name: '第一因追溯者兽', minFloor: 249, effect: { type: 'petHpVaultFlat', value: 1300 } },
    { id: 'vault_m151', name: '可能性之海鲸兽', minFloor: 259, effect: { type: 'petAtkVaultPct', value: 13.5 } },
    { id: 'vault_m152', name: '文明墓碑兽', minFloor: 259, effect: { type: 'petHpVaultPct', value: 13.5 } },
    { id: 'vault_m153', name: '万物归一者兽', minFloor: 259, effect: { type: 'petDefVaultPct', value: 13.5 } }
];

// 升级奖励池（3选1）：百分比加成，选后累加到 abyssRun.buffs
var ABYSS_UPGRADE_POOL = [
    { key: 'atkPct', name: '攻击加成', value: 5, unit: '%' },
    { key: 'hpPct', name: '生命加成', value: 10, unit: '%' },
    { key: 'defPct', name: '防御加成', value: 5, unit: '%' },
    { key: 'lifestealPct', name: '吸血加成', value: 2, unit: '%' },
    { key: 'critRatePct', name: '暴击率加成', value: 2, unit: '%' },
    { key: 'dodgePct', name: '闪避加成', value: 2, unit: '%' },
    { key: 'critDmgPct', name: '爆伤加成', value: 5, unit: '%' },
    { key: 'petAtkPct', name: '宠物攻击加成', value: 5, unit: '%' },
    { key: 'petDefPct', name: '宠物防御加成', value: 5, unit: '%' },
    { key: 'petHpPct', name: '宠物生命加成', value: 8, unit: '%' },
    { key: 'goldPct', name: '金币加成', value: 3, unit: '%' },
    { key: 'expPct', name: '经验加成', value: 3, unit: '%' }
];

var ABYSS_CHOICE_POOL = [
    { key: 'hp', name: '生命', value: 80, valueScale: 5 },
    { key: 'atk', name: '攻击', value: 15, valueScale: 1 },
    { key: 'def', name: '防御', value: 8, valueScale: 0.5 },
    { key: 'lifesteal', name: '吸血', value: 0.5, valueScale: 0 },
    { key: 'dodge', name: '闪避', value: 0.5, valueScale: 0 },
    { key: 'critRate', name: '暴击率', value: 1, valueScale: 0 },
    { key: 'critDmg', name: '爆伤', value: 5, valueScale: 0 },
    { key: 'skillDmg', name: '技能伤害加成', value: 2, valueScale: 0 },
    { key: 'reduceMonsterDef', name: '减少怪物防御', value: 2, valueScale: 0 },
    { key: 'level', name: '增加25经验', value: 25, valueScale: 0 }
];

// ========== 无限深渊 特色玩法（含装备/材料/收藏品类） ==========
function abyssTrySpecialEvents(clearedFloor) {
    if (!abyssRun || !abyssRun.active || clearedFloor <= 0) return false;
    var f = clearedFloor;
    if (f % 20 === 0 && Math.random() < 1) {
        abyssShowTrial();
        return true;
    }
    if (f % 15 === 0 && Math.random() < 0.25) {
        abyssShowCurse();
        return true;
    }
    if (f % 14 === 0 && f % 10 !== 0 && Math.random() < 0.16) {
        abyssShowForge();
        return true;
    }
    if (f % 13 === 0 && f % 10 !== 0 && Math.random() < 0.16) {
        abyssShowEnhanceAltar();
        return true;
    }
    if (f % 12 === 0 && f % 10 !== 0 && Math.random() < 0.18) {
        abyssShowRuin();
        return true;
    }
    if (f % 11 === 0 && f % 10 !== 0 && Math.random() < 0.17) {
        abyssShowAppraiser();
        return true;
    }
    if (f % 9 === 0 && f % 10 !== 0 && Math.random() < 0.18) {
        abyssShowEnchantTable();
        return true;
    }
    if (f % 8 === 0 && f % 10 !== 0 && Math.random() < 0.2) {
        abyssShowMerchant();
        return true;
    }
    if (f % 7 === 0 && f % 10 !== 0 && Math.random() < 0.14) {
        abyssShowEquipChest();
        return true;
    }
    if (f % 6 === 0 && f % 10 !== 0 && Math.random() < 0.15) {
        abyssShowWheel();
        return true;
    }
    if (f % 18 === 0 && f % 10 !== 0 && Math.random() < 0.17) {
        abyssShowMaze();
        return true;
    }
    if (f % 17 === 0 && f % 10 !== 0 && Math.random() < 0.15) {
        abyssShowCrystal();
        return true;
    }
    if (f % 4 === 0 && f % 10 !== 0 && Math.random() < 0.2) {
        abyssShowDiviner();
        return true;
    }
    if (f % 16 === 0 && f % 10 !== 0 && Math.random() < 0.18) {
        abyssShowMaterialMerchant();
        return true;
    }
    if (f % 19 === 0 && f % 10 !== 0 && Math.random() < 0.17) {
        abyssShowEquipRecycle();
        return true;
    }
    if (f % 21 === 0 && f % 10 !== 0 && Math.random() < 0.16) {
        abyssShowMysteryVault();
        return true;
    }
    if (f % 22 === 0 && f % 10 !== 0 && Math.random() < 0.17) {
        abyssShowRuneWorkshop();
        return true;
    }
    if (f % 23 === 0 && f % 10 !== 0 && Math.random() < 0.17) {
        abyssShowGemSmith();
        return true;
    }
    return false;
}
var ABYSS_CURSE_POOL = [
    { curse: { atkPct: -15 }, reward: { atkPct: 25 }, curseName: '攻击-15%', rewardName: '攻击+25%', rounds: 5 },
    { curse: { defPct: -20 }, reward: { defPct: 30 }, curseName: '防御-20%', rewardName: '防御+30%', rounds: 5 },
    { curse: { hpPct: -12 }, reward: { hpPct: 20 }, curseName: '生命-12%', rewardName: '生命+20%', rounds: 5 },
    { curse: { lifestealPct: -3 }, reward: { lifestealPct: 5 }, curseName: '吸血-3%', rewardName: '吸血+5%', rounds: 5 },
    { curse: { critRatePct: -5 }, reward: { critDmgPct: 15 }, curseName: '暴击率-5%', rewardName: '爆伤+15%', rounds: 5 },
    { curse: { dodgePct: -4 }, reward: { goldPct: 20 }, curseName: '闪避-4%', rewardName: '金币+20%', rounds: 5 }
];
function abyssShowCurse() {
    var pool = ABYSS_CURSE_POOL.slice();
    var opts = [];
    for (var i = 0; i < 3 && pool.length > 0; i++) {
        var idx = Math.floor(Math.random() * pool.length);
        opts.push(pool.splice(idx, 1)[0]);
    }
    var el = document.getElementById('abyssCurseOptions');
    if (!el) return;
    el.innerHTML = '';
    opts.forEach(function(o) {
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#6a1b9a,#4a148c)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #ce93d8';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '13px';
        btn.innerHTML = '<span style="color:#ff9999">' + o.curseName + '</span> 换 <span style="color:#81c784">' + o.rewardName + '</span><br><small>(' + o.rounds + '层)</small>';
        btn.onclick = (function(opt) { return function() { abyssApplyCurse(opt); }; })(o);
        el.appendChild(btn);
    });
    document.getElementById('abyssCurseOverlay').style.display = 'block';
    document.getElementById('abyssCurseUI').style.display = 'block';
    abyssLog('深渊诅咒·抉择出现！');
}
function abyssApplyCurse(opt) {
    if (!abyssRun) return;
    abyssRun.buffs = abyssRun.buffs || {};
    abyssRun.curseRounds = (abyssRun.curseRounds || 0) + (opt.rounds || 5);
    abyssRun.curseEffects = abyssRun.curseEffects || {};
    abyssRun.rewardEffects = abyssRun.rewardEffects || {};
    for (var k in opt.curse) abyssRun.curseEffects[k] = (abyssRun.curseEffects[k] || 0) + opt.curse[k];
    for (var k in opt.reward) abyssRun.rewardEffects[k] = (abyssRun.rewardEffects[k] || 0) + opt.reward[k];
    document.getElementById('abyssCurseOverlay').style.display = 'none';
    document.getElementById('abyssCurseUI').style.display = 'none';
    abyssLog('深渊诅咒：' + opt.curseName + ' 换 ' + opt.rewardName + '(' + (opt.rounds || 5) + '层)');
    abyssResumeAfterSpecialEvent();
}
function abyssSkipCurse() {
    document.getElementById('abyssCurseOverlay').style.display = 'none';
    document.getElementById('abyssCurseUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}
var ABYSS_MERCHANT_PACKS = [
    { cost: 80, outcomes: [{ p: 0.5, gold: 200 }, { p: 0.3, gold: 350 }, { p: 0.15, gold: 80 }, { p: 0.05, equip: true }] },
    { cost: 150, outcomes: [{ p: 0.4, gold: 400 }, { p: 0.35, atk: 25 }, { p: 0.15, gold: 50 }, { p: 0.1, equip: true, quality: 2 }] },
    { cost: 250, outcomes: [{ p: 0.35, gold: 600 }, { p: 0.3, hp: 200 }, { p: 0.2, critDmg: 20 }, { p: 0.1, equip: true, quality: 3 }, { p: 0.05, petBook: true }] }
];
function abyssShowMerchant() {
    var gold = abyssRun.gold || 0;
    document.getElementById('abyssMerchantGold').textContent = gold;
    var el = document.getElementById('abyssMerchantOptions');
    if (!el) return;
    el.innerHTML = '';
    ABYSS_MERCHANT_PACKS.forEach(function(pack, idx) {
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#e65100,#bf360c)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #ffb74d';
        btn.style.padding = '14px 20px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.textContent = '神秘礼包 ' + (idx + 1) + ' (' + pack.cost + ' 金币)';
        btn.disabled = gold < pack.cost;
        btn.onclick = (function(p) { return function() { abyssBuyMerchantPack(p); }; })(pack);
        el.appendChild(btn);
    });
    document.getElementById('abyssMerchantOverlay').style.display = 'block';
    document.getElementById('abyssMerchantUI').style.display = 'block';
    abyssLog('神秘流浪商人出现！');
}
function abyssBuyMerchantPack(pack) {
    if (!abyssRun || (abyssRun.gold || 0) < pack.cost) return;
    abyssRun.gold -= pack.cost;
    var r = Math.random();
    var acc = 0;
    for (var i = 0; i < pack.outcomes.length; i++) {
        acc += pack.outcomes[i].p;
        if (r < acc) {
            var o = pack.outcomes[i];
            if (o.gold) { abyssRun.gold += o.gold; abyssLog('获得闯关金币 +' + o.gold); }
            else if (o.atk) { abyssRun.tempStats = abyssRun.tempStats || {}; abyssRun.tempStats.atk = (abyssRun.tempStats.atk || 0) + o.atk; abyssLog('获得攻击 +' + o.atk); }
            else if (o.hp) { abyssRun.player.maxHp = (abyssRun.player.maxHp || 0) + o.hp; abyssRun.player.hp = (abyssRun.player.hp || 0) + o.hp; abyssLog('获得生命 +' + o.hp); }
            else if (o.critDmg) { abyssRun.tempStats = abyssRun.tempStats || {}; abyssRun.tempStats.critDmg = (abyssRun.tempStats.critDmg || 0) + o.critDmg; abyssLog('获得爆伤 +' + o.critDmg + '%'); }
            else if (o.equip) { var eq = abyssGenEquipment(abyssRun.floor, false, o.quality || 4); if (eq) { abyssRun.inventory.push(eq); abyssLog('获得装备 ' + eq.name); } }
            else if (o.petBook) { abyssRun.materials.petSkillBook = (abyssRun.materials.petSkillBook || 0) + 1; abyssLog('获得宠物兽决 x1'); }
            break;
        }
    }
    abyssSkipMerchant();
}
function abyssSkipMerchant() {
    document.getElementById('abyssMerchantOverlay').style.display = 'none';
    document.getElementById('abyssMerchantUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}
var ABYSS_TRIAL_OPTIONS = [
    { id: 'noPotion', name: '禁药试炼', desc: '接下来10层不能使用药剂', reward: { goldPct: 50, expPct: 30 } },
    { id: 'normalAtk', name: '纯武试炼', desc: '接下来10层只能普攻（禁用技能）', reward: { atkPct: 45, defPct: 25 } },
    { id: 'noPet', name: '孤狼试炼', desc: '接下来10层宠物不出战', reward: { hpPct: 35, lifestealPct: 6 } },
    { id: 'lowHp', name: '险境试炼', desc: '接下来10层生命上限-25%', reward: { critDmgPct: 40, skillDmg: 25 } }
];
var ABYSS_TRIAL_REWARD_NAMES = { goldPct: '金币', expPct: '经验', atkPct: '攻击', defPct: '防御', hpPct: '生命', lifestealPct: '吸血', critDmgPct: '爆伤', skillDmg: '技能伤害' };
function abyssFmtTrialReward(reward) {
    var parts = [];
    for (var k in reward) {
        var name = ABYSS_TRIAL_REWARD_NAMES[k] || k;
        var v = reward[k];
        parts.push(name + '+' + v + (k.indexOf('Pct') >= 0 || k === 'skillDmg' ? '%' : ''));
    }
    return parts.join('、');
}
function abyssShowTrial() {
    var opts = ABYSS_TRIAL_OPTIONS.slice();
    var chosen = [];
    for (var i = 0; i < 2 && opts.length > 0; i++) {
        chosen.push(opts.splice(Math.floor(Math.random() * opts.length), 1)[0]);
    }
    var el = document.getElementById('abyssTrialOptions');
    if (!el) return;
    el.innerHTML = '';
    chosen.forEach(function(o) {
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#1565c0,#0d47a1)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #64b5f6';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.style.textAlign = 'left';
        btn.innerHTML = '<strong>' + o.name + '</strong><br><small style="color:#aaa">' + o.desc + '</small><br><small style="color:#81c784">奖励: ' + abyssFmtTrialReward(o.reward) + '</small>';
        btn.onclick = (function(opt) { return function() { abyssApplyTrial(opt); }; })(o);
        el.appendChild(btn);
    });
    document.getElementById('abyssTrialOverlay').style.display = 'block';
    document.getElementById('abyssTrialUI').style.display = 'block';
    abyssLog('深渊试炼出现！');
}
function abyssApplyTrial(opt) {
    if (!abyssRun) return;
    abyssRun.trialId = opt.id;
    abyssRun.trialRoundsLeft = 10;
    abyssRun.trialReward = opt.reward;
    abyssRun.buffs = abyssRun.buffs || {};
    for (var k in opt.reward) abyssRun.buffs[k] = (abyssRun.buffs[k] || 0) + opt.reward[k];
    document.getElementById('abyssTrialOverlay').style.display = 'none';
    document.getElementById('abyssTrialUI').style.display = 'none';
    abyssLog('接受试炼：' + opt.name + '，接下来10层获得加成');
    abyssResumeAfterSpecialEvent();
}
function abyssSkipTrial() {
    document.getElementById('abyssTrialOverlay').style.display = 'none';
    document.getElementById('abyssTrialUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}
function abyssShowRuin() {
    var el = document.getElementById('abyssRuinOptions');
    if (!el) return;
    el.innerHTML = '';
    var opts = [
        { id: 'safe', name: '稳健探索', desc: '获得稳定奖励', style: 'linear-gradient(145deg,#2e7d32,#1b5e20)' },
        { id: 'risk', name: '冒险深入', desc: '50%丰厚/50%普通', style: 'linear-gradient(145deg,#e65100,#bf360c)' }
    ];
    opts.forEach(function(o) {
        var btn = document.createElement('button');
        btn.style.background = o.style;
        btn.style.color = '#fff';
        btn.style.border = '2px solid #d2691e';
        btn.style.padding = '14px 24px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.innerHTML = '<strong>' + o.name + '</strong><br><small>' + o.desc + '</small>';
        btn.onclick = (function(id) { return function() { abyssApplyRuin(id); }; })(o.id);
        el.appendChild(btn);
    });
    document.getElementById('abyssRuinOverlay').style.display = 'block';
    document.getElementById('abyssRuinUI').style.display = 'block';
    abyssLog('远古遗迹出现！');
}
function abyssApplyRuin(id) {
    if (!abyssRun) return;
    var f = abyssRun.floor;
    if (id === 'safe') {
        abyssRun.gold = (abyssRun.gold || 0) + Math.floor(80 + f * 6);
        abyssRun.materials.upgradeStone = (abyssRun.materials.upgradeStone || 0) + 1;
        var eq = abyssGenEquipment(f, false, 2);
        if (eq) abyssRun.inventory.push(eq);
        abyssLog('稳健探索：获得金币、升级石、装备');
    } else {
        if (Math.random() < 0.5) {
            abyssRun.gold = (abyssRun.gold || 0) + Math.floor(150 + f * 12);
            abyssRun.materials.enhanceStone = (abyssRun.materials.enhanceStone || 0) + 2;
            var eq2 = abyssGenEquipment(f, false, 4);
            if (eq2) abyssRun.inventory.push(eq2);
            abyssLog('冒险深入：获得丰厚奖励！');
        } else {
            abyssRun.gold = (abyssRun.gold || 0) + Math.floor(40 + f * 3);
            abyssLog('冒险深入：收获一般');
        }
    }
    document.getElementById('abyssRuinOverlay').style.display = 'none';
    document.getElementById('abyssRuinUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}
var ABYSS_WHEEL_POOL = [
    { type: 'gold', value: 120, name: '闯关金币+120' },
    { type: 'gold', value: 200, name: '闯关金币+200' },
    { type: 'atk', value: 15, name: '攻击+15' },
    { type: 'hp', value: 80, name: '生命+80' },
    { type: 'equip', name: '随机装备' },
    { type: 'potion', name: '生命药剂x2' },
    { type: 'petBook', name: '宠物兽决' },
    { type: 'exp', value: 40, name: '经验+40' }
];
function abyssShowWheel() {
    document.getElementById('abyssWheelResult').textContent = '';
    document.getElementById('abyssWheelSpinBtn').style.display = 'block';
    document.getElementById('abyssWheelOverlay').style.display = 'block';
    document.getElementById('abyssWheelUI').style.display = 'block';
    abyssLog('幸运轮盘出现！');
}
function abyssSpinWheel() {
    if (!abyssRun) return;
    document.getElementById('abyssWheelSpinBtn').style.display = 'none';
    var o = ABYSS_WHEEL_POOL[Math.floor(Math.random() * ABYSS_WHEEL_POOL.length)];
    var resultEl = document.getElementById('abyssWheelResult');
    if (o.type === 'gold') { abyssRun.gold = (abyssRun.gold || 0) + o.value; resultEl.textContent = o.name; }
    else if (o.type === 'atk') { abyssRun.tempStats = abyssRun.tempStats || {}; abyssRun.tempStats.atk = (abyssRun.tempStats.atk || 0) + o.value; resultEl.textContent = o.name; }
    else if (o.type === 'hp') { abyssRun.player.maxHp = (abyssRun.player.maxHp || 0) + o.value; abyssRun.player.hp = (abyssRun.player.hp || 0) + o.value; resultEl.textContent = o.name; }
    else if (o.type === 'equip') { var eq = abyssGenEquipment(abyssRun.floor, false); if (eq) { abyssRun.inventory.push(eq); resultEl.textContent = '获得 ' + eq.name; } }
    else if (o.type === 'potion') { abyssRun.materials.potion = (abyssRun.materials.potion || 0) + 2; resultEl.textContent = o.name; }
    else if (o.type === 'petBook') { abyssRun.materials.petSkillBook = (abyssRun.materials.petSkillBook || 0) + 1; resultEl.textContent = o.name; }
    else if (o.type === 'exp') { var ap = abyssApplyExpGoldBonus(o.value, 0); abyssRun.exp = (abyssRun.exp || 0) + ap.exp; resultEl.textContent = o.name; }
    setTimeout(function() {
        document.getElementById('abyssWheelOverlay').style.display = 'none';
        document.getElementById('abyssWheelUI').style.display = 'none';
        abyssResumeAfterSpecialEvent();
    }, 800);
}
function abyssResumeAfterSpecialEvent() {
    abyssRun.pendingChoice = false;
    if (abyssCheckLevelUp()) { abyssRun.needSpawnAfterUpgrade = true; return; }
    abyssRun.needSpawnAfterUpgrade = false;
    abyssSpawnMonster();
    updateAbyssRunUI();
}

// ========== 装备类5大增益玩法 ==========
function abyssShowForge() {
    var gold = abyssRun.gold || 0;
    document.getElementById('abyssForgeGold').textContent = gold;
    var el = document.getElementById('abyssForgeOptions');
    if (!el) return;
    el.innerHTML = '';
    var inv = abyssRun.inventory || [];
    var upgradable = inv.filter(function(eq) { return eq && eq.quality < 4; });
    var costUpgrade = Math.floor(100 + abyssRun.floor * 8);
    if (upgradable.length > 0 && gold >= costUpgrade) {
        var btn1 = document.createElement('button');
        btn1.style.background = 'linear-gradient(145deg,#d2691e,#8b4513)';
        btn1.style.color = '#fff';
        btn1.style.border = '2px solid #ffb74d';
        btn1.style.padding = '12px';
        btn1.style.borderRadius = '8px';
        btn1.style.cursor = 'pointer';
        btn1.textContent = '升级一件背包装备品质+1 (' + costUpgrade + ' 金币)';
        btn1.onclick = abyssApplyForgeUpgrade;
        el.appendChild(btn1);
    }
    var btn2 = document.createElement('button');
    btn2.style.background = 'linear-gradient(145deg,#607d8b,#455a64)';
    btn2.style.color = '#fff';
    btn2.style.border = '2px solid #90a4ae';
    btn2.style.padding = '12px';
    btn2.style.borderRadius = '8px';
    btn2.style.cursor = 'pointer';
    btn2.textContent = '领取升级石 x2 (免费)';
    btn2.onclick = abyssApplyForgeStone;
    el.appendChild(btn2);
    document.getElementById('abyssForgeOverlay').style.display = 'block';
    document.getElementById('abyssForgeUI').style.display = 'block';
    abyssLog('深渊锻造坊出现！');
}
function abyssApplyForgeUpgrade() {
    if (!abyssRun) return;
    var cost = Math.floor(100 + abyssRun.floor * 8);
    if ((abyssRun.gold || 0) < cost) return;
    var inv = abyssRun.inventory || [];
    var upgradable = inv.filter(function(eq) { return eq && eq.quality < 4; });
    if (upgradable.length === 0) return;
    var idx = Math.floor(Math.random() * upgradable.length);
    var eq = upgradable[idx];
    var invIdx = inv.indexOf(eq);
    eq.quality = Math.min(4, (eq.quality || 0) + 1);
    var baseName = (eq.name || '').replace(/^[灰绿蓝紫橙]·/, '');
    if (!baseName) baseName = '未知装备';
    eq.name = (ABYSS_QUALITIES[eq.quality] || '') + '·' + baseName;
    abyssRun.gold -= cost;
    document.getElementById('abyssForgeOverlay').style.display = 'none';
    document.getElementById('abyssForgeUI').style.display = 'none';
    abyssLog('锻造坊：' + eq.name + ' 品质提升！');
    abyssResumeAfterSpecialEvent();
}
function abyssApplyForgeStone() {
    if (!abyssRun) return;
    abyssRun.materials = abyssRun.materials || {};
    abyssRun.materials.upgradeStone = (abyssRun.materials.upgradeStone || 0) + 2;
    document.getElementById('abyssForgeOverlay').style.display = 'none';
    document.getElementById('abyssForgeUI').style.display = 'none';
    abyssLog('锻造坊：获得升级石 x2');
    abyssResumeAfterSpecialEvent();
}
function abyssSkipForge() {
    document.getElementById('abyssForgeOverlay').style.display = 'none';
    document.getElementById('abyssForgeUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

function abyssShowEnchantTable() {
    var equipped = abyssRun.equipped || {};
    var slots = [];
    for (var k in equipped) { if (equipped[k]) slots.push({ slot: k, eq: equipped[k] }); }
    var el = document.getElementById('abyssEnchantTableOptions');
    if (!el) return;
    el.innerHTML = '';
    if (slots.length === 0) {
        el.innerHTML = '<p style="color:#888;">无已装备装备，获得附魔书 x2</p>';
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#7c4dff,#512da8)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #b388ff';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.textContent = '领取附魔书 x2';
        btn.onclick = function() {
            abyssRun.materials = abyssRun.materials || {};
            abyssRun.materials.enchantBook = (abyssRun.materials.enchantBook || 0) + 2;
            document.getElementById('abyssEnchantTableOverlay').style.display = 'none';
            document.getElementById('abyssEnchantTableUI').style.display = 'none';
            abyssLog('附魔台：无装备可附魔，获得附魔书 x2');
            abyssResumeAfterSpecialEvent();
        };
        el.appendChild(btn);
        document.getElementById('abyssEnchantTableOverlay').style.display = 'block';
        document.getElementById('abyssEnchantTableUI').style.display = 'block';
        abyssLog('深渊附魔台出现！');
        return;
    } else {
        slots.forEach(function(s) {
            var btn = document.createElement('button');
            btn.style.background = 'linear-gradient(145deg,#7c4dff,#512da8)';
            btn.style.color = '#fff';
            btn.style.border = '2px solid #b388ff';
            btn.style.padding = '12px';
            btn.style.borderRadius = '8px';
            btn.style.cursor = 'pointer';
            btn.style.textAlign = 'left';
            btn.textContent = (ABYSS_SLOT_NAMES[s.slot] || s.slot) + ': ' + (s.eq.name || '未知');
            btn.onclick = (function(slotKey, eq) {
                return function() {
                    var mult = 1.15 + Math.random() * 0.11;
                    if (!eq.enchant || eq.enchant === true) eq.enchant = {};
                    if (typeof eq.enchant !== 'object') eq.enchant = { statMult: mult };
                    else eq.enchant.statMult = (eq.enchant.statMult || 1) * mult;
                    document.getElementById('abyssEnchantTableOverlay').style.display = 'none';
                    document.getElementById('abyssEnchantTableUI').style.display = 'none';
                    abyssLog('附魔台：' + (eq.name || '') + ' 已附魔，属性增幅约' + Math.floor((mult - 1) * 100) + '%');
                    abyssResumeAfterSpecialEvent();
                };
            })(s.slot, s.eq);
            el.appendChild(btn);
        });
    }
    document.getElementById('abyssEnchantTableOverlay').style.display = 'block';
    document.getElementById('abyssEnchantTableUI').style.display = 'block';
    abyssLog('深渊附魔台出现！');
}
function abyssSkipEnchantTable() {
    document.getElementById('abyssEnchantTableOverlay').style.display = 'none';
    document.getElementById('abyssEnchantTableUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

function abyssShowAppraiser() {
    var inv = abyssRun.inventory || [];
    var el = document.getElementById('abyssAppraiserOptions');
    if (!el) return;
    el.innerHTML = '';
    if (inv.length === 0) {
        el.innerHTML = '<p style="color:#888;">背包为空，获得符文槽开启器 x1</p>';
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#26c6da,#0097a7)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #4dd0e1';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.textContent = '领取符文槽开启器 x1';
        btn.onclick = function() {
            abyssRun.materials = abyssRun.materials || {};
            abyssRun.materials.runeSlotOpener = (abyssRun.materials.runeSlotOpener || 0) + 1;
            document.getElementById('abyssAppraiserOverlay').style.display = 'none';
            document.getElementById('abyssAppraiserUI').style.display = 'none';
            abyssLog('鉴宝师：背包空，获得符文槽开启器 x1');
            abyssResumeAfterSpecialEvent();
        };
        el.appendChild(btn);
        document.getElementById('abyssAppraiserOverlay').style.display = 'block';
        document.getElementById('abyssAppraiserUI').style.display = 'block';
        abyssLog('深渊鉴宝师出现！');
        return;
    }
    {
        var upgradable = inv.filter(function(eq) {
            var r = (eq.runes || []).length < ABYSS_MAX_RUNE_SLOTS;
            var g = (eq.gems || []).length < ABYSS_MAX_GEM_SLOTS;
            return r || g;
        });
        var pick;
        var addRune = false, addGem = false;
        if (upgradable.length > 0) {
            pick = upgradable[Math.floor(Math.random() * upgradable.length)];
            addRune = (pick.runes || []).length < ABYSS_MAX_RUNE_SLOTS;
            addGem = (pick.gems || []).length < ABYSS_MAX_GEM_SLOTS;
            if (addRune && addGem) {
                if (Math.random() < 0.5) {
                    pick.runes = pick.runes || [];
                    pick.runes.push(null);
                } else {
                    pick.gems = pick.gems || [];
                    pick.gems.push(null);
                }
            } else if (addRune) {
                pick.runes = pick.runes || [];
                pick.runes.push(null);
            } else {
                pick.gems = pick.gems || [];
                pick.gems.push(null);
            }
        } else {
            pick = null;
        }
        document.getElementById('abyssAppraiserOverlay').style.display = 'block';
        document.getElementById('abyssAppraiserUI').style.display = 'block';
        var info = pick ? ('已为 ' + (pick.name || '') + ' 添加孔位') : ('背包装备均已满孔，获得宝石槽开启器 x1');
        el.innerHTML = '<p style="color:#81c784;">' + info + '</p>';
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#26c6da,#0097a7)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #4dd0e1';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.textContent = '确定';
        btn.onclick = function() {
            if (!pick) {
                abyssRun.materials = abyssRun.materials || {};
                abyssRun.materials.gemSlotOpener = (abyssRun.materials.gemSlotOpener || 0) + 1;
                abyssLog('鉴宝师：满孔，获得宝石槽开启器 x1');
            } else abyssLog('鉴宝师：' + (pick.name || '') + ' 鉴定完成');
            document.getElementById('abyssAppraiserOverlay').style.display = 'none';
            document.getElementById('abyssAppraiserUI').style.display = 'none';
            abyssResumeAfterSpecialEvent();
        };
        el.appendChild(btn);
        abyssLog('深渊鉴宝师出现！');
        return;
    }
    document.getElementById('abyssAppraiserOverlay').style.display = 'block';
    document.getElementById('abyssAppraiserUI').style.display = 'block';
    abyssLog('深渊鉴宝师出现！');
}
function abyssSkipAppraiser() {
    document.getElementById('abyssAppraiserOverlay').style.display = 'none';
    document.getElementById('abyssAppraiserUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

var ABYSS_EQUIP_CHEST_PACKS = [
    { cost: 60, minQ: 0, maxQ: 2, name: '普通箱' },
    { cost: 180, minQ: 1, maxQ: 3, name: '精良箱' },
    { cost: 350, minQ: 2, maxQ: 4, name: '史诗箱' }
];
function abyssShowEquipChest() {
    var gold = abyssRun.gold || 0;
    document.getElementById('abyssEquipChestGold').textContent = gold;
    var el = document.getElementById('abyssEquipChestOptions');
    if (!el) return;
    el.innerHTML = '';
    ABYSS_EQUIP_CHEST_PACKS.forEach(function(pack) {
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#4caf50,#2e7d32)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #81c784';
        btn.style.padding = '14px 20px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.textContent = pack.name + ' (' + pack.cost + ' 金币)';
        btn.disabled = gold < pack.cost;
        btn.onclick = (function(p) {
            return function() {
                if (!abyssRun || (abyssRun.gold || 0) < p.cost) return;
                abyssRun.gold -= p.cost;
                var q = p.minQ + Math.floor(Math.random() * (p.maxQ - p.minQ + 1));
                var eq = abyssGenEquipment(abyssRun.floor, false, 4, q);
                if (eq) { abyssRun.inventory.push(eq); abyssLog('装备箱：获得 ' + eq.name); }
                document.getElementById('abyssEquipChestOverlay').style.display = 'none';
                document.getElementById('abyssEquipChestUI').style.display = 'none';
                abyssResumeAfterSpecialEvent();
            };
        })(pack);
        el.appendChild(btn);
    });
    document.getElementById('abyssEquipChestOverlay').style.display = 'block';
    document.getElementById('abyssEquipChestUI').style.display = 'block';
    abyssLog('深渊装备箱出现！');
}
function abyssSkipEquipChest() {
    document.getElementById('abyssEquipChestOverlay').style.display = 'none';
    document.getElementById('abyssEquipChestUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

function abyssShowEnhanceAltar() {
    var equipped = abyssRun.equipped || {};
    var slots = [];
    for (var k in equipped) { if (equipped[k]) slots.push({ slot: k, eq: equipped[k] }); }
    var runLevel = abyssRun.runLevel || 1;
    var el = document.getElementById('abyssEnhanceAltarOptions');
    if (!el) return;
    el.innerHTML = '';
    if (slots.length === 0) {
        el.innerHTML = '<p style="color:#888;">无已装备装备，获得强化石 x3</p>';
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#e91e63,#ad1457)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #f48fb1';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.textContent = '领取强化石 x3';
        btn.onclick = function() {
            abyssRun.materials = abyssRun.materials || {};
            abyssRun.materials.enhanceStone = (abyssRun.materials.enhanceStone || 0) + 3;
            document.getElementById('abyssEnhanceAltarOverlay').style.display = 'none';
            document.getElementById('abyssEnhanceAltarUI').style.display = 'none';
            abyssLog('强化祭坛：无装备可强化，获得强化石 x3');
            abyssResumeAfterSpecialEvent();
        };
        el.appendChild(btn);
    } else {
        slots.forEach(function(s) {
            var equipLv = s.eq.equipLevel != null ? s.eq.equipLevel : (s.eq.level || 0);
            var enhanceLv = s.eq.equipLevel != null ? (s.eq.level || 0) : 0;
            var canEnhance = enhanceLv < runLevel;
            var btn = document.createElement('button');
            btn.style.background = canEnhance ? 'linear-gradient(145deg,#e91e63,#ad1457)' : '#555';
            btn.style.color = '#fff';
            btn.style.border = '2px solid #f48fb1';
            btn.style.padding = '12px';
            btn.style.borderRadius = '8px';
            btn.style.cursor = canEnhance ? 'pointer' : 'not-allowed';
            btn.style.textAlign = 'left';
            btn.textContent = (ABYSS_SLOT_NAMES[s.slot] || s.slot) + ': ' + (s.eq.name || '') + ' (+' + enhanceLv + ')' + (canEnhance ? '' : ' 已满级');
            if (canEnhance) {
                btn.onclick = (function(eq) {
                    return function() {
                        eq.level = (eq.level || 0) + 1;
                        document.getElementById('abyssEnhanceAltarOverlay').style.display = 'none';
                        document.getElementById('abyssEnhanceAltarUI').style.display = 'none';
                        abyssLog('强化祭坛：' + (eq.name || '') + ' 强化+1');
                        abyssResumeAfterSpecialEvent();
                    };
                })(s.eq);
            }
            el.appendChild(btn);
        });
        var btnStone = document.createElement('button');
        btnStone.style.background = 'linear-gradient(145deg,#607d8b,#455a64)';
        btnStone.style.color = '#fff';
        btnStone.style.border = '2px solid #90a4ae';
        btnStone.style.padding = '12px';
        btnStone.style.borderRadius = '8px';
        btnStone.style.cursor = 'pointer';
        btnStone.textContent = '领取强化石 x3 (不强化装备)';
        btnStone.onclick = function() {
            abyssRun.materials = abyssRun.materials || {};
            abyssRun.materials.enhanceStone = (abyssRun.materials.enhanceStone || 0) + 3;
            document.getElementById('abyssEnhanceAltarOverlay').style.display = 'none';
            document.getElementById('abyssEnhanceAltarUI').style.display = 'none';
            abyssLog('强化祭坛：获得强化石 x3');
            abyssResumeAfterSpecialEvent();
        };
        el.appendChild(btnStone);
    }
    document.getElementById('abyssEnhanceAltarOverlay').style.display = 'block';
    document.getElementById('abyssEnhanceAltarUI').style.display = 'block';
    abyssLog('深渊强化祭坛出现！');
}
function abyssSkipEnhanceAltar() {
    document.getElementById('abyssEnhanceAltarOverlay').style.display = 'none';
    document.getElementById('abyssEnhanceAltarUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

// ========== 深渊材料商人（每16层，金币购买材料） ==========
var ABYSS_MATERIAL_MERCHANT_ITEMS = [
    { id: 'upgradeStone', name: '升级石', cost: 120, mat: 'upgradeStone', amount: 2 },
    { id: 'enhanceStone', name: '强化石', cost: 90, mat: 'enhanceStone', amount: 3 },
    { id: 'enchantBook', name: '附魔书', cost: 110, mat: 'enchantBook', amount: 1 },
    { id: 'potion', name: '生命药剂', cost: 70, mat: 'potion', amount: 2 },
    { id: 'rune', name: '随机符文', cost: 180, mat: 'rune', amount: 1 },
    { id: 'gem', name: '随机宝石', cost: 150, mat: 'gem', amount: 1 },
    { id: 'runeSlotOpener', name: '符文开孔器', cost: 280, mat: 'runeSlotOpener', amount: 1 },
    { id: 'gemSlotOpener', name: '宝石开孔器', cost: 260, mat: 'gemSlotOpener', amount: 1 }
];
function abyssShowMaterialMerchant() {
    abyssRun.materialMerchantPurchases = 0;
    var gold = abyssRun.gold || 0;
    document.getElementById('abyssMaterialMerchantGold').textContent = gold;
    document.getElementById('abyssMaterialMerchantPurchases').textContent = 3 - abyssRun.materialMerchantPurchases;
    var el = document.getElementById('abyssMaterialMerchantOptions');
    if (!el) return;
    el.innerHTML = '';
    function updateMaterialMerchantUI() {
        var remaining = 3 - (abyssRun.materialMerchantPurchases || 0);
        document.getElementById('abyssMaterialMerchantGold').textContent = abyssRun.gold;
        document.getElementById('abyssMaterialMerchantPurchases').textContent = remaining;
        for (var bi = 0; bi < el.children.length && bi < ABYSS_MATERIAL_MERCHANT_ITEMS.length; bi++) {
            var item = ABYSS_MATERIAL_MERCHANT_ITEMS[bi];
            el.children[bi].disabled = remaining <= 0 || (abyssRun.gold || 0) < item.cost;
        }
    }
    ABYSS_MATERIAL_MERCHANT_ITEMS.forEach(function(it) {
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#558b2f,#33691e)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #8bc34a';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.style.textAlign = 'left';
        btn.innerHTML = '<span>' + it.name + ' x' + it.amount + '</span><br><small style="color:#b0b0b0;">' + it.cost + ' 金币</small>';
        btn.disabled = (abyssRun.gold || 0) < it.cost;
        btn.onclick = (function(item) {
            return function() {
                if (!abyssRun) return;
                if ((abyssRun.materialMerchantPurchases || 0) >= 3) return;
                if ((abyssRun.gold || 0) < item.cost) return;
                abyssRun.materialMerchantPurchases = (abyssRun.materialMerchantPurchases || 0) + 1;
                abyssRun.gold -= item.cost;
                abyssRun.materials = abyssRun.materials || {};
                if (item.mat === 'rune') {
                    abyssRun.runeInventory = abyssRun.runeInventory || [];
                    for (var i = 0; i < item.amount; i++) abyssRun.runeInventory.push(ABYSS_RUNES[Math.floor(Math.random() * ABYSS_RUNES.length)].id);
                    abyssLog('材料商人：获得随机符文 x' + item.amount);
                } else if (item.mat === 'gem') {
                    abyssRun.gemInventory = abyssRun.gemInventory || [];
                    for (var i = 0; i < item.amount; i++) abyssRun.gemInventory.push(ABYSS_GEMS[Math.floor(Math.random() * ABYSS_GEMS.length)].id);
                    abyssLog('材料商人：获得随机宝石 x' + item.amount);
                } else {
                    abyssRun.materials[item.mat] = (abyssRun.materials[item.mat] || 0) + item.amount;
                    abyssLog('材料商人：获得 ' + item.name + ' x' + item.amount);
                }
                updateMaterialMerchantUI();
            };
        })(it);
        el.appendChild(btn);
    });
    document.getElementById('abyssMaterialMerchantOverlay').style.display = 'block';
    document.getElementById('abyssMaterialMerchantUI').style.display = 'block';
    abyssLog('深渊材料商人出现！本次可购买3次');
}
function abyssSkipMaterialMerchant() {
    document.getElementById('abyssMaterialMerchantOverlay').style.display = 'none';
    document.getElementById('abyssMaterialMerchantUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

// ========== 深渊装备回收站（每19层，分解装备换材料/金币） ==========
function abyssShowEquipRecycle() {
    var inv = abyssRun.inventory || [];
    var el = document.getElementById('abyssEquipRecycleOptions');
    if (!el) return;
    el.innerHTML = '';
    if (inv.length === 0) {
        el.innerHTML = '<p style="color:#888;">背包为空，获得闯关金币 +80</p>';
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#6d4c41,#4e342e)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #a1887f';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.textContent = '领取 80 金币';
        btn.onclick = function() {
            abyssRun.gold = (abyssRun.gold || 0) + 80;
            document.getElementById('abyssEquipRecycleOverlay').style.display = 'none';
            document.getElementById('abyssEquipRecycleUI').style.display = 'none';
            abyssLog('回收站：背包空，获得金币 +80');
            abyssResumeAfterSpecialEvent();
        };
        el.appendChild(btn);
    } else {
        inv.forEach(function(eq, idx) {
            var quality = eq.quality || 0;
            var goldVal = 10 + quality * 10 + (eq.level || 0) * 5;
            var matVal = quality >= 2 ? (quality >= 3 ? '升级石+强化石' : '强化石') : '金币';
            var btn = document.createElement('button');
            btn.style.background = (ABYSS_QUALITY_COLOR[quality] || '#333');
            btn.style.color = '#fff';
            btn.style.border = '2px solid #a1887f';
            btn.style.padding = '10px';
            btn.style.borderRadius = '8px';
            btn.style.cursor = 'pointer';
            btn.style.textAlign = 'left';
            btn.textContent = (eq.name || '装备') + ' → 金币+' + goldVal + (quality >= 2 ? ' 或 ' + matVal : '');
            btn.onclick = (function(item, index) {
                return function() {
                    var inv2 = abyssRun.inventory || [];
                    var idx2 = inv2.indexOf(item);
                    if (idx2 < 0) return;
                    inv2.splice(idx2, 1);
                    if (!abyssRun.materials) abyssRun.materials = {};
                    var q = item.quality || 0;
                    if (q >= 3 && Math.random() < 0.6) {
                        abyssRun.materials.upgradeStone = (abyssRun.materials.upgradeStone || 0) + 1;
                        abyssRun.materials.enhanceStone = (abyssRun.materials.enhanceStone || 0) + 1;
                        abyssLog('回收站：分解 ' + (item.name || '') + ' 获得升级石+强化石');
                    } else if (q >= 2 && Math.random() < 0.5) {
                        abyssRun.materials.enhanceStone = (abyssRun.materials.enhanceStone || 0) + 2;
                        abyssLog('回收站：分解 ' + (item.name || '') + ' 获得强化石 x2');
                    } else {
                        var g = 10 + q * 10 + (item.level || 0) * 5;
                        abyssRun.gold = (abyssRun.gold || 0) + g;
                        abyssLog('回收站：分解 ' + (item.name || '') + ' 获得金币 +' + g);
                    }
                    document.getElementById('abyssEquipRecycleOverlay').style.display = 'none';
                    document.getElementById('abyssEquipRecycleUI').style.display = 'none';
                    abyssResumeAfterSpecialEvent();
                };
            })(eq, idx);
            el.appendChild(btn);
        });
    }
    document.getElementById('abyssEquipRecycleOverlay').style.display = 'block';
    document.getElementById('abyssEquipRecycleUI').style.display = 'block';
    abyssLog('深渊装备回收站出现！');
}
function abyssSkipEquipRecycle() {
    document.getElementById('abyssEquipRecycleOverlay').style.display = 'none';
    document.getElementById('abyssEquipRecycleUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

// ========== 深渊神秘宝库（每21层，开宝箱获装备/材料） ==========
var ABYSS_MYSTERY_VAULT_PACKS = [
    { cost: 100, outcomes: [{ p: 0.4, type: 'gold', val: 150 }, { p: 0.3, type: 'mat', mat: 'upgradeStone', val: 1 }, { p: 0.2, type: 'equip', q: 1 }, { p: 0.1, type: 'rune' }] },
    { cost: 220, outcomes: [{ p: 0.35, type: 'gold', val: 250 }, { p: 0.25, type: 'mat', mat: 'enhanceStone', val: 2 }, { p: 0.25, type: 'equip', q: 2 }, { p: 0.1, type: 'rune' }, { p: 0.05, type: 'gem' }] },
    { cost: 380, outcomes: [{ p: 0.25, type: 'equip', q: 3 }, { p: 0.25, type: 'mat', mat: 'upgradeStone', val: 2 }, { p: 0.2, type: 'rune' }, { p: 0.15, type: 'gem' }, { p: 0.15, type: 'gold', val: 400 }] }
];
function abyssShowMysteryVault() {
    var gold = abyssRun.gold || 0;
    document.getElementById('abyssMysteryVaultGold').textContent = gold;
    var el = document.getElementById('abyssMysteryVaultOptions');
    if (!el) return;
    el.innerHTML = '';
    ABYSS_MYSTERY_VAULT_PACKS.forEach(function(pack, idx) {
        var btn = document.createElement('button');
        btn.style.background = idx === 2 ? 'linear-gradient(145deg,#4a148c,#1a0033)' : idx === 1 ? 'linear-gradient(145deg,#6a1b9a,#4a148c)' : 'linear-gradient(145deg,#7b1fa2,#4a148c)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #b388ff';
        btn.style.padding = '14px 20px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.textContent = '神秘宝箱 ' + (idx + 1) + ' (' + pack.cost + ' 金币)';
        btn.disabled = gold < pack.cost;
        btn.onclick = (function(p) {
            return function() {
                if (!abyssRun || (abyssRun.gold || 0) < p.cost) return;
                abyssRun.gold -= p.cost;
                var r = Math.random(), acc = 0;
                for (var i = 0; i < p.outcomes.length; i++) {
                    acc += p.outcomes[i].p;
                    if (r < acc) {
                        var o = p.outcomes[i];
                        if (o.type === 'gold') { abyssRun.gold += o.val; abyssLog('神秘宝库：获得金币 +' + o.val); }
                        else if (o.type === 'mat') { abyssRun.materials = abyssRun.materials || {}; abyssRun.materials[o.mat] = (abyssRun.materials[o.mat] || 0) + (o.val || 1); abyssLog('神秘宝库：获得材料'); }
                        else if (o.type === 'equip') { var eq = abyssGenEquipment(abyssRun.floor, false, 4, o.q); if (eq) { abyssRun.inventory.push(eq); abyssLog('神秘宝库：获得 ' + eq.name); } }
                        else if (o.type === 'rune') { abyssRun.runeInventory = abyssRun.runeInventory || []; abyssRun.runeInventory.push(ABYSS_RUNES[Math.floor(Math.random() * ABYSS_RUNES.length)].id); abyssLog('神秘宝库：获得随机符文'); }
                        else if (o.type === 'gem') { abyssRun.gemInventory = abyssRun.gemInventory || []; abyssRun.gemInventory.push(ABYSS_GEMS[Math.floor(Math.random() * ABYSS_GEMS.length)].id); abyssLog('神秘宝库：获得随机宝石'); }
                        break;
                    }
                }
                document.getElementById('abyssMysteryVaultOverlay').style.display = 'none';
                document.getElementById('abyssMysteryVaultUI').style.display = 'none';
                abyssResumeAfterSpecialEvent();
            };
        })(pack);
        el.appendChild(btn);
    });
    document.getElementById('abyssMysteryVaultOverlay').style.display = 'block';
    document.getElementById('abyssMysteryVaultUI').style.display = 'block';
    abyssLog('深渊神秘宝库出现！');
}
function abyssSkipMysteryVault() {
    document.getElementById('abyssMysteryVaultOverlay').style.display = 'none';
    document.getElementById('abyssMysteryVaultUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

// ========== 深渊符文工坊（每22层，免费镶符文或获得符文） ==========
function abyssShowRuneWorkshop() {
    var equipped = abyssRun.equipped || {};
    var runeInv = (abyssRun.runeInventory || []).slice();
    var slotsWithSlots = [];
    for (var k in equipped) {
        var eq = equipped[k];
        if (eq && (eq.runes || []).length < ABYSS_MAX_RUNE_SLOTS) slotsWithSlots.push({ slot: k, eq: eq });
    }
    var el = document.getElementById('abyssRuneWorkshopOptions');
    if (!el) return;
    el.innerHTML = '';
    var embedCount = Math.min(slotsWithSlots.length, runeInv.length);
    if (embedCount > 0) {
        for (var i = 0; i < embedCount; i++) {
            (function() {
                var s = slotsWithSlots[i];
                var runeId = runeInv[i];
                var runeInfo = getAbyssRuneById(runeId);
                var btn = document.createElement('button');
                btn.style.background = 'linear-gradient(145deg,#6a1b9a,#4a148c)';
                btn.style.color = '#fff';
                btn.style.border = '2px solid #ce93d8';
                btn.style.padding = '12px';
                btn.style.borderRadius = '8px';
                btn.style.cursor = 'pointer';
                btn.style.textAlign = 'left';
                btn.textContent = (ABYSS_SLOT_NAMES[s.slot] || s.slot) + ': ' + (s.eq.name || '') + ' → 镶嵌 ' + (runeInfo ? runeInfo.name : runeId);
                btn.onclick = (function(equip, rid) {
                    return function() {
                        equip.runes = equip.runes || [];
                        if (equip.runes.length < ABYSS_MAX_RUNE_SLOTS) {
                            var idx = (abyssRun.runeInventory || []).indexOf(rid);
                            if (idx >= 0) {
                                abyssRun.runeInventory.splice(idx, 1);
                                equip.runes.push(rid);
                                abyssLog('符文工坊：' + (equip.name || '') + ' 镶嵌 ' + (getAbyssRuneById(rid) ? getAbyssRuneById(rid).name : ''));
                            }
                        }
                        document.getElementById('abyssRuneWorkshopOverlay').style.display = 'none';
                        document.getElementById('abyssRuneWorkshopUI').style.display = 'none';
                        abyssResumeAfterSpecialEvent();
                    };
                })(s.eq, runeId);
                el.appendChild(btn);
            })();
        }
    }
    var btnRune = document.createElement('button');
    btnRune.style.background = 'linear-gradient(145deg,#7b1fa2,#4a148c)';
    btnRune.style.color = '#fff';
    btnRune.style.border = '2px solid #ce93d8';
    btnRune.style.padding = '12px';
    btnRune.style.borderRadius = '8px';
    btnRune.style.cursor = 'pointer';
    btnRune.textContent = '领取随机符文 x2（不镶嵌）';
    btnRune.onclick = function() {
        abyssRun.runeInventory = abyssRun.runeInventory || [];
        abyssRun.runeInventory.push(ABYSS_RUNES[Math.floor(Math.random() * ABYSS_RUNES.length)].id);
        abyssRun.runeInventory.push(ABYSS_RUNES[Math.floor(Math.random() * ABYSS_RUNES.length)].id);
        document.getElementById('abyssRuneWorkshopOverlay').style.display = 'none';
        document.getElementById('abyssRuneWorkshopUI').style.display = 'none';
        abyssLog('符文工坊：获得随机符文 x2');
        abyssResumeAfterSpecialEvent();
    };
    el.appendChild(btnRune);
    document.getElementById('abyssRuneWorkshopOverlay').style.display = 'block';
    document.getElementById('abyssRuneWorkshopUI').style.display = 'block';
    abyssLog('深渊符文工坊出现！');
}
function abyssSkipRuneWorkshop() {
    document.getElementById('abyssRuneWorkshopOverlay').style.display = 'none';
    document.getElementById('abyssRuneWorkshopUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

// ========== 深渊宝石匠（每23层，免费镶宝石或获得宝石） ==========
function abyssShowGemSmith() {
    var equipped = abyssRun.equipped || {};
    var gemInv = (abyssRun.gemInventory || []).slice();
    var slotsWithSlots = [];
    for (var k in equipped) {
        var eq = equipped[k];
        if (eq && (eq.gems || []).length < ABYSS_MAX_GEM_SLOTS) slotsWithSlots.push({ slot: k, eq: eq });
    }
    var el = document.getElementById('abyssGemSmithOptions');
    if (!el) return;
    el.innerHTML = '';
    var embedCount = Math.min(slotsWithSlots.length, gemInv.length);
    if (embedCount > 0) {
        for (var i = 0; i < embedCount; i++) {
            (function() {
                var s = slotsWithSlots[i];
                var gemId = gemInv[i];
                var gemInfo = getAbyssGemById(gemId);
                var btn = document.createElement('button');
                btn.style.background = 'linear-gradient(145deg,#e65100,#bf360c)';
                btn.style.color = '#fff';
                btn.style.border = '2px solid #ffb74d';
                btn.style.padding = '12px';
                btn.style.borderRadius = '8px';
                btn.style.cursor = 'pointer';
                btn.style.textAlign = 'left';
                btn.textContent = (ABYSS_SLOT_NAMES[s.slot] || s.slot) + ': ' + (s.eq.name || '') + ' → 镶嵌 ' + (gemInfo ? gemInfo.name : gemId);
                btn.onclick = (function(equip, gid) {
                    return function() {
                        equip.gems = equip.gems || [];
                        if (equip.gems.length < ABYSS_MAX_GEM_SLOTS) {
                            var idx = (abyssRun.gemInventory || []).indexOf(gid);
                            if (idx >= 0) {
                                abyssRun.gemInventory.splice(idx, 1);
                                equip.gems.push(gid);
                                abyssLog('宝石匠：' + (equip.name || '') + ' 镶嵌 ' + (getAbyssGemById(gid) ? getAbyssGemById(gid).name : ''));
                            }
                        }
                        document.getElementById('abyssGemSmithOverlay').style.display = 'none';
                        document.getElementById('abyssGemSmithUI').style.display = 'none';
                        abyssResumeAfterSpecialEvent();
                    };
                })(s.eq, gemId);
                el.appendChild(btn);
            })();
        }
    }
    var btnGem = document.createElement('button');
    btnGem.style.background = 'linear-gradient(145deg,#ff9800,#e65100)';
    btnGem.style.color = '#fff';
    btnGem.style.border = '2px solid #ffb74d';
    btnGem.style.padding = '12px';
    btnGem.style.borderRadius = '8px';
    btnGem.style.cursor = 'pointer';
    btnGem.textContent = '领取随机宝石 x2（不镶嵌）';
    btnGem.onclick = function() {
        abyssRun.gemInventory = abyssRun.gemInventory || [];
        abyssRun.gemInventory.push(ABYSS_GEMS[Math.floor(Math.random() * ABYSS_GEMS.length)].id);
        abyssRun.gemInventory.push(ABYSS_GEMS[Math.floor(Math.random() * ABYSS_GEMS.length)].id);
        document.getElementById('abyssGemSmithOverlay').style.display = 'none';
        document.getElementById('abyssGemSmithUI').style.display = 'none';
        abyssLog('宝石匠：获得随机宝石 x2');
        abyssResumeAfterSpecialEvent();
    };
    el.appendChild(btnGem);
    document.getElementById('abyssGemSmithOverlay').style.display = 'block';
    document.getElementById('abyssGemSmithUI').style.display = 'block';
    abyssLog('深渊宝石匠出现！');
}
function abyssSkipGemSmith() {
    document.getElementById('abyssGemSmithOverlay').style.display = 'none';
    document.getElementById('abyssGemSmithUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

// ========== 深渊占卜师（每4层，礼包抽奖有加有减） ==========
var ABYSS_DIVINER_STATS = [
    { key: 'atkPct', name: '攻击' },
    { key: 'hpPct', name: '生命' },
    { key: 'defPct', name: '防御' }
];
var ABYSS_DIVINER_TIERS = [
    { id: 'normal', name: '普通占卜', range: 3, desc: '攻击/生命/防御等 -3%~+3%' },
    { id: 'medium', name: '中级占卜', range: 5, desc: '攻击/生命/防御等 -5%~+5%' },
    { id: 'high', name: '高级占卜', range: 10, desc: '攻击/生命/防御等 -10%~+10%' }
];
function abyssShowDiviner() {
    var el = document.getElementById('abyssDivinerOptions');
    if (!el) return;
    el.innerHTML = '';
    ABYSS_DIVINER_TIERS.forEach(function(tier) {
        var btn = document.createElement('button');
        btn.style.background = tier.id === 'high' ? 'linear-gradient(145deg,#4a148c,#1a0033)' : tier.id === 'medium' ? 'linear-gradient(145deg,#6a1b9a,#3d0d5e)' : 'linear-gradient(145deg,#7b1fa2,#4a148c)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #ce93d8';
        btn.style.padding = '14px 20px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '13px';
        btn.innerHTML = '<strong>' + tier.name + '</strong><br><small style="color:#b0b0b0;">' + tier.desc + '</small>';
        btn.onclick = (function(t) { return function() { abyssApplyDiviner(t); }; })(tier);
        el.appendChild(btn);
    });
    document.getElementById('abyssDivinerOverlay').style.display = 'block';
    document.getElementById('abyssDivinerUI').style.display = 'block';
    abyssLog('深渊占卜师出现！');
}
function abyssApplyDiviner(tier) {
    if (!abyssRun) return;
    var stat = ABYSS_DIVINER_STATS[Math.floor(Math.random() * ABYSS_DIVINER_STATS.length)];
    var range = tier.range;
    var value = Math.floor(Math.random() * (range * 2 + 1)) - range;
    abyssRun.buffs = abyssRun.buffs || {};
    abyssRun.buffs[stat.key] = (abyssRun.buffs[stat.key] || 0) + value;
    var sign = value >= 0 ? '+' : '';
    var name = stat.name + sign + value + '%';
    abyssLog('占卜师·' + tier.name + '：' + name);
    document.getElementById('abyssDivinerOverlay').style.display = 'none';
    document.getElementById('abyssDivinerUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}
function abyssSkipDiviner() {
    document.getElementById('abyssDivinerOverlay').style.display = 'none';
    document.getElementById('abyssDivinerUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

// ========== 深渊共鸣水晶（每17层） ==========
var ABYSS_CRYSTAL_OPTIONS = [
    { cost: 200, buff: 'atkPct', value: 10, name: '攻击+10%', desc: '200金币' },
    { cost: 200, buff: 'hpPct', value: 15, name: '生命+15%', desc: '200金币' },
    { cost: 200, buff: 'critRatePct', value: 5, name: '暴击率+5%', desc: '200金币' },
    { cost: 200, buff: 'critDmgPct', value: 15, name: '爆伤+15%', desc: '200金币' },
    { cost: 200, buff: 'dodgePct', value: 5, name: '闪避+5%', desc: '200金币' },
    { cost: 200, buff: 'goldPct', value: 10, name: '金币+10%', desc: '200金币' }
];
function abyssShowCrystal() {
    var gold = abyssRun.gold || 0;
    document.getElementById('abyssCrystalGold').textContent = gold;
    var el = document.getElementById('abyssCrystalOptions');
    if (!el) return;
    el.innerHTML = '';
    ABYSS_CRYSTAL_OPTIONS.forEach(function(o) {
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#00838f,#006064)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #4dd0e1';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.style.textAlign = 'left';
        btn.innerHTML = '<span style="color:#81c784">' + o.name + '</span> (' + o.desc + ')';
        btn.disabled = gold < o.cost;
        btn.onclick = (function(opt) { return function() { abyssApplyCrystal(opt); }; })(o);
        el.appendChild(btn);
    });
    document.getElementById('abyssCrystalOverlay').style.display = 'block';
    document.getElementById('abyssCrystalUI').style.display = 'block';
    abyssLog('深渊共鸣水晶出现！');
}
function abyssApplyCrystal(opt) {
    if (!abyssRun || (abyssRun.gold || 0) < opt.cost) return;
    abyssRun.gold -= opt.cost;
    abyssRun.buffs = abyssRun.buffs || {};
    abyssRun.buffs[opt.buff] = (abyssRun.buffs[opt.buff] || 0) + opt.value;
    abyssLog('共鸣水晶：' + opt.name);
    document.getElementById('abyssCrystalOverlay').style.display = 'none';
    document.getElementById('abyssCrystalUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}
function abyssSkipCrystal() {
    document.getElementById('abyssCrystalOverlay').style.display = 'none';
    document.getElementById('abyssCrystalUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

// ========== 深渊幻境迷宫（每18层） ==========
function abyssShowMaze() {
    var el = document.getElementById('abyssMazeOptions');
    if (!el) return;
    el.innerHTML = '';
    var btn1 = document.createElement('button');
    btn1.style.background = 'linear-gradient(145deg,#2e7d32,#1b5e20)';
    btn1.style.color = '#fff';
    btn1.style.border = '2px solid #81c784';
    btn1.style.padding = '16px 28px';
    btn1.style.borderRadius = '10px';
    btn1.style.cursor = 'pointer';
    btn1.style.fontSize = '14px';
    btn1.innerHTML = '🛡 稳健路线<br><small style="color:#b0b0b0;">稳定获得金币+装备+材料</small>';
    btn1.onclick = function() { abyssApplyMaze('safe'); };
    var btn2 = document.createElement('button');
    btn2.style.background = 'linear-gradient(145deg,#6a1b9a,#4a148c)';
    btn2.style.color = '#fff';
    btn2.style.border = '2px solid #ce93d8';
    btn2.style.padding = '16px 28px';
    btn2.style.borderRadius = '10px';
    btn2.style.cursor = 'pointer';
    btn2.style.fontSize = '14px';
    btn2.innerHTML = '⚔ 冒险路线<br><small style="color:#b0b0b0;">20%大奖励 / 80%一般奖励</small>';
    btn2.onclick = function() { abyssApplyMaze('risk'); };
    el.appendChild(btn1);
    el.appendChild(btn2);
    document.getElementById('abyssMazeOverlay').style.display = 'block';
    document.getElementById('abyssMazeUI').style.display = 'block';
    abyssLog('深渊幻境迷宫出现！');
}
function abyssApplyMaze(id) {
    if (!abyssRun) return;
    var f = abyssRun.floor;
    abyssRun.materials = abyssRun.materials || {};
    if (id === 'safe') {
        abyssRun.gold = (abyssRun.gold || 0) + Math.floor(70 + f * 5);
        abyssRun.materials.upgradeStone = (abyssRun.materials.upgradeStone || 0) + 1;
        var eq = abyssGenEquipment(f, false, Math.random() < 0.5 ? 1 : 2);
        if (eq) abyssRun.inventory.push(eq);
        abyssLog('幻境迷宫·稳健：获得金币、升级石、装备');
    } else {
        if (Math.random() < 0.2) {
            abyssRun.gold = (abyssRun.gold || 0) + Math.floor(180 + f * 15);
            abyssRun.materials = abyssRun.materials || {};
            abyssRun.materials.enhanceStone = (abyssRun.materials.enhanceStone || 0) + 2;
            var eq2 = abyssGenEquipment(f, false, 3);
            if (eq2) abyssRun.inventory.push(eq2);
            abyssRun.tempStats = abyssRun.tempStats || {};
            abyssRun.tempStats.atk = (abyssRun.tempStats.atk || 0) + Math.floor(10 + f / 3);
            abyssLog('幻境迷宫·冒险：大丰收！');
        } else {
            abyssRun.gold = (abyssRun.gold || 0) + Math.floor(50 + f * 4);
            abyssLog('幻境迷宫·冒险：收获一般');
        }
    }
    document.getElementById('abyssMazeOverlay').style.display = 'none';
    document.getElementById('abyssMazeUI').style.display = 'none';
    abyssResumeAfterSpecialEvent();
}

// 深渊诅咒/奖励效果在 abyssCalcPlayerStats 的 buffs 之后应用；试炼限制在战斗逻辑中检查
// ========== 奇遇·闫闫 ==========
// 奇遇·闫闫：每5层结束有几率触发，奖励池（3选1）
var ABYSS_ENCOUNTER_CHANCE = 0.35;
var ABYSS_ENCOUNTER_POOL = [
    { key: 'gold', name: '闯关金币', value: 150, valueScale: 0 },
    { key: 'hp', name: '生命', value: 120, valueScale: 8 },
    { key: 'atk', name: '攻击', value: 22, valueScale: 1.5 },
    { key: 'def', name: '防御', value: 12, valueScale: 0.8 },
    { key: 'lifesteal', name: '吸血', value: 1, valueScale: 0 },
    { key: 'critRate', name: '暴击率', value: 2, valueScale: 0 },
    { key: 'critDmg', name: '爆伤', value: 8, valueScale: 0 },
    { key: 'skillDmg', name: '技能伤害', value: 4, valueScale: 0 },
    { key: 'exp', name: '经验', value: 50, valueScale: 0 },
    { key: 'equip', name: '随机装备', value: 1, valueScale: 0 }
];

function abyssShowEncounter() {
    var f = abyssRun.floor;
    var pool = ABYSS_ENCOUNTER_POOL.slice();
    var opts = [];
    for (var i = 0; i < 3 && pool.length > 0; i++) {
        var idx = Math.floor(Math.random() * pool.length);
        var o = pool[idx];
        pool.splice(idx, 1);
        var v = o.key === 'equip' ? 1 : (o.value + (o.valueScale ? Math.floor(f * o.valueScale) : 0));
        opts.push({ key: o.key, name: o.name, value: v });
    }
    var el = document.getElementById('abyssEncounterOptions');
    if (!el) return;
    el.innerHTML = '';
    opts.forEach(function(o) {
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#2e7d32,#1b5e20)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #81c784';
        btn.style.padding = '14px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '14px';
        if (o.key === 'equip') btn.textContent = o.name;
        else btn.textContent = o.name + '+' + o.value + (o.key === 'lifesteal' || o.key === 'dodge' || o.key === 'critRate' || o.key === 'skillDmg' ? '%' : (o.key === 'exp' ? '' : ''));
        btn.onclick = (function(k, v) { return function() { abyssApplyEncounterChoice(k, v); }; })(o.key, o.value);
        el.appendChild(btn);
    });
    document.getElementById('abyssEncounterOverlay').style.display = 'block';
    document.getElementById('abyssEncounterUI').style.display = 'block';
}

function abyssApplyEncounterChoice(key, value) {
    if (!abyssRun) return;
    abyssRun.tempStats = abyssRun.tempStats || {};
    var nameMap = { gold: '闯关金币', hp: '生命', atk: '攻击', def: '防御', lifesteal: '吸血', critRate: '暴击率', critDmg: '爆伤', skillDmg: '技能伤害', exp: '经验', equip: '随机装备' };
    if (key === 'gold') {
        abyssRun.gold = (abyssRun.gold || 0) + value;
    } else if (key === 'exp') {
        var applied = abyssApplyExpGoldBonus(value, 0);
        abyssRun.exp = (abyssRun.exp || 0) + applied.exp;
    } else if (key === 'equip') {
        var eq = abyssGenEquipment(abyssRun.floor, false);
        if (eq) { abyssRun.inventory.push(eq); abyssLog('奇遇·闫闫：获得装备 ' + eq.name); }
    } else if (key === 'hp') {
        abyssRun.player.maxHp = (abyssRun.player.maxHp || 0) + value;
        abyssRun.player.hp = (abyssRun.player.hp || 0) + value;
    } else {
        abyssRun.tempStats[key] = (abyssRun.tempStats[key] || 0) + value;
    }
    if (key !== 'equip') abyssLog('奇遇·闫闫：选择 ' + (nameMap[key] || key) + '+' + value);
    document.getElementById('abyssEncounterOverlay').style.display = 'none';
    document.getElementById('abyssEncounterUI').style.display = 'none';
    abyssRun.pendingChoice = false;
    if (abyssCheckLevelUp()) { abyssRun.needSpawnAfterUpgrade = true; return; }
    abyssRun.needSpawnAfterUpgrade = false;
    abyssSpawnMonster();
    updateAbyssRunUI();
}

function abyssShowChoice() {
    var f = abyssRun.floor;
    var pool = ABYSS_CHOICE_POOL.slice();
    var opts = [];
    for (var i = 0; i < 5 && pool.length > 0; i++) {
        var idx = Math.floor(Math.random() * pool.length);
        var o = pool[idx];
        pool.splice(idx, 1);
        var v = o.key === 'level' ? 25 : (o.value + (o.valueScale ? Math.floor(f * o.valueScale) : 0));
        opts.push({ key: o.key, name: o.name, value: v });
    }
    var el = document.getElementById('abyssChoiceOptions');
    el.innerHTML = '';
    opts.forEach(function(o) {
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#6a0dad,#4a0072)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #b388ff';
        btn.style.padding = '12px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.textContent = o.key === 'level' ? o.name : (o.name + '+' + o.value + (o.key === 'lifesteal' || o.key === 'dodge' || o.key === 'critRate' || o.key === 'reduceMonsterDef' ? '%' : ''));
        btn.onclick = (function(k, v) { return function() { abyssApplyChoice(k, v); }; })(o.key, o.value);
        el.appendChild(btn);
    });
    document.getElementById('abyssChoiceOverlay').style.display = 'block';
    document.getElementById('abyssChoiceUI').style.display = 'block';
}

function abyssApplyChoice(key, value) {
    if (!abyssRun || !abyssRun.tempStats) return;
    var nameMap = { hp: '生命', atk: '攻击', def: '防御', lifesteal: '吸血', dodge: '闪避', critRate: '暴击率', critDmg: '爆伤', skillDmg: '技能伤害', reduceMonsterDef: '减怪防', level: '经验' };
    if (key === 'level') {
        var appliedLevel = abyssApplyExpGoldBonus(25, 0);
        abyssRun.exp = (abyssRun.exp || 0) + appliedLevel.exp;
    } else if (key === 'hp') {
        abyssRun.player.maxHp += value;
        abyssRun.player.hp += value;
    } else {
        abyssRun.tempStats[key] = (abyssRun.tempStats[key] || 0) + value;
    }
    document.getElementById('abyssChoiceOverlay').style.display = 'none';
    document.getElementById('abyssChoiceUI').style.display = 'none';
    abyssRun.pendingChoice = false;
    if (abyssCheckLevelUp()) { abyssRun.needSpawnAfterUpgrade = true; return; }
    abyssRun.needSpawnAfterUpgrade = false;
    abyssSpawnMonster();
    updateAbyssRunUI();
    abyssLog('选择: ' + (nameMap[key] || key) + '+' + value);
}

var ABYSS_UPGRADE_REFRESH_COST = 120;

function abyssCheckLevelUp() {
    if (!abyssRun || !abyssRun.active || abyssRun.pendingChoice || abyssRun.pendingUpgradeChoice) return false;
    var rl = Math.floor((abyssRun.exp || 0) / 100);
    if (rl <= (abyssRun.lastUpgradeChoiceLevel || 0)) return false;
    abyssRun.pendingUpgradeChoice = true;
    abyssRun.pendingUpgradeLevel = (abyssRun.lastUpgradeChoiceLevel || 0) + 1;
    abyssShowUpgradeChoice();
    return true;
}

function abyssShowUpgradeChoice() {
    if (!abyssRun) return;
    var pool = ABYSS_UPGRADE_POOL.slice();
    var opts = [];
    for (var i = 0; i < 3 && pool.length > 0; i++) {
        var idx = Math.floor(Math.random() * pool.length);
        var o = pool[idx];
        pool.splice(idx, 1);
        opts.push({ key: o.key, name: o.name, value: o.value, unit: o.unit || '%' });
    }
    abyssRun.currentUpgradeOptions = opts;
    var el = document.getElementById('abyssUpgradeChoiceOptions');
    if (!el) return;
    el.innerHTML = '';
    opts.forEach(function(o) {
        var btn = document.createElement('button');
        btn.style.background = 'linear-gradient(145deg,#2e7d32,#1b5e20)';
        btn.style.color = '#fff';
        btn.style.border = '2px solid #81c784';
        btn.style.padding = '14px';
        btn.style.borderRadius = '8px';
        btn.style.cursor = 'pointer';
        btn.style.fontSize = '14px';
        btn.textContent = o.name + '+' + o.value + (o.unit || '%');
        btn.onclick = (function(k, v) { return function() { abyssApplyUpgradeChoice(k, v); }; })(o.key, o.value);
        el.appendChild(btn);
    });
    var goldEl = document.getElementById('abyssUpgradePanelGold');
    if (goldEl) goldEl.textContent = abyssRun.gold || 0;
    var refreshBtn = document.getElementById('abyssUpgradeRefreshBtn');
    if (refreshBtn) refreshBtn.disabled = (abyssRun.gold || 0) < ABYSS_UPGRADE_REFRESH_COST;
    document.getElementById('abyssUpgradeChoiceOverlay').style.display = 'block';
    document.getElementById('abyssUpgradeChoiceUI').style.display = 'block';
}

function abyssRefreshUpgradeChoice() {
    if (!abyssRun || (abyssRun.gold || 0) < ABYSS_UPGRADE_REFRESH_COST) return;
    abyssRun.gold = (abyssRun.gold || 0) - ABYSS_UPGRADE_REFRESH_COST;
    abyssLog('消耗120闯关金币刷新升级选项');
    abyssShowUpgradeChoice();
}

function abyssApplyUpgradeChoice(key, value) {
    if (!abyssRun) return;
    abyssRun.buffs = abyssRun.buffs || {};
    abyssRun.buffs[key] = (abyssRun.buffs[key] || 0) + value;
    abyssRun.lastUpgradeChoiceLevel = abyssRun.pendingUpgradeLevel || abyssRun.runLevel;
    abyssRun.pendingUpgradeChoice = false;
    document.getElementById('abyssUpgradeChoiceOverlay').style.display = 'none';
    document.getElementById('abyssUpgradeChoiceUI').style.display = 'none';
    abyssLog('升级奖励: ' + (ABYSS_UPGRADE_POOL.find(function(x){ return x.key === key; }) || {}).name + '+' + value + '%');
    updateAbyssRunUI();
    var rl = Math.floor((abyssRun.exp || 0) / 100);
    if (rl > (abyssRun.lastUpgradeChoiceLevel || 0)) {
        abyssRun.pendingUpgradeChoice = true;
        abyssRun.pendingUpgradeLevel = (abyssRun.lastUpgradeChoiceLevel || 0) + 1;
        abyssShowUpgradeChoice();
        return;
    }
    if (abyssRun.afterUpgradeDoFloorClear) {
        abyssRun.afterUpgradeDoFloorClear = false;
        var f = abyssRun.floor - 1;
        if (abyssTrySpecialEvents(f)) return;
        if (f % 5 === 0 && Math.random() < ABYSS_ENCOUNTER_CHANCE) {
            abyssLog('奇遇·闫闫出现！');
            abyssShowEncounter();
            return;
        }
        abyssShowChoice();
        return;
    }
    abyssRun.pendingChoice = false;
    if (abyssRun.needSpawnAfterUpgrade) {
        abyssRun.needSpawnAfterUpgrade = false;
        abyssSpawnMonster();
    }
    updateAbyssRunUI();
}

function openAbyssTempShop() {
    document.getElementById('abyssTempShopGold').textContent = abyssRun.gold;
    var list = [];
    for (var i = 0; i < 6; i++) {
        var eq = abyssGenEquipment(abyssRun.floor, false);
        eq.price = Math.floor(80 + abyssRun.floor * 8 + eq.quality * 50);
        list.push({ type: 'equip', data: eq });
    }
    var el = document.getElementById('abyssTempShopContent');
    el.innerHTML = '';
    list.forEach(function(item) {
        var div = document.createElement('div');
        div.style.background = 'rgba(0,0,0,0.4)';
        div.style.padding = '10px';
        div.style.borderRadius = '8px';
        div.style.border = '1px solid #555';
        if (item.type === 'equip') {
            var e = item.data;
            div.innerHTML = '<div style="color:' + (ABYSS_QUALITY_COLOR[e.quality] || '#fff') + '">' + e.name + '</div><div style="font-size:12px;color:#888">' + (e.price || 0) + ' 金币</div>';
            var buyBtn = document.createElement('button');
            buyBtn.textContent = '购买';
            buyBtn.style.marginTop = '6px';
            buyBtn.onclick = (function(equip, cost) {
                return function() {
                    if (abyssRun.gold >= cost) {
                        abyssRun.gold -= cost;
                        abyssRun.inventory.push(equip);
                        openAbyssTempShop();
                    }
                };
            })(e, e.price);
            div.appendChild(buyBtn);
        } else {
            var name = item.type === 'enhanceStone' ? '强化石' : item.type === 'enchantBook' ? '附魔书' : '生命药剂(20%生命)';
            div.innerHTML = '<div>' + name + '</div><div style="font-size:12px">' + item.price + ' 金币</div>';
            var buyBtn = document.createElement('button');
            buyBtn.textContent = '购买';
            buyBtn.style.marginTop = '6px';
            buyBtn.onclick = (function(t, cost, heal) {
                return function() {
                    if (abyssRun.gold >= cost) {
                        abyssRun.gold -= cost;
                        if (t === 'enhanceStone') abyssRun.materials.enhanceStone++;
                        else if (t === 'enchantBook') abyssRun.materials.enchantBook++;
                        else if (t === 'potion') abyssRun.materials.potion++;
                        openAbyssTempShop();
                    }
                };
            })(item.type, item.price, item.heal || 0);
            div.appendChild(buyBtn);
        }
        el.appendChild(div);
    });
    document.getElementById('abyssTempShopOverlay').style.display = 'block';
    document.getElementById('abyssTempShopUI').style.display = 'block';
}

function closeAbyssTempShop() {
    document.getElementById('abyssTempShopOverlay').style.display = 'none';
    document.getElementById('abyssTempShopUI').style.display = 'none';
    abyssRun.justKilledBoss = false;
    if (abyssRun.curseRounds > 0) abyssRun.curseRounds--;
    if (abyssRun.trialRoundsLeft > 0) abyssRun.trialRoundsLeft--;
    abyssRun.floor++;
    abyssRun.pendingChoice = true;
    var clearedFloor = abyssRun.floor - 1;
    if (abyssTrySpecialEvents(clearedFloor)) return;
    if (clearedFloor % 5 === 0 && Math.random() < ABYSS_ENCOUNTER_CHANCE) {
        abyssLog('奇遇·闫闫出现！');
        abyssShowEncounter();
        return;
    }
    abyssShowChoice();
}

function openAbyssEquipmentPanel() {
    if (!abyssRun || !abyssRun.active) return;
    var goldEl = document.getElementById('abyssEquipGold');
    if (goldEl) goldEl.textContent = formatNumber(abyssRun.gold || 0);
    var upgradeEl = document.getElementById('abyssUpgradeStoneCount');
    if (upgradeEl) upgradeEl.textContent = abyssRun.materials.upgradeStone || 0;
    document.getElementById('abyssEnhanceStoneCount').textContent = abyssRun.materials.enhanceStone || 0;
    document.getElementById('abyssEnchantBookCount').textContent = abyssRun.materials.enchantBook || 0;
    document.getElementById('abyssPotionCount').textContent = abyssRun.materials.potion || 0;
    var runeInv = abyssRun.runeInventory || [];
    var gemInv = abyssRun.gemInventory || [];
    var runeCountEl = document.getElementById('abyssRuneCount');
    var gemCountEl = document.getElementById('abyssGemCount');
    if (runeCountEl) runeCountEl.textContent = runeInv.length;
    if (gemCountEl) gemCountEl.textContent = gemInv.length;
    var runeOpenerEl = document.getElementById('abyssRuneOpenerCount');
    var gemOpenerEl = document.getElementById('abyssGemOpenerCount');
    if (runeOpenerEl) runeOpenerEl.textContent = abyssRun.materials.runeSlotOpener || 0;
    if (gemOpenerEl) gemOpenerEl.textContent = abyssRun.materials.gemSlotOpener || 0;
    var slotEl = document.getElementById('abyssEquippedSlots');
    slotEl.innerHTML = '';
    ABYSS_SLOTS.forEach(function(slot) {
        var eq = abyssRun.equipped[slot];
        var div = document.createElement('div');
        div.style.background = eq ? (ABYSS_QUALITY_COLOR[eq.quality] || '#333') : '#333';
        div.style.padding = '8px';
        div.style.borderRadius = '6px';
        div.style.cursor = 'pointer';
        div.style.fontSize = '12px';
        var line1 = ABYSS_SLOT_NAMES[slot] + ': ' + (eq ? abyssGetEquipDisplayName(eq) : '空');
        var line2 = '';
        if (eq && eq.equipSkill) {
            var eff = eq.equipSkill.effect;
            if (!eff && eq.equipSkill.id) {
                var sk = ABYSS_EQUIP_SKILLS.find(function(s) { return s.id === eq.equipSkill.id; });
                if (sk && sk.effect) eff = sk.effect;
            }
            var effDesc = abyssEquipSkillEffectDesc(eff);
            if (effDesc.length) line2 = '<div style="font-size:11px;color:#ce93d8;margin-top:4px;">' + eq.equipSkill.name + '：' + effDesc.join('；') + '</div>';
            else line2 = '<div style="font-size:11px;color:#b388ff;margin-top:4px;">' + eq.equipSkill.name + '</div>';
        }
        div.innerHTML = line1 + (line2 ? line2 : '');
        div.onclick = (function(s, e) { return function() { if (e) abyssOpenEquipAction(e, s); }; })(slot, eq);
        slotEl.appendChild(div);
    });
    var invEl = document.getElementById('abyssInventorySlots');
    invEl.innerHTML = '';
    (abyssRun.inventory || []).forEach(function(eq, idx) {
        var div = document.createElement('div');
        div.style.background = (ABYSS_QUALITY_COLOR[eq.quality] || '#333');
        div.style.padding = '8px';
        div.style.borderRadius = '6px';
        div.style.cursor = 'pointer';
        div.style.fontSize = '12px';
        div.textContent = abyssGetEquipDisplayName(eq);
        div.onclick = (function(item, i) { return function() { abyssOpenEquipCompare(item, i); }; })(eq, idx);
        invEl.appendChild(div);
    });
    document.getElementById('abyssEquipOverlay').style.display = 'block';
    document.getElementById('abyssEquipUI').style.display = 'block';
}

function closeAbyssEquipmentPanel() {
    document.getElementById('abyssEquipOverlay').style.display = 'none';
    document.getElementById('abyssEquipUI').style.display = 'none';
}

function openAbyssChallengeShop() {
    if (!abyssRun || !abyssRun.active) return;
    document.getElementById('abyssChallengeShopGold').textContent = formatNumber(abyssRun.gold || 0);
    var shopEl = document.getElementById('abyssChallengeShopContent');
    shopEl.innerHTML = '';
    var shopItems = [
        { id: 'upgradeStone', name: '升级石', price: 150, mat: 'upgradeStone' },
        { id: 'potion', name: '生命药剂', price: 80, mat: 'potion' },
        { id: 'enhanceStone', name: '强化石', price: 100, mat: 'enhanceStone' },
        { id: 'enchantBook', name: '附魔书', price: 120, mat: 'enchantBook' },
        { id: 'petRevivePotion', name: '宠物复活药水', price: 300, mat: 'petRevivePotion' },
        { id: 'petSkillBook', name: '宠物兽决', price: 110, mat: 'petSkillBook' },
        { id: 'randomRune', name: '随机符文', price: 200, mat: 'rune' },
        { id: 'randomGem', name: '随机宝石', price: 180, mat: 'gem' },
        { id: 'runeSlotOpener', name: '符文开孔器', price: 350, mat: 'runeSlotOpener' },
        { id: 'gemSlotOpener', name: '宝石开孔器', price: 320, mat: 'gemSlotOpener' }
    ];
    shopItems.forEach(function(it) {
        var div = document.createElement('div');
        div.style.background = 'rgba(0,0,0,0.3)';
        div.style.padding = '10px 12px';
        div.style.borderRadius = '8px';
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        div.style.alignItems = 'center';
        div.style.fontSize = '14px';
        div.innerHTML = '<span>' + it.name + '</span><span style="color:#ffd700;">' + formatNumber(it.price) + ' 金币</span><button style="background:linear-gradient(145deg,#ffd700,#daa520);color:#333;border:none;padding:6px 14px;border-radius:5px;cursor:pointer;font-weight:bold;">购买</button>';
        var btn = div.querySelector('button');
        btn.onclick = (function(cost, mat) {
            return function() {
                if (!abyssRun || !abyssRun.active) return;
                if ((abyssRun.gold || 0) >= cost) {
                    abyssRun.gold -= cost;
                    if (mat === 'rune') {
                        abyssRun.runeInventory = abyssRun.runeInventory || [];
                        abyssRun.runeInventory.push(ABYSS_RUNES[Math.floor(Math.random() * ABYSS_RUNES.length)].id);
                    } else                     if (mat === 'gem') {
                        abyssRun.gemInventory = abyssRun.gemInventory || [];
                        abyssRun.gemInventory.push(ABYSS_GEMS[Math.floor(Math.random() * ABYSS_GEMS.length)].id);
                    } else if (mat === 'runeSlotOpener' || mat === 'gemSlotOpener') {
                        abyssRun.materials[mat] = (abyssRun.materials[mat] || 0) + 1;
                    } else {
                        abyssRun.materials[mat] = (abyssRun.materials[mat] || 0) + 1;
                    }
                    document.getElementById('abyssChallengeShopGold').textContent = formatNumber(abyssRun.gold || 0);
                    updateAbyssRunUI();
                }
            };
        })(it.price, it.mat);
        shopEl.appendChild(div);
    });
    document.getElementById('abyssChallengeShopOverlay').style.display = 'block';
    document.getElementById('abyssChallengeShopUI').style.display = 'block';
}

function closeAbyssChallengeShop() {
    document.getElementById('abyssChallengeShopOverlay').style.display = 'none';
    document.getElementById('abyssChallengeShopUI').style.display = 'none';
}

var abyssPetPanelSelectedId = null;

function openAbyssPetPanel() {
    if (!abyssRun || !abyssRun.active) return;
    var pets = abyssRun.pets || [];
    document.getElementById('abyssPetReviveCount').textContent = abyssRun.materials.petRevivePotion || 0;
    var skillBookEl = document.getElementById('abyssPetSkillBookCount');
    if (skillBookEl) skillBookEl.textContent = abyssRun.materials.petSkillBook || 0;
    var countEl = document.getElementById('abyssPetCount');
    if (countEl) countEl.textContent = pets.length + '/10';
    var listEl = document.getElementById('abyssPetList');
    listEl.innerHTML = '';
    if (pets.length === 0) {
        listEl.innerHTML = '<div style="color:#888;font-size:12px;padding:12px;">暂无宠物<br/>击败怪物20%掉落</div>';
        document.getElementById('abyssPetDetail').innerHTML = '<div style="color:#888;text-align:center;padding:40px 20px;">暂无宠物</div>';
        document.getElementById('abyssPetDetailActions').innerHTML = '';
    } else {
        if (!abyssPetPanelSelectedId || !pets.some(function(p) { return p.id === abyssPetPanelSelectedId; }))
            abyssPetPanelSelectedId = pets[0].id;
        for (var i = 0; i < pets.length; i++) {
            var pet = pets[i];
            var isDeployed = abyssIsPetDeployed(pet.id);
            var isDead = pet.hp !== null && pet.hp <= 0;
            var isSel = abyssPetPanelSelectedId === pet.id;
            var row = document.createElement('div');
            row.style.cssText = 'padding:10px 8px;cursor:pointer;border-bottom:1px solid #333;font-size:13px;' + (isSel ? 'background:rgba(194,24,91,0.35);border-left:3px solid #ff80ab;' : '');
            row.innerHTML = '<div style="color:' + (isDead ? '#666' : '#ff80ab') + ';font-weight:bold;">' + pet.name + '</div><div style="color:#aaa;font-size:11px;">Lv.' + pet.level + (isDeployed ? ' · 出战中' : '') + (isDead ? ' · 已死亡' : '') + '</div>';
            row.onclick = (function(pid) { return function() { abyssPetPanelSelectedId = pid; openAbyssPetPanel(); }; })(pet.id);
            listEl.appendChild(row);
        }
        var selPet = null;
        for (var j = 0; j < pets.length; j++) { if (pets[j].id === abyssPetPanelSelectedId) { selPet = pets[j]; break; } }
        if (selPet) {
            var pstats = abyssCalcPetStats(selPet);
            var maxHp = pstats ? pstats.maxHp : 1;
            var curHp = selPet.hp === null ? maxHp : Math.max(0, selPet.hp);
            var expNext = 50;
            var expCur = (selPet.exp || 0) % expNext;
            var runLv = Math.max(1, Math.floor((abyssRun.exp || 0) / 100));
            var hpPct = maxHp > 0 ? (curHp / maxHp * 100) : 0;
            var expPct = (expCur / expNext * 100);
            var detail = document.getElementById('abyssPetDetail');
            var typeName = (ABYSS_PET_TYPES && ABYSS_PET_TYPES.find(function(t){ return t.id === selPet.type; })) ? ABYSS_PET_TYPES.find(function(t){ return t.id === selPet.type; }).name : '';
            detail.innerHTML = '<div style="margin-bottom:12px;"><span style="color:#ff80ab;font-size:16px;font-weight:bold;">' + selPet.name + '</span> ' + (selPet.variant ? '<span style="color:#ffd700;font-size:11px;">变异</span> ' : '') + (typeName ? '<span style="color:#81c784;font-size:11px;">' + typeName + '</span> ' : '') + '<span style="color:#b388ff;">Lv.' + selPet.level + '/' + runLv + '</span></div>' +
                '<div style="margin-bottom:6px;"><div style="font-size:11px;color:#aaa;">气血</div><div style="height:18px;background:#333;border-radius:4px;overflow:hidden;"><div style="height:100%;width:' + hpPct + '%;background:linear-gradient(90deg,#c62828,#e91e63);border-radius:4px;"></div></div><div style="font-size:11px;color:#888;">' + formatNumber(curHp) + ' / ' + formatNumber(maxHp) + '</div></div>' +
                '<div style="margin-bottom:12px;"><div style="font-size:11px;color:#aaa;">经验</div><div style="height:12px;background:#333;border-radius:3px;overflow:hidden;"><div style="height:100%;width:' + expPct + '%;background:linear-gradient(90deg,#ffa726,#ffd54f);border-radius:3px;"></div></div><div style="font-size:11px;color:#888;">' + expCur + ' / ' + expNext + (selPet.level >= runLv ? ' (已满级)' : '') + '</div></div>' +
                '<div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px;font-size:13px;"><div style="background:rgba(0,0,0,0.3);padding:8px;border-radius:6px;">攻击资质 <span style="color:#ff9800">' + selPet.growth.atk + '</span></div><div style="background:rgba(0,0,0,0.3);padding:8px;border-radius:6px;">防御资质 <span style="color:#2196f3">' + selPet.growth.def + '</span></div><div style="background:rgba(0,0,0,0.3);padding:8px;border-radius:6px;">体力资质 <span style="color:#4caf50">' + selPet.growth.hp + '</span></div><div style="background:rgba(0,0,0,0.3);padding:8px;border-radius:6px;">速度资质 <span style="color:#9c27b0">' + selPet.growth.speed + '</span></div></div>' +
                '<div style="font-size:11px;color:#aaa;margin-bottom:4px;">属性 攻击' + (pstats ? pstats.atk : 0) + ' 防御' + (pstats ? pstats.def : 0) + ' 气血' + (pstats ? pstats.maxHp : 0) + '</div>' +
                '<div style="font-size:11px;color:#b388ff;">技能: ' + ((selPet.skills || []).map(function(s) { return s.name; }).join('、') || '无') + '</div>';
            var actEl = document.getElementById('abyssPetDetailActions');
            var isDeployedSel = abyssIsPetDeployed(selPet.id);
            var isDeadSel = selPet.hp !== null && selPet.hp <= 0;
            var canRevive = isDeadSel && (abyssRun.materials.petRevivePotion || 0) >= 1;
            actEl.innerHTML = '';
            var maxSlots = abyssGetMaxDeployedSlots();
            var slotsFull = (abyssRun.deployedPetIds || []).length >= maxSlots;
            var btnOut = document.createElement('button');
            btnOut.textContent = isDeployedSel ? '收回' : (slotsFull ? '出战位已满(' + maxSlots + ')' : '出战');
            btnOut.style.cssText = 'background:' + (isDeployedSel ? '#555' : slotsFull ? '#444' : '#c2185b') + ';color:#fff;border:none;padding:8px 18px;border-radius:6px;cursor:pointer;font-weight:bold;';
            btnOut.disabled = !isDeployedSel && slotsFull;
            btnOut.onclick = (function(pid) { return function() {
                if (!abyssRun.deployedPetIds) abyssRun.deployedPetIds = [];
                var idx = abyssRun.deployedPetIds.indexOf(pid);
                if (idx >= 0) {
                    abyssRun.deployedPetIds.splice(idx, 1);
                    abyssLog('收回了宠物');
                } else if (abyssRun.deployedPetIds.length < abyssGetMaxDeployedSlots()) {
                    abyssRun.deployedPetIds.push(pid);
                    var p = null;
                    for (var qi = 0; qi < abyssRun.pets.length; qi++) { if (abyssRun.pets[qi].id === pid) { p = abyssRun.pets[qi]; break; } }
                    if (p && p.hp === null) {
                        var ps = abyssCalcPetStats(p);
                        if (ps) p.hp = ps.maxHp;
                    }
                    abyssLog('派出宠物【' + (p ? p.name : '') + '】');
                } else {
                    abyssLog('出战位已满(最多' + abyssGetMaxDeployedSlots() + '只)，可在专属商店购买出场宠物数量');
                }
                openAbyssPetPanel();
                updateAbyssRunUI();
            }; })(selPet.id);
            actEl.appendChild(btnOut);
            var hasSkillBook = (abyssRun.materials.petSkillBook || 0) >= 1;
            var btnSkill = document.createElement('button');
            btnSkill.textContent = '打书(消耗1兽决)';
            btnSkill.style.cssText = 'background:' + (hasSkillBook ? '#ff9800' : '#555') + ';color:#fff;border:none;padding:8px 18px;border-radius:6px;cursor:pointer;font-weight:bold;';
            btnSkill.onclick = (function(pid) { return function() {
                if ((abyssRun.materials.petSkillBook || 0) < 1) return;
                var pet = null;
                for (var sb = 0; sb < abyssRun.pets.length; sb++) {
                    if (abyssRun.pets[sb].id === pid) { pet = abyssRun.pets[sb]; break; }
                }
                if (!pet) return;
                abyssRun.materials.petSkillBook--;
                pet.skills = pet.skills || [];
                var isAdd = Math.random() < 0.3;
                var pool = ABYSS_PET_SKILLS.slice();
                if (isAdd && pet.skills.length < 12) {
                    for (var si = pet.skills.length - 1; si >= 0; si--) {
                        for (var pj = pool.length - 1; pj >= 0; pj--) {
                            if (pool[pj].id === pet.skills[si].id) { pool.splice(pj, 1); break; }
                        }
                    }
                    if (pool.length > 0) {
                        var pick = pool[Math.floor(Math.random() * pool.length)];
                        pet.skills.push({ id: pick.id, name: pick.name });
                        abyssLog('打书成功！宠物【' + pet.name + '】领悟技能【' + pick.name + '】');
                    }
                } else {
                    if (pet.skills.length === 0) {
                        var pick0 = pool[Math.floor(Math.random() * pool.length)];
                        pet.skills.push({ id: pick0.id, name: pick0.name });
                        abyssLog('打书成功！宠物【' + pet.name + '】领悟技能【' + pick0.name + '】');
                    } else {
                        var idx = Math.floor(Math.random() * pet.skills.length);
                        var oldName = pet.skills[idx].name;
                        var pick1 = pool[Math.floor(Math.random() * pool.length)];
                        pet.skills[idx] = { id: pick1.id, name: pick1.name };
                        abyssLog('打书：宠物【' + pet.name + '】技能【' + oldName + '】被替换为【' + pick1.name + '】');
                    }
                }
                openAbyssPetPanel();
                updateAbyssRunUI();
            }; })(selPet.id);
            actEl.appendChild(btnSkill);
            var btnRelease = document.createElement('button');
            btnRelease.textContent = '放生';
            btnRelease.style.cssText = 'background:#795548;color:#fff;border:none;padding:8px 18px;border-radius:6px;cursor:pointer;font-weight:bold;';
            btnRelease.onclick = (function(pid) { return function() {
                if (abyssRun.deployedPetIds) { var ri = abyssRun.deployedPetIds.indexOf(pid); if (ri >= 0) abyssRun.deployedPetIds.splice(ri, 1); }
                for (var r = 0; r < abyssRun.pets.length; r++) {
                    if (abyssRun.pets[r].id === pid) {
                        var rname = abyssRun.pets[r].name;
                        abyssRun.pets.splice(r, 1);
                        abyssLog('放生了宠物【' + rname + '】');
                        abyssPetPanelSelectedId = abyssRun.pets.length ? abyssRun.pets[0].id : null;
                        openAbyssPetPanel();
                        updateAbyssRunUI();
                        return;
                    }
                }
            }; })(selPet.id);
            actEl.appendChild(btnRelease);
            if (canRevive) {
                var btnRev = document.createElement('button');
                btnRev.textContent = '复活(消耗1瓶药水)';
                btnRev.style.cssText = 'background:#4caf50;color:#fff;border:none;padding:8px 18px;border-radius:6px;cursor:pointer;font-weight:bold;';
                btnRev.onclick = (function(pid) { return function() {
                    if ((abyssRun.materials.petRevivePotion || 0) < 1) return;
                    for (var k = 0; k < abyssRun.pets.length; k++) {
                        if (abyssRun.pets[k].id === pid) {
                            abyssRun.materials.petRevivePotion--;
                            var ps = abyssCalcPetStats(abyssRun.pets[k]);
                            abyssRun.pets[k].hp = ps ? ps.maxHp : 100;
                            abyssLog('宠物【' + abyssRun.pets[k].name + '】已复活');
                            openAbyssPetPanel();
                            updateAbyssRunUI();
                            return;
                        }
                    }
                }; })(selPet.id);
                actEl.appendChild(btnRev);
            }
        }
    }
    document.getElementById('abyssPetOverlay').style.display = 'block';
    document.getElementById('abyssPetUI').style.display = 'block';
}

function closeAbyssPetPanel() {
    document.getElementById('abyssPetOverlay').style.display = 'none';
    document.getElementById('abyssPetUI').style.display = 'none';
}

function openAbyssPetSynthesisPanel() {
    if (!abyssRun || !abyssRun.active) return;
    var pets = abyssRun.pets || [];
    if (pets.length < 2) {
        abyssLog('至少需要2只宠物才能合成');
        return;
    }
    var sel1 = document.getElementById('abyssSynthesisPet1');
    var sel2 = document.getElementById('abyssSynthesisPet2');
    sel1.innerHTML = '';
    sel2.innerHTML = '';
    for (var i = 0; i < pets.length; i++) {
        var p = pets[i];
        var opt1 = document.createElement('option');
        opt1.value = p.id;
        opt1.textContent = p.name + ' Lv.' + p.level + ' (攻' + p.growth.atk + '防' + p.growth.def + '体' + p.growth.hp + '速' + p.growth.speed + ')';
        sel1.appendChild(opt1);
        var opt2 = document.createElement('option');
        opt2.value = p.id;
        opt2.textContent = p.name + ' Lv.' + p.level + ' (攻' + p.growth.atk + '防' + p.growth.def + '体' + p.growth.hp + '速' + p.growth.speed + ')';
        sel2.appendChild(opt2);
    }
    if (pets.length > 0) sel2.selectedIndex = 1;
    sel1.onchange = abyssUpdateSynthesisSkillPool;
    sel2.onchange = abyssUpdateSynthesisSkillPool;
    abyssUpdateSynthesisSkillPool();
    document.getElementById('abyssPetSynthesisOverlay').style.display = 'block';
    document.getElementById('abyssPetSynthesisUI').style.display = 'block';
}

function abyssUpdateSynthesisSkillPool() {
    if (!abyssRun || !abyssRun.pets) return;
    var id1 = document.getElementById('abyssSynthesisPet1') && document.getElementById('abyssSynthesisPet1').value;
    var id2 = document.getElementById('abyssSynthesisPet2') && document.getElementById('abyssSynthesisPet2').value;
    var countEl = document.getElementById('abyssSynthesisSkillCount');
    var poolEl = document.getElementById('abyssSynthesisSkillPool');
    if (!countEl || !poolEl) return;
    var pet1 = null, pet2 = null;
    for (var i = 0; i < abyssRun.pets.length; i++) {
        if (abyssRun.pets[i].id === id1) pet1 = abyssRun.pets[i];
        if (abyssRun.pets[i].id === id2) pet2 = abyssRun.pets[i];
    }
    var seen = {};
    var names = [];
    if (pet1 && pet1.skills) for (var s1 = 0; s1 < pet1.skills.length; s1++) { var sk = pet1.skills[s1]; if (!seen[sk.id]) { seen[sk.id] = true; names.push(sk.name); } }
    if (pet2 && pet2.skills) for (var s2 = 0; s2 < pet2.skills.length; s2++) { var sk = pet2.skills[s2]; if (!seen[sk.id]) { seen[sk.id] = true; names.push(sk.name); } }
    countEl.textContent = names.length;
    poolEl.textContent = names.length ? names.join('、') : '（两只宠物均无技能时无技能池）';
}

function closeAbyssPetSynthesisPanel() {
    document.getElementById('abyssPetSynthesisOverlay').style.display = 'none';
    document.getElementById('abyssPetSynthesisUI').style.display = 'none';
}

function abyssDoPetSynthesis() {
    if (!abyssRun || !abyssRun.active) return;
    var id1 = document.getElementById('abyssSynthesisPet1').value;
    var id2 = document.getElementById('abyssSynthesisPet2').value;
    if (!id1 || !id2 || id1 === id2) {
        abyssLog('请选择两只不同的宠物');
        return;
    }
    var pet1 = null, pet2 = null, idx1 = -1, idx2 = -1;
    for (var i = 0; i < abyssRun.pets.length; i++) {
        if (abyssRun.pets[i].id === id1) { pet1 = abyssRun.pets[i]; idx1 = i; }
        if (abyssRun.pets[i].id === id2) { pet2 = abyssRun.pets[i]; idx2 = i; }
    }
    if (!pet1 || !pet2) { abyssLog('宠物不存在'); return; }
    var basePet = Math.random() < 0.5 ? pet1 : pet2;
    var baseGrowth = basePet.growth || { atk: 2000, def: 2000, hp: 2000, speed: 2000 };
    var roll = function(v) { return Math.max(1, Math.floor(v * (0.8 + Math.random() * 0.4))); };
    var growth = {
        atk: roll(baseGrowth.atk),
        def: roll(baseGrowth.def),
        hp: roll(baseGrowth.hp),
        speed: roll(baseGrowth.speed)
    };
    var skillPool = [];
    var seen = {};
    for (var s1 = 0; s1 < (pet1.skills || []).length; s1++) {
        var sk = pet1.skills[s1];
        if (!seen[sk.id]) { seen[sk.id] = true; skillPool.push({ id: sk.id, name: sk.name }); }
    }
    for (var s2 = 0; s2 < (pet2.skills || []).length; s2++) {
        var sk = pet2.skills[s2];
        if (!seen[sk.id]) { seen[sk.id] = true; skillPool.push({ id: sk.id, name: sk.name }); }
    }
    var poolLen = skillPool.length;
    var tierRoll = Math.random();
    var tierPct = tierRoll < 0.05 ? 0.1 : (tierRoll < 0.25 ? 0.25 : (tierRoll < 0.75 ? 0.5 : (tierRoll < 0.95 ? 0.75 : 1)));
    var skillCount = poolLen <= 0 ? 0 : Math.max(1, Math.min(poolLen, Math.round(poolLen * tierPct)));
    var skills = [];
    if (skillCount > 0 && poolLen > 0) {
        var shuffled = skillPool.slice();
        for (var sh = shuffled.length - 1; sh > 0; sh--) {
            var j = Math.floor(Math.random() * (sh + 1));
            var tmp = shuffled[sh];
            shuffled[sh] = shuffled[j];
            shuffled[j] = tmp;
        }
        for (var t = 0; t < skillCount && t < shuffled.length; t++) skills.push(shuffled[t]);
    }
    var newLevel = Math.max(pet1.level || 1, pet2.level || 1);
    var newPet = {
        id: abyssGenPetId(),
        name: basePet.name,
        type: basePet.type || ABYSS_PET_TYPES[Math.floor(Math.random() * ABYSS_PET_TYPES.length)].id,
        variant: !!basePet.variant,
        level: newLevel,
        exp: 0,
        growth: growth,
        skills: skills,
        hp: null,
        maxHp: 0
    };
    if (abyssRun.deployedPetIds) {
        var d = abyssRun.deployedPetIds;
        for (var di = d.length - 1; di >= 0; di--) { if (d[di] === id1 || d[di] === id2) d.splice(di, 1); }
    }
    var ord1 = idx1 < idx2 ? idx1 : idx2;
    var ord2 = idx1 < idx2 ? idx2 : idx1;
    abyssRun.pets.splice(ord2, 1);
    abyssRun.pets.splice(ord1, 1);
    abyssRun.pets.push(newPet);
    closeAbyssPetSynthesisPanel();
    abyssLog('合成成功！获得宠物【' + newPet.name + '】资质 攻' + newPet.growth.atk + ' 防' + newPet.growth.def + ' 体' + newPet.growth.hp + ' 速' + newPet.growth.speed + '，技能数' + newPet.skills.length + '/' + poolLen + '：' + (newPet.skills.map(function(s){ return s.name; }).join('、') || '无'));
    abyssPetPanelSelectedId = newPet.id;
    openAbyssPetPanel();
    updateAbyssRunUI();
}

function openAbyssTalentPanel() {
    if (!abyssRun || !abyssRun.active) return;
    document.getElementById('abyssTalentPointsDisplay').textContent = abyssRun.talentPoints || 0;
    var listEl = document.getElementById('abyssTalentList');
    listEl.innerHTML = '';
    var talents = abyssRun.talents || {};
    for (var i = 0; i < ABYSS_TALENTS.length; i++) {
        var tal = ABYSS_TALENTS[i];
        var curLv = talents[tal.id] || 0;
        var parentOk = !tal.parent || (talents[tal.parent] || 0) > 0;
        var canAdd = (abyssRun.talentPoints || 0) >= 1 && curLv < tal.maxLevel && parentOk;
        var effText = [];
        if (tal.effect) {
            if (tal.effect.hp) effText.push('生命+' + tal.effect.hp);
            if (tal.effect.atk) effText.push('攻击+' + tal.effect.atk);
            if (tal.effect.def) effText.push('防御+' + tal.effect.def);
            if (tal.effect.critRate) effText.push('暴击+' + tal.effect.critRate + '%');
            if (tal.effect.critDmg) effText.push('爆伤+' + tal.effect.critDmg + '%');
            if (tal.effect.dodge) effText.push('闪避+' + tal.effect.dodge + '%');
            if (tal.effect.lifesteal) effText.push('吸血+' + tal.effect.lifesteal + '%');
            if (tal.effect.combo) effText.push('连击+' + tal.effect.combo + '%');
            if (tal.effect.skillDmg) effText.push('技能伤害+' + tal.effect.skillDmg + '%');
            if (tal.effect.reduceMonsterDef) effText.push('减防+' + tal.effect.reduceMonsterDef + '%');
        }
        var div = document.createElement('div');
        div.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:10px;background:rgba(0,0,0,0.3);border-radius:8px;border:1px solid #555;';
        div.innerHTML = '<div><span style="color:#ffb74d;">' + tal.name + '</span> <span style="color:#888;">Lv.' + curLv + '/' + tal.maxLevel + '</span>' + (effText.length ? ' <span style="font-size:12px;color:#aaa;">(' + effText.join(' ') + ')</span>' : '') + (tal.parent ? ' <span style="font-size:11px;color:#666;">需前置</span>' : '') + '</div>';
        var addBtn = document.createElement('button');
        addBtn.textContent = '+';
        addBtn.style.cssText = 'background:' + (canAdd ? '#ff9800' : '#555') + ';color:#fff;border:none;width:32px;height:32px;border-radius:6px;cursor:' + (canAdd ? 'pointer' : 'not-allowed') + ';font-weight:bold;font-size:18px;';
        if (canAdd) {
            addBtn.onclick = (function(tid) { return function() { abyssLearnTalent(tid); openAbyssTalentPanel(); updateAbyssRunUI(); }; })(tal.id);
        }
        div.appendChild(addBtn);
        listEl.appendChild(div);
    }
    document.getElementById('abyssTalentOverlay').style.display = 'block';
    document.getElementById('abyssTalentUI').style.display = 'block';
}

function closeAbyssTalentPanel() {
    document.getElementById('abyssTalentOverlay').style.display = 'none';
    document.getElementById('abyssTalentUI').style.display = 'none';
}

var ABYSS_SKILL_LEARN_COST_BASE = 280;
var ABYSS_SKILL_LEARN_COST_ZHuan_MULT = 1.4;
function openAbyssSkillPanel() {
    if (!abyssRun || !abyssRun.active) return;
    document.getElementById('abyssSkillPanelGold').textContent = formatNumber(abyssRun.gold || 0);
    var runLevel = Math.floor((abyssRun.exp || 0) / 100);
    var currentZhuan = abyssZhuan(runLevel);
    var classId = abyssRun.playerClass || 'warrior';
    abyssRun.learnedSkillIds = abyssRun.learnedSkillIds || [];
    abyssRun.equippedSkillIds = abyssRun.equippedSkillIds || [null, null, null];
    var slotsEl = document.getElementById('abyssEquippedSkillSlots');
    slotsEl.innerHTML = '';
    for (var slotIdx = 0; slotIdx < 3; slotIdx++) {
        var sid = (abyssRun.equippedSkillIds[slotIdx] != null && abyssRun.equippedSkillIds[slotIdx] !== '') ? abyssRun.equippedSkillIds[slotIdx] : null;
        var sk = sid ? abyssGetSkillById(classId, sid) : null;
        var box = document.createElement('div');
        box.style.cssText = 'width:140px;min-height:50px;background:rgba(106,13,173,0.3);border:2px solid #9c27b0;border-radius:8px;padding:8px;text-align:center;';
        if (sk) {
            box.innerHTML = '<div style="color:#ce93d8;font-weight:bold;">' + sk.name + '</div><div style="font-size:11px;color:#888;">' + (sk.zhuan || 1) + '转</div><button type="button" style="margin-top:4px;background:#555;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:11px;">卸下</button>';
            box.querySelector('button').onclick = (function(sl) { return function() { abyssUnequipSkill(sl); openAbyssSkillPanel(); if (abyssRun && abyssRun.active) updateAbyssRunUI(); }; })(slotIdx);
        } else {
            box.innerHTML = '<div style="color:#666;font-size:12px;">空槽位 ' + (slotIdx + 1) + '</div>';
        }
        slotsEl.appendChild(box);
    }
    var listEl = document.getElementById('abyssSkillLearnList');
    listEl.innerHTML = '';
    var skillList = abyssGetSkillList(classId, abyssRun.classBranch);
    if (skillList) {
        for (var z = 1; z <= 4; z++) {
            var header = document.createElement('div');
            header.style.cssText = 'color:#ffd700;font-weight:bold;margin-top:12px;margin-bottom:6px;';
            header.textContent = z + '转技能';
            listEl.appendChild(header);
            for (var si = 0; si < skillList.length; si++) {
                var s = skillList[si];
                if ((s.zhuan || 1) !== z) continue;
                var learned = (abyssRun.learnedSkillIds || []).indexOf(s.id) >= 0;
                var canUnlock = currentZhuan >= z;
                var cost = Math.floor(ABYSS_SKILL_LEARN_COST_BASE * Math.pow(ABYSS_SKILL_LEARN_COST_ZHuan_MULT, z - 1));
                var canAfford = (abyssRun.gold || 0) >= cost;
                var row = document.createElement('div');
                row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:rgba(0,0,0,0.25);border-radius:6px;border:1px solid #555;flex-wrap:wrap;gap:6px;';
                row.innerHTML = '<div><span style="color:#ce93d8;">' + s.name + '</span> <span style="color:#888;font-size:12px;">' + (s.desc || '') + '</span> <span style="color:#ffd700;font-size:11px;">' + z + '转</span></div>';
                var btnWrap = document.createElement('div');
                if (learned) {
                    var slotsFull = true;
                    for (var k = 0; k < 3; k++) { if (abyssRun.equippedSkillIds[k] == null || abyssRun.equippedSkillIds[k] === '') { slotsFull = false; break; } }
                    if (!slotsFull) {
                        var equipBtn = document.createElement('button');
                        equipBtn.textContent = '装备';
                        equipBtn.style.cssText = 'background:#9c27b0;color:#fff;border:none;padding:6px 12px;border-radius:5px;cursor:pointer;font-size:12px;';
                        equipBtn.onclick = (function(sid) { return function() { abyssEquipSkill(sid); openAbyssSkillPanel(); if (abyssRun && abyssRun.active) updateAbyssRunUI(); }; })(s.id);
                        btnWrap.appendChild(equipBtn);
                    } else {
                        var fullSpan = document.createElement('span');
                        fullSpan.style.color = '#888';
                        fullSpan.textContent = '槽位已满';
                        btnWrap.appendChild(fullSpan);
                    }
                } else if (canUnlock && canAfford) {
                    var learnBtn = document.createElement('button');
                    learnBtn.textContent = '学习(' + cost + '金)';
                    learnBtn.style.cssText = 'background:#4caf50;color:#fff;border:none;padding:6px 12px;border-radius:5px;cursor:pointer;font-size:12px;';
                    learnBtn.onclick = (function(sid, c) { return function() { abyssLearnSkill(sid, c); openAbyssSkillPanel(); if (abyssRun && abyssRun.active) updateAbyssRunUI(); }; })(s.id, cost);
                    btnWrap.appendChild(learnBtn);
                } else if (canUnlock && !canAfford) {
                    var noGold = document.createElement('span');
                    noGold.style.color = '#888';
                    noGold.textContent = '金币不足(' + cost + ')';
                    btnWrap.appendChild(noGold);
                } else {
                    var lock = document.createElement('span');
                    lock.style.color = '#666';
                    lock.textContent = '需' + z + '转';
                    btnWrap.appendChild(lock);
                }
                row.appendChild(btnWrap);
                listEl.appendChild(row);
            }
        }
    }
    document.getElementById('abyssSkillOverlay').style.display = 'block';
    document.getElementById('abyssSkillUI').style.display = 'block';
}
function closeAbyssSkillPanel() {
    document.getElementById('abyssSkillOverlay').style.display = 'none';
    document.getElementById('abyssSkillUI').style.display = 'none';
}
function abyssLearnSkill(skillId, cost) {
    if (!abyssRun || !abyssRun.active || (abyssRun.gold || 0) < cost) return;
    var classId = abyssRun.playerClass || 'warrior';
    var sk = abyssGetSkillById(classId, skillId);
    if (!sk || (abyssRun.learnedSkillIds || []).indexOf(skillId) >= 0) return;
    abyssRun.gold -= cost;
    abyssRun.learnedSkillIds = abyssRun.learnedSkillIds || [];
    abyssRun.learnedSkillIds.push(skillId);
}
function abyssEquipSkill(skillId) {
    if (!abyssRun || !abyssRun.active) return;
    var learned = (abyssRun.learnedSkillIds || []).indexOf(skillId) >= 0;
    if (!learned) return;
    abyssRun.equippedSkillIds = abyssRun.equippedSkillIds || [null, null, null];
    for (var i = 0; i < 3; i++) {
        if (abyssRun.equippedSkillIds[i] === skillId) return;
    }
    var firstEmpty = -1;
    for (var j = 0; j < 3; j++) {
        if (abyssRun.equippedSkillIds[j] == null || abyssRun.equippedSkillIds[j] === '') { firstEmpty = j; break; }
    }
    if (firstEmpty >= 0) abyssRun.equippedSkillIds[firstEmpty] = skillId;
}
function abyssUnequipSkill(slotIndex) {
    if (!abyssRun || slotIndex < 0 || slotIndex > 2) return;
    abyssRun.equippedSkillIds = abyssRun.equippedSkillIds || [null, null, null];
    abyssRun.equippedSkillIds[slotIndex] = null;
}

function abyssLearnTalent(talentId) {
    if (!abyssRun || (abyssRun.talentPoints || 0) < 1) return;
    var tal = ABYSS_TALENTS.find(function(x) { return x.id === talentId; });
    if (!tal) return;
    var cur = (abyssRun.talents || {})[talentId] || 0;
    if (cur >= tal.maxLevel) return;
    if (tal.parent && ((abyssRun.talents || {})[tal.parent] || 0) < 1) return;
    abyssRun.talents = abyssRun.talents || {};
    abyssRun.talents[talentId] = cur + 1;
    abyssRun.talentPoints--;
    abyssLog('学习天赋【' + tal.name + '】Lv.' + (cur + 1));
}

var abyssEquipActionTarget = null;
var abyssEquipActionSlot = null;
var abyssEquipActionInvIdx = null;

function abyssGetEquipDisplayName(eq) {
    if (!eq) return '空';
    var t = (eq.name || '').replace(/\s*Lv\.\d+$/, '').replace(/\s*强化\+\d+$/, '');
    var equipLv = eq.equipLevel != null ? eq.equipLevel : (eq.level || 0);
    var enhanceLv = eq.equipLevel != null ? (eq.level || 0) : 0;
    t += ' Lv.' + equipLv;
    if (enhanceLv > 0) t += ' 强化+' + enhanceLv;
    if (eq.enchant && (eq.enchant === true || (typeof eq.enchant === 'object' && (eq.enchant.statMult || eq.enchant.skillMult || eq.enchant.addedSkill)))) t += ' 附魔';
    var runes = eq.runes || [];
    var runeCnt = 0;
    for (var r = 0; r < runes.length; r++) if (runes[r]) runeCnt++;
    if (runeCnt > 0) t += ' 符文×' + runeCnt;
    var gems = eq.gems || [];
    var gemCnt = 0;
    for (var g = 0; g < gems.length; g++) if (gems[g]) gemCnt++;
    if (gemCnt > 0) t += ' 宝石×' + gemCnt;
    return t;
}

function abyssBuildEquipDetailHtml(eq) {
    if (!eq) return '<div style="color:#666;">该部位未装备</div>';
    var html = '<div style="color:' + (ABYSS_QUALITY_COLOR[eq.quality] || '#fff') + '">' + eq.name + '</div>';
    var equipLv = eq.equipLevel != null ? eq.equipLevel : (eq.level || 0);
    var enhanceLv = eq.equipLevel != null ? (eq.level || 0) : 0;
    var hasEnchant = eq.enchant && (eq.enchant === true || (typeof eq.enchant === 'object' && (eq.enchant.statMult || eq.enchant.skillMult || eq.enchant.addedSkill)));
    html += '<div style="font-size:12px;color:#aaa">装备等级 Lv.' + equipLv + ' &nbsp; 强化+' + enhanceLv + (hasEnchant ? ' &nbsp; 附魔' : '') + '</div>';
    if (enhanceLv > 0) html += '<div style="font-size:12px;color:#ff9800;margin-top:4px;">强化效果: 全属性+' + (enhanceLv * 5) + '%</div>';
    if (hasEnchant && typeof eq.enchant === 'object') {
        var enc = eq.enchant;
        var encLines = [];
        if (enc.statMult) encLines.push('属性+' + Math.floor((enc.statMult - 1) * 100) + '%');
        if (enc.skillMult) encLines.push('技能效果+' + Math.floor((enc.skillMult - 1) * 100) + '%');
        if (enc.addedSkill) encLines.push('附加技能: ' + enc.addedSkill.name);
        if (encLines.length) html += '<div style="font-size:12px;color:#9c27b0;margin-top:4px;">附魔: ' + encLines.join(' | ') + '</div>';
    } else if (eq.enchant === true) html += '<div style="font-size:12px;color:#9c27b0;margin-top:4px;">附魔: 属性+20%</div>';
    var s = eq.stats || {};
    var baseLevelMult = 1 + equipLv * 0.2;
    var enhanceMult = 1 + enhanceLv * 0.05;
    var dispStatMult = (eq.enchant && typeof eq.enchant === 'object' && eq.enchant.statMult) ? eq.enchant.statMult : (eq.enchant === true ? 1.2 : 1);
    var totalMult = baseLevelMult * enhanceMult * dispStatMult;
    html += '<div style="font-size:12px;color:#ccc;margin-top:6px;">';
    if (s.hp) html += ' 生命+' + Math.floor((s.hp || 0) * totalMult);
    if (s.atk) html += ' 攻击+' + Math.floor((s.atk || 0) * totalMult);
    if (s.def) html += ' 防御+' + Math.floor((s.def || 0) * totalMult);
    if (s.critRate) html += ' 暴击+' + ((s.critRate || 0) * totalMult).toFixed(1) + '%';
    if (s.critDmg) html += ' 爆伤+' + ((s.critDmg || 0) * totalMult).toFixed(0) + '%';
    if (s.skillDmg) html += ' 技能伤害+' + Math.floor((s.skillDmg || 0) * totalMult) + '%';
    if (s.str) html += ' 力量+' + Math.floor((s.str || 0) * totalMult);
    if (s.agi) html += ' 敏捷+' + Math.floor((s.agi || 0) * totalMult);
    if (s.int) html += ' 智力+' + Math.floor((s.int || 0) * totalMult);
    if (s.sta) html += ' 体力+' + Math.floor((s.sta || 0) * totalMult);
    html += '</div>';
    var elParts = [];
    for (var ei = 0; ei < ABYSS_ELEMENTS.length; ei++) {
        var el = ABYSS_ELEMENTS[ei];
        var elAtk = (s[el + 'Atk'] || 0) * totalMult;
        var elRes = (s[el + 'Res'] || 0) * totalMult;
        if (elAtk > 0 || elRes > 0) elParts.push(ABYSS_ELEMENT_NAMES[el] + '攻' + Math.floor(elAtk) + ' 抗' + Math.floor(elRes) + '%');
    }
    if (elParts.length) html += '<div style="font-size:12px;color:#ffd700;margin-top:4px;">五行: ' + elParts.join(' | ') + '</div>';
    if (eq.equipSkill) {
        html += '<div style="color:#b388ff;margin-top:6px;">装备技能: ' + eq.equipSkill.name + '</div>';
        var eff = eq.equipSkill.effect;
        if (!eff && eq.equipSkill.id) {
            var sk = ABYSS_EQUIP_SKILLS.find(function(s) { return s.id === eq.equipSkill.id; });
            if (sk && sk.effect) eff = sk.effect;
        }
        var effDesc = abyssEquipSkillEffectDesc(eff);
        if (effDesc.length) html += '<div style="font-size:12px;color:#ce93d8;margin-left:8px;">' + effDesc.join('；') + '</div>';
    }
    return html;
}

function abyssOpenEquipCompare(newItem, invIdx) {
    if (!abyssRun || !abyssRun.active || !newItem) return;
    abyssEquipActionTarget = newItem;
    abyssEquipActionSlot = null;
    abyssEquipActionInvIdx = invIdx;
    var slot = newItem.slot;
    var equippedInSlot = abyssRun.equipped && abyssRun.equipped[slot] ? abyssRun.equipped[slot] : null;
    document.getElementById('abyssCompareEquippedDetail').innerHTML = abyssBuildEquipDetailHtml(equippedInSlot);
    document.getElementById('abyssCompareNewDetail').innerHTML = abyssBuildEquipDetailHtml(newItem);
    document.getElementById('abyssEquipCompareOverlay').style.display = 'block';
    document.getElementById('abyssEquipCompareUI').style.display = 'block';
}

function closeAbyssEquipCompare() {
    document.getElementById('abyssEquipCompareOverlay').style.display = 'none';
    document.getElementById('abyssEquipCompareUI').style.display = 'none';
    abyssEquipActionTarget = null;
    abyssEquipActionSlot = null;
    abyssEquipActionInvIdx = null;
}

function abyssCompareDoEquip() {
    if (!abyssEquipActionTarget || abyssEquipActionInvIdx === null || abyssEquipActionInvIdx === undefined) return;
    var slot = abyssEquipActionTarget.slot;
    if (abyssRun.equipped[slot]) abyssRun.inventory.push(abyssRun.equipped[slot]);
    abyssRun.equipped[slot] = abyssEquipActionTarget;
    abyssRun.inventory.splice(abyssEquipActionInvIdx, 1);
    closeAbyssEquipCompare();
    openAbyssEquipmentPanel();
    updateAbyssRunUI();
}

function abyssCompareDoDismantle() {
    if (!abyssRun || !abyssEquipActionTarget || abyssEquipActionInvIdx === null || abyssEquipActionInvIdx === undefined) return;
    var eq = abyssEquipActionTarget;
    var enhanceLv = eq.level || 0;
    abyssRun.materials.enhanceStone = (abyssRun.materials.enhanceStone || 0) + 1;
    if (enhanceLv > 0) {
        var used = abyssEnhanceStonesUsedToReachLevel(enhanceLv);
        abyssRun.materials.enhanceStone += Math.floor(used * 0.8);
    }
    abyssRun.inventory.splice(abyssEquipActionInvIdx, 1);
    closeAbyssEquipCompare();
    openAbyssEquipmentPanel();
    updateAbyssRunUI();
}

function abyssEquipSkillEffectDesc(effect) {
    if (!effect || typeof effect !== 'object') return [];
    var parts = [];
    if (effect.hp) parts.push('生命+' + effect.hp);
    if (effect.atk) parts.push('攻击+' + effect.atk);
    if (effect.def) parts.push('防御+' + effect.def);
    if (effect.critRate) parts.push('暴击率+' + effect.critRate + '%');
    if (effect.critDmg) parts.push('暴击伤害+' + effect.critDmg + '%');
    if (effect.dodge) parts.push('闪避+' + effect.dodge + '%');
    if (effect.lifesteal) parts.push('吸血+' + effect.lifesteal + '%');
    if (effect.combo) parts.push('连击+' + effect.combo + '%');
    if (effect.skillDmg) parts.push('技能伤害+' + effect.skillDmg + '%');
    if (effect.reduceMonsterDef) parts.push('无视怪物防御+' + effect.reduceMonsterDef + '%');
    if (effect.str) parts.push('力量+' + effect.str);
    if (effect.agi) parts.push('敏捷+' + effect.agi);
    if (effect.int) parts.push('智力+' + effect.int);
    if (effect.sta) parts.push('体力+' + effect.sta);
    if (effect.stunChance) parts.push('攻击时' + (effect.stunChance * 100).toFixed(0) + '%眩晕' + (effect.stunTurns || 1) + '回合');
    if (effect.shieldChance) parts.push((effect.shieldChance * 100).toFixed(0) + '%获得护盾(生命' + ((effect.shieldPct || 0.1) * 100).toFixed(0) + '%)');
    if (effect.healChance) parts.push((effect.healChance * 100).toFixed(0) + '%回复生命(生命上限' + ((effect.healPct || 0.05) * 100).toFixed(0) + '%)');
    if (effect.extraDmgChance) parts.push((effect.extraDmgChance * 100).toFixed(0) + '%额外造成本次伤害' + ((effect.extraDmgPct || 0.1) * 100).toFixed(0) + '%');
    if (effect.damageReduction) parts.push('受到伤害减少' + (effect.damageReduction * 100).toFixed(0) + '%');
    if (effect.extraDmgFromDef) parts.push('攻击附加防御' + (effect.extraDmgFromDef * 100).toFixed(0) + '%的伤害');
    if (effect.extraDmgFromMaxHp) parts.push('攻击附加生命上限' + (effect.extraDmgFromMaxHp * 100).toFixed(0) + '%的伤害');
    if (effect.directPctMonsterHp) parts.push('攻击附加怪物当前生命' + (effect.directPctMonsterHp * 100).toFixed(0) + '%的伤害');
    if (effect.extraDmgFromAtk) parts.push('攻击附加攻击力' + (effect.extraDmgFromAtk * 100).toFixed(0) + '%的伤害');
    if (effect.directPctMonsterMaxHp) parts.push('攻击附加怪物最大生命' + (effect.directPctMonsterMaxHp * 100).toFixed(0) + '%的伤害');
    if (effect.splitChance != null && effect.splitPct != null) parts.push('攻击时' + (effect.splitChance * 100).toFixed(0) + '%分裂，对其它目标造成本次伤害' + (effect.splitPct * 100).toFixed(0) + '%');
    if (effect.petAtk) parts.push('宠物攻击+' + effect.petAtk);
    if (effect.petDef) parts.push('宠物防御+' + effect.petDef);
    if (effect.petHp) parts.push('宠物生命+' + effect.petHp);
    if (effect.petLifesteal) parts.push('宠物吸血+' + effect.petLifesteal + '%');
    if (effect.petDodge) parts.push('宠物闪避+' + effect.petDodge + '%');
    if (effect.petCritRate) parts.push('宠物暴击率+' + effect.petCritRate + '%');
    if (effect.petCritDmg) parts.push('宠物爆伤+' + effect.petCritDmg + '%');
    if (effect.petDamageReduction) parts.push('宠物减伤' + (effect.petDamageReduction * 100).toFixed(0) + '%');
    if (effect.petSplitChance != null && effect.petSplitPct != null) parts.push('宠物攻击时' + (effect.petSplitChance * 100).toFixed(0) + '%分裂，对其它目标造成宠物伤害' + (effect.petSplitPct * 100).toFixed(0) + '%');
    return parts;
}

function abyssOpenEquipAction(item, slot, invIdx) {
    abyssEquipActionTarget = item;
    abyssEquipActionSlot = slot;
    abyssEquipActionInvIdx = invIdx;
    var html = '<div style="color:' + (ABYSS_QUALITY_COLOR[item.quality] || '#fff') + '">' + item.name + '</div>';
    var equipLv = item.equipLevel != null ? item.equipLevel : (item.level || 0);
    var enhanceLv = item.equipLevel != null ? (item.level || 0) : 0;
    var hasEnchant = item.enchant && (item.enchant === true || (typeof item.enchant === 'object' && (item.enchant.statMult || item.enchant.skillMult || item.enchant.addedSkill)));
    html += '<div style="font-size:12px;color:#aaa">装备等级 Lv.' + equipLv + ' &nbsp; 强化+' + enhanceLv + (hasEnchant ? ' &nbsp; 附魔' : '') + '</div>';
    if (enhanceLv > 0) {
        html += '<div style="font-size:12px;color:#ff9800;margin-top:4px;">强化效果: 全属性+' + (enhanceLv * 5) + '%</div>';
    }
    var nextEnhanceCost = abyssEnhanceCostForNextLevel(enhanceLv);
    if (hasEnchant && typeof item.enchant === 'object') {
        var enc = item.enchant;
        var encLines = [];
        if (enc.statMult) encLines.push('属性+' + Math.floor((enc.statMult - 1) * 100) + '%');
        if (enc.skillMult) encLines.push('技能效果+' + Math.floor((enc.skillMult - 1) * 100) + '%');
        if (enc.addedSkill) encLines.push('附加技能: ' + enc.addedSkill.name);
        if (encLines.length) html += '<div style="font-size:12px;color:#9c27b0;margin-top:4px;">附魔效果: ' + encLines.join(' | ') + '</div>';
    } else if (item.enchant === true) {
        html += '<div style="font-size:12px;color:#9c27b0;margin-top:4px;">附魔效果: 属性+20%(旧)</div>';
    }
    var s = item.stats || {};
    var baseLevelMult = 1 + equipLv * 0.2;
    var enhanceMult = 1 + enhanceLv * 0.05;
    var dispStatMult = (item.enchant && typeof item.enchant === 'object' && item.enchant.statMult) ? item.enchant.statMult : (item.enchant === true ? 1.2 : 1);
    var totalMult = baseLevelMult * enhanceMult * dispStatMult;
    html += '<div style="font-size:12px;color:#ccc;margin-top:6px;">总属性: ';
    if (s.hp) html += ' 生命+' + Math.floor((s.hp || 0) * totalMult);
    if (s.atk) html += ' 攻击+' + Math.floor((s.atk || 0) * totalMult);
    if (s.def) html += ' 防御+' + Math.floor((s.def || 0) * totalMult);
    if (s.critRate) html += ' 暴击+' + ((s.critRate || 0) * totalMult).toFixed(1) + '%';
    if (s.critDmg) html += ' 爆伤+' + ((s.critDmg || 0) * totalMult).toFixed(0) + '%';
    if (s.skillDmg) html += ' 技能伤害+' + Math.floor((s.skillDmg || 0) * totalMult) + '%';
    if (s.str) html += ' 力量+' + Math.floor((s.str || 0) * totalMult);
    if (s.agi) html += ' 敏捷+' + Math.floor((s.agi || 0) * totalMult);
    if (s.int) html += ' 智力+' + Math.floor((s.int || 0) * totalMult);
    if (s.sta) html += ' 体力+' + Math.floor((s.sta || 0) * totalMult);
    html += '</div>';
    var elParts = [];
    for (var ei = 0; ei < ABYSS_ELEMENTS.length; ei++) {
        var el = ABYSS_ELEMENTS[ei];
        var elAtk = (s[el + 'Atk'] || 0) * totalMult;
        var elRes = (s[el + 'Res'] || 0) * totalMult;
        if (elAtk > 0 || elRes > 0) elParts.push(ABYSS_ELEMENT_NAMES[el] + '攻' + Math.floor(elAtk) + ' 抗' + Math.floor(elRes) + '%');
    }
    if (elParts.length) html += '<div style="font-size:12px;color:#ffd700;margin-top:4px;">五行: ' + elParts.join(' | ') + '</div>';
    if (item.equipSkill) {
        html += '<div style="color:#b388ff;margin-top:6px;">装备技能: ' + item.equipSkill.name + '</div>';
        var eff = item.equipSkill.effect;
        if (!eff && item.equipSkill.id) {
            var sk = ABYSS_EQUIP_SKILLS.find(function(s) { return s.id === item.equipSkill.id; });
            if (sk && sk.effect) eff = sk.effect;
        }
        var effDesc = abyssEquipSkillEffectDesc(eff);
        if (effDesc.length) html += '<div style="font-size:12px;color:#ce93d8;margin-top:2px;margin-left:8px;">效果: ' + effDesc.join('；') + '</div>';
    }
    var runLevel = Math.max(1, Math.floor((abyssRun.exp || 0) / 100));
    var upgradeStone = abyssRun.materials.upgradeStone || 0;
    html += '<div style="font-size:12px;color:#00bcd4;margin-top:6px;">升级: 消耗1个升级石，装备等级不可超过当前等级(' + runLevel + '级)</div>';
    document.getElementById('abyssEquipActionDetail').innerHTML = html;
    var runeGemBlock = document.getElementById('abyssEquipRuneGemBlock');
    if (runeGemBlock) {
        var eq = item;
        eq.runes = eq.runes || [];
        eq.gems = eq.gems || [];
        var rgHtml = '<div style="color:#b388ff;margin-bottom:6px;">符文槽(' + eq.runes.length + '/' + ABYSS_MAX_RUNE_SLOTS + '): </div>';
        for (var rsi = 0; rsi < eq.runes.length; rsi++) {
            var rid = eq.runes[rsi];
            var rname = rid ? (getAbyssRuneById(rid) || {}).name || rid : '空';
            rgHtml += '<span style="margin-right:8px;">' + (rsi + 1) + '.' + rname + '</span>';
            if (rid) rgHtml += '<button type="button" onclick="abyssEquipUnsocketRune(' + rsi + ')" style="background:#555;color:#fff;border:none;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:11px;margin-right:8px;">取下</button>';
        }
        if (eq.runes.length < ABYSS_MAX_RUNE_SLOTS && (abyssRun.materials.runeSlotOpener || 0) >= 1) {
            rgHtml += '<button type="button" onclick="abyssEquipUseRuneOpener()" style="background:#7b1fa2;color:#fff;border:none;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:11px;margin-left:6px;">使用符文开孔器</button>';
        }
        rgHtml += '<div style="color:#ffd700;margin:8px 0 4px 0;">宝石槽(' + eq.gems.length + '/' + ABYSS_MAX_GEM_SLOTS + '): </div>';
        for (var gsi = 0; gsi < eq.gems.length; gsi++) {
            var gid = eq.gems[gsi];
            var gname = gid ? (getAbyssGemById(gid) || {}).name || gid : '空';
            rgHtml += '<span style="margin-right:8px;">' + (gsi + 1) + '.' + gname + '</span>';
            if (gid) rgHtml += '<button type="button" onclick="abyssEquipUnsocketGem(' + gsi + ')" style="background:#555;color:#fff;border:none;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:11px;margin-right:8px;">取下</button>';
        }
        if (eq.gems.length < ABYSS_MAX_GEM_SLOTS && (abyssRun.materials.gemSlotOpener || 0) >= 1) {
            rgHtml += '<button type="button" onclick="abyssEquipUseGemOpener()" style="background:#e65100;color:#fff;border:none;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:11px;margin-left:6px;">使用宝石开孔器</button>';
        }
        var runeInv = abyssRun.runeInventory || [];
        var runeCounts = {};
        for (var rci = 0; rci < runeInv.length; rci++) { var id = runeInv[rci]; runeCounts[id] = (runeCounts[id] || 0) + 1; }
        var firstEmptyRune = -1;
        for (var re = 0; re < eq.runes.length; re++) { if (!eq.runes[re]) { firstEmptyRune = re; break; } }
        if (firstEmptyRune >= 0 && Object.keys(runeCounts).length > 0) {
            rgHtml += '<div style="margin-top:8px;color:#ce93d8;">镶嵌符文: ';
            for (var rid in runeCounts) {
                var rn = (getAbyssRuneById(rid) || {}).name || rid;
                rgHtml += '<button type="button" onclick="abyssEquipSocketRune(\'' + rid.replace(/'/g, "\\'") + '\')" style="background:#6a0dad;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:11px;margin:2px;">' + rn + '(' + runeCounts[rid] + ')</button>';
            }
            rgHtml += '</div>';
        }
        var gemInv = abyssRun.gemInventory || [];
        var gemCounts = {};
        for (var gci = 0; gci < gemInv.length; gci++) { var id = gemInv[gci]; gemCounts[id] = (gemCounts[id] || 0) + 1; }
        var firstEmptyGem = -1;
        for (var ge = 0; ge < eq.gems.length; ge++) { if (!eq.gems[ge]) { firstEmptyGem = ge; break; } }
        if (firstEmptyGem >= 0 && Object.keys(gemCounts).length > 0) {
            rgHtml += '<div style="margin-top:6px;color:#ffd700;">镶嵌宝石: ';
            for (var gid in gemCounts) {
                var gn = (getAbyssGemById(gid) || {}).name || gid;
                rgHtml += '<button type="button" onclick="abyssEquipSocketGem(\'' + gid.replace(/'/g, "\\'") + '\')" style="background:#b8860b;color:#000;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:11px;margin:2px;">' + gn + '(' + gemCounts[gid] + ')</button>';
            }
            rgHtml += '</div>';
        }
        runeGemBlock.innerHTML = rgHtml;
    }
    var ueb = document.getElementById('abyssEquipUnequipBtn');
    if (ueb) ueb.textContent = (invIdx !== null && invIdx !== undefined) ? '装备' : '卸下';
    var upgradeBtn = document.getElementById('abyssEquipUpgradeBtn');
    if (upgradeBtn) upgradeBtn.disabled = (equipLv >= runLevel || upgradeStone < 1);
    var enhanceBtn = document.getElementById('abyssEquipEnhanceBtn');
    if (enhanceBtn) {
        enhanceBtn.textContent = '强化(消耗' + nextEnhanceCost + '个)';
        enhanceBtn.disabled = (abyssRun.materials.enhanceStone || 0) < nextEnhanceCost;
    }
    document.getElementById('abyssEquipActionOverlay').style.display = 'block';
    document.getElementById('abyssEquipActionUI').style.display = 'block';
}

function closeAbyssEquipAction() {
    document.getElementById('abyssEquipActionOverlay').style.display = 'none';
    document.getElementById('abyssEquipActionUI').style.display = 'none';
    abyssEquipActionTarget = null;
    abyssEquipActionSlot = null;
    abyssEquipActionInvIdx = null;
}

function abyssEquipUpgrade() {
    if (!abyssEquipActionTarget || (abyssRun.materials.upgradeStone || 0) < 1) return;
    var eq = abyssEquipActionTarget;
    var currentEquipLv = eq.equipLevel != null ? eq.equipLevel : 1;
    var runLevel = Math.max(1, Math.floor((abyssRun.exp || 0) / 100));
    if (currentEquipLv >= runLevel) return;
    abyssRun.materials.upgradeStone--;
    eq.equipLevel = currentEquipLv + 1;
    closeAbyssEquipAction();
    openAbyssEquipmentPanel();
    if (abyssRun && abyssRun.active) updateAbyssRunUI();
}

function abyssEnhanceCostForNextLevel(currentLevel) {
    return 1 + Math.floor((currentLevel || 0) / 5);
}
function abyssEnhanceStonesUsedToReachLevel(level) {
    var total = 0;
    for (var i = 0; i < (level || 0); i++) total += 1 + Math.floor(i / 5);
    return total;
}

function abyssEquipEnhance() {
    if (!abyssEquipActionTarget) return;
    var curLv = abyssEquipActionTarget.level || 0;
    var cost = abyssEnhanceCostForNextLevel(curLv);
    if ((abyssRun.materials.enhanceStone || 0) < cost) return;
    abyssRun.materials.enhanceStone -= cost;
    abyssEquipActionTarget.level = curLv + 1;
    closeAbyssEquipAction();
    openAbyssEquipmentPanel();
    if (abyssRun && abyssRun.active) updateAbyssRunUI();
}

function abyssEquipEnchant() {
    if (!abyssEquipActionTarget || abyssRun.materials.enchantBook < 1) return;
    abyssRun.materials.enchantBook--;
    var eq = abyssEquipActionTarget;
    var r = Math.random();
    var statMult;
    if (r < 0.80) statMult = 1 + 0.01 + Math.random() * 0.19;
    else if (r < 0.92) statMult = 1.2 + Math.random() * 0.2;
    else if (r < 0.97) statMult = 1.4 + Math.random() * 0.2;
    else if (r < 0.99) statMult = 1.6 + Math.random() * 0.2;
    else statMult = 1.8 + Math.random() * 0.2;
    var skillMult = null;
    var addedSkill = null;
    if (eq.equipSkill && Math.random() < 0.4) skillMult = 1 + Math.random();
    if (!eq.equipSkill && Math.random() < 0.35) {
        var sk = ABYSS_EQUIP_SKILLS[Math.floor(Math.random() * ABYSS_EQUIP_SKILLS.length)];
        addedSkill = { id: sk.id, name: sk.name, effect: JSON.parse(JSON.stringify(sk.effect)) };
    }
    eq.enchant = { statMult: statMult, skillMult: skillMult, addedSkill: addedSkill };
    closeAbyssEquipAction();
    openAbyssEquipmentPanel();
    if (abyssRun && abyssRun.active) updateAbyssRunUI();
}

function abyssEquipUnequip() {
    if (!abyssEquipActionTarget) return;
    if (abyssEquipActionSlot) {
        abyssRun.equipped[abyssEquipActionSlot] = null;
        abyssRun.inventory.push(abyssEquipActionTarget);
    } else if (abyssEquipActionInvIdx !== null) {
        var slot = abyssEquipActionTarget.slot;
        if (abyssRun.equipped[slot]) abyssRun.inventory.push(abyssRun.equipped[slot]);
        abyssRun.equipped[slot] = abyssEquipActionTarget;
        abyssRun.inventory.splice(abyssEquipActionInvIdx, 1);
    }
    closeAbyssEquipAction();
    openAbyssEquipmentPanel();
    updateAbyssRunUI();
}

function abyssEquipDismantle() {
    if (!abyssEquipActionTarget) return;
    var eq = abyssEquipActionTarget;
    var enhanceLv = eq.level || 0;
    abyssRun.materials.enhanceStone = (abyssRun.materials.enhanceStone || 0) + 1;
    if (enhanceLv > 0) {
        var used = abyssEnhanceStonesUsedToReachLevel(enhanceLv);
        abyssRun.materials.enhanceStone += Math.floor(used * 0.8);
    }
    if (abyssEquipActionSlot) abyssRun.equipped[abyssEquipActionSlot] = null;
    else if (abyssEquipActionInvIdx !== null) abyssRun.inventory.splice(abyssEquipActionInvIdx, 1);
    closeAbyssEquipAction();
    openAbyssEquipmentPanel();
    updateAbyssRunUI();
}

function abyssEquipSocketRune(runeId) {
    if (!abyssEquipActionTarget || !abyssRun || !runeId) return;
    var inv = abyssRun.runeInventory || [];
    var idx = inv.indexOf(runeId);
    if (idx < 0) return;
    var eq = abyssEquipActionTarget;
    eq.runes = eq.runes || [];
    var slot = -1;
    for (var i = 0; i < eq.runes.length; i++) { if (!eq.runes[i]) { slot = i; break; } }
    if (slot < 0) return;
    inv.splice(idx, 1);
    eq.runes = eq.runes || [];
    eq.runes[slot] = runeId;
    abyssRun.runeInventory = inv;
    var rn = (getAbyssRuneById(runeId) || {}).name || runeId;
    abyssLog('镶嵌符文【' + rn + '】');
    abyssOpenEquipAction(abyssEquipActionTarget, abyssEquipActionSlot, abyssEquipActionInvIdx);
    if (abyssRun && abyssRun.active) updateAbyssRunUI();
}

function abyssEquipSocketGem(gemId) {
    if (!abyssEquipActionTarget || !abyssRun || !gemId) return;
    var inv = abyssRun.gemInventory || [];
    var idx = inv.indexOf(gemId);
    if (idx < 0) return;
    var eq = abyssEquipActionTarget;
    eq.gems = eq.gems || [null, null, null];
    var slot = -1;
    for (var i = 0; i < eq.gems.length; i++) { if (!eq.gems[i]) { slot = i; break; } }
    if (slot < 0) return;
    inv.splice(idx, 1);
    eq.gems = eq.gems || [];
    eq.gems[slot] = gemId;
    abyssRun.gemInventory = inv;
    var gn = (getAbyssGemById(gemId) || {}).name || gemId;
    abyssLog('镶嵌宝石【' + gn + '】');
    abyssOpenEquipAction(abyssEquipActionTarget, abyssEquipActionSlot, abyssEquipActionInvIdx);
    if (abyssRun && abyssRun.active) updateAbyssRunUI();
}

function abyssEquipUnsocketRune(slotIndex) {
    if (!abyssEquipActionTarget || !abyssRun || slotIndex < 0) return;
    var eq = abyssEquipActionTarget;
    eq.runes = eq.runes || [];
    var runeId = eq.runes[slotIndex];
    if (!runeId) return;
    eq.runes[slotIndex] = null;
    abyssRun.runeInventory = (abyssRun.runeInventory || []).slice();
    abyssRun.runeInventory.push(runeId);
    var rn = (getAbyssRuneById(runeId) || {}).name || runeId;
    abyssLog('取下符文【' + rn + '】');
    abyssOpenEquipAction(abyssEquipActionTarget, abyssEquipActionSlot, abyssEquipActionInvIdx);
    if (abyssRun && abyssRun.active) updateAbyssRunUI();
}

function abyssEquipUnsocketGem(slotIndex) {
    if (!abyssEquipActionTarget || !abyssRun || slotIndex < 0) return;
    var eq = abyssEquipActionTarget;
    eq.gems = eq.gems || [];
    var gemId = eq.gems[slotIndex];
    if (!gemId) return;
    eq.gems[slotIndex] = null;
    abyssRun.gemInventory = (abyssRun.gemInventory || []).slice();
    abyssRun.gemInventory.push(gemId);
    var gn = (getAbyssGemById(gemId) || {}).name || gemId;
    abyssLog('取下宝石【' + gn + '】');
    abyssOpenEquipAction(abyssEquipActionTarget, abyssEquipActionSlot, abyssEquipActionInvIdx);
    if (abyssRun && abyssRun.active) updateAbyssRunUI();
}

function abyssEquipUseRuneOpener() {
    if (!abyssEquipActionTarget || !abyssRun) return;
    var eq = abyssEquipActionTarget;
    eq.runes = eq.runes || [];
    if (eq.runes.length >= ABYSS_MAX_RUNE_SLOTS) return;
    if ((abyssRun.materials.runeSlotOpener || 0) < 1) return;
    abyssRun.materials.runeSlotOpener--;
    eq.runes.push(null);
    abyssLog('使用符文开孔器，当前符文槽 ' + eq.runes.length + '/' + ABYSS_MAX_RUNE_SLOTS);
    abyssOpenEquipAction(abyssEquipActionTarget, abyssEquipActionSlot, abyssEquipActionInvIdx);
    if (abyssRun && abyssRun.active) updateAbyssRunUI();
}

function abyssEquipUseGemOpener() {
    if (!abyssEquipActionTarget || !abyssRun) return;
    var eq = abyssEquipActionTarget;
    eq.gems = eq.gems || [];
    if (eq.gems.length >= ABYSS_MAX_GEM_SLOTS) return;
    if ((abyssRun.materials.gemSlotOpener || 0) < 1) return;
    abyssRun.materials.gemSlotOpener--;
    eq.gems.push(null);
    abyssLog('使用宝石开孔器，当前宝石槽 ' + eq.gems.length + '/' + ABYSS_MAX_GEM_SLOTS);
    abyssOpenEquipAction(abyssEquipActionTarget, abyssEquipActionSlot, abyssEquipActionInvIdx);
    if (abyssRun && abyssRun.active) updateAbyssRunUI();
}

function useAbyssPotion() {
    if (!abyssRun || !abyssRun.active || (abyssRun.materials.potion || 0) < 1) return;
    if (abyssRun.trialId === 'noPotion' && abyssRun.trialRoundsLeft > 0) { abyssLog('试炼中：禁止使用药剂'); return; }
    abyssRun.materials.potion--;
    var stats = abyssCalcPlayerStats();
    if (stats) {
        var heal = Math.floor(stats.maxHp * 0.2);
        abyssRun.player.hp = Math.min(abyssRun.player.hp + heal, stats.maxHp);
        abyssLog('使用生命药剂，恢复 ' + formatNumber(heal) + ' 生命');
        // 宠物同步回血（与玩家相同比例：20% 最大生命）
        var pets = abyssRun.pets || [];
        for (var i = 0; i < pets.length; i++) {
            var pet = pets[i];
            if (pet.hp !== null && pet.hp <= 0) continue; // 已死亡不参与回血
            var pstats = abyssCalcPetStats(pet);
            if (!pstats) continue;
            var curHp = pet.hp === null ? pstats.maxHp : pet.hp;
            var petHeal = Math.floor(pstats.maxHp * 0.2);
            var newHp = Math.min(curHp + petHeal, pstats.maxHp);
            pet.hp = newHp;
            if (petHeal > 0) abyssLog('宠物【' + (pet.name || '') + '】恢复 ' + formatNumber(petHeal) + ' 生命');
        }
        updateAbyssRunUI();
    }
}

function openAbyssExclusiveShop() {
    var at = getAbyssTower();
    document.getElementById('abyssExclusiveShopCurrency').textContent = at.exclusiveCurrency || 0;
    var startGearCount = Math.min(20, at.startGearCount || 0);
    var startGearPurchases = at.startGearPurchaseCount || 0;
    var startGearCost = 80 + startGearPurchases * 120;
    var startPetCount = Math.min(5, at.startPetCount || 0);
    var startPetCosts = [200, 1000, 5000, 10000, 20000];
    var startPetCost = startPetCount < 5 ? startPetCosts[startPetCount] : 20000;
    var deployedSlotsPurchases = Math.min(3, at.deployedSlotsPurchases || 0);
    var deployedSlotsCosts = [2000, 20000, 200000];
    var deployedSlotsCost = deployedSlotsPurchases < 3 ? deployedSlotsCosts[deployedSlotsPurchases] : 200000;
    var items = [
        { id: 'startGear', name: '开局装备+1件', cost: startGearCost, cur: startGearCount, max: 20, special: 'startGear' },
        { id: 'startGold', name: '初始闯关金币+2', cost: 100, cur: (at.startGoldBonus || 0), max: null, special: 'startGold' },
        { id: 'startPet', name: '初始获得宠物1只', cost: startPetCost, cur: startPetCount, max: 5, special: 'startPet' },
        { id: 'deployedSlots', name: '出场宠物数量+1', cost: deployedSlotsCost, cur: deployedSlotsPurchases, max: 3, special: 'deployedSlots' },
        { id: 'hp', name: '生命+50', cost: 100, cur: (at.permanentBonuses && at.permanentBonuses.hp) || 0 },
        { id: 'atk', name: '攻击+10', cost: 100, cur: (at.permanentBonuses && at.permanentBonuses.atk) || 0 },
        { id: 'def', name: '防御+5', cost: 80, cur: (at.permanentBonuses && at.permanentBonuses.def) || 0 },
        { id: 'critRate', name: '暴击+0.5%', cost: 280, cur: (at.permanentBonuses && at.permanentBonuses.critRate) || 0 },
        { id: 'critDmg', name: '爆伤+0.5%', cost: 350, cur: (at.permanentBonuses && at.permanentBonuses.critDmg) || 0 },
        { id: 'dodge', name: '闪避+0.5%', cost: 350, cur: (at.permanentBonuses && at.permanentBonuses.dodge) || 0 },
        { id: 'lifesteal', name: '吸血+0.5%', cost: 320, cur: (at.permanentBonuses && at.permanentBonuses.lifesteal) || 0 },
        { id: 'combo', name: '连击+0.5%', cost: 380, cur: (at.permanentBonuses && at.permanentBonuses.combo) || 0 }
    ];
    var el = document.getElementById('abyssExclusiveShopContent');
    el.innerHTML = '';
    items.forEach(function(it) {
        var div = document.createElement('div');
        div.style.background = 'rgba(0,0,0,0.4)';
        div.style.padding = '12px';
        div.style.borderRadius = '8px';
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        div.style.alignItems = 'center';
        var curText = it.special === 'startGear' ? ('当前' + it.cur + '/' + it.max + '件') : it.special === 'startGold' ? ('已购+' + (it.cur * 2) + '金币') : it.special === 'startPet' ? ('当前' + it.cur + '/' + it.max + '只') : it.special === 'deployedSlots' ? ('可出战' + (1 + it.cur) + '只') : ('已购+' + it.cur);
        div.innerHTML = '<span>' + it.name + ' (' + curText + ')</span><span>深渊币 ' + it.cost + '</span><button id="abyssBuy_' + it.id + '">购买</button>';
        var btn = div.querySelector('button');
        if (it.id === 'startGear') {
            btn.onclick = (function(cost) {
                return function() {
                    var at2 = getAbyssTower();
                    if ((at2.startGearCount || 0) >= 20) return;
                    if ((at2.exclusiveCurrency || 0) >= cost) {
                        at2.exclusiveCurrency -= cost;
                        at2.startGearCount = Math.min(20, (at2.startGearCount || 0) + 1);
                        at2.startGearPurchaseCount = (at2.startGearPurchaseCount || 0) + 1;
                        openAbyssExclusiveShop();
                        refreshAbyssTowerUI();
                    }
                };
            })(it.cost);
        } else if (it.id === 'startGold') {
            btn.onclick = (function(cost) {
                return function() {
                    var at2 = getAbyssTower();
                    if ((at2.exclusiveCurrency || 0) >= cost) {
                        at2.exclusiveCurrency -= cost;
                        at2.startGoldBonus = (at2.startGoldBonus || 0) + 1;
                        openAbyssExclusiveShop();
                        refreshAbyssTowerUI();
                    }
                };
            })(it.cost);
        } else if (it.id === 'startPet') {
            btn.onclick = (function(cost) {
                return function() {
                    var at2 = getAbyssTower();
                    if ((at2.startPetCount || 0) >= 5) return;
                    if ((at2.exclusiveCurrency || 0) >= cost) {
                        at2.exclusiveCurrency -= cost;
                        at2.startPetCount = (at2.startPetCount || 0) + 1;
                        openAbyssExclusiveShop();
                        refreshAbyssTowerUI();
                    }
                };
            })(it.cost);
        } else if (it.id === 'deployedSlots') {
            btn.onclick = (function(cost) {
                return function() {
                    var at2 = getAbyssTower();
                    if ((at2.deployedSlotsPurchases || 0) >= 3) return;
                    if ((at2.exclusiveCurrency || 0) >= cost) {
                        at2.exclusiveCurrency -= cost;
                        at2.deployedSlotsPurchases = (at2.deployedSlotsPurchases || 0) + 1;
                        openAbyssExclusiveShop();
                        refreshAbyssTowerUI();
                    }
                };
            })(it.cost);
        } else {
            btn.onclick = (function(id, cost) {
                return function() {
                    var at2 = getAbyssTower();
                    if ((at2.exclusiveCurrency || 0) >= cost) {
                        at2.exclusiveCurrency -= cost;
                        if (!at2.permanentBonuses) at2.permanentBonuses = {};
                        at2.permanentBonuses[id] = (at2.permanentBonuses[id] || 0) + (id === 'hp' ? 50 : id === 'atk' ? 10 : id === 'def' ? 5 : id === 'critRate' ? 0.5 : id === 'critDmg' ? 0.5 : id === 'dodge' ? 0.5 : id === 'lifesteal' ? 0.5 : id === 'combo' ? 0.5 : 1);
                        openAbyssExclusiveShop();
                        refreshAbyssTowerUI();
                    }
                };
            })(it.id, it.cost);
        }
        if (it.id === 'startGear' && (at.startGearCount || 0) >= 20) btn.disabled = true;
        if (it.id === 'startPet' && (at.startPetCount || 0) >= 5) btn.disabled = true;
        if (it.id === 'deployedSlots' && (at.deployedSlotsPurchases || 0) >= 3) btn.disabled = true;
        el.appendChild(div);
    });
    document.getElementById('abyssExclusiveOverlay').style.display = 'block';
    document.getElementById('abyssExclusiveUI').style.display = 'block';
}

var abyssExclusiveOpenedFromFail = false;

function abyssOpenExclusiveShopFromFail() {
    abyssExclusiveOpenedFromFail = true;
    document.getElementById('abyssFailOverlay').style.display = 'none';
    document.getElementById('abyssFailUI').style.display = 'none';
    openAbyssExclusiveShop();
}

function closeAbyssExclusiveShop() {
    document.getElementById('abyssExclusiveOverlay').style.display = 'none';
    document.getElementById('abyssExclusiveUI').style.display = 'none';
    if (abyssExclusiveOpenedFromFail) {
        abyssExclusiveOpenedFromFail = false;
        document.getElementById('abyssFailOverlay').style.display = 'block';
        document.getElementById('abyssFailUI').style.display = 'block';
    }
}

function openAbyssVault() {
    var at = getAbyssTower();
    var vault = at.abyssVault || {};
    var el = document.getElementById('abyssVaultContent');
    el.innerHTML = '';
    ABYSS_VAULT_TREASURES.forEach(function(t) {
        var count = vault[t.id] || 0;
        if (count <= 0) return;
        var div = document.createElement('div');
        div.style.background = 'rgba(179,136,255,0.25)';
        div.style.padding = '8px 12px';
        div.style.borderRadius = '6px';
        div.style.display = 'flex';
        div.style.justifyContent = 'space-between';
        div.style.alignItems = 'center';
        div.style.border = '1px solid #b388ff';
        var eff = t.effect;
        var effText = eff.type === 'atkVaultPct' ? (eff.value + '%攻击') : eff.type === 'hpVaultPct' ? (eff.value + '%生命') : eff.type === 'defVaultPct' ? (eff.value + '%防御') : eff.type === 'critDmgVaultPct' ? (eff.value + '%爆伤') : eff.type === 'atkVaultFlat' ? ('+' + eff.value + '攻') : eff.type === 'defVaultFlat' ? ('+' + eff.value + '防') : eff.type === 'hpVaultFlat' ? ('+' + eff.value + '血') : eff.type === 'petAtkVaultPct' ? (eff.value + '%宠攻') : eff.type === 'petHpVaultPct' ? (eff.value + '%宠血') : eff.type === 'petDefVaultPct' ? (eff.value + '%宠防') : eff.type === 'petAtkVaultFlat' ? ('+' + eff.value + '宠攻') : eff.type === 'petDefVaultFlat' ? ('+' + eff.value + '宠防') : eff.type === 'petHpVaultFlat' ? ('+' + eff.value + '宠血') : '';
        div.innerHTML = '<span><strong style="color:#e0e0e0">' + t.name + '+</strong> <span style="color:#b388ff;font-size:12px;">' + effText + '</span></span><span style="color:#ffd700;font-weight:bold;">x' + count + '</span>';
        el.appendChild(div);
    });
    if (el.children.length === 0) {
        var emptyDiv = document.createElement('div');
        emptyDiv.style.color = '#888';
        emptyDiv.style.textAlign = 'center';
        emptyDiv.style.padding = '20px';
        emptyDiv.textContent = '暂无宝物，击败BOSS层有2%概率掉落';
        el.appendChild(emptyDiv);
    }
    document.getElementById('abyssVaultOverlay').style.display = 'block';
    document.getElementById('abyssVaultUI').style.display = 'block';
}

function closeAbyssVault() {
    document.getElementById('abyssVaultOverlay').style.display = 'none';
    document.getElementById('abyssVaultUI').style.display = 'none';
}

function abyssShowTreasureDropPopup(name, effText) {
    document.getElementById('abyssTreasureDropName').textContent = '【' + name + '】';
    document.getElementById('abyssTreasureDropEff').textContent = '永久' + effText + '！';
    document.getElementById('abyssTreasureDropOverlay').style.display = 'block';
    document.getElementById('abyssTreasureDropUI').style.display = 'block';
}
function closeAbyssTreasureDropPopup() {
    document.getElementById('abyssTreasureDropOverlay').style.display = 'none';
    document.getElementById('abyssTreasureDropUI').style.display = 'none';
}

function abyssEscapeAndClaim() {
    if (!abyssRun || !abyssRun.active) return;
    abyssLog('选择逃跑，结算当前层深渊币。');
    abyssOnPlayerDeath();
}

function abyssOnPlayerDeath() {
    abyssRun.active = false;
    var at = getAbyssTower();
    if (abyssRun.floor > (at.bestFloor || 0)) at.bestFloor = abyssRun.floor;
    var reward = Math.floor(abyssRun.floor * 4);
    at.exclusiveCurrency = (at.exclusiveCurrency || 0) + reward;
    abyssLog('挑战结束。获得深渊币 ' + reward);
    document.getElementById('abyssFailFloor').textContent = abyssRun.floor;
    document.getElementById('abyssFailCurrency').textContent = reward;
    document.getElementById('abyssFailOverlay').style.display = 'block';
    document.getElementById('abyssFailUI').style.display = 'block';
    refreshAbyssTowerUI();
}

function closeAbyssFailAndRestart() {
    document.getElementById('abyssFailOverlay').style.display = 'none';
    document.getElementById('abyssFailUI').style.display = 'none';
    document.getElementById('abyssStartPanel').style.display = 'block';
    document.getElementById('abyssRunPanel').style.display = 'none';
    abyssRun = null;
    refreshAbyssTowerUI();
}

function saveAbyssTowerProgress() {
    var at = getAbyssTower();
    at.bestFloor = at.bestFloor || 0;
    at.exclusiveCurrency = at.exclusiveCurrency || 0;
    if (!at.permanentBonuses) at.permanentBonuses = {};
}

 // 世界BOSS系统数据
        const worldBossData = {
            summonCount: 1,
            lastSummonTime: Date.now(),
            isBossActive: false,
            bossEndTime: 0,
            bossHealth: 0,
            bossMaxHealth: 0,
            bossName: "",
            bossWorld: "",
            bossStars: 0,
            playerDamage: 0,
            isAutoAttacking: false,
            attackInterval: null,
            virtualPlayers: [],
            rankings: [],
            battleLog: [],
            lastSummonTime: Date.now(),
    nextRecoveryTime: 0, // 新增：下次恢复时间
        };

        // BOSS名字池
        const bossNames = [
            "灭世魔尊·阎罗",
            "永恒天帝·太初",
            "混沌主宰·虚无",
            "九幽冥王·黄泉",
            "万界神皇·凌霄",
            "太古龙帝·烛阴",
            "星空吞噬者·饕餮",
            "时间掌控者·岁月",
            "命运编织者·天机",
            "元素始祖·创世"
        ];

        // 世界名字池
        const worldNames = [
            "玄天大陆",
            "九幽冥界",
            "太虚神境",
            "洪荒古界",
            "星辰海域",
            "万界战场",
            "永恒神域",
            "混沌虚空",
            "天元世界",
            "轮回之境"
        ];

        // 虚拟玩家名字池
        const virtualPlayerNames = [
            "萧炎", "林动", "牧尘", "叶凡", "石昊",
            "楚风", "秦羽", "方源", "韩立", "孟浩",
            "苏铭", "王林", "白小纯", "李七夜", "陈平安",
            "宁缺", "许七安", "陆鸣", "周元", "江离",
            "罗峰", "洪易", "纪宁", "滕青山", "唐三",
            "霍雨浩", "唐舞麟", "蓝轩宇", "古月娜", "唐昊", "茶茶", "闫闫", "萧云凡", "叶玄霄", "林昊辰", "楚星河", "秦无痕", "苏九夜", "陆天行", "沈青岚", "顾长歌", "洛千尘", "云清瑶", "柳如烟", "白芷晴", "慕雨柔", "苏灵儿", "凌寒霜", "楚月璃", "花未央", "冷轻衣", "夜琉璃", "夏知微", "苏晚晴", "林浅夏", "乔曦", "李二狗", "张全蛋", "赵日天", "王富贵"
        ];

        // 初始化世界BOSS系统
            function initWorldBossSystem() {
    // 计算离线时间增加的召唤次数
    const currentTime = Date.now();
    const timePassed = currentTime - (worldBossData.lastSummonTime || currentTime);
    const hoursPassed = Math.floor(timePassed / (60 * 60 * 1000));
    
    if (hoursPassed > 0) {
        worldBossData.summonCount = Math.min(worldBossData.summonCount + hoursPassed, 10);
        worldBossData.lastSummonTime = currentTime;
        saveWorldBossData();
    }
    
    // 计算下次恢复时间
    calculateNextRecoveryTime();
    
    // 启动倒计时更新
    updateSummonCountdown();
    
    updateBossUI();
}

// 计算下次恢复时间
function calculateNextRecoveryTime() {
    if (worldBossData.summonCount >= 10) {
        worldBossData.nextRecoveryTime = 0;
        return;
    }
    
    // 距离下次恢复的时间 = 1小时 - (当前时间与上次恢复的时间差 % 1小时)
    const oneHour = 60 * 60 * 1000;
    const timeSinceLastRecovery = Date.now() - worldBossData.lastSummonTime;
    const timeToNextRecovery = oneHour - (timeSinceLastRecovery % oneHour);
    
    worldBossData.nextRecoveryTime = Date.now() + timeToNextRecovery;
}

// 更新召唤次数倒计时显示
function updateSummonCountdown() {
    const countdownElement = document.getElementById('summonCountdown');
    if (!countdownElement) return;
    
    if (worldBossData.summonCount >= 10) {
        countdownElement.textContent = "已达上限";
        setTimeout(updateSummonCountdown, 1000);
        return;
    }
    
    const now = Date.now();
    const timeLeft = Math.max(0, worldBossData.nextRecoveryTime - now);
    
    if (timeLeft === 0 && worldBossData.summonCount < 10) {
        // 强制更新上次召唤时间为当前时间
        worldBossData.lastSummonTime = now;
        worldBossData.summonCount++;
        calculateNextRecoveryTime(); // 重新计算下次恢复时间（1小时后）
        saveWorldBossData();
        document.getElementById('bossSummonCount').textContent = worldBossData.summonCount;
        console.log("恢复次数+1，下次恢复时间：", new Date(worldBossData.nextRecoveryTime).toLocaleTimeString());
    }
    
    // 格式化时间显示
    const hours = Math.floor(timeLeft / (60 * 60 * 1000));
    const minutes = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
    const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);
    countdownElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    setTimeout(updateSummonCountdown, 1000);
}


        // 保存世界BOSS数据
        function saveWorldBossData() {
    worldBossData.lastUpdate = Date.now();
    localStorage.setItem('worldBossSave', JSON.stringify(worldBossData));
}

        // 加载世界BOSS数据
        // 加载世界BOSS数据
function loadWorldBossData() {
    const save = JSON.parse(localStorage.getItem('worldBossSave'));
    if (save) {
        Object.assign(worldBossData, save);
        
        // 如果BOSS活动正在进行中，计算离线期间的伤害
        if (worldBossData.isBossActive) {
            const currentTime = Date.now();
            
            // 检查BOSS是否已超时
            if (currentTime > worldBossData.bossEndTime) {
                endBossFight(false);
            } else {
                // 计算离线时间（秒）
                const offlineSeconds = Math.floor((currentTime - worldBossData.lastUpdate) / 1000);
                
                if (offlineSeconds > 0) {
                    // 1. 计算虚拟玩家在离线期间造成的总伤害（已有逻辑）
                    const virtualDamagePerSecond = worldBossData.virtualPlayers.reduce((sum, player) => {
                        const avgDamage = player.attack * player.multiAttack * 
                                        (1 + (player.critRate * (player.critDamage - 1)));
                        return sum + avgDamage;
                    }, 0);
                    const totalVirtualDamage = Math.floor(virtualDamagePerSecond * offlineSeconds);
                    worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - totalVirtualDamage);
                    const damagePerPlayer = Math.floor(totalVirtualDamage / worldBossData.virtualPlayers.length);
                    worldBossData.virtualPlayers.forEach(player => {
                        player.damage += damagePerPlayer;
                    });
                    addBossBattleLog(`离线期间虚拟玩家共造成 ${formatNumber(totalVirtualDamage)} 点伤害`);
                    
                    // 2. 新增：计算真实玩家的离线自动攻击伤害
                    if (worldBossData.isAutoAttacking) { // 仅当开启自动攻击时计算
                        // 玩家每秒攻击11次（与startAutoAttack一致）
                        const attacksPerSecond = 11;
                        const totalAttacks = offlineSeconds * attacksPerSecond;
                        
                        // 计算单次攻击的平均伤害（参考calculatePlayerDamage逻辑）
                        const playerData = {
                            attack: player.bossBattleSnapshot?.playerAttack || player.battle.playerAttack,
    multiAttack: player.bossBattleSnapshot?.playerMultiAttack || player.battle.playerMultiAttack,
    critRate: player.bossBattleSnapshot?.playerCritRate || player.battle.playerCritRate,
    critDamage: player.bossBattleSnapshot?.playerCritDamage || player.battle.playerCritDamage
                        };
                        // 计算单次攻击的平均伤害（避免循环计算totalAttacks次，优化性能）
                        const singleAttackAvgDamage = playerData.attack * playerData.multiAttack * 
                                                    (1 + (playerData.critRate * (playerData.critDamage - 1)));
                        const totalPlayerDamage = Math.floor(singleAttackAvgDamage * totalAttacks);
                        
                        // 应用玩家离线伤害
                        worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - totalPlayerDamage);
                        worldBossData.playerDamage += totalPlayerDamage;
                        addBossBattleLog(`离线期间你通过自动攻击造成 ${formatNumber(totalPlayerDamage)} 点伤害`);
                    }
                    
                    // 检查BOSS是否被击败
                    if (worldBossData.bossHealth <= 0) {
                        endBossFight(true);
                        return;
                    }
                }
            }
        }
    }
    
    // 重新开始虚拟玩家攻击
    startVirtualPlayerAttacks();
    
    // 更新最后更新时间
    worldBossData.lastUpdate = Date.now();
    initWorldBossSystem();
}

        // 切换世界BOSS界面
        function toggleWorldBossUI() {
           // 检查转生次数是否达到50次
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能开启世界BOSS系统！");
        return;
    }
            const ui = document.getElementById('worldBossUI');
            const overlay = document.getElementById('bossOverlay');
            
            if (ui.style.display === 'block') {
                ui.style.display = 'none';
                overlay.style.display = 'none';
                
               
            } else {
                ui.style.display = 'block';
                overlay.style.display = 'block';
                updateBossUI();
            }
        }

        // 更新BOSS界面
        function updateBossUI() {
            document.getElementById('bossSummonCount').textContent = worldBossData.summonCount;
    if (worldBossData.isBossActive && player.bossBattleSnapshot) {
        document.getElementById('playerBossAttack').textContent = formatNumber(player.bossBattleSnapshot.playerAttack);
        document.getElementById('playerBossMultiAttack').textContent = player.bossBattleSnapshot.playerMultiAttack;
        document.getElementById('playerBossCritRate').textContent = (player.bossBattleSnapshot.playerCritRate * 100).toFixed(1) + '%';
        document.getElementById('playerBossCritDamage').textContent = ((player.bossBattleSnapshot.playerCritDamage - 1) * 100).toFixed(1) + '%';
    } else {
        // 显示实时属性
        document.getElementById('playerBossAttack').textContent = formatNumber(player.battle.playerAttack);
        document.getElementById('playerBossMultiAttack').textContent = player.battle.playerMultiAttack;
        document.getElementById('playerBossCritRate').textContent = (player.battle.playerCritRate * 100).toFixed(1) + '%';
        document.getElementById('playerBossCritDamage').textContent = ((player.battle.playerCritDamage - 1) * 100).toFixed(1) + '%';
    }
            document.getElementById('playerBossDamage').textContent = formatNumber(worldBossData.playerDamage);
       if (!worldBossData.isBossActive) {
        document.getElementById('playerBossRank').textContent = "未开始";
    } else {
        // 触发一次排行更新
        updateRankings();
    }
            // 新增：检查BOSS是否超时（无论是否在战斗中，强制判断时间）
    if (worldBossData.isBossActive && Date.now() >= worldBossData.bossEndTime) {
        endBossFight(false); // 强制结束战斗
        return; // 结束后无需继续更新UI
    }
          if (!worldBossData.isBossActive) {
        document.getElementById('playerBossRank').textContent = "未开始";
    } else {
        // 触发一次排行更新
        updateRankings();
    }
            // 更新BOSS状态
            if (worldBossData.isBossActive) {
                document.getElementById('bossName').textContent = worldBossData.bossName;
                document.getElementById('bossWorld').textContent = worldBossData.bossWorld;
                document.getElementById('bossStars').textContent = '★'.repeat(worldBossData.bossStars);
                
                const healthPercent = (worldBossData.bossHealth / worldBossData.bossMaxHealth) * 100;
                document.getElementById('bossHealthFill').style.width = healthPercent + '%';
                document.getElementById('bossHealthText').textContent = 
                    formatNumber(worldBossData.bossHealth) + '/' + formatNumber(worldBossData.bossMaxHealth);
                
                const timeLeft = Math.max(0, Math.floor((worldBossData.bossEndTime - Date.now()) / 1000));
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                document.getElementById('bossTimeLeft').textContent = 
                    `剩余: ${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
                
                document.getElementById('bossSummonButton').disabled = true;
                document.getElementById('bossAttackButton').disabled = false;
                
                // 更新排行榜
                updateRankings();
            } else {
                document.getElementById('bossName').textContent = '未召唤BOSS';
                document.getElementById('bossWorld').textContent = '';
                document.getElementById('bossStars').textContent = '';
                document.getElementById('bossHealthFill').style.width = '0%';
                document.getElementById('bossHealthText').textContent = '0/0';
                document.getElementById('bossTimeLeft').textContent = '剩余: 未开始';
                
                document.getElementById('bossSummonButton').disabled = worldBossData.summonCount <= 0;
                document.getElementById('bossAttackButton').disabled = true;
                
                if (worldBossData.summonCount <= 0) {
                    document.getElementById('bossSummonButton').textContent = '无次数';
                } else {
                    document.getElementById('bossSummonButton').textContent = '召唤';
                }
            }
            
            // 更新自动攻击按钮
            document.getElementById('bossAutoAttackButton').textContent = 
                `自动: ${worldBossData.isAutoAttacking ? '开' : '关'}`;
        }

        // 召唤BOSS
        function summonBoss() {
           // 检查转生次数是否达到50次
    if (player.reincarnationCount < 50) {
        alert("需要达到50转才能召唤世界BOSS！");
        return;
    }
            if (worldBossData.summonCount <= 0) return;
            
            worldBossData.summonCount--;
            worldBossData.isBossActive = true;
            worldBossData.bossEndTime = Date.now() + 60 * 60 * 1000; // 60分钟
            worldBossData.playerDamage = 0;
            worldBossData.battleLog = [];
            
            // 随机生成BOSS属性
            worldBossData.bossName = bossNames[Math.floor(Math.random() * bossNames.length)];
            worldBossData.bossWorld = worldNames[Math.floor(Math.random() * worldNames.length)];
            worldBossData.bossStars = Math.floor(Math.random() * 30) + 1; // 1-30星
            
            // BOSS生命值为玩家攻击力的100000万-1000000万倍
            const healthMultiplier = 10000000000000000000 + Math.random() * 99000000000000000000000000;
            worldBossData.bossMaxHealth = Math.floor(player.battle.playerAttack * healthMultiplier * player.battle.playerCritDamage);
            worldBossData.bossHealth = worldBossData.bossMaxHealth;
           // 保存玩家属性快照
    player.bossBattleSnapshot = {
        playerAttack: player.battle.playerAttack,
        playerMultiAttack: player.battle.playerMultiAttack,
        playerCritRate: player.battle.playerCritRate,
        playerCritDamage: player.battle.playerCritDamage
    };                   
            // 生成虚拟玩家
            generateVirtualPlayers();
            
            // 开始虚拟玩家攻击
            startVirtualPlayerAttacks();
            
            // 更新UI
            updateBossUI();
            
            // 保存数据
            saveWorldBossData();
            
            // 添加战斗日志
            addBossBattleLog(`召唤了 ${worldBossData.bossName} [${worldBossData.bossWorld}] (${worldBossData.bossStars}★)`);
            
            // 设置BOSS结束检查
            setTimeout(checkBossEnd, 1000);
        }

        // 生成虚拟玩家
        function generateVirtualPlayers() {
            worldBossData.virtualPlayers = [];
            
            for (let i = 0; i < 60; i++) {
                const name = virtualPlayerNames[i] || `玩家${i+1}`;
                const attackMultiplier = 0.2 + Math.random() * 30; 
                const attack = Math.floor(player.battle.playerAttack * attackMultiplier);
                const multiAttack = Math.max(1, 
                    Math.floor(player.battle.playerMultiAttack * (0.3 + Math.random() * 1.5))); 
                const critRate = 0.5 + Math.random() * 1.9; 
                const critDamage = player.battle.playerCritDamage * (0.3 + Math.random() * 1.5);
                
                worldBossData.virtualPlayers.push({
                    name: name,
                    attack: attack,
                    multiAttack: multiAttack,
                    critRate: critRate,
                    critDamage: critDamage,
                    damage: 0
                });
            } 
      }
      // 修改离线虚拟玩家伤害计算逻辑（替换原有的平均分配部分）
function calculateOfflineVirtualDamage() {
    const now = Date.now();
    const timePassed = now - worldBossData.lastVirtualAttackTime;
    const secondsPassed = Math.floor(timePassed / 1000);
    if (secondsPassed <= 0) return;

    // 为每个虚拟玩家单独计算离线伤害（基于其自身属性）
    worldBossData.virtualPlayers.forEach(player => {
        // 计算该玩家的每秒平均伤害（考虑连击和爆伤）
        const avgDps = player.attack * player.multiAttack * 
                      (3 + (player.critRate * (player.critDamage - 1)));
        // 计算离线总伤害
        const playerDamage = Math.floor(avgDps * secondsPassed);
        // 应用伤害
        worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - playerDamage);
        player.damage += playerDamage;
    });

    // 更新最后攻击时间
    worldBossData.lastVirtualAttackTime = now;

    // 记录总离线伤害
    const totalDamage = worldBossData.virtualPlayers.reduce((sum, p) => sum + p.damageAdded, 0);
    addBossBattleLog(`离线期间虚拟玩家共造成 ${formatNumber(totalDamage)} 点伤害`);

    // 检查BOSS是否被击败
    if (worldBossData.bossHealth <= 0) {
        endBossFight(true);
    }
            
            // 更新排行榜
            updateRankings();
            
            // 保存数据
            saveWorldBossData();
        }
// 开始虚拟玩家攻击
        function startVirtualPlayerAttacks() {
            // 清除之前的攻击间隔
            if (worldBossData.virtualAttackInterval) {
                clearInterval(worldBossData.virtualAttackInterval);
            }
            
            // 设置新的攻击间隔 (每秒攻击一次)
            worldBossData.virtualAttackInterval = registerInterval(() => {
                if (!worldBossData.isBossActive) {
                    clearInterval(worldBossData.virtualAttackInterval);
                    return;
                }
                
                // 所有虚拟玩家攻击
                worldBossData.virtualPlayers.forEach(player => {
                    const result = calculatePlayerDamage(player);
                    worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - result.total);
                    player.damage += result.total;
                    
                    // 每10次攻击记录一次（显示爆伤）
                    if (Math.random() < 0.1) {
                        let logMessage = `${player.name} 造成 ${formatNumber(result.total)} 伤害 - `;
                        logMessage += `普通: ${formatNumber(result.normalDamage)}, `;
                        logMessage += `暴击x${result.critCount}: ${formatNumber(result.critDamage)}`;
                        addBossBattleLog(logMessage);
                    }
                });
                
                // 更新UI
                updateRankings();
                updateBossUI();
                
                // 检查BOSS是否被击败
                if (worldBossData.bossHealth <= 0) {
                    endBossFight(true);
                }
            }, 1000);
        }

        // 计算玩家伤害
        function calculatePlayerDamage(playerData) {
            let totalDamage = 0;
            let critCount = 0;
            let critDamageTotal = 0;
            let normalDamageTotal = 0;
            
            for (let i = 0; i < playerData.multiAttack; i++) {
                const isCrit = Math.random() < playerData.critRate;
                let damage = playerData.attack;
                
                if (isCrit) {
                    damage *= playerData.critDamage;
                    critCount++;
                    critDamageTotal += damage;
                } else {
                    normalDamageTotal += damage;
                }
                
                totalDamage += damage;
            }
            
            return {
                total: Math.floor(totalDamage),
                critCount: critCount,
                critDamage: Math.floor(critDamageTotal),
                normalDamage: Math.floor(normalDamageTotal)
            };
        }

        // 攻击BOSS（修改为显示爆伤信息）
        function attackBoss() {
            if (!worldBossData.isBossActive) return;
            
    // 使用保存的属性快照而不是实时属性
    const result = calculatePlayerDamage({
        attack: player.bossBattleSnapshot.playerAttack,
        multiAttack: player.bossBattleSnapshot.playerMultiAttack,
        critRate: player.bossBattleSnapshot.playerCritRate,
        critDamage: player.bossBattleSnapshot.playerCritDamage
    });
    
            
            worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - result.total);
            worldBossData.playerDamage += result.total;
            
            // 添加战斗日志（显示爆伤详情）
            let logMessage = `你造成了 ${formatNumber(result.total)} 点伤害 (${player.battle.playerMultiAttack}连击) - `;
            logMessage += `普通伤害: ${formatNumber(result.normalDamage)}, `;
            logMessage += `暴击x${result.critCount}: ${formatNumber(result.critDamage)}`;
            
            addBossBattleLog(logMessage);
            
            // 更新UI
            updateRankings();
            updateBossUI();

           // 新增：保存攻击后的BOSS数据
    saveWorldBossData();
            
            // 检查BOSS是否被击败
            if (worldBossData.bossHealth <= 0) {
                endBossFight(true);
            }
        }

        // 切换自动攻击
        function toggleAutoAttackBoss() {
            worldBossData.isAutoAttacking = !worldBossData.isAutoAttacking;
            
            if (worldBossData.isAutoAttacking) {
                // 启动自动攻击（即使界面关闭也会继续）
                startAutoAttack();
            } else {
                stopAutoAttack();
            }
            
            updateBossUI();
        }

        // 新增专用函数处理自动攻击
function startAutoAttack() {
    // 先停止现有的自动攻击
    stopAutoAttack();
    
    // 每秒攻击20次
    worldBossData.attackInterval = registerInterval(() => {
        if (worldBossData.isBossActive && worldBossData.isAutoAttacking) {
            for (let i = 0; i < 20; i++) {
                // 使用属性快照攻击
                const result = calculatePlayerDamage({
                    attack: player.bossBattleSnapshot.playerAttack,
                    multiAttack: player.bossBattleSnapshot.playerMultiAttack,
                    critRate: player.bossBattleSnapshot.playerCritRate,
                    critDamage: player.bossBattleSnapshot.playerCritDamage
                });
                
                worldBossData.bossHealth = Math.max(0, worldBossData.bossHealth - result.total);
                worldBossData.playerDamage += result.total;
                
                // 检查BOSS是否被击败
                if (worldBossData.bossHealth <= 0) {
                    endBossFight(true);
                    break;
                }
            }
        }
    }, 1000);
}

        function stopAutoAttack() {
            clearInterval(worldBossData.attackInterval);
        }

        // 更新排行榜
function updateRankings() {
    // 合并真实玩家和虚拟玩家
    const allPlayers = [
        {
            name: "你",
            damage: worldBossData.playerDamage
        },
        ...worldBossData.virtualPlayers.map(p => ({
            name: p.name,
            damage: p.damage
        }))
    ];
    
    // 按伤害排序
    allPlayers.sort((a, b) => b.damage - a.damage);
    worldBossData.rankings = allPlayers;
    
    // 更新玩家排名
    const playerRank = allPlayers.findIndex(p => p.name === "你") + 1;
    document.getElementById('playerBossRank').textContent = playerRank ? 
        `${playerRank} / ${allPlayers.length}` : "未排名";
    
    // 更新UI
    const rankingsContainer = document.getElementById('bossRankings');
    rankingsContainer.innerHTML = '';
    
    allPlayers.slice(0, 10).forEach((player, index) => {
        const div = document.createElement('div');
        div.className = 'boss-ranking-item';
        div.innerHTML = `
            <span>${index + 1}. ${player.name}</span>
            <span>${formatNumber(player.damage)}</span>
        `;
        rankingsContainer.appendChild(div);
    });
    
    if (allPlayers.length === 0) {
        rankingsContainer.innerHTML = '<div>尚未开始战斗</div>';
    }
}

        // 添加战斗日志
        function addBossBattleLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            worldBossData.battleLog.unshift(logEntry);
            if (worldBossData.battleLog.length > 15) { // 减少日志数量
                worldBossData.battleLog.pop();
            }
            
            // 更新UI
            const logContainer = document.getElementById('bossBattleLog');
            logContainer.innerHTML = worldBossData.battleLog.map(log => 
                `<div class="boss-battle-log-entry">${log}</div>`
            ).join('');
        }

        // 检查BOSS是否结束
        function checkBossEnd() {
            if (!worldBossData.isBossActive) return;
            
            if (Date.now() >= worldBossData.bossEndTime) {
                endBossFight(false);
            } else {
                setTimeout(checkBossEnd, 1000);
                updateBossUI();
            }
        }

        // 结束BOSS战斗
        function endBossFight(isDefeated) {
            worldBossData.isBossActive = false;
            clearInterval(worldBossData.virtualAttackInterval);
            
            // 停止自动攻击
            if (worldBossData.isAutoAttacking) {
                worldBossData.isAutoAttacking = false;
                stopAutoAttack();
            }
             player.bossBattleSnapshot = null;
            // 发放奖励
            distributeRewards();
            
            // 添加战斗日志
            if (isDefeated) {
                addBossBattleLog(`BOSS ${worldBossData.bossName} 已被击败！`);
            } else {
                addBossBattleLog(`BOSS ${worldBossData.bossName} 时间结束！`);
            }
            
            // 保存数据
            saveWorldBossData();
            
            // 更新UI
            updateBossUI();
            
            // 记录开奖结果
            recordBossResult();
        }

        // 分发奖励
        function distributeRewards() {
            const playerRank = worldBossData.rankings.findIndex(p => p.name === "你") + 1;
            
            if (playerRank === 1) {
        // 第一名
        player.items.divineGem += 5;
        player.reincarnationCoin += 30000;
        addBossBattleLog("你获得了第1名奖励: 5个神级宝石 + 30000转生币");
        
        // 解锁成就
        if (!player.achievements.world_boss_1st) {
            player.achievements.world_boss_1st = true;
            player.gpsMultiplier += achievementRewards.world_boss_1st.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_1st.description}，GPS奖励 +${achievementRewards.world_boss_1st.gpsMultiplier * 100}%`, 'success');
        }
    } else if (playerRank >= 2 && playerRank <= 10) {
        // 第2-10名
        player.items.superiorGem += 5;
        player.reincarnationCoin += 10000;
        addBossBattleLog(`你获得了第${playerRank}名奖励: 5个极品宝石 + 10000转生币`);
        
        // 解锁成就
        if (!player.achievements.world_boss_top5) {
            player.achievements.world_boss_top5 = true;
            player.gpsMultiplier += achievementRewards.world_boss_top5.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_top5.description}，GPS奖励 +${achievementRewards.world_boss_top5.gpsMultiplier * 100}%`, 'success');
        }
    } else if (playerRank >= 11 && playerRank <= 30) {
        // 第11-30名
        player.items.advancedGem += 3;
        player.reincarnationCoin += 5000;
        addBossBattleLog(`你获得了第${playerRank}名奖励: 3个高级宝石 + 5000转生币`);
        
        // 解锁成就
        if (!player.achievements.world_boss_top10) {
            player.achievements.world_boss_top10 = true;
            player.gpsMultiplier += achievementRewards.world_boss_top10.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_top10.description}，GPS奖励 +${achievementRewards.world_boss_top10.gpsMultiplier * 100}%`, 'success');
        }
    } else {
        // 参与奖
        player.items.primaryGem += 1;
        player.reincarnationCoin += 100;
        addBossBattleLog("你获得了参与奖: 1个初级宝石 + 100转生币");
        
        // 解锁成就
        if (!player.achievements.world_boss_participant) {
            player.achievements.world_boss_participant = true;
            player.gpsMultiplier += achievementRewards.world_boss_participant.gpsMultiplier;
            logAction(`成就达成：${achievementRewards.world_boss_participant.description}，GPS奖励 +${achievementRewards.world_boss_participant.gpsMultiplier * 100}%`, 'success');
        }
    }
    
    // 更新显示
    updateDisplay();
    updateAchievementsDisplay();
}

        // 记录开奖结果
        function recordBossResult() {
            const top3 = worldBossData.rankings.slice(0, 3).map(p => p.name).join(", ");
            const result = `世界BOSS ${worldBossData.bossName} 结束，前三名: ${top3}`;
            
            player.lotteryResults.unshift({
                time: new Date().toLocaleString(),
                result: result
            });
            
            if (player.lotteryResults.length > 5) {
                player.lotteryResults.pop();
            }
            
            // 更新彩票结果显示
            updateLotteryResultsDisplay();
        }

       // 格式化数字显示
        function formatNumber(value) {
            if (value >= 1e8) {
                return value.toExponential(3);
            } else {
                return value.toLocaleString();
            }
        }

        // 在游戏加载时初始化世界BOSS系统
        loadWorldBossData();
        updateOfficialSystemDisplay();
        updatePlayerClassNameDisplay();
     updateCompanionDisplay();
       updateItemDisplay();
 updateMysterySystemDisplay();
updateItemDisplay();
updateTraditionalLotteryDisplay();
if (typeof updateTotalBonuses === 'function') updateTotalBonuses();
</script>
<!--客服 开始-->
<script src="//g8hh.github.io/static/js/jquery.min.js"></script>
<link rel="stylesheet" href="//g8hh.github.io/static/css/kf.css" type="text/css" media="screen" charset="utf-8">
<script src="//g8hh.github.io/static/js/kf.js"></script>
<!-- 客服 结束 -->
<!--站长统计-->
    <div style="display: none">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?828597e93cee632465679b7ef35edfd5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>    </div>

</body>
</html>